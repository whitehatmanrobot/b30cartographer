eLoginsAllowed(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_GraceLoginsRemaining(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_IsAccountLocked(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_IsAdmin(
                 hConn,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_MaxLogins(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_CanPasswordExpire(
                 hConn,
                 LoginCtrlStruct,
                 fExplicit
                 );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_PasswordExpirationDate(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_PasswordMinimumLength(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_PasswordRequired(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_RequireUniquePassword(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        //
        // Get AccountStatistics functional set.
        //

        hr = GetProperty_BadLoginAddress(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);

        hr = GetProperty_LastLogin(
                  hConn,
                  LoginCtrlStruct,
                  fExplicit
                  );
        BAIL_ON_FAILURE(hr);
    }

    // 
    // if NWApiGetLOGIN_CONTROL failed, it's okay, we just ignore
    // it and don't load those properties into the cache
    //
    hr = S_OK;

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::ImplicitGetInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::ImplicitGetInfo(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    if (dwPropertyID < 100) {
        hr = GetBusinessInfo(
                 hConn,
                 dwPropertyID,
                 fExplicit
                 );
    }
    else if (dwPropertyID < 200) {
        hr = GetAccountRestrictions(
                 hConn,
                 dwPropertyID,
                 fExplicit
                 );
    }
    else if (dwPropertyID < 300) {
        hr = GetAccountStatistics(
                 hConn,
                 dwPropertyID,
                 fExplicit
                 );
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetBusinessInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetBusinessInfo(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;

    switch (dwPropertyID) {

    case USER_FULLNAME_ID:
         hr = GetProperty_FullName(
                  hConn,
                  fExplicit
                  );
         break;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetAccountRestrictions
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetAccountRestrictions(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LC_STRUCTURE LoginCtrlStruct;

    //
    // Get LOGIN_CONTROL.
    //

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrlStruct
             );
    if (SUCCEEDED(hr)) {

        //
        // Get property.
        //

        switch (dwPropertyID) {

        case USER_ACCOUNTDISABLED_ID:
             hr = GetProperty_AccountDisabled(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_ACCOUNTEXPIRATIONDATE_ID:
             hr = GetProperty_AccountExpirationDate(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_CANACCOUNTEXPIRE_ID:
             hr = GetProperty_CanAccountExpire(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_GRACELOGINSALLOWED_ID:
             hr = GetProperty_GraceLoginsAllowed(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
                      break;

        case USER_GRACELOGINSREMAINING_ID:
             hr = GetProperty_GraceLoginsRemaining(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_ISACCOUNTLOCKED_ID:
             hr = GetProperty_IsAccountLocked(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_ISADMIN_ID:
             hr = GetProperty_IsAdmin(
                      hConn,
                      fExplicit
                      );
             break;

        case USER_MAXLOGINS_ID:
             hr = GetProperty_MaxLogins(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_CANPASSWORDEXPIRE_ID:
             hr = GetProperty_CanPasswordExpire(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_PASSWORDEXPIRATIONDATE_ID:
             hr = GetProperty_PasswordExpirationDate(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_PASSWORDMINIMUMLENGTH_ID:
             hr = GetProperty_PasswordMinimumLength(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_PASSWORDREQUIRED_ID:
             hr = GetProperty_PasswordRequired(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_REQUIREUNIQUEPASSWORD_ID:
             hr = GetProperty_RequireUniquePassword(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

         case USER_LOGINHOURS_ID:
             hr = GetProperty_LoginHours(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        }

        BAIL_ON_FAILURE(hr);
    }

    // 
    // if NWApiGetLOGIN_CONTROL failed, it's okay, we just ignore
    // it and don't load those properties into the cache
    //
    hr = S_OK;

error:

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetAccountStatistics
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetAccountStatistics(
    NWCONN_HANDLE hConn,
    DWORD dwPropertyID,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LC_STRUCTURE LoginCtrlStruct;

    //
    // Get LOGIN_CONTROL.
    //

    hr = NWApiGetLOGIN_CONTROL(
             hConn,
             _Name,
             &LoginCtrlStruct
             );

    if (SUCCEEDED(hr)) {

        //
        // Get property.
        //

        switch (dwPropertyID) {

        case USER_BADLOGINADDRESS_ID:
             hr = GetProperty_BadLoginAddress(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;

        case USER_LASTLOGIN_ID:
             hr = GetProperty_LastLogin(
                      hConn,
                      LoginCtrlStruct,
                      fExplicit
                      );
             break;
        }

        BAIL_ON_FAILURE(hr);
    }

    // 
    // if NWApiGetLOGIN_CONTROL failed, it's okay, we just ignore
    // it and don't load those properties into the cache
    //
    hr = S_OK;

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_FullName
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_FullName(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    LPWSTR           lpszFullName = NULL;
    CHAR             szFullName[MAX_FULLNAME_LEN + 1];
    DWORD            dwNumSegment = 0;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL; // Used by DELETE_LIST macro below

    //
    // Get IDENTIFICATIOIN.  This property contains the full name of an object.
    //

    hr = NWApiGetProperty(
             _Name,
             NW_PROP_IDENTIFICATION,
             OT_USER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );

    //
    // This call will fail for those users who has never set
    // their Fullname, ie. "IDENTIFICATION" is not created. Per Raid #34833
    // (resolved By Design), there is no way to distinguish a failure for
    // the property not existing from a general failure --- they both return the
    // same error code.  In general, it is expected that a Bindery user will have
    // the IDENTIFICATION property, so if this call fails we assume it was because
    // the property didn't exist.  In this case, we return success, since it was
    // successful, there just didn't happen to be an IDENTIFICATION.
    //
    if (FAILED(hr)) {
	hr = S_OK;
	goto error;
    }

    //
    // Convert result into a UNICODE string.
    //

    strcpy(szFullName, lpReplySegment->Segment);

    lpszFullName = (LPWSTR) AllocADsMem(
                                (strlen(szFullName)+1) * sizeof(WCHAR)
                                );
    if (!lpszFullName)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    AnsiToUnicodeString(
        szFullName,
        lpszFullName,
        0
        );

    //
    // Unmarshall.
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("FullName"),
                (LPWSTR)lpszFullName,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);

error:

    if (lpszFullName) {

        FreeADsMem(lpszFullName);
    }
    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }



    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_AccountDisabled
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_AccountDisabled(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Put value into a variant.
    //

    dwBool = (BOOL) LoginCtrlStruct.byAccountDisabled;

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("AccountDisabled"),
             dwBool,
             fExplicit
             );


    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_AccountExpirationDate
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_AccountExpirationDate(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    BYTE byDateTime[6];
    BYTE byNoDateTime[6];

    memset(byNoDateTime, 0, 6);
    memset(byDateTime, 0, 6);
    memcpy(byDateTime, LoginCtrlStruct.byAccountExpires, 3);

    //
    // LoginCtrlSturct.byAccountExpires == 000 indicates no expired date
    //
    if (memcmp(byDateTime, byNoDateTime, 3)!=0) {

        hr = SetNw312DATEPropertyInCache(
                    _pPropertyCache,
                    TEXT("AccountExpirationDate"),
                    byDateTime,
                    fExplicit
                    );

        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_CanAccountExpire
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_CanAccountExpire(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Account cannot expire if there is no expiration date.
    //

    if ((LoginCtrlStruct.byAccountExpires[0] == 0) &&
        (LoginCtrlStruct.byAccountExpires[1] == 0) &&
        (LoginCtrlStruct.byAccountExpires[2] == 0)) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
            _pPropertyCache,
            TEXT("AccountCanExpire"),
            dwBool,
            fExplicit
            );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_GraceLoginsAllowed
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_GraceLoginsAllowed(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lGraceLoginsAllowed = 0;

    //
    // Get "byGraceLoginReset".  The property is not meaningful when it equals
    // to 0xff.
    //

    if (LoginCtrlStruct.byGraceLoginReset != 0xff) {

        lGraceLoginsAllowed = (LONG) LoginCtrlStruct.byGraceLoginReset;
    }

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("GraceLoginsAllowed"),
             (DWORD)lGraceLoginsAllowed,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_GraceLoginsRemaining
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_GraceLoginsRemaining(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lGraceLoginsRemaining = 0;

    //
    // Get "byGraceLogins".  The property is not meaningful when it equals to
    // 0xff.
    //

    if (LoginCtrlStruct.byGraceLogins != 0xff) {

        lGraceLoginsRemaining = (LONG) LoginCtrlStruct.byGraceLogins;
    }

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("GraceLoginsRemaining"),
             (DWORD)lGraceLoginsRemaining,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_IsAccountLocked
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_IsAccountLocked(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = FALSE;
    HRESULT      hr = S_OK;

    //
    // Account is locked when wBadLogins = 0xffff.
    //

    if (LoginCtrlStruct.wBadLogins == 0xffff) {

        dwBool = TRUE;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("IsAccountLocked"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_IsAdmin
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_IsAdmin(
    NWCONN_HANDLE hConn,
    BOOL fExplicit
    )
{
    BOOL    dwBool = TRUE;
    HRESULT hr = S_OK;

    //
    // Check if this user has the same security as the supervisor.  If it does,
    // then it is an admin.
    //

    hr = NWApiIsObjectInSet(
             hConn,
             _Name,
             OT_USER,
             NW_PROP_SECURITY_EQUALS,
             NW_PROP_SUPERVISOR,
             OT_USER
             );

    // Per bug #33322 (resolved By Design), there is no way to distinguish
    // "no such object" from a general failure.  So we assume that any failure
    // is "no such object".

    if (FAILED(hr)) {
        dwBool = FALSE;
        hr = S_OK;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("IsAdmin"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_MaxLogins
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_MaxLogins(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lMaxLogins = 0;

    //
    // Get "wMaxConnections".
    //

    lMaxLogins = (LONG) NWApiReverseWORD(
                            LoginCtrlStruct.wMaxConnections
                            );

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("MaxLogins"),
             (DWORD)lMaxLogins,
             fExplicit
             );


    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_CanPasswordExpire
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_CanPasswordExpire(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Password cannot expire if there is no expiration date.
    //

    if ((LoginCtrlStruct.byPasswordExpires[0] == 0) &&
        (LoginCtrlStruct.byPasswordExpires[1] == 0) &&
        (LoginCtrlStruct.byPasswordExpires[2] == 0)) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //
    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("PasswordCanExpire"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_PasswordExpirationDate
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_PasswordExpirationDate(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    BYTE byDateTime[6];

    memset(byDateTime, 0, 6);
    memcpy(byDateTime, LoginCtrlStruct.byPasswordExpires, 3);

    hr = SetNw312DATEPropertyInCache(
                _pPropertyCache,
                TEXT("PasswordExpirationDate"),
                byDateTime,
                fExplicit
                );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_PasswordMinimumLength
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_PasswordMinimumLength(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT      hr = S_OK;
    LONG         lMinimumLength = 0;

    //
    // Get "byMinPasswordLength".
    //

    lMinimumLength = (LONG) LoginCtrlStruct.byMinPasswordLength;

    //
    // Unmarshall.
    //

    hr = SetDWORDPropertyInCache(
             _pPropertyCache,
             TEXT("PasswordMinimumLength"),
             (DWORD)lMinimumLength,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_PasswordRequired
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_PasswordRequired(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Password is not required if "byMinPasswordLength" is 0.
    //

    if (LoginCtrlStruct.byMinPasswordLength == 0) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //

    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("PasswordRequired"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_RequireUniquePassword
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_RequireUniquePassword(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // If byRestrictions = 0, "RequireUniquePassword" = FALSE.
    //

    if (LoginCtrlStruct.byRestrictions == 0) {

        dwBool = FALSE;
    }

    //
    // Unmarshall.
    //
    hr = SetBOOLPropertyInCache(
             _pPropertyCache,
             TEXT("RequireUniquePassword"),
             dwBool,
             fExplicit
             );

    RRETURN(hr);
}

HRESULT
CNWCOMPATUser::GetProperty_LoginHours(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    BOOL         dwBool = TRUE;
    HRESULT      hr = S_OK;

    //
    // Unmarshall.
    //
    hr = SetOctetPropertyInCache(
             _pPropertyCache,
             TEXT("LoginHours"),
             (BYTE*)LoginCtrlStruct.byLoginTimes,
             24,
             fExplicit
             );

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_BadLoginAddress
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_BadLoginAddress(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    LPWSTR  lpszTemp = NULL;

    //
    // Put address together in the format described in spec.
    //

    lpszTemp = (LPWSTR) AllocADsMem((NET_ADDRESS_NUM_CHAR+1)*sizeof(WCHAR));
    if (!lpszTemp) {
        RRETURN(E_OUTOFMEMORY);
    }

    wsprintf(
        lpszTemp,
        L"%s:%02X%02X%02X%02X.%02X%02X%02X%02X%02X%02X.%02X%02X",
        bstrAddressTypeString,
        LoginCtrlStruct.byBadLoginAddr[10],
        LoginCtrlStruct.byBadLoginAddr[11],
        LoginCtrlStruct.byBadLoginAddr[0],
        LoginCtrlStruct.byBadLoginAddr[1],
        LoginCtrlStruct.byBadLoginAddr[2],
        LoginCtrlStruct.byBadLoginAddr[3],
        LoginCtrlStruct.byBadLoginAddr[4],
        LoginCtrlStruct.byBadLoginAddr[5],
        LoginCtrlStruct.byBadLoginAddr[6],
        LoginCtrlStruct.byBadLoginAddr[7],
        LoginCtrlStruct.byBadLoginAddr[8],
        LoginCtrlStruct.byBadLoginAddr[9]
        );

    //
    // Unmarshall.
    //

    hr = SetLPTSTRPropertyInCache(
                _pPropertyCache,
                TEXT("BadLoginAddress"),
                (LPWSTR)lpszTemp,
                fExplicit
                );
    BAIL_ON_FAILURE(hr);

error:

    if (lpszTemp) {

        FreeADsMem(lpszTemp);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: CNWCOMPATUser::GetProperty_LastLogin
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUser::GetProperty_LastLogin(
    NWCONN_HANDLE hConn,
    LC_STRUCTURE LoginCtrlStruct,
    BOOL fExplicit
    )
{

    HRESULT hr = S_OK;
    BYTE byNoDateTime[6];

    memset(byNoDateTime, 0, 6);

    //
    // LastLogin==000000 indicates no or unknown LastLogin
    //
    if (memcmp(LoginCtrlStruct.byLastLogin, byNoDateTime, 6) != 0)  {

        hr =  SetNw312DATEPropertyInCache(
                _pPropertyCache,
                TEXT("LastLogin"),
                LoginCtrlStruct.byLastLogin,
                fExplicit
                );
    }

    RRETURN(hr);
}



HRESULT
ConvertNW312DateToVariant(
    BYTE byDateTime[],
    PDATE pDate
    )
{
    HRESULT hr = S_OK;
    WORD wYear;

    //
    // Subtract 80 from wYear for NWApiMakeVariantTime.
    //

    wYear = (WORD)byDateTime[0];

    if (wYear != 0) {
        wYear -= 80;
    }

    //
    // Convert into Variant Time.
    //

    hr = NWApiMakeVariantTime(
                pDate,
                (WORD)byDateTime[2],
                (WORD)byDateTime[1],
                wYear,
                0,0,0
                );
    RRETURN(hr);
}


HRESULT
ConvertVariantToNW312Date(
    DATE daDate,
    BYTE byDateTime[]
    )
{
    WORD wDay;
    WORD wYear;
    WORD wMonth;
    HRESULT hr = S_OK;

    hr = NWApiBreakVariantTime(
                daDate,
                &wDay,
                &wMonth,
                &wYear
                );
    BAIL_ON_FAILURE(hr);

    byDateTime[0] = (BYTE)wYear;
    byDateTime[1] = (BYTE)wMonth;
    byDateTime[2] = (BYTE)wDay;

    byDateTime[3] = 0;
    byDateTime[4] = 0;
    byDateTime[5] = 0;

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cuoi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cuoi.cxx
//
//  Contents:  User Object Other Information FunctionalSet
//
//  History:   Feb-14-96     t-ptam    Created.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATUser
//


STDMETHODIMP CNWCOMPATUser::get_EmailAddress(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_EmailAddress(THIS_ BSTR bstrEmailAddress)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_HomeDirectory(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_HomeDirectory(THIS_ BSTR bstrHomeDirectory)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_Languages(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_Languages(THIS_ VARIANT vLanguages)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_Profile(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_Profile(THIS_ BSTR bstrProfile)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::get_LoginScript(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::put_LoginScript(THIS_ BSTR bstrLoginScript)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cubi.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cubi.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//              8-5-96     ramv        Modified to be consistent with spec
//
//
//      PROPERTY_RW(Address, VARIANT, 1)                NI
//      PROPERTY_RW(Department, BSTR, 3)                NI
//      PROPERTY_RW(Division, BSTR, 5)                  NI
//      PROPERTY_RW(EmployeeID, BSTR, 6)                NI
//      PROPERTY_RW(FirstName, BSTR, 8)                 Implemented
//      PROPERTY_RW(FullName, BSTR, 9)                  NI
//      PROPERTY_RW(Initials, BSTR, 10)                 NI
//      PROPERTY_RW(LastName, BSTR, 11)                 NI
//      PROPERTY_RW(Manager, BSTR, 12)                  NI
//      PROPERTY_RW(NickName, BSTR, 13)                 NI
//      PROPERTY_RW(OfficeLocation, BSTR, 14)           NI
//      PROPERTY_RW(Picture, VARIANT, 15)               NI
//      PROPERTY_RW(TelephoneNumber, BSTR, 18)          NI
//      PROPERTY_RW(Title, BSTR, 19)
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//  Class CNWCOMPATUser




/* IADsFSUserBusinessInformation methods */

STDMETHODIMP
CNWCOMPATUser::get_Department(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}


STDMETHODIMP
CNWCOMPATUser::put_Department(THIS_ BSTR bstrDepartment)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Description(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Description(THIS_ BSTR bstrDescription)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Division(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Division(THIS_ BSTR bstrDivision)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_EmployeeID(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_EmployeeID(THIS_ BSTR bstrEmployeeID)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_FirstName(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_FirstName(THIS_ BSTR bstrFirstName)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_FullName(THIS_ BSTR FAR* retval)
{
    GET_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNWCOMPATUser::put_FullName(THIS_ BSTR bstrFullName)
{
    PUT_PROPERTY_BSTR((IADsUser *)this, FullName);
}

STDMETHODIMP
CNWCOMPATUser::get_LastName(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_LastName(THIS_ BSTR bstrLastName)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Manager(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Manager(THIS_ BSTR bstrManager)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_OfficeLocations(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_OfficeLocations(THIS_ VARIANT vOfficeLocation)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Picture(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Picture(THIS_ VARIANT vPicture)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_PostalAddresses(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_PostalAddresses(THIS_ VARIANT vPostalAddresses)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_PostalCodes(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_PostalCodes(THIS_ VARIANT vPostalCodes)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephoneNumber(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephoneNumber(THIS_ VARIANT vTelephoneNumber)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephoneHome(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephoneHome(THIS_ VARIANT vTelephoneHome)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephoneMobile(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephoneMobile(THIS_ VARIANT vTelephoneMobile)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_TelephonePager(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_TelephonePager(THIS_ VARIANT vTelephonePager)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_FaxNumber(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_FaxNumber(THIS_ VARIANT vFaxNumber)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::get_Title(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CNWCOMPATUser::put_Title(THIS_ BSTR bstrTitle)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP CNWCOMPATUser::Groups(THIS_ IADsMembers FAR*  FAR * ppGroups)
{
    HRESULT hr = S_OK;

    hr = CNWCOMPATUserCollection::CreateUserCollection(
             _Parent,
             _ParentType,
             _ServerName,
             _Name,
             IID_IADsMembers,
             (void **)ppGroups
             );
    RRETURN_EXP_IF_ERR(hr);
}
STDMETHODIMP CNWCOMPATUser::get_HomePage(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_HomePage(THIS_ BSTR bstrHomePage)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::get_SeeAlso(THIS_ VARIANT FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_SeeAlso(THIS_ VARIANT vSeeAlso)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::get_NamePrefix(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_NamePrefix(THIS_ BSTR bstrNamePrefix)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::get_NameSuffix(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::put_NameSuffix(THIS_ BSTR bstrNamePrefix)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP CNWCOMPATUser::get_OtherName(THIS_ BSTR FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
STDMETHODIMP CNWCOMPATUser::put_OtherName(THIS_ BSTR bstrOtherName)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  getobj.cxx
//
//  Contents:  NetWare 3.12 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPWSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-Jan-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetObject(
    LPWSTR szBuffer,
    LPVOID * ppObject
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = Object(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    if (pObjectInfo->NumComponents >= 1) {

        hr = NWApiLoginToServer(pObjectInfo->ComponentArray[0],
                 NULL,
                 NULL) ;
        BAIL_ON_FAILURE(hr);
    }

    switch (pObjectInfo->ObjectType) {
    case TOKEN_COMPUTER:
        hr = GetComputerObject(pObjectInfo, ppObject);
        break;

    case TOKEN_USER:
        hr = GetUserObject(pObjectInfo, ppObject);
        break;

    case TOKEN_GROUP:
        hr = GetGroupObject(pObjectInfo, ppObject);
        break;

    case TOKEN_SCHEMA:
        hr = GetSchemaObject(pObjectInfo, ppObject);
        break;

    case TOKEN_CLASS:
        hr = GetClassObject(pObjectInfo, ppObject);
        break;

    case TOKEN_PROPERTY:
        hr = GetPropertyObject(pObjectInfo, ppObject);
        break;

    case TOKEN_SYNTAX:
        hr = GetSyntaxObject(pObjectInfo, ppObject);
        break;

    case TOKEN_FILESERVICE:
        hr = GetFileServiceObject(pObjectInfo, ppObject);
        break;

    case TOKEN_FILESHARE:
        hr = GetFileShareObject(pObjectInfo, ppObject);
        break;

    case TOKEN_PRINTER:
        hr = GetPrinterObject(pObjectInfo, ppObject);
        break;

    default:
        hr = HeuristicGetObject(pObjectInfo, ppObject);
        break;
    }

error:

    FreeObjectInfo( &ObjectInfo, TRUE );
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   HeuristicGetObject
//
// Synopsis:   Get object of yet undetermined type.
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPVOID *ppObject]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-Jan-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
HeuristicGetObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;

    //
    // Case 0: No componenet - Namespace object.
    //

    if (pObjectInfo->NumComponents == 0) {
        RRETURN(GetNamespaceObject(pObjectInfo, ppObject));
    }

    //
    // Case 1: Single component - Computer object.
    //

    if (pObjectInfo->NumComponents == 1) {

        RRETURN(GetComputerObject(pObjectInfo, ppObject));
    }

    //
    // Case 2: Two components - FileService object
    //                          Group object
    //                          Schema object
    //                          User object
    //                          Printer object
    //

    if (pObjectInfo->NumComponents == 2) {

        hr = GetSchemaObject(pObjectInfo, ppObject);

        if (FAILED(hr)) {

            hr = GetUserObject(pObjectInfo, ppObject);

            if (FAILED(hr)) {

                hr = GetGroupObject(pObjectInfo, ppObject);

                if (FAILED(hr)) {

                    hr = GetFileServiceObject(pObjectInfo, ppObject);

                    if (FAILED(hr)) {

                        hr = GetPrinterObject(pObjectInfo, ppObject);
                    }
                }
            }
        }

        if (FAILED(hr)) {
           hr = E_ADS_UNKNOWN_OBJECT;
        }
        else {
           RRETURN(S_OK);
        }
    }

    //
    // Case 3: Three components - FileShare object
    //                            Schema Class object
    //                            Schema FunctionSet object
    //                            Schema Syntax object
    //

    if (pObjectInfo->NumComponents == 3) {

        hr = GetFileShareObject(pObjectInfo, ppObject);

        if (FAILED(hr)) {

            if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) == 0 ){

                hr = GetClassObject(pObjectInfo, ppObject);

                if (FAILED(hr)) {
                    hr = GetPropertyObject(pObjectInfo, ppObject);
                }

                if (FAILED(hr)) {

                    hr = GetSyntaxObject(pObjectInfo, ppObject);
                }
            }
        }

        if (FAILED(hr)) {
           hr = E_ADS_UNKNOWN_OBJECT;
        }
        else {
           RRETURN(S_OK);
        }
    }

    //
    // Case 4: Four components - Schema FunctionSetAlias object
    //                           Schema Property object
    //

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetNamespaceObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    04-Mar-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ValidateNamespaceObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = CoCreateInstance(
             CLSID_NWCOMPATNamespace,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IUnknown,
             (void **)ppObject
             );

    RRETURN(hr);

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetComputerObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-Jan-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetComputerObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateComputerObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATComputer::CreateComputer(
             ADsParent,
             pObjectInfo->ComponentArray[0],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetUserObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    29-Feb-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetUserObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateUserObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATUser::CreateUser(
             ADsParent,
             NWCOMPAT_COMPUTER_ID,
             pObjectInfo->ComponentArray[0],
             pObjectInfo->ComponentArray[1],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetGroupObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    29-Feb-96   t-ptam     Created.
//
//----------------------------------------------------------------------------

HRESULT
GetGroupObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateGroupObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATGroup::CreateGroup(
             ADsParent,
             NWCOMPAT_COMPUTER_ID,
             pObjectInfo->ComponentArray[0],
             pObjectInfo->ComponentArray[1],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetSchemaObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 2)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATSchema::CreateSchema(
             ADsParent,
             pObjectInfo->ComponentArray[1],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetClassObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetClassObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD i;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given class name
    //

    for ( i = 0; i < g_cNWCOMPATClasses; i++ )
    {
         if ( _wcsicmp( g_aNWCOMPATClasses[i].bstrName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( i == g_cNWCOMPATClasses )
    {
        //
        // Class name not found, return error
        //

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Class name found, create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATClass::CreateClass(
             ADsParent,
             &g_aNWCOMPATClasses[i],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetSyntaxObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetSyntaxObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD i;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cNWCOMPATSyntax; i++ )
    {
         if ( _wcsicmp( g_aNWCOMPATSyntax[i].bstrName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( i == g_cNWCOMPATSyntax )
    {
        //
        // Syntax name not found, return error
        //

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Syntax name found, create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATSyntax::CreateSyntax(
             ADsParent,
             &g_aNWCOMPATSyntax[i],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetPropertyObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    1-17-96   yihsins     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetPropertyObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_ADS_PATH];
    WCHAR ADsGrandParent[MAX_ADS_PATH];
    HRESULT hr = S_OK;
    DWORD nClass, nProp;

    if (pObjectInfo->NumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjectInfo->ComponentArray[1], SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We found the specified functional set, now see if we can locate
    // the given property name
    //

    for ( nProp = 0; nProp < g_cNWCOMPATProperties; nProp++ )
    {
         if ( _wcsicmp(g_aNWCOMPATProperties[nProp].szPropertyName,
                        pObjectInfo->ComponentArray[2] ) == 0 )
             break;
    }

    if ( nProp == g_cNWCOMPATProperties )
    {
        // Return error because the given property name is not found

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Property name is found, so create and return the object
    //

    hr = BuildParent(pObjectInfo, ADsParent);
    BAIL_ON_FAILURE(hr);

    hr = BuildGrandParent(pObjectInfo, ADsGrandParent);
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATProperty::CreateProperty(
             ADsParent,
             &(g_aNWCOMPATProperties[nProp]),
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetFileServiceObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    22-Apr-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetFileServiceObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateFileServiceObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATFileService::CreateFileService(
             ADsParent,
             pObjectInfo->ComponentArray[0],
             pObjectInfo->ComponentArray[1],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetFileShareObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    22-Apr-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetFileShareObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidateFileShareObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATFileShare::CreateFileShare(
             ADsParent,
             pObjectInfo->ComponentArray[2],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetPrinterObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//             LPVOID * ppObject
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    2-May-96   t-ptam     Created.
//
//----------------------------------------------------------------------------
HRESULT
GetPrinterObject(
    POBJECTINFO pObjectInfo,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    WCHAR ADsParent[MAX_ADS_PATH];

    hr = ValidatePrinterObject(
             pObjectInfo
             );
    BAIL_ON_FAILURE(hr);

    hr = BuildParent(
             pObjectInfo,
             ADsParent
             );
    BAIL_ON_FAILURE(hr);

    hr = CNWCOMPATPrintQueue::CreatePrintQueue(
             ADsParent,
             pObjectInfo->ComponentArray[1],
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             ppObject
             );
error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateNamespaceObject
//
// Synopsis:
//
// Arguments:  POBJECTINFO pObjectInfo
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    16-Jan-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{

    if (!_wcsicmp(pObjectInfo->ProviderName, bstrProviderName)) {
    }
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   ValidateComputerObject
//
// Synopsis:   Validate the existence of a computer object by obtaining
//             a handle to it.  A computer object must exist if a handle
//             to it can be obtained.
//
// Arguments:  [LPWSTR szComputerName]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    16-Jan-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------

HRESULT
ValidateComputerObject(
     POBJECTINFO pObjectInfo
     )
{
    //
    // A handle of a certain bindery can only be obtained if the bindery
    // exist.  Therefore we used this fact to validate the existence of
    // a computer object.
    //

    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 1) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Try to obtain a handle to a NWCOMPAT Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Detach handle.
    //

    hr = NWApiReleaseBinderyHandle(
             hConn
             );

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateUserObject
//
// Synopsis:   Validate the existence of a computer object by obtaining
//             a handle to it.  A computer object must exist if a handle
//             to it can be obtained.
//
// Arguments:  [LPWSTR szComputerName]
//
// Returns:    HRESULT
//
// Modifies:   pObjectInfo->ComponentArray[1] is upper-cased
//
// History:    29-Feb-96   t-ptam (Patrick)     Created.
//             29-Jul-96   t-danal              Uppercase fix.
//
// Note:       Netware will let you create a lowercase user name but will
//             internally store only uppercase.  However, it will not
//             return the uppercase user name on a lowercase request.
//
//----------------------------------------------------------------------------

HRESULT
ValidateUserObject(
     POBJECTINFO pObjectInfo
     )
{
    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;
    DWORD dwResumeObjectID = 0xffffffff;

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Obtain a handle to a NetWare Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get the specified (uppercased) user object.
    //

    hr = NWApiValidateObject(
             hConn,
             OT_USER,
             _wcsupr(pObjectInfo->ComponentArray[1]),
             &dwResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateGroupObject
//
// Synopsis:   Validate the existence of a group object by scanning
//             for it in the bindery.
//
// Arguments:  [POBJECTINFO pObjectInfo]
//
// Returns:    HRESULT
//
// Modifies:   pObjectInfo->ComponentArray[1] is upper-cased
//
// History:    29-Feb-96   t-ptam (Patrick)     Created.
//             29-Jul-96   t-danal              Uppercase fix.
//
// Note:       Netware will let you create a lowercase user name but will
//             internally store only uppercase.  However, it will not
//             return the uppercase user name on a lowercase request.
//
//----------------------------------------------------------------------------

HRESULT
ValidateGroupObject(
     POBJECTINFO pObjectInfo
     )
{
    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;
    DWORD dwResumeObjectID = 0xffffffff;

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Obtain a handle to a NetWare Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get the specified (uppercased) group object.
    //

    hr = NWApiValidateObject(
             hConn,
             OT_USER_GROUP,
             _wcsupr(pObjectInfo->ComponentArray[1]),
             &dwResumeObjectID
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateFileServiceObject
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    22-Apr-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidateFileServiceObject(
    POBJECTINFO pObjectInfo
    )
{
    //
    // In NetWare, a FileService object represents a bindery, which is also
    // represented as a computer object.  Therefore validation of file service
    // object can be done the same way as the computer object.
    //

    //
    // A handle of a certain bindery can only be obtained if the bindery exist.
    // Therefore we used this fact to validate the existence of a computer
    // object.
    //

    NWCONN_HANDLE hConn = NULL;
    HRESULT hr = S_OK;

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Check for valid NetWare File Server name.
    //

    if (_wcsicmp(pObjectInfo->ComponentArray[1], bstrNWFileServiceName)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Try to obtain a handle to a NWCOMPAT Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Detach handle.
    //

    hr = NWApiReleaseBinderyHandle(
             hConn
             );

error:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidateFileShareObject
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    29-Apr-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidateFileShareObject(
     POBJECTINFO pObjectInfo
     )
{
    HRESULT hr = S_OK;
    DWORD dwResumeObjectID = 0xffffffff;
    NWCONN_HANDLE hConn = NULL;
    NWVOL_NUM VolumeNumber = 0;

    if (pObjectInfo->NumComponents != 3) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Obtain a handle to a NetWare Server.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Try to get the Volume ID that correspond to the Volume name.  If it
    // succeeds, the FileShare is valid.
    //

    hr = NWApiGetVolumeNumber(
             hConn,
             pObjectInfo->ComponentArray[2],
             &VolumeNumber
             );
    BAIL_ON_FAILURE(hr);

error:
    if (hConn) {
        NWApiReleaseBinderyHandle(hConn);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ValidatePrinterObject
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    2-May-96   t-ptam (Patrick)     Created.
//
//----------------------------------------------------------------------------
HRESULT
ValidatePrinterObject(
     POBJECTINFO pObjectInfo
     )
{
    HANDLE  hPrinter = NULL;
    HRESULT hr = S_OK;
    WCHAR szUncName[MAX_PATH];

    if (pObjectInfo->NumComponents != 2) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // Build UNC name from ObjectInfo.
    //

    wsprintf(
        szUncName,
        L"\\\\%s\\%s",
        pObjectInfo->ComponentArray[0],
        pObjectInfo->ComponentArray[1]
        );

    //
    // Get a handle of the printer.
    //

    hr = NWApiOpenPrinter(
             szUncName,
             &hPrinter,
             PRINTER_ACCESS_USE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Release it.
    //

    hr = NWApiClosePrinter(
             hPrinter
             );
error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   BuildParent
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPWSTR szBuffer]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
BuildParent(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;


    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer,L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents - 1) {

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents - 1); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }
    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   BuildGrandParent
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPWSTR szBuffer]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
BuildGrandParent(POBJECTINFO pObjectInfo, LPWSTR szBuffer)
{
    DWORD i = 0;

    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer,L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents - 2) {

        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents - 2); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:   BuildADsPath
//
// Synopsis:
//
// Arguments:  [POBJECTINFO pObjectInfo]
//             [LPWSTR szBuffer]
//
// Returns:    HRESULT
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------

HRESULT
BuildADsPath(
    POBJECTINFO pObjectInfo,
    LPWSTR szBuffer
    )
{
    DWORD i = 0;

    if (!pObjectInfo->ProviderName) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    wsprintf(szBuffer,L"%s:", pObjectInfo->ProviderName);

    if (pObjectInfo->NumComponents) {


        wcscat(szBuffer, L"//");
        wcscat(szBuffer, pObjectInfo->DisplayComponentArray[0]);

        for (i = 1; i < (pObjectInfo->NumComponents); i++) {
            wcscat(szBuffer, L"/");
            wcscat(szBuffer, pObjectInfo->DisplayComponentArray[i]);
        }
    }
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\globals.cxx ===
#include "NWCOMPAT.hxx"
#pragma hdrstop

const BSTR bstrAddressTypeString = L"IPX";
const BSTR bstrComputerOperatingSystem = L"NW3Compat";
const BSTR bstrFileShareDescription = L"Disk";
const BSTR bstrNWFileServiceName = L"NetWareFileServer";
const BSTR bstrProviderName   = L"NWCOMPAT";
const BSTR bstrProviderPrefix = L"NWCOMPAT:";

#define MAX_LONG    (0x7FFFFFFF)
#define MIN_LONG    (0x80000000)
#define MAX_BOOLEAN 1
#define MAX_STRLEN  256
#define MAX_UCHAR   255
#define MAX_USHORT  65535


PROPERTYINFO ComputerClass[] =
    { { TEXT("OperatingSystem"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEM_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("OperatingSystemVersion"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEMVERSION_ID, NT_SYNTAX_ID_LPTSTR}
    };


DWORD gdwComputerTableSize = sizeof(ComputerClass)/sizeof(PROPERTYINFO);


PROPERTYINFO UserClass[] =
    { { TEXT("FullName"),
        TEXT(""), TEXT("String"), NW_DATA_SIZE, 0, FALSE,   //  max 128 bytes
        PROPERTY_RW, USER_FULLNAME_ID, NT_SYNTAX_ID_LPTSTR },
      { TEXT("AccountDisabled"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTDISABLED_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("AccountExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE },
      { TEXT("AccountCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANACCOUNTEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("GraceLoginsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSALLOWED_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("GraceLoginsRemaining"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSREMAINING_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("IsAccountLocked"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISACCOUNTLOCKED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("IsAdmin"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISADMIN_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("MaxLogins"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_RW, USER_MAXLOGINS_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE},
      { TEXT("PasswordCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANPASSWORDEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("PasswordMinimumLength"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDMINIMUMLENGTH_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordRequired"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDREQUIRED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("RequireUniquePassword"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_REQUIREUNIQUEPASSWORD_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("BadLoginAddress"),    // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, USER_BADLOGINADDRESS_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("LastLogin"),          // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, USER_LASTLOGIN_ID, NT_SYNTAX_ID_NW312DATE},
      { TEXT("LoginHours"),          
        TEXT(""), TEXT("OctetString"), 0, 0, FALSE,
        PROPERTY_RW, USER_LOGINHOURS_ID, NT_SYNTAX_ID_OCTETSTRING}
    };

DWORD gdwUserTableSize = sizeof(UserClass)/sizeof(PROPERTYINFO);


PROPERTYINFO GroupClass[] =
    { { TEXT("Description"),            // FSGroupGeneralInfo
        TEXT(""), TEXT("String"), NW_DATA_SIZE, 0, FALSE,   // max 128 bytes
        PROPERTY_RW, GROUP_DESCRIPTION_ID, NT_SYNTAX_ID_LPTSTR }
    };


DWORD gdwGroupTableSize = sizeof(GroupClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FileServiceClass[] =
    { { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD }
    };

DWORD gdwFileServiceTableSize = sizeof(FileServiceClass)/sizeof(PROPERTYINFO);

PROPERTYINFO FileShareClass[] =
    { { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("HostComputer"),
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_RW, 1, NT_SYNTAX_ID_DWORD }
    };

DWORD gdwFileShareTableSize = sizeof(FileShareClass)/sizeof(PROPERTYINFO);

PROPERTYINFO PrintQueueClass[] =
    { { TEXT("PrinterPath"), // FSPrintQueueGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Model"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Datatype"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintProcessor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Location"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("DefaultJobPriority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("BannerPage"),
        TEXT(""), TEXT("Path"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintDevices"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DelimitedString }
    };

DWORD gdwPrinterTableSize = sizeof(PrintQueueClass)/sizeof(PROPERTYINFO);


PROPERTYINFO PrintJobClass[] =
    { { TEXT("HostPrintQueue"),     // ro, FSPrintJobGeneralInfo
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("User"),               // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeSubmitted"),      // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_SYSTEMTIME },
      { TEXT("TotalPages"),         // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_DWORD },
      { TEXT("Size"),               // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("Description"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 1,  NT_SYNTAX_ID_DWORD },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DATE },
      { TEXT("Notify"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeElapsed"),        // ro
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("PagesPrinted"),       // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("Position"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DWORD }
    };


DWORD gdwJobTableSize = sizeof(PrintJobClass)/sizeof(PROPERTYINFO);

CLASSINFO g_aNWCOMPATClasses[] =
{

//
//  Computer Class
//



  { COMPUTER_SCHEMA_NAME, &CLSID_NWCOMPATComputer, &IID_IADsComputer,
    TEXT(""), FALSE,

    NULL,


    TEXT("OperatingSystemVersion"),


    NULL, TEXT("User,Group,FileService,PrintQueue"), TRUE,
    TEXT(""), 0,
    ComputerClass, sizeof(ComputerClass)/sizeof(PROPERTYINFO) },


  { USER_SCHEMA_NAME, &CLSID_NWCOMPATUser, &IID_IADsUser,
    TEXT(""), FALSE,


    NULL,


    TEXT("FullName,AccountDisabled,AccountExpirationDate,")
    TEXT("AccountCanExpire,GraceLoginsAllowed,GraceLoginsRemaining,")
    TEXT("IsAccountLocked,IsAdmin,MaxLogins,PasswordExpirationDate,")
    TEXT("PasswordCanExpire,PasswordMinimumLength,PasswordRequired,")
    TEXT("RequireUniquePassword,BadLoginAddress,LastLogin"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    UserClass, sizeof(UserClass)/sizeof(PROPERTYINFO) },


  { GROUP_SCHEMA_NAME, &CLSID_NWCOMPATGroup, &IID_IADsGroup,
    TEXT(""), FALSE,


    NULL,


    TEXT("Description"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    GroupClass, sizeof(GroupClass)/sizeof(PROPERTYINFO) },

  { FILESERVICE_SCHEMA_NAME, &CLSID_NWCOMPATFileService, &IID_IADsFileService,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostComputer,MaxUserCount,"),

    TEXT("Computer"), TEXT("FileShare"), TRUE,
    TEXT(""), 0,
    FileServiceClass, sizeof(FileServiceClass)/sizeof(PROPERTYINFO) },

  { FILESHARE_SCHEMA_NAME,  &CLSID_NWCOMPATFileShare,  &IID_IADsFileShare,
    TEXT(""), FALSE,

    NULL,

    TEXT("Description,HostComputer,MaxUserCount"),

    TEXT("FileService"), NULL, FALSE,
    TEXT(""), 0,
    FileShareClass, sizeof(FileShareClass)/sizeof(PROPERTYINFO) },


  { PRINTER_SCHEMA_NAME, &CLSID_NWCOMPATPrintQueue, &IID_IADsPrintQueue,
    TEXT(""), FALSE,

    NULL,


    TEXT("PrinterPath,Model,Datatype,PrintProcessor,")
    TEXT("Description,Location,StartTime,UntilTime,DefaultJobPriority,")
    TEXT("Priority,BannerPage,PrintDevices"),


    TEXT("Computer"), NULL, FALSE,
    TEXT(""), 0,
    PrintQueueClass, sizeof(PrintQueueClass)/sizeof(PROPERTYINFO) },

  { PRINTJOB_SCHEMA_NAME, &CLSID_NWCOMPATPrintJob, &IID_IADsPrintJob,
    TEXT(""), FALSE,


    NULL,


    TEXT("HostPrintQueue,User,TimeSubmitted,TotalPages,")
    TEXT("Size,Priority,StartTime,UntilTime,Notify,TimeElapsed,")
    TEXT("PagesPrinted,Position"),


    NULL, NULL, FALSE,
    TEXT(""), 0,
    PrintJobClass, sizeof(PrintJobClass)/sizeof(PROPERTYINFO) }

};

SYNTAXINFO g_aNWCOMPATSyntax[] =
{ {  TEXT("Boolean"),       VT_BOOL },
  {  TEXT("Counter"),       VT_I4 },
  {  TEXT("ADsPath"),     VT_BSTR },
  {  TEXT("EmailAddress"),  VT_BSTR },
  {  TEXT("FaxNumber"),     VT_BSTR },
  {  TEXT("Integer"),       VT_I4 },
  {  TEXT("Interval"),      VT_I4 },
  {  TEXT("List"),          VT_VARIANT },  // VT_BSTR | VT_ARRAY
  {  TEXT("NetAddress"),    VT_BSTR },
  {  TEXT("OctetString"),   VT_VARIANT },  // VT_UI1| VT_ARRAY
  {  TEXT("Path"),          VT_BSTR },
  {  TEXT("PhoneNumber"),   VT_BSTR },
  {  TEXT("PostalAddress"), VT_BSTR },
  {  TEXT("SmallInterval"), VT_I4 },
  {  TEXT("String"),        VT_BSTR },
  {  TEXT("Time"),          VT_DATE }
};

DWORD g_cNWCOMPATClasses = (sizeof(g_aNWCOMPATClasses)/sizeof(g_aNWCOMPATClasses[0]));
DWORD g_cNWCOMPATSyntax = (sizeof(g_aNWCOMPATSyntax)/sizeof(g_aNWCOMPATSyntax[0]));

PROPERTYINFO g_aNWCOMPATProperties[] =
    { { TEXT("OperatingSystem"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEM_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("OperatingSystemVersion"), // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, COMP_OPERATINGSYSTEMVERSION_ID, NT_SYNTAX_ID_LPTSTR},

      // User Properties

      { TEXT("FullName"),
        TEXT(""), TEXT("String"), NW_DATA_SIZE, 0, FALSE,   //  max 128 bytes
        PROPERTY_RW, USER_FULLNAME_ID, NT_SYNTAX_ID_LPTSTR },
      { TEXT("AccountDisabled"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTDISABLED_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("AccountExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_ACCOUNTEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE },
      { TEXT("AccountCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANACCOUNTEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("GraceLoginsAllowed"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSALLOWED_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("GraceLoginsRemaining"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_GRACELOGINSREMAINING_ID, NT_SYNTAX_ID_DWORD },
      { TEXT("IsAccountLocked"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISACCOUNTLOCKED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("IsAdmin"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_ISADMIN_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("MaxLogins"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_RW, USER_MAXLOGINS_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordExpirationDate"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDEXPIRATIONDATE_ID, NT_SYNTAX_ID_NW312DATE},
      { TEXT("PasswordCanExpire"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_CANPASSWORDEXPIRE_ID, NT_SYNTAX_ID_BOOL },
      { TEXT("PasswordMinimumLength"),
        TEXT(""), TEXT("Integer"), MAX_UCHAR, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDMINIMUMLENGTH_ID, NT_SYNTAX_ID_DWORD},
      { TEXT("PasswordRequired"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_PASSWORDREQUIRED_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("RequireUniquePassword"),
        TEXT(""), TEXT("Boolean"), MAX_BOOLEAN, 0, FALSE,
        PROPERTY_RW, USER_REQUIREUNIQUEPASSWORD_ID, NT_SYNTAX_ID_BOOL},
      { TEXT("BadLoginAddress"),    // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, USER_BADLOGINADDRESS_ID, NT_SYNTAX_ID_LPTSTR},
      { TEXT("LastLogin"),          // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, USER_LASTLOGIN_ID, NT_SYNTAX_ID_NW312DATE},

      // Group Properties

      { TEXT("Description"),            // FSGroupGeneralInfo
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,   // max 128 bytes
        PROPERTY_RW, GROUP_DESCRIPTION_ID, NT_SYNTAX_ID_LPTSTR },

      // FileService Properties

      { TEXT("HostComputer"),          // FSServiceConfiguration
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1, NT_SYNTAX_ID_LPTSTR },
      { TEXT("MaxUserCount"),
        TEXT(""), TEXT("Integer"), MAX_USHORT, 0, FALSE,
        PROPERTY_READABLE, 2, NT_SYNTAX_ID_DWORD },

      // FileShare Properties

      //
      // Description (Group)
      //
      // HostComputer (FileService)
      //
      // MaxUserCount(FileService)
      //

      // PrintQueue Properties

      //
      // HostComputer (FileService)
      //
      { TEXT("Model"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("Datatype"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintProcessor"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      //
      // Description (Group)
      //
      { TEXT("Location"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("StartTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("UntilTime"),
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DATE },
      { TEXT("DefaultJobPriority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("Priority"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DWORD },
      { TEXT("BannerPage"),
        TEXT(""), TEXT("Path"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_LPTSTR },
      { TEXT("PrintDevices"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, TRUE,
        PROPERTY_RW, 2, NT_SYNTAX_ID_DelimitedString },

      // PrintJob Properties

      { TEXT("HostPrintQueue"),     // ro, FSPrintJobGeneralInfo
        TEXT(""), TEXT("ADsPath"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("User"),               // ro
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeSubmitted"),      // ro
        TEXT(""), TEXT("Time"), 0, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_SYSTEMTIME },
      { TEXT("TotalPages"),         // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 1,  NT_SYNTAX_ID_DWORD },
      { TEXT("Size"),               // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      //
      //  Description (Group)
      //
      // Priority (PrintQueue)
      //
      //
      // StartTime (PrintQueue)
      //
      // UntilTime(PrintQueue)
      //
      { TEXT("Notify"),
        TEXT(""), TEXT("String"), MAX_STRLEN, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_LPTSTR },
      { TEXT("TimeElapsed"),        // ro
        TEXT(""), TEXT("Interval"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("PagesPrinted"),       // ro
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_READABLE, 2,  NT_SYNTAX_ID_DWORD },
      { TEXT("Position"),
        TEXT(""), TEXT("Integer"), MAX_LONG, 0, FALSE,
        PROPERTY_RW, 2,  NT_SYNTAX_ID_DWORD }

    };


DWORD g_cNWCOMPATProperties = (sizeof(g_aNWCOMPATProperties)/sizeof(g_aNWCOMPATProperties[0]));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\fsmacro.h ===
#define PUT_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_LONG(this, Property) \
                HRESULT tmphr; \
                tmphr = get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_BSTR(this, Property) \
                HRESULT tmphr; \
                tmphr = get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_DATE(this, Property) \
                HRESULT tmphr; \
                tmphr = get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);


#define PUT_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);

#define GET_PROPERTY_VARIANT(this, Property) \
                HRESULT tmphr; \
                tmphr = get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ); \
                RRETURN_EXP_IF_ERR(tmphr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\extension.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for ADs.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop


LPCWSTR lpszTopLevel = L"SOFTWARE\\Microsoft\\ADs\\Providers\\NWCOMPAT";
LPCWSTR lpszExtensions = L"Extensions";

PCLASS_ENTRY gpClassHead = NULL;


PCLASS_ENTRY
BuildClassesList()
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;
    HKEY hExtensionRootKey = NULL;

    HKEY hClassKey = NULL;

    DWORD dwIndex = 0;
    WCHAR lpszClassName[MAX_PATH];
    DWORD dwchClassName = 0;
    PCLASS_ENTRY pClassHead = NULL;
    PCLASS_ENTRY pClassEntry = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     lpszTopLevel,
                     0,
                     KEY_READ,
                     &hTopLevelKey
                     ) != ERROR_SUCCESS)
    {
        goto CleanupAndExit;
    }

    if (RegOpenKeyEx(hTopLevelKey,
                     lpszExtensions,
                     0,
                     KEY_READ,
                     &hExtensionRootKey
                     ) != ERROR_SUCCESS)

    {
        goto CleanupAndExit;

    }

    memset(lpszClassName, 0, sizeof(lpszClassName));
    dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);

    while(RegEnumKeyEx(hExtensionRootKey,
                     dwIndex,
                     lpszClassName,
                     &dwchClassName,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hExtensionRootKey,
                         lpszClassName,
                         0,
                         KEY_READ,
                         &hClassKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        pClassEntry  = BuildClassEntry(
                                lpszClassName,
                                hClassKey
                                );

        if (pClassEntry) {

            pClassEntry->pNext = pClassHead;
            pClassHead = pClassEntry;
        }

        if (hClassKey) {
            CloseHandle(hClassKey);
        }

        memset(lpszClassName, 0, sizeof(lpszClassName));
        dwchClassName = sizeof(lpszClassName)/sizeof(WCHAR);
        dwIndex++;
    }

CleanupAndExit:

    if (hExtensionRootKey) {
        RegCloseKey(hExtensionRootKey);
    }

    if (hTopLevelKey) {
        RegCloseKey(hTopLevelKey);
    }

    return(pClassHead);
}


VOID
FreeClassesList(
    PCLASS_ENTRY pClassHead
    )
{
    PCLASS_ENTRY pDelete;

    while (pClassHead) {

        pDelete = pClassHead;
        pClassHead = pClassHead->pNext;

        FreeClassEntry(pDelete);
    }

    return;
}


PCLASS_ENTRY
BuildClassEntry(
    LPWSTR lpszClassName,
    HKEY hClassKey
    )
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;

    DWORD dwIndex = 0;
    DWORD dwchExtensionCLSID = 0;
    WCHAR lpszExtensionCLSID[MAX_PATH];
    PCLASS_ENTRY pClassEntry = NULL;
    PEXTENSION_ENTRY pExtensionHead = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;

    pClassEntry =  (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (!pClassEntry) {

        goto CleanupAndExit;
    }

    wcscpy(pClassEntry->szClassName, lpszClassName);

    memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
    dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);

    while(RegEnumKeyEx(hClassKey,
                     dwIndex,
                     lpszExtensionCLSID,
                     &dwchExtensionCLSID,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hClassKey,
                         lpszExtensionCLSID,
                         0,
                         KEY_READ,
                         &hExtensionKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        //
        // Read the Interfaces that this Extension supports
        //

        pExtensionEntry = BuildExtensionEntry(
                                lpszExtensionCLSID,
                                hExtensionKey
                                );

        if (pExtensionEntry) {

            wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);

            pExtensionEntry->pNext = pExtensionHead;
            pExtensionHead = pExtensionEntry;
        }


        if (hExtensionKey) {

            CloseHandle(hExtensionKey);
        }

        memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
        dwchExtensionCLSID = sizeof(lpszExtensionCLSID)/sizeof(WCHAR);
        dwIndex++;

    }

    pClassEntry->pExtensionHead = pExtensionHead;




CleanupAndExit:

    return(pClassEntry);
}


PEXTENSION_ENTRY
BuildExtensionEntry(
    LPWSTR lpszExtensionCLSID,
    HKEY hExtensionKey
    )
{
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pInterfaceHead = NULL;
    WCHAR lpszInterfaces[MAX_PATH];
    DWORD dwchInterfaces = 0;
    LPWSTR psz = NULL;
    WCHAR Interface[MAX_PATH];
    HRESULT hr = S_OK;


    pExtensionEntry =  (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (!pExtensionEntry) {

        goto CleanupAndExit;
    }

    memset(lpszInterfaces, 0, sizeof(lpszInterfaces));
    dwchInterfaces = sizeof(lpszInterfaces);

    RegQueryValueEx(
            hExtensionKey,
            L"Interfaces",
            NULL,
            NULL,
            (LPBYTE) lpszInterfaces,
            &dwchInterfaces
            );

    psz = lpszInterfaces;

    while (psz && *psz) {

       wcscpy(Interface, psz);

       // skip (length) + 1
       // lstrlen returns length sans '\0'


       pInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

       if (pInterfaceEntry) {

           wcscpy(pInterfaceEntry->szInterfaceIID, Interface);
           hr = IIDFromString(Interface, &(pInterfaceEntry->iid));

           pInterfaceEntry->pNext = pInterfaceHead;
           pInterfaceHead = pInterfaceEntry;

       }

       psz = psz + lstrlen(psz) + 1;

    }

    wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);
    hr = CLSIDFromString(lpszExtensionCLSID, &(pExtensionEntry->ExtCLSID));

    pExtensionEntry->pIID = pInterfaceHead;

CleanupAndExit:

    return(pExtensionEntry);
}


void
FreeInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    if (pInterfaceEntry) {

        FreeADsMem(pInterfaceEntry);
    }
}


void
FreeExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pTemp = NULL;

    if (pExtensionEntry) {

        pInterfaceEntry = pExtensionEntry->pIID;

        while (pInterfaceEntry) {

            pTemp = pInterfaceEntry->pNext;

            if (pInterfaceEntry) {

                FreeInterfaceEntry(pInterfaceEntry);
            }

            pInterfaceEntry = pTemp;

        }

        //
        // Now unload the Extension Object
        //

        if (pExtensionEntry->pUnknown) {

            //
            // Call non-delegating Release to release ref. count on innner
            // object (for pUnkown) -> inner object self destroy
            //
            (pExtensionEntry->pUnknown)->Release();

        }


        FreeADsMem(pExtensionEntry);
    }

    return;
}

void
FreeClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{

    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PEXTENSION_ENTRY pTemp = NULL;

    if (pClassEntry) {

        pExtensionEntry = pClassEntry->pExtensionHead;

        while (pExtensionEntry) {

            pTemp = pExtensionEntry->pNext;

            if (pExtensionEntry) {

                FreeExtensionEntry(pExtensionEntry);
            }

            pExtensionEntry = pTemp;

        }

        FreeADsMem(pClassEntry);
    }

    return;
}


PINTERFACE_ENTRY
MakeCopyofInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    pNewInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

    if (pNewInterfaceEntry) {

        wcscpy(pNewInterfaceEntry->szInterfaceIID, pInterfaceEntry->szInterfaceIID);
        memcpy(&(pNewInterfaceEntry->iid), &(pInterfaceEntry->iid), sizeof(GUID));
    }

    return(pNewInterfaceEntry);
}



PEXTENSION_ENTRY
MakeCopyofExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PINTERFACE_ENTRY pInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceHead = NULL;


    pInterfaceEntry = pExtensionEntry->pIID;

    while (pInterfaceEntry) {

        pNewInterfaceEntry = MakeCopyofInterfaceEntry(pInterfaceEntry);

        if (pNewInterfaceEntry) {

            pNewInterfaceEntry->pNext = pNewInterfaceHead;
            pNewInterfaceHead = pNewInterfaceEntry;
        }

        pInterfaceEntry = pInterfaceEntry->pNext;

    }

    pNewExtensionEntry = (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (pNewExtensionEntry) {

        wcscpy(
            pNewExtensionEntry->szExtensionCLSID,
            pExtensionEntry->szExtensionCLSID
            );

        memcpy(
            &(pNewExtensionEntry->ExtCLSID),
            &(pExtensionEntry->ExtCLSID),
            sizeof(GUID)
            );

        pNewExtensionEntry->pIID = pNewInterfaceHead;


        //
        // Initialize fields we won't know the values of until an instacne of
        // the extension is created and aggregated (loaded).
        //

        pNewExtensionEntry->pUnknown=NULL;
        pNewExtensionEntry->pPrivDisp=NULL;
        pNewExtensionEntry->pADsExt=NULL;
        pNewExtensionEntry->fDisp=FALSE;
        pNewExtensionEntry->dwExtensionID = (DWORD) -1; //invalid dwExtensionID

        //
        // let class entry handle pNext
        //
    }

    return(pNewExtensionEntry);
}


PCLASS_ENTRY
MakeCopyofClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{
    PCLASS_ENTRY pNewClassEntry = NULL;

    PEXTENSION_ENTRY pExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionHead = NULL;


    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pNewExtensionEntry = MakeCopyofExtensionEntry(pExtensionEntry);

        if (pNewExtensionEntry) {

            pNewExtensionEntry->pNext = pNewExtensionHead;
            pNewExtensionHead = pNewExtensionEntry;
        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    pNewClassEntry = (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (pNewClassEntry) {

        wcscpy(pNewClassEntry->szClassName, pClassEntry->szClassName);

        pNewClassEntry->pExtensionHead = pNewExtensionHead;

    }

    return(pNewClassEntry);
}


CRITICAL_SECTION g_ExtCritSect;


#define ENTER_EXTENSION_CRITSECT()  EnterCriticalSection(&g_ExtCritSect)
#define LEAVE_EXTENSION_CRITSECT()  LeaveCriticalSection(&g_ExtCritSect)

HRESULT
ADSIGetExtensionList(
    LPWSTR pszClassName,
    PCLASS_ENTRY * ppClassEntry
    )
{

    PCLASS_ENTRY pTempClassEntry = NULL;
    PCLASS_ENTRY pClassEntry = NULL;
    ENTER_EXTENSION_CRITSECT();

    pTempClassEntry = gpClassHead;

    while (pTempClassEntry) {


        if (!_wcsicmp(pTempClassEntry->szClassName, pszClassName)) {

            //
            // Make a copy of this entire extension and
            // hand it over to the calling entity.
            //

            pClassEntry = MakeCopyofClassEntry(pTempClassEntry);

            *ppClassEntry = pClassEntry;

            LEAVE_EXTENSION_CRITSECT();

            RRETURN(S_OK);

        }

        pTempClassEntry = pTempClassEntry->pNext;

   }


   *ppClassEntry = NULL;

   LEAVE_EXTENSION_CRITSECT();

   RRETURN(S_OK);

}


//
//
// Instantiate extension objects listed in <pClassEntry> as aggregatees of
// aggregator <pUnkOuter>.
//
// Max Load 127 extensions. Return S_FALSE if more extension in <pClassEntry>


HRESULT
ADSILoadExtensions(
    IUnknown FAR * pUnkOuter,
    PCLASS_ENTRY pClassEntry
    )

{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    DWORD dwExtensionID = MIN_EXTENSION_ID;
    IPrivateDispatch * pPrivDisp = NULL;
    BOOL    fReturnError = FALSE;
    VARIANT varUserName, varPassword, varAuthFlags;

    VariantInit(&varUserName);
    VariantInit(&varPassword);
    VariantInit(&varAuthFlags);

    varUserName.vt = VT_BSTR;
    varUserName.bstrVal = NULL;

    varPassword.vt = VT_BSTR;
    varPassword.bstrVal = NULL;

    varAuthFlags.vt = VT_I4;
    varAuthFlags.lVal = 0;

    ASSERT(pUnkOuter);


    if (!pClassEntry || !(pExtEntry=pClassEntry->pExtensionHead) ) {
        RRETURN(S_OK);
    }

    while (pExtEntry) {

        //
        // Max # of extension have been loaded, cannot load more
        //

        if (dwExtensionID>MAX_EXTENSION_ID) {

            hr = S_FALSE;
            fReturnError = TRUE;
            break;
        }

        //
        // create extension object (aggregatee) and ask for Non-delegating
        // IUnknown. Ref count on extension object = 1.
        //

        hr = CoCreateInstance(
                    pExtEntry->ExtCLSID,
                    pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IUnknown,
                    (void **)&(pExtEntry->pUnknown)
                    );

        //
        // if fail, go to next extesion entry s.t. bad individual extension
        // cannot block other extensions from loading (no clean up needed)
        //
        // The user receives no warning about the failure to load a particular
        // extension (we really don't have any way to do so specified), other
        // than the fact that their extension doesn't work when they try to
        // use it (e.g., they'll probably get back something like
        // DISP_E_UNKNOWNNAME when they try to use GetIDsOfNames to find its
        // methods).
        //

        if (SUCCEEDED(hr)) {

            pExtEntry->dwExtensionID = dwExtensionID;


            hr = (pExtEntry->pUnknown)->QueryInterface(
                        IID_IADsExtension,
                        (void **) &(pExtEntry->pADsExt)
                        );

            if  (FAILED(hr)) {

                //
                // extension does not support the optioanl IADsExtension -> OK.
                // (no clean up needed)
                //

                pExtEntry->pADsExt=NULL;

                pExtEntry->fDisp = FALSE;

            } else {

                //
                // Cache the interface ptr but call Release() immediately to
                // avoid aggregator having a ref count on itself
                // since IADsExtension inherits from delegating IUnknown.
                //
                // Note: codes still works if inherit from NonDelegatingIUknown
                //

                (pExtEntry->pADsExt)->Release() ;

                //
                // For efficiency, set this flag to FALSE on FIRST encounter of
                // pADsExt->PrivateGetIDsOfNames()/Invoke() returning E_NOTIMPL.
                // Set as TRUE now s.t. at least first encounter will happen.
                //

                pExtEntry->fDisp = TRUE;

                pExtEntry->pADsExt->Operate(
                                        ADS_EXT_INITCREDENTIALS,
                                        varUserName,
                                        varPassword,
                                        varAuthFlags
                                        );
            }

        } // end if CoCreateInstance() succeeded

        pExtEntry = pExtEntry->pNext;


        //
        // ++ extension ID even if creat'n of extension fails just to be safe
        // - chuck's stuff :)
        //

        dwExtensionID++;

    }   // end while


    if (fReturnError) {
        RRETURN(hr);        // fetal error,
    }
    else {
        RRETURN(S_OK);      // "okay" error if any, optional support
    }

}

#if 0
HRESULT
ADSILoadExtensions(
    IUnknown FAR * pUnkOuter,
    PCLASS_ENTRY pClassEntry,
    LPTSTR pszClassName
    )

{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    DWORD dwExtensionID = 1;
    IPrivateDispatch * pPrivDisp = NULL;

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        hr = CoCreateInstance(
                    pExtensionEntry->ExtCLSID,
                    pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IPrivateUnknown,
                    (void **)&(pExtensionEntry->pUnknown)
                    );


        if (SUCCEEDED(hr)) {


            hr = (pExtensionEntry->pUnknown)->ADSIInitializeObject(
                                                    NULL,
                                                    NULL,
                                                    0
                                                    );

            pExtensionEntry->dwExtensionID = dwExtensionID;

            hr = (pExtensionEntry->pUnknown)->QueryInterface(
                                    IID_IPrivateDispatch,
                                    (void **)&pPrivDisp
                                    );
            if (SUCCEEDED(hr)) {

                hr = pPrivDisp->ADSIInitializeDispatchManager(dwExtensionID);

                if (FAILED(hr)) {

                    //
                    // Remember NOT to do a Release here for IPrivateDispatch
                    //

                    pExtensionEntry->fDisp = FALSE;

                    (pExtensionEntry->pUnknown)->Release();


                }else {
                    pExtensionEntry->fDisp = TRUE;
                    pExtensionEntry->pPrivDisp = pPrivDisp;

                    //
                    // Now release  both pointers because we don't want to
                    // have a cyclic reference count
                    //

                    (pExtensionEntry->pPrivDisp)->Release();
                    (pExtensionEntry->pUnknown)->Release();
                }

            }else {
                pExtensionEntry->fDisp = FALSE;

                (pExtensionEntry->pUnknown)->Release();

            }

        }

        pExtensionEntry = pExtensionEntry->pNext;

        dwExtensionID++;

    }

    RRETURN(S_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\cusers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cgroups.cxx
//
//  Contents:  Group object
//
//  History:   Mar-18-965     t-ptam (PatrickT)    Migrated.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop

//
//  Class CNWCOMPATUserCollection
//

DEFINE_IDispatch_Implementation(CNWCOMPATUserCollection)

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollection::CNWCOMPATUserCollection():
        _ParentType(0),
        _ServerName(NULL),
        _pDispMgr(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CNWCOMPATUserCollection);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
CNWCOMPATUserCollection::~CNWCOMPATUserCollection( )
{
    if (_ServerName)
        ADsFreeString(_ServerName);
    delete _pDispMgr;
    VariantClear(&_vFilter);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollection::CreateUserCollection(
    BSTR Parent,
    ULONG ParentType,
    BSTR ServerName,
    BSTR UserName,
    REFIID riid,
    void **ppvObj
    )
{
    CNWCOMPATUserCollection FAR * pUser = NULL;
    HRESULT hr = S_OK;

    hr = AllocateUserCollectionObject(&pUser);
    BAIL_ON_FAILURE(hr);

    hr = pUser->InitializeCoreObject(
                     Parent,
                     UserName,
                     L"users",
                     NO_SCHEMA,
                     CLSID_NWCOMPATUser,
                     ADS_OBJECT_UNBOUND
                     );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ServerName, &pUser->_ServerName);
    BAIL_ON_FAILURE(hr);

    pUser->_ParentType = ParentType;

    hr = pUser->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pUser->Release();
    RRETURN(hr);

error:
    delete pUser;

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsMembers))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsMembers FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//----------------------------------------------------------------------------
//
//  Function:CNWCOMPATUserCollection::InterfaceSupportsErrorInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::InterfaceSupportsErrorInfo(
    THIS_ REFIID riid
    )
{
    if (IsEqualIID(riid, IID_IADsMembers)) {
        RRETURN(S_OK);
    } else {
        RRETURN(S_FALSE);
    }
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::get_Count(
    long FAR* retval
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::get_Filter(
    THIS_ VARIANT FAR* pVar
    )
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::put_Filter(
    THIS_ VARIANT Var
    )
{
    HRESULT hr;
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CNWCOMPATUserCollection::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CNWCOMPATUserCollectionEnum::Create(
             (CNWCOMPATUserCollectionEnum **)&penum,
             _Parent,
             _ParentType,
             _ADsPath,
             _ServerName,
             _Name,
             _vFilter
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                    IID_IUnknown,
                    (VOID FAR* FAR*)retval
                    );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//----------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
CNWCOMPATUserCollection::AllocateUserCollectionObject(
    CNWCOMPATUserCollection ** ppUser
    )
{
    CNWCOMPATUserCollection FAR * pUser = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;


    pUser = new CNWCOMPATUserCollection();
    if (pUser == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsMembers,
             (IADsMembers *)pUser,
             DISPID_NEWENUM
             );
    BAIL_ON_FAILURE(hr);

    pUser->_pDispMgr = pDispMgr;
    *ppUser = pUser;

    RRETURN(hr);

error:
    if (pUser) {
        delete pUser;
    }

    if (pDispMgr) {
        delete  pDispMgr;
    }

    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\guid.c ===
#define INITGUID

#include <ole2.h>

//--------------------------------------------------------------------------
//
//  NWCOMPAT CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(CLSID_NWCOMPATProvider,0x0df68130L,0x4b62,0x11CF,0xAE,0x2C,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATNamespace,0x0fb32cc0L,0x4b62,0x11CF,0xAE,0x2C,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATComputer,0xcad1bde0L,0x4cf0,0x11cf,0xae,0x2d,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATUser,0x5c250b00L,0x5863,0x11cf,0xae,0x32,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATGroup,0x3c5662e0L,0x5a74,0x11cf,0xae,0x32,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATDomain,0x9f6616f0L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATService,0x9f02c3c0L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATPrintQueue,0x9e7dd270L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATPrintJob,0x9e09b030L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATFileService,0x9d9eb910L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATSession,0x9d2a96d0L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATResource,0x9cb36630L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATFileShare,0x9c486f10L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATSchema,0x9bcfb740L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATClass,0x9b602a90L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATSyntax,0x9af53370L,0x7934,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

DEFINE_GUID(CLSID_NWCOMPATProperty,0x44687d30L,0x7937,0x11cf,0xae,0x3b,0x00,0xaa,0x00,0x6e,0xbf,0xb9);

//------------------------------------------------------------------------
//  GUIDS that come out of NWCOMPAT.tlb.
//------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\nw2ods.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw2ods.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma  hdrstop



HRESULT
NTTypeToAdsTypeCopyString(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->DNString  =
                        AllocADsStr(
                                lpNtSrcObject->NTValue.pszValue
                                );
    if ((!lpAdsDestValue->DNString) &&
        (lpNtSrcObject->NTValue.pszValue)) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(hr);
}



HRESULT
NTTypeToAdsTypeCopyBoolean(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpNtSrcObject->NTValue.fValue;

    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyInteger(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                        lpNtSrcObject->NTValue.dwValue;

    RRETURN(hr);

}


HRESULT
NTTypeToAdsTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {

    case NT_SYNTAX_ID_BOOL:
        hr = NTTypeToAdsTypeCopyBoolean(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = NTTypeToAdsTypeCopyInteger(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = NTTypeToAdsTypeCopyString(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;
    /*
    case NT_SYNTAX_ID_SYSTEMTIME:
    case NT_SYNTAX_ID_DATE:
    case NT_SYNTAX_ID_NW312TIME:
        hr = NTTypeToAdsTypeCopyNDSSynId4(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = NTTypeToAdsTypeCopyNDSSynId5(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = NTTypeToAdsTypeCopyNDSSynId6(
                lpNtSrcObject,
                lpAdsDestValue
                );
        break;
    */

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
NTTypeToAdsTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    LPADSVALUE * ppAdsDestValues
    )
{

    DWORD i = 0;
    LPADSVALUE pAdsDestValues = NULL;
    HRESULT hr = S_OK;

    if (!dwNumObjects) {
        *ppAdsDestValues =0;
        RRETURN(S_OK);
    }

    pAdsDestValues = (LPADSVALUE)AllocADsMem(
                                    dwNumObjects * sizeof(ADSVALUE)
                                    );

    if (!pAdsDestValues) {
        RRETURN(E_OUTOFMEMORY);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = NTTypeToAdsTypeCopy(
                    pNtSrcObjects + i,
                    pAdsDestValues + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppAdsDestValues = pAdsDestValues;

     RRETURN(S_OK);

error:

     if (pAdsDestValues) {
        AdsFreeAdsValues(
            pAdsDestValues,
            dwNumObjects
            );
       FreeADsMem(pAdsDestValues); 
     }

     *ppAdsDestValues = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for NWCOMPAT guids
//
//  History:    10-Jan-06  t-ptam
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// NWCOMPATOle CLSIDs
//
//-------------------------------------------

// uuids from NWCOMPAT.tlb

extern const CLSID CLSID_NWCOMPATProvider;

extern const CLSID CLSID_NWCOMPATNamespace;

extern const CLSID CLSID_NWCOMPATComputer;

extern const CLSID CLSID_NWCOMPATUser;

extern const CLSID CLSID_NWCOMPATGroup;

extern const CLSID CLSID_NWCOMPATProvider;

extern const CLSID CLSID_NWCOMPATNamespace;

extern const CLSID CLSID_NWCOMPATComputer;

extern const CLSID CLSID_NWCOMPATUser;

extern const CLSID CLSID_NWCOMPATGroup;

extern const CLSID CLSID_NWCOMPATDomain;

extern const CLSID CLSID_NWCOMPATService;

extern const CLSID CLSID_NWCOMPATPrintQueue;

extern const CLSID CLSID_NWCOMPATPrintJob;

extern const CLSID CLSID_NWCOMPATFileService;

extern const CLSID CLSID_NWCOMPATSession;

extern const CLSID CLSID_NWCOMPATResource;

extern const CLSID CLSID_NWCOMPATFileShare;

extern const CLSID CLSID_NWCOMPATSchema;

extern const CLSID CLSID_NWCOMPATClass;

extern const CLSID CLSID_NWCOMPATSyntax;

extern const CLSID CLSID_NWCOMPATProperty;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\nw312_2.h ===
#define NWCOMPAT_LIBIID_NWCOMPATOle        09d69aa0-4b62-11cf-ae2c-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATProvider    0df68130-4b62-11cf-ae2c-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATNamespace   0fb32cc0-4b62-11cf-ae2c-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATComputer    cad1bde0-4cf0-11cf-ae2d-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATUser        5c250b00-5863-11cf-ae32-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATGroup       3c5662e0-5a74-11cf-ae32-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATDomain             9f6616f0-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATService            9f02c3c0-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATPrintQueue         9e7dd270-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATPrintJob           9e09b030-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATFileService        9d9eb910-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATSession            9d2a96d0-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATResource           9cb36630-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATFileShare          9c486f10-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATSchema             9bcfb740-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATClass              9b602a90-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATSyntax             9af53370-7934-11cf-ae3b-00aa006ebfb9
#define NWCOMPAT_CLSID_NWCOMPATProperty           44687d30-7937-11cf-ae3b-00aa006ebfb9
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\grputils.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      grputils.cxx
//
//  Contents:  NetWare compatible GroupCollection Enumeration Code
//
//  History:   22-Mar-96    t-ptam (PatrickT) migrated from KrishnaG for NetWare
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

COMPUTER_GROUP_MEMBER CompMember;

//
// This assumes that addr is an LPBYTE type.
//

#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((UINT_PTR)addr & ~1))

DWORD ComputerGrpMemberStrings[]=
                             {
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Parent),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Computer),
                             FIELD_OFFSET(COMPUTER_GROUP_MEMBER, Name),
                             0xFFFFFFFF
                             };

DECLARE_INFOLEVEL(GrpUt)
DECLARE_DEBUG(GrpUt)
#define GrpUtDebugOut(x) GrpUtInlineDebugOut x

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupOpen
//
//  Synopsis: This function opens a handle to a INI_COMP_GROUP structure.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupOpen(
    LPWSTR szComputerName,
    LPWSTR szGroupName,
    PHANDLE phGroup
    )
{
    WCHAR szTempBuffer[MAX_PATH];
    PINI_COMP_GROUP pIniCompGrp;
    HRESULT hr = S_OK;

    if (!phGroup) {
        return(FALSE);
    }

    pIniCompGrp = (PINI_COMP_GROUP)AllocADsMem(
                                       sizeof(INI_COMP_GROUP)
                                       );
    if (!pIniCompGrp) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    if (!(pIniCompGrp->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    if (!(pIniCompGrp->szGroupName = AllocADsStr(szGroupName))){
        goto error;
    }

    hr = NWApiGetBinderyHandle(
             &pIniCompGrp->_hConn,
             szComputerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return
    //

    *phGroup =  (HANDLE)pIniCompGrp;

    return(TRUE);


error:
    if (pIniCompGrp) {
        FreeIniCompGroup(pIniCompGrp);
    }

    *phGroup = NULL;

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupEnum
//
//  Synopsis: This function returns a buffer which contains all the binding
//            informations for the requested number of objects without any
//            references.
//            It returns TRUE iff dwReturned = dwRequested.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupEnum(
    HANDLE hGroup,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{
    LPCOMPUTER_GROUP_MEMBER * ppGroupMembers = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPCOMPUTER_GROUP_MEMBER pBuffer = NULL;
    LPBYTE pEnd = NULL;

    //
    // Allocate buffer for the number of requested members.
    //

    ppGroupMembers = (LPCOMPUTER_GROUP_MEMBER *)AllocADsMem(
                                                    sizeof(LPCOMPUTER_GROUP_MEMBER)* dwRequested
                                                    );
    if (!ppGroupMembers) {
        return(FALSE);
    }

    //
    // Fill in ppGroupMembers one by one.
    //

    for (i = 0; i < dwRequested; i++) {

        dwRet = NWCOMPATComputerGroupGetObject(
                    hGroup,
                    &ppGroupMembers[i]
                    );
        if (!dwRet) {
            break;
        }
    }

    if (dwRet) {
        dwReturned = i;

        //
        // Determine actual size of ppGroupMembers[], ie. since each string in
        // COMPUTER_GROUP_MEMBER have a different length, a buffer that is going
        // to contain all the data without any references is unknown.
        //

        dwRet = ComputeComputerGroupDataSize(
                    ppGroupMembers,
                    dwReturned,
                    &dwSize
                    );

        pBuffer = (LPCOMPUTER_GROUP_MEMBER)AllocADsMem(
                                               dwSize
                                               );
        if (!pBuffer) {
            goto error;
        }

        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        //
        // Put data into pBuffer, starting from the end.
        //

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniCompGroupToCompGroup(
                       ppGroupMembers[i],
                       (LPBYTE)(pBuffer + i),
                       pEnd
                       );
        }

        //
        // Clean up.
        //

        for (i = 0; i < dwReturned; i++ ) {
            FreeIntCompGroup(*(ppGroupMembers + i));
        }

        //
        // Return values.
        //

        *ppBuffer = (LPBYTE)pBuffer;
        *pdwReturned  = dwReturned;
    }

    FreeADsMem(ppGroupMembers);

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }

error:
    
    for (i = 0; i < dwReturned; i++ ) {
        FreeIntCompGroup(*(ppGroupMembers + i));
    }
    
    FreeADsMem(ppGroupMembers);
    
    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupGetObject
//
//  Synopsis: This function returns binding information of a user (group member)
//            object one by one.  In its first call, it builds a buffer that
//            contains all the UserID of the group members.  Then, and in
//            subsequent calls, this UserID is translated into a user name.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupGetObject(
    HANDLE hGroup,
    LPCOMPUTER_GROUP_MEMBER * ppGroupMember
    )
{
    BOOL            dwRet = FALSE;
    DWORD           dwUserID = 0;
    HRESULT         hr = S_OK;
    PINI_COMP_GROUP pIniCompGrp = (PINI_COMP_GROUP)hGroup;

    //
    // Fill buffer with User ID.  NetWare returns all UserID in one call.
    //

    if (!pIniCompGrp->_pBuffer) {

        pIniCompGrp->_dwCurrentObject = 0;

        hr = NWApiGroupGetMembers(
                 pIniCompGrp->_hConn,
                 pIniCompGrp->szGroupName,
                 &(pIniCompGrp->_pBuffer)
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Build one group member.
    //

    dwUserID = *((LPDWORD)pIniCompGrp->_pBuffer + pIniCompGrp->_dwCurrentObject);

    if (dwUserID != 0x0000) {

        dwRet = BuildComputerGroupMember(
                    hGroup,
                    dwUserID,
                    ppGroupMember
                    );
        if (!dwRet) {
            goto error;
        }

        pIniCompGrp->_dwCurrentObject++;

        return(TRUE);
    }

error:

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerGroupClose
//
//  Synopsis: Wrapper of FreeIniCompGroup.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerGroupClose(
    HANDLE hGroup
    )
{
    PINI_COMP_GROUP pIniCompGrp = (PINI_COMP_GROUP)hGroup;

    if (pIniCompGrp) {
        FreeIniCompGroup(pIniCompGrp);
    }
    return(TRUE);
}

//----------------------------------------------------------------------------
//
//  Function: FreeIniCompGroup
//
//  Synopsis: Free an INI_COMP_GROUP structure.
//
//----------------------------------------------------------------------------
void
FreeIniCompGroup(
    PINI_COMP_GROUP pIniCompGrp
    )
{
    HRESULT hr = S_OK;

    if (pIniCompGrp) {

        if (pIniCompGrp->szComputerName) {
            FreeADsStr(pIniCompGrp->szComputerName);
        }

        if (pIniCompGrp->szGroupName) {
            FreeADsStr(pIniCompGrp->szGroupName);
        }

        if (pIniCompGrp->_pBuffer) {
            FreeADsMem(pIniCompGrp->_pBuffer);
        }

        if (pIniCompGrp->_hConn) {
            hr = NWApiReleaseBinderyHandle(pIniCompGrp->_hConn);
        }

        FreeADsMem(pIniCompGrp);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: FreeIntCompGroup
//
//  Synopsis: Free a COMPUTER_GROUP_MEMBER structure.
//
//----------------------------------------------------------------------------
void
FreeIntCompGroup(
    LPCOMPUTER_GROUP_MEMBER pCompGroupMember
    )
{
    if (pCompGroupMember) {

        if (pCompGroupMember->Parent) {
            FreeADsStr(pCompGroupMember->Parent);
        }

        if (pCompGroupMember->Computer) {
            FreeADsStr(pCompGroupMember->Computer);
        }

        if (pCompGroupMember->Name) {
            FreeADsStr(pCompGroupMember->Name);
        }

        FreeADsMem(pCompGroupMember);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: ComputeComputerGroupDataSize
//
//  Synopsis: Calculate the size of a buffer that is going to store the data in
//            ppGroupMembers without any references.
//
//----------------------------------------------------------------------------
BOOL
ComputeComputerGroupDataSize(
        LPCOMPUTER_GROUP_MEMBER * ppGroupMembers,
        DWORD  dwReturned,
        PDWORD pdwSize
        )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPCOMPUTER_GROUP_MEMBER pMember = NULL;

    for (i = 0; i < dwReturned; i++) {

        pMember = *(ppGroupMembers + i);

        cb += sizeof(COMPUTER_GROUP_MEMBER);

        if (pMember->Parent) {
            cb += wcslen(pMember->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Computer) {
            cb += wcslen(pMember->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Name) {
            cb += wcslen(pMember->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}

//------------------------------------------------------------------------------
//
//  Function: CopyIniCompGroupToCompGroup
//
//  Synopsis: Pack referenced data (string) into a buffer without any reference.
//
//------------------------------------------------------------------------------
LPBYTE
CopyIniCompGroupToCompGroup(
    LPCOMPUTER_GROUP_MEMBER  pIntCompGrp,
    LPBYTE  pExtCompGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(COMPUTER_GROUP_MEMBER)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings =  SourceStrings;
    LPCOMPUTER_GROUP_MEMBER pCompGrpMember = (LPCOMPUTER_GROUP_MEMBER)pExtCompGrp;

    memset(SourceStrings, 0, sizeof(COMPUTER_GROUP_MEMBER));
    *pSourceStrings++ = pIntCompGrp->Parent;
    *pSourceStrings++ = pIntCompGrp->Computer;
    *pSourceStrings++ = pIntCompGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtCompGrp,
                ComputerGrpMemberStrings,
                pEnd
                );

    pCompGrpMember->Type = pIntCompGrp->Type;

    return pEnd;
}

//----------------------------------------------------------------------------
//
//  Function: BuildComputerGroupMember
//
//  Synopsis: Put binding information of a group member into ppGroupMember.
//
//----------------------------------------------------------------------------
BOOL
BuildComputerGroupMember(
    HANDLE hGroup,
    DWORD  dwUserID,
    LPCOMPUTER_GROUP_MEMBER * ppGroupMember
    )
{
    DWORD                   dwTempUserID = dwUserID;
    HRESULT                 hr = S_OK;
    LPCOMPUTER_GROUP_MEMBER pGroupMember = NULL;
    LPINI_COMP_GROUP        pGroup = (LPINI_COMP_GROUP)hGroup;
    WCHAR                   szADsParent[MAX_PATH];

    //
    // Allocate one COMPUTER_GROUP_MEMBER.
    //

    pGroupMember = (LPCOMPUTER_GROUP_MEMBER)AllocADsMem(
                                                sizeof(COMPUTER_GROUP_MEMBER)
                                                );
    if (!pGroupMember) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    pGroupMember->Type = NWCOMPAT_USER_ID;

    wsprintf(
        szADsParent,
        L"%s://%s",
        szProviderName,
        pGroup->szComputerName
        );
    pGroupMember->Parent = AllocADsStr(szADsParent);

    pGroupMember->Computer = AllocADsStr(pGroup->szComputerName);

    hr = NWApiGetObjectName(
             pGroup->_hConn,
             dwTempUserID,
             &pGroupMember->Name
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppGroupMember = pGroupMember;
    return(TRUE);

error:

    if (pGroupMember) {

        if (pGroupMember->Parent)
            FreeADsStr(pGroupMember->Parent);

        if (pGroupMember->Computer)
            FreeADsStr(pGroupMember->Computer);

        FreeADsMem(pGroupMember);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: PackStrings
//
//  Synopsis:
//
//----------------------------------------------------------------------------
LPBYTE
PackStrings(
    LPWSTR *pSource,
    LPBYTE pDest,
    DWORD *DestOffsets,
    LPBYTE pEnd
    )
{
    DWORD cbStr;
    WORD_ALIGN_DOWN(pEnd);

    while (*DestOffsets != -1) {
        if (*pSource) {
            cbStr = wcslen(*pSource)*sizeof(WCHAR) + sizeof(WCHAR);
            pEnd -= cbStr;
            CopyMemory( pEnd, *pSource, cbStr);
            *(LPWSTR *)(pDest+*DestOffsets) = (LPWSTR)pEnd;
        } else {
            *(LPWSTR *)(pDest+*DestOffsets)=0;
        }
        pSource++;
        DestOffsets++;
    }
    return pEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\nwcmacro.h ===
#include "nwapi32.h"

//
// Return Code macro
//
#define NWCCODE_FAILED(Status) ((NWCCODE)(Status) != SUCCESSFUL)

#define NWCCODE_SUCCESS(Status) ((NWCCODE)(Status) == SUCCESSFUL)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\nw2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw2var.cxx
//
//  Contents:   Nw312 Object to Variant Copy Routines
//
//  Functions:
//
//  History:      06/12/96   KrishnaG created.
//                cloned off NDS conversion code.
//
//
//----------------------------------------------------------------------------

//
// NTType objects copy code
//

#include "nwcompat.hxx"
#pragma  hdrstop

void
VarTypeFreeVarObjects(
    PVARIANT pVarObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    if( !pVarObject){
        return;
    }

    for (i = 0; i < dwNumValues; i++ ) {
         VariantClear(pVarObject + i);
    }

    FreeADsMem(pVarObject);

    return;
}


HRESULT
NTTypeToVarTypeCopyBOOL(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_BOOL;

    if((pNTSrcValue->NTValue).fValue){
        lpVarDestObject->boolVal = VARIANT_TRUE;  // notation for TRUE in V_BOOL
    } else {
        lpVarDestObject->boolVal = VARIANT_FALSE;
    }

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopySYSTEMTIME(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

 lpVarDestObject->vt = VT_DATE;

    hr = ConvertSystemTimeToDATE (pNTSrcValue->NTValue.stSystemTimeValue,
                                  &lpVarDestObject->date );


    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyDWORD(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    //
    // we cast the DWORD  to a LONG
    //

    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_I4;

    lpVarDestObject->lVal = (LONG)(pNTSrcValue->NTValue).dwValue;

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyDATE(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{

    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE       date ;
    BOOL       fRetval;

    GetSystemTime( &stSystemTime);

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &stSystemTime,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    stSystemTime.wHour = (WORD)(pNTSrcValue->NTValue.dwValue)/60;
    stSystemTime.wMinute = (WORD)(pNTSrcValue->NTValue.dwValue)%60;
    stSystemTime.wSecond =0;
    stSystemTime.wMilliseconds = 0;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_DATE;

    hr = ConvertSystemTimeToDATE (stSystemTime,
                                  &date );
    BAIL_ON_FAILURE(hr);

    lpVarDestObject->date = date - (DWORD)date;

error:

    RRETURN(hr);
}


HRESULT
NTTypeToVarTypeCopyNW312DATE(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{

    HRESULT hr = S_OK;
    SYSTEMTIME stSystemTime;
    SYSTEMTIME LocalTime;
    DATE       date ;
    BOOL       fRetval;


    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_DATE;


    hr = ConvertNW312DateToVariant(
              pNTSrcValue->NTValue.Nw312Date,
              &lpVarDestObject->date
              );
    BAIL_ON_FAILURE(hr);


error:

    RRETURN(hr);
}


HRESULT
NTTypeToVarTypeCopyOctetString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

	hr = BinaryToVariant(
		(pNTSrcValue->NTValue).octetstring.dwSize,
		(pNTSrcValue->NTValue).octetstring.pByte,
		lpVarDestObject
    );

    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyLPTSTR(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    lpVarDestObject->vt = VT_BSTR;

    if(!(pNTSrcValue->NTValue).pszValue){
        lpVarDestObject->bstrVal = NULL;
        hr = S_OK;
        goto error;
    }


    if(!pNTSrcValue){
        lpVarDestObject->bstrVal = NULL;
    } else {
        hr =  ADsAllocString((pNTSrcValue->NTValue).pszValue,
                               &(lpVarDestObject->bstrVal));
    }

error:
    RRETURN(hr);
}



HRESULT
NTTypeToVarTypeCopyDelimitedString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
   HRESULT hr = S_OK;

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    } else {
        hr = DelimitedStringToVariant((pNTSrcValue->NTValue).pszValue,
                                      lpVarDestObject,
                                      TEXT(',') );
    }
    RRETURN(hr);
}

HRESULT
NTTypeToVarTypeCopyNulledString(
    PNTOBJECT     pNTSrcValue,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    if(!pNTSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpVarDestObject){
        RRETURN(E_POINTER);
    }

    if(!(pNTSrcValue->NTValue).pszValue){
        RRETURN(E_POINTER);
    }

    hr = NulledStringToVariant((pNTSrcValue->NTValue).pszValue,
                               lpVarDestObject );

    RRETURN(hr);
}


HRESULT
NtTypeToVarTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {
    case NT_SYNTAX_ID_BOOL:
        hr = NTTypeToVarTypeCopyBOOL(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = NTTypeToVarTypeCopySYSTEMTIME(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_DWORD:
        hr = NTTypeToVarTypeCopyDWORD(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = NTTypeToVarTypeCopyDATE(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_NW312DATE:
        hr = NTTypeToVarTypeCopyNW312DATE(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;


    case NT_SYNTAX_ID_LPTSTR:
        hr = NTTypeToVarTypeCopyLPTSTR(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:

        hr = NTTypeToVarTypeCopyDelimitedString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_NulledString :
        hr = NTTypeToVarTypeCopyNulledString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    case NT_SYNTAX_ID_OCTETSTRING :
        hr = NTTypeToVarTypeCopyOctetString(
                lpNtSrcObject,
                lpVarDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
NtTypeToVarTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    PVARIANT pVarDestObjects
    )
{

    long i = 0;
    HRESULT hr = S_OK;

    VariantInit(pVarDestObjects);

    //
    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumObjects;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumObjects; i++ )
    {
        VARIANT v;

        VariantInit(&v);
        hr = NtTypeToVarTypeCopy( pNtSrcObjects + i,
                                  &v );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\macro.h ===
//
// This is a macro which is ONLY used in CNWCOMPATUser::SetAccountRestrictions.
//

#define GET_LOGIN_CONTROL()             \
        if (fUmOK == FALSE) {           \
                                        \
            hr = NWApiGetLOGIN_CONTROL( \
                     hConn,             \
                     _Name,             \
                     &LoginCtrl         \
                     );                 \
            BAIL_ON_FAILURE(hr);        \
                                        \
            fUmOK = TRUE;               \
        }

//
// NCP Reply buffer macro.
//

#define INIT_RPLY_SGMT(RS)          \
        RS## = new RPLY_SGMT_LST;   \
        if (!##RS##) {              \
            RRETURN(E_OUTOFMEMORY); \
        }                           \
        RS##->lpNext = NULL;

#define DELETE_LIST(ptr)                    \
        if (##ptr##) {                      \
            do {                            \
                lpTemp = (##ptr##)->lpNext; \
                delete (##ptr##);           \
                (##ptr##) = lpTemp;         \
            } while (##ptr##);              \
        }

//
// Misc Macro.
//

#define ADSFREESTRING(str)          \
        if (##str##) {                \
            ADsFreeString(##str##); \
        }

//
// Error flow control macro.
//

#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);

#define BAIL_IF_ERROR(hr)     \
        if (FAILED(hr)) {     \
                goto cleanup; \
        }                     \

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {   \
                goto error; \
        }                   \

//
// DEFINE_IDispatch_Implementation_Unimplemented
//

#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                               \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)           \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}                                                          \
                                                           \
STDMETHODIMP                                               \
cls::GetTypeInfo(                                          \
         unsigned int itinfo,                              \
         LCID lcid,                                        \
         ITypeInfo FAR* FAR* pptinfo                       \
         )                                                 \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}                                                          \
                                                           \
STDMETHODIMP                                               \
cls::GetIDsOfNames(                                        \
         REFIID iid,                                       \
         LPWSTR FAR* rgszNames,                            \
         unsigned int cNames,                              \
         LCID lcid,                                        \
         DISPID FAR* rgdispid                              \
         )                                                 \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}                                                          \
                                                           \
STDMETHODIMP                                               \
cls::Invoke(                                               \
         DISPID dispidMember,                              \
         REFIID iid, LCID lcid,                            \
         unsigned short wFlags,                            \
         DISPPARAMS FAR* pdispparams,                      \
         VARIANT FAR* pvarResult,                          \
         EXCEPINFO FAR* pexcepinfo,                        \
         unsigned int FAR* puArgErr                        \
         )                                                 \
{                                                          \
    RRETURN(E_NOTIMPL);                                    \
}

//
// DEFINE_IDispatch_Implementation
//

#define DEFINE_IDispatch_Implementation(cls)       \
STDMETHODIMP                                       \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)   \
{                                                  \
    RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo)); \
}                                                  \
                                                   \
STDMETHODIMP                                       \
cls::GetTypeInfo(                                  \
         unsigned int itinfo,                      \
         LCID lcid,                                \
         ITypeInfo FAR* FAR* pptinfo)              \
{                                                  \
    RRETURN(_pDispMgr->GetTypeInfo(                \
                           itinfo,                 \
                           lcid,                   \
                           pptinfo                 \
                           ));                     \
}                                                  \
                                                   \
STDMETHODIMP                                       \
cls::GetIDsOfNames(                                \
         REFIID iid,                               \
         LPWSTR FAR* rgszNames,                    \
         unsigned int cNames,                      \
         LCID lcid,                                \
         DISPID FAR* rgdispid                      \
         )                                         \
{                                                  \
    RRETURN(_pDispMgr->GetIDsOfNames(              \
                           iid,                    \
                           rgszNames,              \
                           cNames,                 \
                           lcid,                   \
                           rgdispid                \
                           ));                     \
}                                                  \
                                                   \
STDMETHODIMP                                       \
cls::Invoke(                                       \
         DISPID dispidMember,                      \
         REFIID iid,                               \
         LCID lcid,                                \
         unsigned short wFlags,                    \
         DISPPARAMS FAR* pdispparams,              \
         VARIANT FAR* pvarResult,                  \
         EXCEPINFO FAR* pexcepinfo,                \
         unsigned int FAR* puArgErr                \
         )                                         \
{                                                  \
    RRETURN (_pDispMgr->Invoke(                    \
                            dispidMember,          \
                            iid,                   \
                            lcid,                  \
                            wFlags,                \
                            pdispparams,           \
                            pvarResult,            \
                            pexcepinfo,            \
                            puArgErr               \
                            ));                    \
}                                                  \

//
// DEFINE_IADs_Implementation
//

#define DEFINE_IADs_Implementation(cls)  \
STDMETHODIMP                               \
cls::get_Name(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreName(retval));         \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_ADsPath(THIS_ BSTR FAR* retval) \
{                                          \
    RRETURN(get_CoreADsPath(retval));    \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Class(THIS_ BSTR FAR* retval)     \
{                                          \
    RRETURN(get_CoreADsClass(retval));   \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Parent(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreParent(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Schema(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreSchema(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_GUID(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreGUID(retval));         \
}                                          \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(GetInfo());                                               \
}

//
// DEFINE_IADs_Implementation
//

#define DEFINE_IADs_TempImplementation(cls)  \
STDMETHODIMP                               \
cls::get_Name(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreName(retval));         \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_ADsPath(THIS_ BSTR FAR* retval) \
{                                          \
    RRETURN(get_CoreADsPath(retval));    \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Class(THIS_ BSTR FAR* retval)     \
{                                          \
    RRETURN(get_CoreADsClass(retval));   \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Parent(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreParent(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_Schema(THIS_ BSTR FAR* retval)    \
{                                          \
    RRETURN(get_CoreSchema(retval));       \
}                                          \
                                           \
STDMETHODIMP                               \
cls::get_GUID(THIS_ BSTR FAR* retval)      \
{                                          \
    RRETURN(get_CoreGUID(retval));         \
}                                          \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(GetInfo());                                               \
}










#define DEFINE_IADs_PutGetImplementation(cls, SchemaClassTable, dwTableSize)                   \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericGetPropertyManager(                                   \
                _pPropertyCache,                                      \
                bstrName,                                             \
                pvProp                                                \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericPutPropertyManager(                                   \
                _pPropertyCache,                                      \
                SchemaClassTable,                                     \
                dwTableSize,                                          \
                bstrName,                                             \
                vProp                                                 \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericGetExPropertyManager(                                 \
                GetObjectState(),                                     \
                _pPropertyCache,                                      \
                bstrName,                                             \
                pvProp                                                \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = GenericPutExPropertyManager(                                 \
                _pPropertyCache,                                      \
                SchemaClassTable,                                     \
                dwTableSize,                                          \
                bstrName,                                             \
                vProp                                                 \
                );                                                    \
                                                                      \
    RRETURN(hr);                                                      \
}


#define DEFINE_IADsPropertyList_Implementation(cls, SchemaClassTable, dwTableSize)                 \
STDMETHODIMP                                                                                       \
cls::get_PropertyCount(THIS_ long  FAR * plCount)                                                  \
{                                                                                                  \
    HRESULT hr = E_FAIL;                                                                           \
                                                                                                   \
    hr = GenericPropCountPropertyManager(                                                          \
                _pPropertyCache,                                                                   \
                plCount                                                                            \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Next(THIS_ VARIANT FAR *pVariant)                                                             \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericNextPropertyManager(                                                               \
                    _pPropertyCache,                                                               \
                    pVariant                                                                       \
                    );                                                                             \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Skip(THIS_ long cElements)                                                                   \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
                                                                                                   \
    hr = GenericSkipPropertyManager(                                                               \
                    _pPropertyCache,                                                               \
                    cElements                                                                      \
                    );                                                                             \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::Reset()                                                                                       \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericResetPropertyManager(                                                              \
                _pPropertyCache                                                                    \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::ResetPropertyItem(THIS_ VARIANT varEntry)                                                    \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericDeletePropertyManager(                                                             \
                    _pPropertyCache,                                                               \
                    varEntry                                                                       \
                    );                                                                             \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::GetPropertyItem(THIS_ BSTR bstrName, LONG lnADsType, VARIANT * pVariant)                      \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericGetPropItemPropertyManager(                                                        \
                _pPropertyCache,                                                                   \
                GetObjectState(),                                                                  \
                bstrName,                                                                          \
                lnADsType,                                                                         \
                pVariant                                                                           \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
                                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::PutPropertyItem(THIS_ VARIANT varData)                                                        \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericPutPropItemPropertyManager(                                                        \
                _pPropertyCache,                                                                   \
                SchemaClassTable,                                                                  \
                dwTableSize,                                                                       \
                varData                                                                            \
                );                                                                                 \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   \
STDMETHODIMP                                                                                       \
cls::PurgePropertyList(THIS_)                                                                      \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericPurgePropertyManager(                                                              \
                _pPropertyCache                                                                    \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
STDMETHODIMP                                                                                       \
cls::Item(THIS_ VARIANT varIndex, VARIANT * pVariant)                                              \
{                                                                                                  \
    HRESULT hr = S_OK;                                                                             \
                                                                                                   \
    hr = GenericItemPropertyManager(                                                               \
                _pPropertyCache,                                                                   \
                GetObjectState(),                                                                  \
                varIndex,                                                                          \
                pVariant                                                                           \
                );                                                                                 \
                                                                                                   \
                                                                                                   \
    RRETURN(hr);                                                                                   \
}                                                                                                  \
                                                                                                   

#define DEFINE_IDispatch_ExtMgr_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pExtMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pExtMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\nw3utils.cxx ===
#include "NWCOMPAT.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: NWApiGetProperty
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetProperty(
    BSTR bstrObjectName,
    LPSTR lpszPropertyName,
    NWOBJ_TYPE dwOT_ID,
    NWCONN_HANDLE hConn,
    LPP_RPLY_SGMT_LST lppReplySegment,
    LPDWORD pdwNumSegment
    )
{
    CHAR             szObjectName[(OBJ_NAME_SIZE + 1)*2];
    NWFLAGS          pucMoreFlag = 0;
    NWFLAGS          pucPropFlag = 0;
    unsigned char    ucSegment = 1;
    LP_RPLY_SGMT_LST lpHeadReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTempReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    HRESULT          hr = S_OK;
    NWCCODE          usRet = 0;

    //
    // lppReplySegment is assumed to be NULL.
    //

    ADsAssert((*lppReplySegment) == NULL);

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    
    if (wcslen(bstrObjectName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    UnicodeToAnsiString(
        bstrObjectName,
        szObjectName,
        0
        );

    //
    // Initialize first node of the list and set up temp traversal pointer.
    //

    INIT_RPLY_SGMT(lpTempReplySegment);
    lpHeadReplySegment = lpTempReplySegment;

    //
    // Read & dump property values into linked-list.
    //

    do {

       usRet = NWCReadPropertyValue(
                   hConn,
                   szObjectName,
                   dwOT_ID,
                   lpszPropertyName,
                   ucSegment,
                   lpTempReplySegment->Segment,
                   &pucMoreFlag,
                   &pucPropFlag
                   );
       hr = HRESULT_FROM_NWCCODE(usRet);

       BAIL_ON_FAILURE(hr);

       if (pucMoreFlag) {

           INIT_RPLY_SGMT(lpTempReplySegment->lpNext);
           lpTempReplySegment = lpTempReplySegment->lpNext;

          ucSegment++;
       }

    } while(pucMoreFlag);

    //
    // Return the resulting linked-list.
    //

    *lppReplySegment = lpHeadReplySegment;
    *pdwNumSegment = ucSegment;

error:
    if (FAILED(hr) && lpHeadReplySegment) {

        DELETE_LIST(lpHeadReplySegment);
    }

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetFileServerVersionInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetFileServerVersionInfo(
    NWCONN_HANDLE hConn,
    VERSION_INFO  *pVersionInfo
    )
{
    NWCCODE usRet = SUCCESSFUL;
    HRESULT hr = S_OK;

    usRet = NWCGetFileServerVersionInfo(
                hConn,
                pVersionInfo
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiIsObjectInSet
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiIsObjectInSet(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    LPSTR lpszPropertyName,
    LPSTR lpszMemberName,
    NWOBJ_TYPE wMemberType
    )
{
    CHAR szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Call NWCIsObjectInSet.
    //

    usRet = NWCIsObjectInSet(
                hConn,
                szAnsiObjectName,
                wObjType,
                lpszPropertyName,
                lpszMemberName,
                wMemberType
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetObjectID
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetObjectID(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    NWOBJ_ID *pObjectID
    )
{
    CHAR szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Get Object's ID.
    //

    usRet = NWCGetObjectID(
                hConn,
                szAnsiObjectName,
                wObjType,
                pObjectID
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGroupGetMembers
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGroupGetMembers(
    NWCONN_HANDLE hConn,
    LPWSTR szGroupName,
    LPBYTE *lppBuffer
    )
{
    DWORD   dwNumSegment = 0;
    HRESULT hr = S_OK;
    DWORD   i;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;

    //
    // Assert
    //

    ADsAssert(*lppBuffer == NULL);

    //
    // Get GROUP_MEMBERS.
    //

    hr = NWApiGetProperty(
             szGroupName,
             NW_PROP_GROUP_MEMBERS,
             OT_USER_GROUP,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pack returned linked list into buffer.
    //

    *lppBuffer = (LPBYTE) AllocADsMem(
                           dwNumSegment * REPLY_VALUE_SIZE
                           );
    if (!(*lppBuffer)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpTemp = lpReplySegment;

    for (i = 0; i < dwNumSegment; i++) {
        memcpy(
            *lppBuffer + i * REPLY_VALUE_SIZE,
            lpTemp->Segment,
            REPLY_VALUE_SIZE
            );
        lpTemp = lpTemp->lpNext;
    }

error:

    //
    // Clean up.
    //

    lpTemp = NULL;

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}
//----------------------------------------------------------------------------
//
//  Function: NWApiAddGroupMember
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiAddGroupMember(
    NWCONN_HANDLE hConn,
    LPWSTR pszGroupName,
    LPWSTR pszMemberName
    )
{
    CHAR    szGroupName[(OBJ_NAME_SIZE + 1)*2];
    CHAR    szMemberName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(pszGroupName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }
    
    if (wcslen(pszMemberName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    UnicodeToAnsiString(
        pszGroupName,
        szGroupName,
        0
        );

    UnicodeToAnsiString(
        pszMemberName,
        szMemberName,
        0
        );

    //
    // Modify GROUP_MEMBERS property of the group to include the new member.
    //

    usRet = NWCAddObjectToSet(
                hConn,
                szGroupName,
                OT_USER_GROUP,
                "GROUP_MEMBERS",
                szMemberName,
                OT_USER
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Modify GROUPS_I'M_IN property of the new member to reflect its included
    // in the new group.
    //

    usRet = NWCAddObjectToSet(
                hConn,
                szMemberName,
                OT_USER,
                "GROUPS_I'M_IN",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Modify SECURITY_EQUALS property of the new member to equate its security
    // to that of the new group it just joined.
    //

    usRet = NWCAddObjectToSet(
                hConn,
                szMemberName,
                OT_USER,
                "SECURITY_EQUALS",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiRemoveGroupMember
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiRemoveGroupMember(
    NWCONN_HANDLE hConn,
    LPWSTR pszGroupName,
    LPWSTR pszMemberName
    )
{
    CHAR    szGroupName[(OBJ_NAME_SIZE + 1)*2];
    CHAR    szMemberName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(pszGroupName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }
    
    if (wcslen(pszMemberName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    UnicodeToAnsiString(
        pszGroupName,
        szGroupName,
        0
        );

    UnicodeToAnsiString(
        pszMemberName,
        szMemberName,
        0
        );

    //
    // Modify SECURITY_EQUALS property of the removed member to break its
    // security tie with the group it joined.
    //

    usRet = NWCDeleteObjectFromSet(
                hConn,
                szMemberName,
                OT_USER,
                "SECURITY_EQUALS",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Modify GROUPS_I'M_IN property of the new member to reflect it is not
    // included in the group anymore.
    //

    usRet = NWCDeleteObjectFromSet(
                hConn,
                szMemberName,
                OT_USER,
                "GROUPS_I'M_IN",
                szGroupName,
                OT_USER_GROUP
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Modify GROUP_MEMBERS property of the group to remove the member.
    //

    usRet = NWCDeleteObjectFromSet(
                hConn,
                szGroupName,
                OT_USER_GROUP,
                "GROUP_MEMBERS",
                szMemberName,
                OT_USER
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

error:
    RRETURN(hr);

}
//----------------------------------------------------------------------------
//
//  Function: NWApiGetLOGIN_CONTROL
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetLOGIN_CONTROL(
    NWCONN_HANDLE hConn,
    LPWSTR lpszUserName,
    LPLC_STRUCTURE lpLoginCtrlStruct
    )
{
    DWORD            dwNumSegment = 0;
    HRESULT          hr = S_OK;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;

    hr = NWApiGetProperty(
             lpszUserName,
             NW_PROP_LOGIN_CONTROL,
             OT_USER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    *lpLoginCtrlStruct = *((LPLC_STRUCTURE) lpReplySegment->Segment);

error:

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetDefaultAcctExpDate
//
//  Synopsis: This function looks at the local time and returns a default value
//            for an account expiration date in a variant date.
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetDefaultAcctExpDate(
    DOUBLE * pdTime,
    SYSTEMTIME SysTime
    )
{
    DOUBLE  vTime;
    HRESULT hr = S_OK;

    //
    // According to SysCon, the default account expiration date is the first day
    // of the following month.
    //

    if (SysTime.wMonth == 12) {
        SysTime.wMonth = 1;
    }
    else {
        SysTime.wMonth++;
    }

    SysTime.wDay = 1;

    //
    // Subtract 1980 from wYear for NWApiMakeVariantTime.
    //

    SysTime.wYear -= 1980;

    hr = NWApiMakeVariantTime(
             &vTime,
             SysTime.wDay,
             SysTime.wMonth,
             SysTime.wYear,
             0,0,0
             );
    BAIL_ON_FAILURE(hr);

    *pdTime = vTime;

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiUserAsSupervisor
//
//  Synopsis: This functions turns the user into one of the supervisors if TRUE
//            is passed.  User's supervisor privilege is removed otherwise.
//
//----------------------------------------------------------------------------
HRESULT
NWApiUserAsSupervisor(
    NWCONN_HANDLE hConn,
    LPWSTR lpszUserName,
    BOOL fSupervisor
    )
{
    CHAR    szUserName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszUserName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        lpszUserName,
        szUserName,
        0
        );

    //
    // Make it a supervisor.
    //

    if (fSupervisor == TRUE) {
        usRet = NWCAddObjectToSet(
                    hConn,
                    szUserName,
                    OT_USER,
                    "SECURITY_EQUALS",
                    "SUPERVISOR",
                    OT_USER
                    );
    }

    //
    // Remove supervisor privilege.
    //

    else {
        usRet = NWCDeleteObjectFromSet(
                    hConn,
                    szUserName,
                    OT_USER,
                    "SECURITY_EQUALS",
                    "SUPERVISOR",
                    OT_USER
                    );
    }

    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiGetVolumeNumber
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetVolumeNumber(
    NWCONN_HANDLE hConn,
    LPWSTR lpszVolumeName,
    NWVOL_NUM *pVolumeNumber
    )
{
    CHAR    szVolumeName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszVolumeName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        lpszVolumeName,
        szVolumeName,
        0
        );

    //
    // Get Volume's number.
    //

    usRet = NWCGetVolumeNumber(
                hConn,
                szVolumeName,
                pVolumeNumber
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiGetVolumeName
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetVolumeName(
    NWCONN_HANDLE hConn,
    NWVOL_NUM bVolNum,
    LPWSTR *lppszVolName
    )
{
    CHAR    szVolumeName[OBJ_NAME_SIZE + 1];
    HRESULT hr = S_OK;
    LPWSTR  lpszTemp = NULL;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Get Volume's name.
    //

    usRet = NWCGetVolumeName(
                hConn,
                bVolNum,
                szVolumeName
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Convert result into Unicode.
    //

    lpszTemp = AllocateUnicodeString(szVolumeName);
    if (!lpszTemp) {
       RRETURN(E_OUTOFMEMORY);
    }

    *lppszVolName = AllocADsStr(lpszTemp);
    if (!(*lppszVolName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    FreeUnicodeString(lpszTemp);

    //
    // Return.
    //

    RRETURN(hr);

error:

    *lppszVolName = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiEnumJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiEnumJobs(
    HANDLE hPrinter,
    DWORD dwFirstJob,
    DWORD dwNoJobs,
    DWORD dwLevel,
    LPBYTE *lplpbJobs,
    DWORD *pcbBuf,
    LPDWORD lpdwReturned
    )
{
    BOOL    fStatus = TRUE;
    HRESULT hr = S_OK;

    fStatus = WinNTEnumJobs(
                  hPrinter,
                  dwFirstJob,
                  dwNoJobs,
                  dwLevel,
                  lplpbJobs,
                  pcbBuf,
                  lpdwReturned
                  );

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiGetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters
    )
{
    BOOL    fStatus = TRUE;
    HRESULT hr = S_OK;

    fStatus = WinNTGetPrinter(
                  hPrinter,
                  dwLevel,
                  lplpbPrinters
                  );

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiUncFromADsPath
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiUncFromADsPath(
    LPWSTR lpszADsPath,
    LPWSTR lpszUncName
    )
{
    HRESULT hr;
    POBJECTINFO pObjectInfo = NULL;

    hr = BuildObjectInfo(lpszADsPath,
                         &pObjectInfo );

    BAIL_ON_FAILURE(hr);

   wsprintf(
        lpszUncName,
        L"\\\\%s\\%s",
        pObjectInfo->ComponentArray[0],
        pObjectInfo->ComponentArray[1]
        );

error:
    if(pObjectInfo){
        FreeObjectInfo(pObjectInfo);
    }
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiMakeUserInfo
//
//  Synopsis: This function is very provider specific.
//
//----------------------------------------------------------------------------
HRESULT
NWApiMakeUserInfo(
    LPWSTR lpszBinderyName,
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    PNW_USER_INFO pNwUserInfo
    )
{
    HRESULT hr = S_OK;
    NW_USER_INFO NwUserInfo = {NULL, NULL, NULL, NULL};

    hr = NWApiGetBinderyHandle(
             &NwUserInfo.hConn,
             lpszBinderyName
             );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(lpszBinderyName, &NwUserInfo.lpszBinderyName);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(lpszUserName, &NwUserInfo.lpszUserName);
    BAIL_ON_FAILURE(hr);

    if (lpszPassword) {

        hr = ADsAllocString(lpszPassword, &NwUserInfo.lpszPassword);
        BAIL_ON_FAILURE(hr);
    }

    //
    // Return.
    //

    *pNwUserInfo = NwUserInfo;
    RRETURN(hr);

error:
    if (NwUserInfo.lpszBinderyName)
        ADsFreeString(NwUserInfo.lpszBinderyName);

    if (NwUserInfo.lpszUserName)
        ADsFreeString(NwUserInfo.lpszUserName);

    if (NwUserInfo.lpszPassword) {
        SecureZeroMemory(NwUserInfo.lpszPassword, wcslen(NwUserInfo.lpszPassword) * sizeof(WCHAR));
        ADsFreeString(NwUserInfo.lpszPassword);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiFreeUserInfo
//
//  Synopsis: This function is very provider specific.
//
//----------------------------------------------------------------------------
HRESULT
NWApiFreeUserInfo(
    PNW_USER_INFO pNwUserInfo
    )
{
    HRESULT hr = S_OK;

    if (pNwUserInfo->lpszBinderyName) {
        ADsFreeString(pNwUserInfo->lpszBinderyName);
        pNwUserInfo->lpszBinderyName = NULL ;
    }

    if (pNwUserInfo->lpszUserName) {
        ADsFreeString(pNwUserInfo->lpszUserName);
        pNwUserInfo->lpszUserName = NULL;
    }

    if (pNwUserInfo->lpszPassword) {
        SecureZeroMemory(pNwUserInfo->lpszPassword, wcslen(pNwUserInfo->lpszPassword) * sizeof(WCHAR));
        ADsFreeString(pNwUserInfo->lpszPassword);
        pNwUserInfo->lpszPassword = NULL;
    }

    if (pNwUserInfo->hConn) {
        hr = NWApiReleaseBinderyHandle(
                 pNwUserInfo->hConn
                 );
        BAIL_ON_FAILURE(hr);
    }

error:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateUser(
    PNW_USER_INFO pNwUserInfo
    )
{
    HRESULT       hr = S_OK;
    HRESULT       hrTemp = S_OK;
    NTSTATUS      Status = STATUS_SUCCESS;
    NWCCODE       usRet = SUCCESSFUL;
    NWCONN_HANDLE hConn = NULL;
    NWOBJ_ID      UserObjectID;
    UCHAR         ChallengeKey[8];
    UCHAR         NewKeyedPassword[17];
    UCHAR         ValidationKey[8];
    WCHAR         szTemp[MAX_PATH];

    //
    // "Create Bindery Object" - user object.  This user object is going to be
    // static, with access equals to logged read, supervisor write.
    //

    hr = NWApiCreateBinderyObject(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             BF_STATIC,
             BS_LOGGED_READ | BS_SUPER_WRITE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Add user password.
    //

    hr = NWApiSetUserPassword(
             pNwUserInfo,
             &UserObjectID,
             NULL                 // no old passwd - this is a SET
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create necessary bindery property to facilitate the addition of this user
    // to the group EVERYONE.
    //

    hr = NWApiCreateProperty(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             "GROUPS_I'M_IN",
             BF_SET
             );
    BAIL_ON_FAILURE(hr);

    hr = NWApiCreateProperty(
             pNwUserInfo->hConn,
             pNwUserInfo->lpszUserName,
             OT_USER,
             "SECURITY_EQUALS",
             BF_SET
             );
    BAIL_ON_FAILURE(hr);

    //
    // Add this user to the group EVERYONE.
    // (okay if this fails, EVERYONE might not exist)
    //

    wcscpy(szTemp, L"EVERYONE");

    hrTemp = NWApiAddGroupMember(
                pNwUserInfo->hConn,
                szTemp,
                pNwUserInfo->lpszUserName
                );

    //
    // Create mail directory and login files.
    // (okay if this fails)
    //

    hrTemp = NWApiCreateMailDirectory(
                pNwUserInfo,
                UserObjectID
                );

    //
    // Create LOGIN_CONTROL & ACCOUNT_BALANCE property for the user.  Values
    // from USER_DEFAULTS are used as default.
    //

    hr = NWApiSetLoginCtrlAndAcctBalance(
             pNwUserInfo
             );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteUser
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeleteUser(
    POBJECTINFO pObjectInfo
    )
{
    BOOL          err = TRUE;
    DWORD         dwErr = 0;
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;
    NWOBJ_ID      ObjectID;
    WCHAR         szPath[MAX_PATH];

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get the user's ObjectID which is needed to compose the path name of LOGIN
    // and LOGIN.OS2.
    //

    hr = NWApiGetObjectID(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER,
             &ObjectID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Delete SYS:MAIL\<JOBID>\LOGIN.  If the file is not found, that's OK, as
    // long as it is not there.
    //

    wsprintf(
        szPath,
        L"\\\\%s\\SYS\\MAIL\\%X\\LOGIN",
        pObjectInfo->ComponentArray[0],
        dwSWAP(ObjectID)
        );

    err = DeleteFile(szPath);

    //
    // Remove any error checking for the cleanup of
    // files. If they do exist, and we do clean them up
    // great. But otherwise Win95 chokes on us.
    //

    //
    // Delete SYS:MAIL\<JOBID>\LOGIN.OS2.  If the file is not found, that's OK,
    // as long as it is not there.
    //

    wsprintf(
        szPath,
        L"\\\\%s\\SYS\\MAIL\\%X\\LOGIN.OS2",
        pObjectInfo->ComponentArray[0],
        dwSWAP(ObjectID)
        );

    err = DeleteFile(szPath);

    //
    // Remove any error checking for the cleanup of
    // files. If they do exist, and we do clean them up
    // great. But otherwise Win95 chokes on us.
    //

    //
    // Delete SYS:MAIL\<JOBID>.
    //

    wsprintf(
        szPath,
        L"\\\\%s\\SYS\\MAIL\\%X",
        pObjectInfo->ComponentArray[0],
        dwSWAP(ObjectID)
        );

    err = RemoveDirectory(szPath);

    //
    // Remove any error checking for the cleanup of
    // files. If they do exist, and we do clean them up
    // great. But otherwise Win95 chokes on us.
    //


    //
    // Delete the user object.
    //

    hr = NWApiDeleteBinderyObject(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateBinderyObject
//
//  Synopsis: This function create the specified object in the specified NetWare
//            bindery.  It returns S_OK if the object alread exist.
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateBinderyObject(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    NWFLAGS ucObjectFlags,
    NWFLAGS usObjSecurity
    )
{
    CHAR szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Create a Static object with LOGGED_READ & SUPERVISOR_WRITE.
    //

    usRet = NWCCreateObject(
                hConn,
                szAnsiObjectName,
                wObjType,
                BF_STATIC,
                BS_LOGGED_READ | BS_SUPER_WRITE
                );
    //
    // If an error occured, check if it is OBJECT_ALREADY_EXISTS.  If it is,
    // treat it as no error.
    //

    if (usRet) {
        if (usRet == OBJECT_ALREADY_EXISTS) {
            usRet = SUCCESSFUL;
        }
    }

    //
    // Return.
    //

    hr = HRESULT_FROM_NWCCODE(usRet);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteBinderyObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeleteBinderyObject(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType
    )
{
    CHAR szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Delete the object from the bindery.
    //

    usRet = NWCDeleteObject(
                hConn,
                szAnsiObjectName,
                wObjType
                );
    //
    // Return.
    //

    hr = HRESULT_FROM_NWCCODE(usRet);
    RRETURN(hr);
}

#define            NW_MAX_PASSWORD_LEN    256

//----------------------------------------------------------------------------
//
//  Function: NWApiSetUserPassword
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetUserPassword(
    PNW_USER_INFO pNwUserInfo,
    DWORD *pdwUserObjID,
    LPWSTR pszOldPassword
    )
{
    CHAR           szAnsiUserName[(OBJ_NAME_SIZE + 1)*2];
    CHAR           szAnsiPassword[(NW_MAX_PASSWORD_LEN + 1)*2];
    CHAR           szAnsiOldPassword[(NW_MAX_PASSWORD_LEN + 1)*2];
    CHAR           Buffer[128];
    DWORD          err = 0;
    HRESULT        hr = S_OK;
    LC_STRUCTURE   LoginCtrl;
    NTSTATUS       NtStatus;
    UCHAR          ChallengeKey[8];
    UCHAR          ucMoreFlag;
    UCHAR          ucPropFlag;
    WCHAR          szOldPasswordCopy[NW_MAX_PASSWORD_LEN + 1];

    if ( !pNwUserInfo ||
         !(pNwUserInfo->lpszUserName) ||
         !(pNwUserInfo->lpszPassword) ) {

        hr = E_INVALIDARG ;
        BAIL_ON_FAILURE(hr);
    }

    if ( (wcslen(pNwUserInfo->lpszUserName) > OBJ_NAME_SIZE) ||
         (wcslen(pNwUserInfo->lpszPassword) > NW_MAX_PASSWORD_LEN) ||
         ( pszOldPassword && (wcslen(pszOldPassword) > NW_MAX_PASSWORD_LEN)) ) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Convert UNICODE into ANSI representation required by NW APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    err = UnicodeToAnsiString(
        pNwUserInfo->lpszUserName,
        szAnsiUserName,
        0
        );
    if (!err) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    _wcsupr(pNwUserInfo->lpszPassword) ;
    err = UnicodeToAnsiString(
        pNwUserInfo->lpszPassword,
        szAnsiPassword,
        0
        );
    if (!err) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (pszOldPassword) {
        wcscpy(szOldPasswordCopy, pszOldPassword);
        _wcsupr(szOldPasswordCopy) ;
        err = UnicodeToAnsiString(
            szOldPasswordCopy,
            szAnsiOldPassword,
            0
            );
        if (!err) {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

    }
    else {

        szAnsiOldPassword[0] = 0 ;
    }

    //
    // Get challenge key.
    //

    err = NWApiMapNtStatusToDosError(
              NWPGetChallengeKey(
                  pNwUserInfo->hConn,
                  ChallengeKey
                  ));

    if (!err) {

        //
        // For NetWare 4.x servers, this has to be done after the
        // NWPGetChallengeKey so that the object id returned can be used to
        // encrypt the password. 4.x bindery emulation might return different
        // object ids for some users depending on whether the NWPGetChallengeKey
        // is called beforehand.
        //

        err = NWApiMapNtStatusToDosError(
                  NWPGetObjectID(
                      pNwUserInfo->hConn,
                      szAnsiUserName,
                      OT_USER,
                      pdwUserObjID
                      ));
    }


    if (!err) {

        //
        // The old password and object ID make up the 17-byte Vold. This is used
        // later to form the 17-byte Vc for changing password on the server.
        //

        UCHAR ValidationKey[8];
        UCHAR NewKeyedPassword[17];

        EncryptChangePassword(
            (PUCHAR) szAnsiOldPassword,
            (PUCHAR) szAnsiPassword,
            *pdwUserObjID,
            ChallengeKey,
            ValidationKey,
            NewKeyedPassword
            );

        err = NWApiMapNtStatusToDosError(
                  NWPChangeObjectPasswordEncrypted(
                      pNwUserInfo->hConn,
                      szAnsiUserName,
                      OT_USER,
                      ValidationKey,
                      NewKeyedPassword
                      ));
    }

    //
    // Return.
    //

    hr = HRESULT_FROM_WIN32(err);


error:

    SecureZeroMemory(szAnsiPassword, sizeof(szAnsiPassword));
    SecureZeroMemory(szAnsiOldPassword, sizeof(szAnsiOldPassword));
    SecureZeroMemory(szOldPasswordCopy, sizeof(szOldPasswordCopy));

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateMailDirectory
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateMailDirectory(
    PNW_USER_INFO pNwUserInfo,
    NWOBJ_ID UserObjID
    )
{
    BYTE    szPath[(MAX_PATH + 1) * sizeof(WCHAR)];
    CHAR    szUserObjID[255];
    DWORD   err = 0;
    HRESULT hr = S_OK;

    //
    // Make path.
    //

    _ltoa(
        dwSWAP(UserObjID),
        szUserObjID,
        16
        );

    strcpy((char *) szPath, "SYS:\\MAIL\\");
    strcat((char *) szPath, szUserObjID);

    //
    // Create a directory with Maximum rights mask.
    //

    err = NWApiMapNtStatusToDosError(
              NWPCreateDirectory(
                  pNwUserInfo->hConn,
                  0,
                  (char *) szPath,
                  0xFF // From SysCon --- Max. access rights for directory
                  ));  //   = Full Access
                  
    if ( !err ) {
        //
        // Add a trustee with all rights except PARENTAL right.
        //

        err = NWApiMapNtStatusToDosError(
                  NWPAddTrustee(
                      pNwUserInfo->hConn,
                      0,
                      (char *) szPath,
                      UserObjID,
                      0xDF  // From SysCon --- Trustee has all rights
                      ));   //   EXCEPT parental rights (right to create/
                            //   delete subdirs, make others trustees)
        //
        // Create a Login file.
        //

        if ( !err ) {
            HANDLE hFile;

            wsprintfW(
                (LPWSTR) szPath,
                L"\\\\%ws\\SYS\\MAIL\\%X\\LOGIN",
                pNwUserInfo->lpszBinderyName,
                dwSWAP(UserObjID)
                );

            hFile = CreateFile(
                        (LPWSTR) szPath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        0
                        );

            if ( hFile == INVALID_HANDLE_VALUE ) {
                err = GetLastError();
            }

            if ( !err )
                CloseHandle( hFile );


            if (!err) {
            
                //
                // Create a Login.os2 file.
                //

                wsprintfW(
                    (LPWSTR) szPath,
                    L"\\\\%ws\\SYS\\MAIL\\%X\\LOGIN.OS2",
                    pNwUserInfo->lpszBinderyName,
                    dwSWAP(UserObjID)
                    );

                hFile = CreateFile(
                            (LPWSTR) szPath,
                            GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            0
                            );

                if ( hFile == INVALID_HANDLE_VALUE ) {
                    err = GetLastError();
                }

                if ( !err )
                    CloseHandle( hFile );

            }
        }
    }

    // err == 255 == "FAILURE"
    // might be used to indicate directory already exists,
    // but also used to signal generic failure

    hr = HRESULT_FROM_WIN32(err);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetLoginCtrlAndAcctBalance
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetLoginCtrlAndAcctBalance(
    PNW_USER_INFO pNwUserInfo
    )
{
    ACCT_BALANCE     AccountBalance;
    DWORD            dwNumSegment;
    HRESULT          hr = S_OK;
    int              i = 0;
    LC_STRUCTURE     LoginCtrl;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    USER_DEFAULT     UserDefault;
    WCHAR            szTemp[MAX_PATH];

    //
    // Get Supervisor's USER_DEFAULTS.
    //

    wcscpy(szTemp, NW_PROP_SUPERVISORW);

    hr = NWApiGetProperty(
             szTemp,
             NW_PROP_USER_DEFAULTS,
             OT_USER,
             pNwUserInfo->hConn,
             &lpReplySegment,
             &dwNumSegment
             );

    if (SUCCEEDED(hr)) {
    
        UserDefault = *((LPUSER_DEFAULT) lpReplySegment->Segment);

        //
        // Put default values into LoginCtrl.
        //

        LoginCtrl.byAccountExpires[0] = UserDefault.byAccountExpiresYear;
        LoginCtrl.byAccountExpires[1] = UserDefault.byAccountExpiresMonth;
        LoginCtrl.byAccountExpires[2] = UserDefault.byAccountExpiresDay;
        LoginCtrl.byAccountDisabled = 0;
        LoginCtrl.byPasswordExpires[0] = 85;
        LoginCtrl.byPasswordExpires[1] = 01;
        LoginCtrl.byPasswordExpires[2] = 01;
        LoginCtrl.byGraceLogins = UserDefault.byGraceLoginReset;
        LoginCtrl.wPasswordInterval = UserDefault.wPasswordInterval;
        LoginCtrl.byGraceLoginReset = UserDefault.byGraceLoginReset;
        LoginCtrl.byMinPasswordLength = UserDefault.byMinPasswordLength;
        LoginCtrl.wMaxConnections = UserDefault.wMaxConnections;
        LoginCtrl.byRestrictions = UserDefault.byRestrictions;
        LoginCtrl.byUnused = 0;
        LoginCtrl.lMaxDiskBlocks = UserDefault.lMaxDiskBlocks;
        LoginCtrl.wBadLogins = 0;
        LoginCtrl.lNextResetTime = 0;

        for (i = 0; i < 42; i++) {
            LoginCtrl.byLoginTimes[i] = UserDefault.byLoginTimes[i];
        }

        for (i = 0; i < 6; i++) {
            LoginCtrl.byLastLogin[i] = 0;
        }

        for (i = 0; i < 12; i++) {
            LoginCtrl.byBadLoginAddr[i] = 0;
        }


        LoginCtrl.byGraceLogins = LoginCtrl.byGraceLoginReset;

        //
        // Put default values into AccountBalance.
        //

        AccountBalance.lBalance = UserDefault.lBalance;
        AccountBalance.lCreditLimit = UserDefault.lCreditLimit;

        //
        // Write LOGIN_CONTROL property.
        //

        hr = NWApiWriteProperty(
                 pNwUserInfo->hConn,
                 pNwUserInfo->lpszUserName,
                 OT_USER,
                 NW_PROP_LOGIN_CONTROL,
                 (LPBYTE) &LoginCtrl
                 );
        BAIL_ON_FAILURE(hr);

        //
        // Write ACCOUNT_BALANCE property.
        //

        hr = NWApiWriteProperty(
                 pNwUserInfo->hConn,
                 pNwUserInfo->lpszUserName,
                 OT_USER,
                 NW_PROP_ACCOUNT_BALANCE,
                 (LPBYTE) &AccountBalance
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // SUPERVISOR may not exist, or may not have USER_DEFAULTS.
    // This is okay.
    //
    hr = S_OK;

error:

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreateGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateGroup(
    POBJECTINFO pObjectInfo
    )
{
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create a group bindery object.
    //

    hr = NWApiCreateBinderyObject(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER_GROUP,
             BF_STATIC,
             BS_LOGGED_READ | BS_SUPER_WRITE
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create GROUP_MEMBERS property.
    //

    hr = NWApiCreateProperty(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER_GROUP,
             NW_PROP_GROUP_MEMBERS,
             BF_SET
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeleteGroup(
    POBJECTINFO pObjectInfo
    )
{
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Delete the group object.
    //

    hr = NWApiDeleteBinderyObject(
             hConn,
             pObjectInfo->ComponentArray[1],
             OT_USER_GROUP
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreatePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreatePrinter(
    POBJECTINFO pObjectInfo
    )
{
    CHAR          szQueueName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT       hr = S_OK;
    NWCCODE       usRet = SUCCESSFUL;
    NWCONN_HANDLE hConn = NULL;
    WCHAR         szTemp[MAX_PATH];

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(pObjectInfo->ComponentArray[1]) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        pObjectInfo->ComponentArray[1],
        szQueueName,
        0
        );

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Create a print queue object.
    //

    hr = NWApiCreatePrintQueue(
             hConn,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Change property security.
    //

    usRet = NWCChangePropertySecurity(
                hConn,
                szQueueName,
                OT_PRINT_QUEUE,
                NW_PROP_Q_OPERATORS,
                BS_LOGGED_READ | BS_SUPER_WRITE
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Add SUPERVISOR to Q_OPERATORS.
    // (okay if this fails, maybe SUPERVISOR doesn't exist)
    //

    usRet = NWCAddObjectToSet(
                hConn,
                szQueueName,
                OT_PRINT_QUEUE,
                NW_PROP_Q_OPERATORS,
                NW_PROP_SUPERVISOR,
                OT_USER
                );

    //
    // Add EVERYONE to Q_USERS.
    // (okay if this fails, maybe EVERYONE doesn't exist)    
    //

    usRet = NWCAddObjectToSet(
                hConn,
                szQueueName,
                OT_PRINT_QUEUE,
                NW_PROP_Q_USERS,
                NW_PROP_EVERYONE,
                OT_USER_GROUP
                );

    //
    // Return.
    //

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDeleteGroup
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDeletePrinter(
    POBJECTINFO pObjectInfo
    )
{
    HRESULT       hr = S_OK;
    NWCONN_HANDLE hConn = NULL;
    NWOBJ_ID      dwQueueID = 0;

    //
    // Open a handle to the bindery.
    //

    hr = NWApiGetBinderyHandle(
             &hConn,
             pObjectInfo->ComponentArray[0]
             );
    BAIL_ON_FAILURE(hr);

    //
    // Get Queue ID.
    //

    hr = NWApiDestroyPrintQueue(
             hConn,
             pObjectInfo->ComponentArray[1]
             );
    BAIL_ON_FAILURE(hr);

error:

    NWApiReleaseBinderyHandle(hConn);

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiCreatePrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreatePrintQueue(
    NWCONN_HANDLE hConn,
    LPWSTR lpszQueueName
    )
{
    CHAR    szQueueName[(OBJ_NAME_SIZE + 1)*2];
    DWORD   dwQueueID = 0;
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //
    if (wcslen(lpszQueueName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }    

    UnicodeToAnsiString(
        lpszQueueName,
        szQueueName,
        0
        );

    //
    // Create a print queue object.
    //

    usRet = NWCCreateQueue(
                hConn,
                NULL,
                szQueueName,
                OT_PRINT_QUEUE,
                NW_PRINTER_PATH,
                &dwQueueID
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiDestroyPrintQueue
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiDestroyPrintQueue(
    NWCONN_HANDLE hConn,
    LPWSTR lpszQueueName
    )
{
    DWORD   dwQueueID = 0;
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Get Queue ID.
    //

    hr = NWApiGetObjectID(
             hConn,
             lpszQueueName,
             OT_PRINT_QUEUE,
             &dwQueueID
             );
    BAIL_ON_FAILURE(hr);

    //
    // Destroy print queue.
    //

    usRet = NWCDestroyQueue(
                hConn,
                dwSWAP(dwQueueID)
                );
    hr = HRESULT_FROM_NWCCODE(usRet);

    //
    // Return.
    //

error:

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiMapNtStatusToDosError
//
//  Synopsis: This function maps the ntstatus that was returned from the NetWare
//            redirector to window errors. Similar to RtlNtStatusToDosError
//            except that the special handling is done to ntstatus with netware
//            facility codes.
//
//  Argument: NtStatus - The ntstatus returned from NetWare rdr
//
//  Return Value: WinError
//
//----------------------------------------------------------------------------
DWORD
NWApiMapNtStatusToDosError(
    IN NTSTATUS NtStatus
    )
{
    if ( (HIWORD( NtStatus) & FACILITY_NWRDR ) == FACILITY_NWRDR )
    {
        if ( NtStatus == NWRDR_PASSWORD_HAS_EXPIRED )
            return ERROR_PASSWORD_EXPIRED;
        else
            return NETWARE_GENERAL_ERROR;
    }
    else if ( HIWORD( NtStatus) == 0xC001 )
    {
        return LOWORD( NtStatus ) + NETWARE_ERROR_BASE;
    }

    return RtlNtStatusToDosError( NtStatus );
}

//----------------------------------------------------------------------------
//
//  Function: NWApiConvertToAddressFormat
//
//  Synopsis: Convert an IPX address obtain from NWApiGetProperty into the
//            format specified in spec.
//
//----------------------------------------------------------------------------
HRESULT
NWApiConvertToAddressFormat(
    LP_RPLY_SGMT_LST lpReplySegment,
    LPWSTR *lppszAddresses
    )
{
    int    i = 0;
    LPBYTE lpBuffer = NULL;
    LPWSTR lpszTemp = NULL;
    WORD   wSegment[NET_ADDRESS_WORD_SIZE];

    //
    // Put values from szReply into the wSegment array
    //

    lpBuffer = (LPBYTE) lpReplySegment->Segment;

    for (i = 0; i < NET_ADDRESS_WORD_SIZE; i++) {

        wSegment[i] = NWApiReverseWORD(*((LPWORD)lpBuffer + i));
    }

    //
    // Put address together in the format described in spec.
    //

    lpszTemp = (LPWSTR) AllocADsMem((NET_ADDRESS_NUM_CHAR+1)*sizeof(WCHAR));
    if (!lpszTemp) {
        RRETURN(E_OUTOFMEMORY);
    }

    wsprintf(
        lpszTemp,
        L"%s:%04X%04X.%04X%04X%04X.%04X",
        bstrAddressTypeString,
        wSegment[0],
        wSegment[1],
        wSegment[2],
        wSegment[3],
        wSegment[4],
        wSegment[5]
        );

    //
    // Return.
    //
    *lppszAddresses = lpszTemp;

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiMakeVariantTime
//
//  Synopsis: This function creates a double precision variant time.
//
//----------------------------------------------------------------------------
HRESULT
NWApiMakeVariantTime(
    DOUBLE * pdTime,
    WORD wDay,         // Day = 1..31
    WORD wMonth,       // Month = 1..12
    WORD wYear,        // Year = (19XX or 20XX) - 1980, ie. 2019 -> 39
    WORD wSecond,      // Second = 0..30, Second divided by 2
    WORD wMinute,      // Minute = 0..59
    WORD wHour         // Hour = 0..23
    )
{
    BOOL   fBool = TRUE;
    DOUBLE vTime = 0;
    WORD   wDOSDate = 0;
    WORD   wDOSTime = 0;

    //
    // Fix up parameters.
    // If wDay and wMonth are 0, turn them into one.
    //

    if (wDay == 0) {
        wDay++;
    }

    if (wMonth == 0) {
        wMonth++;
    }

    //
    // Shift data to correct bit as required by the DOS date & time format.
    //

    wMonth = wMonth << 5;
    wYear =  wYear << 9;
    wMinute = wMinute << 5;
    wHour = wHour << 11;

    //
    // Put them in DOS format.
    //

    wDOSDate = wYear | wMonth | wDay;
    wDOSTime = wHour | wMinute | wSecond;

    //
    // Convert into VariantTime.
    //

    fBool = DosDateTimeToVariantTime(
                wDOSDate,
                wDOSTime,
                &vTime
                );

    //
    // Return.
    //

    if (fBool == TRUE) {

        *pdTime = vTime;

        RRETURN(S_OK);
    }
    else {
        RRETURN(E_FAIL);
    }
}

//----------------------------------------------------------------------------
//
//  Function: NWApiBreakVariantTime
//
//  Synopsis: This function interprets a double precision variant time and
//            returns the day, month and year individually.
//
//----------------------------------------------------------------------------
HRESULT
NWApiBreakVariantTime(
    DOUBLE daDate,
    PWORD pwDay,
    PWORD pwMonth,
    PWORD pwYear
    )
{
    BOOL   fBool;
    DOUBLE vTime;
    WORD   wDOSDate = 0;
    WORD   wDOSTime = 0;
    WORD   wDay = 0;
    WORD   wMonth = 0;
    WORD   wYear = 0;

    //
    // Convert variant time into DOS format.
    //

    fBool = VariantTimeToDosDateTime(
                daDate,
                &wDOSDate,
                &wDOSTime
                );
    if (fBool == FALSE) {
        goto error;
    }

    //
    // Year: bits 9-15, add 80 to wYear because 80 was subtracted from it to
    // call VariantTimeToDosDateTime.
    //

    wYear = wDOSDate >> 9;
    wYear += 80;

    //
    // Month: bits 5-8.
    //

    wMonth = (wDOSDate >> 5) - (wYear << 4);

    //
    // Day: bits 0-4.
    //

    wDay = wDOSDate - (wMonth << 5) - (wYear << 9);

    //
    // Return.
    //

    *pwDay = wDay;
    *pwMonth = wMonth;
    *pwYear = wYear;

    RRETURN(S_OK);

error:

    RRETURN(E_FAIL);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiReverseWORD
//
//  Synopsis: This function reverse a WORD.
//
//----------------------------------------------------------------------------
WORD
NWApiReverseWORD(
    WORD wWORD
    )
{

    LPBYTE lpbTemp = (LPBYTE) &wWORD;
    BYTE bTemp;

    bTemp = *lpbTemp;
    *lpbTemp = *(lpbTemp + 1);
    *(lpbTemp + 1) = bTemp;

    return(*((LPWORD) lpbTemp));
}


//----------------------------------------------------------------------------
//
//  Function: NWApiUserGetGroups
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiUserGetGroups(
    NWCONN_HANDLE hConn,
    LPWSTR szUserName,
    LPBYTE *lppBuffer
    )
{
    DWORD   dwNumSegment = 0;
    HRESULT hr = S_OK;
    DWORD   i;
    LP_RPLY_SGMT_LST lpTemp = NULL;
    LP_RPLY_SGMT_LST lpReplySegment = NULL;

    //
    // Assert
    //

    ADsAssert(*lppBuffer == NULL);

    //
    // Get GROUP_MEMBERS.
    //

    hr = NWApiGetProperty(
             szUserName,
             NW_PROP_USER_GROUPS,
             OT_USER,
             hConn,
             &lpReplySegment,
             &dwNumSegment
             );
    BAIL_ON_FAILURE(hr);

    //
    // Pack returned linked list into buffer.
    //

    *lppBuffer = (LPBYTE) AllocADsMem(
                           dwNumSegment * REPLY_VALUE_SIZE
                           );
    if (!(*lppBuffer)) {
        RRETURN(E_OUTOFMEMORY);
    }

    lpTemp = lpReplySegment;

    for (i = 0; i < dwNumSegment; i++) {
        memcpy(
            *lppBuffer + i * REPLY_VALUE_SIZE,
            lpTemp->Segment,
            REPLY_VALUE_SIZE
            );
        lpTemp = lpTemp->lpNext;
    }

error:

    //
    // Clean up.
    //

    lpTemp = NULL;

    if (lpReplySegment) {
        DELETE_LIST(lpReplySegment);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for oleds.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//              09-Jan-96   PatrickT   Migrated to the Netware 3.12 Provider.
//
//----------------------------------------------------------------------------
#include "NWCOMPAT.hxx"
#pragma hdrstop


HINSTANCE          g_hInst = NULL;
PNW_CACHED_SERVER  pNwCachedServers = NULL ;
WCHAR             *szNWCOMPATPrefix = L"@NWCOMPAT!";

//
// 3rd party extension
//
extern PCLASS_ENTRY gpClassHead;
extern CRITICAL_SECTION g_ExtCritSect;
extern CRITICAL_SECTION g_TypeInfoCritSect;
//
// Disabled to avoid link warnings.
// extern CRITICAL_SECTION g_DispTypeInfoCritSect;
//

//
// login to server (in win{95,nt}\nw3login.cxx)
//
extern CRITICAL_SECTION g_csLoginCritSect;


//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     AllocArenaDump( NULL );
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"NWCOMPAT",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"NWCOMPAT",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"NWCOMPAT",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CNWCOMPATProviderCF g_cfProvider;
CNWCOMPATNamespaceCF g_cfNamespace;


//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_NWCOMPATProvider,                        &g_cfProvider,
    &CLSID_NWCOMPATNamespace,                       &g_cfNamespace
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been
    // called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    if (AggregatorDllCanUnload()) {
        hr = S_OK;
    }
    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Need to catch case of init crit sect failing.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;

#if DBG==1
#ifndef MSVC
            InitializeCriticalSection(&g_csOT);
            InitializeCriticalSection(&g_csMem);
#endif
            InitializeCriticalSection(&g_csDP);
#endif


            InitializeCriticalSection(&g_TypeInfoCritSect);
            InitializeCriticalSection(&g_csLoginCritSect);
            //
            // Disabled to avoid link warnings.
            // InitializeCriticalSection(&g_DispTypeInfoCritSect);
            //

            //
            // for 3rd party extension
            //

            InitializeCriticalSection(&g_ExtCritSect);
            gpClassHead = BuildClassesList();
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical failure
            //
            return FALSE;
        }

        break;


    case DLL_PROCESS_DETACH:

        //
        // free global list of class entries for 3rd party ext
        //

        FreeClassesList(gpClassHead);


        while (pNwCachedServers != NULL) {

            PVOID pTmp ;
            LPWSTR pszServer ;

            pTmp = (PVOID) pNwCachedServers ;

            pszServer = pNwCachedServers->pszServerName ;
            NWApiLogoffServer(pszServer) ;
            FreeADsStr(pszServer);

            pNwCachedServers = pNwCachedServers->pNextEntry ;
            FreeADsMem(pTmp);
        }

        //
        // Delete the critical sections
        //
#if DBG==1
#ifndef MSVC
        DeleteCriticalSection(&g_csOT);
        DeleteCriticalSection(&g_csMem);
#endif
        DeleteCriticalSection(&g_csDP);
#endif
        DeleteCriticalSection(&g_TypeInfoCritSect);
        DeleteCriticalSection(&g_csLoginCritSect);
        //
        // Disabled to avoid link warnings.
        // DeleteCriticalSection(&g_DispTypeInfoCritSect);
        //
        DeleteCriticalSection(&g_ExtCritSect);

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  object.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop

HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    );

HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    );


ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    return(hr);

}


HRESULT
IsValidFilter(
    LPWSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_wcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    VARIANT varDest;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if (!(V_VT(&var) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter and vFilter do not contain entries, that means no filter is
    // being set. Hence, we return err in this case so that we build the
    // default array.
    //

    if ( !uDestCount && (( dwSUBound - dwSLBound + 1 ) == 0 )) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\ods2nw.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       ods2nw.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//
//
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop



HRESULT
AdsTypeToNTTypeCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_LPTSTR;

    lpNtDestObject->NTValue.pszValue =
                        AllocADsStr(
                            lpAdsSrcValue->CaseIgnoreString
                        );
    if ((!lpNtDestObject->NTValue.pszValue) &&
        (lpAdsSrcValue->CaseIgnoreString)) {
        RRETURN(E_OUTOFMEMORY);
    }
    
    RRETURN(hr);

}


HRESULT
AdsTypeToNTTypeCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_BOOL;

    lpNtDestObject->NTValue.fValue =
                        lpAdsSrcValue->Boolean;

    RRETURN(hr);
}


HRESULT
AdsTypeToNTTypeCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpNtDestObject->NTType = NT_SYNTAX_ID_DWORD;

    lpNtDestObject->NTValue.dwValue =
                                lpAdsSrcValue->Integer;

    RRETURN(hr);
}

HRESULT
AdsTypeToNTTypeCopy(
    PADSVALUE lpAdsSrcValue,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsTypeToNTTypeCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    case ADSTYPE_BOOLEAN:
        hr = AdsTypeToNTTypeCopyBoolean(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsTypeToNTTypeCopyInteger(
                lpAdsSrcValue,
                lpNtDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
AdsTypeToNTTypeCopyConstruct(
    LPADSVALUE pAdsSrcValues,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects,
    PDWORD pdwNumNdsObjects,
    PDWORD pdwNdsSyntaxId
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = AdsTypeToNTTypeCopy(
                    pAdsSrcValues + i,
                    pNtDestObjects + i
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppNtDestObjects = pNtDestObjects;
     *pdwNumNdsObjects = dwNumObjects;
     *pdwNdsSyntaxId = pNtDestObjects->NTType;
     RRETURN(S_OK);

error:

     if (pNtDestObjects) {

        NTTypeFreeNTObjects(
                pNtDestObjects,
                dwNumObjects
                );
     }

     *ppNtDestObjects = NULL;
     *pdwNumNdsObjects = 0;

     RRETURN(hr);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\nwtypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nttypes.h
//
//  Contents:    Types for generic Get and Put
//
//  Functions:
//
//
//  History:      14-June-1996   RamV   Cloned off nds code.
//
//----------------------------------------------------------------------------

//
// various values of NT types
//

#define NT_SYNTAX_ID_BOOL                     1
#define NT_SYNTAX_ID_SYSTEMTIME               2
#define NT_SYNTAX_ID_DWORD                    3
#define NT_SYNTAX_ID_LPTSTR                   4
#define NT_SYNTAX_ID_DelimitedString          5
#define NT_SYNTAX_ID_NulledString             6
#define NT_SYNTAX_ID_DATE                     7 // internally treated as DWORD
#define NT_SYNTAX_ID_NW312DATE                8
#define NT_SYNTAX_ID_OCTETSTRING              9

typedef struct _octetstring {
    DWORD dwSize;
    BYTE *pByte;
} OctetString;

typedef struct _nttype{
    DWORD NTType;
    union {
        DWORD dwValue;
        LPTSTR pszValue;
        SYSTEMTIME stSystemTimeValue;
        BOOL       fValue;
        BYTE       Nw312Date[6];
        OctetString octetstring;
    }NTValue;

    //
    // for both Delimited and Nulled Strings we use pszValue
    //
}NTOBJECT, *PNTOBJECT, *LPNTOBJECT;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\nwmrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       nwmrshl.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      23-June-1996   KrishnaG Created.
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop

HRESULT
CopyNTOBJECTToDWORD(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DWORD)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToDATE(
    PNTOBJECT pNtSrcObject,
    PDWORD   pdwRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DATE)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdwRetval = (pNtSrcObject->NTValue).dwValue;

    RRETURN(S_OK);

}



HRESULT
CopyNTOBJECTToNw312DATE(
    PNTOBJECT pNtSrcObject,
    PBYTE   pbyRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }
    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_NW312DATE)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }


    memcpy(pbyRetval,(pNtSrcObject->NTValue).Nw312Date, 6);

    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToBOOL(
    PNTOBJECT pNtSrcObject,
    PBOOL   pfRetval
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_BOOL)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pfRetval = (pNtSrcObject->NTValue).fValue;

    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToSYSTEMTIME(
    PNTOBJECT pNtSrcObject,
    SYSTEMTIME *pstRetVal
    )

{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_SYSTEMTIME)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pstRetVal = (pNtSrcObject->NTValue).stSystemTimeValue;

    RRETURN(S_OK);

}

HRESULT
CopyNTOBJECTToLPTSTR(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_LPTSTR)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *ppszRetval = AllocADsStr((pNtSrcObject->NTValue).pszValue);

    if (! *ppszRetval && ((pNtSrcObject->NTValue).pszValue)) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToOctet(
    PNTOBJECT pNtSrcObject,
    OctetString *pOctet
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_OCTETSTRING)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pOctet->dwSize = (pNtSrcObject->NTValue).octetstring.dwSize;
    pOctet->pByte = (BYTE*)AllocADsMem(sizeof(BYTE) * (pNtSrcObject->NTValue).octetstring.dwSize);
    if (!pOctet->pByte) {
        RRETURN(E_OUTOFMEMORY);
    }
    memcpy(pOctet->pByte,
           (pNtSrcObject->NTValue).octetstring.pByte,
           (pNtSrcObject->NTValue).octetstring.dwSize);
    RRETURN(S_OK);

}


HRESULT
CopyNTOBJECTToDelimitedString(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_DelimitedString)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    if ((pNtSrcObject->NTValue).pszValue == NULL){
        *ppszRetval = NULL;
    } else {
        *ppszRetval = AllocADsStr((pNtSrcObject->NTValue).pszValue);
    }

    if (! *ppszRetval && ((pNtSrcObject->NTValue).pszValue)) {
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);
}


HRESULT
CopyNTOBJECTToNulledString(
    PNTOBJECT pNtSrcObject,
    LPTSTR  *ppszRetval
    )
{
    HRESULT hr = S_OK;

    if(!pNtSrcObject){
        RRETURN(E_POINTER);
    }

    if(!(pNtSrcObject->NTType == NT_SYNTAX_ID_NulledString)){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = CopyNulledString((pNtSrcObject->NTValue).pszValue,
                          ppszRetval );

    if ( FAILED (hr)){
        RRETURN(hr);
    }
    RRETURN(S_OK);
}

HRESULT
CopyNTOBJECTToNT(
    DWORD dwSyntaxId,
    PNTOBJECT lpNTObject,
    LPBYTE lpByte
    )
{

    HRESULT hr = S_OK;

    switch (dwSyntaxId) {
    case NT_SYNTAX_ID_BOOL:
        hr = CopyNTOBJECTToBOOL(
                         lpNTObject,
                         (PBOOL)lpByte
                         );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = CopyNTOBJECTToSYSTEMTIME(
                         lpNTObject,
                         (PSYSTEMTIME)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = CopyNTOBJECTToDWORD(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = CopyNTOBJECTToDATE(
                         lpNTObject,
                         (PDWORD)lpByte
                         );
        break;

    case NT_SYNTAX_ID_NW312DATE:
        hr = CopyNTOBJECTToNw312DATE(
                         lpNTObject,
                         (LPBYTE)lpByte
                         );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = CopyNTOBJECTToDelimitedString(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = CopyNTOBJECTToNulledString(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = CopyNTOBJECTToLPTSTR(
                         lpNTObject,
                         (LPTSTR *)lpByte
                         );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = CopyNTOBJECTToOctet(
                         lpNTObject,
                         (OctetString *)lpByte
                         );
        break;

    default:
        hr = E_FAIL;
        break;

    }

    RRETURN(hr);
}


HRESULT
MarshallNTSynIdToNT(
    DWORD dwSyntaxId,
    PNTOBJECT pNTObject,
    DWORD dwNumValues,
    LPBYTE lpValue
    )
{

    HRESULT hr = S_OK;
    DWORD  i = 0;

    //
    // Loop below does not really handle case other than 1 value
    //

    for (i = 0; i < dwNumValues; i++) {

        hr  = CopyNTOBJECTToNT(
                         dwSyntaxId,
                         (pNTObject + i) ,
                         lpValue
                         );

    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\nwumrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nwumrshl.cxx
//
//  Contents:
//
//  Functions:
//
//
//  History:      17-June-1996   KrishnaG   Cloned off NDS.
//
//
//  Notes :
//
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop

HRESULT
NTTypeInit(
    PNTOBJECT pNtType
    )
{
    memset(pNtType, 0, sizeof(NTOBJECT));

    RRETURN(S_OK);
}


HRESULT
NTTypeClear(
    PNTOBJECT pNtObject
    )
{
    if(!pNtObject)
        RRETURN(S_OK);

    switch (pNtObject->NTType) {
    case NT_SYNTAX_ID_LPTSTR:
    case NT_SYNTAX_ID_DelimitedString:
        FreeADsStr((pNtObject->NTValue).pszValue);
        break;
    case NT_SYNTAX_ID_NulledString:
        FreeADsMem((pNtObject->NTValue).pszValue);
        break;
    case NT_SYNTAX_ID_OCTETSTRING:
        FreeADsMem((pNtObject->NTValue).octetstring.pByte);
        break;
    default:
        break;
    }
    RRETURN(S_OK);
}


void
NTTypeFreeNTObjects(
    PNTOBJECT pNtObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         NTTypeClear(pNtObject + i);
    }

    FreeADsMem(pNtObject);

    return;
}


HRESULT
CopyDWORDToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DWORD;
    (lpNtDestValue->NTValue).dwValue = *pdwSrcValue;

    RRETURN(hr);

}

HRESULT
CopyDATEToNTOBJECT(
    PDWORD pdwSrcValue,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_DATE;
    (lpNtDestValue->NTValue).dwValue = *pdwSrcValue;

    RRETURN(hr);

}


HRESULT
CopyNw312DATEToNTOBJECT(
    PBYTE pbyDateTime,
    PNTOBJECT lpNtDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpNtDestValue){
        RRETURN(E_POINTER);
    }

    lpNtDestValue->NTType = NT_SYNTAX_ID_NW312DATE;
    memcpy((lpNtDestValue->NTValue).Nw312Date, pbyDateTime, 6);

    RRETURN(hr);

}






HRESULT
CopyBOOLToNTOBJECT(
    PBOOL pfSrcValue,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }


    lpNtObject->NTType = NT_SYNTAX_ID_BOOL;

    (lpNtObject->NTValue).fValue = *pfSrcValue;

    RRETURN(S_OK);

}


HRESULT
CopySYSTEMTIMEToNTOBJECT(
    PSYSTEMTIME pSysTime,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    (lpNtObject->NTValue).stSystemTimeValue = *pSysTime;
    lpNtObject->NTType = NT_SYNTAX_ID_SYSTEMTIME;

    RRETURN(S_OK);
}

HRESULT
CopyLPTSTRToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_LPTSTR;

    if(!pszSrcValue){
        (lpNtObject->NTValue). pszValue = NULL;
    } else {

        (lpNtObject->NTValue). pszValue = AllocADsStr(pszSrcValue);
        if (!((lpNtObject->NTValue). pszValue)){
            RRETURN(E_OUTOFMEMORY);
        }
    }

    RRETURN(S_OK);
}

HRESULT
CopyOctetToNTOBJECT(
    PBYTE   pOctetString,
    PNTOBJECT lpNtObject
    )
{

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_OCTETSTRING;

    if(!pOctetString){
        (lpNtObject->NTValue).octetstring.dwSize = 0;
        (lpNtObject->NTValue).octetstring.pByte = NULL;
    } else {
        OctetString *pOctString = (OctetString*)pOctetString;
        (lpNtObject->NTValue).octetstring.dwSize = pOctString->dwSize;
        (lpNtObject->NTValue).octetstring.pByte = (BYTE*)AllocADsMem(sizeof(BYTE)*pOctString->dwSize);
        if (!(lpNtObject->NTValue).octetstring.pByte) {
            RRETURN(E_OUTOFMEMORY);
        }
        memcpy((lpNtObject->NTValue).octetstring.pByte, pOctString->pByte,pOctString->dwSize);
    }

    RRETURN(S_OK);
}


HRESULT
CopyDelimitedStringToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{
    if(!pszSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_DelimitedString;
    (lpNtObject->NTValue). pszValue = AllocADsStr(pszSrcValue);

    if (!((lpNtObject->NTValue). pszValue)){
        RRETURN(E_OUTOFMEMORY);
    }
    RRETURN(S_OK);
}


HRESULT
CopyNulledStringToNTOBJECT(
    LPTSTR   pszSrcValue,
    PNTOBJECT lpNtObject
    )
{
    HRESULT hr = S_OK;

    if(!pszSrcValue){
        RRETURN(E_POINTER);
    }

    if(!lpNtObject){
        RRETURN(E_POINTER);
    }

    lpNtObject->NTType = NT_SYNTAX_ID_NulledString;

    hr = CopyNulledString (pszSrcValue,
                           &((lpNtObject->NTValue). pszValue) );

    if (FAILED(hr)){
        RRETURN(hr);
    }
    RRETURN(S_OK);
}


HRESULT
CopyNTToNTSynId(
    DWORD dwSyntaxId,
    LPBYTE lpByte,
    PNTOBJECT lpNTObject
    )
{
    HRESULT hr = S_OK;

    switch (dwSyntaxId) {
    case NT_SYNTAX_ID_BOOL:

        hr = CopyBOOLToNTOBJECT(
                         (PBOOL)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = CopySYSTEMTIMEToNTOBJECT(
                         (PSYSTEMTIME)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DWORD:
        hr = CopyDWORDToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = CopyDATEToNTOBJECT(
                         (PDWORD)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_NW312DATE:
        hr = CopyNw312DATEToNTOBJECT(
                         lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = CopyDelimitedStringToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = CopyNulledStringToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_LPTSTR:
        hr = CopyLPTSTRToNTOBJECT(
                         (LPTSTR)lpByte,
                         lpNTObject
                         );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = CopyOctetToNTOBJECT(
                         lpByte,
                         lpNTObject
                         );
        break;

    default:
        break;

    }

    RRETURN(hr);
}



//
//  NT is always single-valued!!
//

HRESULT
UnMarshallNTToNTSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpValue,
    PNTOBJECT * ppNTObject
    )
{
    LPBYTE lpByte = lpValue;
    DWORD  i = 0;
    PNTOBJECT pNTObject = NULL;
    HRESULT hr = S_OK;

    pNTObject = (PNTOBJECT)AllocADsMem(
                            sizeof(NTOBJECT)
                            );

    if (!pNTObject) {
        RRETURN(E_FAIL);
    }

    hr = CopyNTToNTSynId(
                     dwSyntaxId,
                     lpByte,
                     pNTObject
                     );
    BAIL_ON_FAILURE(hr);


    *ppNTObject = pNTObject;
    RRETURN(hr);

error:
    if (pNTObject) {
        FreeADsMem(pNTObject);
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\nwcopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nwcopy.cxx
//
//  Contents:   Nw312 Object Copy Routines
//
//  Functions:
//
//  History:      17-June-96   KrishnaG   Created.
//                cloned off NDS copy code.
//
//
//
//
//
//----------------------------------------------------------------------------

//
// NtType objects copy code
//

#include "nwcompat.hxx"
#pragma  hdrstop


HRESULT
NtTypeCopy(
    PNTOBJECT lpNtSrcObject,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpNtSrcObject->NTType) {

    case NT_SYNTAX_ID_BOOL:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_BOOL;
        (lpNtDestObject->NTValue).fValue =  (lpNtSrcObject->NTValue).fValue;
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_SYSTEMTIME;
        (lpNtDestObject->NTValue).stSystemTimeValue =
            (lpNtSrcObject->NTValue).stSystemTimeValue;
        break;

    case NT_SYNTAX_ID_DWORD:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DWORD;
        (lpNtDestObject->NTValue).dwValue =
            (lpNtSrcObject->NTValue).dwValue;
        break;

    case NT_SYNTAX_ID_DATE:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DATE;
        (lpNtDestObject->NTValue).dwValue =
            (lpNtSrcObject->NTValue).dwValue;
        break;

    case NT_SYNTAX_ID_NW312DATE:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_NW312DATE;
        memcpy(
            (lpNtDestObject->NTValue).Nw312Date,
            (lpNtSrcObject->NTValue).Nw312Date,
            6
            );
        break;


    case NT_SYNTAX_ID_LPTSTR:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_LPTSTR;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_OCTETSTRING:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_OCTETSTRING;
        (lpNtDestObject->NTValue).octetstring.dwSize = 
			(lpNtSrcObject->NTValue).octetstring.dwSize;
		if ((lpNtSrcObject->NTValue).octetstring.dwSize == 0) {
			(lpNtDestObject->NTValue).octetstring.pByte = NULL;
		}
		else {
			(lpNtDestObject->NTValue).octetstring.pByte = 
					(BYTE*)AllocADsMem(sizeof(BYTE)*(lpNtSrcObject->NTValue).octetstring.dwSize);
			if (!(lpNtDestObject->NTValue).octetstring.pByte) {
				RRETURN(E_OUTOFMEMORY);
			}
			memcpy((lpNtDestObject->NTValue).octetstring.pByte, 
				   (lpNtSrcObject->NTValue).octetstring.pByte,
				   (lpNtSrcObject->NTValue).octetstring.dwSize);
		}

        break;

    case NT_SYNTAX_ID_DelimitedString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_DelimitedString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        (lpNtDestObject->NTValue).pszValue =
            AllocADsStr((lpNtSrcObject->NTValue).pszValue);

        hr =((lpNtDestObject->NTValue).pszValue == NULL)
            ? E_OUTOFMEMORY :S_OK;

        break;

    case NT_SYNTAX_ID_NulledString:

        lpNtDestObject->NTType =  NT_SYNTAX_ID_NulledString;

        if(!(lpNtSrcObject->NTValue).pszValue){
            (lpNtDestObject->NTValue).pszValue = NULL;
            hr = S_OK;
            goto error;
        }

        hr = CopyNulledString((lpNtSrcObject->NTValue).pszValue,
                              &(lpNtDestObject->NTValue).pszValue );

        BAIL_ON_FAILURE(hr);

        break;

    default:
        hr = E_FAIL;
        break;
    }

error:
    RRETURN(hr);
}



HRESULT
NtTypeCopyConstruct(
    LPNTOBJECT pNtSrcObjects,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

    //
    // Zero out so we can clear the memory on an error
    //

    memset(pNtDestObjects, 0, dwNumObjects * sizeof(NTOBJECT));

    for (i = 0; i < dwNumObjects; i++ ) {
        hr = NtTypeCopy(pNtSrcObjects + i, pNtDestObjects + i);
        BAIL_ON_FAILURE(hr);
    }

    *ppNtDestObjects = pNtDestObjects;

    RRETURN(S_OK);

error:
    //
    // pNtDestObjects is assumed to be non-NULL
    //
    NTTypeFreeNTObjects(pNtDestObjects, dwNumObjects);
    RRETURN(hr);
}


HRESULT
CopyNulledString(
    LPTSTR pszSrcString,
    LPTSTR *ppszDestString
    )

{
    HRESULT hr = S_OK;
    LPTSTR pszPosition = pszSrcString;
    DWORD dwLength = 0 ;
    DWORD dwCurrLen = 0;
    BOOL foundNULL  = FALSE;
    DWORD i;

    ADsAssert(ppszDestString);
    *ppszDestString = NULL;

    if (!pszSrcString)
        RRETURN(S_OK);

    //
    // scan source string looking for 2 successive NULLS
    //

    if(*pszPosition == TEXT('\0')) {
        pszPosition++;
        dwLength++;
    }

    while(*pszPosition != TEXT('\0')){
        dwCurrLen = wcslen(pszPosition) +1;
        dwLength += dwCurrLen;
        pszPosition += dwCurrLen;
    }
    dwLength++;

    *ppszDestString = (LPTSTR)AllocADsMem (dwLength * sizeof(TCHAR));

    if ( !*ppszDestString){
        RRETURN(E_OUTOFMEMORY);
    }

    // copy one character at a time

    for ( i=0; i<dwLength; i++){
        (*ppszDestString)[i] = pszSrcString[i] ;
    }

    RRETURN (hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  parse.cxx
//
//  Contents:  Windows NT 3.5 GetObject functionality
//
//  History:
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

KWDLIST KeywordList[MAX_KEYWORDS] =
{
    { TOKEN_DOMAIN, L"domain"},
    { TOKEN_USER, L"user"},
    { TOKEN_GROUP, L"group"},
    { TOKEN_COMPUTER, L"computer"},
    { TOKEN_PRINTER, L"printqueue"},
    { TOKEN_SERVICE, L"service"},
    { TOKEN_FILESERVICE, L"fileservice"},
    { TOKEN_FILESHARE, L"fileshare"},
    { TOKEN_NAMESPACE, L"namespace"},
    { TOKEN_SCHEMA, L"schema"},
    { TOKEN_CLASS,  L"class"},
    { TOKEN_PROPERTY, L"property"},
    { TOKEN_SYNTAX, L"syntax" }
};

WCHAR *  szProviderName  = L"NWCOMPAT";


// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Object(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);


    switch (dwToken) {
    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();

        hr = DsPathName(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }

    }

cleanup:
    RRETURN(hr);
}



HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


// PathName -> Component \\ PathName
// PathName -> Component

HRESULT
DsPathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_FSLASH) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    hr = Component(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);

    if (dwToken == TOKEN_FSLASH) {
        RRETURN (PathName(pTokenizer, pObjectInfo));
    }else {
        hr = pTokenizer->PushBackToken();
        RRETURN (S_OK);
    }
cleanup:
    RRETURN(hr);
}

// Component -> <identifier>





//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    WCHAR szDisplayToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, szDisplayToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddComponent(pObjectInfo, szToken, szDisplayToken);
    BAIL_IF_ERROR(hr);

    RRETURN(S_OK);
cleanup:
    RRETURN(hr);
}

// Type -> "user", "group","printer","service"

//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_PATH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        if (pTokenizer->IsKeyword(szToken, &dwToken)) {
            hr = SetType(pObjectInfo, dwToken);
            RRETURN(hr);
        }
    }

    RRETURN(E_FAIL);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CLexer::CLexer(LPWSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPWSTR szDisplayToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;
    LPWSTR pDisplayCh = szDisplayToken;
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);

    if (szDisplayToken) {
        memset(szDisplayToken, 0, sizeof(TCHAR) * MAX_TOKEN_LENGTH);
    }

    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();
        switch (state) {
        case  0:
            *pch++ = c;
            _dwLastTokenLength++;

            if (c == TEXT('"')) {
                //
                // Quoting; 
                //

                fQuotingOn = TRUE;

                pch--;
                state = 1;
                
            }else if (c == TEXT('\\')) {
                //
                // Escaping; Ignore the '\' in the token and check to make 
                // sure that the next character exists
                //
                pch--;

                fEscapeOn = TRUE;

                state = 1;

            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L':'){
                if (!_bAtDisabled) {
                    *pdwToken = TOKEN_COLON;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);
                }else {
                    state = 1;
                }
            }else if (c == TEXT('<')) {
                RRETURN(E_FAIL);
            }else if (c == TEXT('>')) {
                RRETURN(E_FAIL);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;


        case 1:
            if ((fEscapeOn || fQuotingOn) && c == TEXT('\0') ) {
                RRETURN(E_FAIL);
            }
            else if (fEscapeOn) {
                fEscapeOn = FALSE;
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
            else if (fQuotingOn) {
                if (c == TEXT('"')) {
                    fQuotingOn = FALSE;
                }
                *pch++ = c;
                _dwLastTokenLength++;
                break;
            }
            else if (c == TEXT('\\') ) {
                fEscapeOn = TRUE;
                _dwLastTokenLength++;

                break;

            }
            else if (c == TEXT('"')) {
                fQuotingOn = TRUE;
                _dwLastTokenLength++;
                break;
            }
            if (c == L'\0' || c == L',' || c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);
            }else if (c == L'@' || c == L'!' || c == L':') {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    *pch++ = c;
                    _dwLastTokenLength++;
                    state = 1;
                    break;

                }
            }else {
                *pch++ = c;
                _dwLastTokenLength++;
                state = 1;
                break;
            }
        default:
            RRETURN(E_FAIL);
        }

        if (pDisplayCh) {
            *pDisplayCh++ = c;
        }

    }
}

HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    RRETURN (GetNextToken(szToken, NULL, pdwToken));
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}


//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo, LPWSTR szToken, LPWSTR szDisplayToken)
{
    if (!szToken || !*szToken) {
    }
    pObjectInfo->ComponentArray[pObjectInfo->NumComponents] =
                    AllocADsStr(szToken);

    pObjectInfo->DisplayComponentArray[pObjectInfo->NumComponents] =
                    AllocADsStr(szToken);
                
    pObjectInfo->NumComponents++;

    RRETURN(S_OK);

}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}

HRESULT
GetDisplayName(
    LPWSTR szName,
    LPWSTR *ppszDisplayName
    )
{

    HRESULT hr = S_OK;
    DWORD len = 0;
    LPWSTR pch = szName;
    LPWSTR pszDisplayCh = NULL, pszDisplay = NULL;
    BOOL fQuotingOn = FALSE;

    if (!ppszDisplayName ) {
        RRETURN (E_INVALIDARG);
    }

    *ppszDisplayName = NULL;

    if (!szName) {
        RRETURN (S_OK);
    }

    pch = szName;
    fQuotingOn = FALSE;

    for (len=0; *pch; pch++, len++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            len++;
        }
    }

    pszDisplay = (LPWSTR) AllocADsMem((len+1) * sizeof(WCHAR));

    if (!pszDisplay) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pch = szName; 
    pszDisplayCh = pszDisplay;
    fQuotingOn = FALSE;

    for (; *pch; pch++, pszDisplayCh++) {
        if ((!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'"') ) {
            fQuotingOn = ~fQuotingOn;
        }
        else if (!fQuotingOn && (!(pch > szName && *(pch-1) == '\\')) && 
            (*pch == L'/' || *pch == L'<' || *pch == L'>') ) {
            *pszDisplayCh++ = L'\\';
        }
        *pszDisplayCh = *pch;
    }

    *pszDisplayCh = L'\0';

    *ppszDisplayName = pszDisplay;

error:

    RRETURN(hr);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\printhlp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:      printhlp.cxx
//
//  Contents:  Helper functions for printer object.
//
//  History:   08-May-96    t-ptam (PatrickT) migrated
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma hdrstop

//----------------------------------------------------------------------------
//
//  Function: WinNTEnumJobs
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTEnumJobs(
    HANDLE hPrinter,
    DWORD dwFirstJob,
    DWORD dwNoJobs,
    DWORD dwLevel,
    LPBYTE *lplpbJobs,
    DWORD *pcbBuf,
    LPDWORD lpdwReturned
    )
{
    BOOL  fStatus = FALSE;
    DWORD dwNeeded = 0;
    DWORD dwError = 0;

    //
    // Enumerate Jobs using Win32 API.
    //

    fStatus = EnumJobs(
                  hPrinter,
                  dwFirstJob,
                  dwNoJobs,
                  dwLevel,
                  *lplpbJobs,
                  *pcbBuf,
                  &dwNeeded,
                  lpdwReturned
                  );

    //
    // Enumerate for Jobs again with a bigger buffer if a bigger one is needed
    // for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) == ERROR_INSUFFICIENT_BUFFER) {

            if (*lplpbJobs) {
                FreeADsMem( *lplpbJobs );
            }

            *lplpbJobs = (LPBYTE)AllocADsMem(dwNeeded);

            if (!*lplpbJobs) {
                *pcbBuf = 0;
                return(FALSE);
            }

            *pcbBuf = dwNeeded;

            fStatus = EnumJobs(
                          hPrinter,
                          dwFirstJob,
                          dwNoJobs,
                          dwLevel,
                          *lplpbJobs,
                          *pcbBuf,
                          &dwNeeded,
                          lpdwReturned
                          );

            if (!fStatus) {
                return(FALSE);
            }
            else {
                return(TRUE);
            }
        }
        else {
            return(FALSE);
        }
    }
    else {
        return(TRUE);
    }
}

//----------------------------------------------------------------------------
//
//  Function: WinNTEnumPrinters
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTEnumPrinters(
    DWORD  dwType,
    LPTSTR lpszName,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters,
    LPDWORD lpdwReturned
    )
{
    BOOL   fStatus = FALSE;
    DWORD  dwPassed = 1024;
    DWORD  dwNeeded = 0;
    DWORD  dwError = 0;
    LPBYTE pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    //
    // Enumerate Printers using Win32 API.
    //

    fStatus = EnumPrinters(
                  dwType,
                  lpszName,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded,
                  lpdwReturned
                  );

    //
    // Enumerate for Printers again with a bigger buffer if a bigger one is
    // needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;
        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        fStatus = EnumPrinters(
                      dwType,
                      lpszName,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded,
                      lpdwReturned
                      );

        if (!fStatus) {
            goto error;
        }
    }

    //
    // Return.
    //

    *lplpbPrinters = pMem;

    return(TRUE);

error:

    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: WinNTGetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
BOOL
WinNTGetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE *lplpbPrinters
    )
{

    BOOL    fStatus = FALSE;
    DWORD   dwPassed = 1024;
    DWORD   dwNeeded = 0;
    DWORD   dwError = 0;
    LPBYTE  pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem =  (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        goto error;
    }

    //
    // Get printer's information.
    //

    fStatus = GetPrinter(
                  hPrinter,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded
                  );

    //
    // Get printer's information again with a bigger buffer if a bigger buffer
    // is needed for the result.
    //

    if (!fStatus) {

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            goto error;
        }

        if (pMem) {
            FreeADsMem(pMem);
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            goto error;
        }

        dwPassed = dwNeeded;

        fStatus = GetPrinter(
                      hPrinter,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded
                      );

        if (!fStatus) {
            goto error;
        }
    }

    //
    // Return.
    //

    *lplpbPrinters = pMem;

    return(TRUE);


error:
    if (pMem) {
        FreeADsMem(pMem);
    }

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: GetPrinterInfo
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
GetPrinterInfo(
     THIS_ LPPRINTER_INFO_2 *lplpPrinterInfo2,
     BSTR  bstrPrinterName
     )
{
    //
    // Do a GetPrinter call to bstrPrinterName
    //

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE |
                                              READ_CONTROL};
    DWORD LastError = 0;
    HANDLE hPrinter = NULL;
    LPBYTE pMem = NULL;
    HRESULT hr = S_OK;

    ADsAssert(bstrPrinterName);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  (LPTSTR)bstrPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    //
    // If access is denied, do it again with a different access right.
    //

    if (!fStatus) {
        LastError = GetLastError();
        switch (LastError) {

        case ERROR_ACCESS_DENIED:
            {
                PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_USE};
                fStatus = OpenPrinter(
                              (LPTSTR)bstrPrinterName,
                              &hPrinter,
                              &PrinterDefaults
                              );
                if (fStatus) {
                    break;
                }
            }

        default:
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    //
    // Get printer's info.
    //

    fStatus = WinNTGetPrinter(
                  hPrinter,
                  2,
                  (LPBYTE *)&pMem
                  );

    if (!fStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    //
    // Return.
    //

    *lplpPrinterInfo2 = (LPPRINTER_INFO_2)pMem;

cleanup:

    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: Set
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
Set(
    LPPRINTER_INFO_2 lpPrinterInfo2,
    LPTSTR   pszPrinterName
    )
{

    BOOL fStatus = FALSE;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ALL_ACCESS};
    HANDLE hPrinter = NULL;
    HRESULT hr;

    ADsAssert(pszPrinterName);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  pszPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Set printer's data.
    //

    fStatus = SetPrinter(
                  hPrinter,
                  2,
                  (LPBYTE)lpPrinterInfo2,
                  0
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Return.
    //

    fStatus = ClosePrinter(hPrinter);

    RRETURN(S_OK);

error:
    hr = HRESULT_FROM_WIN32(GetLastError());
    if(hPrinter)
        fStatus = ClosePrinter(hPrinter);
    RRETURN(hr);

}

//----------------------------------------------------------------------------
//
//  Function: WinNTDeletePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
WinNTDeletePrinter(
    POBJECTINFO pObjectInfo
    )
{
    WCHAR szUncServerName[MAX_PATH];
    WCHAR szUncPrinterName[MAX_PATH];
    HANDLE hPrinter = NULL;
    PRINTER_DEFAULTS PrinterDefaults = {0, 0, PRINTER_ACCESS_ADMINISTER};
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    //
    // Make Unc Name for OpenPrinter.
    //

    MakeUncName(pObjectInfo->ComponentArray[1],
                szUncServerName
                );

    wcscpy(szUncPrinterName, szUncServerName);
    wcscat(szUncPrinterName, L"\\");
    wcscat(szUncPrinterName, (LPTSTR)pObjectInfo->ComponentArray[2]);

    //
    // Open a printer handle.
    //

    fStatus = OpenPrinter(
                  (LPTSTR)szUncPrinterName,
                  &hPrinter,
                  &PrinterDefaults
                  );

    if (!fStatus) {
        goto error;
    }

    //
    // Delete the given printer.
    //

    fStatus = DeletePrinter(hPrinter);

    //
    // Return.
    //

    if (!fStatus) {

        hr = GetLastError();

        fStatus = ClosePrinter(hPrinter);

        goto error;
    }


error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\property.cxx ===
#include "nwcompat.hxx"
#pragma hdrstop


#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);




HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PDATE pdaDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackDATEfromVariant(
            varOutputData,
            pdaDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varInputData);
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear(&varOutputData);
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\var2nw.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       var2nw.cxx
//
//  Contents:
//
//  Functions:
//
//  History:      13-June-1996   KrishnaG Created.
//
//
//
//----------------------------------------------------------------------------

#include "nwcompat.hxx"
#pragma  hdrstop


//
// WinNT objects copy code
//

HRESULT
VarTypeToWinNTTypeCopyBOOL(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpVarSrcObject){
        RRETURN(E_POINTER);
    }

    if(lpVarSrcObject->vt != VT_BOOL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_BOOL;

    if(lpVarSrcObject->boolVal){
        (pNTDestValue->NTValue).fValue = TRUE;

    } else {
        (pNTDestValue->NTValue).fValue = FALSE;
    }

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopySYSTEMTIME(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!lpVarSrcObject){
        RRETURN(E_POINTER);
    }

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ConvertDATEToSYSTEMTIME(lpVarSrcObject->date,
                                 &(pNTDestValue->NTValue.stSystemTimeValue) );


    RRETURN( hr );
}


HRESULT
VarTypeToWinNTTypeCopyDWORD(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_I4){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DWORD;

    (pNTDestValue->NTValue).dwValue = (DWORD)lpVarSrcObject->lVal;
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyDATE(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stTime;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_DATE;

    //
    // Note carefully! date is supplied as a value which is < 1 however
    // VariantTimeToDosDateTime complains when given a value < 30000.
    // (Number of days between 1900 and 1980). So
    // we add 35000 to make it a legal value.
    //

    hr = ConvertDATEToSYSTEMTIME(lpVarSrcObject->date+ 35000,
                                 &stTime);

    BAIL_ON_FAILURE(hr);

    (pNTDestValue->NTValue).dwValue = stTime.wHour*60 + stTime.wMinute ;


error:
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyNW312DATE(
    PVARIANT lpVarSrcObject,
    PNTOBJECT pNTDestValue
    )
{
    HRESULT hr = S_OK;
    SYSTEMTIME stTime;

    if(lpVarSrcObject->vt != VT_DATE){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_NW312DATE;

    hr = ConvertVariantToNW312Date(
                lpVarSrcObject->date,
                pNTDestValue->NTValue.Nw312Date
                );
    BAIL_ON_FAILURE(hr);


error:
    RRETURN(hr);

}

HRESULT
VarTypeToWinNTTypeCopyLPTSTR(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpVarSrcObject->vt != VT_BSTR){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_LPTSTR;

    (pNTDestValue->NTValue).pszValue =
        AllocADsStr(lpVarSrcObject->bstrVal);

    if(!(pNTDestValue->NTValue).pszValue){
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopyDelimitedString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if (!(V_VT(lpVarSrcObject) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }


    pNTDestValue->NTType = NT_SYNTAX_ID_DelimitedString;

    hr = VariantToDelimitedString(*lpVarSrcObject,
                                  &((pNTDestValue->NTValue).pszValue),
                                  TEXT(','));

    RRETURN(hr);
}

HRESULT
VarTypeToWinNTTypeCopyOctetString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    pNTDestValue->NTType = NT_SYNTAX_ID_OCTETSTRING;
    hr = VariantToBinary(
            lpVarSrcObject,
            &(pNTDestValue->NTValue).octetstring.dwSize,
            &(pNTDestValue->NTValue).octetstring.pByte);

    RRETURN(hr);
}


HRESULT
VarTypeToWinNTTypeCopyNulledString(
    PVARIANT lpVarSrcObject,
    PNTOBJECT   pNTDestValue
    )
{
    HRESULT hr = S_OK;

    if(!(V_VT(lpVarSrcObject) == (VT_VARIANT|VT_ARRAY))) {
        RRETURN(E_FAIL);
    }

    pNTDestValue->NTType = NT_SYNTAX_ID_NulledString;

    hr = VariantToNulledString(*lpVarSrcObject,
                                  &((pNTDestValue->NTValue).pszValue) );

    RRETURN(hr);
}

HRESULT
VarTypeToNtTypeCopy(
    DWORD dwNtType,
    PVARIANT lpVarSrcObject,
    PNTOBJECT lpNtDestObject
    )
{
    HRESULT hr = S_OK;
    switch (dwNtType){
    case NT_SYNTAX_ID_BOOL:
        hr = VarTypeToWinNTTypeCopyBOOL(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_SYSTEMTIME:
        hr = VarTypeToWinNTTypeCopySYSTEMTIME(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_DWORD:
        hr = VarTypeToWinNTTypeCopyDWORD(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_DATE:
        hr = VarTypeToWinNTTypeCopyDATE(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;


    case NT_SYNTAX_ID_NW312DATE:
        hr = VarTypeToWinNTTypeCopyNW312DATE(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;



    case NT_SYNTAX_ID_LPTSTR:
        hr = VarTypeToWinNTTypeCopyLPTSTR(
                lpVarSrcObject,
                lpNtDestObject
                );
        break;

    case NT_SYNTAX_ID_DelimitedString:
        hr = VarTypeToWinNTTypeCopyDelimitedString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        break;

    case NT_SYNTAX_ID_NulledString:
        hr = VarTypeToWinNTTypeCopyNulledString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        break;

    case NT_SYNTAX_ID_OCTETSTRING:
        hr = VarTypeToWinNTTypeCopyOctetString(
                 lpVarSrcObject,
                 lpNtDestObject
                 );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
VarTypeToNtTypeCopyConstruct(
    DWORD dwNtType,
    LPVARIANT pVarSrcObjects,
    DWORD dwNumObjects,
    LPNTOBJECT * ppNtDestObjects
    )
{

    DWORD i = 0;
    LPNTOBJECT pNtDestObjects = NULL;
    HRESULT hr = S_OK;

    pNtDestObjects = (LPNTOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(NTOBJECT)
                                    );

    if (!pNtDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {

         hr = VarTypeToNtTypeCopy(
                    dwNtType,
                    pVarSrcObjects + i,
                    pNtDestObjects + i
                    );

         BAIL_ON_FAILURE(hr);
     }

     *ppNtDestObjects = pNtDestObjects;

     RRETURN(S_OK);

error:

    if (pNtDestObjects) {

        FreeADsMem(pNtDestObjects);
    }

    *ppNtDestObjects = NULL;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\usrutils.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:      usrutils.cxx
//
//  Contents:  NetWare compatible UserCollection Enumeration Code
//
//  History:   22-Mar-96    t-ptam (PatrickT) migrated from KrishnaG for NetWare
//----------------------------------------------------------------------------
#include "nwcompat.hxx"
#pragma hdrstop

USER_GROUP_ENTRY UserGroupEntry;

//
// This assumes that addr is an LPBYTE type.
//

#define WORD_ALIGN_DOWN(addr) \
        addr = ((LPBYTE)((DWORD)addr & ~1))

DWORD UserGrpEntryStrings[]=
                             {
                             FIELD_OFFSET(USER_GROUP_ENTRY, Parent),
                             FIELD_OFFSET(USER_GROUP_ENTRY, Computer),
                             FIELD_OFFSET(USER_GROUP_ENTRY, Name),
                             0xFFFFFFFF
                             };

DECLARE_INFOLEVEL(UsrUt)
DECLARE_DEBUG(UsrUt)
#define UsrUtDebugOut(x) UsrUtInlineDebugOut x

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserOpen
//
//  Synopsis: This function opens a handle to a INI_COMP_USER structure.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserOpen(
    LPWSTR szComputerName,
    LPWSTR szGroupName,
    PHANDLE phUser
    )
{
    WCHAR szTempBuffer[MAX_PATH];
    PINI_COMP_USER pIniCompUsr;
    HRESULT hr = S_OK;

    if (!phUser) {
        return(FALSE);
    }

    pIniCompUsr = (PINI_COMP_USER)AllocADsMem(
                                       sizeof(INI_COMP_USER)
                                       );
    if (!pIniCompUsr) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    if (!(pIniCompUsr->szComputerName =  AllocADsStr(szComputerName))){
        goto error;
    }

    if (!(pIniCompUsr->szGroupName = AllocADsStr(szGroupName))){
        goto error;
    }

    hr = NWApiGetBinderyHandle(
             &pIniCompUsr->_hConn,
             szComputerName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return
    //

    *phUser =  (HANDLE)pIniCompUsr;

    return(TRUE);


error:
    if (pIniCompUsr) {
        FreeIniCompUser(pIniCompUsr);
    }

    *phUser = NULL;

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserEnum
//
//  Synopsis: This function returns a buffer which contains all the binding
//            informations for the requested number of objects without any
//            references.
//            It returns TRUE iff dwReturned = dwRequested.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserEnum(
    HANDLE hUser,
    DWORD  dwRequested,
    LPBYTE * ppBuffer,
    PDWORD pdwReturned
    )
{
    LPUSER_GROUP_ENTRY * ppUserMembers = NULL;
    DWORD i = 0;
    BOOL dwRet = FALSE;
    DWORD dwReturned = 0;
    DWORD dwSize = 0;
    LPUSER_GROUP_ENTRY pBuffer = NULL;
    LPBYTE pEnd = NULL;

    //
    // Allocate buffer for the number of requested members.
    //

    ppUserMembers = (LPUSER_GROUP_ENTRY *)AllocADsMem(
                                                    sizeof(LPUSER_GROUP_ENTRY)* dwRequested
                                                    );
    if (!ppUserMembers) {
        return(FALSE);
    }

    //
    // Fill in ppUserMembers one by one.
    //

    for (i = 0; i < dwRequested; i++) {

        dwRet = NWCOMPATComputerUserGetObject(
                    hUser,
                    &ppUserMembers[i]
                    );
        if (!dwRet) {
            break;
        }
    }

    if (dwRet) {
        dwReturned = i;

        //
        // Determine actual size of ppUserMembers[], ie. since each string in
        // USER_GROUP_ENTRY have a different length, a buffer that is going
        // to contain all the data without any references is unknown.
        //

        dwRet = ComputeComputerUserDataSize(
                    ppUserMembers,
                    dwReturned,
                    &dwSize
                    );

        pBuffer = (LPUSER_GROUP_ENTRY)AllocADsMem(
                                               dwSize
                                               );
        if (!pBuffer) {
            goto error;
        }

        pEnd = (LPBYTE)((LPBYTE)(pBuffer) + dwSize);

        //
        // Put data into pBuffer, starting from the end.
        //

        for (i = 0; i < dwReturned; i++) {

            pEnd = CopyIniCompUserToCompUser(
                       ppUserMembers[i],
                       (LPBYTE)(pBuffer + i),
                       pEnd
                       );
        }

        //
        // Clean up.
        //

        for (i = 0; i < dwReturned; i++ ) {
            FreeIntCompUser(*(ppUserMembers + i));
        }

        //
        // Return values.
        //

        *ppBuffer = (LPBYTE)pBuffer;
        *pdwReturned  = dwReturned;
    }

    FreeADsMem(ppUserMembers);

    if (dwReturned == dwRequested){
        return(TRUE);
    }else {
        return(FALSE);
    }

error:

    for (i = 0; i < dwReturned; i++ ) {
        FreeIntCompUser(*(ppUserMembers + i));
    }
    
    FreeADsMem(ppUserMembers);
    
    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserGetObject
//
//  Synopsis: This function returns binding information of a user (group member)
//            object one by one.  In its first call, it builds a buffer that
//            contains all the UserID of the group members.  Then, and in
//            subsequent calls, this UserID is translated into a user name.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserGetObject(
    HANDLE hUser,
    LPUSER_GROUP_ENTRY * ppUserMember
    )
{
    BOOL            dwRet = FALSE;
    DWORD           dwGroupId = 0;
    HRESULT         hr = S_OK;
    PINI_COMP_USER pIniCompUsr = (PINI_COMP_USER)hUser;

    //
    // Fill buffer with User ID.  NetWare returns all UserID in one call.
    //

    if (!pIniCompUsr->_pBuffer) {

        pIniCompUsr->_dwCurrentObject = 0;

        hr = NWApiUserGetGroups(
                 pIniCompUsr->_hConn,
                 pIniCompUsr->szGroupName,
                 &(pIniCompUsr->_pBuffer)
                 );
        BAIL_ON_FAILURE(hr);
    }

    //
    // Build one group member.
    //

    dwGroupId = *((LPDWORD)pIniCompUsr->_pBuffer + pIniCompUsr->_dwCurrentObject);

    if (dwGroupId != 0x0000) {

        dwRet = BuildComputerUserMember(
                    hUser,
                    dwGroupId,
                    ppUserMember
                    );
        if (!dwRet) {
            goto error;
        }

        pIniCompUsr->_dwCurrentObject++;

        return(TRUE);
    }

error:

    return(FALSE);
}

//----------------------------------------------------------------------------
//
//  Function: NWCOMPATComputerUserClose
//
//  Synopsis: Wrapper of FreeIniCompUser.
//
//----------------------------------------------------------------------------
BOOL
NWCOMPATComputerUserClose(
    HANDLE hUser
    )
{
    PINI_COMP_USER pIniCompUsr = (PINI_COMP_USER)hUser;

    if (pIniCompUsr) {
        FreeIniCompUser(pIniCompUsr);
    }
    return(TRUE);
}

//----------------------------------------------------------------------------
//
//  Function: FreeIniCompUser
//
//  Synopsis: Free an INI_COMP_USER structure.
//
//----------------------------------------------------------------------------
void
FreeIniCompUser(
    PINI_COMP_USER pIniCompUsr
    )
{
    HRESULT hr = S_OK;

    if (pIniCompUsr) {

        if (pIniCompUsr->szComputerName) {
            FreeADsStr(pIniCompUsr->szComputerName);
        }

        if (pIniCompUsr->szGroupName) {
            FreeADsStr(pIniCompUsr->szGroupName);
        }

        if (pIniCompUsr->_pBuffer) {
            FreeADsMem(pIniCompUsr->_pBuffer);
        }

        if (pIniCompUsr->_hConn) {
            hr = NWApiReleaseBinderyHandle(pIniCompUsr->_hConn);
        }

        FreeADsMem(pIniCompUsr);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: FreeIntCompUser
//
//  Synopsis: Free a USER_GROUP_ENTRY structure.
//
//----------------------------------------------------------------------------
void
FreeIntCompUser(
    LPUSER_GROUP_ENTRY pCompUserMember
    )
{
    if (pCompUserMember) {

        if (pCompUserMember->Parent) {
            FreeADsStr(pCompUserMember->Parent);
        }

        if (pCompUserMember->Computer) {
            FreeADsStr(pCompUserMember->Computer);
        }

        if (pCompUserMember->Name) {
            FreeADsStr(pCompUserMember->Name);
        }

        FreeADsMem(pCompUserMember);
    }

    return;
}

//----------------------------------------------------------------------------
//
//  Function: ComputeComputerUserDataSize
//
//  Synopsis: Calculate the size of a buffer that is going to store the data in
//            ppUserMembers without any references.
//
//----------------------------------------------------------------------------
BOOL
ComputeComputerUserDataSize(
        LPUSER_GROUP_ENTRY * ppUserMembers,
        DWORD  dwReturned,
        PDWORD pdwSize
        )
{

    DWORD i = 0;
    DWORD cb = 0;
    LPUSER_GROUP_ENTRY pMember = NULL;

    for (i = 0; i < dwReturned; i++) {

        pMember = *(ppUserMembers + i);

        cb += sizeof(USER_GROUP_ENTRY);

        if (pMember->Parent) {
            cb += wcslen(pMember->Parent)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Computer) {
            cb += wcslen(pMember->Computer)*sizeof(WCHAR) + sizeof(WCHAR);
        }

        if (pMember->Name) {
            cb += wcslen(pMember->Name)*sizeof(WCHAR) + sizeof(WCHAR);
        }
    }

    *pdwSize = cb;
    return(TRUE);
}

//------------------------------------------------------------------------------
//
//  Function: CopyIniCompUserToCompUser
//
//  Synopsis: Pack referenced data (string) into a buffer without any reference.
//
//------------------------------------------------------------------------------
LPBYTE
CopyIniCompUserToCompUser(
    LPUSER_GROUP_ENTRY  pIntCompGrp,
    LPBYTE  pExtCompGrp,
    LPBYTE  pEnd
    )
{
    LPWSTR   SourceStrings[sizeof(USER_GROUP_ENTRY)/sizeof(LPWSTR)];
    LPWSTR   *pSourceStrings =  SourceStrings;
    LPUSER_GROUP_ENTRY pCompGrpMember = (LPUSER_GROUP_ENTRY)pExtCompGrp;

    memset(SourceStrings, 0, sizeof(USER_GROUP_ENTRY));
    *pSourceStrings++ = pIntCompGrp->Parent;
    *pSourceStrings++ = pIntCompGrp->Computer;
    *pSourceStrings++ = pIntCompGrp->Name;

    pEnd = PackStrings(
                SourceStrings,
                pExtCompGrp,
                UserGrpEntryStrings,
                pEnd
                );

    pCompGrpMember->Type = pIntCompGrp->Type;

    return pEnd;
}

//----------------------------------------------------------------------------
//
//  Function: BuildComputerUserMember
//
//  Synopsis: Put binding information of a group member into ppUserMember.
//
//----------------------------------------------------------------------------
BOOL
BuildComputerUserMember(
    HANDLE hUser,
    DWORD  dwGroupId,
    LPUSER_GROUP_ENTRY * ppUserMember
    )
{
    DWORD                   dwTempUserId = dwGroupId;
    HRESULT                 hr = S_OK;
    LPUSER_GROUP_ENTRY pUserMember = NULL;
    LPINI_COMP_USER        pUser = (LPINI_COMP_USER)hUser;
    WCHAR                   szADsParent[MAX_PATH];

    //
    // Allocate one USER_GROUP_ENTRY.
    //

    pUserMember = (LPUSER_GROUP_ENTRY)AllocADsMem(
                                                sizeof(USER_GROUP_ENTRY)
                                                );
    if (!pUserMember) {
        return(FALSE);
    }

    //
    // Fill structure's fields.
    //

    pUserMember->Type = NWCOMPAT_USER_ID;

    wsprintf(
        szADsParent,
        L"%s://%s",
        szProviderName,
        pUser->szComputerName
        );
    pUserMember->Parent = AllocADsStr(szADsParent);

    pUserMember->Computer = AllocADsStr(pUser->szComputerName);

    hr = NWApiGetObjectName(
             pUser->_hConn,
             dwTempUserId,
             &pUserMember->Name
             );
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *ppUserMember = pUserMember;
    return(TRUE);

error:

    if (pUserMember) {

        if (pUserMember->Parent)
            FreeADsStr(pUserMember->Parent);

        if (pUserMember->Computer)
            FreeADsStr(pUserMember->Computer);

        FreeADsMem(pUserMember);
    }

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nwutils\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nwutils\encrypt.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    encrypt.h

Abstract:

    Contains API to encrypt password.

Author:

    Yi-Hsin Sung (yihsins)  30-Aug-1994

Revision History:

--*/

#ifndef _ENCRYPT_H_
#define _ENCRYPT_H_

VOID
EncryptChangePassword(
    IN  PUCHAR pOldPassword,
    IN  PUCHAR pNewPassword,
    IN  ULONG  ObjectId,
    IN  PUCHAR pKey,
    OUT PUCHAR pValidationKey,
    OUT PUCHAR pEncryptNewPassword
);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\win95\nw3login.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       nw3login.cxx
//
//  Description:
//          Spinned off from nw3utils.cxx because of differences in Win95
//          Contains routines to login and logoff from servers.
//
//  Functions:
//
//  History:      18-Sept-1996   t-felixw Created.
//
//
//  Issues:     
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

CRITICAL_SECTION g_csLoginCritSect;

DWORD
WideToSz( 
    LPSTR lpszC, 
        LPCWSTR lpszW, 
    INT nSize 
    )
{
    if (!WideCharToMultiByte(CP_ACP,
                             WC_COMPOSITECHECK | WC_SEPCHARS,
                             lpszW,
                             -1,
                             lpszC,
                             nSize,
                             NULL,
                             NULL)) {
        return (GetLastError()) ;
    }
    
    return NO_ERROR ;
};



HRESULT 
NWApiLoginToServer(
    LPWSTR pszServerName,
    LPWSTR pszUserName,
    LPWSTR pszPassword
    )
{
    PNW_CACHED_SERVER pNwServer = pNwCachedServers ;
    DWORD Status ;
    NETRESOURCEA netResource ;
    DWORD nSize;
    LPSTR lpszServerName = NULL;
    LPSTR lpszUserName = NULL;
    LPSTR lpszPassword = NULL;
    HRESULT hrResult = NO_ERROR;    

    if (!pszServerName)
        return NOERROR ;

    EnterCriticalSection(&g_csLoginCritSect);
    
    // Is the code below necessary?
    while (pNwServer) {
        if (_wcsicmp(pszServerName,pNwServer->pszServerName)==0)
            break ;
    } 

    if (pNwServer == NULL) {

        //
        // not in list. add connection 
        //

        memset(&netResource, 
            0, 
            sizeof(netResource)
            );
        
        if (pszServerName) {
            nSize = wcslen(pszServerName) + 1;
            
            if(!(lpszServerName = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
                hrResult = E_OUTOFMEMORY;
                goto Exit;
            }
            if (WideToSz(lpszServerName, 
                         pszServerName, 
                         nSize ) != NO_ERROR) {
                hrResult = E_FAIL;
                goto Exit;
            }
        }

        if (pszUserName) {
            nSize = wcslen(pszUserName) + 1;
            
            if(!(lpszUserName = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
                hrResult = E_OUTOFMEMORY;
                goto Exit;
            }
            if (WideToSz( lpszUserName, 
                          pszUserName, 
                          nSize ) != NO_ERROR) {
                hrResult = E_FAIL;
                goto Exit;
            }
        }
                                           
        if (pszPassword) {
            nSize = wcslen(pszPassword) + 1;
            
            if(!(lpszPassword = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
                hrResult = E_OUTOFMEMORY;
                goto Exit;
                }
            if (WideToSz( lpszPassword, 
                          pszPassword, 
                          nSize ) != NO_ERROR) {
                hrResult = E_FAIL;
                goto Exit;
            }
        }
                                           
                
        netResource.lpRemoteName = (LPSTR)lpszServerName;

        Status = WNetAddConnection2A( &netResource,
                                      lpszUserName,
                                      lpszPassword,
                                      0 );

        if (Status) {   
            // FAILURE
            hrResult = HRESULT_FROM_WIN32(Status);
            goto Exit;
        }

        if (!(pNwServer = (PNW_CACHED_SERVER)
                        AllocADsMem(sizeof(NW_CACHED_SERVER)))) {
            NWApiLogoffServer(pszServerName) ;
            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        LPWSTR pszTmp ;
        
        if (!(pszTmp = AllocADsStr(pszServerName))) {
            NWApiLogoffServer(pszServerName) ;
            hrResult = E_OUTOFMEMORY;
            goto Exit;
        }

        pNwServer->pszServerName = pszTmp ;
        pNwServer->pNextEntry = pNwCachedServers ;
        pNwCachedServers = pNwServer ;
Exit:
    if (lpszServerName)
        FreeADsMem(lpszServerName);
    if (lpszUserName)
        FreeADsMem(lpszUserName);
    if (lpszPassword)
        FreeADsMem(lpszPassword);
    // Not necessary to free pszTmp cuz it is the last one
    if (hrResult != NO_ERROR) {
        if (pNwServer)
            FreeADsMem(pNwServer);
    }
  }
  LeaveCriticalSection(&g_csLoginCritSect);
  return hrResult;
}


// Because this function is used in a variety of contexts,
// it is the responsibility of the caller to remove the
// server from the list of cached servers (pNwCachedServers)
// if necessary.  This function simply logouts from the server.
HRESULT 
NWApiLogoffServer(
    LPWSTR pszServerName
    )
{
    LPSTR lpszServerName;
    HRESULT hrResult = NOERROR;
    DWORD err;
    DWORD nSize = wcslen(pszServerName) + 1;
    
    if(!(lpszServerName = (LPSTR) AllocADsMem(nSize * sizeof(CHAR) ))) {
        return(E_FAIL);
    }
    if (WideToSz( lpszServerName, 
                  pszServerName, 
                  nSize ) != NO_ERROR) {
        hrResult = E_FAIL;
        goto Exit;
    }

    err = WNetCancelConnectionA(lpszServerName,FALSE);
    hrResult = HRESULT_FROM_WIN32(err);
Exit:
    FreeADsMem(lpszServerName);
    return hrResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nwutils\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nwutils\nwutils.cxx ===
#include "procs.hxx"
#pragma hdrstop


//----------------------------------------------------------------------------
//
//  Function: NWApiGetBinderyHandle
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetBinderyHandle(
    NWCONN_HANDLE *phConnReturned,
    BSTR bstrBinderyName
    )
{
    NWLOCAL_SCOPE ScopeFlag = 0;
    NWCONN_HANDLE hConn;
    NWCCODE       usRet = SUCCESSFUL;
    HRESULT       hr = S_OK;

    usRet = NWCAttachToFileServerW(
                bstrBinderyName,
                ScopeFlag,
                &hConn
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    //
    // Return.
    //

    *phConnReturned = hConn;

    RRETURN(hr);

error:
    *phConnReturned = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiReleaseBinderyHandle
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiReleaseBinderyHandle(
    NWCONN_HANDLE hConn
    )
{
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    if (hConn) {
        usRet = NWCDetachFromFileServer(hConn);
        hr = HRESULT_FROM_NWCCODE(usRet);
    }

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiWriteProperty
//
//  Synopsis: This function modifies values of a bindery property.  For now, it
//            only accept one buffer segment.  However, one segment is enough
//            for most practical purpose.  If the bindery property does not
//            exist, the function will attempt to create the property.
//
//----------------------------------------------------------------------------
HRESULT
NWApiWriteProperty(
    NWCONN_HANDLE hConn,
    BSTR bstrObjectName,
    NWOBJ_TYPE wObjType,
    LPSTR lpszPropertyName,
    NWSEGMENT_DATA *SegmentData
    )
{
    CHAR    szObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    if (wcslen(bstrObjectName) > OBJ_NAME_SIZE) {
        hr = E_INVALIDARG;
        BAIL_ON_FAILURE(hr);
    }

    UnicodeToAnsiString(
        bstrObjectName,
        szObjectName,
        0
        );

    usRet = NWCWritePropertyValue(
                hConn,
                szObjectName,
                wObjType,
                lpszPropertyName,
                1,                   // "1" for one segment.
                SegmentData,
                0                    // "0" for no more segment.
                );
    //
    // Create the property if it doesn't exist and attempt to write again.
    //

    // If the property doesn't exist, NWCWritePropertyValue will return
    // UNSUCCESSFUL, not NO_SUCH_PROPERTY (bug #34833 --- by design).
    // So if the call doesn't succeed, try to create the property and
    // see if that succeeds.

    if (usRet == 0xffff) {

        hr = NWApiCreateProperty(
                 hConn,
                 bstrObjectName,
                 wObjType,
                 lpszPropertyName,
                 BF_ITEM
                 );
        BAIL_ON_FAILURE(hr);

        usRet = NWCWritePropertyValue(
                    hConn,
                    szObjectName,
                    wObjType,
                    lpszPropertyName,
                    1,                   // "1" for one segment.
                    SegmentData,
                    0                    // "0" for no more segment.
                    );
    }

    hr = HRESULT_FROM_NWCCODE(usRet);

error:

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiObjectEnum
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiObjectEnum(
    NWCONN_HANDLE hConn,
    NWOBJ_TYPE dwObjType,
    LPWSTR *lppszObjectName,
    DWORD  *pdwResumeObjectID
    )
{
    HRESULT       hr = S_OK;
    LPWSTR        lpszTemp = NULL;
    NWCCODE       usRet = SUCCESSFUL;
    NWOBJ_TYPE    pdwObjType = 0xFFFF;
    NWFLAGS       pucHasProperties;
    NWFLAGS       pucObjectFlags;
    NWFLAGS       pucObjSecurity;
    CHAR          szObjectName[(OBJ_NAME_SIZE + 1)*2];

    //
    // This call will fail and return 0xffff if the user is not authenticated
    // on the server to which the hConn handle is attached to.
    //

    usRet = NWCScanObject(
                hConn,
                "*",
                dwObjType,
                pdwResumeObjectID,
                szObjectName,
                &pdwObjType,
                &pucHasProperties,
                &pucObjectFlags,
                &pucObjSecurity
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);

    lpszTemp = AllocateUnicodeString(szObjectName);
    if (!lpszTemp) {
       RRETURN(E_OUTOFMEMORY);
    }

    *lppszObjectName = AllocADsStr(lpszTemp);
    if (!(*lppszObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    if(lpszTemp){
        FreeUnicodeString(lpszTemp);
    }

    RRETURN(hr);

error:
    *lppszObjectName = NULL;
    pdwResumeObjectID = NULL;

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiValidateObject
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiValidateObject(
    NWCONN_HANDLE hConn,
    NWOBJ_TYPE dwObjType,
    LPWSTR lpszObjectName,
    DWORD  *pdwResumeObjectID
    )
{
    HRESULT       hr = S_OK;
    NWCCODE       usRet = SUCCESSFUL;
    CHAR          szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    CHAR          szObjectName[(OBJ_NAME_SIZE + 1)*2];
    NWOBJ_TYPE    pdwObjType = 0xFFFF;
    NWFLAGS       pucHasProperties;
    NWFLAGS       pucObjectFlags;
    NWFLAGS       pucObjSecurity;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // This call will fail and return 0xffff if the user is not authenticated
    // on the server to which the hConn handle is attached to.
    //

    usRet = NWCScanObject(
                hConn,
                szAnsiObjectName,
                dwObjType,
                pdwResumeObjectID,
                szObjectName,
                &pdwObjType,
                &pucHasProperties,
                &pucObjectFlags,
                &pucObjSecurity
                );

    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetAnyBinderyHandle
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetAnyBinderyHandle(
    NWCONN_HANDLE *phConn
    )
{
    HRESULT hr = S_OK;

    //
    // Get Bindery handle.
    //

    hr = NWApiGetBinderyHandle(
             phConn,
             L"*"
             );

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetObjectName
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetObjectName(
    NWCONN_HANDLE hConn,
    DWORD dwObjectID,
    LPWSTR *lppszObjectName
    )
{
    CHAR       szObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT    hr = S_OK;
    LPWSTR     lpszTemp = NULL;
    NWCCODE    usRet = SUCCESSFUL;
    NWOBJ_TYPE dwObjType;

    usRet = NWCGetObjectName(
                hConn,
                dwObjectID,
                szObjectName,
                &dwObjType
                );
    hr = HRESULT_FROM_NWCCODE(usRet);
    BAIL_ON_FAILURE(hr);


    lpszTemp = AllocateUnicodeString(szObjectName);
    if (!lpszTemp) {
       RRETURN(E_OUTOFMEMORY);
    }

    *lppszObjectName = AllocADsStr(lpszTemp);
    if (!(*lppszObjectName)) {
        RRETURN(E_OUTOFMEMORY);
    }

    FreeUnicodeString(lpszTemp);

    RRETURN(hr);

error:
    *lppszObjectName = NULL;

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: HRESULT_FROM_NWCCODE
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
HRESULT_FROM_NWCCODE(
    NWCCODE usRet
    )
{
    HRESULT hr = S_OK;

    if (usRet != SUCCESSFUL) {

        hr = HRESULT_FROM_WIN32(GetLastError());

        if (hr == S_OK) {
            //
            // In case CSNW didn't SetLastError,
            // make sure we don't return a false S_OK,
            // since we know _some_ error occurred
            //
            hr = HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR);
        }

        if (hr == HRESULT_FROM_WIN32(ERROR_EXTENDED_ERROR)) {
  
            ADsSetLastError((DWORD) usRet,
                            L"",
                            L"NDS Provider"
                            );
        }
    }

    RRETURN(hr);
}



//----------------------------------------------------------------------------
//
//  Function: NWApiOpenPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiOpenPrinter(
    LPWSTR lpszUncPrinterName,
    HANDLE *phPrinter,
    DWORD  dwAccess
    )
{
    BOOL    fStatus = TRUE;
    HANDLE  hPrinter;
    HRESULT hr = S_OK;
    PRINTER_DEFAULTS PrinterDefault = {0, 0, dwAccess};

    //
    // Set desired access right.
    //

    PrinterDefault.DesiredAccess = dwAccess;

    //
    // Get a handle to the speccified printer using Win32 API.
    //

    fStatus = OpenPrinter(
                  lpszUncPrinterName,
                  &hPrinter,
                  &PrinterDefault
                  );

    //
    // Convert error code into HRESULT.
    //

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Return.
    //

    else {
        *phPrinter = hPrinter;
    }

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiClosePrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiClosePrinter(
    HANDLE hPrinter
    )
{
    BOOL fStatus = TRUE;
    HRESULT hr = S_OK;

    //
    // Close a printer using Win32 API.
    //

    fStatus = ClosePrinter(hPrinter);

    //
    // Convert error code into HRESULT.
    //

    if (fStatus == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    //
    // Return.
    //

    RRETURN(hr);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetPrinter
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetPrinter(
    HANDLE hPrinter,
    DWORD  dwLevel,
    LPBYTE lpbPrinters,
    DWORD  dwAccess
    )
{
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    fStatus = SetPrinter(
                  hPrinter,
                  dwLevel,
                  lpbPrinters,
                  dwAccess
                  );
    if (!fStatus) {
        goto error;
    }

    RRETURN(S_OK);

error:

    hr = HRESULT_FROM_WIN32(GetLastError());

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiGetJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiGetJob(
    HANDLE hPrinter,
    DWORD dwJobId,
    DWORD dwLevel,
    LPBYTE *lplpbJobs
    )
{
    BOOL  fStatus = FALSE;
    DWORD dwError = 0;
    DWORD dwNeeded = 0;
    DWORD dwPassed = 1024;
    LPBYTE pMem = NULL;

    //
    // Allocate memory for return buffer.
    //

    pMem = (LPBYTE)AllocADsMem(dwPassed);
    if (!pMem) {
        RRETURN(E_OUTOFMEMORY);
    }

    //
    // Get Job's information.
    //

    fStatus = GetJob(
                  hPrinter,
                  dwJobId,
                  dwLevel,
                  pMem,
                  dwPassed,
                  &dwNeeded
                  );

    //
    // Get job's information again with a bigger buffer if a bigger buffer is
    // needed for the result.
    //

    if (!fStatus) {

        if (pMem){
            FreeADsMem(pMem);
        }

        if ((dwError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER) {
            RRETURN(HRESULT_FROM_WIN32(dwError));
        }

        pMem = (LPBYTE)AllocADsMem(
                           dwNeeded
                           );

        if (!pMem) {
            RRETURN(E_OUTOFMEMORY);
        }

        dwPassed = dwNeeded;

        fStatus = GetJob(
                      hPrinter,
                      dwJobId,
                      dwLevel,
                      pMem,
                      dwPassed,
                      &dwNeeded
                      );

        if (!fStatus) {
            FreeADsMem(pMem);
            RRETURN(HRESULT_FROM_WIN32(GetLastError()));
        }
    }

    //
    // Return.
    //

    *lplpbJobs = pMem;

    RRETURN(S_OK);
}

//----------------------------------------------------------------------------
//
//  Function: NWApiSetJob
//
//  Synopsis:
//
//----------------------------------------------------------------------------
HRESULT
NWApiSetJob(
    HANDLE hPrinter,
    DWORD  dwJobId,
    DWORD  dwLevel,
    LPBYTE lpbJobs,
    DWORD  dwCommand
    )
{
    BOOL fStatus = FALSE;
    HRESULT hr = S_OK;

    fStatus = SetJob(
                  hPrinter,
                  dwJobId,
                  dwLevel,
                  lpbJobs,
                  dwCommand
                  );
    if (!fStatus) {
        goto error;
    }

    RRETURN(S_OK);

error:

    hr = HRESULT_FROM_WIN32(GetLastError());

    RRETURN(hr);
}


//----------------------------------------------------------------------------
//
//  Function: NWApiCreateProperty
//
//  Synopsis: This function creates a bindery property.  Access is logged read,
//            supervisor write.
//
//----------------------------------------------------------------------------
HRESULT
NWApiCreateProperty(
    NWCONN_HANDLE hConn,
    LPWSTR lpszObjectName,
    NWOBJ_TYPE wObjType,
    LPSTR lpszPropertyName,
    NWFLAGS ucObjectFlags
    )
{
    CHAR    szAnsiObjectName[(OBJ_NAME_SIZE + 1)*2];
    HRESULT hr = S_OK;
    NWCCODE usRet = SUCCESSFUL;

    //
    // Convert BSTR into an ANSI representation required by NWC APIs.  "0" is
    // passed to UnicodeToAnsiString when the length of the string is unknown.
    //

    if (wcslen(lpszObjectName) > OBJ_NAME_SIZE) {
        RRETURN(E_INVALIDARG);
    }

    UnicodeToAnsiString(
        lpszObjectName,
        szAnsiObjectName,
        0
        );

    //
    // Create property.
    //

    usRet = NWCCreateProperty(
                hConn,
                szAnsiObjectName,
                wObjType,
                lpszPropertyName,
                ucObjectFlags,
                BS_LOGGED_READ | BS_SUPER_WRITE
                );
    //
    // Return.
    //

    hr = HRESULT_FROM_NWCCODE(usRet);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nwutils\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsiid\common\makefile.inc ===
.SUFFIXES: .def

{..\}.def{$(O)}.def:
    $(C_PREPROCESSOR) $<  > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nw312\winnt\nw3login.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       nw3login.cxx
//
//  Description:
//          Spin off from nw3utils.cxx because of differences in Win95
//
//  Functions:
//
//  History:      18-Sept-1996   t-felixw Created.
//
//
//  Issues:     
//
//----------------------------------------------------------------------------

#include "NWCOMPAT.hxx"
#pragma hdrstop

CRITICAL_SECTION g_csLoginCritSect;

HRESULT 
NWApiLoginToServer(
    LPWSTR pszServerName,
    LPWSTR pszUserName,
    LPWSTR pszPassword
    )
{
    PNW_CACHED_SERVER pNwServer = pNwCachedServers ;
    DWORD Status ;
    NETRESOURCE netResource ;

    if (!pszServerName)
        return NOERROR ;

    EnterCriticalSection(&g_csLoginCritSect);
    
    while (pNwServer) {
 
        if (_wcsicmp(pszServerName,pNwServer->pszServerName)==0) {
            break ;
        }

        pNwServer = pNwServer->pNextEntry;   
    } 

    if (pNwServer == NULL) {

        //
        // not in list. add connection 
        //

        memset(&netResource, 
            0, 
            sizeof(netResource)
            );

        netResource.lpRemoteName = pszServerName;

        Status = WNetAddConnection2(&netResource,
                     pszUserName,
                     pszPassword,
                     0
                     );

        if (Status) {

            LeaveCriticalSection(&g_csLoginCritSect);
            return(HRESULT_FROM_WIN32(Status));
        }

        if (!(pNwServer = (PNW_CACHED_SERVER)
                  AllocADsMem(sizeof(NW_CACHED_SERVER)))) {

            NWApiLogoffServer(pszServerName) ;
            LeaveCriticalSection(&g_csLoginCritSect);
            return(E_OUTOFMEMORY);
        }

        LPWSTR pszTmp ;
        
        if (!(pszTmp = AllocADsStr(pszServerName))) {

            NWApiLogoffServer(pszServerName) ;
            (void) FreeADsMem(pNwServer) ;
            LeaveCriticalSection(&g_csLoginCritSect);
            return(E_OUTOFMEMORY);
        }

        pNwServer->pszServerName = pszTmp ;
        pNwServer->pNextEntry = pNwCachedServers ;
        pNwCachedServers = pNwServer ;
 
    }

    LeaveCriticalSection(&g_csLoginCritSect);
    return(NOERROR) ;
}


// Because this function is used in a variety of contexts,
// it is the responsibility of the caller to remove the
// server from the list of cached servers (pNwCachedServers)
// if necessary.  This function simply logouts from the server.
HRESULT 
NWApiLogoffServer(
    LPWSTR pszServerName
    )
{
    DWORD err = WNetCancelConnection(pszServerName,FALSE);
    return(HRESULT_FROM_WIN32(err));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nwutils\encrypt.c ===
/*++

Copyright (c) 1994  Micro Computer Systems, Inc.

Module Name:

    nwlibs\encrypt.c

Abstract:

    This module implements the routines for the NetWare
    redirector to mangle an objectid, challenge key and
    password such that a NetWare server will accept the
    password as valid.

    This program uses information published in Byte Magazine.

Author:

    Shawn Walker (v-swalk) 10-10-1994

Revision History:

    11-9-1994 Copied from nwslib for login and minimars for
                change password.
    09-7-1995 (AndyHe) Put in proper setpass compatible processing

--*/
#include "dswarn.h"
#include <windef.h>
#include "encrypt.h"
#include <oledsdbg.h>

#define STATIC
#define STRLEN strlen
#define STRUPR _strupr

#define NUM_NYBBLES             34

STATIC
VOID
RespondToChallengePart1(
    IN     PUCHAR pObjectId,
    IN     PUCHAR pPassword,
       OUT PUCHAR pResponse
    );

STATIC
VOID
RespondToChallengePart2(
    IN     PUCHAR pResponsePart1,
    IN     PUCHAR pChallenge,
       OUT PUCHAR pResponse
    );

STATIC
VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer,
    UCHAR ChangePassword
    );

STATIC
int
Scramble(
    int   iSeed,
    UCHAR achBuffer[32]
    );

STATIC
VOID
ExpandBytes(
    IN  PUCHAR InArray,
    OUT PUCHAR OutArray
    );

STATIC
VOID
CompressBytes(
    IN  PUCHAR InArray,
    OUT PUCHAR OutArray
    );

VOID
CalculateWireFromOldAndNewPasswords(
    UCHAR *Vold,
    UCHAR *Vnew,
    UCHAR *Vc
    );



/*++
*******************************************************************

        EncryptLoginPassword

Routine Description:

        Encrypts the password for login.

Arguments:

        pPassword = The pointer to a plain text null terminated password.
        ObjectId = The object id of the user to encrypt the password.
        pLogKey = The pointer to key to use to encrpyt the password.
        pEncryptedPassword = The pointer to return a 8 byte encrypted
                                password.

Return Value:

        None.

*******************************************************************
--*/
void
EncryptLoginPassword(
    unsigned char *pPassword,
    unsigned long  ObjectId,
    unsigned char *pLogKey,
    unsigned char *pEncryptedPassword
    )
{
    INT   Index;
    UCHAR achK[32];
    UCHAR achBuf[32];

    ADsAssert(pPassword);

    /** The password must be upper case **/

    pPassword = STRUPR(pPassword);

    /** Encrypt the password **/

    Shuffle((UCHAR *) &ObjectId, pPassword, STRLEN(pPassword), achBuf, FALSE);
    Shuffle((UCHAR *) &pLogKey[0], achBuf, 16, &achK[0], FALSE);
    Shuffle((UCHAR *) &pLogKey[4], achBuf, 16, &achK[16], FALSE);

    for (Index = 0; Index < 16; Index++) {
        achK[Index] ^= achK[31 - Index];
    }

    for (Index = 0; Index < 8; Index++) {
        pEncryptedPassword[Index] = achK[Index] ^ achK[15 - Index];
    }

    return;
}



/*++
*******************************************************************

        EncryptChangePassword

Routine Description:

        This function encrypts for change passwords.

Arguments:

        pOldPassword = The pointer to the old password.
        pNewPassword = The pointer to the new password.
        ObjectId = The object id to use to encrypt the password.
        pKey = The challenge key from the server.
        pValidationKey = The 8 byte validation key to return.
        pEncryptNewPassword = The 17 byte encrypted new password to
                                return.

Return Value:

        None.

*******************************************************************
--*/
VOID
EncryptChangePassword(
    IN     PUCHAR pOldPassword,
    IN     PUCHAR pNewPassword,
    IN     ULONG  ObjectId,
    IN     PUCHAR pKey,
       OUT PUCHAR pValidationKey,
       OUT PUCHAR pEncryptNewPassword
    )
{
    UCHAR Vc[17];
    UCHAR Vold[17];
    UCHAR Vnew[17];
    UCHAR ValidationKey[16];
    UCHAR VcTemp[NUM_NYBBLES];
    UCHAR VoldTemp[NUM_NYBBLES];
    UCHAR VnewTemp[NUM_NYBBLES];

    ADsAssert(pOldPassword);
    ADsAssert(pNewPassword);

    /** Uppercase the passwords **/

    pOldPassword = STRUPR(pOldPassword);
    pNewPassword = STRUPR(pNewPassword);

    //
    // The old password and object ID make up the 17-byte Vold.
    // This is used later to form the 17-byte Vc for changing
    // password on the server.
    //

    Shuffle((PUCHAR) &ObjectId, pOldPassword, STRLEN(pOldPassword), Vold, FALSE);

    //
    // Need to make an 8-byte key which includes the old password
    // The server validates this value before allowing the user to
    // set password.
    //

    RespondToChallengePart2(Vold, pKey, ValidationKey);

    //
    //  Now determine Vold using the Change PW table rather than verify pw table
    //

    Shuffle((PUCHAR) &ObjectId, pOldPassword, STRLEN(pOldPassword), Vold, TRUE);

    //
    // The new password and object ID make up the 17-byte Vnew.
    //

    RespondToChallengePart1((PUCHAR) &ObjectId, pNewPassword, Vnew);

    //
    // Expand the 17-byte Vold and Vnew arrays into 34-byte arrays
    // for easy munging.
    //
    ExpandBytes(Vold, VoldTemp);
    ExpandBytes(Vnew, VnewTemp);

    //
    //  leave first two bytes of VcTemp free... we slap in the value based
    //  on new password length in below.
    //

    CalculateWireFromOldAndNewPasswords( VoldTemp, VnewTemp, &VcTemp[2] );

    //
    // Compress 34-byte array of nibbles into 17-byte array of bytes.
    //

    CompressBytes(VcTemp, Vc);

    //
    //  Calculate the 1st byte of Vc as a function of the new password length
    //  and the old password residue.
    //

    Vc[0] = ( ( ( Vold[0] ^ Vold[1] ) & 0x7F ) | 0x40 ) ^ STRLEN(pNewPassword);

    memcpy(pValidationKey, ValidationKey, 8);
    memcpy(pEncryptNewPassword, Vc, 17);

    return;
}



/*++
*******************************************************************
        Encryption table.
*******************************************************************
--*/

//
//  This is the same as LoginTable, just in a slightly different format.
//

UCHAR ChangeTable[] = {
    0x78, 0x08, 0x64, 0xe4, 0x5c, 0x17, 0xbf, 0xa8,
    0xf8, 0xcc, 0x94, 0x1e, 0x46, 0x24, 0x0a, 0xb9,
    0x2f, 0xb1, 0xd2, 0x19, 0x5e, 0x70, 0x02, 0x66,
    0x07, 0x38, 0x29, 0x3f, 0x7f, 0xcf, 0x64, 0xa0,
    0x23, 0xab, 0xd8, 0x3a, 0x17, 0xcf, 0x18, 0x9d,
    0x91, 0x94, 0xe4, 0xc5, 0x5c, 0x8b, 0x23, 0x9e,
    0x77, 0x69, 0xef, 0xc8, 0xd1, 0xa6, 0xed, 0x07,
    0x7a, 0x01, 0xf5, 0x4b, 0x7b, 0xec, 0x95, 0xd1,
    0xbd, 0x13, 0x5d, 0xe6, 0x30, 0xbb, 0xf3, 0x64,
    0x9d, 0xa3, 0x14, 0x94, 0x83, 0xbe, 0x50, 0x52,
    0xcb, 0xd5, 0xd5, 0xd2, 0xd9, 0xac, 0xa0, 0xb3,
    0x53, 0x69, 0x51, 0xee, 0x0e, 0x82, 0xd2, 0x20,
    0x4f, 0x85, 0x96, 0x86, 0xba, 0xbf, 0x07, 0x28,
    0xc7, 0x3a, 0x14, 0x25, 0xf7, 0xac, 0xe5, 0x93,
    0xe7, 0x12, 0xe1, 0xf4, 0xa6, 0xc6, 0xf4, 0x30,
    0xc0, 0x36, 0xf8, 0x7b, 0x2d, 0xc6, 0xaa, 0x8d
};

UCHAR LoginTable[] = {
    0x7,0x8,0x0,0x8,0x6,0x4,0xE,0x4,0x5,0xC,0x1,0x7,0xB,0xF,0xA,0x8,
    0xF,0x8,0xC,0xC,0x9,0x4,0x1,0xE,0x4,0x6,0x2,0x4,0x0,0xA,0xB,0x9,
    0x2,0xF,0xB,0x1,0xD,0x2,0x1,0x9,0x5,0xE,0x7,0x0,0x0,0x2,0x6,0x6,
    0x0,0x7,0x3,0x8,0x2,0x9,0x3,0xF,0x7,0xF,0xC,0xF,0x6,0x4,0xA,0x0,
    0x2,0x3,0xA,0xB,0xD,0x8,0x3,0xA,0x1,0x7,0xC,0xF,0x1,0x8,0x9,0xD,
    0x9,0x1,0x9,0x4,0xE,0x4,0xC,0x5,0x5,0xC,0x8,0xB,0x2,0x3,0x9,0xE,
    0x7,0x7,0x6,0x9,0xE,0xF,0xC,0x8,0xD,0x1,0xA,0x6,0xE,0xD,0x0,0x7,
    0x7,0xA,0x0,0x1,0xF,0x5,0x4,0xB,0x7,0xB,0xE,0xC,0x9,0x5,0xD,0x1,
    0xB,0xD,0x1,0x3,0x5,0xD,0xE,0x6,0x3,0x0,0xB,0xB,0xF,0x3,0x6,0x4,
    0x9,0xD,0xA,0x3,0x1,0x4,0x9,0x4,0x8,0x3,0xB,0xE,0x5,0x0,0x5,0x2,
    0xC,0xB,0xD,0x5,0xD,0x5,0xD,0x2,0xD,0x9,0xA,0xC,0xA,0x0,0xB,0x3,
    0x5,0x3,0x6,0x9,0x5,0x1,0xE,0xE,0x0,0xE,0x8,0x2,0xD,0x2,0x2,0x0,
    0x4,0xF,0x8,0x5,0x9,0x6,0x8,0x6,0xB,0xA,0xB,0xF,0x0,0x7,0x2,0x8,
    0xC,0x7,0x3,0xA,0x1,0x4,0x2,0x5,0xF,0x7,0xA,0xC,0xE,0x5,0x9,0x3,
    0xE,0x7,0x1,0x2,0xE,0x1,0xF,0x4,0xA,0x6,0xC,0x6,0xF,0x4,0x3,0x0,
    0xC,0x0,0x3,0x6,0xF,0x8,0x7,0xB,0x2,0xD,0xC,0x6,0xA,0xA,0x8,0xD
};

UCHAR Keys[32] = {
    0x48,0x93,0x46,0x67,0x98,0x3D,0xE6,0x8D,
    0xB7,0x10,0x7A,0x26,0x5A,0xB9,0xB1,0x35,
    0x6B,0x0F,0xD5,0x70,0xAE,0xFB,0xAD,0x11,
    0xF4,0x47,0xDC,0xA7,0xEC,0xCF,0x50,0xC0
};

#define XorArray( DEST, SRC ) {                             \
    PULONG D = (PULONG)DEST;                                \
    PULONG S = (PULONG)SRC;                                 \
    int i;                                                  \
    for ( i = 0; i <= 7 ; i++ ) {                           \
        D[i] ^= S[i];                                       \
    }                                                       \
}

/*++
*******************************************************************

        RespondToChallengePart1

Routine Description:

        This routine takes the ObjectId and Challenge key from the server
        and encrypts the user supplied password to develop a credential
        for the server to verify.

Arguments:

        pObjectId - Supplies the 4 byte user's bindery object id
        pPassword - Supplies the user's uppercased password
        pChallenge - Supplies the 8 byte challenge key
        pResponse - Returns the 16 byte response held by the server

Return Value:

        None.

*******************************************************************
--*/

STATIC
VOID
RespondToChallengePart1(
    IN     PUCHAR pObjectId,
    IN     PUCHAR pPassword,
       OUT PUCHAR pResponse
    )
{
    UCHAR   achBuf[32];

    Shuffle(pObjectId, pPassword, STRLEN(pPassword), achBuf, TRUE);
    memcpy(pResponse, achBuf, 17);

    return;
}

/*++
*******************************************************************

        RespondToChallengePart2

Routine Description:

        This routine takes the result of Shuffling the ObjectId and
        the Password and processes it with a challenge key.

Arguments:

        pResponsePart1 - Supplies the 16 byte output of
                                        RespondToChallengePart1.
        pChallenge - Supplies the 8 byte challenge key
        pResponse - Returns the 8 byte response

Return Value:

        None.
*******************************************************************
--*/

STATIC
VOID
RespondToChallengePart2(
    IN     PUCHAR pResponsePart1,
    IN     PUCHAR pChallenge,
       OUT PUCHAR pResponse
    )
{
    int     index;
    UCHAR   achK[32];

    Shuffle( &pChallenge[0], pResponsePart1, 16, &achK[0], TRUE);
    Shuffle( &pChallenge[4], pResponsePart1, 16, &achK[16], TRUE);

    for (index = 0; index < 16; index++) {
        achK[index] ^= achK[31-index];
    }

    for (index = 0; index < 8; index++) {
        pResponse[index] = achK[index] ^ achK[15-index];
    }

    return;
}


/*++
*******************************************************************

        Shuffle

Routine Description:

        This routine shuffles around the object ID with the password

Arguments:

        achObjectId - Supplies the 4 byte user's bindery object id
        szUpperPassword - Supplies the user's uppercased password on the
                            first call to process the password. On the
                            second and third calls this parameter contains
                            the OutputBuffer from the first call
        iPasswordLen - length of uppercased password
        achOutputBuffer - Returns the 8 byte sub-calculation

Return Value:

        None.

*******************************************************************
--*/

STATIC
VOID
Shuffle(
    UCHAR *achObjectId,
    UCHAR *szUpperPassword,
    int   iPasswordLen,
    UCHAR *achOutputBuffer,
    UCHAR ChangePassword
    )
{
    int     iTempIndex;
    int     iOutputIndex;
    UCHAR   achTemp[32];

    //
    //  Truncate all trailing zeros from the password.
    //

    while (iPasswordLen > 0 && szUpperPassword[iPasswordLen-1] == 0 ) {
        iPasswordLen--;
    }

    //
    //  Initialize the achTemp buffer. Initialization consists of taking
    //  the password and dividing it up into chunks of 32. Any bytes left
    //  over are the remainder and do not go into the initialization.
    //
    //  achTemp[0] = szUpperPassword[0] ^ szUpperPassword[32] ^ szUpper...
    //  achTemp[1] = szUpperPassword[1] ^ szUpperPassword[33] ^ szUpper...
    //  etc.
    //

    if ( iPasswordLen > 32) {

        //  At least one chunk of 32. Set the buffer to the first chunk.

        memcpy( achTemp, szUpperPassword, 32 );

        szUpperPassword += 32;   //  Remove the first chunk
        iPasswordLen    -= 32;

        while ( iPasswordLen >= 32 ) {
            //
            //  Xor this chunk with the characters already loaded into
            //  achTemp.
            //

            XorArray( achTemp, szUpperPassword);

            szUpperPassword += 32;   //  Remove this chunk
            iPasswordLen    -= 32;
        }

    } else {

        //  No chunks of 32 so set the buffer to zero's

        memset( achTemp, 0, sizeof(achTemp));

    }

    //
    //  achTemp is now initialized. Load the remainder into achTemp.
    //  The remainder is repeated to fill achTemp.
    //
    //  The corresponding character from Keys is taken to seperate
    //  each repitition.
    //
    //  As an example, take the remainder "ABCDEFG". The remainder is expanded
    //  to "ABCDEFGwABCDEFGxABCDEFGyABCDEFGz" where w is Keys[7],
    //  x is Keys[15], y is Keys[23] and z is Keys[31].
    //
    //

    if (iPasswordLen > 0) {
        int iPasswordOffset = 0;
        for (iTempIndex = 0; iTempIndex < 32; iTempIndex++) {

            if (iPasswordLen == iPasswordOffset) {
                iPasswordOffset = 0;
                achTemp[iTempIndex] ^= Keys[iTempIndex];
            } else {
                achTemp[iTempIndex] ^= szUpperPassword[iPasswordOffset++];
            }
        }
    }

    //
    //  achTemp has been loaded with the users password packed into 32
    //  bytes. Now take the objectid that came from the server and use
    //  that to munge every byte in achTemp.
    //

    for (iTempIndex = 0; iTempIndex < 32; iTempIndex++)
        achTemp[iTempIndex] ^= achObjectId[ iTempIndex & 3];

    Scramble( Scramble( 0, achTemp ), achTemp );

    //
    //  Finally take pairs of bytes in achTemp and return the two
    //  nibbles obtained from Table. The pairs of bytes used
    //  are achTemp[n] and achTemp[n+16].
    //

    for (iOutputIndex = 0; iOutputIndex < 16; iOutputIndex++) {

        if (ChangePassword) {
            unsigned int offset = achTemp[iOutputIndex << 1],
                         shift  = (offset & 0x1) ? 0 : 4 ;

            achOutputBuffer[iOutputIndex] =
                (ChangeTable[offset >> 1] >> shift) & 0xF ;

            offset = achTemp[(iOutputIndex << 1)+1],
            shift = (offset & 0x1) ? 4 : 0 ;

            achOutputBuffer[iOutputIndex] |=
                (ChangeTable[offset >> 1] << shift) & 0xF0;
        } else {
            achOutputBuffer[iOutputIndex] =
                LoginTable[achTemp[iOutputIndex << 1]] |
                (LoginTable[achTemp[(iOutputIndex << 1) + 1]] << 4);
        }
    }

    return;
}


/*++
*******************************************************************

        Scramble

Routine Description:

        This routine scrambles around the contents of the buffer. Each
        buffer position is updated to include the contents of at least
        two character positions plus an EncryptKey value. The buffer
        is processed left to right and so if a character position chooses
        to merge with a buffer position to its left then this buffer
        position will include bits derived from at least 3 bytes of
        the original buffer contents.

Arguments:

        iSeed =
        achBuffer =

Return Value:

        None.

*******************************************************************
--*/
STATIC
int
Scramble(
    int     iSeed,
    UCHAR   achBuffer[32]
    )
{
    int iBufferIndex;

    for (iBufferIndex = 0; iBufferIndex < 32; iBufferIndex++) {
        achBuffer[iBufferIndex] =
            (UCHAR)(
                ((UCHAR)(achBuffer[iBufferIndex] + iSeed)) ^
                ((UCHAR)(   achBuffer[(iBufferIndex+iSeed) & 31] -
                    Keys[iBufferIndex] )));

        iSeed += achBuffer[iBufferIndex];
    }
    return iSeed;
}

//
// Takes a 17-byte array and makes a 34-byte array out of it by
// putting each nibble into the space of a byte.
//

STATIC
void
ExpandBytes(
    IN  PUCHAR InArray,
    OUT PUCHAR OutArray
    )
{
    unsigned int i;

    for (i = 0 ; i < (NUM_NYBBLES / 2); i++) {
        OutArray[i * 2] = InArray[i] & 0x0f;
        OutArray[(i * 2) + 1] = (InArray[i] & 0xf0) >> 4;
    }
}

//
// Takes a 34-byte array and makes a 17-byte array out of it
// by combining the lower nibbles of two bytes into a byte.
//

STATIC
void
CompressBytes(
    IN  PUCHAR InArray,
    OUT PUCHAR OutArray
    )
{
    unsigned int i;

    for (i = 0; i < (NUM_NYBBLES / 2); i++) {
        OutArray[i] = InArray[i * 2] | (InArray[i * 2 + 1] << 4);
    }
}


#define N   0x10
typedef char    entry_t;

entry_t pinv[N][N] = {
    { 0xF,0x8,0x5,0x7,0xC,0x2,0xE,0x9,0x0,0x1,0x6,0xD,0x3,0x4,0xB,0xA,},
    { 0x2,0xC,0xE,0x6,0xF,0x0,0x1,0x8,0xD,0x3,0xA,0x4,0x9,0xB,0x5,0x7,},
    { 0x5,0x2,0x9,0xF,0xC,0x4,0xD,0x0,0xE,0xA,0x6,0x8,0xB,0x1,0x3,0x7,},
    { 0xF,0xD,0x2,0x6,0x7,0x8,0x5,0x9,0x0,0x4,0xC,0x3,0x1,0xA,0xB,0xE,},
    { 0x5,0xE,0x2,0xB,0xD,0xA,0x7,0x0,0x8,0x6,0x4,0x1,0xF,0xC,0x3,0x9,},
    { 0x8,0x2,0xF,0xA,0x5,0x9,0x6,0xC,0x0,0xB,0x1,0xD,0x7,0x3,0x4,0xE,},
    { 0xE,0x8,0x0,0x9,0x4,0xB,0x2,0x7,0xC,0x3,0xA,0x5,0xD,0x1,0x6,0xF,},
    { 0x1,0x4,0x8,0xA,0xD,0xB,0x7,0xE,0x5,0xF,0x3,0x9,0x0,0x2,0x6,0xC,},
    { 0x5,0x3,0xC,0x8,0xB,0x2,0xE,0xA,0x4,0x1,0xD,0x0,0x6,0x7,0xF,0x9,},
    { 0x6,0x0,0xB,0xE,0xD,0x4,0xC,0xF,0x7,0x2,0x8,0xA,0x1,0x5,0x3,0x9,},
    { 0xB,0x5,0xA,0xE,0xF,0x1,0xC,0x0,0x6,0x4,0x2,0x9,0x3,0xD,0x7,0x8,},
    { 0x7,0x2,0xA,0x0,0xE,0x8,0xF,0x4,0xC,0xB,0x9,0x1,0x5,0xD,0x3,0x6,},
    { 0x7,0x4,0xF,0x9,0x5,0x1,0xC,0xB,0x0,0x3,0x8,0xE,0x2,0xA,0x6,0xD,},
    { 0x9,0x4,0x8,0x0,0xA,0x3,0x1,0xC,0x5,0xF,0x7,0x2,0xB,0xE,0x6,0xD,},
    { 0x9,0x5,0x4,0x7,0xE,0x8,0x3,0x1,0xD,0xB,0xC,0x2,0x0,0xF,0x6,0xA,},
    { 0x9,0xA,0xB,0xD,0x5,0x3,0xF,0x0,0x1,0xC,0x8,0x7,0x6,0x4,0xE,0x2,},
};

entry_t master_perm[] = {
    0, 3, 0xe, 0xf, 9, 6, 0xa, 7, 0xc, 0xb, 1, 4, 5, 8, 2, 0xd,
};

entry_t key_sched[N][N];
entry_t perm_sched[N][N];

int InverseTableInitialized = 0;

void cipher_inv (
    const entry_t    *ctxt,
    const entry_t    *key,
          entry_t    *ptxt
    )
{
    int sc, r;
    entry_t v;

    for (sc = 0; sc < N; sc++) {
        v = ctxt[sc];
        for (r = N; --r >= 0; ) {
            v ^= key[key_sched[sc][r]];
            v = pinv[perm_sched[sc][r]][v];
        }
        ptxt[sc] = v;
    }
}

#if 0
void swab_nybbles (
    entry_t *vec
    )
{
    int i, j;

    //
    //  swap all columns instead of calling this routine twice.
    //

    for (i = 0; i < (2 * N); i += 2) {
        j = vec[i];
        vec[i] = vec[i+1];
        vec[i+1] = j;
    }
}
#endif

VOID
CalculateWireFromOldAndNewPasswords(
    UCHAR *Vold,
    UCHAR *Vnew,
    UCHAR *Vc
    )
{
    if (InverseTableInitialized == 0) {

        UCHAR sc,r;

        for (sc = 0; sc < N; sc++) {
            key_sched[sc][N-1] = sc;    /* terminal subkey */
            key_sched[0][(N+ N-1 - master_perm[sc])%N] = (N+sc-master_perm[sc])%N;
        }
        for (sc = 1; sc < N; sc++) for (r = 0; r < N; r++) {
            key_sched[sc][(r+master_perm[sc])%N] = (key_sched[0][r] + master_perm[sc]) % N;
        }
        for (sc = 0; sc < N; sc++) {
            perm_sched[sc][N-1] = sc;
            perm_sched[0][(N + N-1 - master_perm[sc])%N] = sc;
        }
        for (sc = 1; sc < N; sc++) for (r = 0; r < N; r++) {
            perm_sched[sc][r] = perm_sched[0][(N+r-master_perm[sc])%N];
        }

        InverseTableInitialized = 1;
    }

    //
    //  already swapped coming in here... don't swap them again.
    //

//  swab_nybbles(Vold);
//  swab_nybbles(Vnew);

    cipher_inv( (entry_t *)(&Vnew[0]),
                (entry_t *)(&Vold[0]),
                (entry_t *)(&Vc[0]));
    cipher_inv( (entry_t *)(&Vnew[16]),
                (entry_t *)(&Vold[16]),
                (entry_t *)(&Vc[16]));

//  swab_nybbles(Vc);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsiid\win95\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nwutils\sconv.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  sconv.cxx
//
//  Contents:  Ansi to Unicode conversions
//
//  History:    KrishnaG        Jan 22 1996
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop

#define NULL_TERMINATED 0

int
AnsiToUnicodeString(
    LPSTR pAnsi,
    LPWSTR pUnicode,
    DWORD StringLength
    )
{
    int iReturn;

    if( StringLength == NULL_TERMINATED )
        StringLength = strlen( pAnsi );

    iReturn = MultiByteToWideChar(CP_ACP,
                                  MB_PRECOMPOSED,
                                  pAnsi,
                                  StringLength + 1,
                                  pUnicode,
                                  StringLength + 1 );

    //
    // Ensure NULL termination.
    //
    pUnicode[StringLength] = 0;

    return iReturn;
}


int
UnicodeToAnsiString(
    LPWSTR pUnicode,
    LPSTR pAnsi,
    DWORD StringLength
    )
{
    LPSTR pTempBuf = NULL;
    INT   rc = 0;

    if( StringLength == NULL_TERMINATED ) {

        //
        // StringLength is just the
        // number of characters in the string
        //
        StringLength = wcslen( pUnicode );
    }

    //
    // WideCharToMultiByte doesn't NULL terminate if we're copying
    // just part of the string, so terminate here.
    //

    pUnicode[StringLength] = 0;

    //
    // Include one for the NULL
    //
    StringLength++;

    //
    // Unfortunately, WideCharToMultiByte doesn't do conversion in place,
    // so allocate a temporary buffer, which we can then copy:
    //

    if( pAnsi == (LPSTR)pUnicode )
    {
        pTempBuf = (LPSTR)LocalAlloc( LPTR, StringLength * 2);
        pAnsi = pTempBuf;
    }

    if( pAnsi )
    {
        rc = WideCharToMultiByte( CP_ACP,
                                  0,
                                  pUnicode,
                                  StringLength,
                                  pAnsi,
                                  StringLength*2,
                                  NULL,
                                  NULL );
    }

    /* If pTempBuf is non-null, we must copy the resulting string
     * so that it looks as if we did it in place:
     */
    if( pTempBuf && ( rc > 0 ) )
    {
        pAnsi = (LPSTR)pUnicode;
        strcpy( pAnsi, pTempBuf );
        LocalFree( pTempBuf );
    }

    return rc;
}


LPWSTR
AllocateUnicodeString(
    LPSTR  pAnsiString
    )
{
    LPWSTR  pUnicodeString = NULL;

    if (!pAnsiString)
        return NULL;

    pUnicodeString = (LPWSTR)LocalAlloc(
                        LPTR,
                        strlen(pAnsiString)*sizeof(WCHAR) +sizeof(WCHAR)
                        );

    if (pUnicodeString) {

        AnsiToUnicodeString(
            pAnsiString,
            pUnicodeString,
            NULL_TERMINATED
            );
    }

    return pUnicodeString;
}


void
FreeUnicodeString(
    LPWSTR  pUnicodeString
    )
{
    if (!pUnicodeString)
        return;

    LocalFree(pUnicodeString);

    return;
}


DWORD
ComputeMaxStrlenW(
    LPWSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //

    cchBufMax--;

    cchLen = wcslen(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}


DWORD
ComputeMaxStrlenA(
    LPSTR pString,
    DWORD  cchBufMax
    )
{
    DWORD cchLen;

    //
    // Include space for the NULL.
    //
    cchBufMax--;

    cchLen = lstrlenA(pString);

    if (cchLen > cchBufMax)
        return cchBufMax;

    return cchLen;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsiid\winnt\makefile.inc ===
!INCLUDE ..\common\makefile.inc



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nwutils\win95\offsets.h ===
extern DWORD PrinterInfoStressOffsets[];
extern DWORD PrinterInfoStressStrings[];
extern DWORD PrinterInfo4Offsets[];
extern DWORD PrinterInfo4Strings[];
extern DWORD PrinterInfo1Offsets[];
extern DWORD PrinterInfo1Strings[];
extern DWORD PrinterInfo2Offsets[];
extern DWORD PrinterInfo2Strings[];
extern DWORD PrinterInfo3Offsets[];
extern DWORD PrinterInfo3Strings[];
extern DWORD PrinterInfo5Offsets[];
extern DWORD PrinterInfo5Strings[];
extern DWORD JobInfo1Offsets[];
extern DWORD JobInfo1Strings[];
extern DWORD JobInfo2Offsets[];
extern DWORD JobInfo2Strings[];
extern DWORD JobInfo3Offsets[];
extern DWORD JobInfo3Strings[];
extern DWORD DriverInfo1Offsets[];
extern DWORD DriverInfo1Strings[];
extern DWORD DriverInfo2Offsets[];
extern DWORD DriverInfo2Strings[];
extern DWORD DriverInfo3Offsets[];
extern DWORD DriverInfo3Strings[];
extern DWORD AddJobOffsets[];
extern DWORD AddJobStrings[];
extern DWORD FormInfo1Offsets[];
extern DWORD FormInfo1Strings[];
extern DWORD PortInfo1Offsets[];
extern DWORD PortInfo1Strings[];
extern DWORD PortInfo2Offsets[];
extern DWORD PortInfo2Strings[];
extern DWORD PortInfo3Offsets[];
extern DWORD PrintProcessorInfo1Offsets[];
extern DWORD PrintProcessorInfo1Strings[];
extern DWORD MonitorInfo1Offsets[];
extern DWORD MonitorInfo2Offsets[];
extern DWORD MonitorInfo1Strings[];
extern DWORD MonitorInfo2Strings[];
extern DWORD DocInfo1Offsets[];
extern DWORD DocInfo1Strings[];
extern DWORD ProvidorInfo1Strings[];
extern DWORD DatatypeInfo1Offsets[];
extern DWORD DatatypeInfo1Strings[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsiid\guid.c ===
#define INITGUID

#include "dswarn.h"
#include <ole2.h>

//--------------------------------------------------------------------------
//
//  ADs CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(LIBID_ADs,0x97D25DB0L,0x0363,0x11CF,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(IID_IADs,0xFD8256D0L,0xFD15,0x11CE,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(IID_IADsContainer,0x001677D0L,0xFD16,0x11CE,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(IID_IADsNamespaces,0x28B96BA0L,0xB330,0x11CF,0xA9,0xAD,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(IID_IADsDomain,0x00E4C220L,0xFD16,0x11CE,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);


DEFINE_GUID(IID_IADsUser,0x3E37E320L,0x17E2,0x11CF,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);



DEFINE_GUID(IID_IADsComputerOperations,0xEF497680L,0x1D9F,0x11CF,0xB1,0xF3,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(IID_IADsComputer,0xEFE3CC70L,0x1D9F,0x11CF,0xB1,0xF3,0x02,0x60,0x8C,0x9E,0x75,0x53);


DEFINE_GUID(IID_IADsGroup,0x27636B00L,0x410F,0x11CF,0xB1,0xFF,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(IID_IADsMembers,0x451A0030L,0x72EC,0x11CF,0xB0,0x3B,0x00,0xAA,0x00,0x6E,0x09,0x75);


DEFINE_GUID(IID_IADsPrintQueue,0xB15160D0L,0x1226,0x11CF,0xA9,0x85,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(IID_IADsPrintQueueOperations,0x124BE5C0L,0x156E,0x11CF,0xA9,0x86,0x00,0xAA,0x00,0x6B,0xC1,0x49);



DEFINE_GUID(IID_IADsPrintJobOperations,0x9A52DB30L,0x1ECF,0x11CF,0xA9,0x88,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(IID_IADsPrintJob,0x32FB6780L,0x1ED0,0x11CF,0xA9,0x88,0x00,0xAA,0x00,0x6B,0xC1,0x49);


DEFINE_GUID(IID_IADsCollection,0x72B945E0L,0x253B,0x11CF,0xA9,0x88,0x00,0xAA,0x00,0x6B,0xC1,0x49);



DEFINE_GUID(IID_IADsServiceOperations,0x5D7B33F0L,0x31CA,0x11CF,0xA9,0x8A,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(IID_IADsService,0x68AF66E0L,0x31CA,0x11CF,0xA9,0x8A,0x00,0xAA,0x00,0x6B,0xC1,0x49);



DEFINE_GUID(IID_IADsFileServiceOperations,0xA02DED10L,0x31CA,0x11CF,0xA9,0x8A,0x00,0xAA,0x00,0x6B,0xC1,0x49);

DEFINE_GUID(IID_IADsFileService,0xA89D1900L,0x31CA,0x11CF,0xA9,0x8A,0x00,0xAA,0x00,0x6B,0xC1,0x49);



DEFINE_GUID(IID_IADsResource,0x34A05B20L,0x4AAB,0x11CF,0xAE,0x2C,0x00,0xAA,0x00,0x6E,0xBF,0xB9);



DEFINE_GUID(IID_IADsSession,0x398B7DA0L,0x4AAB,0x11CF,0xAE,0x2C,0x00,0xAA,0x00,0x6E,0xBF,0xB9);


DEFINE_GUID(IID_IADsFileShare,0xEB6DCAF0L,0x4B83,0x11CF,0xA9,0x95,0x00,0xAA,0x00,0x6B,0xC1,0x49);


DEFINE_GUID(IID_IADsClass, 0xC8F93DD0L, 0x4AE0, 0x11CF, 0x9E, 0x73, 0x00, 0xAA, 0x00, 0x4A, 0x56, 0x91);

DEFINE_GUID(IID_IADsSyntax, 0xC8F93DD2L, 0x4AE0, 0x11CF, 0x9E, 0x73, 0x00, 0xAA, 0x00, 0x4A, 0x56, 0x91);

DEFINE_GUID(IID_IADsProperty, 0xC8F93DD3L, 0x4AE0, 0x11CF, 0x9E, 0x73, 0x00, 0xAA, 0x00, 0x4A, 0x56, 0x91);

DEFINE_GUID(IID_IADsLocality,0xA05E03A2L,0xEFFE,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(IID_IADsO,0xA1CD2DC6L,0xEFFE,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(IID_IADsOU,0xA2F733B8L,0xEFFE,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(IID_IADsOpenDSObject,0xddf2891e,0x0f9c,0x11d0,0x8a,0xd4,0x00,0xc0,0x4f,0xd8,0xd5,0x03);

DEFINE_GUID(IID_IDirectoryObject,0xe798de2c,0x22e4,0x11d0,0x84,0xfe,0x00,0xc0,0x4f,0xd8,0xd5,0x03);

DEFINE_GUID(IID_IDirectorySearch,0x109ba8ec,0x92f0,0x11d0,0xa7,0x90,0x00,0xc0,0x4f,0xd8,0xd5,0xa8);


DEFINE_GUID(IID_IDirectorySchemaMgmt, 0x75db3b9c, 0xa4d8, 0x11d0, 0xa7, 0x9c, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xa8);


DEFINE_GUID(IID_IADsSearch, 0xC69F7780L, 0x4008, 0x11D0, 0xB9, 0x4C, 0x00, 0xC0, 0x4F, 0xD8, 0xD5, 0xA8);

DEFINE_GUID(IID_IADsPropertyList, 0xc6f602b6,0x8f69,0x11d0, 0x85, 0x28, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0x03);

DEFINE_GUID(IID_IADsObjectOptions, 0x46f14fda,0x232b,0x11d1, 0xa8, 0x08, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xa8);

DEFINE_GUID(IID_IADsObjOptPrivate, 0x81cbb829,0x1867,0x11d2, 0x92, 0x20, 0x00, 0xc0, 0x4f, 0xb6, 0xd0, 0xd1);

const IID IID_IADsPropertyEntry = {0x05792c8e,0x941f,0x11d0,{0x85,0x29,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const CLSID CLSID_PropertyEntry = {0x72d3edc2,0xa4c4,0x11d0,{0x85,0x33,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const IID IID_IADsAccessControlEntry = {0xb4f3a14c,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const CLSID CLSID_AccessControlEntry = {0xb75ac000,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const IID IID_IADsAccessControlList = {0xb7ee91cc,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const CLSID CLSID_AccessControlList = {0xb85ea052,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const IID IID_IADsSecurityDescriptor = {0xb8c787ca,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


const CLSID CLSID_SecurityDescriptor = {0xb958f73c,0x9bdd,0x11d0,{0x85,0x2c,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const IID IID_IADsPropertyValue = {0x79fa9ad0,0xa97c,0x11d0,{0x85,0x34,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_PropertyValue = {0x7b9e38b0,0xa97c,0x11d0,{0x85,0x34,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const IID IID_IADsPropertyValue2 = {0x306e831c,0x5bc7,0x11d1,{0xa3,0xb8,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

const IID IID_IADsValue = {0x1e3ef0aa,0xaef5,0x11d0,{0x85,0x37,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const IID IID_IADsPathname = {0xd592aed4,0xf420,0x11d0,{0xa3,0x6e,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};
const IID IID_IADsPathnameProvider = {0xaacd1d30,0x8bd0,0x11d2,{0x92, 0xa9, 0x00, 0xc0, 0x4f, 0x79, 0xf8, 0x34}};


const CLSID CLSID_Pathname = {0x080d0d78,0xf421,0x11d0,{0xa3,0x6e,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

const IID IID_IADsADSystemInfo = {0x5BB11929, 0xAFD1, 0x11d2, {0x9C, 0xB9, 0x00, 0x00, 0xF8, 0x7A, 0x36, 0x9E}};
const CLSID CLSID_ADSystemInfo = {0x50B6327F, 0xAFD1, 0x11d2, {0x9C, 0xB9, 0x00, 0x00, 0xF8, 0x7A, 0x36, 0x9E}};

const IID IID_IADsWinNTSystemInfo = {0x6C6D65DC, 0xAFD1, 0x11d2, {0x9C, 0xB9, 0x00, 0x00, 0xF8, 0x7A, 0x36, 0x9E}};
const CLSID CLSID_WinNTSystemInfo = {0x66182EC4, 0xAFD1, 0x11d2, {0x9C, 0xB9, 0x00, 0x00, 0xF8, 0x7A, 0x36, 0x9E}};

const IID IID_IADsDNWithString = {0x370df02e, 0xf934, 0x11d2, {0xba, 0x96, 0x00, 0xc0, 0x4f, 0xb6, 0xd0, 0xd1}};
const CLSID CLSID_DNWithString = {0x334857cc, 0xf934, 0x11d2, {0xba, 0x96, 0x00, 0xc0, 0x4f, 0xb6, 0xd0, 0xd1}};

const IID IID_IADsDNWithBinary = {0x7e99c0a2, 0xf935, 0x11d2, {0xba, 0x96, 0x00, 0xc0, 0x4f, 0xb6, 0xd0, 0xd1}};
const CLSID CLSID_DNWithBinary = {0x7e99c0a3, 0xf935, 0x11d2, {0xba, 0x96, 0x00, 0xc0, 0x4f, 0xb6, 0xd0, 0xd1}};

const IID IID_IADsNameTranslate = {0xb1b272a3,0x3625,0x11d1,{0xa3,0xa4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};
const CLSID CLSID_NameTranslate = {0x274fae1f,0x3626,0x11d1,{0xa3,0xa4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

const IID IID_IADsLargeInteger = {0x9068270b,0x0939,0x11d1,{0x8b,0xe1,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const CLSID CLSID_LargeInteger = {0x927971f5,0x0939,0x11d1,{0x8b,0xe1,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const IID IID_IADsAcl = {0x8452d3ab,0x0869,0x11d1,{0xa3,0x77,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_NetAddress,0xb0b71247L,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsNetAddress = {0xb21a50a9,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_Path,0xb2538919L,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsPath = {0xb287fcd5,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_Timestamp,0xb2bed2ebL,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsTimestamp = {0xb2f5a901,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_TypedName,0xb33143cbL,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsTypedName = {0xb371a349,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_Hold,0xb3ad3e13L,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsHold = {0xb3eb3b37,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_ReplicaPointer,0xf5d1badfL,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsReplicaPointer= {0xf60fb803,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_BackLink,0xfcbf906fL,0x4080,0x11D1,0xA3,0xAC,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsBackLink = {0xfd1302bd,0x4080,0x11d1,{0xa3,0xac,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_PostalAddress,0x0a75afcdL,0x4680,0x11D1,0xA3,0xB4,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsPostalAddress = {0x7adecf29,0x4680,0x11d1,{0xa3,0xb4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_OctetList,0x1241400fL,0x4680,0x11D1,0xA3,0xB4,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsOctetList= {0x7b28b80f,0x4680,0x11d1,{0xa3,0xb4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_CaseIgnoreList,0x15f88a55L,0x4680,0x11D1,0xA3,0xB4,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsCaseIgnoreList = {0x7b66b533,0x4680,0x11d1,{0xa3,0xb4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_FaxNumber,0xa5062215L,0x4681,0x11D1,0xA3,0xB4,0x00,0xC0,0x4F,0xB9,0x50,0xDC);
const IID IID_IADsFaxNumber= {0xa910dea9,0x4680,0x11d1,{0xa3,0xb4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

DEFINE_GUID(CLSID_Email,0x8f92a857L,0x478e,0x11D1,0xA3,0xB4,0x00,0xC0,0x4F,0xB9,0x50,0xDC);

const IID IID_IADsEmail= {0x97af011a,0x478e,0x11d1,{0xa3,0xb4,0x00,0xc0,0x4f,0xb9,0x50,0xdc}};

const IID IID_IPrivateDispatch = {0x86ab4bbe,0x65f6,0x11d1,{0x8c,0x13,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

const IID IID_IPrivateUnknown = {0x89126bab,0x6ead,0x11d1,{0x8c,0x18,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};

DEFINE_GUID(IID_IADsExtension, 0x3d35553c, 0xd2b0, 0x11d1, 0xb1, 0x7b, 0x0, 0x0, 0xf8, 0x75, 0x93, 0xa0);

const IID IID_IADsDeleteOps = {0xb2bd0902,0x8878,0x11d1,{0x8c,0x21,0x00,0xc0,0x4f,0xd8,0xd5,0x03}};


//
// Umi specific GUIDS
//
/*
DEFINE_GUID(IID_IUmiPropList,0x12575a7b,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiBaseObject,0x12575a7c,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiConnection,0x5ed7ee20,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiContainer,0x5ed7ee21,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiObject,0x5ed7ee23,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiCursor,0x5ed7ee26,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiObjectSink,0x5ed7ee24,0x64a4,0x11d3,0xa0,0xda,0x00,0x10,0x5a,0x1f,0x51,0x5a);


DEFINE_GUID(IID_IUmiURL,0x12575a7d,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);

DEFINE_GUID(IID_IUmiPathKeyList,0xcf779c98,0x4739,0x4fd4,0xa4,0x15,0xda,0x93,0x7a,0x59,0x9f,0x2f);

DEFINE_GUID(IID_IUmiQuery,0x12575a7e,0xd9db,0x11d3,0xa1,0x1f,0x00,0x10,0x5a,0x1f,0x51,0x5a);
*/

//
// LDAP Connection object GUID - uuid(7da2a9c4-0c46-43bd-b04e-d92b1be27c45)
//
DEFINE_GUID(CLSID_LDAPConnectionObject,0x7da2a9c4,0x0c46,0x43bd,0xb0,0x4e,0xd9,0x2b,0x1b,0xe2,0x7c,0x45);

// 
// WinNT Connection object GUID - uuid(7992c6eb-d142-4332-831e-3154c50a8316)
//
DEFINE_GUID(CLSID_WinNTConnectionObject,0x7992c6eb,0xd142,0x4332,0x83,0x1e,0x31,0x54,0xc5,0x0a,0x83,0x16);

//
// CLSID to represent non-extension objects for IUmiCustomInterface calls
//
DEFINE_GUID(CLSID_WinNTObject,0xb8324185,0x4050,0x4220,0x98,0x0a,0xab,0x14,0x62,0x3e,0x06,0x3a);

//
// CLSID to represent non-extension interfaces for LDAP objects - 05709878-5195-466c-9e64-487ce3ca20bf
//
DEFINE_GUID(CLSID_LDAPObject,0x05709878,0x5195,0x466c,0x9e,0x64,0x48,0x7c,0xe3,0xca,0x20,0xbf);

//
// LDAP Umi Query object GUID - uuid(cd5d4d76-a818-4f95-b958-7970fd9412ca)
//
DEFINE_GUID(CLSID_UmiLDAPQueryObject, 0xcd5d4d76,0xa818,0x4f95,0xb9,0x58,0x79,0x70,0xfd,0x94,0x12,0xca);

//
// Private Umi helper routine GUID - 4fe243f0-ad89-4cbc-9b14-486126446ae0.
//
DEFINE_GUID(IID_IADsUmiHelperPrivate, 0x4fe243f0,0xad89,0x4cbc,0x9b,0x14,0x48,0x61,0x26,0x44,0x6a,0xe0);

DEFINE_GUID(IID_IUmiADSIPrivate,0xcfcecb01,0x3123,0x4926,0xb5,0xe3,0x62,0x78,0x08,0x27,0x26,0x43);

//
// Definition for private ACE helper interface GUID - fd145df2-fd96-4135-9b22-68ff0f6bf5bb
//
DEFINE_GUID(IID_IADsAcePrivate, 0xfd145df2, 0xfd96, 0x4135,0x9b, 0x22, 0x68, 0xff, 0x0f, 0x6b, 0xf5, 0xbb);

//
// ADS Util related GUIDs.
//
DEFINE_GUID(CLSID_ADsSecurityUtility, 0xf270c64a, 0xffb8, 0x4ae4, 0x85, 0xfe, 0x3a, 0x75, 0xe5, 0x34, 0x79, 0x66);
DEFINE_GUID(IID_IADsSecurityUtility, 0xa63251b2, 0x5f21, 0x474b, 0xab, 0x52, 0x4a, 0x8e, 0xfa, 0xd1, 0x08, 0x95);

//
// Define the OLE DB specific GUIDs
//

DEFINE_GUID(CLSID_ADsDSOObject,0x549365D0L,0xEC26,0x11CF,0x83,0x10,0x00,0xAA,0x00,0xB5,0x05,0xDB);

DEFINE_GUID(DBGUID_LDAPDialect, 0xEFF65380L, 0x9C98, 0x11CF, 0xB9, 0x63, 0x00, 0xAA, 0x00, 0x44, 0x77, 0x3D);

DEFINE_GUID(DBPROPSET_ADSISEARCH, 0xcfcfc928, 0x9aa2, 0x11d0, 0xa7, 0x9a, 0x00, 0xc0, 0x4f, 0xd8, 0xd5, 0xa8);

DEFINE_GUID(DBPROPSET_ADSIBIND, 0x6da66dc8, 0xb7e8, 0x11d2, 0x9d, 0x60, 0x0, 0xc0, 0x4f, 0x68, 0x93, 0x45);

#define DBINITCONSTANTS
#include "oledb.h"
#include "oledberr.h"
#include "msdaguid.h"
#include "msdatt.h"
#include "msdadc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nwutils\win95\printwrp.cxx ===
#include "procs.hxx"
#pragma hdrstop

/*++

Copyright (c) 1996  Microsoft Corporation
All rights reserved

Module Name:

    PrintWrp.c

Abstract:

    Wide end to Win95 Ansi printing APIs

Author:
    Felix Wong (t-felixw)

Environment:

Revision History:

--*/

#include "dswarn.h"
#include <stddef.h>
#include <stdio.h>
#include <string.h>
#include <data.h>

typedef struct _SPOOL *PSPOOL;
typedef struct _NOTIFY *PNOTIFY;

typedef struct _NOTIFY {
    PNOTIFY  pNext;
    HANDLE   hEvent;      // event to trigger on notification
    DWORD    fdwFlags;    // flags to watch for
    DWORD    fdwOptions;  // PRINTER_NOTIFY_*
    DWORD    dwReturn;    // used by WPC when simulating FFPCN
    PSPOOL   pSpool;
} NOTIFY;

typedef struct _SPOOL {
    DWORD       signature;
    HANDLE      hPrinter;
    HANDLE      hFile;
    DWORD       JobId;
    LPBYTE      pBuffer;
    DWORD       cbBuffer;
    DWORD       Status;
    DWORD       fdwFlags;
    DWORD       cCacheWrite;
    DWORD       cWritePrinters;
    DWORD       cFlushBuffers;
    DWORD       dwTickCount;
    DWORD       dwCheckJobInterval;
    PNOTIFY     pNotify;
} SPOOL;

#define SPOOL_STATUS_ANSI                  0x00000004
#define MIN_DEVMODE_SIZEW 72
#define MIN_DEVMODE_SIZEA 40
#define NULL_TERMINATED 0


BOOL
ConvertAnsiToUnicodeBuf(
    LPBYTE pAnsiBlob,
    LPBYTE pUnicodeBlob,
    DWORD dwAnsiSize,
    DWORD dwUnicodeSize,
    PDWORD pOffsets
    );


BOOL
bValidDevModeW(
    const DEVMODEW *pDevModeW
    )

/*++

Routine Description:

    Check whether a devmode is valid to be RPC'd across to the spooler.

Arguments:

    pDevMode - DevMode to check.

Return Value:

    TRUE - Devmode can be RPC'd to spooler.
    FALSE - Invalid Devmode.

--*/

{
    if( !pDevModeW ){
        return FALSE;
    }

    if( pDevModeW->dmSize < MIN_DEVMODE_SIZEW ){

        //
        // The only valid case is if pDevModeW is NULL.  If it's
        // not NULL, then a bad devmode was passed in and the
        // app should fix it's code.
        //
        ASSERT( pDevModeW->dmSize >= MIN_DEVMODE_SIZEW );
        return FALSE;
    }

    return TRUE;
}

LPSTR
AllocateAnsiString(
    LPWSTR  pPrinterName
)
{
    LPSTR  pAnsiString;

    if (!pPrinterName)
        return NULL;

    pAnsiString = (LPSTR)LocalAlloc(LPTR, wcslen(pPrinterName)*sizeof(CHAR) +
                                      sizeof(CHAR));

    if (pAnsiString)
        UnicodeToAnsiString(pPrinterName, pAnsiString, NULL_TERMINATED);

    return pAnsiString;
}


LPSTR
FreeAnsiString(
    LPSTR  pAnsiString
)
{
    if (!pAnsiString)
        return NULL;

    return (LPSTR)LocalFree(pAnsiString);
}


/***************************** Function Header ******************************
 * AllocateAnsiDevMode
 *      Allocate an ANSI version of the DEVMODE structure, and optionally
 *      copy the contents of the ANSI version passed in.
 *
 * RETURNS:
 *      Address of newly allocated structure, 0 if storage not available.
 *
 * HISTORY:
 * 09:23 on 10-Aug-92 -by- Lindsay Harris [lindsayh]
 *      Made it usable.
 *
 * Originally "written" by DaveSn.
 *
 ***************************************************************************/

LPDEVMODEA
AllocateAnsiDevMode(
    LPDEVMODEW pUNICODEDevMode
    )
{
    LPDEVMODEA  pAnsiDevMode;
    LPBYTE      p1, p2;
    DWORD       dwSize;

    //
    // If the devmode is NULL, then return NULL -- KrishnaG
    //
    if ( !pUNICODEDevMode || !pUNICODEDevMode->dmSize ) {
        return NULL;
    }

    ASSERT( bValidDevModeW( pUNICODEDevMode ));

    //
    // Determine output structure size.  This has two components:  the
    // DEVMODEW structure size,  plus any private data area.  The latter
    // is only meaningful when a structure is passed in.
    //
    dwSize = pUNICODEDevMode->dmSize + pUNICODEDevMode->dmDriverExtra
                                  + sizeof(DEVMODEA) - sizeof(DEVMODEW);

    pAnsiDevMode = (LPDEVMODEA) LocalAlloc(LPTR, dwSize);

    if( !pAnsiDevMode ) {
        return NULL;                   /* This is bad news */
    }

    //
    // Copy dmDeviceName which is a string
    //
    UnicodeToAnsiString(pUNICODEDevMode->dmDeviceName,
                        (LPSTR)(pAnsiDevMode->dmDeviceName),
                        ComputeMaxStrlenW(pUNICODEDevMode->dmDeviceName,
                                     sizeof pUNICODEDevMode->dmDeviceName));

    //
    // Does the devmode we got have a dmFormName? (Windows 3.1 had
    // DevMode of size 40 and did not have dmFormName)
    //
    if ( (LPBYTE)pUNICODEDevMode + pUNICODEDevMode->dmSize >
                                    (LPBYTE) pUNICODEDevMode->dmFormName ) {

        //
        // Copy everything between dmDeviceName and dmFormName
        //
        p1      = (LPBYTE) pUNICODEDevMode->dmDeviceName +
                                    sizeof(pUNICODEDevMode->dmDeviceName);
        p2      = (LPBYTE) pUNICODEDevMode->dmFormName;


        CopyMemory((LPBYTE) pAnsiDevMode->dmDeviceName +
                            sizeof(pAnsiDevMode->dmDeviceName),
                   p1,
                   p2 - p1);

        //
        // Copy dmFormName which is a string
        //
        UnicodeToAnsiString(pUNICODEDevMode->dmFormName,
                            (LPSTR)(pAnsiDevMode->dmFormName),
                            ComputeMaxStrlenW(pUNICODEDevMode->dmFormName,
                                         sizeof pUNICODEDevMode->dmFormName));

        //
        // Copy everything after dmFormName
        //
        p1      = (LPBYTE) pUNICODEDevMode->dmFormName +
                                sizeof(pUNICODEDevMode->dmFormName);
        p2      = (LPBYTE) pUNICODEDevMode + pUNICODEDevMode->dmSize
                                        + pUNICODEDevMode->dmDriverExtra;

        CopyMemory((LPBYTE) pAnsiDevMode->dmFormName +
                                sizeof(pAnsiDevMode->dmFormName),
                    p1,
                    p2 - p1);

        pAnsiDevMode->dmSize = pUNICODEDevMode->dmSize + sizeof(DEVMODEA)
                                                       - sizeof(DEVMODEW);
    } else {

        //
        // Copy everything after dmDeviceName
        //
        p1 = (LPBYTE) pUNICODEDevMode->dmDeviceName +
                                    sizeof(pUNICODEDevMode->dmDeviceName);
        p2 = (LPBYTE) pUNICODEDevMode + pUNICODEDevMode->dmSize + pUNICODEDevMode->dmDriverExtra;

        CopyMemory((LPBYTE) pAnsiDevMode->dmDeviceName +
                            sizeof(pAnsiDevMode->dmDeviceName),
                   p1,
                   p2-p1);

        pAnsiDevMode->dmSize = pUNICODEDevMode->dmSize
                                        + sizeof(pAnsiDevMode->dmDeviceName)
                                        - sizeof(pUNICODEDevMode->dmDeviceName);
    }

    ASSERT(pAnsiDevMode->dmDriverExtra == pUNICODEDevMode->dmDriverExtra);


    return pAnsiDevMode;
}

/************************** Function Header ******************************
 * CopyUnicodeDevModeFromAnsiDevMode
 *      Converts the ANSI version of the DEVMODE to the UNICODE version.
 *
 * RETURNS:
 *      Nothing.
 *
 * HISTORY:
 * 09:57 on 10-Aug-92  -by-  Lindsay Harris [lindsayh]
 *      This one actually works!
 *
 * Originally dreamed up by DaveSn.
 *
 **************************************************************************/

void
CopyUnicodeDevModeFromAnsiDevMode(
    LPDEVMODEW  pUNICODEDevMode,              /* Filled in by us */
    LPDEVMODEA  pAnsiDevMode            /* Source of data to fill above */
)
{
    LPBYTE  p1, p2, pExtra;
    WORD    dmSize, dmDriverExtra;

    //
    // NOTE:    THE TWO INPUT STRUCTURES MAY BE THE SAME.
    //
    dmSize          = pAnsiDevMode->dmSize;
    dmDriverExtra   = pAnsiDevMode->dmDriverExtra;
    pExtra          = (LPBYTE) pAnsiDevMode + pAnsiDevMode->dmSize;

    //
    // Copy dmDeviceName which is a string
    //
    AnsiToUnicodeString((LPSTR)(pAnsiDevMode->dmDeviceName),
                        (pUNICODEDevMode->dmDeviceName),
                        ComputeMaxStrlenA((LPSTR)(pAnsiDevMode->dmDeviceName),
                                     sizeof pUNICODEDevMode->dmDeviceName));

    //
    // Does the devmode we got have a dmFormName? (Windows 3.1 had
    // DevMode of size 40 and did not have dmFormName)
    //
    if ( (LPBYTE)pAnsiDevMode + dmSize >
                                    (LPBYTE) pAnsiDevMode->dmFormName ) {

        //
        // Copy everything between dmDeviceName and dmFormName
        //
        p1      = (LPBYTE) pAnsiDevMode->dmDeviceName +
                                    sizeof(pAnsiDevMode->dmDeviceName);
        p2      = (LPBYTE) pAnsiDevMode->dmFormName;

        MoveMemory((LPBYTE) pUNICODEDevMode->dmDeviceName +
                                sizeof(pUNICODEDevMode->dmDeviceName),
                    p1,
                    p2 - p1);

        //
        // Copy dmFormName which is a string
        //
        AnsiToUnicodeString((LPSTR)(pAnsiDevMode->dmFormName),
                            pUNICODEDevMode->dmFormName,
                            ComputeMaxStrlenA((LPSTR)pAnsiDevMode->dmFormName,
                                         sizeof pUNICODEDevMode->dmFormName));

        //
        // Copy everything after dmFormName
        //
        p1      = (LPBYTE) pAnsiDevMode->dmFormName +
                                sizeof(pAnsiDevMode->dmFormName);
        p2      = (LPBYTE) pAnsiDevMode + dmSize + dmDriverExtra;

        MoveMemory((LPBYTE) pUNICODEDevMode->dmFormName +
                                sizeof(pUNICODEDevMode->dmFormName),
                    p1,
                    p2 - p1);


        pUNICODEDevMode->dmSize = dmSize + sizeof(DEVMODEW) - sizeof(DEVMODEA);
    } else {

        //
        // Copy everything after dmDeviceName
        //
        p1      = (LPBYTE) pAnsiDevMode->dmDeviceName +
                                sizeof(pAnsiDevMode->dmDeviceName);
        p2      = (LPBYTE) pAnsiDevMode + dmSize + dmDriverExtra;

        MoveMemory((LPBYTE) pUNICODEDevMode->dmDeviceName +
                                sizeof(pUNICODEDevMode->dmDeviceName),
                   p1,
                   p2 - p1);


        pUNICODEDevMode->dmSize = dmSize + sizeof(pUNICODEDevMode->dmDeviceName)
                                      - sizeof(pAnsiDevMode->dmDeviceName);
    }

    ASSERT(pUNICODEDevMode->dmDriverExtra == dmDriverExtra);

    return;
}

void
ConvertAnsiToUnicodeStrings(
    LPBYTE  pStructure,
    LPDWORD pOffsets
)
{
    register DWORD  i=0;
    LPSTR           pAnsi;
    LPWSTR          pUnicode;

    while (pOffsets[i] != -1) {
        pAnsi = *(LPSTR *)(pStructure+pOffsets[i]);
        if (pAnsi) {
            pUnicode = (LPWSTR)LocalAlloc( LPTR, 
                                           strlen(pAnsi)*sizeof(WCHAR)+
                                                sizeof(WCHAR));
            if (pUnicode) {
                AnsiToUnicodeString(pAnsi, 
                                    pUnicode, 
                                    NULL_TERMINATED);
                *(LPWSTR *)(pStructure+pOffsets[i]) = pUnicode;
                LocalFree(pAnsi);
            }
        }
        i++;
    }
}

LPBYTE
AllocateAnsiStructure(
    LPBYTE  pUnicodeStructure,
    DWORD   cbStruct,
    LPDWORD pOffsets
)
{
    DWORD   i, j;
    LPSTR   *ppAnsiString;
    LPWSTR  *ppUnicodeString;
    LPBYTE  pAnsiStructure;


    if (!pUnicodeStructure) {
        return NULL;
    }
    pAnsiStructure = (LPBYTE)LocalAlloc(LPTR, cbStruct);

    if (pAnsiStructure) {

        memcpy(pAnsiStructure, pUnicodeStructure, cbStruct);

        for (i = 0 ; pOffsets[i] != -1 ; ++i) {

            ppUnicodeString = (LPWSTR *)(pUnicodeStructure+pOffsets[i]);
            ppAnsiString = (LPSTR *)(pAnsiStructure+pOffsets[i]);

            *ppAnsiString = AllocateAnsiString(*ppUnicodeString);

            if (*ppUnicodeString && !*ppAnsiString) {

                for( j = 0 ; j < i ; ++j) {
                    ppAnsiString = (LPSTR *)(pAnsiStructure+pOffsets[j]);
                    FreeAnsiString(*ppAnsiString);
                }
                LocalFree(pAnsiStructure);
                pAnsiStructure = NULL;
                break;
            }
       }
    }

    return pAnsiStructure;
}

void
FreeAnsiStructure(
    LPBYTE  pAnsiStructure,
    LPDWORD pOffsets
)
{
    DWORD   i=0;

    if ( pAnsiStructure == NULL ) {
        return;
    }

    while (pOffsets[i] != -1) {

        FreeAnsiString(*(LPSTR *)(pAnsiStructure+pOffsets[i]));
        i++;
    }

    LocalFree( pAnsiStructure );
}


BOOL
EnumJobsW(
    HANDLE  hPrinter,
    DWORD   FirstJob,
    DWORD   NoJobs,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcReturned
)
{
    DWORD   i, cbStruct, *pOffsets;

    switch (Level) {

    case 1:
        pOffsets = JobInfo1StringsA;
        cbStruct = sizeof(JOB_INFO_1W);
        break;

    case 2:
        pOffsets = JobInfo2StringsA;
        cbStruct = sizeof(JOB_INFO_2W);
        break;

    case 3:
        return EnumJobsA( hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf, pcbNeeded, pcReturned );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (EnumJobsA(hPrinter, FirstJob, NoJobs, Level, pJob, cbBuf, pcbNeeded,
                 pcReturned)) {

        i=*pcReturned;

        while (i--) {

            ConvertAnsiToUnicodeStrings(pJob, pOffsets);

            //
            // Convert the devmode in place for INFO_2.
            //
            if( Level == 2 ){

                PJOB_INFO_2W pJobInfo2 = (PJOB_INFO_2W)pJob;

                if( pJobInfo2->pDevMode ){
                    CopyUnicodeDevModeFromAnsiDevMode(
                        (LPDEVMODEW)pJobInfo2->pDevMode,
                        (LPDEVMODEA)pJobInfo2->pDevMode);
                }
            }

            pJob += cbStruct;
        }

        return TRUE;

    } else

        return FALSE;
}

BOOL
GetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD   *pOffsets;

    switch (Level) {

    //case STRESSINFOLEVEL:
    //    pOffsets = PrinterInfoStressOffsetsA;
    //    break;

    case 1:
        pOffsets = PrinterInfo1StringsA;
        break;

    case 2:
        pOffsets = PrinterInfo2StringsA;
        break;

    case 3:
        pOffsets = PrinterInfo3StringsA;
        break;

    case 4:
        pOffsets = PrinterInfo4StringsA;
        break;

    case 5:
        pOffsets = PrinterInfo5StringsA;
        break;

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }

    if (GetPrinterA(hPrinter, Level, pPrinter, cbBuf, pcbNeeded)) {

        if (pPrinter) {

            ConvertAnsiToUnicodeStrings(pPrinter, pOffsets);

            if ((Level == 2) && pPrinter) {

                PRINTER_INFO_2W *pPrinterInfo2 = (PRINTER_INFO_2W *)pPrinter;

                if (pPrinterInfo2->pDevMode)
                    CopyUnicodeDevModeFromAnsiDevMode(
                                        (LPDEVMODEW)pPrinterInfo2->pDevMode,
                                        (LPDEVMODEA)pPrinterInfo2->pDevMode);
            }
        }

        return TRUE;
    }

    return FALSE;
}

BOOL
SetPrinterW(
    HANDLE  hPrinter,
    DWORD   Level,
    LPBYTE  pPrinter,
    DWORD   Command
)
{
    LPBYTE  pAnsiStructure;         /* Ansi version of input data */
    DWORD   cbStruct;                  /* Size of the output structure */
    DWORD  *pOffsets;                  /* -1 terminated list of addresses */
    DWORD   ReturnValue=FALSE;

    switch (Level) {

    case 0:
        //
        // This could be 2 cases. STRESSINFOLEVEL, or the real 0 level.
        // If Command is 0 then it is STRESSINFOLEVEL, else real 0 level
        //
        /*
                if ( !Command ) {

            pOffsets = PrinterInfoStressStringsA;
            cbStruct = sizeof( PRINTER_INFO_STRESSA );
        }
                */
        break;

    case 1:
        pOffsets = PrinterInfo1StringsA;
        cbStruct = sizeof( PRINTER_INFO_1W );
        break;

    case 2:
        pOffsets = PrinterInfo2StringsA;
        cbStruct = sizeof( PRINTER_INFO_2W );
        break;

    case 3:
        pOffsets = PrinterInfo3StringsA;
        cbStruct = sizeof( PRINTER_INFO_3);
        break;

    case 4:
        pOffsets = PrinterInfo4StringsA;
        cbStruct = sizeof( PRINTER_INFO_4W );
        break;

    case 5:
        pOffsets = PrinterInfo5StringsA;
        cbStruct = sizeof( PRINTER_INFO_5W );
        break;

    case 6:
        break;

    default:
        SetLastError( ERROR_INVALID_LEVEL );
        return FALSE;
    }

     //
     //    The structure needs to have its CONTENTS converted from
     //  ANSI to Unicode.  The above switch() statement filled in
     //  the two important pieces of information needed to accomplish
     //  this goal.  First is the size of the structure, second is
     //  a list of the offset within the structure to UNICODE
     //  string pointers.  The AllocateUnicodeStructure() call will
     //  allocate a wide version of the structure, copy its contents
     //  and convert the strings to Unicode as it goes.  That leaves
     //  us to deal with any other pieces needing conversion.
     //

    //
    // If Level == 0 and Command != 0 then pPrintert is a DWORD
    //
    if ( Level == 6 || (!Level && Command) ) {

        if ( Level == 6 || Command == PRINTER_CONTROL_SET_STATUS )
            pAnsiStructure = pPrinter;
        else
            pAnsiStructure = NULL;
    } else {

        pAnsiStructure = AllocateAnsiStructure(pPrinter, cbStruct, pOffsets);
        if (pPrinter && !pAnsiStructure)
            return FALSE;
    }

#define pPrinterInfo2A  ((LPPRINTER_INFO_2A)pAnsiStructure)
#define pPrinterInfo2W  ((LPPRINTER_INFO_2W)pPrinter)

    //  The Level 2 structure has a DEVMODE struct in it: convert now

    if ( Level == 2  &&
         pAnsiStructure &&
         pPrinterInfo2W->pDevMode ) {

        if( bValidDevModeW( pPrinterInfo2W->pDevMode )){
            pPrinterInfo2A->pDevMode = AllocateAnsiDevMode(
                                           pPrinterInfo2W->pDevMode );

            if( !pPrinterInfo2A->pDevMode) {
                FreeAnsiStructure(pAnsiStructure, pOffsets);
                return FALSE;
            }
        }
    }

    ReturnValue = SetPrinterA( hPrinter, Level, pAnsiStructure, Command );


    //  Free the DEVMODE we allocated (if we did!), then the
    //  the Unicode structure and its contents.


    if (Level == 2 &&
        pAnsiStructure &&
        pPrinterInfo2A->pDevMode ) {

        LocalFree( pPrinterInfo2A->pDevMode );
    }

    //
    // STRESS_INFO and Levels 1-5
    //
    if ( Level != 6 && (Level || !Command) )
        FreeAnsiStructure( pAnsiStructure, pOffsets );

#undef pPrinterInfo2A
#undef pPrinterInfo2W
    
        return ReturnValue;
}

BOOL
SetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   Command
)
{
    BOOL        ReturnValue=FALSE;
    LPBYTE      pAnsiStructure=NULL;
    LPDEVMODEA  pDevModeA = NULL;
    DWORD       cbStruct;
    DWORD       *pOffsets;

    switch (Level) {

    case 0:
        break;

    case 1:
        pOffsets = JobInfo1StringsA;
        cbStruct = sizeof(JOB_INFO_1W);
        break;

    case 2:
        pOffsets = JobInfo2StringsA;
        cbStruct = sizeof(JOB_INFO_2W);
        break;

    case 3:
        return SetJobA( hPrinter, JobId, Level, pJob, Command );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }


    if (Level) {
        pAnsiStructure = AllocateAnsiStructure(pJob, cbStruct, pOffsets);
        if (pJob && !pAnsiStructure)
            return FALSE;
    }

    if ( Level == 2 && pAnsiStructure && pJob ) {

        if( bValidDevModeW( ((LPJOB_INFO_2W)pJob)->pDevMode )){

            pDevModeA = AllocateAnsiDevMode(((LPJOB_INFO_2W)pJob)->pDevMode);

            if( !pDevModeA ){
                ReturnValue = FALSE;
                goto Cleanup;
            }
            ((LPJOB_INFO_2A) pAnsiStructure)->pDevMode = pDevModeA;
        }
    }

    ReturnValue = SetJobA(hPrinter, JobId, Level, pAnsiStructure, Command);

    if ( pDevModeA ) {

        LocalFree(pDevModeA);
    }

Cleanup:
    FreeAnsiStructure(pAnsiStructure, pOffsets);

    return ReturnValue;
}

BOOL
GetJobW(
    HANDLE  hPrinter,
    DWORD   JobId,
    DWORD   Level,
    LPBYTE  pJob,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    DWORD *pOffsets;
    LPBYTE pJobA = NULL;
    DWORD cbNeededA = 0;
    DWORD cbBufA = 0;
    DWORD dwJobStructSizeW = 0;
    DWORD dwJobStructSizeA = 0;
    BOOL fRetval;

    switch (Level) {

    case 1:
        pOffsets = JobInfo1StringsA;
        dwJobStructSizeW = sizeof(JOB_INFO_1W);
        dwJobStructSizeA = sizeof(JOB_INFO_1A);
        break;

    case 2:
        pOffsets = JobInfo2StringsA;
        dwJobStructSizeW = sizeof(JOB_INFO_2W);
        dwJobStructSizeA = sizeof(JOB_INFO_2A);
        break;

    case 3:
        return GetJobA( hPrinter, JobId, Level, pJob, cbBuf, pcbNeeded );

    default:
        SetLastError(ERROR_INVALID_LEVEL);
        return FALSE;
    }


    //
    // GetJobA is broken. THis is a workaround here which will work 
    // sometimes. The AV problem however goes away.
    //
    // Ramv bug fix: The user has passed in a certain amount of 
    // unicode memory. This has to be appropriately translated into
    // equivalent ANSI memory.
    //
    //
    // The translation is to take the entire blob of memory and
    // subtract sizeof(JOB_INFO_2W) and then divide the remaining memory
    // into 2. 
    //
    // we also have to contend with GetJobA's erroneous return values
    // when we pass in a buffer of sixe 0, it gives back wrong results
    //
    //
    //

    cbBufA = cbBuf > dwJobStructSizeW ?  
        (cbBuf-dwJobStructSizeW)/sizeof(WCHAR) + dwJobStructSizeA : 64;


    pJobA = (LPBYTE)AllocADsMem( cbBufA);
    
    if (!pJobA){
        goto error;
    }
    
    
    fRetval = GetJobA (hPrinter, JobId, Level, pJobA, cbBufA, &cbNeededA);

    if ( fRetval) {
        
        //
        // RamV bug fix.
        // The size that we get back is actually the size of
        // the ANSI array needed. We need our array to be larger for 
        // unicode by an amount = (total lengths of all strings +1)
        // times the sizeof(WCHAR)
        //
        
        
        //
        // Looks like we have sufficient memory here for our operations
        // we need to copy the memory blob from Ansi to Unicode
        //
        
        
        // 
        // Thanks to win95 returning erroneous values, we are forced
        // to fail this call even though it succeeded and send back 
        // the cbNeededA value converted into the Unicode value
        //

        if (cbBuf == 0){
            *pcbNeeded = 2*cbNeededA; // just being conservative here by
            
            // allocating a little more space than needed

            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto error;
        }

        if (!ConvertAnsiToUnicodeBuf(
            pJobA, 
            pJob,
            dwJobStructSizeA,
            dwJobStructSizeW,
            pOffsets)){
            
            goto error;
        }
        
        //
        // Convert the devmode in place for INFO_2.
        //
        if( Level == 2 ){
            
            PJOB_INFO_2W pJobInfo2 = (PJOB_INFO_2W)pJob;
            
            if( pJobInfo2->pDevMode ){
                CopyUnicodeDevModeFromAnsiDevMode(
                    (LPDEVMODEW)pJobInfo2->pDevMode,
                    (LPDEVMODEA)pJobInfo2->pDevMode);
            }
        }
        
        return TRUE;
        
        } else {
      
            //
            // RamV bug fix.
            // The size that we get back is actually the size of
            // the ANSI array needed. We need our array to be larger for 
            // unicode by an amount = (total lengths of all strings +1)
            // times the sizeof(WCHAR)
            //
            
            if(cbNeededA) {
                //
                // we need to translate this into unicode terms
                //
                
                *pcbNeeded = dwJobStructSizeW + 
                    (cbBufA + cbNeededA - dwJobStructSizeA)*sizeof(WCHAR);
            }
            
            return FALSE;
        }
    
error: 
    if(pJobA) {
        FreeADsMem(pJobA);
    }

    return FALSE;
}



BOOL
ConvertAnsiToUnicodeBuf(
    LPBYTE pAnsiBlob,
    LPBYTE pUnicodeBlob,
    DWORD dwAnsiSize,
    DWORD dwUnicodeSize,
    PDWORD pOffsets
    )

{
    DWORD i = 0;
    LPSTR pAnsi;
    LPBYTE pUnicode;
    LPBYTE pszString = pUnicodeBlob + dwUnicodeSize;
    LPBYTE pStringPos = NULL;

    memcpy(pUnicodeBlob, pAnsiBlob, dwAnsiSize);

    pUnicode = pszString;
    while (pOffsets[i] != -1) {
        pAnsi = *(LPSTR *)(pAnsiBlob + pOffsets[i]);

        if (!AnsiToUnicodeString((LPSTR)pAnsi,
                                 (LPWSTR)pUnicode,
                                 NULL_TERMINATED )){
            return(FALSE);
        }

        pStringPos = pUnicodeBlob +pOffsets[i];

        *((LPBYTE *)pStringPos) = pUnicode;

        pUnicode = pUnicode + (wcslen((LPWSTR)(pUnicode))+1)* sizeof(WCHAR);
        
        i++;
    }
    
    return(TRUE);

}

    

    

BOOL
OpenPrinterW(
    LPWSTR pPrinterName,
    LPHANDLE phPrinter,
    LPPRINTER_DEFAULTSW pDefault
    )
{
    BOOL ReturnValue = FALSE;
    LPSTR pAnsiPrinterName = NULL;
    PRINTER_DEFAULTSA AnsiDefaults={NULL, NULL, 0};

    pAnsiPrinterName = AllocateAnsiString(pPrinterName);
    
        if (pPrinterName && !pAnsiPrinterName)
        goto Cleanup;

    if (pDefault) {

        AnsiDefaults.pDatatype = AllocateAnsiString(pDefault->pDatatype);
        if (pDefault->pDatatype && !AnsiDefaults.pDatatype)
            goto Cleanup;

        //
        // Milestones etc. 4.5 passes in a bogus devmode in pDefaults.
        // Be sure to validate here.
        //
        if( bValidDevModeW( pDefault->pDevMode )){

            AnsiDefaults.pDevMode = AllocateAnsiDevMode(
                                           pDefault->pDevMode );

            if( !AnsiDefaults.pDevMode ){
                goto Cleanup;
            }
        }

        AnsiDefaults.DesiredAccess = pDefault->DesiredAccess;
    }

    ReturnValue = OpenPrinterA(pAnsiPrinterName, phPrinter, &AnsiDefaults);

/*  Ramv This code below causes AV. I have disabled it
    MattRim 1-10-00: Leaving this disabled.  phPrinter is an opaque handle
    to an undocumented structure.  Trying to manipulate it is a surefire way
    to cause AVs if a service pack/O.S. upgrade ever changes the implementation
    of this Win9x-internal structure.
    if (ReturnValue) {

        ((PSPOOL)*phPrinter)->Status |= SPOOL_STATUS_ANSI;
    }

    */


Cleanup:

    if (AnsiDefaults.pDevMode)
        LocalFree(AnsiDefaults.pDevMode);

    FreeAnsiString(AnsiDefaults.pDatatype);
    FreeAnsiString(pAnsiPrinterName);

    return ReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\adsqdoc.cpp ===
// adsqryDoc.cpp : implementation of the CAdsqryDoc class
//

#include "stdafx.h"
#include "adsqDoc.h"
#include "newquery.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAdsqryDoc

IMPLEMENT_DYNCREATE(CAdsqryDoc, CDocument)

BEGIN_MESSAGE_MAP(CAdsqryDoc, CDocument)
	//{{AFX_MSG_MAP(CAdsqryDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAdsqryDoc construction/destruction

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CAdsqryDoc::CAdsqryDoc()
{
	// TODO: add one-time construction code here
   m_pDataSource  = NULL;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CAdsqryDoc::~CAdsqryDoc()
{
   if( m_pDataSource )
   {
      delete m_pDataSource;
   }
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CAdsqryDoc::OnNewDocument()
{
   CNewQuery   aNewQuery;
   CString     strTitle;
   SEARCHPREF* pSearchPref;

	if (!CDocument::OnNewDocument())
		return FALSE;

      
   if( aNewQuery.DoModal( ) != IDOK )
      return FALSE;

   pSearchPref = (SEARCHPREF*) AllocADsMem( sizeof(SEARCHPREF) );
   if( NULL == pSearchPref )
      return FALSE;

   pSearchPref->bEncryptPassword = FALSE;
   pSearchPref->bUseSQL          = FALSE;
   pSearchPref->nAsynchronous    = -1;
   pSearchPref->nDerefAliases    = -1;
   pSearchPref->nSizeLimit       = -1;
   pSearchPref->nTimeLimit       = -1;
   pSearchPref->nAttributesOnly  = -1;
   pSearchPref->nScope           = -1;
   pSearchPref->nTimeOut         = -1;
   pSearchPref->nPageSize        = -1;
   pSearchPref->nChaseReferrals  = -1;

   _tcscpy( pSearchPref->szSource, aNewQuery.m_strSource );
   _tcscpy( pSearchPref->szQuery,  aNewQuery.m_strQuery );
   _tcscpy( pSearchPref->szAttributes, aNewQuery.m_strAttributes );
   _tcscpy( pSearchPref->szScope,      aNewQuery.m_strScope );
   _tcscpy( pSearchPref->szUserName,   aNewQuery.m_strUser );
   _tcscpy( pSearchPref->szPassword,   aNewQuery.m_strPassword );

   pSearchPref->bEncryptPassword    = aNewQuery.m_bEncryptPassword;
   pSearchPref->bUseSQL             = aNewQuery.m_bUseSQL;

   if( !GetSearchPreferences( pSearchPref ) )
      return FALSE;

   if( aNewQuery.m_bUseSearch )
   {
      m_pDataSource  = new CADsSearchDataSource;
   }
   else
   {
      m_pDataSource  = new CADsOleDBDataSource;
   }


   m_pDataSource->SetQueryParameters( pSearchPref );

   FreeADsMem( pSearchPref );

   strTitle = aNewQuery.m_strSource + _T("  ")+
              aNewQuery.m_strQuery  + _T("  ")+
              aNewQuery.m_strAttributes;

   m_pDataSource->RunTheQuery( );

   SetTitle( strTitle );

	return TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL  CAdsqryDoc::GetSearchPreferences( SEARCHPREF* pSearchPref )
{
   CSearchPreferencesDlg   aSearchPref;

   if( aSearchPref.DoModal( ) != IDOK )
   {
      return FALSE;
   }
   
   //***************************************************************************
   if( !aSearchPref.m_strAsynchronous.IsEmpty( ) )
   {
      if( !aSearchPref.m_strAsynchronous.CompareNoCase( _T("Yes") ) )
      {
         pSearchPref->nAsynchronous = 1;
      }
      else
      {
         pSearchPref->nAsynchronous = 0;
      }
   }

   //***************************************************************************
   if( !aSearchPref.m_strChaseReferrals.IsEmpty( ) )
   {
      if( !aSearchPref.m_strChaseReferrals.CompareNoCase( _T("Yes") ) )
      {
         pSearchPref->nChaseReferrals = 1;
      }
      else
      {
         pSearchPref->nChaseReferrals = 0;
      }
   }
      
   //***************************************************************************
   if( !aSearchPref.m_strAttributesOnly.IsEmpty( ) )
   {
      if( !aSearchPref.m_strAttributesOnly.CompareNoCase( _T("Yes") ) )
      {
         pSearchPref->nAttributesOnly = 1;
      }
      else
      {
         pSearchPref->nAttributesOnly = 0;
      }
   }

   //***************************************************************************
   if( !aSearchPref.m_strDerefAliases.IsEmpty( ) )
   {
      if( !aSearchPref.m_strDerefAliases.CompareNoCase( _T("Yes") ) )
      {
         pSearchPref->nDerefAliases = 1;
      }
      else
      {
         pSearchPref->nDerefAliases = 0;
      }
   }

   //***************************************************************************
   if( !aSearchPref.m_strTimeOut.IsEmpty( ) )
   {
      pSearchPref->nTimeOut = _ttoi( aSearchPref.m_strTimeOut.GetBuffer( 16 ) );
   }

   //***************************************************************************
   if( !aSearchPref.m_strTimeLimit.IsEmpty( ) )
   {
      pSearchPref->nTimeLimit = _ttoi( aSearchPref.m_strTimeLimit.GetBuffer( 16 ) );
   }
   
   //***************************************************************************
   if( !aSearchPref.m_strSizeLimit.IsEmpty( ) )
   {
      pSearchPref->nSizeLimit = _ttoi( aSearchPref.m_strSizeLimit.GetBuffer( 16 ) );
   }

   //***************************************************************************
   if( !aSearchPref.m_strPageSize.IsEmpty( ) )
   {
      pSearchPref->nPageSize  = _ttoi( aSearchPref.m_strPageSize.GetBuffer( 16 ) );
   }

   //***************************************************************************
   if( !aSearchPref.m_strScope.IsEmpty( ) )
   {
      _tcscpy( pSearchPref->szScope, aSearchPref.m_strScope );
   }

   return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAdsqryDoc serialization


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CAdsqryDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CAdsqryDoc diagnostics

#ifdef _DEBUG
void CAdsqryDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CAdsqryDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CAdsqryDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\adsqdoc.h ===
// adsqryDoc.h : interface of the CAdsqryDoc class
//
/////////////////////////////////////////////////////////////////////////////

#include "adsdsrc.h"

class CAdsqryDoc : public CDocument
{
protected: // create from serialization only
	CAdsqryDoc();
	DECLARE_DYNCREATE(CAdsqryDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAdsqryDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CAdsqryDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

public:
   CADsDataSource*   GetADsDataSource( ) {return m_pDataSource;};

protected:
   BOOL              GetSearchPreferences( SEARCHPREF* );

protected:
   CADsDataSource*   m_pDataSource;

// Generated message map functions
protected:
	//{{AFX_MSG(CAdsqryDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\nwutils\win95\data.h ===
/*++

Copyright (c) 1990-1996  Microsoft Corporation
All rights reserved

Module Name:

    data.h

Abstract:

    Common definitions for structure offsets for pointer based data.

Author:

Environment:

    User Mode - Win32

Revision History:

--*/

//DWORD PrinterInfoStressOffsetsA[]={offsetof(PRINTER_INFO_STRESSW, pPrinterName),
//                             offsetof(PRINTER_INFO_STRESSW, pServerName),
//                             0xFFFFFFFF};

DWORD PrinterInfo1OffsetsA[]={offsetof(PRINTER_INFO_1W, pDescription),
                             offsetof(PRINTER_INFO_1W, pName),
                             offsetof(PRINTER_INFO_1W, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2OffsetsA[]={offsetof(PRINTER_INFO_2W, pServerName),
                             offsetof(PRINTER_INFO_2W, pPrinterName),
                             offsetof(PRINTER_INFO_2W, pShareName),
                             offsetof(PRINTER_INFO_2W, pPortName),
                             offsetof(PRINTER_INFO_2W, pDriverName),
                             offsetof(PRINTER_INFO_2W, pComment),
                             offsetof(PRINTER_INFO_2W, pLocation),
                             offsetof(PRINTER_INFO_2W, pDevMode),
                             offsetof(PRINTER_INFO_2W, pSepFile),
                             offsetof(PRINTER_INFO_2W, pPrintProcessor),
                             offsetof(PRINTER_INFO_2W, pDatatype),
                             offsetof(PRINTER_INFO_2W, pParameters),
                             offsetof(PRINTER_INFO_2W, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo3OffsetsA[]={offsetof(PRINTER_INFO_3, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo4OffsetsA[]={offsetof(PRINTER_INFO_4W, pPrinterName),
                             offsetof(PRINTER_INFO_4W, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5OffsetsA[]={offsetof(PRINTER_INFO_5W, pPrinterName),
                             offsetof(PRINTER_INFO_5W, pPortName),
                             0xFFFFFFFF};
/*
DWORD PrinterInfoStressStringsA[]={offsetof(PRINTER_INFO_STRESSW, pPrinterName),
                             offsetof(PRINTER_INFO_STRESSW, pServerName),
                             0xFFFFFFFF};
*/

DWORD PrinterInfo1StringsA[]={offsetof(PRINTER_INFO_1W, pDescription),
                             offsetof(PRINTER_INFO_1W, pName),
                             offsetof(PRINTER_INFO_1W, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2StringsA[]={offsetof(PRINTER_INFO_2W, pServerName),
                             offsetof(PRINTER_INFO_2W, pPrinterName),
                             offsetof(PRINTER_INFO_2W, pShareName),
                             offsetof(PRINTER_INFO_2W, pPortName),
                             offsetof(PRINTER_INFO_2W, pDriverName),
                             offsetof(PRINTER_INFO_2W, pComment),
                             offsetof(PRINTER_INFO_2W, pLocation),
                             offsetof(PRINTER_INFO_2W, pSepFile),
                             offsetof(PRINTER_INFO_2W, pPrintProcessor),
                             offsetof(PRINTER_INFO_2W, pDatatype),
                             offsetof(PRINTER_INFO_2W, pParameters),
                             0xFFFFFFFF};

DWORD PrinterInfo3StringsA[]={0xFFFFFFFF};

DWORD PrinterInfo4StringsA[]={offsetof(PRINTER_INFO_4W, pPrinterName),
                             offsetof(PRINTER_INFO_4W, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5StringsA[]={offsetof(PRINTER_INFO_5W, pPrinterName),
                             offsetof(PRINTER_INFO_5W, pPortName),
                             0xFFFFFFFF};


DWORD JobInfo1OffsetsA[]={offsetof(JOB_INFO_1W, pPrinterName),
                         offsetof(JOB_INFO_1W, pMachineName),
                         offsetof(JOB_INFO_1W, pUserName),
                         offsetof(JOB_INFO_1W, pDocument),
                         offsetof(JOB_INFO_1W, pDatatype),
                         offsetof(JOB_INFO_1W, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2OffsetsA[]={offsetof(JOB_INFO_2W, pPrinterName),
                         offsetof(JOB_INFO_2W, pMachineName),
                         offsetof(JOB_INFO_2W, pUserName),
                         offsetof(JOB_INFO_2W, pDocument),
                         offsetof(JOB_INFO_2W, pNotifyName),
                         offsetof(JOB_INFO_2W, pDatatype),
                         offsetof(JOB_INFO_2W, pPrintProcessor),
                         offsetof(JOB_INFO_2W, pParameters),
                         offsetof(JOB_INFO_2W, pDriverName),
                         offsetof(JOB_INFO_2W, pDevMode),
                         offsetof(JOB_INFO_2W, pStatus),
                         offsetof(JOB_INFO_2W, pSecurityDescriptor),
                         0xFFFFFFFF};

DWORD JobInfo3OffsetsA[]={0xFFFFFFFF};

DWORD JobInfo1StringsA[]={offsetof(JOB_INFO_1W, pPrinterName),
                         offsetof(JOB_INFO_1W, pMachineName),
                         offsetof(JOB_INFO_1W, pUserName),
                         offsetof(JOB_INFO_1W, pDocument),
                         offsetof(JOB_INFO_1W, pDatatype),
                         offsetof(JOB_INFO_1W, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo2StringsA[]={offsetof(JOB_INFO_2W, pPrinterName),
                         offsetof(JOB_INFO_2W, pMachineName),
                         offsetof(JOB_INFO_2W, pUserName),
                         offsetof(JOB_INFO_2W, pDocument),
                         offsetof(JOB_INFO_2W, pNotifyName),
                         offsetof(JOB_INFO_2W, pDatatype),
                         offsetof(JOB_INFO_2W, pPrintProcessor),
                         offsetof(JOB_INFO_2W, pParameters),
                         offsetof(JOB_INFO_2W, pDriverName),
                         offsetof(JOB_INFO_2W, pStatus),
                         0xFFFFFFFF};

DWORD JobInfo3StringsA[]={0xFFFFFFFF};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\adsdsrc.h ===
#ifndef  _ADSDATASOURCE_H_
#define  _ADSDATASOURCE_H_

//#define  ROWS  10L
#define  ROWS  1L

typedef  struct _tagSEARCHPREF
{
   TCHAR szSource       [ MAX_PATH ];
   TCHAR szQuery        [ 2048 ];
   TCHAR szAttributes   [ MAX_PATH ];
   TCHAR szScope        [ MAX_PATH ];
   TCHAR szUserName     [ 2 * MAX_PATH ];
   TCHAR szPassword     [ MAX_PATH ];
   BOOL  bEncryptPassword;
   BOOL  bUseSQL;
   int   nAsynchronous;
   int   nDerefAliases;
   int   nSizeLimit;
   int   nTimeLimit;
   int   nAttributesOnly;
   int   nScope;
   int   nTimeOut;
   int   nPageSize;
   int   nChaseReferrals;
}  SEARCHPREF;

class CADsDataSource: public CObject
{
   public:
      CADsDataSource( );
      ~CADsDataSource( );

   public:
      /*void     SetQueryParameters( CString& strSource,
                                   CString& strQuery,
                                   CString& strAttributes,
                                   CString& strScope,
                                   CString& strUserName,
                                   CString& strPassword,
                                   BOOL bEncryptPassword,
                                   BOOL bUseSQL );*/

      void     SetQueryParameters( SEARCHPREF* pSerachPref );

      virtual  int   GetColumnsCount   ( int nRow );
      virtual  BOOL  GetValue          ( int nRow, int nColumn, CString& );
      virtual  BOOL  GetValue          ( int nRow, CString& strColumn, CString& );
      virtual  BOOL  GetADsPath        ( int nRow, CString& );
      virtual  BOOL  GetColumnText     ( int nRow, int nColumn, CString& );
               BOOL  Refresh           ( void );
      virtual  BOOL  RunTheQuery       ( void );

   protected:
      DBORDINAL      m_nColumnsCount;
      int            m_nAddOne;

      BOOL           m_bNoQuery;
      BOOL           m_bNoMoreData;

      int            m_nFirstRow;
      int            m_nLastRow;
      int            m_nCurrentRow;

      ULONG          m_cRows;
      ULONG          m_cColumns;
      CString        m_strAttributes;

      /*CString        m_strSource;
      CString        m_strQuery;
      CString        m_strScope;
      CString        m_strPassword;
      CString        m_strUserName;
      BOOL           m_bEncryptPassword;
      BOOL           m_bUseSQL;*/

      CStringArray   m_ADsPath;
      SEARCHPREF*    m_pSearchPref;
};


/*typedef struct tagData {
    void          *obValue;
    DATE          dateValue;
    ULONG         obLength;
    LARGE_INTEGER aLargeInteger;
    ULONG         status;
} Data;*/

typedef struct tagData {
    union {
        void *obValue;
        double obValue2;
    };
    ULONG obLength;
    ULONG status;
} Data;


class CADsOleDBDataSource: public CADsDataSource
{
   public:
      CADsOleDBDataSource( );
      ~CADsOleDBDataSource( );

   public:
      HRESULT  SetQueryCredentials( IDBInitialize* pInit, ICommandText* pCommand );

      virtual  int   GetColumnsCount   ( int nRow );
      virtual  BOOL  GetValue          ( int nRow, int nColumn, CString& );
      virtual  BOOL  GetADsPath        ( int nRow, CString& );
      virtual  BOOL  GetColumnText     ( int nRow, int nColumn, CString& );
      virtual  BOOL  RunTheQuery       ( void );

   private:
      void     DestroyInternalData  ( void );
      BOOL     AdvanceCursor        ( void );
      BOOL     CreateAccessorHelp   ( void );
      BOOL     BringRowInBuffer     ( int nRow );
      CString  ExtractData          ( int );
      void     ReadADsPath          ( void );

      private:
      Data*          m_pData;

      IRowset*       m_pIRowset;
      IMalloc*       m_pIMalloc;
      IAccessor*     m_pAccessor;
      IColumnsInfo*  m_pIColsInfo;
      HROW*          m_hRows;

      HACCESSOR      m_hAccessor;
      DBCOLUMNINFO*  m_prgColInfo;
      DBBINDSTATUS*  m_pBindStatus;
      OLECHAR*       m_szColNames;
};

class CADsSearchDataSource: public CADsDataSource
{
   public:
      CADsSearchDataSource( );
      ~CADsSearchDataSource( );

   public:
      virtual  int   GetColumnsCount   ( int nRow );
      virtual  BOOL  GetValue          ( int nRow, int nColumn, CString& );
      virtual  BOOL  GetValue          ( int nRow, CString& rColumn, CString& );
      virtual  BOOL  GetADsPath        ( int nRow, CString& );
      virtual  BOOL  GetColumnText     ( int nRow, int nColumn, CString& );
      virtual  BOOL  RunTheQuery       ( void );

   private:
      void     DestroyInternalData  ( void );
      HRESULT  CreateSearchInterface( );
      BOOL     BringRowInBuffer     ( int nRow );
      BOOL     ReadColumnNames      ( int nRow );
      HRESULT  SetQueryPreferences  ( );
      HRESULT  SetSearchPreferences ( );
      HRESULT  SetAttributesName    ( );
      void     ReadADsPath          ( void );

   private:
      IDirectorySearch*        m_pSearch;
      ADS_SEARCH_HANDLE m_hSearch;
      CStringArray      m_strColumns;
      /*BOOL              m_bAsynchronous;     //ADS_SEARCHPREF_ASYNCHRONOUS
      BOOL              m_bDerefAliases;     //ADS_SEARCHPREF_DEREF_ALIASES
      int               m_nSizeLimit;        //ADS_SEARCHPREF_SIZE_LIMIT
	   int               m_nTimeLimit;        //ADS_SEARCHPREF_TIME_LIMIT
	   BOOL              m_bAttributesOnly;   //ADS_SEARCHPREF_ATTRIBTYPES_ONLY
	   CString           m_strScope;          //ADS_SEARCHPREF_SEARCH_SCOPE
      int               m_nTimeOut;          //ADS_SEARCHPREF_TIMEOUT
      int               m_nPageSize;	      //ADS_SEARCHPREF_PAGESIZE*/
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\adsdsrc.cpp ===
// adsqryDoc.cpp : implementation of the CAdsqryDoc class
//

#include "stdafx.h"
#include "adsqDoc.h"
#include "adsdsrc.h"
#include "oledberr.h"
#include "adsdb.h"
#include "csyntax.h"
#include "newquery.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef BUILD_FOR_NT40
typedef DWORD DWORD_PTR;
#endif

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CADsDataSource::CADsDataSource( )
{
   m_pSearchPref  = NULL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CADsDataSource::~CADsDataSource( )
{
   if( NULL != m_pSearchPref )
   {
      FreeADsMem( m_pSearchPref );
   }
}


/***********************************************************
  Function:    CADsDataSource::SetQueryParameters
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
/*void CADsDataSource::SetQueryParameters( CString& strSource,
                                         CString& strQuery,
                                         CString& strAttributes,
                                         CString& strScope,
                                         CString& strUserName,
                                         CString& strPassword,
                                         BOOL bEncryptPassword,
                                         BOOL bUseSQL )
{
   m_strSource          = strSource;
   m_strQuery           = strQuery;
   m_strAttributes      = strAttributes;
   m_strScope           = strScope;
   m_strUserName        = strUserName;
   m_strPassword        = strPassword;
   m_bEncryptPassword   = bEncryptPassword;
   m_bUseSQL            = bUseSQL;
} */


void CADsDataSource::SetQueryParameters( SEARCHPREF* pSearchPref )
{
   if( NULL == m_pSearchPref )
   {
      m_pSearchPref  = (SEARCHPREF*) AllocADsMem( sizeof(SEARCHPREF) );
   }

   *m_pSearchPref = *pSearchPref;
}

/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   CADsDataSource::GetColumnsCount( int nRow )
{
   ASSERT( FALSE );

   return 0;
}


/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::GetValue( int nRow, int nColumn, CString& )
{
   return FALSE;
}

/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::GetValue( int nRow, CString& strColumn, CString& )
{
   return FALSE;
}


/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::GetADsPath( int nRow, CString& )
{
   ASSERT( FALSE );
   return FALSE;
}


/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::GetColumnText( int nRow, int nColumn, CString& )
{
   ASSERT( FALSE );
   return FALSE;
}


/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::Refresh( void )
{
   return FALSE;
}


/***********************************************************
  Function:    CADsDataSource::GetColumnsCount
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CADsDataSource::RunTheQuery( void )
{
   ASSERT( FALSE );

   return FALSE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::CADsOleDBDataSource
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
CADsOleDBDataSource::CADsOleDBDataSource( )
{
   CoGetMalloc(MEMCTX_TASK, &m_pIMalloc);

   m_pData              = NULL;
   m_pBindStatus        = NULL;
   m_hRows              = NULL;
   m_pIRowset           = NULL;
   m_pIColsInfo         = NULL;
   m_pAccessor          = NULL;
   m_nColumnsCount      = 0;
   m_prgColInfo         = NULL;
   m_szColNames         = NULL;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::~CADsOleDBDataSource
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
CADsOleDBDataSource::~CADsOleDBDataSource( )
{
   DestroyInternalData( );
   m_pIMalloc->Release( );
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::GetColumnsCount
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
int   CADsOleDBDataSource::GetColumnsCount( int nRow )
{
   if( m_nColumnsCount )
   {
      return   (int)(m_nColumnsCount - m_nAddOne);
   }
   else
   {
      return 0;
   }
}



/*****************************************************************************
   Function:   CADsOleDBDataSource::GetColumnText
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
BOOL  CADsOleDBDataSource::GetColumnText( int nRow, int nColumn, CString& rValue )
{
   nColumn += m_nAddOne;

   if( nColumn < 0 || nColumn >= (int)m_nColumnsCount )
   {
      ASSERT( FALSE );
      return FALSE;
   }

   if( FALSE )
   {
      rValue   = _T("ADsPath");
   }
   else
   {
      TCHAR szColumnName[ MAX_PATH ];

      Convert( szColumnName, m_prgColInfo[ nColumn + 1].pwszName );

      rValue   = szColumnName;
   }

   return TRUE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::CreateAccessorHelper
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsOleDBDataSource::CreateAccessorHelp( void )
{

   DBBINDING*  prgBindings = NULL;
   HRESULT     hResult;
   ULONG       i;
   IAccessor*  pIAccessor = NULL;

   prgBindings = (DBBINDING *) LocalAlloc(
                                           LPTR,
                                           sizeof(DBBINDING) * (m_nColumnsCount)
                                         );
	if(NULL == prgBindings)
		return FALSE; //SMITHA return E_OUTOFMEMORY;

   //
   // Set up rest of the attributes
   //
   for ( i=0; i < m_nColumnsCount ; i++)
   {
      prgBindings[i].iOrdinal       = i+1;
      prgBindings[i].obValue        = sizeof(Data)*i + offsetof(Data, obValue);
      prgBindings[i].obLength       = sizeof(Data)*i + offsetof(Data, obLength);
      prgBindings[i].obStatus       = sizeof(Data)*i + offsetof(Data, status);
      prgBindings[i].dwPart         = DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS;
      //prgBindings[i].dwMemOwner     = DBMEMOWNER_PROVIDEROWNED;
      prgBindings[i].wType          = m_prgColInfo[i+1].wType;
      prgBindings[i].dwFlags        = 0;

      if( prgBindings[i].wType & DBTYPE_BYREF )
      {
         prgBindings[i].dwMemOwner  = DBMEMOWNER_PROVIDEROWNED;
      }
      else
      {
         prgBindings[i].dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
      }

      if( m_prgColInfo[i+1].wType == DBTYPE_DATE  ||
          m_prgColInfo[i+1].wType == DBTYPE_I8 )
      {
         prgBindings[i].obValue  = sizeof(Data)*i + offsetof(Data, obValue2);
      }

   }


   hResult= m_pIRowset->QueryInterface( IID_IAccessor, (void**) &pIAccessor );
   ASSERT( SUCCEEDED( hResult ) );

   //
   // With the bindings create the accessor
   //
   hResult = pIAccessor->CreateAccessor(
                                         DBACCESSOR_ROWDATA,
                                         m_nColumnsCount,
                                         prgBindings,
                                         0,
                                         &m_hAccessor,
                                         m_pBindStatus
                                       );
   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      AfxMessageBox( _T("IAccessor::CreateAccessor failed") );
   }

   pIAccessor->Release();
   LocalFree(prgBindings);

   return( SUCCEEDED( hResult ) );
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::SetQueryCredentials
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
HRESULT  CADsOleDBDataSource::SetQueryCredentials( IDBInitialize* pInit,
                                                   ICommandText* pCommand )
{
   DBPROPSET      aPropSet;
   DBPROP         arrProp[ 20 ];
   HRESULT        hResult;
   int            nIter, nIdx;

   ASSERT( !( (NULL != pInit) && (NULL != pCommand) ) );

   for ( nIter = 0; nIter < 20; nIter++)
   {
      VariantInit( &(arrProp[ nIter ].vValue ) );
      V_VT( &(arrProp[ nIter ].vValue ) ) = VT_BSTR;
      arrProp[ nIter ].dwOptions          = DBPROPOPTIONS_REQUIRED;
   }

   if( NULL != pInit )
   {
      IDBProperties* pIProp   = NULL;

      if( !_tcslen(m_pSearchPref->szUserName) )
      {
         return S_OK;
      }

      hResult  = pInit->QueryInterface( IID_IDBProperties, (void**)&pIProp );

      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         return hResult;

      nIter = 0;
      if( _tcslen(m_pSearchPref->szUserName) )
      {
         arrProp[ nIter ].dwPropertyID        = DBPROP_AUTH_USERID;
         V_BSTR( &(arrProp[ nIter ].vValue) ) = AllocBSTR( m_pSearchPref->szUserName );
         nIter++;

         arrProp[ nIter ].dwPropertyID        = DBPROP_AUTH_PASSWORD;
         V_BSTR( &(arrProp[ nIter ].vValue) ) = AllocBSTR( m_pSearchPref->szPassword );
         nIter++;

         arrProp[ nIter ].dwPropertyID        = DBPROP_AUTH_ENCRYPT_PASSWORD;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_BOOL;

         if( m_pSearchPref->bEncryptPassword )
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_TRUE;
         }
         else
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_FALSE;
         }
         nIter++;

         aPropSet.rgProperties            = arrProp;
         aPropSet.cProperties             = nIter;
         aPropSet.guidPropertySet         = DBPROPSET_DBINIT;

         hResult                          = pIProp->SetProperties( 1, &aPropSet );

         ASSERT( S_OK == hResult );

         for ( nIdx = 0; nIdx < nIter ; nIdx++ )
         {
            VariantClear( &(arrProp[ nIdx ].vValue ) );
         }
         nIter = 0;
      }

      pIProp->Release( );
   }

   if( NULL != pCommand )
   {
      ICommandProperties*  pCommandProp   = NULL;


      hResult  = pCommand->QueryInterface( IID_ICommandProperties,
                                           (void**) &pCommandProp );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         return hResult;

      nIter = 0;
      // Initialize the VARIANTs and the options in rgProps.
      //***************************************************************************
      if( -1 != m_pSearchPref->nAsynchronous )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_ASYNCHRONOUS;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_BOOL;

         if( m_pSearchPref->nAsynchronous )
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_TRUE;
         }
         else
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_FALSE;
         }
         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nAttributesOnly )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_ATTRIBTYPES_ONLY;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_BOOL;

         if( m_pSearchPref->nAttributesOnly )
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_TRUE;
         }
         else
         {
            V_BOOL( &(arrProp[ nIter ].vValue) ) = VARIANT_FALSE;
         }
         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nTimeOut )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_TIMEOUT;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         V_I4( &(arrProp[ nIter ].vValue ) )  = m_pSearchPref->nTimeOut;
         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nTimeLimit )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_TIME_LIMIT;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         V_I4( &(arrProp[ nIter ].vValue ) )  = m_pSearchPref->nTimeLimit;
         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nSizeLimit )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_SIZE_LIMIT;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         V_I4( &(arrProp[ nIter ].vValue ) )  = m_pSearchPref->nSizeLimit;
         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nPageSize )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_PAGESIZE;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         V_I4( &(arrProp[ nIter ].vValue ) )  = m_pSearchPref->nPageSize;
         nIter++;
      }

      //***************************************************************************

      if( _tcslen( m_pSearchPref->szScope ) )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_SEARCH_SCOPE;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         if( !_tcsicmp(  m_pSearchPref->szScope, _T("subtree") ) )
         {
            V_I4( &(arrProp[ nIter ].vValue ) )  = ADS_SCOPE_SUBTREE;
         }
         else if( !_tcsicmp(  m_pSearchPref->szScope, _T("onelevel") ) )
         {
            V_I4( &(arrProp[ nIter ].vValue ) )  = ADS_SCOPE_ONELEVEL;
         }
         else
         {
            V_I4( &(arrProp[ nIter ].vValue ) )  = ADS_SCOPE_BASE;
         }

         nIter++;
      }

      //***************************************************************************
      if( -1 != m_pSearchPref->nChaseReferrals )
      {
         arrProp[ nIter ].dwPropertyID        = ADSIPROP_CHASE_REFERRALS;
         V_VT( &(arrProp[ nIter ].vValue ) )  = VT_I4;
         if( m_pSearchPref->nChaseReferrals )
         {
            V_I4( &(arrProp[ nIter ].vValue) ) = ADS_CHASE_REFERRALS_ALWAYS;
         }
         else
         {
            V_I4( &(arrProp[ nIter ].vValue) ) = ADS_CHASE_REFERRALS_NEVER;
         }
         nIter++;
      }



      // Create the initialization structure.
      if( nIter )
      {
         aPropSet.rgProperties            = arrProp;
         aPropSet.cProperties             = nIter;
         aPropSet.guidPropertySet         = DBPROPSET_ADSISEARCH;

         hResult                          = pCommandProp->SetProperties( 1, &aPropSet );

         ASSERT( S_OK == hResult );

         for ( nIdx = 0; nIdx < nIter ; nIdx++ )
         {
            VariantClear( &(arrProp[ nIdx ].vValue ) );
         }
         ASSERT( SUCCEEDED( hResult ) );
      }
      pCommandProp->Release( );
   }

   return hResult;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::RunTheQuery
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsOleDBDataSource::RunTheQuery( void )
{
   HRESULT            hResult;

   IDBInitialize    * pIDBInit         = NULL;
   IDBCreateSession * pIDBCS           = NULL;
   IDBCreateCommand * pIDBCreateCommand= NULL;
   ICommandText     * pICommandText    = NULL;
   ICommand         * pICommand        = NULL;
   DBBINDSTATUS     * pMyStatus = NULL;
   CString          strCommandText;
   BSTR             bstrCommandText;
   HCURSOR          aCursor, oldCursor;

   aCursor     = LoadCursor( NULL, IDC_WAIT );
   oldCursor   = SetCursor( aCursor );

   m_nCurrentRow  = -1;
   m_nFirstRow    = -1;
   m_nLastRow     = -1;
   m_bNoMoreData  = FALSE;
   m_hRows        = NULL;

   m_nAddOne         = 0;
   m_strAttributes   = m_pSearchPref->szAttributes;

   if( !_tcsicmp( m_pSearchPref->szAttributes, _T("*") ) )
   {
      CString  strTemp  = _T("ADsPath,");

      strTemp          += m_pSearchPref->szAttributes;
      m_strAttributes   = strTemp;
      m_nAddOne         = 1;
   }

   if( !m_pSearchPref->bUseSQL )
   {
      strCommandText   = m_pSearchPref->szSource;
      if( strCommandText[ 0 ] != _T('<') )
       {
         CString  strTemp;

         strTemp  = _T("<");
         strTemp  = strTemp + strCommandText;
         strTemp  = strTemp + _T(">");
         strCommandText = strTemp;
       }

      strCommandText  += _T(';');
      strCommandText  += m_pSearchPref->szQuery;
      strCommandText  += _T(';');
      strCommandText  += m_strAttributes;

      /*if( _tcslen( m_pSearchPref->szScope ) )
      {
         strCommandText  += _T(';');
         strCommandText  += m_pSearchPref->szScope;
      }*/
   }
   else
   {
      strCommandText   = _T("SELECT ");
      strCommandText  += m_strAttributes;

      strCommandText  += _T(" FROM '");
      strCommandText  += m_pSearchPref->szSource;
      strCommandText  += _T("'");

      strCommandText  += _T(" WHERE ");
      strCommandText  += m_pSearchPref->szQuery;
   }

   bstrCommandText = AllocBSTR( strCommandText.GetBuffer( strCommandText.GetLength( ) + 1 ) );

    //
    // Instantiate a data source object for LDAP provider
    //
   while( TRUE )
   {
      hResult  = CoCreateInstance( CLSID_ADsDSOObject,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IDBInitialize,
                                   (void **)&pIDBInit
                                  );
      ASSERT( SUCCEEDED( hResult ) );

      if(FAILED(hResult))
      {
         TRACE(_T("CoCreateInstance failed \n"));
         AfxMessageBox( _T("CoCreateInstance failed") );
         break;
      }

       //
       // Initialize the Data Source
       //

      hResult  = SetQueryCredentials( pIDBInit, NULL );

      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pIDBInit->Initialize();

      ASSERT( SUCCEEDED( hResult ) );
      if(FAILED(hResult))
      {
         TRACE(_T("IDBIntialize::Initialize failed \n"));
         AfxMessageBox( _T("IDBIntialize::Initialize failed") );
         break;
      }

      hResult  = pIDBInit->QueryInterface(
                                           IID_IDBCreateSession,
                                           (void**) &pIDBCS);

      ASSERT( SUCCEEDED( hResult ) );
      if(FAILED(hResult))
      {
         TRACE(_T("QueryInterface for IDBCreateSession failed \n"));
         AfxMessageBox( _T("QueryInterface for IDBCreateSession failed") );
         break;
      }

      pIDBInit->Release( );
      pIDBInit = NULL;

      //
      // Create a session returning a pointer to its CreateCommand interface
      //
      hResult  = pIDBCS->CreateSession(
                                        NULL,
                                        IID_IDBCreateCommand,
                                        (LPUNKNOWN*) &pIDBCreateCommand
                                      );

      ASSERT( SUCCEEDED( hResult ) );
      if(FAILED(hResult))
      {
         TRACE( _T("IDBCreateSession::CreateSession failed \n") );
         AfxMessageBox( _T("IDBCreateSession::CreateSession failed") );
         break;
      }

      pIDBCS->Release( );
      pIDBCS   = NULL;

       //
       // Create a command from the session object
       //
      hResult = pIDBCreateCommand->CreateCommand(
                                                  NULL,
                                                  IID_ICommandText,
                                                  (LPUNKNOWN*) &pICommandText
                                                );

      ASSERT( SUCCEEDED( hResult ) );

      if(FAILED(hResult))
      {
         TRACE( _T(" IDBCreateCommand::CreateCommand failed\n") );
         AfxMessageBox( _T("IDBCreateCommand::CreateCommand failed") );
         break;
      }

      pIDBCreateCommand->Release( );
      pIDBCreateCommand = NULL;

      hResult  = SetQueryCredentials( NULL, pICommandText );

      ASSERT( SUCCEEDED( hResult ) );

      if( !m_pSearchPref->bUseSQL )
      {
         hResult  = pICommandText->SetCommandText(
                                                   DBGUID_LDAPDialect,
                                                   bstrCommandText
                                                 );
      }
      else
      {
         hResult  = pICommandText->SetCommandText(
                                                   DBGUID_DBSQL,
                                                   bstrCommandText
                                                 );
      }

      ASSERT( SUCCEEDED( hResult ) );

      if(FAILED(hResult))
      {
         TRACE(_T("ICommandText::CommandText failed \n"));
         AfxMessageBox( _T("ICommandText::CommandText failed") );
         break;
      }

      hResult  = pICommandText->QueryInterface(
                                                IID_ICommand,
                                                (void**) &pICommand);

      ASSERT( SUCCEEDED( hResult ) );

      if(FAILED(hResult))
      {
         TRACE(_T("QueryInterface for ICommand failed \n") );
         AfxMessageBox( _T("QueryInterface for ICommand failed ") );
         break;
      }

      pICommandText->Release();
      pICommandText = NULL;

      //
      // Do the Query and get back a rowset
      //
      pICommand->AddRef( );
      pICommand->Release( );

      hResult = pICommand->Execute(
                                  NULL,
                                  IID_IRowset,
                                  NULL,
                                  NULL,
                                  (LPUNKNOWN *)&m_pIRowset
                                );

      ASSERT( SUCCEEDED( hResult ) );

      if(FAILED(hResult))
      {
         TRACE(_T("ICommand::Execute failed \n"));
         AfxMessageBox( _T("ICommand::Execute failed") );
         pICommand->Release( );
         pICommand  = NULL;

         break;
      }

      m_pIRowset->AddRef( );
      m_pIRowset->Release( );

      pICommand->Release( );
      pICommand   = NULL;


      hResult = m_pIRowset->QueryInterface(
                                          IID_IColumnsInfo,
                                          (void**) &m_pIColsInfo
                                        );
      ASSERT( SUCCEEDED( hResult ) );
      if(FAILED(hResult))
      {
         TRACE(_T("QueryInterface for IColumnsInfo failed \n"));
         AfxMessageBox( _T("QueryInterface for IColumnsInfo failed") );
         break;
      }

      hResult = m_pIColsInfo->GetColumnInfo(
                                           &m_nColumnsCount,
                                           &m_prgColInfo,
                                           &m_szColNames
                                         );

      ASSERT( SUCCEEDED( hResult ) );
      if(FAILED(hResult))
      {
         TRACE( _T("IColumnsInfo::GetColumnInfo failed \n") );
         AfxMessageBox( _T("IColumnsInfo::GetColumnInfo failed") );
         break;
      }

       //
       // The no. of attributes is one less than the no. of columns because of
       // the Bookmark column
       //
      m_nColumnsCount--;

      m_pData  = (Data *) LocalAlloc( LPTR, sizeof(Data) * m_nColumnsCount );

      m_pBindStatus = (DBBINDSTATUS *) LocalAlloc(
                                                   LPTR,
                                                   sizeof(DBBINDSTATUS) * m_nColumnsCount
                                                  );
      /* SMITHA hResult = CreateAccessorHelp( );
      if(FAILED(hResult))
      {
         TRACE(_T("CreateAccessorHelper failed \n"));
         break;
      }*/
      if (!CreateAccessorHelp( ))
      {
         TRACE(_T("CreateAccessorHelper failed \n"));
         break;
      }

      break;
   }

   SysFreeString( bstrCommandText );

   SetCursor( oldCursor );

   return SUCCEEDED( hResult );
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::AdvanceCursor
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsOleDBDataSource::AdvanceCursor( void )
{
   HRESULT  hResult;
   DBCOUNTITEM cRowsObtained;
   HCURSOR  aCursor, oldCursor;

   aCursor     = LoadCursor( NULL, IDC_WAIT );
   oldCursor   = SetCursor( aCursor );

   if( !m_bNoMoreData )
   {
      cRowsObtained  = 0;

      if( m_hRows )
      {
         ULONG       refCount[ ROWS ];
         DBROWSTATUS rowStat[ ROWS ];

         m_pIRowset->ReleaseRows( ROWS,
                                  m_hRows,
                                  NULL,
                                  refCount,
                                  rowStat );

         m_pIMalloc->Free( m_hRows );
         m_hRows        = NULL;
      }

      TRACE( _T("Ask for %d rows starting from %d\n"), ROWS, m_nLastRow + 1 );

      hResult        = m_pIRowset->GetNextRows(
                                                NULL,
                                                0,
                                                ROWS,
                                                //1L,
                                                &cRowsObtained,
                                                &m_hRows
                                              );
      TRACE( _T("After asking for %d rows starting from %d\n"), ROWS, m_nLastRow + 1 );

      if( SUCCEEDED( hResult ) )
      {
         m_nFirstRow = m_nLastRow + 1;
         m_nLastRow  = (int)(m_nFirstRow + cRowsObtained - 1);
      }

      m_bNoMoreData  = (cRowsObtained != ROWS);
   }

   SetCursor( oldCursor );

   return TRUE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::GetADsPath
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
BOOL  CADsOleDBDataSource::GetADsPath( int nRow, CString& rPath )
{
   ASSERT( nRow < m_ADsPath.GetSize( ) );

   if( ! (nRow < m_ADsPath.GetSize( ) ) )
   {
      return FALSE;
   }

   rPath = m_ADsPath.GetAt( nRow );

   return TRUE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::GetValue
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
BOOL  CADsOleDBDataSource::GetValue( int nRow, int nColumn, CString& rValue )
{
   HRESULT  hResult = S_OK;

   nColumn += m_nAddOne;

   ASSERT( nRow >= 0 );
   if( nRow < 0 )
   {
      return FALSE;
   }

   ASSERT( nColumn >=0 && nColumn < (int)m_nColumnsCount );
   if( nColumn < 0 || nColumn >= (int)m_nColumnsCount )
   {
      return FALSE;
   }

   if( !BringRowInBuffer( nRow ) )
      return FALSE;

   if( m_nCurrentRow != nRow )
   {
      hResult  = m_pIRowset->GetData( m_hRows[nRow - m_nFirstRow],
                                      m_hAccessor,
                                      (void*)m_pData );
      m_nCurrentRow  = nRow;

      ReadADsPath( );
   }

   if( SUCCEEDED( hResult) )
   {
      rValue   = ExtractData( nColumn );
   }
   else
   {
      rValue   = _T("Error");
   }

   return TRUE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::ReadADsPath
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
void     CADsOleDBDataSource::ReadADsPath( void )
{
   CString  strADsPath;

   strADsPath  = ExtractData( 0 );
   m_ADsPath.Add( strADsPath );
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::ExtractData
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
CString  CADsOleDBDataSource::ExtractData( int nColumn )
{
   ULONG    i;
   TCHAR    szValue[ 2048 ]   = _T("Error");
   HRESULT  hResult;

   i = nColumn;

   if( m_pData[i].status == DBSTATUS_S_ISNULL )
      return CString(_T("<No value>") );

   if( !( m_prgColInfo[i+1].dwFlags & DBCOLUMNFLAGS_ISNULLABLE &&
          m_pData[i].status == DBSTATUS_S_ISNULL))
   {

      switch(m_prgColInfo[i+1].wType)
      {
         case  DBTYPE_I8:
            LARGE_INTEGERToString( szValue, (LARGE_INTEGER*)&m_pData[i].obValue2 );
            break;

         case  DBTYPE_I4:
            wsprintf( szValue, _T("%ld"), (DWORD_PTR) m_pData[i].obValue );
            break;

         case DBTYPE_BOOL:
            /*SMITHA wsprintf( szValue,  _T("%s"),
                      (VARIANT_TRUE == (VARIANT_BOOL) m_pData[i].obValue) ? _T("TRUE") : _T("FALSE") );*/
            _tcscpy( szValue, (VARIANT_TRUE == (VARIANT_BOOL) m_pData[i].obValue) ? _T("TRUE") : _T("FALSE") );

            break;

         case DBTYPE_DATE:
         {
            VARIANT  varTemp, varString;
            //SMITHA HRESULT  hResult;

            VariantInit( &varString );
            VariantInit( &varTemp );

            V_VT( &varTemp )     = VT_DATE;
            V_DATE( &varTemp )   = (DATE) m_pData[i].obValue2;

            hResult=  VariantChangeType( &varString, &varTemp, VARIANT_NOVALUEPROP, VT_BSTR );
            ASSERT( SUCCEEDED( hResult ) );

            if( SUCCEEDED( hResult ) )
            {
               Convert( szValue, V_BSTR( &varString ) );
               VariantClear( &varString );
            }

            break;
         }

         case DBTYPE_STR | DBTYPE_BYREF:
            if( NULL != (char *)m_pData[i].obValue )
            {
               //SMITHA wsprintf( szValue, _T("%s"), (char *)m_pData[i].obValue );
               _tcscpy(szValue, (TCHAR *) m_pData[i].obValue);
            }
            else
            {
               _tcscpy( szValue, _T("NULL") );
            }
            break;

         case DBTYPE_BYTES | DBTYPE_BYREF:
            {
               TCHAR szTemp[ 16 ];
               ULONG ulIter;
               BYTE* pByte;

               _ltot    ( m_pData[i].obLength, szTemp, 10 );
               _tcscpy  ( szValue, _T("[") );
               _tcscat  ( szValue, szTemp );
               _tcscat  ( szValue, _T("] ") );
               pByte    = (BYTE*) (m_pData[i].obValue);

               for( ulIter = 0; ulIter < m_pData[i].obLength && _tcslen( szValue ) < 2000; ulIter++ )
               {
                  BYTE  bVal;

                  bVal  = pByte[ ulIter ];
                  _itot( (int)bVal , szTemp, 16 );
                  _tcscat  ( szValue, _T("x") );
                  _tcscat  ( szValue, szTemp );
                  _tcscat  ( szValue, _T(" ") );
               }
            }
            break;

         case DBTYPE_WSTR | DBTYPE_BYREF:
            if( NULL != (WCHAR *)m_pData[i].obValue )
            {
               wsprintf( szValue, _T("%S"), (WCHAR *) m_pData[i].obValue );
            }
            else
            {
               _tcscpy( szValue, _T("NULL") );
            }
            break;

         case DBTYPE_VARIANT | DBTYPE_BYREF:
         {

            ULONG dwSLBound;
            ULONG dwSUBound, j;
            void HUGEP *pArray;
            VARIANT *pVariant;

            pArray   = NULL;
            pVariant = (VARIANT*) m_pData[i].obValue;

               if( NULL == pVariant )
                   _tcscpy( szValue, _T("ERROR!!! m_pData[i].obValue is NULL") );


            while( TRUE && (NULL != pVariant) )
            {

               ASSERT( V_VT( pVariant ) & VT_ARRAY );
               if( ! (V_VT( pVariant ) & VT_ARRAY ) )
                  break;


               hResult  = SafeArrayGetLBound( V_ARRAY(pVariant),
                                              1,
                                              (long FAR *) &dwSLBound );
               ASSERT( SUCCEEDED( hResult ) );
               if( FAILED( hResult ) )
                  break;

               hResult  = SafeArrayGetUBound( V_ARRAY(pVariant),
                                        1,
                                        (long FAR *) &dwSUBound );
               ASSERT( SUCCEEDED( hResult ) );
               if( FAILED( hResult ) )
                  break;

               hResult  = SafeArrayAccessData( V_ARRAY(pVariant),
                                               &pArray );
               ASSERT( SUCCEEDED( hResult ) );
               if( FAILED( hResult ) )
                  break;

               _tcscpy( szValue, _T("") );

               for ( j = dwSLBound; j <= dwSUBound; j++ )
               {
                  TCHAR szTemp[ 1024 ];

                  switch( pVariant->vt & ~VT_ARRAY )
                  {
                     case VT_BSTR:
                        Convert( szTemp, ( (BSTR *)pArray )[j] );
                        break;

                     case VT_I8:
                        LARGE_INTEGERToString( szTemp, &( (LARGE_INTEGER *)pArray )[j] );
                        break;

                     case VT_I4:
                        _ltot( ((DWORD *) pArray)[j], szTemp, 10 );
                        break;

                     case VT_BOOL:
                        _tcscpy( szTemp, (((VARIANT_BOOL *) pArray)[j]) == VARIANT_TRUE ?
                                 _T("TRUE") : _T("FALSE") );
                        break;

                     case  VT_VARIANT:
                     {
                        VARIANT* pVar;

                        pVar  = ((VARIANT *)pArray) + j;
                        switch( V_VT( pVar ) )
                        {
                           case VT_BSTR:
                              Convert( szTemp, V_BSTR( pVar ) );
                              break;

                           case VT_I4:
                              _ltot( V_I4( pVar ), szTemp, 10 );
                              break;

                           case VT_BOOL:
                              _tcscpy( szTemp, V_BOOL( pVar ) == VARIANT_TRUE ?
                                       _T("TRUE") : _T("FALSE") );
                              break;

                           default:
                               ASSERT( FALSE ) ;
                              _tcscpy( szTemp, _T("Unsupported") );
                              break;
                        }

                        break;
                     }

                     default:
                        _tcscpy( szTemp, _T("Unsupported") );
                  }

                  if( _tcslen( szValue) + _tcslen( szTemp ) < 2040 )
                  {
                     if( j != dwSLBound )
                     {
                        _tcscat( szValue, _T("# ") );
                     }

                     _tcscat( szValue, szTemp );
                  }
               }

               SafeArrayUnaccessData( V_ARRAY(pVariant) );
               break;
            }

            break;
         }

         default:
            wsprintf( szValue, _T("Don't know how to convert") );
            break;
      }
   }
   else
   {
      _tcscpy( szValue, _T("NA") );
   }

   return CString( szValue );
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::BringRowInBuffer
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
BOOL  CADsOleDBDataSource::BringRowInBuffer( int nRow )
{
   if( nRow >= m_nFirstRow && nRow <= m_nLastRow )
      return TRUE;

   if( m_nLastRow == -1 )
      AdvanceCursor( );

   while( nRow > m_nLastRow && !m_bNoMoreData )
      AdvanceCursor( );

   if (nRow >= m_nFirstRow && nRow <= m_nLastRow)
   {
      return TRUE;
   }

   return FALSE;
}


/*****************************************************************************
   Function:   CADsOleDBDataSource::DestroyInternalData
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
***********************************************************/
void  CADsOleDBDataSource::DestroyInternalData( void )
{
   if( m_hRows )
   {
      m_pIMalloc->Free( m_hRows );
   }
   if( m_pBindStatus )
   {
      LocalFree( m_pBindStatus );
   }
   if( m_pData )
   {
      LocalFree( m_pData );
   }
   if( m_pIRowset )
   {
      m_pIRowset->Release( );
   }
   if( m_pIColsInfo )
   {
      m_pIColsInfo->Release( );
   }
   if( m_pAccessor )
   {
      m_pAccessor->Release( );
   }
   if( m_prgColInfo )
   {
      m_pIMalloc->Free( m_prgColInfo );
   }
   if( m_szColNames )
   {
      m_pIMalloc->Free( m_szColNames );
   }
}



/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
CADsSearchDataSource::CADsSearchDataSource( )
{
   m_pSearch      = NULL;
   m_nCurrentRow  = -1;
   m_hSearch      = NULL;
}


/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
CADsSearchDataSource::~CADsSearchDataSource( )
{
   if( m_pSearch )
   {
      m_pSearch->CloseSearchHandle( m_hSearch );
      m_pSearch->Release( );
   }
}



/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
int   CADsSearchDataSource::GetColumnsCount( int nRow )
{
   BOOL  bOK;

   bOK   = BringRowInBuffer( nRow );
   if( bOK )
   {
      return (int)m_strColumns.GetSize( );
   }
   else
   {
      return 0;
   }
}


/*****************************************************************************
   Function:   CADsSearchDataSource::GetValue
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::GetValue( int nRow, int nColumn, CString& )
{
   return FALSE;
}

/*****************************************************************************
   Function:   CADsSearchDataSource::GetValue
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::GetValue( int nRow, CString& strColumn, CString& rValue )
{
   HRESULT           hResult;
   BSTR              bstrColumnName;
   ADS_SEARCH_COLUMN aSearchColumn;
   ADS_ATTR_INFO      aAttrDef;
   BOOL              bOK   = TRUE;
   COleDsSyntax*     pSyntax;

   rValue   = _T("<No value>");

   bOK   = BringRowInBuffer( nRow );
   if( bOK )
   {
      bstrColumnName = AllocBSTR( strColumn.GetBuffer( 256 ) );

      hResult        = m_pSearch->GetColumn( m_hSearch,
                                             bstrColumnName,
                                             &aSearchColumn );
      if( SUCCEEDED( hResult ) )
      {
         aAttrDef.pszAttrName = aSearchColumn.pszAttrName;
         aAttrDef.dwADsType   = aSearchColumn.dwADsType;
         aAttrDef.pADsValues  = aSearchColumn.pADsValues;
         aAttrDef.dwNumValues = aSearchColumn.dwNumValues;
         pSyntax              = NULL;

         pSyntax  = GetSyntaxHandler( aAttrDef.dwADsType, rValue );

         if( pSyntax )
         {
            hResult  = pSyntax->Native2Value( &aAttrDef, rValue );
            delete pSyntax;
         }

         hResult        = m_pSearch->FreeColumn( &aSearchColumn );
      }

      SysFreeString( bstrColumnName );
   }

   return bOK;
}


/*****************************************************************************
   Function:   CADsSearchDataSource::GetADsPath
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::GetADsPath( int nRow, CString& rPath )
{
   ASSERT( nRow < m_ADsPath.GetSize( ) );

   if( ! (nRow < m_ADsPath.GetSize( ) ) )
   {
      return FALSE;
   }

   rPath = m_ADsPath.GetAt( nRow );

   return TRUE;
}


/*****************************************************************************
   Function:   CADsSearchDataSource::GetColumnText
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::GetColumnText( int nRow, int nColumn, CString& rColumn )
{
   BOOL  bOK   = TRUE;

   bOK   = BringRowInBuffer( nRow );
   if( bOK )
   {
      rColumn  = m_strColumns[ nColumn ];
   }

   return bOK;
}


/*****************************************************************************
   Function:   CADsSearchDataSource::RunTheQuery
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::RunTheQuery( void )
{
   HRESULT  hResult;
   HCURSOR  aCursor, oldCursor;

   aCursor     = LoadCursor( NULL, IDC_WAIT );
   oldCursor   = SetCursor( aCursor );
   while( TRUE )
   {

      hResult  = CreateSearchInterface( );
      if( FAILED( hResult ) )
         break;

      hResult  = SetSearchPreferences( );
      if( FAILED( hResult ) )
         break;

      hResult  = SetAttributesName( );
      break;
   }
   SetCursor( oldCursor );

   m_bNoMoreData  = FALSE;

   return (S_OK == hResult);
}


/*****************************************************************************
   Function:   CADsSearchDataSource::SetAttributesName
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
HRESULT  CADsSearchDataSource::SetAttributesName( void )
{
   HRESULT  hResult  = E_FAIL;
   BSTR     bstrSearchFilter;
   DWORD    dwNumAttributes = (DWORD)-1;
   BSTR     ppszAttributes[ 128 ];
   int      nIterator;
   TCHAR    szAttribute[ 128 ];
   CString  strAttr;
   CString  strAttributes;

   bstrSearchFilter  = AllocBSTR( m_pSearchPref->szQuery );
   strAttributes   = m_pSearchPref->szAttributes;

   // first, we need to figure out how many attributes are requested
   strAttributes.TrimLeft( );
   strAttributes.TrimRight( );

   if( strAttributes.CompareNoCase( _T("*") ) )
   {
      dwNumAttributes   = 1;
      _tcscpy( szAttribute, _T("") );

      for( nIterator = 0; nIterator < strAttributes.GetLength( ) ; nIterator++ )
      {
         if( strAttributes[ nIterator ] == _T(',') )
         {
            strAttr  = szAttribute;
            strAttr.TrimLeft( );
            strAttr.TrimRight( );

            ppszAttributes[ dwNumAttributes - 1 ]  = AllocBSTR( strAttr.GetBuffer( 128 ) );
            dwNumAttributes++;
            _tcscpy( szAttribute, _T("") );
         }
         else
         {
            TCHAR szChars[ 2 ];

            szChars[ 1 ]   = _T('\0');
            szChars[ 0 ]   = strAttributes[ nIterator ];
            _tcscat( szAttribute, szChars );

            if( nIterator == strAttributes.GetLength( ) - 1 )
            {
               strAttr  = szAttribute;
               strAttr.TrimLeft( );
               strAttr.TrimRight( );

               ppszAttributes[ dwNumAttributes - 1 ]  = AllocBSTR( strAttr.GetBuffer( 128 ) );
            }
         }
      }
   }

   hResult  = m_pSearch->ExecuteSearch(
                                        bstrSearchFilter,
                                        ppszAttributes,
                                        dwNumAttributes,
                                        &m_hSearch
                                      );

   if( FAILED( hResult ) )
   {
      TRACE(_T("ExecuteSearch failed with %lx \n"), hResult);
      AfxMessageBox( _T("ExecuteSearch failed") );
   }

   for( nIterator = 0; nIterator < (int)dwNumAttributes ; nIterator++ )
   {
      SysFreeString( ppszAttributes[ nIterator ] );
   }

   SysFreeString( bstrSearchFilter );

   return hResult;
}


/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
/*HRESULT  CADsSearchDataSource::SetSearchPreferences( )
{
   CSearchPreferencesDlg   aSearchPref;
   ADS_SEARCHPREF_INFO     arrSearchPref[ 20 ];
   int                     nSearchPrefCount  = 0;
   HRESULT                 hResult;

   if( aSearchPref.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }
   //***************************************************************************
   if( !aSearchPref.m_strAsynchronous.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
      arrSearchPref[nSearchPrefCount].vValue.dwType= ADSTYPE_BOOLEAN;
      if( !aSearchPref.m_strAsynchronous.CompareNoCase( _T("Yes") ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Boolean = TRUE;
      }
      else
      {
         arrSearchPref[nSearchPrefCount].vValue.Boolean = FALSE;
      }
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strAttributesOnly.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_BOOLEAN;
      if( !aSearchPref.m_strAttributesOnly.CompareNoCase( _T("Yes") ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Boolean = TRUE;
      }
      else
      {
         arrSearchPref[nSearchPrefCount].vValue.Boolean = FALSE;
      }
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strDerefAliases.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
      arrSearchPref[nSearchPrefCount].vValue.dwType= ADSTYPE_INTEGER;
      if( !aSearchPref.m_strDerefAliases.CompareNoCase( _T("Yes") ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_DEREF_ALWAYS;
      }
      else
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_DEREF_NEVER;
      }
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strTimeOut.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_TIMEOUT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = _ttoi( aSearchPref.m_strTimeOut.GetBuffer( 16 ) );
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strTimeLimit.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_TIME_LIMIT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = _ttoi( aSearchPref.m_strTimeLimit.GetBuffer( 16 ) );
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strSizeLimit.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_SIZE_LIMIT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = _ttoi( aSearchPref.m_strSizeLimit.GetBuffer( 16 ) );
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strPageSize.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_PAGESIZE;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = _ttoi( aSearchPref.m_strPageSize.GetBuffer( 16 ) );
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( !aSearchPref.m_strScope.IsEmpty( ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_SEARCH_SCOPE;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      if (!aSearchPref.m_strScope.CompareNoCase( _T("Base" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_BASE;
      }
      if (!aSearchPref.m_strScope.CompareNoCase( _T("OneLevel" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_ONELEVEL;
      }
      if (!aSearchPref.m_strScope.CompareNoCase( _T("Subtree" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_SUBTREE;
      }
      nSearchPrefCount++;
   }

   hResult  = m_pSearch->SetSearchPreference( arrSearchPref, nSearchPrefCount );

   ASSERT( SUCCEEDED( hResult ) );

   return hResult;

} */



/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
HRESULT  CADsSearchDataSource::SetSearchPreferences( )
{
   ADS_SEARCHPREF_INFO     arrSearchPref[ 20 ];
   int                     nSearchPrefCount  = 0;
   HRESULT                 hResult;

   //***************************************************************************
   if( -1 != m_pSearchPref->nAsynchronous )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref = ADS_SEARCHPREF_ASYNCHRONOUS;
      arrSearchPref[nSearchPrefCount].vValue.dwType= ADSTYPE_BOOLEAN;
      arrSearchPref[nSearchPrefCount].vValue.Boolean = (BOOLEAN) m_pSearchPref->nAsynchronous;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nAttributesOnly )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_ATTRIBTYPES_ONLY;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_BOOLEAN;
      arrSearchPref[nSearchPrefCount].vValue.Boolean  = (BOOLEAN) m_pSearchPref->nAttributesOnly;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nDerefAliases )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
      arrSearchPref[nSearchPrefCount].vValue.dwType= ADSTYPE_INTEGER;
      if( m_pSearchPref->nDerefAliases )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_DEREF_ALWAYS;
      }
      else
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_DEREF_NEVER;
      }
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nTimeOut )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_TIMEOUT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = m_pSearchPref->nTimeOut;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nTimeLimit )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_TIME_LIMIT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = m_pSearchPref->nTimeLimit;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nSizeLimit )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_SIZE_LIMIT;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = m_pSearchPref->nSizeLimit;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( -1 != m_pSearchPref->nPageSize )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_PAGESIZE;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      arrSearchPref[nSearchPrefCount].vValue.Integer  = m_pSearchPref->nPageSize;
      nSearchPrefCount++;
   }

   //***************************************************************************
   if( _tcslen( m_pSearchPref->szScope ) )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_SEARCH_SCOPE;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      if( !_tcsicmp( m_pSearchPref->szScope, _T("Base" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_BASE;
      }
      if( !_tcsicmp( m_pSearchPref->szScope, _T("OneLevel" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_ONELEVEL;
      }
      if( !_tcsicmp( m_pSearchPref->szScope, _T("Subtree" ) ) )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer = ADS_SCOPE_SUBTREE;
      }
      nSearchPrefCount++;
   }


   //***************************************************************************
   if( -1 != m_pSearchPref->nChaseReferrals )
   {
      arrSearchPref[nSearchPrefCount].dwSearchPref    = ADS_SEARCHPREF_CHASE_REFERRALS;
      arrSearchPref[nSearchPrefCount].vValue.dwType   = ADSTYPE_INTEGER;
      if( m_pSearchPref->nChaseReferrals )
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer  = ADS_CHASE_REFERRALS_ALWAYS;
      }
      else
      {
         arrSearchPref[nSearchPrefCount].vValue.Integer  = ADS_CHASE_REFERRALS_NEVER;
      }
      nSearchPrefCount++;
   }

   hResult  = m_pSearch->SetSearchPreference( arrSearchPref, nSearchPrefCount );

   ASSERT( S_OK == hResult );

   return hResult;
}



/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
HRESULT  CADsSearchDataSource::CreateSearchInterface( )
{
   BSTR     bstrPath = NULL;
   HRESULT  hResult  = E_FAIL;

   bstrPath = AllocBSTR( m_pSearchPref->szSource );

   if( _tcslen( m_pSearchPref->szUserName ) )
   {
      BSTR  bstrOpenAs = NULL;
      BSTR  bstrPassword = NULL;
      LONG  lControlCode = 0L;

      bstrOpenAs     = AllocBSTR( m_pSearchPref->szUserName );

      if (_tcslen(m_pSearchPref->szPassword))
          bstrPassword   = AllocBSTR( m_pSearchPref->szPassword );
      else
          bstrPassword = NULL;

      if ((NULL != bstrOpenAs) && (0 == _wcsicmp( bstrOpenAs, L"NULL" )))
      {
          SysFreeString(bstrOpenAs);
          bstrOpenAs = NULL;
      }
      if ((NULL != bstrPassword) && (0 == _wcsicmp( bstrPassword, L"NULL" )))
      {
          SysFreeString(bstrPassword);
          bstrPassword = NULL;
      }

      if( m_pSearchPref->bEncryptPassword )
         lControlCode   = lControlCode | ADS_SECURE_AUTHENTICATION;

      hResult        = ADsOpenObject( bstrPath,
                                      bstrOpenAs,
                                      bstrPassword,
                                      lControlCode, IID_IDirectorySearch, (void**)&m_pSearch );

      if (NULL != bstrOpenAs)
        SysFreeString( bstrOpenAs );
      
      if (NULL != bstrPassword)
        SysFreeString( bstrPassword );
   }
   else
   {
      hResult  = ADsGetObject( bstrPath, IID_IDirectorySearch, (void**)&m_pSearch );
   }

   ASSERT( SUCCEEDED( hResult ) );

   if (NULL != bstrPath)
      SysFreeString( bstrPath );

   return hResult;
}


/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL     CADsSearchDataSource::BringRowInBuffer( int nRow )
{
   HRESULT  hResult  = E_FAIL;

   if( NULL == m_pSearch )
   {
      m_bNoMoreData  = TRUE;
   }

   if( m_bNoMoreData )
      return FALSE;

   if( m_nCurrentRow == nRow )
      return TRUE;

   if( m_nCurrentRow != -1 )
   {
      ASSERT( nRow >= m_nCurrentRow );
   }

   while( m_nCurrentRow != nRow )
   {
      m_bNoMoreData  = TRUE;
      TRACE(  _T("Asking for row %d\n"), m_nCurrentRow + 1);
      hResult  = m_pSearch->GetNextRow( m_hSearch );
      if( hResult != S_OK )
         break;
      m_bNoMoreData  = FALSE;

      if( hResult == S_ADS_NOMORE_ROWS )
      {
         m_bNoMoreData  = TRUE;
      }

      m_nCurrentRow++;
   }

   if( hResult == S_OK )
   {
      ReadColumnNames( nRow );
   }

   return ( hResult == S_OK );
}


/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
BOOL  CADsSearchDataSource::ReadColumnNames( int nRow )
{
   HRESULT  hResult = E_FAIL;
   WCHAR*   pszColumnName;
   TCHAR    szColumn[ 256 ];

   ASSERT( nRow == m_nCurrentRow );
   if( nRow != m_nCurrentRow )
   {
      return FALSE;
   }

   m_strColumns.RemoveAll( );
   ReadADsPath( );

   while( TRUE )
   {
      hResult  = m_pSearch->GetNextColumnName( m_hSearch, &pszColumnName );
      //if( SUCCEEDED( hResult ) )
      if( S_OK == hResult )
      {
         Convert( szColumn, pszColumnName );
         m_strColumns.Add( szColumn );
         FreeADsStr( pszColumnName );
      }
      //if( FAILED( hResult ) )
      else
      {
         break;
      }
   }

   return TRUE;
}

/*****************************************************************************
   Function:
   Arguments:
   Return:
   Purpose:
   Author(s):
   Revision:
   Date:
*****************************************************************************/
void  CADsSearchDataSource::ReadADsPath( void )
{
   HRESULT           hResult;
   BSTR              bstrColumnName;
   ADS_SEARCH_COLUMN aSearchColumn;
   ADS_ATTR_INFO      aAttrDef;
   BOOL              bOK   = TRUE;
   COleDsSyntax*     pSyntax;
   CString           rValue   = _T("");

   bstrColumnName = AllocBSTR( _T("ADsPath") );

   hResult        = m_pSearch->GetColumn( m_hSearch,
                                          bstrColumnName,
                                          &aSearchColumn );
   SysFreeString( bstrColumnName );

   if( SUCCEEDED( hResult ) )
   {
      aAttrDef.pszAttrName = aSearchColumn.pszAttrName;
      aAttrDef.dwADsType   = aSearchColumn.dwADsType;
      aAttrDef.pADsValues  = aSearchColumn.pADsValues;
      aAttrDef.dwNumValues = aSearchColumn.dwNumValues;

      pSyntax  = new COleDsBSTR;

      hResult  = pSyntax->Native2Value( &aAttrDef, rValue );
      delete pSyntax;

      hResult        = m_pSearch->FreeColumn( &aSearchColumn );
   }

   m_ADsPath.Add( rValue );
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\adsqview.cpp ===
// adsqryView.cpp : implementation of the CAdsqryView class
//

#include "stdafx.h"
#include "viewex.h"
#include "adsqDoc.h"
#include "adsqView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAdsqryView

IMPLEMENT_DYNCREATE(CAdsqryView, CListView )

BEGIN_MESSAGE_MAP(CAdsqryView, CListView )
	//{{AFX_MSG_MAP(CAdsqryView)
	ON_WM_VSCROLL()
	//}}AFX_MSG_MAP
	// Standard printing commands
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAdsqryView construction/destruction

extern   CViewExApp NEAR theApp;
extern   TCHAR szOpen[ MAX_PATH ];

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CAdsqryView::CAdsqryView()
{
	// TODO: add construction code here
   m_nLastInsertedRow   = -1;
   m_nColumnsCount      = 0;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CAdsqryView::~CAdsqryView()
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CAdsqryView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs

	cs.style   |= LVS_REPORT;

   return CListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CAdsqryView diagnostics

#ifdef _DEBUG
void CAdsqryView::AssertValid() const
{
	CListView::AssertValid();
}

void CAdsqryView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}

CAdsqryDoc* CAdsqryView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CAdsqryDoc)));
	return (CAdsqryDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CAdsqryView message handlers

/***********************************************************
  Function:    CAdsqryView::OnInitialUpdate
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CAdsqryView::OnInitialUpdate() 
{
   CListView ::OnInitialUpdate();

   CreateColumns( );
   AddRows( );
}


/***********************************************************
  Function:    CAdsqryView::AddColumns
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CAdsqryView::AddColumns( int nRow )
{
   int               nColumnCount, nIdx, nColumn;
   CString           strColumn;
   LV_COLUMN         lvColumn;
   CADsDataSource*   pDataSource;
   CAdsqryDoc*       pDoc;
   
   pDoc        = GetDocument( );
   pDataSource = pDoc->GetADsDataSource( );

   nColumnCount   =  pDataSource->GetColumnsCount( nRow );
   
   for( nIdx = 0; nIdx < nColumnCount ; nIdx++ )
   {
      pDataSource->GetColumnText( nRow, nIdx, strColumn );

      for( nColumn = 0; nColumn < m_nColumnsCount ; nColumn++ )
      {
         if( m_strColumns[ nColumn ] == strColumn )
            break;
      }
      if( nColumn == m_nColumnsCount )
      {
         m_strColumns.Add( strColumn );
         m_nColumnsCount++;
         lvColumn.iSubItem = m_nColumnsCount - 1;
         lvColumn.mask     = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	      lvColumn.fmt      = LVCFMT_LEFT;
	      lvColumn.pszText  = strColumn.GetBuffer( 256 );
	      lvColumn.cx       = GetListCtrl( ).GetStringWidth( _T("WWWWWWWWWW") ) + 15;

         GetListCtrl( ).InsertColumn( m_nColumnsCount - 1, &lvColumn );
         TRACE( _T("Found new Column %s\n"), (LPCTSTR)strColumn );
      }
   }
}



/***********************************************************
  Function:    CAdsqryView::CreateColumns
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CAdsqryView::CreateColumns( void )
{
/*   int               nCol;
   LV_COLUMN         lvColumn;
   CADsDataSource*   pDataSource;
   CAdsqryDoc*       pDoc;
   CString           strColumn;
   
   pDoc  = GetDocument( );
   pDataSource = pDoc->GetADsDataSource( );

   m_nColumnsCount = pDataSource->GetColumnsCount( );

   for( nCol = 0 ; nCol < m_nColumnsCount ; nCol++ )
   {
      pDataSource->GetColumnText( nCol, strColumn );

      lvColumn.iSubItem = nCol;
      lvColumn.mask     = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
	   lvColumn.fmt      = LVCFMT_LEFT;
	   lvColumn.pszText  = strColumn.GetBuffer( 256 );
	   lvColumn.cx       = GetListCtrl( ).GetStringWidth( _T("WWWWWWWWWW") ) + 15;

      GetListCtrl( ).InsertColumn( nCol, &lvColumn );
   }*/
}


/***********************************************************
  Function:    CAdsqryView::ClearContent
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CAdsqryView::ClearContent( void )
{
   GetListCtrl( ).DeleteAllItems( );

   m_nLastInsertedRow   = -1;
}


/***********************************************************
  Function:    CAdsqryView::AddRows
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CAdsqryView::AddRows( void )
{
   int               nCol;
   int               nTopIndex, nPageItems;
   int               nRowIndex;
   CADsDataSource*   pDataSource;
   CAdsqryDoc*       pDoc;
   
   pDoc        = GetDocument( );
   pDataSource = pDoc->GetADsDataSource( );

   nTopIndex   = GetListCtrl( ).GetTopIndex( );
   nPageItems  = GetListCtrl( ).GetCountPerPage( );
   if( m_nLastInsertedRow < nTopIndex + 2 * nPageItems )
   {
      HCURSOR  aCursor, oldCursor;

      aCursor     = LoadCursor( NULL, IDC_WAIT );
      oldCursor   = SetCursor( aCursor );
      // we must add extra items in the list view
      for( nRowIndex = m_nLastInsertedRow + 1 ; 
           nRowIndex < nTopIndex + 2 * nPageItems ;
           nRowIndex++ )
      {
         CString  strValue;
         BOOL  bWork = FALSE;

         AddColumns( nRowIndex );

         for( nCol = 0; nCol < m_nColumnsCount ; nCol++ )
         {
            CString  strColumnName;

            strColumnName  = m_strColumns.GetAt( nCol );

            if( pDataSource->GetValue( nRowIndex, nCol, strValue ) || 
                pDataSource->GetValue( nRowIndex, strColumnName, strValue ) )
            {
               LV_ITEM  lvItem;
               TCHAR*   pszText;

               
               pszText  = (TCHAR*) malloc( strValue.GetLength( ) + 10 );
               
					if(NULL != pszText)
					{
						_tcscpy( pszText, _T("") );
						if( !nCol )
						{
							_itot( nRowIndex + 1, pszText, 10 );
							_tcscat( pszText, _T(") ") );
						}

						_tcscat( pszText, strValue.GetBuffer( strValue.GetLength( ) + 1 ) );
               
						bWork = TRUE;
						memset( &lvItem, 0, sizeof(lvItem) );

						lvItem.mask       = LVIF_TEXT | LVIF_STATE; 
						lvItem.state      = 0; 
						lvItem.stateMask  = 0; 
						lvItem.iItem      = nRowIndex;
						lvItem.iSubItem   = nCol;
						lvItem.pszText    = pszText;
						lvItem.cchTextMax = _tcslen( pszText );

						if( nCol == 0)
						{
							GetListCtrl( ).InsertItem(&lvItem);
						}
						else
						{
							GetListCtrl( ).SetItem(&lvItem);
						}

						free( pszText );
					}
            }
         }
         if( bWork )
         {
            m_nLastInsertedRow++;
         }
      }
      SetCursor( oldCursor );
   }
}


/***********************************************************
  Function:    CAdsqryView::OnVScroll
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CAdsqryView::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) 
{
	// TODO: Add your message handler code here and/or call default

   CListView ::OnVScroll(nSBCode, nPos, pScrollBar);
   
   //if( nSBCode == SB_LINEDOWN || nSBCode == SB_PAGEDOWN )
   {
      AddRows( );
   }
}


/***********************************************************
  Function:    CAdsqryView::OnChildNotify
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CAdsqryView::OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult) 
{
	// TODO: Add your specialized code here and/or call the base class
   NMHDR*            pHeader;
   int               nSel;
   CADsDataSource*   pDataSource;
   CAdsqryDoc*       pDoc;
   CString           strADsPath;

   while( TRUE )
   {
      if( message != WM_NOTIFY )
         break;

      pHeader  = (NMHDR*)lParam;
      if( pHeader->code != NM_DBLCLK )
         break;

      
      if( !GetListCtrl( ).GetSelectedCount( ) )
         break;

      nSel  = GetListCtrl( ).GetNextItem( -1, LVNI_SELECTED );;
          
      if( -1 == nSel )
         break;

      pDoc           = GetDocument( );
      pDataSource    = pDoc->GetADsDataSource( );

      pDataSource->GetADsPath( nSel, strADsPath );

      _tcscpy( szOpen, strADsPath.GetBuffer( MAX_PATH ) );

      theApp.OpenDocumentFile( strADsPath.GetBuffer( MAX_PATH ) );

      return TRUE;
   }
	
	return CListView::OnChildNotify(message, wParam, lParam, pLResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\adsqview.h ===
// adsqryView.h : interface of the CAdsqryView class
//
/////////////////////////////////////////////////////////////////////////////



class CAdsqryView : public CListView
{
protected: // create from serialization only
	CAdsqryView();
	DECLARE_DYNCREATE(CAdsqryView)

// Attributes
public:
	CAdsqryDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAdsqryView)
	public:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void OnInitialUpdate();
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pLResult);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CAdsqryView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CAdsqryView)
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
protected:
   void  CreateColumns  ( void );
   void  ClearContent   ( void );
   void  AddRows        ( void );
   void  AddColumns     ( int nRow );

protected:
   int            m_nLastInsertedRow;
   int            m_nColumnsCount;
   CStringArray   m_strColumns;

};

#ifndef _DEBUG  // debug version in adsqryView.cpp
inline CAdsqryDoc* CAdsqryView::GetDocument()
   { return (CAdsqryDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\bwsview.cpp ===
// BrowseView.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "bwsview.h"
#include "schclss.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define  BUFF_SIZE   0xFFFFL
//#define  BUFF_SIZE   0x1000L

/////////////////////////////////////////////////////////////////////////////
// CBrowseView

IMPLEMENT_DYNCREATE(CBrowseView, CTreeView)

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CBrowseView::CBrowseView()
{
   BOOL        bOK;
   DWORD       dwObjectType;
   CBitmap*    pBitmap;
   UINT        imageID;

   m_pImageList  = new CImageList( );

   if( NULL != m_pImageList )
   {
      bOK   = m_pImageList->Create( 18, 18, FALSE, 20, 20 );
      if( bOK )
      {
         for( dwObjectType = FIRST; dwObjectType < LIMIT ; dwObjectType++)
         {
            pBitmap  = new CBitmap;

            imageID  = GetBitmapImageId  ( dwObjectType );
            pBitmap->LoadBitmap( imageID );
            m_pImageList->Add( pBitmap, (COLORREF)0L );

            pBitmap->DeleteObject( );
            delete   pBitmap;
         }
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CBrowseView::OnInitialUpdate()
{
   HTREEITEM      hItem;
   CMainDoc*      pDoc;
   DWORD          dwStyle;
   BOOL           bRez;
   COleDsObject*  pObject;

   m_bDoNotUpdate = TRUE;

   pDoc     = (CMainDoc*)  GetDocument( );

   dwStyle  = TVS_HASLINES | TVS_LINESATROOT | TVS_HASBUTTONS;

   bRez     = GetTreeCtrl( ).ModifyStyle( 0L, dwStyle );

   GetTreeCtrl( ).SetImageList( m_pImageList, TVSIL_NORMAL );
   GetTreeCtrl( ).DeleteAllItems( );
   GetTreeCtrl( ).SetIndent( 20 );

   pObject  = pDoc->GetCurrentObject( );
   hItem    = GetTreeCtrl( ).InsertItem( pObject->GetItemName( ) );
   GetTreeCtrl( ).SetItemData( hItem, pDoc->GetToken( &pObject ) );
   GetTreeCtrl( ).SetItemImage( hItem, pObject->GetType( ), pObject->GetType( ) );

   m_bDoNotUpdate = FALSE;

   CTreeView::OnInitialUpdate( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CBrowseView::~CBrowseView()
{
   delete m_pImageList;
}

BEGIN_MESSAGE_MAP(CBrowseView, CTreeView)
	//{{AFX_MSG_MAP(CBrowseView)
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelChanged)
	ON_NOTIFY_REFLECT(TVN_ITEMEXPANDED, OnItemExpanded)
	ON_COMMAND(IDM_ADD, OnAddItem)
	ON_COMMAND(IDM_DELETE, OnDeleteItem)
	ON_COMMAND(IDM_MOVEITEM, OnMoveItem)
	ON_COMMAND(IDM_COPYITEM, OnCopyItem)
	ON_COMMAND(IDM_REFRESH, OnRefresh)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


CMainDoc*   sgpDoc;

int __cdecl  QSortCompare( const void* pVal1, const void* pVal2 )
{
   COleDsObject*  pObject1;
   COleDsObject*  pObject2;
   CString*       pString1;
   CString*       pString2;
   int            nDiff;

   pObject1 = sgpDoc->GetObject( (void*)pVal1 );
   pObject2 = sgpDoc->GetObject( (void*)pVal2 );
   nDiff    = pObject1->GetType( ) - pObject2->GetType( );
   if( nDiff )
      return nDiff;

   pString1 = pObject1->PtrGetItemName( );
   pString2 = pObject2->PtrGetItemName( );

   return pString1->Compare( (LPCTSTR)( pString2->GetBuffer( 128 ) ) );
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CBrowseView::SortChildItemList( DWORD* pChildTokens, DWORD dwCount )
{
   sgpDoc   = (CMainDoc*)GetDocument( );
   qsort( (void*)pChildTokens, dwCount, sizeof(DWORD), QSortCompare );
}
/////////////////////////////////////////////////////////////////////////////
// CBrowseView diagnostics

#ifdef _DEBUG
/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::AssertValid() const
{
	CTreeView::AssertValid();
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::Dump(CDumpContext& dc) const
{
	CTreeView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CBrowseView message handlers


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	// TODO: Add your control notification handler code here
	
	
   HTREEITEM      hTreeItem, hChildItem;;
   CString        strItemName;
   CMainDoc*      pDoc;
   DWORD          dwIter;
   DWORD          dwToken;
   DWORD*         pTokens     = NULL;
   DWORD          dwNumItems  = 0L;

   *pResult       = 0;
   if( m_bDoNotUpdate )
   {
      return;
   }

   hTreeItem      = GetTreeCtrl( ).GetSelectedItem( );
   hChildItem     = TVI_LAST;

   if( NULL != hTreeItem )
   {
      dwToken  = (DWORD)GetTreeCtrl( ).GetItemData( hTreeItem );
      pDoc     = (CMainDoc*)  GetDocument( );

      ASSERT( NULL != pDoc );

      if( NULL != pDoc )
      {
         HCURSOR  oldCursor, newCursor;

         newCursor   = LoadCursor( NULL, IDC_WAIT );
         oldCursor   = SetCursor( newCursor );

         // the item has children support ???
         pTokens     = (DWORD*) malloc( sizeof(DWORD) * BUFF_SIZE );

         if( !GetTreeCtrl( ).ItemHasChildren( hTreeItem ) )
         {
            dwNumItems  = pDoc->GetChildItemList( dwToken, pTokens, BUFF_SIZE );

            if( dwNumItems )
            {
               // siaply children items
               SortChildItemList( pTokens, dwNumItems );
               for( dwIter = 0; dwIter < dwNumItems ; dwIter++ )
               {
                  COleDsObject*  pObject;
                  CString*       pName;
                  DWORD          dwType;
                  TCHAR          szName[ 256 ];

                  pObject     = pDoc->GetObject( &pTokens[ dwIter ] );
                  dwType      = pObject->GetType( );
                  pName       = pObject->PtrGetItemName( );

                  _ultot( dwIter + 1, szName, 10 );
                  _tcscat( szName, _T(") ") );
                  _tcscat( szName, pName->GetBuffer( 128 ) );

                  /*hChildItem  = GetTreeCtrl( ).InsertItem( pName->GetBuffer( 128 ),
                                                           hTreeItem, hChildItem ); */

                  hChildItem  = GetTreeCtrl( ).InsertItem( szName,
                                                           hTreeItem,
                                                           hChildItem );

                  GetTreeCtrl( ).SetItemData( hChildItem, pTokens[ dwIter ] );
                  GetTreeCtrl( ).SetItemImage( hChildItem, dwType, dwType );
               }
            }
         }
         if( NULL != pTokens )
         {
            free((void*)pTokens);
         }
         pDoc->SetCurrentItem( dwToken );
         SetCursor( oldCursor );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnItemExpanded(NMHDR* pNMHDR, LRESULT* pResult)
{
	NM_TREEVIEW*   pNMTreeView = (NM_TREEVIEW*)pNMHDR;
   HTREEITEM      hItem;
	// TODO: Add your control notification handler code here
	
   hItem = pNMTreeView->itemNew.hItem;
   if( !( pNMTreeView->itemNew.state & TVIS_EXPANDED ) )
   {
      //    this should mean that the item was unexpanded.
      //    We should delete its children.

      /*hChildItem  = GetTreeCtrl( ).GetChildItem( hItem );
      while( NULL != hChildItem )
      {
         bRez  = GetTreeCtrl( ).DeleteItem( hChildItem );
         ASSERT( bRez );
         hChildItem  = GetTreeCtrl( ).GetChildItem( hItem );
      } */
   }
   else
   {
      /*dwItemData  = GetTreeCtrl( ).GetItemData( hItem );
      GetItemPath( hItem, strItemName );
      pDoc  = (CMainDoc*)  GetDocument( );

      ASSERT( NULL != pDoc );

      if( NULL != pDoc )
      {
         HCURSOR  oldCursor, newCursor;

         newCursor   = LoadCursor( NULL, IDC_WAIT );
         oldCursor   = SetCursor( newCursor );

         // the item has children support ???
         lpItemsName = (LPWSTR) malloc( 0x40000L );
         lpItemsType = (LPDWORD) malloc( 0x20000L );

         bRez  = pDoc->GetChildItemList( strItemName, dwItemData,
                                         lpItemsName, lpItemsType,
                                         &dwNumItems, 0x40000L );

         if( bRez )
         {

            // siaply children items
            lpName   = lpItemsName;
            for( nIter = 0; nIter < dwNumItems ; nIter++ )
            {
               hChildItem  = GetTreeCtrl( ).InsertItem( lpName, hItem );
               GetTreeCtrl( ).SetItemData( hChildItem, lpItemsType[ nIter ] );
               lpName      = lpName + ( _tcslen( lpName ) + 1 );
            }
         }

         if( NULL != lpItemsName )
         {
            free( lpItemsName );
         }

         if( NULL != lpItemsType )
         {
            free( lpItemsType );
         }

         //pDoc->SetItemName( strItemName, dwItemData );

         SetCursor( oldCursor );
      } */
   }

	*pResult = 0;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnAddItem()
{
	// TODO: Add your command handler code here
   CMainDoc*      pDoc;
   COleDsObject*  pObject;
   HRESULT        hResult;

   pDoc     = (CMainDoc*)  GetDocument( );

   pObject  = pDoc->GetCurrentObject( );
   if( NULL == pObject )
      return;

   if( pObject->AddItemSuported( ) )
   {
      pObject->CreateTheObject( );
      hResult  = pObject->AddItem( );
      pObject->ReleaseIfNotTransient( );
      if( FAILED( hResult ) )
      {
         AfxMessageBox( OleDsGetErrorText( hResult ) );
      }
      else
      {
         pDoc->DeleteAllItems( );
         OnInitialUpdate( );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnDeleteItem()
{
	// TODO: Add your command handler code here
   CMainDoc*      pDoc;
   COleDsObject*  pObject;
   HRESULT        hResult;

   pDoc     = (CMainDoc*)  GetDocument( );

   pObject  = pDoc->GetCurrentObject( );
   if( NULL == pObject )
      return;

   if( pObject->DeleteItemSuported( ) )
   {
      pObject->CreateTheObject( );
      hResult  = pObject->DeleteItem( );
      pObject->ReleaseIfNotTransient( );
      if( FAILED( hResult ) )
      {
         AfxMessageBox( OleDsGetErrorText( hResult ) );
      }
      else
      {
         pDoc->DeleteAllItems( );
         OnInitialUpdate( );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnMoveItem()
{
	// TODO: Add your command handler code here
   CMainDoc*      pDoc;
   COleDsObject*  pObject;
   HRESULT        hResult;

   pDoc     = (CMainDoc*)  GetDocument( );

   pObject  = pDoc->GetCurrentObject( );
   if( NULL == pObject )
      return;

   if( pObject->MoveItemSupported( ) )
   {
      hResult  = pObject->MoveItem( );
      if( FAILED( hResult ) )
      {
         AfxMessageBox( OleDsGetErrorText( hResult ) );
      }
      else
      {
         OnRefresh( );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnCopyItem()
{
   // TODO: Add your command handler code here
   CMainDoc*      pDoc;
   COleDsObject*  pObject;
   HRESULT        hResult;

   pDoc     = (CMainDoc*)  GetDocument( );

   pObject  = pDoc->GetCurrentObject( );
   if( NULL == pObject )
      return;

   if( pObject->CopyItemSupported( ) )
   {
      hResult  = pObject->CopyItem( );

      if( FAILED( hResult ) )
      {
         AfxMessageBox( OleDsGetErrorText( hResult ) );
      }
      else
      {
         OnRefresh( );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnRefresh()
{
	// TODO: Add your command handler code here
   CMainDoc*      pDoc;

   pDoc  = (CMainDoc*)GetDocument( );
   pDoc->DeleteAllItems( );
   OnInitialUpdate( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CBrowseView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
   HTREEITEM   hTreeItem;

   // TODO: Add your specialized code here and/or call the base class
   CTreeView::OnUpdate( pSender, lHint, pHint );	

   hTreeItem      = GetTreeCtrl( ).GetSelectedItem( );

   if( NULL == hTreeItem )
   {
      hTreeItem      = GetTreeCtrl( ).GetRootItem( );
      GetTreeCtrl( ).SelectItem( hTreeItem );
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\bwsview.h ===
// BrowseView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CBrowseView view

class CBrowseView : public CTreeView
{
protected:
	CBrowseView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CBrowseView)

// Attributes
public:
   void  OnInitialUpdate( void );
// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBrowseView)
	protected:
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CBrowseView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CBrowseView)
	afx_msg void OnSelChanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnItemExpanded(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnAddItem();
	afx_msg void OnDeleteItem();
	afx_msg void OnMoveItem();
	afx_msg void OnCopyItem();
	afx_msg void OnRefresh();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
   void  SortChildItemList( DWORD*, DWORD );

   BOOL        m_bDoNotUpdate;
   CImageList* m_pImageList;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cacls.h ===
// cacls.h: interface for the CADsAccessControlEntry class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CACLS_H__11DBDB41_BC2B_11D0_B1D8_00C04FD702AD__INCLUDED_)
#define AFX_CACLS_H__11DBDB41_BC2B_11D0_B1D8_00C04FD702AD__INCLUDED_

#if _MSC_VER >= 1000
#if (!defined(BUILD_FOR_NT40))
#pragma once
#endif
#endif // _MSC_VER >= 1000

typedef enum _tagACLTYPE
{
   acl_Invalid = 0,
   acl_DACL,
   acl_SACL,
   acl_Limit
} ACLTYPE;

class CADsAccessControlEntry : public COleDsObject  
{
   public:
	   CADsAccessControlEntry  ( void      );
      CADsAccessControlEntry  ( IUnknown* );
	   ~CADsAccessControlEntry ( void      );

   public:
	   void FooFunction(void);
      IDispatch*  GetACE      ( void      );
      IDispatch*  CreateACE   ( void      );

      HRESULT     PutProperty ( int, 
                                CString&, 
                                long Code = ADS_PROPERTY_UPDATE );

      HRESULT     GetProperty ( int, 
                                CString&  );

   private:
      void        InitializeMembers( void );

};

class CADsAccessControlList : public COleDsObject
{
   public:
	   CADsAccessControlList      ( void      );
      CADsAccessControlList      ( IUnknown* );
	   ~CADsAccessControlList     ( void      );

   public:
      IDispatch*     GetACL      ( void      );
      IDispatch*     CreateACL   ( void      );
      
      void           SetDocument ( CMainDoc* );
      
      int            GetACECount ( void      );
      CADsAccessControlEntry*  GetACEObject( int nACE  );

      HRESULT        AddACE      ( IUnknown* pNewACE );
      HRESULT        RemoveACE   ( IUnknown* pRemoveACE );

      void           RemoveAllACE( void      );

      HRESULT        PutProperty ( int, 
                                   int, 
                                   CString&, 
                                   long Code = ADS_PROPERTY_UPDATE );

      HRESULT        GetProperty ( int, 
                                   int, 
                                   CString&  );
      

   private:
      void  InitializeMembers    ( void      );

   private:
      CObArray  m_arrACE;
};


class CADsSecurityDescriptor : public COleDsObject  
{
   public:
	   CADsSecurityDescriptor();
      CADsSecurityDescriptor( IUnknown* );
	   virtual ~CADsSecurityDescriptor();

   public:
      HRESULT        PutProperty ( int, 
                                   CString&, 
                                   long Code = ADS_PROPERTY_UPDATE );
      HRESULT        GetProperty ( int, 
                                   CString& );

      
      HRESULT        PutProperty ( ACLTYPE, 
                                   int, 
                                   int, 
                                   CString&, 
                                   long Code = ADS_PROPERTY_UPDATE );

      HRESULT        GetProperty ( ACLTYPE, 
                                   int, 
                                   int, 
                                   CString& );

      HRESULT        PutACL      ( IDispatch* pACL, 
                                   ACLTYPE eACL );

	   IDispatch*     GetACL      ( ACLTYPE eACL );
      CADsAccessControlList*     GetACLObject( ACLTYPE eACL );
      
      HRESULT        AddACE      ( ACLTYPE eACL, IUnknown* pNewACE );
      HRESULT        RemoveACE   ( ACLTYPE eACL, IUnknown* pNewACE );
      void           RemoveAllACE( ACLTYPE eACL );
      int            GetACECount ( ACLTYPE eACL );
      void           SetDocument ( CMainDoc*    );

   private:
      void                    InitializeMembers ( );
      

   private:
      COleDsObject*  pACLObj[ acl_Limit ];
};


#endif // !defined(AFX_CACLS_H__11DBDB41_BC2B_11D0_B1D8_00C04FD702AD__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cacls.cpp ===
// cacls.cpp: implementation of the CADsAccessControlEntry class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"
#include "cacls.h"
#include "newquery.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************

//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlEntry::CADsAccessControlEntry()
{
   InitializeMembers( );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlEntry::CADsAccessControlEntry( IUnknown* pIUnk)
   :COleDsObject( pIUnk )
{
   InitializeMembers( );
}

//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlEntry::~CADsAccessControlEntry( )
{
}



//***********************************************************
//  Function:    CADsAccessControlEntry::PutProperty
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlEntry::PutProperty ( int nProp,
                                               CString& rValue,
                                               long lCode  )
{
   BOOL     bOldUseGeneric;
   HRESULT  hResult;

   bOldUseGeneric = m_pDoc->GetUseGeneric( );

   m_pDoc->SetUseGeneric( FALSE );

   hResult  = COleDsObject::PutProperty( nProp, rValue, lCode );

   m_pDoc->SetUseGeneric( bOldUseGeneric );

   return hResult;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlEntry::GetProperty ( int nProp,
                                               CString& rValue )
{
   BOOL     bOldUseGeneric;
   HRESULT  hResult;

   bOldUseGeneric = m_pDoc->GetUseGeneric( );

   m_pDoc->SetUseGeneric( FALSE );

   hResult  = COleDsObject::GetProperty( nProp, rValue );

   m_pDoc->SetUseGeneric( bOldUseGeneric );

   return hResult;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
IDispatch*  CADsAccessControlEntry::GetACE( )
{
   IDispatch*  pDispatch   = NULL;

   if( NULL != m_pIUnk )
   {
      m_pIUnk->QueryInterface( IID_IDispatch, (void**)&pDispatch );
   }

   return pDispatch;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
IDispatch*  CADsAccessControlEntry::CreateACE( )
{
   IDispatch*              pDispatch   = NULL;
   IADsAccessControlEntry* pNewACE     = NULL;
   HRESULT                 hResult     = NULL;
   DWORD                   dwAceType = 0;
   CACEDialog              aDialog;
   BSTR                    bstrTrustee;


   if( IDOK != aDialog.DoModal( ) )
      return NULL;

   hResult = CoCreateInstance(
                               CLSID_AccessControlEntry,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IADsAccessControlEntry,
                               (void **)&pNewACE
                             );
   if( SUCCEEDED( hResult ) )
   {
      bstrTrustee = AllocBSTR( aDialog.m_strTrustee.GetBuffer( 128 ) );

      pNewACE->put_Trustee( bstrTrustee );
      hResult  = pNewACE->QueryInterface( IID_IDispatch,
                                          (void**)&pDispatch );
      SysFreeString( bstrTrustee );
      pNewACE->Release( );
   }

   return pDispatch;
   return NULL;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsAccessControlEntry::InitializeMembers ( )
{
   IADsAccessControlEntry* pEntry;
   HRESULT           hResult;

   if( NULL != m_pIUnk )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsAccessControlEntry,
                                          (void**)&pEntry );
      if( SUCCEEDED( hResult ) )
      {
         BSTR  bstrTrustee = NULL;
         TCHAR szTrustee[ 256 ];

         pEntry->get_Trustee( &bstrTrustee );
         if( NULL != bstrTrustee )
         {
            Convert( szTrustee, bstrTrustee );
            m_strItemName  = szTrustee;
         }
         SysFreeString( bstrTrustee );
         pEntry->Release( );
      }
   }
   m_strSchemaPath   = _T("ACE");
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsSecurityDescriptor::CADsSecurityDescriptor()
{
   InitializeMembers( );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsSecurityDescriptor::CADsSecurityDescriptor( IUnknown* pIUnk )
   :COleDsObject( pIUnk )
{
   /*IADsSecurityDescriptor* pSecD;
   IDispatch*              pCopy;
   HRESULT  hResult;

   hResult  = m_pIUnk->QueryInterface( IID_IADsSecurityDescriptor,
                                       (void**)&pSecD );

   hResult  = pSecD->CopySecurityDescriptor( &pCopy );

   if( SUCCEEDED( hResult ) )
   {
      m_pIUnk->Release( );
      hResult  = pCopy->QueryInterface( IID_IUnknown,(void**)&m_pIUnk );
      pCopy->Release( );
   }

   pSecD->Release( );*/

   InitializeMembers( );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsSecurityDescriptor::~CADsSecurityDescriptor()
{
   for( int nIdx = 0; nIdx < (int) acl_Limit ; nIdx++ )
   {
      if( NULL != pACLObj[ nIdx ] )
         delete pACLObj[ nIdx ];
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsSecurityDescriptor::PutProperty ( int nProp,
                                               CString& rValue,
                                               long lCode )
{
   BOOL     bOldUseGeneric;
   HRESULT  hResult;

   bOldUseGeneric = m_pDoc->GetUseGeneric( );

   m_pDoc->SetUseGeneric( FALSE );

   hResult  = COleDsObject::PutProperty( nProp, rValue, lCode );

   m_pDoc->SetUseGeneric( bOldUseGeneric );

   return hResult;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsSecurityDescriptor::GetProperty ( int nProp,
                                               CString& rValue )
{
   BOOL     bOldUseGeneric;
   HRESULT  hResult;

   bOldUseGeneric = m_pDoc->GetUseGeneric( );

   m_pDoc->SetUseGeneric( FALSE );

   hResult  = COleDsObject::GetProperty( nProp, rValue );

   m_pDoc->SetUseGeneric( bOldUseGeneric );

   return hResult;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsSecurityDescriptor::InitializeMembers ( )
{
   HRESULT                 hResult;
   IADsSecurityDescriptor* pDescriptor = NULL;
   IDispatch*              pDispACL;

   m_strSchemaPath   = _T("SecurityDescriptor");

   pACLObj[ acl_SACL ]     = NULL;
   pACLObj[ acl_DACL ]     = NULL;
   pACLObj[ acl_Invalid ]    = NULL;

   if( NULL == m_pIUnk )
      return;

   while( TRUE )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsSecurityDescriptor,
                                          (void**)&pDescriptor );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      pDispACL = GetACL( acl_DACL );
      ASSERT( NULL != pDispACL );

      if( NULL != pDispACL )
      {
         pACLObj[ acl_DACL ]  = new CADsAccessControlList( pDispACL );
         pDispACL->Release( );
      }

      pDispACL = GetACL( acl_SACL );
      ASSERT( NULL != pDispACL );

      if( NULL != pDispACL )
      {
         pACLObj[ acl_SACL ]  = new CADsAccessControlList( pDispACL );
         pDispACL->Release( );
      }

      break;
   }

   if( NULL != pDescriptor )
   {
      pDescriptor->Release( );
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
IDispatch* CADsSecurityDescriptor::GetACL( ACLTYPE eType )
{
   HRESULT                    hResult;
   IDispatch*                 pACL        = NULL;
   IDispatch*                 pCopyACL    = NULL;
   IADsSecurityDescriptor*    pSecDescr   = NULL;

   while( TRUE )
   {
      if( NULL == m_pIUnk )
         break;

      //QI for IID_IADsSecurityDescriptor interface

      hResult  = m_pIUnk->QueryInterface( IID_IADsSecurityDescriptor,
                                          (void**)&pSecDescr );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         break;
      }

      hResult  = E_FAIL;

      if( acl_DACL == eType )
      {
         hResult  = pSecDescr->get_DiscretionaryAcl( &pACL );
      }
      if( acl_SACL == eType )
      {
         hResult  = pSecDescr->get_SystemAcl( &pACL );
      }
      pSecDescr->Release( );

      ASSERT( SUCCEEDED( hResult ) );
      break;
   }

   if( NULL != pACL )
   {
      //pCopyACL = CopyACL( pACL );
      //pACL->Release( );

      pACL->QueryInterface( IID_IDispatch, (void**)&pCopyACL );
      pACL->Release( );
   }

   return pCopyACL;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT CADsSecurityDescriptor::PutACL( IDispatch * pACL,
                                        ACLTYPE eACL )
{
   HRESULT     hResult = S_OK;
   IADsSecurityDescriptor*  pSecDescr   = NULL;

   while( TRUE )
   {
      if( NULL == m_pIUnk )
         break;

      //QI for IID_IADsSecurityDescriptor interface

      hResult  = m_pIUnk->QueryInterface( IID_IADsSecurityDescriptor,
                                          (void**)&pSecDescr );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         break;
      }

      hResult  = E_FAIL;

      if( acl_DACL == eACL )
      {
         hResult  = pSecDescr->put_DiscretionaryAcl( pACL );
      }
      if( acl_SACL == eACL )
      {
         hResult  = pSecDescr->put_SystemAcl( pACL );
      }

      pSecDescr->Release( );
      break;
   }

   return hResult;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsSecurityDescriptor::AddACE( ACLTYPE eACL, IUnknown* pNewACE )
{
   ASSERT( acl_DACL == eACL || acl_SACL == eACL );

   if( acl_DACL != eACL && acl_SACL != eACL )
      return -1;

   if( NULL == pACLObj[ (int)eACL ] )
      return -1;

   return ((CADsAccessControlList*)(pACLObj[ (int)eACL ]))->AddACE( pNewACE );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsSecurityDescriptor::RemoveACE( ACLTYPE eACL, IUnknown* pRemoveACE )
{
   ASSERT( acl_DACL == eACL || acl_SACL == eACL );

   if( acl_DACL != eACL && acl_SACL != eACL )
      return -1;

   if( NULL == pACLObj[ (int)eACL ] )
      return -1;

   return ((CADsAccessControlList*)(pACLObj[ (int)eACL ]))->RemoveACE( pRemoveACE );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsSecurityDescriptor::SetDocument( CMainDoc* pDoc )
{
   int   nIdx;

   COleDsObject::SetDocument ( pDoc );

   for( nIdx = 0 ; nIdx < (int)acl_Limit ; nIdx++ )
   {
      if( NULL != pACLObj[ nIdx ] )
         pACLObj[ nIdx ]->SetDocument( pDoc );
   }
}

//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsSecurityDescriptor::RemoveAllACE( ACLTYPE eACL )
{
   ASSERT( acl_DACL == eACL || acl_SACL == eACL );

   if( acl_DACL != eACL && acl_SACL != eACL )
      return;

   if( NULL == pACLObj[ (int)eACL ] )
      return;
}



//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlList*  CADsSecurityDescriptor::GetACLObject( ACLTYPE eACL )
{
   CADsAccessControlList* pACL;

   ASSERT( acl_DACL == eACL || acl_SACL == eACL );

   if( acl_DACL != eACL && acl_SACL != eACL )
      return NULL;

   pACL  = (CADsAccessControlList*) (pACLObj[ (int)eACL ]);

   return pACL;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlList::CADsAccessControlList()
{
   InitializeMembers( );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlList::CADsAccessControlList( IUnknown* pUnk ):
   COleDsObject( pUnk )
{
   InitializeMembers( );
}


//***********************************************************
//  Function:    CADsAccessControlList::AddACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlList::AddACE( IUnknown* pNewACE )
{
   IDispatch*  pDisp = NULL;
   HRESULT     hResult;
   IADsAccessControlList*  pACL  = NULL;

   if( NULL == m_pIUnk )
   {
      return E_FAIL;
   }

   hResult  = m_pIUnk->QueryInterface( IID_IADsAccessControlList,
                                       (void**)&pACL );

   if( FAILED( hResult ) )
      return hResult;

   hResult  = pNewACE->QueryInterface( IID_IDispatch, (void**)&pDisp );
   if( SUCCEEDED( hResult ) )
   {
      hResult  = pACL->AddAce( pDisp );

      if( SUCCEEDED( hResult ) )
         InitializeMembers( );

      pDisp->Release( );
   }

   pACL->Release( );

   return hResult;
}


//***********************************************************
//  Function:    CADsAccessControlList::AddACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlList::RemoveACE( IUnknown* pRemoveACE )
{
   IDispatch*  pDisp = NULL;
   HRESULT     hResult;
   IADsAccessControlList*  pACL  = NULL;

   if( NULL == m_pIUnk )
   {
      return E_FAIL;
   }

   hResult  = m_pIUnk->QueryInterface( IID_IADsAccessControlList,
                                       (void**)&pACL );

   if( FAILED( hResult ) )
      return hResult;

   hResult  = pRemoveACE->QueryInterface( IID_IDispatch, (void**)&pDisp );
   if( SUCCEEDED( hResult ) )
   {
      hResult  = pACL->RemoveAce( pDisp );

      if( SUCCEEDED( hResult ) )
         InitializeMembers( );

      pDisp->Release( );
   }

   pACL->Release( );

   return hResult;
}



//***********************************************************
//  Function:    CADsAccessControlList::~CADsAccessControlList
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlList::~CADsAccessControlList()
{
   for( int nIdx = 0 ; nIdx < m_arrACE.GetSize( ) ; nIdx++ )
   {
      delete m_arrACE.GetAt( nIdx );
   }

   m_arrACE.RemoveAll( );
}


//***********************************************************
//  Function:    CADsAccessControlList::GetACL
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
IDispatch*  CADsAccessControlList::GetACL( )
{
   IDispatch*  pDispatch   = NULL;

   if( NULL != m_pIUnk )
   {
      m_pIUnk->QueryInterface( IID_IDispatch, (void**)&pDispatch );
   }

   return pDispatch;
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
IDispatch*  CADsAccessControlList::CreateACL( )
{
   IDispatch*              pDispatch   = NULL;
   IADsAccessControlList*  pNewACL     = NULL;
   HRESULT                 hResult     = NULL;
   DWORD dwAceType = 0;

   hResult = CoCreateInstance(
                               CLSID_AccessControlList,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IADsAccessControlList,
                               (void **)&pNewACL
                             );
   if( SUCCEEDED( hResult ) )
   {
      hResult  = pNewACL->QueryInterface( IID_IDispatch,
                                          (void**)&pDispatch );
      pNewACL->Release( );
   }

   return pDispatch;
}

//***********************************************************
//  Function:    CADsAccessControlList::PutProperty
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlList::PutProperty ( int nACE,
                                              int nProp,
                                              CString& rVal,
                                              long lCode )
{
   HRESULT        hResult = S_OK;
   COleDsObject*  pACE;

   ASSERT( nACE < m_arrACE.GetSize( ) );

   if( nACE < m_arrACE.GetSize( ) )
   {
      pACE  = (COleDsObject*) m_arrACE.GetAt( nACE );

      hResult  = pACE->PutProperty ( nProp, rVal, lCode );
   }

   return hResult;
}



//***********************************************************
//  Function:    CADsAccessControlList::GetProperty
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  CADsAccessControlList::GetProperty ( int nACE,
                                              int nProp,
                                              CString& rVal )
{
   HRESULT        hResult = S_OK;
   COleDsObject*  pACE;

   ASSERT( nACE < m_arrACE.GetSize( ) );

   if( nACE < m_arrACE.GetSize( ) )
   {
      pACE  = (COleDsObject*) m_arrACE.GetAt( nACE );

      hResult  = pACE->GetProperty ( nProp, rVal );
   }

   return hResult;
}


//***********************************************************
//  Function:    CADsAccessControlList::InitializeMembers
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsAccessControlList::InitializeMembers( )
{
   IADsAccessControlList*  pACList   = NULL;
   IUnknown*               pIUnk;
   HRESULT                 hResult;
   IEnumVARIANT*           pEnum = NULL;
   VARIANT                 aVariant;
   IUnknown*               pACE;
   ULONG                   ulGet;

   if( !m_pIUnk )
      return;

   for( int nIdx = 0 ; nIdx < m_arrACE.GetSize( ) ; nIdx++ )
   {
      delete m_arrACE.GetAt( nIdx );
   }

   m_arrACE.RemoveAll( );


   while( TRUE )
   {
      //hResult  = m_pIUnk->QueryInterface( IID_IEnumVARIANT,
      //                                    (void**)&pEnum );
      hResult  = m_pIUnk->QueryInterface( IID_IADsAccessControlList,
                                          (void**)&pACList );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pACList->get__NewEnum( &pIUnk );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pIUnk->QueryInterface( IID_IEnumVARIANT,
                                        (void**)&pEnum );

      pIUnk->Release( );
      pACList->Release( );


      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      while( TRUE )
      {
         CADsAccessControlEntry* pNewACE;

         ulGet    = 0L;
         hResult  = pEnum->Next( 1, &aVariant, &ulGet );
         if( FAILED( hResult ) )
            break;

         if( 0 == ulGet )
            break;

         hResult  = V_DISPATCH( &aVariant )->QueryInterface( IID_IUnknown,
                                                             (void**)&pACE );
         VariantClear( &aVariant );
         pNewACE  = new CADsAccessControlEntry( pACE );

         if( NULL != m_pDoc )
         {
            pNewACE->SetDocument( m_pDoc );
         }

         m_arrACE.Add( pNewACE );

         pACE->Release( );
      }
      pEnum->Release( );
      break;
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CADsAccessControlList::SetDocument ( CMainDoc* pDoc )
{
   COleDsObject*  pObject;
   int            nSize, nIdx;

   COleDsObject::SetDocument ( pDoc );

   nSize = (int)m_arrACE.GetSize( );
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      pObject  = (COleDsObject*)m_arrACE.GetAt( nIdx );
      pObject->SetDocument( pDoc );
   }
}


//***********************************************************
//  Function:    CADsAccessControlList::GetACECount
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
int   CADsAccessControlList::GetACECount ( void )
{
   return (int)m_arrACE.GetSize( );
}


//***********************************************************
//  Function:    CADsAccessControlList::GetACEObject
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
CADsAccessControlEntry* CADsAccessControlList::GetACEObject ( int nACE )
{
   CADsAccessControlEntry* pACE;

   //ASSERT( nACE < GetACECount( ) );
   if( nACE >= GetACECount( ) )
      return NULL;

   pACE  = (CADsAccessControlEntry*) (m_arrACE.GetAt( nACE ) );

   return pACE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\ccomp.h ===
#ifndef  _CCOMPUTER_H_
#define  _CCOMPUTER_H_

class COleDsComputer: public COleDsObject
{

public:   
   COleDsComputer( IUnknown* );
   COleDsComputer( );
   ~COleDsComputer( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );

public:
   DWORD    GetChildren( DWORD*     pTokens, 
                         DWORD      dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, 
                         DWORD      dwFilters );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cdomain.h ===
#ifndef  _CDOMAIN_H_
#define  _CDOMAIN_H_

class COleDsDomain: public COleDsObject
{

public:   
   COleDsDomain( IUnknown* );
   COleDsDomain( );
   ~COleDsDomain( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );

public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\ccomp.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"
#include "resource.h"
#include "createit.h"
#include "delitem.h"

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsComputer::COleDsComputer( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsComputer::COleDsComputer( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = TRUE;
   m_bSupportAdd  = TRUE;
   m_bSupportMove = TRUE;
   m_bSupportCopy = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsComputer::~COleDsComputer( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsComputer::GetChildren( DWORD*     pTokens, 
                                      DWORD      dwMaxChildren,
                                      CDialog*   pQueryStatus,
                                      BOOL*      pFilters, 
                                      DWORD      dwFilters )
{
   HRESULT           hResult;
   IADsContainer*  pIContainer;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, 
                                       (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   return m_dwCount;
}
  


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsComputer::DeleteItem  ( COleDsObject* pObject )
{
   return ContainerDeleteItem( pObject );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsComputer::AddItem( )
{
   return ContainerAddItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsComputer::MoveItem( )
{
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsComputer::CopyItem( )
{
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cfserv.h ===
#ifndef  _CFILESERVICE_H_
#define  _CFILESERVICE_H_

class COleDsFileService: public COleDsService
{

public:   
   COleDsFileService( IUnknown* );
   COleDsFileService( );
   ~COleDsFileService( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );

   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cfserv.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"
#include "resource.h"
#include "grpcrtit.h"
#include "delgrpit.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileService::COleDsFileService( )
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileService::COleDsFileService( IUnknown *pIUnk): COleDsService( pIUnk )
{
   m_bHasChildren    = TRUE;
   m_bSupportAdd     = TRUE;   
   m_bSupportDelete  = TRUE;   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileService::~COleDsFileService( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsFileService::GetChildren( DWORD*     pTokens, 
                                         DWORD      dwMaxChildren,
                                         CDialog*   pQueryStatus,
                                         BOOL*      pFilters, 
                                         DWORD      dwFilters )
{
   HRESULT                          hResult;
   IADsFileService*               pIOleDsFileService   = NULL;
   IADsFileServiceOperations*     pIFServOper       = NULL;
   IADsCollection*                pICollFShares  = NULL;
   IADsCollection*                pICollSessions = NULL;
   IADsCollection*                pICollRes      = NULL;
   IADsContainer*                 pIContainer    = NULL;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsFileService, 
                                       (void**) &pIOleDsFileService );
   hResult  = m_pIUnk->QueryInterface( IID_IADsFileServiceOperations, 
                                       (void**) &pIFServOper );

   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
      return 0L;
   hResult  = pIOleDsFileService->QueryInterface( IID_IADsContainer, 
                                          (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      pIOleDsFileService->Release( );

      return 0L;
   }
   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   hResult  = pIFServOper->Sessions ( &pICollSessions );
   hResult  = pIFServOper->Resources( &pICollRes      );

   if( NULL != pICollFShares )
   {
      COleDsObject::GetChildren( pICollFShares );
      pICollFShares->Release( );
   }
   if( NULL != pICollSessions )
   {
      COleDsObject::GetChildren( pICollSessions );
      pICollSessions->Release( );
   }
   if( NULL != pICollRes )
   {
      COleDsObject::GetChildren( pICollRes );
      pICollRes->Release( );
   }
   pIFServOper->Release( );
   pIOleDsFileService->Release( );

   return m_dwCount;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsFileService::DeleteItem( COleDsObject* pObject )
{
   DWORD                         dwType;
   HRESULT                       hResult;
   CString                       strQualifiedName;
   CString                       strItemType;
   CString                       strDeleteName;
   CDeleteGroupItem              aDeleteItem;
   IADsCollection*             pIColl      = NULL;
   IADsFileService*            pIFServ     = NULL;

   
   hResult  = m_pIUnk->QueryInterface( IID_IADsFileService, (void**)&pIFServ );
   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      return E_FAIL;
   }

   dwType   = pObject->GetType( );

   switch( dwType )
   {
      case  FILESHARE:
      {
         return ContainerDeleteItem( pObject );
      }

      case  SESSION:
      {
         IADsFileServiceOperations*  pIOper   = NULL;

         hResult  = pIFServ->QueryInterface( IID_IADsFileServiceOperations, (void**)&pIOper );
         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
         {
            break;
         }
         hResult  = pIOper->Sessions( &pIColl );
         pIOper->Release( );
         break;
      }

      case  RESOURCE:
      {
         IADsFileServiceOperations*  pIOper   = NULL;

         hResult  = pIFServ->QueryInterface( IID_IADsFileServiceOperations, (void**)&pIOper );
         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
         {
            break;
         }
         hResult  = pIOper->Resources( &pIColl );
         pIOper->Release( );
         break;
      }

      default:
         ASSERT( FALSE );
         return E_FAIL;
   }
   
   if( NULL != pIColl )
   {
      strDeleteName  = pObject->GetDeleteName( );   
      MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );

      strItemType = pObject->GetClass( ); 

      aDeleteItem.m_strItemName  = strDeleteName;
      aDeleteItem.m_strParent    = strQualifiedName;
      aDeleteItem.m_strItemType  = strItemType;
      if( aDeleteItem.DoModal( ) == IDOK )
      {
         VARIANT  var;

         VariantInit( &var );
         V_VT( &var )   = VT_BSTR;
         V_BSTR( &var ) = AllocBSTR( aDeleteItem.m_strItemName.GetBuffer( 128 ) );
         hResult        = pIColl->Remove( V_BSTR( &var ) );
         VariantClear( &var );
      }
      pIColl->Release( );
   }

   pIFServ->Release( );

   return hResult;   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsFileService::AddItem( )
{
   return ContainerAddItem( );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsFileService::MoveItem( )
{
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsFileService::CopyItem( )
{
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cfshare.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileShare::COleDsFileShare( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileShare::COleDsFileShare( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsFileShare::~COleDsFileShare( )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cfshare.h ===
#ifndef  _CFILESHARE_H_
#define  _CFILESHARE_H_

class COleDsFileShare: public COleDsObject
{

public:   
   COleDsFileShare( IUnknown* );
   COleDsFileShare( );
   ~COleDsFileShare( );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cdomain.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "objects.h"
#include "maindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsDomain::COleDsDomain( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsDomain::COleDsDomain( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren       = TRUE;
   m_bSupportAdd        = TRUE;
   m_bSupportMove       = TRUE;
   m_bSupportCopy       = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsDomain::~COleDsDomain( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsDomain::GetChildren( DWORD*     pTokens, 
                                    DWORD      dwMaxChildren,
                                    CDialog*   pQueryStatus,
                                    BOOL*      pFilters, 
                                    DWORD      dwFilters )
{
   HRESULT           hResult;
   IADsContainer*  pIContainer;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, 
                                       (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   return m_dwCount;
}

  
   
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsDomain::DeleteItem( COleDsObject* pObject )
{
   return ContainerDeleteItem( pObject );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsDomain::AddItem( )
{
   return ContainerAddItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsDomain::MoveItem( )
{
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsDomain::CopyItem( )
{
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cgeneric.h ===
#ifndef  _CGENERIC_H_
#define  _CGENERIC_H_

class COleDsGeneric: public COleDsObject
{

public:   
   COleDsGeneric( IUnknown* );
   COleDsGeneric( );
   ~COleDsGeneric( );

//   void      SetClass   ( CClass*   );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );

public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cgeneric.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "objects.h"
#include "maindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGeneric::COleDsGeneric( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGeneric::COleDsGeneric( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   BOOL              bContainer;
   IADsContainer*  pContainer;
   HRESULT           hResult;

   hResult  = pIUnk->QueryInterface( IID_IADsContainer, (void**)&pContainer );
   bContainer  = SUCCEEDED( hResult );

   if( SUCCEEDED( hResult ) )
      pContainer->Release( );

   m_bHasChildren       = bContainer;
   m_bSupportAdd        = bContainer;
   m_bSupportMove       = bContainer;
   m_bSupportCopy       = bContainer;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
/*void  COleDsGeneric::SetClass( CClass* pClass )
{
   
   /*CString  strContainer;

   strContainer   = pClass->GetAttribute( ca_Container );
   if( strContainer == _T("YES") || strContainer == _T("Yes") )
   {
      m_bHasChildren       = TRUE;
      m_bSupportAdd        = TRUE;
      m_bSupportMove       = TRUE;
      m_bSupportCopy       = TRUE;   
   } 

   COleDsObject::SetClass( pClass );
} */


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGeneric::~COleDsGeneric( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsGeneric::GetChildren( DWORD*     pTokens, 
                                     DWORD      dwMaxChildren,
                                     CDialog*   pQueryStatus,
                                     BOOL*      pFilters, 
                                     DWORD      dwFilters )
{
   HRESULT           hResult;
   IADsContainer*  pIContainer;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }

   if( !m_bHasChildren )
      return 0L;
   

   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, 
                                       (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   return m_dwCount;
}
  
   
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGeneric::DeleteItem( COleDsObject* pObject )
{
   if( !m_bHasChildren )
      return E_FAIL;

   return ContainerDeleteItem( pObject );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGeneric::AddItem( )
{
   if( !m_bHasChildren )
      return E_FAIL;
   return ContainerAddItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGeneric::MoveItem( )
{
   if( !m_bHasChildren )
      return E_FAIL;
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGeneric::CopyItem( )
{
   if( !m_bHasChildren )
      return E_FAIL;
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cgroup.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"
#include "resource.h"
#include "grpcrtit.h"
#include "delgrpit.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGroup::COleDsGroup( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGroup::COleDsGroup( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   BOOL              bContainer;
   IADsContainer*    pContainer;
   HRESULT           hResult;

   hResult  = pIUnk->QueryInterface( IID_IADsContainer, (void**)&pContainer );
   bContainer  = SUCCEEDED( hResult );

   if( SUCCEEDED( hResult ) )
      pContainer->Release( );

   m_bHasChildren       = bContainer;
   m_bSupportAdd        = bContainer;
   m_bSupportMove       = bContainer;
   m_bSupportCopy       = bContainer;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsGroup::~COleDsGroup( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsGroup::GetChildren( DWORD*     pTokens, 
                                   DWORD      dwMaxChildren,
                                   CDialog*   pQueryStatus,
                                   BOOL*      pFilters, 
                                   DWORD      dwFilters )
{
   HRESULT                    hResult;
   IADsGroup*               pIGroup;
   //IOleDsGroupOperations*     pIGroupOper;
   MEMBERS*        pIMembers;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsGroup, (void**) &pIGroup );
   if( FAILED( hResult ) )
   {
      TRACE( _T("ERROR!!! Group object does not return IID_IADsGroup interface\n") );
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   
   //hResult  = pIGroup->QueryInterface( IID_IADsGroupOperations, (void**)&pIGroupOper );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = pIGroup->Members( &pIMembers );
      if( SUCCEEDED( hResult ) )
      {
         COleDsObject::GetChildren( pIMembers );
         pIMembers->Release( );
      }
      else
      {
         TRACE( _T("ERROR!!! Members fails for Group object\n") );
      }

      //pIGroupOper->Release( );
   }
   else
   {
      TRACE( _T("ERROR!!! GeneralInfo fails for Group object\n") );
   }
   
   pIGroup->Release( );

   return m_dwCount;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGroup::DeleteItem  ( COleDsObject* pObject )
{
   return ContainerDeleteItem( pObject );
   
   CDeleteGroupItem           aDeleteItem;
   BSTR                       bstrName;
   //IOleDsGroupOperations*     pIGroupOperations = NULL;
   IADsGroup*               pIGroup           = NULL;
   HRESULT                    hResult;
   CString                    strFullName;
   CString                    strQualifiedName;
   CString                    strItemType;

   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   
   strFullName = pObject->GetOleDsPath( );
   strItemType = pObject->GetClass( );

   aDeleteItem.m_strItemName  = strFullName;
   aDeleteItem.m_strParent    = strQualifiedName;
   aDeleteItem.m_strItemType  = strItemType;

   if( aDeleteItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   while( TRUE )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsGroup, 
                                          (void**)&pIGroup );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         break;
      }

      //hResult  = m_pIUnk->QueryInterface( IID_IADsGroupOperations, 
      //                                    (void**)&pIGroupOperations );
      //ASSERT( SUCCEEDED( hResult ) );
      //if( FAILED( hResult ) )
      //{
      //   break;
      //}

      bstrName = AllocBSTR( aDeleteItem.m_strItemName.GetBuffer( 128 ) );
      //hResult  = pIGroupOperations->Remove( bstrName );
      hResult  = pIGroup->Remove( bstrName );
      SysFreeString( bstrName );

      break;
   }

   //if( NULL != pIGroupOperations )
   //{
   //   pIGroupOperations->Release( );
   //}

   if( NULL != pIGroup )
   {
      pIGroup->Release( );
   }

   return hResult;   

}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsGroup::AddItem( )
{

   return ContainerAddItem( );

   CGroupCreateItem           aCreateItem;
   BSTR                       bstrName;
   //IOleDsGroupOperations*     pIGroupOperations = NULL;
   IADsGroup*               pIGroup           = NULL;
   HRESULT                    hResult;
   CString                    strQualifiedName;

   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   aCreateItem.m_strParent    = strQualifiedName;
   aCreateItem.m_strItemType  = _T("NA");

   if( aCreateItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   bstrName  = AllocBSTR( aCreateItem.m_strNewItemName.GetBuffer(128) );

   while( TRUE )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsGroup, (void**)&pIGroup );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         break;
      }

      //hResult  = m_pIUnk->QueryInterface( IID_IADsGroupOperations, (void**)&pIGroupOperations );
      //ASSERT( SUCCEEDED( hResult ) );
      //if( FAILED( hResult ) )
      //{
      //   break;
      //}

      hResult  = pIGroup->Add( bstrName );
      break;
   }

   SysFreeString( bstrName );

   //if( NULL != pIGroupOperations )
   //{
   //   pIGroupOperations->Release( );
   //}

   if( NULL != pIGroup )
   {
      pIGroup->Release( );
   }

   return hResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cgroup.h ===
#ifndef  _CGROUP_H_
#define  _CGROUP_H_

class COleDsGroup: public COleDsObject
{

public:   
   COleDsGroup( IUnknown* );
   COleDsGroup( );
   ~COleDsGroup( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );


public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cnmsp.h ===
#ifndef  _CNAMESPACE_H_
#define  _CNAMESPACE_H_

class COleDsNamespace: public COleDsObject
{

public:   
   COleDsNamespace( IUnknown* );
   COleDsNamespace( );
   ~COleDsNamespace( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );

public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cnmsp.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "objects.h"
#include "maindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespace::COleDsNamespace( )
{
   m_bHasChildren       = TRUE;
   m_bSupportAdd        = TRUE;
   m_bSupportMove       = TRUE;
   m_bSupportCopy       = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespace::COleDsNamespace( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren       = TRUE;
   m_bSupportAdd        = TRUE;
   m_bSupportMove       = TRUE;
   m_bSupportCopy       = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespace::~COleDsNamespace( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsNamespace::GetChildren( DWORD*     pTokens, 
                                       DWORD      dwMaxChildren,
                                       CDialog*   pQueryStatus,
                                       BOOL*      pFilters, 
                                       DWORD      dwFilters )
{
   HRESULT           hResult;
   IADsContainer*  pIContainer;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, 
                                       (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   return m_dwCount;
}

  
   
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespace::DeleteItem( COleDsObject* pObject )
{
   return ContainerDeleteItem( pObject );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespace::AddItem( )
{
   return ContainerAddItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespace::MoveItem( )
{
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespace::CopyItem( )
{
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cnmsps.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "objects.h"
#include "maindoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespaces::COleDsNamespaces( )
{
   m_bHasChildren       = TRUE;
   m_bSupportAdd        = TRUE;
   m_bSupportMove       = TRUE;
   m_bSupportCopy       = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespaces::COleDsNamespaces( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren       = TRUE;
   m_bSupportAdd        = TRUE;
   m_bSupportMove       = TRUE;
   m_bSupportCopy       = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNamespaces::~COleDsNamespaces( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsNamespaces::GetChildren( DWORD*     pTokens, 
                                        DWORD      dwMaxChildren,
                                        CDialog*   pQueryStatus,
                                        BOOL*      pFilters, 
                                        DWORD      dwFilters )
{
   HRESULT           hResult;
   IADsContainer*  pIContainer;

   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }
   
   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, 
                                       (void**) &pIContainer );

   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   COleDsObject::GetChildren( pIContainer );

   pIContainer->Release( );

   return m_dwCount;
}

  
   
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespaces::DeleteItem( COleDsObject* pObject )
{
   return ContainerDeleteItem( pObject );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespaces::AddItem( )
{
   return ContainerAddItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespaces::MoveItem( )
{
   return ContainerMoveItem( );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNamespaces::CopyItem( )
{
   return ContainerCopyItem( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cnmsps.h ===
#ifndef  _CNAMESPACES_H_
#define  _CNAMESPACES_H_

class COleDsNamespaces: public COleDsObject
{

public:   
   COleDsNamespaces( IUnknown* );
   COleDsNamespaces( );
   ~COleDsNamespaces( );

   HRESULT  DeleteItem  ( COleDsObject* );
   HRESULT  AddItem     (               );
   HRESULT  MoveItem    (               );
   HRESULT  CopyItem    (               );
public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\colldlg.h ===
// colldlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCollectionDialog dialog

class CCollectionDialog : public CDialog
{
// Construction
public:
	CCollectionDialog(CWnd* pParent = NULL);   // standard constructor
   ~CCollectionDialog( );   // standard destructor

// Dialog Data
	//{{AFX_DATA(CCollectionDialog)
	enum { IDD = IDD_COLLECTION };
	CStatic	m_strParent;
	CStatic	m_strItemType;
	CStatic	m_strItemOleDsPath;
	CListBox	m_ItemsList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCollectionDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCollectionDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeItemCollection();
	afx_msg void OnAdd();
	afx_msg void OnRefresh();
	afx_msg void OnRemove();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

public:
   void  SetCollectionInterface  ( IADsCollection* );
   void  SetMembersInterface     ( IADsMembers* );
   void  SetGroup                ( IADsGroup* );
   void  DisplayActiveItemData   ( void );
   void  BuildStrings            ( void );

protected:
   IADsCollection*   m_pCollection;
   IADsMembers*      m_pMembers;
   IADsGroup*        m_pGroup;
   CStringArray      m_Paths;
   CStringArray      m_Types;
   CStringArray      m_Names;
   int               m_nSelectedItem;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\colldlg.cpp ===
// colldlg.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "colldlg.h"
#include "delgrpit.h"
#include "grpcrtit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCollectionDialog dialog


CCollectionDialog::CCollectionDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CCollectionDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCollectionDialog)
	//}}AFX_DATA_INIT

   m_pCollection     = NULL;
   m_pMembers        = NULL;
   m_pGroup          = NULL;
   m_nSelectedItem   = -1;
}

CCollectionDialog::~CCollectionDialog( )
{
   m_Paths.RemoveAll( );
   m_Types.RemoveAll( );
   m_Names.RemoveAll( );
   if( NULL != m_pGroup && NULL != m_pMembers )
   {
      m_pMembers->Release( );
   }
}


void CCollectionDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCollectionDialog)
	DDX_Control(pDX, IDC_ITEMTYPE, m_strItemType);
	DDX_Control(pDX, IDC_ITEMOLEDSPATH, m_strItemOleDsPath);
	DDX_Control(pDX, IDC_COLLECTONITEMSLIST, m_ItemsList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCollectionDialog, CDialog)
	//{{AFX_MSG_MAP(CCollectionDialog)
	ON_LBN_SELCHANGE(IDC_COLLECTONITEMSLIST, OnSelchangeItemCollection)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
	ON_BN_CLICKED(IDC_REMOVE, OnRemove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCollectionDialog message handlers


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CCollectionDialog::SetCollectionInterface( IADsCollection* pICollection )
{
   m_pCollection   = pICollection;

   BuildStrings( );
}


/***********************************************************
  Function:    CCollectionDialog::SetGroup
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CCollectionDialog::SetGroup( IADsGroup* pGroup )
{
   HRESULT  hResult;

   ASSERT( NULL == m_pMembers );

   hResult  = pGroup->Members( &m_pMembers );
   BuildStrings( );

   m_pGroup = pGroup;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CCollectionDialog::SetMembersInterface( IADsMembers* pIMembers )
{
   m_pMembers   = pIMembers;

   BuildStrings( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CCollectionDialog::DisplayActiveItemData( )
{
   if( m_Types.GetSize( ) )
   {
      m_strItemType.SetWindowText( m_Types[ m_nSelectedItem ] );
      m_strItemOleDsPath.SetWindowText( m_Paths[ m_nSelectedItem ] );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CCollectionDialog::BuildStrings( )
{
   IUnknown*      pIEnum      = NULL;
   IEnumVARIANT*  pIEnumVar   = NULL;
   HRESULT        hResult;
   VARIANT        var;
   IADs*        pIOleDs     = NULL;
   BSTR           bstrPath;
   BSTR           bstrName;
   BSTR           bstrClass;
   ULONG          ulFetch;
   TCHAR          szTemp[ 1024 ];

   m_Paths.RemoveAll( );
   m_Names.RemoveAll( );
   m_Types.RemoveAll( );

   while( TRUE )
   {
      if( NULL != m_pCollection )
      {
         hResult  = m_pCollection->get__NewEnum( &pIEnum );
         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
            break;
      }
      else
      {
         hResult  = m_pMembers->get__NewEnum( &pIEnum );
         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
            break;
      }

      hResult  = pIEnum->QueryInterface( IID_IEnumVARIANT,
                                         (void**)&pIEnumVar );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      VariantInit( &var );

      hResult  = pIEnumVar->Next( 1, &var, &ulFetch );
      while( ulFetch )
      {
         hResult  = V_DISPATCH( &var )->QueryInterface( IID_IADs,
                                                        (void**)&pIOleDs );
         VariantClear( &var );

         ASSERT( SUCCEEDED( hResult ) );


         bstrPath    = NULL;
         bstrName    = NULL;
         bstrClass   = NULL;

         hResult     = pIOleDs->get_ADsPath( &bstrPath );
         ASSERT( SUCCEEDED( hResult ) );

         hResult     = pIOleDs->get_Name( &bstrName );
         ASSERT( SUCCEEDED( hResult ) );

         hResult     = pIOleDs->get_Class( &bstrClass );
         ASSERT( SUCCEEDED( hResult ) );

         _tcscpy( szTemp, _T("NA") );
         if( bstrName )
         {
            _tcscpy( szTemp, _T("") );
            StringCat( szTemp, bstrName );
         }
         m_Names.Add( szTemp );

         _tcscpy( szTemp, _T("NA") );
         if( bstrClass )
         {
            _tcscpy( szTemp, _T("") );
            StringCat( szTemp, bstrClass );
         }
         m_Types.Add( szTemp );

         _tcscpy( szTemp, _T("NA") );
         if( bstrPath )
         {
            _tcscpy( szTemp, _T("") );
            StringCat( szTemp, bstrPath );
         }
         m_Paths.Add( szTemp );

         pIOleDs->Release( );
         SysFreeString( bstrPath );
         bstrPath = NULL;

         SysFreeString( bstrName );
         bstrName = NULL;

         SysFreeString( bstrClass );
         bstrClass   = NULL;


         hResult  = pIEnumVar->Next( 1, &var, &ulFetch );
      }
      pIEnumVar->Release( );
      pIEnum->Release( );

      break;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CCollectionDialog::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

   if( NULL == m_pGroup && NULL == m_pCollection  )
   {
      GetDlgItem( IDC_ADD )->EnableWindow( FALSE );
      GetDlgItem( IDC_REMOVE )->EnableWindow( FALSE );
   }

   if( m_pCollection != NULL || m_pMembers != NULL )
   {
      int   nItems, nIdx;

      nItems   = (int)m_Paths.GetSize( );
      for( nIdx = 0; nIdx < nItems ; nIdx++ )
      {
         m_ItemsList.AddString( m_Names[ nIdx ] );
      }
      m_nSelectedItem   = 0;
      m_ItemsList.SetCurSel( 0 );
      DisplayActiveItemData( );
   }


	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CCollectionDialog::OnSelchangeItemCollection()
{
	// TODO: Add your control notification handler code here
	int   nSelected;

   nSelected   = m_ItemsList.GetCurSel( );
   if( nSelected != m_nSelectedItem )
   {
      m_nSelectedItem = nSelected;
      DisplayActiveItemData( );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CCollectionDialog::OnAdd()
{
	// TODO: Add your control notification handler code here
   CGroupCreateItem*    m_pAddItem;

   if( NULL == m_pGroup )
      return;


   m_pAddItem  = new CGroupCreateItem;

   if( IDOK == m_pAddItem->DoModal( ) )
   {
      BSTR     bstrName;
      HRESULT  hResult;

      bstrName = AllocBSTR( m_pAddItem->m_strNewItemName.GetBuffer( 512 ) );
      hResult  = m_pGroup->Add( bstrName );
      SysFreeString( bstrName );

      MessageBox( (LPCTSTR)OleDsGetErrorText( hResult ), _T("Add") );

      OnRefresh( );

      if( SUCCEEDED( hResult ) )
      {
         m_ItemsList.SelectString( 0, m_pAddItem->m_strNewItemName );
      }
   }

   delete m_pAddItem;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CCollectionDialog::OnRefresh()
{
	// TODO: Add your control notification handler code here
   int   nItems, nIdx;


   if( NULL == m_pGroup )
      return;

   if( NULL != m_pMembers )
   {
      m_pMembers->Release( );
      m_pMembers  = NULL;
   }

   m_pGroup->GetInfo( );

   SetGroup( m_pGroup );

   nItems   = (int)m_Paths.GetSize( );

   m_ItemsList.ResetContent( );

   for( nIdx = 0; nIdx < nItems ; nIdx++ )
   {
      m_ItemsList.AddString( m_Names[ nIdx ] );
   }

   m_nSelectedItem   = 0;
   m_ItemsList.SetCurSel( 0 );
   DisplayActiveItemData( );
}


/***********************************************************
  Function:    CCollectionDialog::OnRemove
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CCollectionDialog::OnRemove()
{
	// TODO: Add your control notification handler code here
	int               nSelect;
   CDeleteGroupItem* m_pDeleteItem;

   if( NULL == m_pGroup )
      return;

   nSelect  = m_ItemsList.GetCurSel( );

   if( LB_ERR == nSelect )
      return;

   m_pDeleteItem  = new CDeleteGroupItem;

   m_pDeleteItem->m_strItemName  = m_Paths[ nSelect ];
	//CString	m_strParent;
	m_pDeleteItem->m_strItemType  = m_Types[ nSelect ];

   if( IDOK == m_pDeleteItem->DoModal( ) )
   {
      BSTR     bstrName;
      HRESULT  hResult;

      bstrName = AllocBSTR( m_pDeleteItem->m_strItemName.GetBuffer( 512 ) );
      hResult  = m_pGroup->Remove( bstrName );
      SysFreeString( bstrName );

      MessageBox( (LPCTSTR)OleDsGetErrorText( hResult ), _T("Remove") );

      OnRefresh( );
   }

   delete m_pDeleteItem;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\copyitem.cpp ===
// CopyItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "CopyItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCopyItem dialog


CCopyItem::CCopyItem(CWnd* pParent /*=NULL*/)
	: CDialog(CCopyItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCopyItem)
	m_strDestination = _T("");
	m_strParent = _T("");
	m_strSource = _T("");
	//}}AFX_DATA_INIT
}


void  CCopyItem::SetContainerName( CString strParent )
{
   m_strParent = strParent;
}

void CCopyItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCopyItem)
	DDX_Text(pDX, IDC_DESTINATION, m_strDestination);
	DDX_Text(pDX, IDC_PARENT, m_strParent);
	DDX_Text(pDX, IDC_SOURCE, m_strSource);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCopyItem, CDialog)
	//{{AFX_MSG_MAP(CCopyItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCopyItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\copyitem.h ===
// CopyItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCopyItem dialog

class CCopyItem : public CDialog
{
// Construction
public:
	CCopyItem(CWnd* pParent = NULL);   // standard constructor

public:
   void  SetContainerName( CString );

// Dialog Data
	//{{AFX_DATA(CCopyItem)
	enum { IDD = IDD_COPYITEM };
	CString	m_strDestination;
	CString	m_strParent;
	CString	m_strSource;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCopyItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCopyItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cpdevice.h ===
#ifndef  _PRINTDEVICE_H_
#define  _PRINTDEVICE_H_

class COleDsPrintDevice: public COleDsObject
{

public:   
   COleDsPrintDevice( IUnknown* );
   COleDsPrintDevice( );
   ~COleDsPrintDevice( );

public:
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cpjob.h ===
#ifndef  _CPRINTJOB_H_
#define  _CPRINTJOB_H_

class COleDsPrintJob: public COleDsObject
{

public:   
   COleDsPrintJob( IUnknown* );
   COleDsPrintJob( );
   ~COleDsPrintJob( );

   virtual  HRESULT  ReleaseIfNotTransient( void               );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cpdevice.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintDevice::COleDsPrintDevice( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintDevice::COleDsPrintDevice( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintDevice::~COleDsPrintDevice( )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cpqueue.h ===
#ifndef  _PRINTQUEUE_H_
#define  _PRINTQUEUE_H_

class COleDsPrintQueue: public COleDsObject
{

public:   
   COleDsPrintQueue( IUnknown* );
   COleDsPrintQueue( );
   ~COleDsPrintQueue( );

   HRESULT  DeleteItem  ( COleDsObject* );

public:
   DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                         CDialog*   pQueryStatus,
                         BOOL*      pFilters, DWORD dwFilters );


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cpjob.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintJob::COleDsPrintJob( )
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintJob::COleDsPrintJob( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintJob::~COleDsPrintJob( )
{

}
  

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsPrintJob::ReleaseIfNotTransient( void )
{
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\createit.cpp ===
// CreateItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "createit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateItem dialog


CCreateItem::CCreateItem(CWnd* pParent /*=NULL*/)
	: CDialog(CCreateItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CCreateItem)
	m_strClass = _T("");
	m_strRelativeName = _T("");
	m_strParent = _T("");
	//}}AFX_DATA_INIT
}


void CCreateItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCreateItem)
	DDX_Control(pDX, IDC_RELATIVENAME, m_RelativeName);
	DDX_Control(pDX, IDC_CLASS, m_Class);
	DDX_Text(pDX, IDC_CLASS, m_strClass);
	DDX_Text(pDX, IDC_RELATIVENAME, m_strRelativeName);
	DDX_Text(pDX, IDC_PARENTNAME, m_strParent);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreateItem, CDialog)
	//{{AFX_MSG_MAP(CCreateItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreateItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cresourc.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsResource::COleDsResource( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsResource::COleDsResource( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsResource::~COleDsResource( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsResource::ReleaseIfNotTransient( void )
{
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\createit.h ===
// CreateItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCreateItem dialog

class CCreateItem : public CDialog
{
// Construction
public:
	CCreateItem(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CCreateItem)
	enum { IDD = IDD_CREATEITEM };
	CEdit	m_RelativeName;
	CEdit	m_Class;
	CString	m_strClass;
	CString	m_strRelativeName;
	CString	m_strParent;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreateItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CCreateItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cpqueue.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"
#include "resource.h"
#include "grpcrtit.h"
#include "delgrpit.h"



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintQueue::COleDsPrintQueue( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintQueue::COleDsPrintQueue( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsPrintQueue::~COleDsPrintQueue( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsPrintQueue::GetChildren( DWORD*     pTokens, 
                                        DWORD      dwMaxChildren,
                                        CDialog*   pQueryStatus,
                                        BOOL*      pFilters, 
                                        DWORD      dwFilters )
{
   HRESULT                       hResult;
   IADsPrintQueue*             pIOleDsPrintQueue = NULL;
   IADsCollection*             pIJobs            = NULL;
   IADsPrintQueueOperations*   pIPQueueOper      = NULL;

   
   if( m_strOleDsPath[ 4 ] == _T(':') )
   {
      // the wort way to find if this is "LDAP:"
      // SWilson (NT) needs this 
      return 0L;
   }

   
   if( NULL == m_pIUnk )
   {
      ASSERT( FALSE );
      return 0L;
   }

   COleDsObject::GetChildren( pTokens, dwMaxChildren, pQueryStatus, 
                              pFilters, dwFilters );

   hResult  = m_pIUnk->QueryInterface( IID_IADsPrintQueue, 
                                       (void**) &pIOleDsPrintQueue );
   if( FAILED( hResult ) )
   {
      TRACE( _T("ERROR: QueryInterface for IID_IADsPrintQueue failed\n") );
   }
   else
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsPrintQueueOperations, 
                                       (void**) &pIPQueueOper );
      
      if( FAILED( hResult ) )
      {
         TRACE( _T("ERROR: QueryInterface for IID_IADsPrintQueueOperations failed\n") );
      }
      else
      {
         hResult  = pIPQueueOper->PrintJobs( &pIJobs );

         if( NULL != pIJobs )
         {
            COleDsObject::GetChildren( pIJobs );
            pIJobs->Release( );
         }
         pIPQueueOper->Release( );
      }
      pIOleDsPrintQueue->Release( );
   }

   return m_dwCount;
}
  

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsPrintQueue::DeleteItem  ( COleDsObject* pObject )
{
   DWORD                         dwType;
   HRESULT                       hResult;
   CString                       strQualifiedName;
   CString                       strItemType;
   CString                       strDeleteName;
   CDeleteGroupItem              aDeleteItem;
   IADsCollection*             pIColl      = NULL;
   IADsPrintQueue*             pIPQueue    = NULL;
   BOOL                          bSuccess = FALSE;

   
   hResult  = m_pIUnk->QueryInterface( IID_IADsPrintQueue, (void**)&pIPQueue );
   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      return E_FAIL;
   }

   dwType   = pObject->GetType( );

   switch( dwType )
   {
      case  PRINTJOB:
      {
         IADsPrintQueueOperations*  pIOper   = NULL;

         hResult  = pIPQueue->QueryInterface( IID_IADsPrintQueueOperations, (void**)&pIOper );
         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
         {
            break;
         }
         hResult  = pIOper->PrintJobs( &pIColl );
         pIOper->Release( );
         bSuccess = TRUE;
         break;
      }


      default:
         ASSERT( FALSE );
         return E_FAIL;
   }
   
   if( bSuccess )
   {
      strDeleteName  = pObject->GetDeleteName( );   
      MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );

      strItemType = pObject->GetClass( ); 

      aDeleteItem.m_strItemName  = strDeleteName;
      aDeleteItem.m_strParent    = strQualifiedName;
      aDeleteItem.m_strItemType  = strItemType;
      if( aDeleteItem.DoModal( ) == IDOK )
      {
         VARIANT  var;

         VariantInit( &var );
         V_VT( &var )   = VT_BSTR;
         V_BSTR( &var ) = AllocBSTR( aDeleteItem.m_strItemName.GetBuffer( 128 ) );
         if( NULL != pIColl )
         {
            hResult  = pIColl->Remove( V_BSTR(&var) );
         }
         VariantClear( &var );
      }

      if( NULL != pIColl )
      {
         ULONG ulRef;

         ulRef = pIColl->Release( );
         if( ulRef )
         {
            TRACE( _T("ERROR: Release on PrintJob collection did not returned 0\n") );
         }
      }
   }

   pIPQueue->Release( );

   return hResult;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cservice.h ===
#ifndef  _CSERVICE_H_
#define  _CSERVICE_H_

class COleDsService: public COleDsObject
{

public:   
   COleDsService( IUnknown* );
   COleDsService( );
   ~COleDsService( );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cresourc.h ===
#ifndef  _CRESOURCE_H_
#define  _CRESOURCE_H_

class COleDsResource: public COleDsObject
{

public:   
   COleDsResource( IUnknown* );
   COleDsResource( );
   ~COleDsResource( );

   virtual  HRESULT  ReleaseIfNotTransient( void               );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cservice.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsService::COleDsService( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsService::COleDsService( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsService::~COleDsService( )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\csession.h ===
#ifndef  _CSESSION_H_
#define  _CSESSION_H_

class COleDsSession: public COleDsObject
{

public:   
   COleDsSession( IUnknown* );
   COleDsSession( );
   ~COleDsSession( );

   CString  GetDeleteName        ( );

public:
   HRESULT  ReleaseIfNotTransient( void  );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cuser.h ===
#ifndef  _CUSER_H_
#define  _CUSER_H_

class COleDsUser: public COleDsObject
{

   public:   
      COleDsUser( IUnknown* );
      COleDsUser( );
      ~COleDsUser( );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\csyntax.h ===
#ifndef  _CSYNTAX_H_
#define  _CSYNTAX_H_

class COleDsSyntax: public CObject
{
   public:   
      COleDsSyntax( );

   public:
      virtual  CString  VarToDisplayString( VARIANT&, BOOL bMultiValued, BOOL bUseGetEx );
      virtual  BOOL     DisplayStringToDispParams( CString&, DISPPARAMS&, BOOL bMultiValued, BOOL bUseGetEx );
      virtual  CString  VarToDisplayStringEx( VARIANT&, BOOL bMultiValued );
      virtual  BOOL     DisplayStringToDispParamsEx( CString&, DISPPARAMS&, BOOL bMultiValued );

      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );
      virtual  void      FreeAttrValue ( ADSVALUE* );
      
      void     FreeAttrInfo            ( ADS_ATTR_INFO* );  
      HRESULT  Native2Value            ( ADS_ATTR_INFO*, CString& );
      HRESULT  Value2Native            ( ADS_ATTR_INFO*, CString& );

   public:
      DWORD    m_dwSyntaxID;
   protected:
      CString  GetValueByIndex         ( CString&, TCHAR, DWORD );
      DWORD    GetValuesCount          ( CString&, TCHAR );

   protected:
      VARTYPE  m_lType;
      

};

class COleDsBSTR: public COleDsSyntax
{
   public:   
      COleDsBSTR( );

   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );
      virtual  void      FreeAttrValue ( ADSVALUE* );

};


class COleDsBOOL: public COleDsSyntax
{
   public:   
      COleDsBOOL( );
   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );

};


class COleDsLONG: public COleDsSyntax
{
   public:   
      COleDsLONG( );

   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );

};

class COleDsLargeInteger: public COleDsSyntax
{
   public:   
      COleDsLargeInteger( );

   public:
      HRESULT  Native2Value  ( ADSVALUE*, CString& );
      HRESULT  Value2Native  ( ADSVALUE*, CString& );
      
      BOOL     DisplayStringToDispParams( CString&, DISPPARAMS&, BOOL, BOOL );
      BOOL     DisplayStringToDispParamsEx( CString&, DISPPARAMS&, BOOL bMultiValued );

      CString  VarToDisplayStringEx( VARIANT&, BOOL bMultiValued );
      CString  VarToDisplayString( VARIANT&, BOOL, BOOL );
};


class COleDsDATE: public COleDsSyntax
{
   public:   
      COleDsDATE( );

   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );
};


class COleDsNDSComplexType: public COleDsSyntax
{
   public:
      COleDsNDSComplexType            ( );

      CString  VarToDisplayString         ( VARIANT&, BOOL, BOOL        );
      BOOL     DisplayStringToDispParams  ( CString&, DISPPARAMS&, BOOL, BOOL );
      CString  VarToDisplayStringEx       ( VARIANT&, BOOL bMultiValued );
      BOOL     DisplayStringToDispParamsEx( CString&, DISPPARAMS&, BOOL bMultiValued );

   private:
      virtual  HRESULT  String_2_VARIANT( TCHAR*, VARIANT& ) = 0;
      virtual  HRESULT  VARIANT_2_String( TCHAR*, VARIANT& ) = 0;
};


class COleDsNDSTimeStamp: public COleDsNDSComplexType
{
   public:
      COleDsNDSTimeStamp            ( );

      HRESULT  Native2Value               ( ADSVALUE*, CString&         );
      HRESULT  Value2Native               ( ADSVALUE*, CString&         );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

      HRESULT  GetComponents  ( TCHAR*, DWORD*, DWORD*   );
      HRESULT  GenerateString ( TCHAR*, DWORD, DWORD     );
};


class COleDsNDSCaseIgnoreList: public COleDsNDSComplexType
{
   public:
      COleDsNDSCaseIgnoreList      ( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSOctetList: public COleDsNDSComplexType
{
   public:
      COleDsNDSOctetList      ( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};


class COleDsNDSNetAddress: public COleDsNDSComplexType
{
   public:
      COleDsNDSNetAddress      ( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSPostalAddress: public COleDsNDSComplexType
{
   public:
      COleDsNDSPostalAddress  ( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSEMail: public COleDsNDSComplexType
{
   public:
      COleDsNDSEMail( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSFaxNumber: public COleDsNDSComplexType
{
   public:
      COleDsNDSFaxNumber( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};
class COleDsNDSBackLink: public COleDsNDSComplexType
{
   public:
      COleDsNDSBackLink( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSPath: public COleDsNDSComplexType
{
   public:
      COleDsNDSPath( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};

class COleDsNDSHold: public COleDsNDSComplexType
{
   public:
      COleDsNDSHold( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};


class COleDsNDSTypedName: public COleDsNDSComplexType
{
   public:
      COleDsNDSTypedName( );

      HRESULT  Native2Value   ( ADSVALUE*, CString&  );
      HRESULT  Value2Native   ( ADSVALUE*, CString&  );
      void     FreeAttrValue  ( ADSVALUE* );

   private:
      HRESULT  String_2_VARIANT( TCHAR*, VARIANT& );
      HRESULT  VARIANT_2_String( TCHAR*, VARIANT& );

};




class COleDsVARIANT: public COleDsSyntax
{
   public:   
      COleDsVARIANT( ){};

   public:
      CString   VarToDisplayString( VARIANT&, BOOL, BOOL );
      BOOL      DisplayStringToDispParams( CString&, DISPPARAMS&, BOOL, BOOL );

   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );

};


class COleDsOctetString: public COleDsSyntax
{
   public:   
      COleDsOctetString( );

   public:
      CString  VarToDisplayString( VARIANT&, BOOL, BOOL );
      BOOL     DisplayStringToDispParams( CString&, DISPPARAMS&, BOOL, BOOL );
      CString  VarToDisplayStringEx( VARIANT&, BOOL bMultiValued );
      BOOL     DisplayStringToDispParamsEx( CString&, DISPPARAMS&, BOOL bMultiValued );

   public:
      virtual  HRESULT   Native2Value  ( ADSVALUE*, CString& );
      virtual  HRESULT   Value2Native  ( ADSVALUE*, CString& );
      virtual  void      FreeAttrValue ( ADSVALUE* );

   private:
      BYTE      GetByteValue( TCHAR* szString );

};


class COleDsCounter: public COleDsLONG
{
   public:   
      COleDsCounter( ){};
};

class COleDsNetAddress: public COleDsBSTR
{
   public:   
      COleDsNetAddress( ){};
};

class COleDsOleDsPath: public COleDsBSTR
{
   public:
      COleDsOleDsPath( ){};
};


class COleDsEmailAddress: public COleDsBSTR
{
   public:
      COleDsEmailAddress( ){};
};

class COleDsInteger: public COleDsLONG
{
   public:
      COleDsInteger( ){};
};


class COleDsInterval: public COleDsLONG
{
   public:
      COleDsInterval( ){};
};

class COleDsList: public COleDsVARIANT
{
   public:
      COleDsList( ){};
};

class COleDsString: public COleDsBSTR
{
   public:
      COleDsString( ){ };
};


COleDsSyntax*  GetSyntaxHandler( ADSTYPE eType, CString& rText );
COleDsSyntax*  GetSyntaxHandler( WCHAR* pszSyntax );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\csyntax.cpp ===
#include "stdafx.h"
//#include "inds.h"
#include <limits.h>
#include "ole2.h"
#include "csyntax.h"

#define  NDS_SEPARATOR     _T('&')
#define  NDS_SEPARATOR_S     _T(" & ")
#define  NDS_SEPARATOR_W   L'&'
#define  NDS_SEPARATOR_A   '&'


/***********************************************************
  Function:    GetSyntaxHandler
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSyntax*  GetSyntaxHandler( WCHAR* pszSyntax )
{
   ADSTYPE        eType;
   CString        strText;

   eType = ADsTypeFromSyntaxString( pszSyntax );

   return GetSyntaxHandler( eType, strText );
}
   

/***********************************************************
  Function:    GetSyntaxHandler
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSyntax*  GetSyntaxHandler( ADSTYPE eType, CString& rText )
{
   COleDsSyntax*  pSyntax  = NULL;

   switch( eType )
   {
      case  ADSTYPE_INVALID:
         ASSERT( FALSE );
         rText = _T("ERROR: ADSTYPE_INVALID");
         break;

      case  ADSTYPE_DN_STRING:
      case  ADSTYPE_CASE_EXACT_STRING:
      case  ADSTYPE_CASE_IGNORE_STRING:
      case  ADSTYPE_PRINTABLE_STRING:
      case  ADSTYPE_NUMERIC_STRING:
      case  ADSTYPE_OBJECT_CLASS:
         pSyntax  = new COleDsBSTR( );
         break;

      case  ADSTYPE_BOOLEAN:
         pSyntax  = new COleDsBOOL( );
         break;

      case  ADSTYPE_CASEIGNORE_LIST:
         pSyntax  = new COleDsNDSCaseIgnoreList( );
         break;

      case  ADSTYPE_OCTET_LIST:
         pSyntax  = new COleDsNDSOctetList( );
         break;

      case  ADSTYPE_PATH:
         pSyntax  = new COleDsNDSPath( );
         break;

      case  ADSTYPE_NETADDRESS:
         pSyntax  = new COleDsNDSNetAddress( );
         break;

      case  ADSTYPE_BACKLINK:
         pSyntax  = new COleDsNDSBackLink( );
         break;

      case  ADSTYPE_HOLD:
         pSyntax  = new COleDsNDSHold( );
         break;

      case  ADSTYPE_TYPEDNAME:
         pSyntax  = new COleDsNDSTypedName( );
         break;

      case  ADSTYPE_INTEGER:
         pSyntax  = new COleDsLONG( );
         break;

      case  ADSTYPE_LARGE_INTEGER:
         pSyntax  = new COleDsLargeInteger( );
         break;

      case  ADSTYPE_POSTALADDRESS:
         pSyntax  = new COleDsNDSPostalAddress( );
         break;
 
      case  ADSTYPE_OCTET_STRING:
         pSyntax  = new COleDsOctetString( );
         break;

      case  ADSTYPE_UTC_TIME:
         pSyntax  = new COleDsDATE( );
         break;

      case  ADSTYPE_TIMESTAMP:
         pSyntax  = new COleDsNDSTimeStamp;
         break;

      case  ADSTYPE_EMAIL:
         pSyntax  = new COleDsNDSEMail;
         break;

      case  ADSTYPE_FAXNUMBER:
         pSyntax  = new COleDsNDSFaxNumber;
         break;

      case  ADSTYPE_PROV_SPECIFIC:
         ASSERT( FALSE );
         rText = _T("ADSTYPE_PROV_SPECIFIC");
         break;

      default:
         ASSERT( FALSE );
         rText = _T("ERROR Unknown ADSTYPE");
         break;
   }

   return pSyntax;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSyntax::COleDsSyntax( )
{
   m_lType        = VT_BSTR;
   m_dwSyntaxID   = ADSTYPE_DN_STRING;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsSyntax::VarToDisplayStringEx( VARIANT& var, BOOL bMultiValued )
{
   VARIANT  aVar;
   HRESULT  hResult;
   CString  strText  = _T("ERROR");

   VariantInit( &aVar );
   
   if( !bMultiValued )
   {
      SAFEARRAY*  pSafeArray; 
      TCHAR       szText[ 8096 ];
      VARIANT     varString;
      long        lBound, uBound, lItem;
      CString     strResult;

      ASSERT( VT_ARRAY & V_VT(&var ) );
      
      if( !(VT_ARRAY & V_VT(&var) ) )
      {
         ERROR_HERE( szText );
      }

      else
      {
         VariantInit( &varString );

         pSafeArray  = V_ARRAY( &var );

         hResult     = SafeArrayGetLBound(pSafeArray, 1, &lBound); 
         hResult     = SafeArrayGetUBound(pSafeArray, 1, &uBound); 

         ASSERT( lBound == uBound );

         szText[ 0 ]    = _T('\0');

         lItem = lBound;
         hResult  = SafeArrayGetElement( pSafeArray, &lItem, &aVar );
         if( FAILED( hResult ) )
         {
            ASSERT(FALSE);
         }

         if( !ConvertFromPropertyValue( aVar, szText ) )
         {
            hResult  = VariantChangeType( &varString, &aVar, VARIANT_NOVALUEPROP, VT_BSTR );

            ASSERT( SUCCEEDED( hResult ) );
            if( FAILED( hResult ) )
            {
               ERROR_HERE( szText );
            }
            else
            {
               Convert( szText, V_BSTR( &varString ) );
               VariantClear( &varString );
            }
            VariantClear( &aVar );
         }
      }

      return CString( szText );
   }
   else
   {
      strText  = FromVariantArrayToString( var );
   }


   return strText;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsSyntax::VarToDisplayString( VARIANT& var, BOOL bMultiValued, BOOL bUseGetEx )
{
   VARIANT  aVar;
   HRESULT  hResult;
   CString  strText;

   // we have to use GetEx style
   if( bUseGetEx )
      return VarToDisplayStringEx( var, bMultiValued );
   
   // we're using Get
   VariantInit( &aVar );
   if( !bMultiValued )
   {
      hResult  = VariantChangeType( &aVar, &var, VARIANT_NOVALUEPROP, VT_BSTR );
      if( SUCCEEDED( hResult ) )
      {
         strText  = V_BSTR( &aVar );
      }
      else
      {
         strText  = _T("ERROR on conversion");
      }

      hResult  = VariantClear( &aVar  );
   }
   else
   {
      strText  = FromVariantArrayToString( var );
   }

   return strText;
}


/***********************************************************
  Function:    COleDsSyntax::DisplayStringToDispParamsEx
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL     COleDsSyntax::DisplayStringToDispParamsEx( CString& rText, 
                                                    DISPPARAMS& dispParams, 
                                                    BOOL bMultiValued )
{
   HRESULT  hResult;

   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   hResult  = BuildVariantArray( m_lType, rText, dispParams.rgvarg[0] );

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL     COleDsSyntax::DisplayStringToDispParams( CString& rText, DISPPARAMS& dispParams, 
                                                  BOOL bMultiValued, BOOL bUseGetEx )
{
   HRESULT  hResult;

   if( bUseGetEx )
   {
      return DisplayStringToDispParamsEx( rText, dispParams, bMultiValued );
   }
   
   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   if( bMultiValued )
   {
      hResult  = BuildVariantArray( m_lType, rText, dispParams.rgvarg[0] );
   }
   else
   {
      VARIANT  vStr;

      VariantInit( &vStr );
      VariantInit( &dispParams.rgvarg[0] );

      V_VT( &vStr )     = VT_BSTR;
      V_BSTR( &vStr )   = AllocBSTR( rText.GetBuffer( 1024 ) );

      hResult           = VariantChangeType( &dispParams.rgvarg[0], &vStr, VARIANT_NOVALUEPROP, m_lType );

      VariantClear( &vStr );

   }

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsSyntax::Native2Value( ADSVALUE* pADsObject, CString& rVal )
{
   ASSERT( FALSE );

   return E_FAIL;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsSyntax::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   ASSERT( FALSE );

   return E_FAIL;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  COleDsSyntax::FreeAttrValue ( ADSVALUE* pADsValue )
{
   return;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsSyntax::FreeAttrInfo( ADS_ATTR_INFO* pAttrInfo )
{
   DWORD dwIter;

   ASSERT( NULL != pAttrInfo->pszAttrName );
   
   FREE_MEMORY( pAttrInfo->pszAttrName );

   if( ADS_ATTR_CLEAR == pAttrInfo->dwControlCode )
      return;

   for( dwIter = 0; 
        NULL != pAttrInfo->pADsValues &&  dwIter < pAttrInfo->dwNumValues ; 
        dwIter++ )
   {
      FreeAttrValue( pAttrInfo->pADsValues + dwIter );
   }

   FREE_MEMORY( pAttrInfo->pADsValues );

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsSyntax::Native2Value( ADS_ATTR_INFO* pAttr, CString& rVal )
{
   HRESULT     hResult  = E_FAIL;
   CString     strItem;
   ADSVALUE*   pAdsValue;

   rVal.Empty( );

   while( TRUE )
   {
      ASSERT( pAttr );
      if( !pAttr )
         break;
      
      ASSERT( pAttr->pADsValues );
      if( !pAttr->pADsValues )
         break;

      for( DWORD dwIdx = 0L; dwIdx < pAttr->dwNumValues ; dwIdx++ )
      {
         if( dwIdx )
            rVal  = rVal + SEPARATOR_S;

         pAdsValue  = pAttr->pADsValues + dwIdx;
         if( ADSTYPE_INVALID != pAdsValue->dwType )
         {
            hResult  = Native2Value( pAdsValue, strItem );
         }
         else
         {
            strItem  = _T("ERROR: ADSTYPE_INVALID");
            TRACE( _T("ERROR: Got ADSTYPE_INVALID!!!\n") );
         }
         rVal        = rVal + strItem;
      }

      break;
   }

   return hResult;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsSyntax::Value2Native( ADS_ATTR_INFO* pAttr, CString& rVal )
{
   HRESULT     hResult  = E_FAIL;
   CString     strItem;
   ADSVALUE*   pCurrentADsObject;
   DWORD       dwValues;
   DWORD       dwIdx;

   pAttr->dwADsType  = (ADSTYPE)m_dwSyntaxID;
   
   while( TRUE )
   {
      ASSERT( pAttr );
      if( !pAttr )
         break;
      
      dwValues             = GetValuesCount( rVal, SEPARATOR_C );

      pAttr->dwNumValues   = dwValues;
      pAttr->pADsValues    = (ADSVALUE*)AllocADsMem( sizeof( ADSVALUE ) * dwValues );
      pCurrentADsObject    = pAttr->pADsValues;

      for( dwIdx = 0L; dwIdx < dwValues ; dwIdx++ )
      {
         strItem  = GetValueByIndex( rVal, SEPARATOR_C, dwIdx );
         pCurrentADsObject->dwType = (ADSTYPE)m_dwSyntaxID;
         hResult  = Value2Native( pCurrentADsObject, strItem );
         pCurrentADsObject++;
      }

      break;
   }

   return hResult;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
DWORD    COleDsSyntax::GetValuesCount( CString& rString, TCHAR cSeparator )
{
   DWORD dwValues;
   DWORD dwIdx;

   dwValues = 1L;
   
   for( dwIdx = 0L; dwIdx < (DWORD)rString.GetLength( ) ; dwIdx++ )
   {
      TCHAR cCurrent;

      cCurrent = rString.GetAt( dwIdx );
      if(  cCurrent == cSeparator )
      {
         dwValues++;
      }
   }

   return dwValues;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsSyntax::GetValueByIndex( CString& rVal, TCHAR cSeparator, DWORD dwIndex )
{
   DWORD    dwParsed = 0L;
   DWORD    dwIter   = 0L;
   DWORD    dwSize;
   CString  strItem;

   dwSize   = rVal.GetLength( );
   
   while( dwIter < dwSize && dwParsed < dwIndex && rVal.GetAt(dwIter) )
   {
      if( cSeparator == rVal.GetAt(dwIter++) )
         dwParsed++;
   }

   
   while( dwIter < dwSize && cSeparator != rVal.GetAt(dwIter) )
   {
      strItem += rVal.GetAt(dwIter++);
   }

   strItem.TrimLeft( );

   return strItem;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsBSTR::COleDsBSTR( )
{
   m_lType        = VT_BSTR;
   m_dwSyntaxID   = ADSTYPE_DN_STRING;
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsBSTR::Native2Value( ADSVALUE* pAdsValue, CString& rVal )
{
   TCHAR    szBuffer[ 1024 ];
   
   if( pAdsValue->DNString )
   {
      Convert( szBuffer, pAdsValue->DNString );
   }
   else
   {
      _tcscpy( szBuffer, _T("NULL value") );
   }
   rVal  = szBuffer;

   return S_OK;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsBSTR::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   LPWSTR   lpwszValue;

   lpwszValue  = (LPWSTR) AllocADsMem( sizeof(WCHAR) * ( rVal.GetLength( ) + 1 ) );
   Convert( lpwszValue, rVal.GetBuffer( 1024 ) );
   pADsObject->DNString  = lpwszValue;

   return S_OK;
}


/***********************************************************
  Function:    COleDsBSTR::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  COleDsBSTR::FreeAttrValue ( ADSVALUE* pADsValue )
{
   ASSERT( NULL != pADsValue->DNString );

   FREE_MEMORY( pADsValue->DNString );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsBOOL::COleDsBOOL( )
{
   m_lType        = VT_BOOL;
   m_dwSyntaxID   = ADSTYPE_BOOLEAN;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsBOOL::Native2Value( ADSVALUE* pADsObject, CString& rVal )
{
   BOOL     bVal;

   bVal  = pADsObject->Boolean;
   rVal  = ( bVal ? _T("1") : _T("0") );

   return S_OK;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsBOOL::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   pADsObject->Boolean = 
      rVal.Compare( _T("0") ) ? TRUE : FALSE;

   return S_OK;
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsLONG::COleDsLONG( )
{
   m_lType        = VT_I4;
   m_dwSyntaxID   = ADSTYPE_INTEGER;
}  


/***********************************************************
  Function:    COleDsLONG::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsLONG::Native2Value( ADSVALUE* pADsObject, CString& rVal )
{
   DWORD    dwVal;
   TCHAR    szText[ 16 ];

   dwVal = pADsObject->Integer;
   _ultot( dwVal, szText, 10 );
   rVal  = szText;

   return S_OK;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsLONG::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   DWORD    dwVal;

   dwVal = (DWORD)_ttol( rVal.GetBuffer( 128 ) );

   pADsObject->Integer   = dwVal ;

   return S_OK;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsLargeInteger::COleDsLargeInteger( )
{
   m_lType        = VT_I8;
   m_dwSyntaxID   = ADSTYPE_LARGE_INTEGER;
}


/******************************************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
******************************************************************************/
HRESULT   COleDsLargeInteger::Native2Value( ADSVALUE* pValue, CString& rValue)
{
   HRESULT  hResult;
   TCHAR    szValue[ 32 ];

   hResult  = LARGE_INTEGERToString( szValue, &pValue->LargeInteger );
   ASSERT( SUCCEEDED( hResult ) );

   if( SUCCEEDED( hResult ) ) 
   {
      rValue   = szValue;
   }

   return hResult;
}


/******************************************************************************
  Function:    COleDsLargeInteger::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
******************************************************************************/
HRESULT   COleDsLargeInteger::Value2Native( ADSVALUE* pValue, CString& rValue )
{
   HRESULT  hResult;

   hResult  = LARGE_INTEGERToString( rValue.GetBuffer( 128 ), &pValue->LargeInteger );

   return hResult;
}


/***********************************************************
  Function:    COleDsLargeInteger::DisplayStringToDispParamsEx
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL  COleDsLargeInteger::DisplayStringToDispParamsEx( CString& rText, 
                                                       DISPPARAMS& dispParams, 
                                                       BOOL bMultiValued )
{
   SAFEARRAY*        pSArray;
   SAFEARRAYBOUND    saBound;
   HRESULT           hResult;
   LONG              lIdx = LBOUND;

   DisplayStringToDispParams( rText, dispParams, bMultiValued, FALSE );
   
   if( !bMultiValued )
   {
      saBound.lLbound   = LBOUND;
      saBound.cElements = 1;
      pSArray           = SafeArrayCreate( VT_VARIANT, 1, &saBound );
      hResult           = SafeArrayPutElement( pSArray, &lIdx, &dispParams.rgvarg[0] );
      
      VariantClear( &dispParams.rgvarg[0] );

      V_VT( &dispParams.rgvarg[0] )    = VT_ARRAY | VT_VARIANT;
      V_ARRAY( &dispParams.rgvarg[0] ) = pSArray;
   }

   return TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL     COleDsLargeInteger::DisplayStringToDispParams( CString& rText, 
                                                        DISPPARAMS& dispParams, 
                                                        BOOL bMultiValued, 
                                                        BOOL bUseEx )
{
   HRESULT  hResult  = E_FAIL;
   int      x= 0;

  
   if( bUseEx )
   {
      return DisplayStringToDispParamsEx( rText, dispParams, bMultiValued );
   }

   
   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   if( bMultiValued )
   {
      SAFEARRAY*     psa;
      SAFEARRAYBOUND sab;
      long           lItems   = 0;
      int            lIdx;
      //SMITHA HRESULT        hResult;

      rText.MakeUpper( );

      lItems   = GetValuesCount( rText, SEPARATOR_C );

      sab.cElements   = lItems;
      sab.lLbound     = LBOUND;
      psa             = SafeArrayCreate( VT_VARIANT, 1, &sab );
      ASSERT( NULL != psa );
      if ( psa )
      {
         for( lIdx = LBOUND; lIdx < ( LBOUND + lItems ) ; lIdx++ )
         {
            VARIANT  var;
            CString  strTemp;

            strTemp  = GetValueAt( rText, SEPARATOR_C, lIdx - LBOUND );
            V_VT( &var )         = VT_DISPATCH;
            V_DISPATCH( &var )   = CreateLargeInteger( strTemp );

            hResult  = SafeArrayPutElement( psa, (long FAR *)&lIdx, &var );
            VariantClear( &var );
         }
         V_VT( &dispParams.rgvarg[0] )     = VT_VARIANT | VT_ARRAY;
         V_ARRAY( &dispParams.rgvarg[0] )  = psa;
      }
   }
   else
   {
      IDispatch*        pDisp = NULL;
      hResult  = S_OK;

      pDisp    = CreateLargeInteger( rText );

      V_VT( &dispParams.rgvarg[0] )       = VT_DISPATCH;
      V_DISPATCH( &dispParams.rgvarg[0] ) = pDisp;
   }

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsLargeInteger::VarToDisplayStringEx( VARIANT& var, 
                                                   BOOL bMultiValued )
{
   SAFEARRAY*  pSArray;
   HRESULT     hResult;
   LONG        uLow, uHigh, uIndex;
   VARIANT     vItem;
   CString     strVal;
   CString     strTemp;

   pSArray  = V_ARRAY( &var );

   hResult  = SafeArrayGetLBound( pSArray, 1, &uLow );
   hResult  = SafeArrayGetUBound( pSArray, 1, &uHigh );

   if( !bMultiValued )
   {
      ASSERT( uLow == uHigh );
   }

   for( uIndex = uLow; uIndex <= uHigh; uIndex++ )
   {
      if( uIndex != uLow )
      {
         strVal  += SEPARATOR_S;
      }

      VariantInit( &vItem );
      hResult  = SafeArrayGetElement( pSArray, &uIndex, &vItem );
      ASSERT( SUCCEEDED( hResult ) );

      strTemp   = FromLargeInteger( V_DISPATCH( &vItem ) );
      VariantClear( &vItem );
      strVal   += strTemp;

      if( strVal.GetLength( ) > 8096 )
         break;
   }

   return strVal;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsLargeInteger::VarToDisplayString( VARIANT& var, 
                                                 BOOL bMultiValued, 
                                                 BOOL bUseEx )
{
   if( bUseEx )
   {
      return VarToDisplayStringEx( var, bMultiValued );
   }
   
   if( bMultiValued )   
   {
      return VarToDisplayStringEx( var, TRUE );
   }
   else
   {
      return FromLargeInteger( V_DISPATCH( &var ) );
   }
}



/******************************************************************************
  Function:    COleDsDATE::COleDsDATE
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
******************************************************************************/
COleDsDATE::COleDsDATE( )
{
   m_lType        = VT_DATE;
   m_dwSyntaxID   = ADSTYPE_UTC_TIME;
}

/******************************************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
******************************************************************************/
HRESULT   COleDsDATE::Native2Value( ADSVALUE* pADsObject, CString& rVal )
{
   DATE           aDate;
   ADS_UTC_TIME   aUTCTime;
   HRESULT        hResult;

   aUTCTime = pADsObject->UTCTime;
   
   hResult  = SystemTimeToVariantTime( (SYSTEMTIME*) &aUTCTime, &aDate );

   if( SUCCEEDED( hResult ) )
   {
      VARIANT  aVar;
      VARIANT  vText;

      VariantInit( &aVar );
      VariantInit( &vText );
      V_VT( &aVar )     = VT_DATE;
      V_DATE( &aVar )   = aDate;

      hResult  = VariantChangeType( &vText, &aVar, VARIANT_NOVALUEPROP, VT_BSTR );
      if( SUCCEEDED( hResult ) )
      {
         TCHAR szText[ 128 ];

         Convert( szText, V_BSTR( &vText ) );
         rVal  = szText;
         VariantClear( &vText );
      }
   }

   return hResult;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsDATE::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   DATE           aDate;
   ADS_UTC_TIME   aUTCTime;
   HRESULT        hResult;
   VARIANT        vDate;
   VARIANT        vText;

   VariantInit( &vText );
   VariantInit( &vDate );

   V_VT( &vText )    = VT_BSTR;
   V_BSTR( &vText )  = AllocBSTR( rVal.GetBuffer( 128 ) );

   hResult  = VariantChangeType( &vDate, &vText, VARIANT_NOVALUEPROP, VT_DATE );
   VariantClear( &vText );

   if( SUCCEEDED( hResult ) )
   {
      aDate    = V_DATE( &vDate );
      hResult  = VariantTimeToSystemTime( aDate, (SYSTEMTIME*) &aUTCTime );
      pADsObject->UTCTime  = aUTCTime;
   }

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSOctetList::COleDsNDSOctetList
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSCaseIgnoreList::COleDsNDSCaseIgnoreList( )
{
   m_dwSyntaxID   = ADSTYPE_CASEIGNORE_LIST;
}

      
/***********************************************************
  Function:    COleDsNDSCaseIgnoreList::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSCaseIgnoreList::Native2Value( ADSVALUE* pValue, 
                                                CString& rText )
{
   ADS_CASEIGNORE_LIST* pStringList;
   int                  nIdx;

   ASSERT( ADSTYPE_CASEIGNORE_LIST == pValue->dwType );
   
   if( ADSTYPE_CASEIGNORE_LIST != pValue->dwType )
   {
      rText  = _T("ERROR: ADSTYPE_CASEIGNORE_LIST != pValue->dwType");
      return E_FAIL;
   }   
   nIdx  = 0;

   pStringList   = pValue->pCaseIgnoreList;
   while( NULL != pStringList && NULL != pStringList->String ) 
   {
      TCHAR*   pszText;

      if( 0 != nIdx )
         rText = rText + NDS_SEPARATOR;
      nIdx  = 1;

      pszText  = AllocTCHAR( pStringList->String );
      if( NULL != pszText )
      {
         rText = rText + pszText;
         FreeADsMem( pszText );
      }

      pStringList   = pStringList->Next;
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSCaseIgnoreList::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSCaseIgnoreList::Value2Native( ADSVALUE* pValue, 
                                                CString& rText )
{
   HRESULT               hResult  = E_FAIL;
   DWORD                 dwValues, dwItem;
   CString               strItem;
   ADS_CASEIGNORE_LIST** ppItem;

   pValue->dwType = ADSTYPE_CASEIGNORE_LIST;
   pValue->pCaseIgnoreList = NULL;

   dwValues = GetValuesCount( rText, NDS_SEPARATOR );
   
   ppItem   = &(pValue->pCaseIgnoreList);

   for( dwItem = 0; dwItem < dwValues ; dwItem++ )
   {
      strItem  = GetValueByIndex( rText, NDS_SEPARATOR, dwItem );
      *ppItem  = (ADS_CASEIGNORE_LIST*) AllocADsMem( sizeof( ADS_CASEIGNORE_LIST ) );

      (*ppItem)->String  = AllocWCHAR( strItem.GetBuffer( strItem.GetLength( ) ) );
      (*ppItem)->Next    = NULL;
      ppItem   = &((*ppItem)->Next );
   }
   if( dwValues   == 0 )
   {
      pValue->pCaseIgnoreList = (ADS_CASEIGNORE_LIST*) AllocADsMem( sizeof( ADS_CASEIGNORE_LIST ) );
      pValue->pCaseIgnoreList->String  = NULL;
      pValue->pCaseIgnoreList->Next  = NULL;

   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSCaseIgnoreList::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSCaseIgnoreList::FreeAttrValue( ADSVALUE* pValue )
{
   ADS_CASEIGNORE_LIST* pStringList;
   ADS_CASEIGNORE_LIST* pSaveStringList;

   pStringList = pValue->pCaseIgnoreList;

   while( NULL != pStringList )
   {
      FREE_MEMORY( pStringList->String );
      
      pSaveStringList = pStringList;
      pStringList     = pStringList->Next;

      FREE_MEMORY( pSaveStringList );
   }
}


/***********************************************************
  Function:    COleDsNDSCaseIgnoreList::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSCaseIgnoreList::String_2_VARIANT( TCHAR* pszText, 
                                                    VARIANT& rValue )
{
   HRESULT              hResult  = E_FAIL;
   CString              strItem;
   VARIANT              vVal;
   IADsCaseIgnoreList*  pCaseIgnoreList  = NULL;
   IDispatch*           pDisp = NULL;

   VariantInit( &vVal );
   VariantInit( &rValue );

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_CaseIgnoreList,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsCaseIgnoreList,
                                  (void **)&pCaseIgnoreList );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      strItem  = pszText;
      hResult  = BuildVariantArray( VT_BSTR, 
                                    strItem, 
                                    vVal, 
                                    NDS_SEPARATOR );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pCaseIgnoreList->put_CaseIgnoreList( vVal );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pCaseIgnoreList->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      V_VT( &rValue )         = VT_DISPATCH;
      V_DISPATCH( &rValue )   = pDisp;
      break;

   }
   VariantClear( &vVal );
   RELEASE( pCaseIgnoreList );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSCaseIgnoreList::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSCaseIgnoreList::VARIANT_2_String( TCHAR* pszText, 
                                                    VARIANT& rValue )
{
   IADsCaseIgnoreList*  pCaseIgnoreList  = NULL;
   HRESULT  hResult;
   VARIANT  vValue;
   CString  strText;

   VariantInit( &vValue );
   while( TRUE )
   {
      hResult  = V_DISPATCH( &rValue )->QueryInterface( IID_IADsCaseIgnoreList, 
                                                        (void**)&pCaseIgnoreList );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pCaseIgnoreList->get_CaseIgnoreList( &vValue );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      strText  = FromVariantArrayToString( vValue, NDS_SEPARATOR_S );
      _tcscpy( pszText, (LPCTSTR)strText );
      break;
   }

   RELEASE( pCaseIgnoreList );
   VariantClear( &vValue );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSNetAddress::COleDsNDSNetAddress
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSNetAddress::COleDsNDSNetAddress( )
{
   m_dwSyntaxID   = ADSTYPE_NETADDRESS;
}

      
/***********************************************************
  Function:    COleDsNDSNetAddress::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSNetAddress::Native2Value( ADSVALUE* pValue, CString& rText )
{
   ADS_NETADDRESS*  pNetAddress;
   TCHAR szText[ 16 ];

   ASSERT( ADSTYPE_NETADDRESS == pValue->dwType );
   
   if( ADSTYPE_NETADDRESS != pValue->dwType )
   {
      rText  = _T("ERROR: ADSTYPE_NETADDRESS != pValue->dwType");
      return E_FAIL;
   }   
   if( NULL == pValue->pNetAddress )
   {
      rText  = _T("ERROR: pValue->pNetAddress is NULL");
      return E_FAIL;
   }   
   
   pNetAddress = pValue->pNetAddress;
   _ultot( pNetAddress->AddressType, szText, 10 );
   rText = rText + SEPARATOR_S;

   if( NULL != pNetAddress->Address ) 
   {
      rText = rText + Blob2String( pNetAddress->Address, pNetAddress->AddressLength );
   }
   else
   {
      rText = rText + _T("NULL");
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSNetAddress::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSNetAddress::Value2Native( ADSVALUE* pValue, 
                                            CString& rText )
{
   HRESULT           hResult  = E_FAIL;
   DWORD             dwValues;
   CString           strAddressType;
   CString           strAddress;

   pValue->dwType       = ADSTYPE_NETADDRESS;
   pValue->pNetAddress  = NULL;

   while( TRUE )
   {
      dwValues = GetValuesCount( rText, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         ASSERT( FALSE );
         break;
      }
      
      pValue->pNetAddress  = (ADS_NETADDRESS*) AllocADsMem( sizeof(ADS_NETADDRESS) );
      if( NULL == pValue->pNetAddress )
         break;
   
      strAddressType = GetValueByIndex( rText, NDS_SEPARATOR, 0L );
      strAddress     = GetValueByIndex( rText, NDS_SEPARATOR, 1L );

      hResult  = String2Blob( strAddress.GetBuffer( strAddress.GetLength( ) ),
                             (void**) &(pValue->pNetAddress->Address), 
                             &(pValue->pNetAddress->AddressLength) );

      pValue->pNetAddress->AddressType  = (DWORD)_ttol( (LPCTSTR)strAddressType );
      break;
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSNetAddress::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSNetAddress::FreeAttrValue( ADSVALUE* pValue )
{
   if( NULL != pValue->pNetAddress )
   {
      FREE_MEMORY( pValue->pNetAddress->Address );
   }
   FREE_MEMORY( pValue->pNetAddress );
}


/***********************************************************
  Function:    COleDsNDSNetAddress::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSNetAddress::String_2_VARIANT( TCHAR* pszText, 
                                                VARIANT& rValue )
{
   HRESULT              hResult     = E_FAIL;
   CString              strItem;
   CString              strAddressType;
   CString              strAddress;
   DWORD                dwValues;
   VARIANT              vVal, vBlob;
   IADsNetAddress*      pNetAddress  = NULL;
   IDispatch*           pDisp       = NULL;

   VariantInit( &vVal );
   VariantInit( &vBlob );
   VariantInit( &rValue );

   strItem  = pszText;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_NetAddress,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsNetAddress,
                                  (void **)&pNetAddress );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      dwValues = GetValuesCount( strItem, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         ASSERT( FALSE );
         break;
      }
      
      strAddressType = GetValueByIndex( strItem, NDS_SEPARATOR, 0L );
      strAddress     = GetValueByIndex( strItem, NDS_SEPARATOR, 1L );

      pNetAddress->put_AddressType( _ttol( (LPCTSTR)strAddressType ) );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = CreateBlobArray( strAddress, vBlob );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      pNetAddress->put_Address( vBlob );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pNetAddress->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      V_VT( &rValue )         = VT_DISPATCH;
      V_DISPATCH( &rValue )   = pDisp;
      break;

   }

   VariantClear( &vVal );
   VariantClear( &vBlob );

   RELEASE( pNetAddress );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSNetAddress::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSNetAddress::VARIANT_2_String( TCHAR* pszText, 
                                                VARIANT& rValue )
{
   IADsNetAddress*  pNetAddress= NULL;
   HRESULT  hResult;
   CString  strText;
   LONG     lAddressType;
   VARIANT  vItem;

   VariantInit( &vItem );

   while( TRUE )
   {
      hResult  = V_DISPATCH( &rValue )->QueryInterface( IID_IADsNetAddress, 
                                                        (void**)&pNetAddress );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pNetAddress->get_Address( &vItem );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pNetAddress->get_AddressType( &lAddressType );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      strText  = FromVariantToString( vItem );

      _ltot( lAddressType, pszText, 10 );
      _tcscat( pszText, NDS_SEPARATOR_S ) ;
      _tcscat( pszText, (LPCTSTR)strText );

      break;
   }

   RELEASE( pNetAddress );
   VariantClear( &vItem );

   return hResult;
}

/***********************************************************
  Function:    COleDsNDSOctetList::COleDsNDSOctetList
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSOctetList::COleDsNDSOctetList( )
{
   m_dwSyntaxID   = ADSTYPE_OCTET_LIST;
}

      
/***********************************************************
  Function:    COleDsNDSOctetList::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSOctetList::Native2Value( ADSVALUE* pValue, CString& rText )
{
   ADS_OCTET_LIST*  pOctetString;
   int              nIdx;

   ASSERT( ADSTYPE_OCTET_LIST == pValue->dwType );
   
   if( ADSTYPE_OCTET_LIST != pValue->dwType )
   {
      rText  = _T("ERROR: ADSTYPE_OCTET_LIST != pValue->dwType");
      return E_FAIL;
   }   
   nIdx  = 0;

   pOctetString   = pValue->pOctetList;
   while( NULL != pOctetString && NULL != pOctetString->Data ) 
   {
      if( 0 != nIdx )
         rText = rText + SEPARATOR_S;
      nIdx  = 1;

      rText = rText + Blob2String( pOctetString->Data, (DWORD)pOctetString->Length );

      pOctetString   = pOctetString->Next;
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSOctetList::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSOctetList::Value2Native( ADSVALUE* pValue, 
                                           CString& rText )
{
   HRESULT           hResult  = E_FAIL;
   DWORD             dwValues, dwItem;
   CString           strItem;
   ADS_OCTET_LIST**  ppItem;

   pValue->dwType       = ADSTYPE_OCTET_LIST;
   pValue->pOctetList   = NULL;

   dwValues = GetValuesCount( rText, NDS_SEPARATOR );
   
   ppItem   = &(pValue->pOctetList);

   for( dwItem = 0; dwItem < dwValues ; dwItem++ )
   {
      strItem  = GetValueByIndex( rText, NDS_SEPARATOR, dwItem );
      *ppItem  = (ADS_OCTET_LIST*) AllocADsMem( sizeof( ADS_OCTET_LIST ) );

      hResult  = String2Blob( strItem.GetBuffer( strItem.GetLength( ) ),
                             (void**) &((*ppItem)->Data), 
                             &((*ppItem)->Length) );
      
      ASSERT( SUCCEEDED( hResult ) );

      (*ppItem)->Next    = NULL;
      ppItem   = &((*ppItem)->Next );
   }
   if( dwValues   == 0 )
   {
      pValue->pOctetList = (ADS_OCTET_LIST*) AllocADsMem( sizeof( ADS_OCTET_LIST ) );
      pValue->pOctetList->Data   = NULL;
      pValue->pOctetList->Next   = NULL;
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSOctetList::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSOctetList::FreeAttrValue( ADSVALUE* pValue )
{
   ADS_OCTET_LIST*  pOctetList;
   ADS_OCTET_LIST*  pSaveOctetList;
   BOOL             bMark;

   pOctetList  = pValue->pOctetList;
   bMark       = FALSE;

   while( NULL != pOctetList )
   {
      FREE_MEMORY( pOctetList->Data );
      
      pSaveOctetList = pOctetList;
      pOctetList     = pOctetList->Next;

      FREE_MEMORY( pSaveOctetList );
   }
}


/***********************************************************
  Function:    COleDsNDSOctetList::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSOctetList::String_2_VARIANT( TCHAR* pszText, 
                                               VARIANT& rValue )
{
   HRESULT              hResult     = E_FAIL;
   CString              strItem;
   VARIANT              vVal;
   IADsOctetList*       pOctetList  = NULL;
   IDispatch*           pDisp       = NULL;

   VariantInit( &vVal );
   VariantInit( &rValue );

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_OctetList,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsOctetList,
                                  (void **)&pOctetList );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      strItem  = pszText;
      hResult  = CreateBlobArrayEx( strItem, vVal, NDS_SEPARATOR );
      
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pOctetList->put_OctetList( vVal );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pOctetList->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      V_VT( &rValue )         = VT_DISPATCH;
      V_DISPATCH( &rValue )   = pDisp;
      break;

   }

   VariantClear( &vVal );
   RELEASE( pOctetList );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSOctetList::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSOctetList::VARIANT_2_String( TCHAR* pszText, 
                                               VARIANT& rValue )
{
   IADsOctetList*  pOctetList= NULL;
   HRESULT  hResult;
   VARIANT  vValue;
   CString  strText;
   LONG     lItems, lIdx;
   VARIANT  vItem;

   VariantInit( &vValue );

   *pszText = '\0';

   while( TRUE )
   {
      hResult  = V_DISPATCH( &rValue )->QueryInterface( IID_IADsOctetList, 
                                                        (void**)&pOctetList );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pOctetList->get_OctetList( &vValue );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      lItems   = GetVARIANTSize ( vValue );
      for( lIdx = 0; lIdx < lItems ; lIdx++ )
      {
         hResult  = GetVARIANTAt( lIdx, vValue, vItem );
         strText  = FromVariantToString( vItem );
         if( lIdx != 0 )
         {
            _tcscat( pszText, NDS_SEPARATOR_S );
         }
         _tcscat( pszText, (LPCTSTR)strText );
         VariantClear( &vItem );
      }
	  break;
   }

   RELEASE( pOctetList );
   VariantClear( &vValue );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::COleDsNDSPostalAddress
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSPostalAddress::COleDsNDSPostalAddress  ( )
{
   m_dwSyntaxID   = ADSTYPE_POSTALADDRESS;
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPostalAddress::Native2Value( ADSVALUE* pValue, 
                                               CString& rString )
{
   int   nIdx;

   ASSERT( ADSTYPE_POSTALADDRESS == pValue->dwType );
   
   if( ADSTYPE_POSTALADDRESS != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_POSTALADDRESS != pValue->dwType");
      return E_FAIL;
   }

   nIdx  = 0;
   rString  = _T("");

   for( nIdx = 0 ; nIdx < 6 ; nIdx++ )
   {
      LPWSTR   lpszPostalAddress;

      lpszPostalAddress = pValue->pPostalAddress->PostalAddress[ nIdx ];

      if( NULL != lpszPostalAddress )
      {
         TCHAR*   pszTemp;
         
         if( 0 != nIdx )
         {
            rString  = rString + NDS_SEPARATOR;
         }

         pszTemp  = (TCHAR*) AllocADsMem( sizeof(TCHAR) * ( 1 + wcslen( lpszPostalAddress ) ) );
         Convert( pszTemp, lpszPostalAddress );
         rString  = rString + pszTemp;
         FreeADsMem( pszTemp );
      }
      else
      {
         ASSERT( 0 != nIdx );
         break;
      }
   }

   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSPostalAddress::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPostalAddress::Value2Native( ADSVALUE* pValue, 
                                               CString& rString )
{
   DWORD dwIdx;
   DWORD dwValues;

   pValue->dwType = ADSTYPE_POSTALADDRESS;

   pValue->pPostalAddress  = (ADS_POSTALADDRESS*) AllocADsMem( sizeof(ADS_POSTALADDRESS) );

   for( dwIdx = 0; dwIdx < 6 ; dwIdx++ )
   {
      pValue->pPostalAddress->PostalAddress[ dwIdx ]  = NULL;
   }

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 0 == dwValues )
      return S_OK;

   for( dwIdx = 0; dwIdx < dwValues && dwIdx < 6; dwIdx++ )
   {
      CString  strItem;
      LPWSTR   lpszPostalAddress;

      strItem  = GetValueByIndex( rString, NDS_SEPARATOR, dwIdx );

      lpszPostalAddress = (LPWSTR) AllocADsMem( sizeof(TCHAR) * (strItem.GetLength( ) + 1 ) );
      Convert( lpszPostalAddress, strItem.GetBuffer( strItem.GetLength( ) ) );

      pValue->pPostalAddress->PostalAddress[ dwIdx ]  = lpszPostalAddress;
   }

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSPostalAddress::FreeAttrValue( ADSVALUE* pValue )
{
   DWORD dwIdx;

   for( dwIdx = 0; dwIdx < 6 ; dwIdx++ )
   {
      FREE_MEMORY( pValue->pPostalAddress->PostalAddress[ dwIdx ] );
   }
   FreeADsMem( pValue->pPostalAddress );
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPostalAddress::String_2_VARIANT( TCHAR* pszText, 
                                                   VARIANT& rVar )
{
   CString              strData;
   CString              strItem;
   DWORD                dwIdx;
   DWORD                dwValues;
   HRESULT              hResult;
   VARIANT              vArray;
   SAFEARRAY*           pSArray;
   SAFEARRAYBOUND       saBound;
   LONG                 lIdx;
   IADsPostalAddress*   pPostalAddress;
   IDispatch*           pDisp;

   hResult = CoCreateInstance(
                               CLSID_PostalAddress,
                               NULL,
                               CLSCTX_ALL,
                               IID_IADsPostalAddress,
                               (void **)&pPostalAddress );

   if( FAILED( hResult ) )
      return hResult;

   strData           = pszText;
   dwValues          = GetValuesCount( strData, NDS_SEPARATOR );
   saBound.lLbound   = LBOUND;
   saBound.cElements = dwValues;
   pSArray           = SafeArrayCreate( VT_VARIANT, 1, &saBound );
   if( NULL == pSArray )
   {
      ASSERT( FALSE );
      pPostalAddress->Release( );
      return E_FAIL;
   }

   for( dwIdx = 0; dwIdx < dwValues ; dwIdx++ )
   {
      VARIANT  vTemp;

      VariantInit( &vTemp );
      strItem           = GetValueByIndex( strData, NDS_SEPARATOR, dwIdx );
      V_VT( &vTemp )    = VT_BSTR;
      V_BSTR( &vTemp )  = AllocBSTR( strItem.GetBuffer( strItem.GetLength( ) ) );

      lIdx  = (long)dwIdx + LBOUND;
      hResult  = SafeArrayPutElement( pSArray, &lIdx, &vTemp );

      VariantClear( &vTemp );

      ASSERT( SUCCEEDED( hResult ) );
   }

   VariantInit( &vArray );
   V_VT( &vArray )      = VT_ARRAY | VT_VARIANT;
   V_ARRAY( &vArray )   = pSArray;

   hResult  = pPostalAddress->put_PostalAddress( vArray );
   ASSERT( SUCCEEDED( hResult ) );

   VariantClear( &vArray );

   hResult  = pPostalAddress->QueryInterface( IID_IDispatch, (void**)&pDisp );
   VariantInit( &rVar );

   V_VT( &rVar )        = VT_DISPATCH;
   V_DISPATCH( &rVar )  = pDisp;

   RELEASE( pPostalAddress );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPostalAddress::VARIANT_2_String( TCHAR* pszText, 
                                                   VARIANT& rVar )
{
   HRESULT           hResult  = E_FAIL;
   IADsPostalAddress* pPostalAddress = NULL;
   VARIANT           varData;
   CString           strText;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsPostalAddress,
                                                      (void**)&pPostalAddress );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pPostalAddress->get_PostalAddress( &varData );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      strText  = FromVariantArrayToString( varData, NDS_SEPARATOR_S );

      _tcscpy( pszText, (LPCTSTR)strText );

      VariantClear( &varData );

      break;
   }

   RELEASE( pPostalAddress )

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSFaxNumber::COleDsNDSFaxNumber
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSFaxNumber::COleDsNDSFaxNumber  ( )
{
   m_dwSyntaxID   = ADSTYPE_FAXNUMBER;
}


/***********************************************************
  Function:    COleDsNDSFaxNumber::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSFaxNumber::Native2Value( ADSVALUE* pValue, 
                                           CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_FAXNUMBER == pValue->dwType );
   
   if( ADSTYPE_FAXNUMBER != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_FAXNUMBER != pValue->dwType");
      return E_FAIL;
   }

   if( NULL == pValue->pFaxNumber )
   {
      ASSERT( FALSE );
      rString  = _T("ERROR: pValue->pFaxNumber Is NULL");
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->pFaxNumber->TelephoneNumber )
   {
      _tcscpy( szText, (TCHAR *) pValue->pFaxNumber->TelephoneNumber );
   }
   else
   {
      _tcscpy( szText, _T("NULL") );
   }
   _tcscat( szText, NDS_SEPARATOR_S );

   rString  = szText;

   if( NULL != pValue->pFaxNumber->Parameters )
   {
      rString = rString + Blob2String( pValue->pFaxNumber->Parameters, 
                                       pValue->pFaxNumber->NumberOfBits );
   }
   else
   {
      rString = rString + _T("NULL");
   }

   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSFaxNumber::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSFaxNumber::Value2Native( ADSVALUE* pValue, 
                                       CString& rString )
{
   DWORD    dwValues;
   CString  strTelephoneNumber;
   CString  strParameters;

   pValue->dwType = ADSTYPE_FAXNUMBER;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strTelephoneNumber   = GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strParameters        = GetValueByIndex( rString, NDS_SEPARATOR, 1L );

   pValue->pFaxNumber   = (ADS_FAXNUMBER*) AllocADsMem( sizeof(ADS_FAXNUMBER) );
   ASSERT( NULL != pValue->pFaxNumber );
   if( NULL == pValue->pFaxNumber )
   {
      return E_FAIL;
   }
   pValue->pFaxNumber->TelephoneNumber = AllocWCHAR( (LPTSTR)(LPCTSTR)strTelephoneNumber );
   
   String2Blob( strParameters.GetBuffer( strParameters.GetLength( ) ),
                (void**) (pValue->pFaxNumber->Parameters), 
                &(pValue->pFaxNumber->NumberOfBits) );


   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSFaxNumber::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSFaxNumber::FreeAttrValue( ADSVALUE* pValue )
{
   if( NULL !=  pValue->pFaxNumber )
   {
      FREE_MEMORY( pValue->pFaxNumber->TelephoneNumber );
      FREE_MEMORY( pValue->pFaxNumber->Parameters );
   }
   FREE_MEMORY( pValue->pFaxNumber );
}


/***********************************************************
  Function:    COleDsNDSFaxNumber::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSFaxNumber::String_2_VARIANT( TCHAR* pszText, 
                                               VARIANT& rVar )
{
   DWORD          dwValues;
   CString        strTelephoneNumber, strVal;
   CString        strParameters;
   HRESULT        hResult;
   IADsFaxNumber* pFaxNumber  = NULL;
   IDispatch*     pDisp       = NULL;
   BSTR           bstrVal     = NULL;
   VARIANT        vVal;

   VariantInit( &vVal );

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_FaxNumber,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsFaxNumber,
                                  (void **)&pFaxNumber);
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strTelephoneNumber= GetValueByIndex( strVal, NDS_SEPARATOR, 0L );
      strParameters     = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );

      bstrVal  = AllocBSTR( strTelephoneNumber.GetBuffer( strTelephoneNumber.GetLength( ) ) );

      hResult  = pFaxNumber->put_TelephoneNumber( bstrVal );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = CreateBlobArray( strParameters, vVal );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pFaxNumber->put_Parameters( vVal );
      ASSERT( SUCCEEDED( hResult ) );
      
      hResult  = pFaxNumber->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   SysFreeString( bstrVal );
   VariantClear( &vVal );
   RELEASE( pFaxNumber );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSFaxNumber::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSFaxNumber::VARIANT_2_String( TCHAR* pszText, 
                                               VARIANT& rVar )
{
   HRESULT     hResult  = E_FAIL;
   IADsFaxNumber*  pFaxNumber = NULL;
   VARIANT     vParameters;
   BSTR        bstrTelephoneNumber  = NULL;
   CString     strText;

   VariantInit( &vParameters );
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsFaxNumber,
                                                      (void**)&pFaxNumber );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pFaxNumber->get_TelephoneNumber( &bstrTelephoneNumber );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pFaxNumber->get_Parameters( &vParameters );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      Convert( pszText, bstrTelephoneNumber );

      _tcscat( pszText, NDS_SEPARATOR_S );

      strText  = FromVariantToString( vParameters );

      _tcscat( pszText, (LPCTSTR)strText );

      break;
   }
   
   SysFreeString( bstrTelephoneNumber );
   VariantClear( &vParameters );
   RELEASE( pFaxNumber );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSEMail::COleDsNDSEMail
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSEMail::COleDsNDSEMail  ( )
{
   m_dwSyntaxID   = ADSTYPE_EMAIL;
}


/***********************************************************
  Function:    COleDsNDSEMail::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSEMail::Native2Value( ADSVALUE* pValue, 
                                       CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_EMAIL == pValue->dwType );
   
   if( ADSTYPE_EMAIL != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_EMAIL != pValue->dwType");
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->Email.Address )
   {
      _stprintf( szText, 
                 _T("%ld & %S"),
                 pValue->Email.Type,  
                 pValue->Email.Address );
   }
   else
   {
      _stprintf( szText, 
                 _T("%ld & NULL"),
                 pValue->Email.Type );      
   }

   rString  = szText;
   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSEMail::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSEMail::Value2Native( ADSVALUE* pValue, 
                                       CString& rString )
{
   DWORD    dwValues, dwSize;
   CString  strNumber;
   CString  strAddress;

   pValue->dwType = ADSTYPE_EMAIL;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strNumber   = GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strAddress  = GetValueByIndex( rString, NDS_SEPARATOR, 1L );

   pValue->Email.Type   = (DWORD)_ttol( (LPCTSTR) strNumber );

   dwSize   = strAddress.GetLength( ) + 1;
   dwSize   = dwSize * sizeof(WCHAR);

   pValue->Email.Address   = (LPWSTR) AllocADsMem( dwSize );
   Convert( pValue->Email.Address, strAddress.GetBuffer( strAddress.GetLength( ) ) );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSEMail::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSEMail::FreeAttrValue( ADSVALUE* pValue )
{
   FREE_MEMORY( pValue->Email.Address );
}


/***********************************************************
  Function:    COleDsNDSEMail::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSEMail::String_2_VARIANT( TCHAR* pszText, 
                                           VARIANT& rVar )
{
   DWORD    dwValues;
   CString  strNumber, strVal;
   CString  strAddress;
   HRESULT              hResult;
   IADsEmail*   pEMail  = NULL;
   IDispatch*   pDisp   = NULL;
   BSTR         bstrVal = NULL;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_Email,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsEmail,
                                  (void **)&pEMail);
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strNumber   = GetValueByIndex( strVal, NDS_SEPARATOR, 0L );
      strAddress  = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );

      hResult  = pEMail->put_Type( _ttol( (LPCTSTR) strNumber )  );
      ASSERT( SUCCEEDED( hResult ) );

      bstrVal  = AllocBSTR( strAddress.GetBuffer( strAddress.GetLength( ) ) );

      hResult  = pEMail->put_Address( bstrVal );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pEMail->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   SysFreeString( bstrVal );
   RELEASE( pEMail );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSEMail::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSEMail::VARIANT_2_String( TCHAR* pszText, 
                                           VARIANT& rVar )
{
   HRESULT     hResult  = E_FAIL;
   IADsEmail*  pEmail = NULL;
   LONG        lType;
   BSTR        bstrVal  = NULL;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsEmail,
                                                      (void**)&pEmail );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pEmail->get_Type( &lType );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pEmail->get_Address( &bstrVal );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      _ltot( lType, pszText, 10 );
      _tcscat( pszText, NDS_SEPARATOR_S );
      Convert( pszText + _tcslen(pszText), bstrVal );

      break;
   }
   
   SysFreeString( bstrVal );
   RELEASE( pEmail );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSTypedName::COleDsNDSTypedName
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSTypedName::COleDsNDSTypedName( )
{
   m_dwSyntaxID   = ADSTYPE_TYPEDNAME;
}


/***********************************************************
  Function:    COleDsNDSTypedName::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTypedName::Native2Value( ADSVALUE* pValue, 
                                       CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_TYPEDNAME == pValue->dwType );
   
   if( ADSTYPE_TYPEDNAME != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_TYPEDNAME != pValue->dwType");
      return E_FAIL;
   }

   if( NULL == pValue->pTypedName )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->pTypedName->ObjectName )
   {
      _stprintf( szText, 
                 _T("%S & %ld & %ld"),
                 pValue->pTypedName->ObjectName,
                 pValue->pTypedName->Level,
                 pValue->pTypedName->Interval );
   }
   else
   {
      _stprintf( szText, 
                 _T("NULL & %ld & %ld"),
                 pValue->pTypedName->Level,
                 pValue->pTypedName->Interval );
   }

   rString  = szText;
   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSTypedName::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTypedName::Value2Native( ADSVALUE* pValue, 
                                          CString& rString )
{
   DWORD    dwValues;
   CString  strLevel;
   CString  strInterval;
   CString  strObjectName;

   pValue->dwType = ADSTYPE_TYPEDNAME;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 3 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   pValue->pTypedName   = (ADS_TYPEDNAME*) AllocADsMem( sizeof(ADS_TYPEDNAME) );

   strObjectName  = GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strLevel       = GetValueByIndex( rString, NDS_SEPARATOR, 1L );
   strInterval    = GetValueByIndex( rString, NDS_SEPARATOR, 2L );

   pValue->pTypedName->Level     = (DWORD)_ttol( (LPCTSTR) strLevel );
   pValue->pTypedName->Interval  = (DWORD)_ttol( (LPCTSTR) strInterval );
   pValue->pTypedName->ObjectName= AllocWCHAR( (TCHAR*)(LPCTSTR)strObjectName );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSTypedName::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSTypedName::FreeAttrValue( ADSVALUE* pValue )
{
   FREE_MEMORY( pValue->pTypedName->ObjectName );
   FREE_MEMORY( pValue->pTypedName );
}


/***********************************************************
  Function:    COleDsNDSEMail::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTypedName::String_2_VARIANT( TCHAR* pszText, 
                                          VARIANT& rVar )
{
   DWORD          dwValues;
   CString        strLevel, strVal;
   CString        strInterval;
   CString        strObjectName;
   HRESULT        hResult;
   IADsTypedName* pTypedName = NULL;
   IDispatch*     pDisp = NULL;
   BSTR           bstrObjectName =  NULL;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_TypedName,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsTypedName,
                                  (void **)&pTypedName );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 3 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strObjectName  = GetValueByIndex( strVal, NDS_SEPARATOR, 0L );
      strLevel       = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );
      strInterval    = GetValueByIndex( strVal, NDS_SEPARATOR, 2L );
      

      hResult  = pTypedName->put_Level( _ttol( (LPCTSTR) strLevel )  );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pTypedName->put_Interval( _ttol( (LPCTSTR) strInterval )  );
      ASSERT( SUCCEEDED( hResult ) );

      bstrObjectName = AllocBSTR( strObjectName.GetBuffer( strObjectName.GetLength( ) ) );

      hResult  = pTypedName->put_ObjectName( bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pTypedName->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   SysFreeString( bstrObjectName );
   RELEASE( pTypedName );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSTypedName::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTypedName::VARIANT_2_String( TCHAR* pszText, 
                                          VARIANT& rVar )
{
   HRESULT     hResult  = E_FAIL;
   IADsTypedName*   pTypedName = NULL;
   LONG        lLevel, lInterval;
   BSTR        bstrObjectName  = NULL;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsTypedName,
                                                      (void**)&pTypedName );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pTypedName->get_Level( &lLevel );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pTypedName->get_Interval( &lInterval );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pTypedName->get_ObjectName( &bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      Convert( pszText, bstrObjectName );
      _tcscat( pszText, NDS_SEPARATOR_S );
      _ltot( lLevel, pszText + _tcslen( pszText), 10 );
      _tcscat( pszText, NDS_SEPARATOR_S );
      _ltot( lInterval, pszText + _tcslen( pszText), 10 );

      break;
   }
   
   SysFreeString( bstrObjectName );
   RELEASE( pTypedName );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSHold::COleDsNDSHold
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSHold::COleDsNDSHold( )
{
   m_dwSyntaxID   = ADSTYPE_HOLD;
}


/***********************************************************
  Function:    COleDsNDSHold::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSHold::Native2Value( ADSVALUE* pValue, 
                                      CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_HOLD == pValue->dwType );
   
   if( ADSTYPE_HOLD != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_HOLD != pValue->dwType");
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->Hold.ObjectName )
   {
      _stprintf( szText, 
                 _T("%ld & %S"),
                 pValue->Hold.Amount,  
                 pValue->Hold.ObjectName );
   }
   else
   {
      _stprintf( szText, 
                 _T("NULL & %ld "),
                 pValue->Hold.Amount );      
   }

   rString  = szText;
   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSHold::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSHold::Value2Native( ADSVALUE* pValue, 
                                      CString& rString )
{
   DWORD    dwValues;
   CString  strAmount;
   CString  strObjectName;

   pValue->dwType = ADSTYPE_HOLD;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strAmount      = GetValueByIndex( rString, NDS_SEPARATOR, 1L );
   strObjectName  = GetValueByIndex( rString, NDS_SEPARATOR, 0L );

   pValue->Hold.Amount    = (DWORD)_ttol( (LPCTSTR) strAmount );
   pValue->Hold.ObjectName = AllocWCHAR( (TCHAR*)(LPCTSTR)strObjectName );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSHold::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSHold::FreeAttrValue( ADSVALUE* pValue )
{
   FREE_MEMORY( pValue->Hold.ObjectName );
}


/***********************************************************
  Function:    COleDsNDSEMail::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSHold::String_2_VARIANT( TCHAR* pszText, 
                                          VARIANT& rVar )
{
   DWORD          dwValues;
   CString        strAmount, strVal;
   CString        strObjectName;
   HRESULT        hResult;
   IADsHold*      pHold = NULL;
   IDispatch*     pDisp = NULL;
   BSTR           bstrObjectName =  NULL;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_Hold,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsHold,
                                  (void **)&pHold );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strAmount     = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );
      strObjectName  = GetValueByIndex( strVal, NDS_SEPARATOR, 0L );

      hResult  = pHold->put_Amount( _ttol( (LPCTSTR) strAmount )  );
      ASSERT( SUCCEEDED( hResult ) );

      bstrObjectName = AllocBSTR( strObjectName.GetBuffer( strObjectName.GetLength( ) ) );

      hResult  = pHold->put_ObjectName( bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pHold->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   SysFreeString( bstrObjectName );
   RELEASE( pHold );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSHold::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSHold::VARIANT_2_String( TCHAR* pszText, 
                                          VARIANT& rVar )
{
   HRESULT     hResult  = E_FAIL;
   IADsHold*   pHold = NULL;
   LONG        lAmount;
   BSTR        bstrObjectName  = NULL;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsHold,
                                                      (void**)&pHold );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pHold->get_Amount( &lAmount );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pHold->get_ObjectName( &bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      Convert( pszText, bstrObjectName );
      _tcscat( pszText, NDS_SEPARATOR_S );
      _ltot( lAmount, pszText + _tcslen( pszText), 10 );

      break;
   }
   
   SysFreeString( bstrObjectName );
   RELEASE( pHold );

   return hResult;
}



/***********************************************************
  Function:    COleDsNDSBackLink::COleDsNDSBackLink
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSBackLink::COleDsNDSBackLink( )
{
   m_dwSyntaxID   = ADSTYPE_BACKLINK;
}


/***********************************************************
  Function:    COleDsNDSBackLink::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSBackLink::Native2Value( ADSVALUE* pValue, 
                                       CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_BACKLINK == pValue->dwType );
   
   if( ADSTYPE_BACKLINK != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_BACKLINK != pValue->dwType");
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->BackLink.ObjectName )
   {
      _stprintf( szText, 
                 _T("%ld & %S"),
                 pValue->BackLink.RemoteID,  
                 pValue->BackLink.ObjectName );
   }
   else
   {
      _stprintf( szText, 
                 _T("%ld & NULL"),
                 pValue->BackLink.RemoteID );      
   }

   rString  = szText;
   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSBackLink::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSBackLink::Value2Native( ADSVALUE* pValue, 
                                          CString& rString )
{
   DWORD    dwValues;
   CString  strRemoteID;
   CString  strObjectName;

   pValue->dwType = ADSTYPE_BACKLINK;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strRemoteID    = GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strObjectName  = GetValueByIndex( rString, NDS_SEPARATOR, 1L );

   pValue->BackLink.RemoteID     = (DWORD)_ttol( (LPCTSTR) strRemoteID );
   pValue->BackLink.ObjectName   = AllocWCHAR( (TCHAR*)(LPCTSTR)strObjectName );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSBackLink::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSBackLink::FreeAttrValue( ADSVALUE* pValue )
{
   FREE_MEMORY( pValue->BackLink.ObjectName );
}


/***********************************************************
  Function:    COleDsNDSEMail::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSBackLink::String_2_VARIANT( TCHAR* pszText, 
                                           VARIANT& rVar )
{
   DWORD          dwValues;
   CString        strRemoteID, strVal;
   CString        strObjectName;
   HRESULT        hResult;
   IADsBackLink*  pBackLink  = NULL;
   IDispatch*     pDisp   = NULL;
   BSTR           bstrObjectName =  NULL;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_BackLink,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsBackLink,
                                  (void **)&pBackLink );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 2 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strRemoteID    = GetValueByIndex( strVal, NDS_SEPARATOR, 0L );
      strObjectName  = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );

      hResult  = pBackLink->put_RemoteID( _ttol( (LPCTSTR) strRemoteID )  );
      ASSERT( SUCCEEDED( hResult ) );

      bstrObjectName = AllocBSTR( strObjectName.GetBuffer( strObjectName.GetLength( ) ) );

      hResult  = pBackLink->put_ObjectName( bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pBackLink->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   SysFreeString( bstrObjectName );
   RELEASE( pBackLink );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSBackLink::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSBackLink::VARIANT_2_String( TCHAR* pszText, 
                                           VARIANT& rVar )
{
   HRESULT     hResult  = E_FAIL;
   IADsBackLink*  pBackLink = NULL;
   LONG        lRemoteID;
   BSTR        bstrObjectName  = NULL;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsBackLink,
                                                      (void**)&pBackLink );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pBackLink->get_RemoteID( &lRemoteID );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pBackLink->get_ObjectName( &bstrObjectName );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      _ltot( lRemoteID, pszText, 10 );
      _tcscat( pszText, NDS_SEPARATOR_S );
      Convert( pszText + _tcslen(pszText), bstrObjectName );

      break;
   }
   
   SysFreeString( bstrObjectName );
   RELEASE( pBackLink );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSPostalAddress::COleDsNDSPostalAddress
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSPath::COleDsNDSPath  ( )
{
   m_dwSyntaxID   = ADSTYPE_PATH;
}


/***********************************************************
  Function:    COleDsNDSPath::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPath::Native2Value( ADSVALUE* pValue, 
                                       CString& rString )
{
   int   nIdx;
   TCHAR szText[ 256 ];

   ASSERT( ADSTYPE_PATH == pValue->dwType );
   
   if( ADSTYPE_PATH != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_PATH != pValue->dwType");
      return E_FAIL;
   }

   nIdx  = 0;
   if( NULL != pValue->pPath )
   {
      _stprintf( szText, 
                 _T("%ld & %S & %S"),
                 pValue->pPath->Type,  
                 pValue->pPath->VolumeName,
                 pValue->pPath->Path);
   }
   else
   {
      _stprintf( szText, 
                 _T("%ld & NULL & NULL"),
                 pValue->pPath->Type );      
   }

   rString  = szText;
   return S_OK;
}

/***********************************************************
  Function:    COleDsNDSPath::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPath::Value2Native( ADSVALUE* pValue, 
                                      CString& rString )
{
   DWORD    dwValues;
   CString  strType;
   CString  strVolName;
   CString  strPath;

   pValue->pPath  = (ADS_PATH*) AllocADsMem( sizeof(ADS_PATH) );
   if( NULL == pValue->pPath )
      return E_FAIL;

   pValue->pPath->VolumeName  = NULL;
   pValue->pPath->Path        = NULL;

   pValue->dwType = ADSTYPE_PATH;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 3 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strType     = GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strVolName  = GetValueByIndex( rString, NDS_SEPARATOR, 1L );
   strPath     = GetValueByIndex( rString, NDS_SEPARATOR, 2L );

   pValue->pPath->Type  = (DWORD)_ttol( (LPCTSTR) strType );
   pValue->pPath->VolumeName  = AllocWCHAR( strVolName.GetBuffer( strVolName.GetLength( ) ) );
   pValue->pPath->Path  = AllocWCHAR( strPath.GetBuffer( strPath.GetLength( ) ) );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSEMail::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void     COleDsNDSPath::FreeAttrValue( ADSVALUE* pValue )
{
   FREE_MEMORY( pValue->pPath->VolumeName );
   FREE_MEMORY( pValue->pPath->Path );
   FREE_MEMORY( pValue->pPath );
}


/***********************************************************
  Function:    COleDsNDSPath::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPath::String_2_VARIANT( TCHAR* pszText, 
                                           VARIANT& rVar )
{
   DWORD    dwValues;
   CString  strType, strVal;
   CString  strVolName;
   CString  strPath;
   HRESULT     hResult;
   IADsPath*   pPath    = NULL;
   IDispatch*  pDisp   = NULL;
   BSTR        bstrVal = NULL;

   while( TRUE )
   {
      hResult = CoCreateInstance(
                                  CLSID_Path,
                                  NULL,
                                  CLSCTX_ALL,
                                  IID_IADsPath,
                                  (void **)&pPath );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      strVal   = pszText;

      dwValues = GetValuesCount( strVal, NDS_SEPARATOR );
      if( 3 != dwValues )
      {
         hResult  = E_FAIL;
         ASSERT( FALSE );
         break;
      }

      strType     = GetValueByIndex( strVal, NDS_SEPARATOR, 0L );
      strVolName  = GetValueByIndex( strVal, NDS_SEPARATOR, 1L );
      strPath     = GetValueByIndex( strVal, NDS_SEPARATOR, 2L );

      hResult  = pPath->put_Type( _ttol( (LPCTSTR) strType )  );
      ASSERT( SUCCEEDED( hResult ) );

      bstrVal  = AllocBSTR( strVolName.GetBuffer( strVolName.GetLength( ) ) );
      hResult  = pPath->put_VolumeName( bstrVal );
      ASSERT( SUCCEEDED( hResult ) );
      SysFreeString( bstrVal );

      bstrVal  = AllocBSTR( strPath.GetBuffer( strPath.GetLength( ) ) );
      hResult  = pPath->put_Path( bstrVal );
      ASSERT( SUCCEEDED( hResult ) );
      SysFreeString( bstrVal );


      hResult  = pPath->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_VT( &rVar )        = VT_DISPATCH;
      V_DISPATCH( &rVar )  = pDisp;

      break;
   }

   RELEASE( pPath );
   
   return hResult;
}


/***********************************************************
  Function:    COleDsNDSPath::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSPath::VARIANT_2_String( TCHAR* pszText, 
                                          VARIANT& rVar )
{
   HRESULT     hResult     = E_FAIL;
   IADsPath*   pPath       = NULL;
   LONG        lType;
   BSTR        bstrVolName = NULL;
   BSTR        bstrPath    = NULL;
   
   while( TRUE )
   {
      ASSERT( VT_DISPATCH == V_VT( &rVar ) );
      if( VT_DISPATCH != V_VT( &rVar ) )
         break;

      hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsPath,
                                                      (void**)&pPath );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pPath->get_Type( &lType );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pPath->get_VolumeName( &bstrVolName );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      hResult  = pPath->get_Path( &bstrPath );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult) )
         break;

      _ltot( lType, pszText, 10 );
      _tcscat( pszText, NDS_SEPARATOR_S );
      Convert( pszText + _tcslen(pszText), bstrVolName );
      _tcscat( pszText, NDS_SEPARATOR_S );
      Convert( pszText + _tcslen(pszText), bstrPath );
      break;
   }
   
   SysFreeString( bstrVolName );
   SysFreeString( bstrPath );
   RELEASE( pPath );

   return hResult;
}





/***********************************************************
  Function:    COleDsNDSTimeStamp::COleDsNDSTimeStamp
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSTimeStamp::COleDsNDSTimeStamp( )
{
   m_dwSyntaxID   = ADSTYPE_TIMESTAMP;
}


/***********************************************************
  Function:    COleDsNDSTimeStamp::GenerateString
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsNDSTimeStamp::GenerateString( TCHAR* szText,
                                              DWORD dwWholeSeconds,
                                              DWORD dwEventID )
{
   _tcscpy( szText, _T("WholeSeconds: ") );

   _ultot( dwWholeSeconds, 
           szText + _tcslen(szText), 
           10 );
   _tcscat( szText, _T("EventID: ") );

   _ultot( dwEventID, 
           szText + _tcslen(szText), 
           10 );

   return S_OK;
}


/***********************************************************
  Function: COleDsNDSTimeStamp::GetComponents
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTimeStamp::GetComponents( TCHAR* pszString, 
                                            DWORD* pdwWholeSeconds, 
                                            DWORD* pdwEventID )
{
   
   TCHAR szText1[ 128 ];
   TCHAR szText2[ 128 ];
   int nRet = 0;
   

   *pdwWholeSeconds  = 0xAABBCCDD;
   *pdwEventID       = 0xAABBCCDD;

   nRet = _stscanf( pszString, _T("%s%d%s%d"), szText1, 
                      pdwWholeSeconds, szText2, pdwWholeSeconds );

   if (4 != nRet)
       return E_FAIL;

   return ( (*pdwWholeSeconds  == 0xAABBCCDD) && (*pdwEventID == 0xAABBCCDD) ) ? 
            S_OK : E_FAIL;
}



/***********************************************************
  Function: COleDsNDSTimeStamp::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsNDSTimeStamp::Value2Native  ( ADSVALUE* pValue, 
                                              CString& rString )
{
   DWORD    dwValues;
   CString  strWholeSeconds;
   CString  strEventID;

   pValue->dwType = ADSTYPE_TIMESTAMP;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strWholeSeconds= GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strEventID     = GetValueByIndex( rString, NDS_SEPARATOR, 1L );

   pValue->Timestamp.WholeSeconds= (DWORD)_ttol( (LPCTSTR) strWholeSeconds );
   pValue->Timestamp.EventID     = (DWORD)_ttol( (LPCTSTR) strEventID );

   return S_OK;
}


/***********************************************************
  Function:    COleDsNDSTimeStamp::Native2Value
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsNDSTimeStamp::Native2Value( ADSVALUE* pValue, 
                                            CString& rString)
{
   TCHAR szText[ 128 ];

   ASSERT( ADSTYPE_TIMESTAMP != pValue->dwType );
   
   if( ADSTYPE_TIMESTAMP != pValue->dwType )
   {
      rString  = _T("ERROR: ADSTYPE_TIMESTAMP != pValue->dwType");
      return E_FAIL;
   }

   _ultot( pValue->Timestamp.WholeSeconds, 
           szText, 
           10 );

   _tcscat( szText, NDS_SEPARATOR_S );

   _ultot( pValue->Timestamp.EventID, 
           szText + _tcslen(szText), 
           10 );

   rString  = szText;

   return S_OK;
   
}


/***********************************************************
  Function:    COleDsNDSTimeStamp::String_2_VARIANT
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTimeStamp::String_2_VARIANT( TCHAR* pszText, 
                                               VARIANT& rVar )
{
   HRESULT        hResult;
   IADsTimestamp* pTimeStamp;
   DWORD    dwValues;
   CString  strWholeSeconds;
   CString  strEventID;
   CString  rString;

   rString  = pszText;

   dwValues = GetValuesCount( rString, NDS_SEPARATOR );
   if( 2 != dwValues )
   {
      ASSERT( FALSE );
      return E_FAIL;
   }

   strWholeSeconds= GetValueByIndex( rString, NDS_SEPARATOR, 0L );
   strEventID     = GetValueByIndex( rString, NDS_SEPARATOR, 1L );

   hResult  =    hResult = CoCreateInstance(
                                             CLSID_Timestamp,
                                             NULL,
                                             CLSCTX_INPROC_SERVER,
                                             IID_IADsTimestamp,
                                             (void **)&pTimeStamp );

   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
      return hResult;

   hResult  = pTimeStamp->put_WholeSeconds( _ttol( (LPCTSTR) strWholeSeconds ) );
   ASSERT( SUCCEEDED( hResult ) );

   hResult  = pTimeStamp->put_EventID( _ttol( (LPCTSTR) strEventID ) );
   ASSERT( SUCCEEDED( hResult ) );
   

   if( SUCCEEDED( hResult ) )
   {
      IDispatch*  pDisp = NULL;

      V_VT( &rVar )   = VT_DISPATCH;
      hResult  = pTimeStamp->QueryInterface( IID_IDispatch, (void**)&pDisp );
      ASSERT( SUCCEEDED( hResult ) );

      V_DISPATCH( &rVar )   = pDisp;
   }

   pTimeStamp->Release( );

   return hResult;
}


/***********************************************************
  Function:    COleDsNDSTimeStamp::VARIANT_2_String
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsNDSTimeStamp::VARIANT_2_String( TCHAR* pszText, VARIANT& rVar )
{
   IADsTimestamp* pTimeStamp = NULL;
   HRESULT        hResult;
   long           lWholeSeconds, lEventID;

   ASSERT( VT_DISPATCH == V_VT( &rVar) );
   if( VT_DISPATCH != V_VT( &rVar) )
   {
      _tcscpy( pszText, _T("ERROR: VT_DISPATCH != V_VT( &rVar)") );
      return E_FAIL;
   }

   hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsTimestamp, 
                                                   (void**)&pTimeStamp );
   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      _tcscpy( pszText, _T("ERROR: QI for IID_IADsTimeStamp fails") );
      return hResult;
   }

   hResult  = pTimeStamp->get_WholeSeconds( &lWholeSeconds );
   ASSERT( SUCCEEDED( hResult ) );

   hResult  = pTimeStamp->get_EventID( &lEventID );
   ASSERT( SUCCEEDED( hResult ) );

   pTimeStamp->Release( );

   _ultot( lWholeSeconds, 
           pszText, 
           10 );

   _tcscat( pszText, NDS_SEPARATOR_S );

   _ultot( lEventID, 
           pszText + _tcslen(pszText), 
           10 );

   return hResult;
}

/***********************************************************
  Function:    COleDsNDSComplexType::COleDsNDSComplexType
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsNDSComplexType::COleDsNDSComplexType( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsNDSComplexType::VarToDisplayStringEx( VARIANT& var, 
                                                     BOOL bMultiValued )
{
   SAFEARRAY*  pSArray;
   HRESULT     hResult;
   LONG        uLow, uHigh, uIndex;
   VARIANT     vItem;
   CString     strVal;
   CString     strTemp;

   pSArray  = V_ARRAY( &var );

   hResult  = SafeArrayGetLBound( pSArray, 1, &uLow );
   hResult  = SafeArrayGetUBound( pSArray, 1, &uHigh );

   if( !bMultiValued )
   {
      ASSERT( uLow == uHigh );
   }

   for( uIndex = uLow; uIndex <= uHigh; uIndex++ )
   {
      if( uIndex != uLow )
      {
         strVal  += SEPARATOR_S;
      }

      VariantInit( &vItem );
      hResult  = SafeArrayGetElement( pSArray, &uIndex, &vItem );
      ASSERT( SUCCEEDED( hResult ) );

      strTemp   = VarToDisplayString( vItem, bMultiValued, FALSE );
      VariantClear( &vItem );
      strVal   += strTemp;

      if( strVal.GetLength( ) > 8096 )
         break;
   }

   return strVal;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsNDSComplexType::VarToDisplayString( VARIANT& var, 
                                                   BOOL bMultiValued, 
                                                   BOOL bUseEx )
{
   LONG        uLow, uHigh, uIndex;
   SAFEARRAY*  psa;
   VARIANT     vItem;
   CString     strVal, strTemp;
   HRESULT     hResult;
   TCHAR       szText[ 2048 ];

   if( bUseEx )
   {
      return VarToDisplayStringEx( var, bMultiValued );
   }
   
   if( bMultiValued )   
   {
      if( VT_DISPATCH == V_VT( &var ) )
      {
         VARIANT_2_String( szText, var );
         return CString( szText );
      }

      ASSERT( (VT_ARRAY | VT_VARIANT) == V_VT(&var) );
      if( (VT_ARRAY | VT_VARIANT) == V_VT(&var) )
      {
         return CString( _T("ERROR: (VT_ARRAY | VT_VARIANT) != V_VT(&var)") );
      }

      psa   = V_ARRAY( &var );
      ASSERT( NULL != psa );
      if( NULL == psa )
      {
         return CString( _T("ERROR: NULL == psa" ) );
      }

      hResult  = SafeArrayGetLBound( psa, 1, &uLow );
      hResult  = SafeArrayGetUBound( psa, 1, &uHigh );

      for( uIndex = uLow; uIndex <= uHigh; uIndex++ )
      {
         if( uIndex != uLow )
         {
            strVal  += SEPARATOR_S;
         }

         VariantInit( &vItem );
         hResult  = SafeArrayGetElement( psa, &uIndex, &vItem );
         ASSERT( SUCCEEDED( hResult ) );

         strTemp   = VarToDisplayString( vItem, FALSE, FALSE );
         VariantClear( &vItem );
         strVal   += strTemp;

         if( strVal.GetLength( ) > 8096 )
            break;
      }
   }
   else
   {
      hResult  = VARIANT_2_String( szText, var );

      if( SUCCEEDED( hResult ) )
      {
         strVal   = szText;
      }
      else
      {
         strVal   = OleDsGetErrorText( hResult );
      }
   }

   return strVal;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL  COleDsNDSComplexType::DisplayStringToDispParamsEx( CString& rText, 
                                                         DISPPARAMS& dispParams, 
                                                         BOOL bMultiValued )
{
   SAFEARRAY*        pSArray;
   SAFEARRAYBOUND    saBound;
   HRESULT           hResult;
   LONG              lIdx = LBOUND;

   DisplayStringToDispParams( rText, dispParams, bMultiValued, FALSE );
   
   if( !bMultiValued )
   {
      saBound.lLbound   = LBOUND;
      saBound.cElements = 1;
      pSArray           = SafeArrayCreate( VT_VARIANT, 1, &saBound );
      hResult           = SafeArrayPutElement( pSArray, &lIdx, &dispParams.rgvarg[0] );
      
      VariantClear( &dispParams.rgvarg[0] );

      V_VT( &dispParams.rgvarg[0] )    = VT_ARRAY | VT_VARIANT;
      V_ARRAY( &dispParams.rgvarg[0] ) = pSArray;
   }

   return TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL     COleDsNDSComplexType::DisplayStringToDispParams( CString& rText, 
                                                          DISPPARAMS& dispParams, 
                                                          BOOL bMultiValued, 
                                                          BOOL bUseEx )
{
   HRESULT  hResult;
   int      x= 0;
  
   if( bUseEx )
   {
      return DisplayStringToDispParamsEx( rText, dispParams, bMultiValued );
   }

   
   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   if( bMultiValued )
   {
      SAFEARRAY*     psa;
      SAFEARRAYBOUND sab;
      TCHAR*         strText;
      TCHAR*         strStore;
      int            nItems   = 0;
      int            nIdx;
      int            nSize;

      //rText.MakeUpper( );

      strText  = (TCHAR*) new TCHAR[ rText.GetLength( ) + 1 ];
      strStore = strText;
      if( !strText )
      {
         return FALSE;
      }

      _tcscpy( strText, rText.GetBuffer( rText.GetLength( ) ) );
      nSize    = rText.GetLength( );
      nItems   = 1;
      for( nIdx = 0; nIdx < nSize ; nIdx++ )
      {
         if( strText[ nIdx ] == SEPARATOR_C )
         {
            strText[ nIdx ]   = _T('\0');
            nItems++;
         }
      }

      sab.cElements   = nItems;
      sab.lLbound     = LBOUND;
      psa             = SafeArrayCreate( VT_VARIANT, 1, &sab );
      ASSERT( NULL != psa );
      if ( psa )
      {
         for( nIdx = LBOUND; nIdx < ( LBOUND + nItems ) ; nIdx++ )
         {
            VARIANT  var;

            String_2_VARIANT( strText, var );
            strText += _tcslen( strText ) + 1;

            hResult  = SafeArrayPutElement( psa, (long FAR *)&nIdx, &var );
            VariantClear( &var );
         }

         V_VT( &dispParams.rgvarg[0] )     = VT_VARIANT | VT_ARRAY;
         V_ARRAY( &dispParams.rgvarg[0] )  = psa;
      }

      delete [] strStore;
   }
   else
   {
      hResult  = String_2_VARIANT( rText.GetBuffer( rText.GetLength( ) ), 
                                   dispParams.rgvarg[0] );
   }

   return SUCCEEDED( hResult );
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsVARIANT::VarToDisplayString( VARIANT& var, BOOL bMultiValued, BOOL bUseEx )
{
   return FromVariantArrayToString( var );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsVARIANT::Native2Value( ADSVALUE* pADsObject, CString& rVal )
{
   return S_OK;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsVARIANT::Value2Native( ADSVALUE* pADsObject, CString& rVal )
{
   return S_OK;
}
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL  COleDsVARIANT::DisplayStringToDispParams( CString& rText, DISPPARAMS& dispParams, BOOL bMultiValued, BOOL bUseEx )
{
   HRESULT  hResult;
   
   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   hResult  = BuildVariantArray( VT_BSTR, rText, dispParams.rgvarg[0] );

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsOctetString::COleDsOctetString( )
{
   m_dwSyntaxID   = ADSTYPE_OCTET_STRING;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsOctetString::VarToDisplayStringEx( VARIANT& var, BOOL bMultiValued )
{
   SAFEARRAY*  pSArray;
   HRESULT     hResult;
   LONG        uLow, uHigh, uIndex;
   VARIANT     vItem;
   CString     strVal;
   CString     strTemp;

   pSArray  = V_ARRAY( &var );

   hResult  = SafeArrayGetLBound( pSArray, 1, &uLow );
   hResult  = SafeArrayGetUBound( pSArray, 1, &uHigh );

   if( !bMultiValued )
   {
      ASSERT( uLow == uHigh );
   }

   for( uIndex = uLow; uIndex <= uHigh; uIndex++ )
   {
      if( uIndex != uLow )
      {
         strVal  += SEPARATOR_S;
      }

      VariantInit( &vItem );
      hResult  = SafeArrayGetElement( pSArray, &uIndex, &vItem );
      ASSERT( SUCCEEDED( hResult ) );

      strTemp   = VarToDisplayString( vItem, bMultiValued, FALSE );
      VariantClear( &vItem );
      strVal   += strTemp;

      if( strVal.GetLength( ) > 8096 )
         break;
   }

   return strVal;
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsOctetString::VarToDisplayString( VARIANT& var, BOOL bMultiValued, BOOL bUseEx )
{
   if( bUseEx )
   {
      return VarToDisplayStringEx( var, bMultiValued );
   }
   
   if( bMultiValued )   
   {
      return FromVariantArrayToString( var );
   }
   else
   {
      return FromVariantArrayToString( var );
   }
}



/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL  COleDsOctetString::DisplayStringToDispParamsEx( CString& rText, DISPPARAMS& dispParams, BOOL bMultiValued )
{
   SAFEARRAY*        pSArray;
   SAFEARRAYBOUND    saBound;
   HRESULT           hResult;
   LONG              lIdx = LBOUND;

   DisplayStringToDispParams( rText, dispParams, bMultiValued, FALSE );
   
   if( !bMultiValued )
   {
      saBound.lLbound   = LBOUND;
      saBound.cElements = 1;
      pSArray           = SafeArrayCreate( VT_VARIANT, 1, &saBound );
      hResult           = SafeArrayPutElement( pSArray, &lIdx, &dispParams.rgvarg[0] );
      
      VariantClear( &dispParams.rgvarg[0] );

      V_VT( &dispParams.rgvarg[0] )    = VT_ARRAY | VT_VARIANT;
      V_ARRAY( &dispParams.rgvarg[0] ) = pSArray;
   }

   return TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL     COleDsOctetString::DisplayStringToDispParams( CString& rText, DISPPARAMS& dispParams, 
                                                       BOOL bMultiValued, BOOL bUseEx )
{
   HRESULT  hResult;
   int      x= 0;

  
   if( bUseEx )
   {
      return DisplayStringToDispParamsEx( rText, dispParams, bMultiValued );
   }

   
   dispParams.rgdispidNamedArgs[ 0 ]   = DISPID_PROPERTYPUT; 
   dispParams.cArgs                    = 1; 
   dispParams.cNamedArgs               = 1; 

   if( bMultiValued )
   {
      hResult  = CreateBlobArrayEx( rText, dispParams.rgvarg[0] );
   }
   else
   {
      hResult  = CreateBlobArray( rText, dispParams.rgvarg[0] );
   }

   return SUCCEEDED( hResult );
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsOctetString::Native2Value( ADSVALUE* pADsObject, 
                                           CString& rVal )
{
   DWORD    dwItem;
   LPBYTE   lpByte;
   TCHAR    szText[ 128 ];

   lpByte   = pADsObject->OctetString.lpValue;

   ASSERT( lpByte );
   
   _tcscpy( szText, _T("[") );
   _ultot( pADsObject->OctetString.dwLength, szText + _tcslen( szText ), 10 );
   _tcscat( szText, _T("]") );


   for( dwItem = 0L; dwItem < pADsObject->OctetString.dwLength ; dwItem++ )
   {
#ifdef UNICODE
      swprintf( 
#else
      sprintf( 
#endif
               szText + _tcslen(szText), _T(" x%02x"), lpByte[ dwItem ] );

      if( _tcslen( szText ) > 120 )
         break;
   }
   rVal  = szText;

   return S_OK;
}


/***********************************************************
  Function: COleDsOctetString::Value2Native
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT   COleDsOctetString::Value2Native( ADSVALUE* pADsObject, 
                                           CString& rVal )
{
   HRESULT  hResult  = E_FAIL;
   TCHAR*   strText;
   LPBYTE   lpByte;
   int      nSize, nItems, nIdx;
   
   rVal.MakeUpper( );

   strText  = (TCHAR*) new TCHAR[ rVal.GetLength( ) + 1 ];
   if( !strText )
   {
      return E_FAIL;
   }

   _tcscpy( strText, rVal.GetBuffer( rVal.GetLength( ) ) );
   nSize    = rVal.GetLength( );
   nItems   = 0;
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      if( strText[ nIdx ] == _T('X') )
      {
         nItems++;
      }
   }

   lpByte         = (LPBYTE) AllocADsMem( nItems );
   ASSERT( lpByte );
   if ( lpByte ) 
   {
      //SMITHA int   nItems = 0;

      for( nIdx = 0; nIdx < nSize ; nIdx++ )
      {
         if( strText[ nIdx ] == _T('X') )
         {
            lpByte[ nItems++] = GetByteValue( strText + nIdx + 1 );
            while( nIdx < nSize && !isspace( strText[ nIdx ] ) )
               nIdx++;
         }
      }
   }
   pADsObject->OctetString.lpValue  = lpByte;
   pADsObject->OctetString.dwLength = nItems;

   delete [] strText;

   return hResult;
}


/***********************************************************
  Function:    COleDsOctetString::FreeAttrValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  COleDsOctetString::FreeAttrValue( ADSVALUE* pADsValue )
{
   ASSERT( NULL != pADsValue->OctetString.lpValue );

   FREE_MEMORY( pADsValue->OctetString.lpValue );
}


/*******************************************************************
  Function:    GetByteValue
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
*******************************************************************/
BYTE  COleDsOctetString::GetByteValue( TCHAR* szString )
{
   BYTE  bBytes[ 2 ];

   bBytes[ 0 ] = bBytes[ 1 ]  = 0;

   for( int i = 0; i < 2 ; i++ )
   {
      if( !szString[ i ] )
         break;

#ifdef UNICODE
      if( !iswdigit( szString[ i ] ) )
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x37; 
      }
#else
      if( !isdigit( szString[ i ] ) )
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x37; 
      }
#endif
      else
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x30; 
      }
   }

   return ( bBytes[ 0 ] << 4 ) + bBytes[ 1 ];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\cuser.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsUser::COleDsUser( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsUser::COleDsUser( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsUser::~COleDsUser( )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\csession.cpp ===
#include "stdafx.h"
#include "objects.h"
#include "maindoc.h"


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSession::COleDsSession( )
{
   
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSession::COleDsSession( IUnknown *pIUnk): COleDsObject( pIUnk )
{
   m_bHasChildren = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
COleDsSession::~COleDsSession( )
{

}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
HRESULT  COleDsSession::ReleaseIfNotTransient( void )
{
   return S_OK;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CString  COleDsSession::GetDeleteName( )
{
   HRESULT        hResult, hResultX;
   IADsSession* pISess   = NULL;
   CString        strDeleteName;
   BSTR           bstrName;

   hResult  = m_pIUnk->QueryInterface( IID_IADs, (void**) &pISess );
   ASSERT( SUCCEEDED( hResult ) );

   hResultX = pISess->get_Name( &bstrName );
   if( SUCCEEDED( hResultX ) )
   {
      strDeleteName  = bstrName;
      SysFreeString( bstrName );

      return strDeleteName;
   }

   if( SUCCEEDED( hResult ) )
   {
      VARIANT  var;

      hResult  = Get( pISess, _T("User"), &var );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         strDeleteName  = V_BSTR( &var );
         VariantClear( &var );
      }

      hResult  = Get( pISess, _T("Computer"), &var );
      ASSERT( SUCCEEDED( hResult ) );
      if( SUCCEEDED( hResult ) )
      {
         strDeleteName += _T('\\');
         strDeleteName += V_BSTR( &var );
         VariantClear( &var );
      }
      pISess->Release( );
   }
   
   return strDeleteName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\delgrpit.cpp ===
// DeleteGroupItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "delgrpit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CDeleteGroupItem::CDeleteGroupItem(CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteGroupItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDeleteGroupItem)
	m_strItemName = _T("");
	m_strParent = _T("");
	m_strItemType = _T("");
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CDeleteGroupItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteGroupItem)
	DDX_Text(pDX, IDC_ITEMNAME, m_strItemName);
	DDX_Text(pDX, IDC_PARENT, m_strParent);
	DDX_Text(pDX, IDC_ITEMTYPE, m_strItemType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteGroupItem, CDialog)
	//{{AFX_MSG_MAP(CDeleteGroupItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteGroupItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\delgrpit.h ===
// DeleteGroupItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDeleteGroupItem dialog

class CDeleteGroupItem : public CDialog
{
// Construction
public:
	CDeleteGroupItem(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteGroupItem)
	enum { IDD = IDD_GROUPDELETEITEM };
	CString	m_strItemName;
	CString	m_strParent;
	CString	m_strItemType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteGroupItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteGroupItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\delitem.cpp ===
// DeleteItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "delitem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CDeleteItem::CDeleteItem(CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDeleteItem)
	m_strClass = _T("");
	m_strName = _T("");
	m_strParent = _T("");
	m_bRecursive = FALSE;
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CDeleteItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteItem)
	DDX_Text(pDX, IDC_CLASS, m_strClass);
	DDX_Text(pDX, IDC_RELATIVENAME, m_strName);
	DDX_Text(pDX, IDC_PARENTNAME, m_strParent);
	DDX_Check(pDX, IDC_DELETERECURSIVE, m_bRecursive);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteItem, CDialog)
	//{{AFX_MSG_MAP(CDeleteItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDeleteItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\delitem.h ===
// DeleteItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDeleteItem dialog

class CDeleteItem : public CDialog
{
// Construction
public:
	CDeleteItem(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteItem)
	enum { IDD = IDD_DELETEITEM };
	CString	m_strClass;
	CString	m_strName;
	CString	m_strParent;
	BOOL	m_bRecursive;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\enterdlg.cpp ===
// enterdlg.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "viewex.h"
#include "enterdlg.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEnterDlg dialog

IMPLEMENT_DYNAMIC(CEnterDlg, CDialog)

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CEnterDlg::CEnterDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CEnterDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEnterDlg)
	m_strInput = "";
	//}}AFX_DATA_INIT
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CEnterDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEnterDlg)
	DDX_Text(pDX, IDC_EDIT1, m_strInput);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CEnterDlg, CDialog)
	//{{AFX_MSG_MAP(CEnterDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEnterDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\errordlg.h ===
// ErrorDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CErrorDialog dialog

class CErrorDialog : public CDialog
{
// Construction
public:
	CErrorDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CErrorDialog)
	enum { IDD = IDD_ERRORPUTPROP };
	CString	m_Operation;
	CString	m_Result;
	CString	m_Value;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CErrorDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CErrorDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\errordlg.cpp ===
// ErrorDialog.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "errordlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CErrorDialog dialog


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CErrorDialog::CErrorDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CErrorDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CErrorDialog)
	m_Operation = _T("");
	m_Result = _T("");
	m_Value = _T("");
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CErrorDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CErrorDialog)
	DDX_Text(pDX, IDC_ERROROPERATION, m_Operation);
	DDX_Text(pDX, IDC_ERRORRESULT, m_Result);
	DDX_Text(pDX, IDC_ERRORVALUE, m_Value);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CErrorDialog, CDialog)
	//{{AFX_MSG_MAP(CErrorDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CErrorDialog message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\fltrdlg.h ===
// FilterDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFilterDialog dialog

class CFilterDialog : public CDialog
{
// Construction
public:
	CFilterDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CFilterDialog)
	enum { IDD = IDD_FILTER };
	CListBox	m_DoNotDisplayThis;
	CListBox	m_DisplayThis;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFilterDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
	void  SetDisplayFilter( BOOL* pFilters ) { m_pFilters  = pFilters ;}

   // Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFilterDialog)
	afx_msg void OnMoveToDisplay();
	afx_msg void OnMoveToNotDisplay();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
   void  DisplayThisType( DWORD, TCHAR* );
   BOOL* m_pFilters;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\fltrdlg.cpp ===
// FilterDialog.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "fltrdlg.h"
#include "testcore.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFilterDialog dialog


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CFilterDialog::CFilterDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CFilterDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFilterDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CFilterDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFilterDialog)
	DDX_Control(pDX, IDC_DONOTDISPLAYTHIS, m_DoNotDisplayThis);
	DDX_Control(pDX, IDC_DISPLAYTHIS, m_DisplayThis);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFilterDialog, CDialog)
	//{{AFX_MSG_MAP(CFilterDialog)
	ON_BN_CLICKED(IDC_TODISPLAY, OnMoveToDisplay)
	ON_BN_CLICKED(IDC_TONOTDISPLAY, OnMoveToNotDisplay)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFilterDialog message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CFilterDialog::OnMoveToDisplay()
{
	// TODO: Add your control notification handler code here
   int      nIdx;
   DWORD    dwItemData;
   TCHAR    szText[ 128 ];

   nIdx        = m_DoNotDisplayThis.GetCurSel( );
   if( LB_ERR != nIdx )
   {
      dwItemData  = (DWORD)m_DoNotDisplayThis.GetItemData( nIdx );

      m_DoNotDisplayThis.DeleteString( nIdx );
      StringFromType( dwItemData, szText );

      nIdx  = m_DisplayThis.AddString( szText );
      m_DisplayThis.SetItemData( nIdx, dwItemData );

      m_pFilters[ dwItemData ]   = TRUE;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CFilterDialog::OnMoveToNotDisplay()
{
	// TODO: Add your control notification handler code here
	// TODO: Add your control notification handler code here
   int      nIdx;
   DWORD    dwItemData;
   TCHAR    szText[ 128 ];

   nIdx        = m_DisplayThis.GetCurSel( );
   if( LB_ERR != nIdx )
   {
      dwItemData  = (DWORD)m_DisplayThis.GetItemData( nIdx );

      m_DisplayThis.DeleteString( nIdx );
      StringFromType( dwItemData, szText );

      nIdx  = m_DoNotDisplayThis.AddString( szText );
      m_DoNotDisplayThis.SetItemData( nIdx, dwItemData );

      m_pFilters[ dwItemData ]   = FALSE;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CFilterDialog::DisplayThisType( DWORD dwType, TCHAR* pszText )
{
   CListBox*   pListBox;
   int         nIdx;

   if( m_pFilters[ dwType ] )
   {
      pListBox = &m_DisplayThis;
   }
   else
   {
      pListBox = &m_DoNotDisplayThis;
   }

   nIdx  = pListBox->AddString( pszText );
   pListBox->SetItemData( nIdx, dwType );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CFilterDialog::OnInitDialog()
{

	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
   TCHAR szType[ 128 ];

   for( DWORD dwType = 0L ; dwType < LIMIT ; dwType++ )
   {
      if( OTHER == dwType || SCHEMA == dwType )
         continue;

      StringFromType( dwType, szType );
      DisplayThisType( dwType, szType );
   }

   return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\grpcrtit.cpp ===
// GroupCreateItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "grpcrtit.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGroupCreateItem dialog


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CGroupCreateItem::CGroupCreateItem(CWnd* pParent /*=NULL*/)
	: CDialog(CGroupCreateItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGroupCreateItem)
	m_strNewItemName = _T("");
	m_strParent = _T("");
	m_strItemType = _T("");
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CGroupCreateItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGroupCreateItem)
	DDX_Text(pDX, IDC_ITEMNAME, m_strNewItemName);
	DDX_Text(pDX, IDC_PARENT, m_strParent);
	DDX_Text(pDX, IDC_ITEMTYPE, m_strItemType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGroupCreateItem, CDialog)
	//{{AFX_MSG_MAP(CGroupCreateItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGroupCreateItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\enterdlg.h ===
// enterdlg.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CEnterDlg dialog

class CEnterDlg : public CDialog
{
	DECLARE_DYNAMIC(CEnterDlg)
// Construction
public:
	CEnterDlg(CWnd* pParent = NULL);    // standard constructor

// Dialog Data
	//{{AFX_DATA(CEnterDlg)
	enum { IDD = IDD_CHANGEDATA };
	CString m_strInput;
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support

	// Generated message map functions
	//{{AFX_MSG(CEnterDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\inputvw.h ===
// inputvw.h : header file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CInputView form view

class CInputView : public CFormView
{
	DECLARE_DYNCREATE(CInputView)
protected:
	CInputView();           // protected constructor used by dynamic creation

// Form Data
public:
	//{{AFX_DATA(CInputView)
	enum { IDD = IDD_INPUTFORM };
	CString m_strData;
	int     m_iColor;
	//}}AFX_DATA

// Attributes
public:
	CMainDoc* GetDocument()
			{
				ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
				return (CMainDoc*) m_pDocument;
			}

// Operations
public:

// Implementation
protected:
	virtual ~CInputView();
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);

	// Generated message map functions
	//{{AFX_MSG(CInputView)
	afx_msg void OnDataChange();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\grpcrtit.h ===
// GroupCreateItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGroupCreateItem dialog

class CGroupCreateItem : public CDialog
{
// Construction
public:
	CGroupCreateItem(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CGroupCreateItem)
	enum { IDD = IDD_GROUPCREATEITEM };
	CString	m_strNewItemName;
	CString	m_strParent;
	CString	m_strItemType;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGroupCreateItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGroupCreateItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\inputvw.cpp ===
// inputvw.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "viewex.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInputView

IMPLEMENT_DYNCREATE(CInputView, CFormView)

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CInputView::CInputView()
	: CFormView(CInputView::IDD)
{
	//{{AFX_DATA_INIT(CInputView)
	m_strData = "";
	m_iColor = -1;
	//}}AFX_DATA_INIT
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CInputView::~CInputView()
{
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CInputView::OnUpdate(CView*, LPARAM, CObject*)
{
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CInputView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CInputView)
	DDX_Text(pDX, IDC_EDIT1, m_strData);
	DDX_Radio(pDX, IDC_RADIO1, m_iColor);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CInputView, CFormView)
	//{{AFX_MSG_MAP(CInputView)
	ON_EN_CHANGE(IDC_EDIT1, OnDataChange)
	ON_BN_CLICKED(IDC_RADIO1, OnDataChange)
	ON_BN_CLICKED(IDC_RADIO2, OnDataChange)
	ON_BN_CLICKED(IDC_RADIO3, OnDataChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInputView message handlers

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CInputView::OnDataChange()
{
	/*if (!UpdateData())
		return;

	CMainDoc* pDoc = GetDocument();
	COLORREF color = RGB(255 * (m_iColor == 0),
						255 * (m_iColor == 1),
						255 * (m_iColor == 2));

	BOOL bUpdate = FALSE;
	if (m_strData != pDoc->m_strData)
	{
		pDoc->m_strData = m_strData;
		bUpdate = TRUE;
	}
	if (color != pDoc->m_colorData)
	{
		pDoc->m_colorData = color;
		bUpdate = TRUE;
	}
	if (bUpdate)
	{
		// if the document stored data then we would call SetModifiedFlag here
		pDoc->UpdateAllViews(this);
	}*/
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\maindoc.cpp ===
// maindoc.cpp : implementation of the CMainDoc class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "schclss.h"
#include "viewex.h"
#include "enterdlg.h"
#include "fltrdlg.h"
#include "qstatus.h"
#include "newobj.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif


TCHAR szOpen[ MAX_PATH ];

/////////////////////////////////////////////////////////////////////////////
// CMainDoc

IMPLEMENT_SERIAL(CMainDoc, CDocument, 0 /* schema number*/ )

BEGIN_MESSAGE_MAP(CMainDoc, CDocument)
    //{{AFX_MSG_MAP(CMainDoc)
    ON_COMMAND(IDM_CHANGEDATA, OnChangeData)
    ON_COMMAND(IDM_FILTER, OnSetFilter)
    ON_COMMAND(IDM_DISABLEFILTER, OnDisableFilter)
    ON_UPDATE_COMMAND_UI(IDM_DISABLEFILTER, OnUpdateDisablefilter)
    ON_COMMAND(IDM_USEGENERIC, OnUseGeneric)
    ON_UPDATE_COMMAND_UI(IDM_USEGENERIC, OnUpdateUseGeneric)
    ON_UPDATE_COMMAND_UI(IDM_USEGETEXPUTEX, OnUpdateUseGetExPutEx)
    ON_COMMAND(IDM_USEGETEXPUTEX, OnUseGetExPutEx)
    ON_COMMAND(IDM_USEPROPERTIESLIST, OnUsepropertiesList)
    ON_UPDATE_COMMAND_UI(IDM_USEPROPERTIESLIST, OnUpdateUsepropertiesList)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainDoc construction/destruction

//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
CMainDoc::CMainDoc()
{
   m_pClasses        = new CMapStringToOb;
   m_pItems          = new CMapStringToOb;
   m_bApplyFilter    = FALSE;
   m_dwRoot          = 0L;
   m_bUseGeneric     = TRUE;
   m_bUseGetEx       = TRUE;
   //m_bUseGetEx       = FALSE;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
CMainDoc::~CMainDoc()
{
   POSITION       pos;
   CObject*       pItem;
   CString        strItem;
   COleDsObject*  pRoot;

   if( NULL !=  m_pClasses )
   {
      for( pos = m_pClasses->GetStartPosition(); pos != NULL; )
       {
          m_pClasses->GetNextAssoc( pos, strItem, pItem );
         delete pItem;

         #ifdef _DEBUG
              //afxDump << strItem << "\n";
         #endif
       }

      m_pClasses->RemoveAll( );
      delete m_pClasses;
   }

   if( NULL !=  m_pItems )
   {
      for( pos = m_pItems->GetStartPosition(); pos != NULL; )
       {
          m_pItems->GetNextAssoc( pos, strItem, pItem );
         delete pItem;

         /*#ifdef _DEBUG
              afxDump << strItem << "\n";
         #endif*/
       }

      m_pItems->RemoveAll( );
      delete m_pItems;
   }

   pRoot = GetObject( &m_dwRoot );
   if( pRoot )
      delete pRoot;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::CreateFakeSchema( )
{
   CClass*     pClass;
   CProperty*  pProperty;

   pClass      = new CClass( _T("Class"), IID_IADsClass );

   pProperty   = new CProperty( _T("PrimaryInterface"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("CLSID"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("OID"), _T("String") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Abstract"), _T("Boolean") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Auxiliary"), _T("Boolean") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("MandatoryProperties"), _T("String"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("OptionalProperties"), _T("String"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("NamingProperties"), _T("String"), TRUE );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("DerivedFrom"), _T("String"), TRUE );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("AuxDerivedFrom"), _T("String"), TRUE );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("PossibleSuperiors"), _T("String"), TRUE );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Containment"), _T("String"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Container"), _T("Boolean") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("HelpFileName"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("HelpFileContext"), _T("Integer") );
   pClass->AddProperty( pProperty );

   m_pClasses->SetAt( _T("Class"), pClass );

   // Property

   pClass      = new CClass( _T("Property"), IID_IADsProperty );

   pProperty   = new CProperty( _T("OID"), _T("String") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );
   pProperty   = new CProperty( _T("Syntax"), _T("String") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );
   pProperty   = new CProperty( _T("MaxRange"), _T("Integer") );
   pClass->AddProperty( pProperty );
   pProperty   = new CProperty( _T("MinRange"), _T("Integer") );
   pClass->AddProperty( pProperty );
   pProperty   = new CProperty( _T("MultiValued"), _T("Boolean") );
   pProperty->SetMandatory( TRUE );
   pClass->AddProperty( pProperty );

   m_pClasses->SetAt( _T("Property"), pClass );

   // Syntax

   pClass      = new CClass( _T("Syntax"), IID_IADsSyntax );
   pProperty   = new CProperty( _T("OleAutoDataType"), _T("Integer") );
   pClass->AddProperty( pProperty );

   m_pClasses->SetAt( _T("Syntax"), pClass );

   // AccessControlEntry

   pClass      = new CClass( _T("ACE"), IID_IADsAccessControlEntry );

   pProperty   = new CProperty( _T("Trustee"),     _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("AccessMask"),  _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("AceType"),     _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("AceFlags"),    _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Flags"),       _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("ObjectType"),  _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("InheritedObjectType"), _T("String") );
   pClass->AddProperty( pProperty );


   m_pClasses->SetAt( _T("ACE"), pClass );


   // SecurityDescriptor

   pClass      = new CClass( _T("SecurityDescriptor"), 
                             IID_IADsSecurityDescriptor );

   pProperty   = new CProperty( _T("Revision"), _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Control"), _T("Integer") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Owner"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("OwnerDefaulted"), _T("Boolean") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("Group"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("GroupDefaulted"), _T("Boolean") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("SaclDefaulted"), _T("Boolean") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("DaclDefaulted"), _T("Boolean") );
   pClass->AddProperty( pProperty );

   m_pClasses->SetAt( _T("SecurityDescriptor"), pClass );


   // ROOTDSE
   pClass      = new CClass( _T("ROOTDSE"), IID_IADs );

   pProperty   = new CProperty( _T("currentTime"), _T("UTCTime") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("subschemaSubentry"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("serverName"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("namingContexts"), _T("String"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("defaultNamingContext"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("schemaNamingContext"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("configurationNamingContext"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("rootDomainNamingContext"), _T("String") );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("supportedControl"), _T("String"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("supportedVersion"), _T("Integer"), TRUE );
   pClass->AddProperty( pProperty );

   pProperty   = new CProperty( _T("highestCommittedUsn"), _T("Integer8") );
   pClass->AddProperty( pProperty );

   m_pClasses->SetAt( _T("ROOTDSE"), pClass );

   return TRUE;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
DWORD CMainDoc::GetToken( void* pVoid )
{
   DWORD dwToken;

   dwToken  = *(DWORD*) pVoid;

   return   dwToken;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
COleDsObject*  CMainDoc::GetObject( void* pVoid )
{
   COleDsObject*  pObject;

   pObject  = *(COleDsObject**) pVoid;

   return pObject;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void  CMainDoc::SetCurrentItem( DWORD dwToken )
{
   m_dwToken      = dwToken;

   if( NewActiveItem( ) )
   {
      UpdateAllViews( NULL );
   }
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
DWORD CMainDoc::GetChildItemList( DWORD dwToken, 
                                  DWORD* pTokens,
                                  DWORD dwMaxChildren )
{
   CQueryStatus      aQueryStatus;
   COleDsObject*     pOleDsObject   = NULL;
   DWORD             dwFilters, dwChildrenCount=0L;

   pOleDsObject   = GetObject( &dwToken );
   if( !pOleDsObject->HasChildren( ) )
   {
      return 0L;
   }

   aQueryStatus.Create( IDD_QUERYSTATUS );
   aQueryStatus.ShowWindow( SW_SHOW );
   aQueryStatus.UpdateWindow( );

   if( ! pOleDsObject->CreateTheObject( ) )
   {
      TRACE( _T("Warning: could not create the object\n") );
   }
   else
   {
      dwFilters         = m_bApplyFilter ? LIMIT : 0;
      dwChildrenCount   = pOleDsObject->GetChildren( pTokens, 
                                                     dwMaxChildren,
                                                     &aQueryStatus, 
                                                     m_arrFilters,
                                                     dwFilters );
      pOleDsObject->ReleaseIfNotTransient( );
   }
   aQueryStatus.DestroyWindow( );

   return dwChildrenCount;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL CMainDoc::OnOpenDocument( LPCTSTR lpszName )
{
   BOOL     bRez;
   TCHAR    szString[ 1024 ];

   GetPrivateProfileString( _T("Open_ADsPath"), 
                            _T("Value_1"), 
                            _T(""), 
                            szString, 
                            1023, 
                            ADSVW_INI_FILE );
   
   WritePrivateProfileString( _T("Open_ADsPath"), 
                              _T("Value_1"), 
                              lpszName, 
                              ADSVW_INI_FILE );

   bRez     = OnNewDocument( );

   WritePrivateProfileString( _T("Open_ADsPath"), 
                              _T("Value_1"), 
                              szString, 
                              ADSVW_INI_FILE );

   return bRez;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL CMainDoc::OnNewDocument()
{
   CNewObject     aNewObject;
   HRESULT        hResult;

    if (!CDocument::OnNewDocument())
        return FALSE;

   if( aNewObject.DoModal( ) != IDOK )
      return FALSE;

    m_strRoot            = aNewObject.m_strPath;
   m_strUser            = aNewObject.m_strOpenAs;
   m_strPassword        = aNewObject.m_strPassword;
   m_bUseOpenObject     = aNewObject.m_bUseOpen;
   m_bSecure            = aNewObject.m_bSecure;
   m_bEncryption        = aNewObject.m_bEncryption;
   m_bUseVBStyle        = !(aNewObject.m_bUseExtendedSyntax);
   m_bUsePropertiesList = FALSE;

   hResult     = CreateRoot( );

   if( FAILED( hResult ) )
   {
      CString  strErrorText;
      strErrorText   = OleDsGetErrorText ( hResult  );
      AfxMessageBox( strErrorText );
   }
   else
   {
      SetTitle( m_strRoot );
   }

   return SUCCEEDED( hResult );
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::NewActiveItem( )
{
   BOOL           bRez  = TRUE;
/*   TCHAR          szQName[ 128 ];
   CString        strName;
   COleDsObject*  pNewObject;

   MakeQualifiedName( szQName, m_strItemName.GetBuffer( 128 ),
                      m_dwItemType );
   strName  = szQName;
   bRez     = m_pItems->Lookup( strName, (CObject*&) pNewObject );
   ASSERT( bRez );
   m_strDisplayName  = szQName;
   if( m_pObject != NULL )
   {
      m_pObject->ReleaseIfNotTransient( );
   }
   m_pObject   = pNewObject;
   pNewObject->CreateTheObject( );*/

   return bRez;
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc serialization

//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::Serialize(CArchive&)
{
    ASSERT(FALSE);      // this example program does not store data
}

/////////////////////////////////////////////////////////////////////////////
// CMainDoc commands

//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnChangeData()
{
    CEnterDlg dlg;
    if (dlg.DoModal() != IDOK)
        return;
    UpdateAllViews(NULL);   // general update
}

/////////////////////////////////////////////////////////////////////////////

//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnSetFilter()
{
    // TODO: Add your command handler code here
   CFilterDialog  aFilterDialog;

   aFilterDialog.SetDisplayFilter( m_arrFilters );

   aFilterDialog.DoModal( );
}

//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnDisableFilter()
{
    // TODO: Add your command handler code here
   m_bApplyFilter = !m_bApplyFilter;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
COleDsObject* CMainDoc::GetCurrentObject( void )
{
   return GetObject( &m_dwToken );
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::GetUseGeneric( )   
{
   return m_bUseGeneric;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::UseVBStyle( )   
{
   return m_bUseVBStyle;
}



//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::UsePropertiesList( )   
{
   return m_bUsePropertiesList;
}


//***********************************************************
//  Function:  CMainDoc::XOleDsGetObject
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
BOOL  CMainDoc::GetUseGetEx( )   
{
   return m_bUseGetEx;
}


//***********************************************************
//  Function:  
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
CClass*  CMainDoc::CreateClass( COleDsObject* pObject )
{
   CClass*  pClass;
   CString  strSchema;
   CString  strClass;

   strSchema   = pObject->GetSchemaPath( );

   strClass    = pObject->GetClass( );

   if( !strClass.CompareNoCase( _T("Class") ) ||
       !strClass.CompareNoCase( _T("Property") ) ||
       !strClass.CompareNoCase( _T("Syntax") ) )
   {
      if( !strSchema.IsEmpty( ) )
      {
         TRACE(_T("[OLEDS] Error, nonempty schema path for Class, Property or Syntax objects\n" ) );
      }
      strSchema.Empty( );
   }


   if( strSchema.IsEmpty( ) )
   {
      strSchema   = strClass;
   }

   if( 0 == (pObject->GetItemName( ).CompareNoCase( _T("ROOTDSE") ) ) )
   {
      strSchema   = _T("ROOTDSE");
   }

   if( ! m_pClasses->Lookup( strSchema, ( CObject*& )pClass ) )
   {
      // we must create a new class item
      HCURSOR  oldCursor, newCursor;

      newCursor   = LoadCursor( NULL, IDC_WAIT );
      oldCursor   = SetCursor( newCursor );

      pClass   = new CClass( strSchema, this );
      ASSERT( NULL != pClass );

      if( !strClass.CompareNoCase( _T("User") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsUser") );
      }

      if( !strClass.CompareNoCase( _T("Computer") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsComputerOperations") );
      }

      if( !strClass.CompareNoCase( _T("Service") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsServiceOperations") );
      }

      if( !strClass.CompareNoCase( _T("FileService") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsFileServiceOperations") );
      }

      if( !strClass.CompareNoCase( _T("FPNWFileService") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsFileServiceOperations") );
      }

      if( !strClass.CompareNoCase( _T("PrintQueue") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsPrintQueueOperations") );
      }

      if( !strClass.CompareNoCase( _T("Queue") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsPrintQueueOperations") );
      }

      if( !strClass.CompareNoCase( _T("PrintJob") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsPrintJobOperations") );
      }

      if( !strClass.CompareNoCase( _T("Group") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsGroup") );
      }

      if( !strClass.CompareNoCase( _T("localGroup") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsGroup") );
      }

      if( !strClass.CompareNoCase( _T("GlobalGroup") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsGroup") );
      }

      if( !strClass.CompareNoCase( _T("GroupOfNames") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsGroup") );
      }

      if( !strClass.CompareNoCase( _T("GroupOfUniqueNames") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsGroup") );
      }

      if( !strClass.CompareNoCase( _T("person") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsUser") );
      }

      if( !strClass.CompareNoCase( _T("organizationalPerson") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsUser") );
      }

      if( !strClass.CompareNoCase( _T("residentialPerson") ) )
      {
         pClass->LoadMethodsInformation( _T("IADsUser") );
      }

      m_pClasses->SetAt( strSchema, pClass );

      SetCursor( oldCursor );
   }

   return pClass;
}


//***********************************************************
//  Function:  CMainDoc::XOleDsGetObject
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
HRESULT  CMainDoc::XOleDsGetObject( WCHAR* pszwPath, REFIID refiid, 
                                    void** pVoid )
{
   // cahged to add the hack for Win95.
   HRESULT  hResult;
   WCHAR    szOpenAs[ MAX_PATH ];
   WCHAR    szPassword[ MAX_PATH ];
   LONG     lCode = 0L;

   Convert( szOpenAs, m_strUser.GetBuffer( MAX_PATH ) );
   Convert( szPassword, m_strPassword.GetBuffer( MAX_PATH ) );

   if( !m_bUseOpenObject )
   {
      hResult  = ADsGetObject( pszwPath, refiid, pVoid );
   }
   else
   {
      if( m_bSecure )
      {                          
         lCode |= ADS_SECURE_AUTHENTICATION;
      }

      if( m_bEncryption )
      {
         lCode |= ADS_USE_ENCRYPTION;
      }
       // hack fo rDavid...
       //if( L':' == pszwPath[ 3 ] )
      if( FALSE )
      {
         IADsOpenDSObject* pINamespace;
         
         hResult  = ADsGetObject( L"NDS:", 
                                  IID_IADsOpenDSObject, 
                                  (void**)&pINamespace );

         ASSERT( SUCCEEDED( hResult ) );

         if( SUCCEEDED( hResult ) )
         {
            IDispatch*  pIDisp;

            BSTR bstrPath = NULL;
            bstrPath = SysAllocString(pszwPath);
            if (NULL == bstrPath)
                return E_FAIL;
            hResult  = pINamespace->OpenDSObject( pszwPath, 
                                                  _wcsicmp( szOpenAs, L"NULL") ? szOpenAs : NULL, 
                                                  _wcsicmp( szPassword, L"NULL") ? szPassword : NULL,
                                                  lCode, 
                                                  &pIDisp );
            if( SUCCEEDED( hResult ) )
            {
               hResult  = pIDisp->QueryInterface( refiid, pVoid );
               pIDisp->Release( );
            }
            
            pINamespace->Release( );
         }
      }
      else
      {
         hResult  = ADsOpenObject( pszwPath, 
                                   _wcsicmp( szOpenAs, L"NULL") ? szOpenAs : NULL, 
                                   _wcsicmp( szPassword, L"NULL") ? szPassword : NULL,
                                   lCode, 
                                   refiid, 
                                   pVoid );
      }
   }

   return hResult;
}


/*******************************************************************
  Function:    XGetOleDsObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  CMainDoc::PurgeObject( IUnknown* pIUnknown, LPWSTR pszPrefix )
{
   IADs*    pObject;
   HRESULT  hResult;
   BSTR     bstrParent  = NULL;
   IADsContainer* pParent;

   while( TRUE )
   {
      hResult  = pIUnknown->QueryInterface( IID_IADs, (void**)&pObject );
      if( FAILED( hResult ) )
         break;

      hResult  = pObject->get_Parent( &bstrParent );
      pObject->Release( );

      if( NULL != bstrParent )
      {
         hResult  = XOleDsGetObject( bstrParent, IID_IADsContainer, (void**)&pParent );
         if( SUCCEEDED( hResult ) )
         {
            hResult  = ::PurgeObject( pParent, pIUnknown, pszPrefix );
            pParent->Release( );
         }
      }
      SysFreeString( bstrParent );

      break;
   }

   return hResult;
}


/*******************************************************************
  Function:    XGetOleDsObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  CMainDoc::XOleDsGetObject( CHAR* pszPath, REFIID refiid, void** pVoid )
{
   int      nLength;
   WCHAR*   pszwPath;
   HRESULT  hResult;

   nLength  = strlen( pszPath );

   pszwPath = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   if (NULL == pszwPath)
       return E_FAIL;

   memset( pszwPath, 0, ( nLength + 1 ) * sizeof(WCHAR) );

   MultiByteToWideChar( CP_ACP,
                        MB_PRECOMPOSED,
                        pszPath,
                        nLength,
                        pszwPath,
                        nLength + 1 );

   hResult  = XOleDsGetObject( pszwPath, refiid, pVoid );

   free( pszwPath );

   return hResult;
}



//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
DWORD CMainDoc::CreateOleDsItem( COleDsObject* pParent, IADs* pIOleDs )
{
   COleDsObject*  pObject  = NULL;
   HRESULT        hResult;
   IUnknown*      pIUnk;
   BSTR           bstrOleDsPath  = NULL;
   BSTR           bstrClass;

   hResult  = pIOleDs->QueryInterface( IID_IUnknown, (void**)&pIUnk );
   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
      return 0L;

   hResult  = pIOleDs->get_Class( &bstrClass );
   hResult  = pIOleDs->get_ADsPath( &bstrOleDsPath );

   //if( FAILED( hResult ) || NULL == bstrOleDsPath );

   pObject  = CreateOleDsObject( TypeFromString( bstrClass ), pIUnk );
   pIUnk->Release( );

   pObject->SetParent( pParent );
   pObject->SetDocument( this );

   return GetToken( &pObject );
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
HRESULT  CMainDoc::CreateRoot( )
{
   IADs*        pIOleDs;
   HRESULT        hResult;
   HCURSOR        oldCursor, newCursor;
   BSTR            bstrPath;

   CreateFakeSchema( );

   newCursor   = LoadCursor( NULL, IDC_WAIT );
   oldCursor   = SetCursor( newCursor );

   bstrPath    = AllocBSTR( m_strRoot.GetBuffer( 1024 ) );

   hResult     = XOleDsGetObject( bstrPath, IID_IADs, (void**) &pIOleDs );

   SysFreeString( bstrPath );
   if( SUCCEEDED( hResult ) )
   {
      m_dwToken   = CreateOleDsItem( NULL, pIOleDs );
      m_dwRoot    = m_dwToken;
      pIOleDs->Release( );
   }
   SetCursor( oldCursor );

   return hResult;
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void  CMainDoc::DeleteAllItems( )
{
   COleDsObject*  pObject;
   POSITION       pos;
   CString        strItem;
   CObject*       pItem;

   if( NULL !=  m_pClasses )
   {
      for( pos = m_pClasses->GetStartPosition(); pos != NULL; )
       {
          m_pClasses->GetNextAssoc( pos, strItem, pItem );
         delete pItem;

         #ifdef _DEBUG
              //afxDump << strItem << "\n";
         #endif
       }

      m_pClasses->RemoveAll( );
   }

   pObject  = GetObject( &m_dwRoot );

   delete pObject;

   CreateRoot( );
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUpdateDisablefilter(CCmdUI* pCmdUI)
{
    // TODO: Add your command update UI handler code here
    
   pCmdUI->SetCheck( !m_bApplyFilter );
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUseGeneric()
{
    // TODO: Add your command handler code here
    m_bUseGeneric = !m_bUseGeneric;
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUpdateUseGeneric(CCmdUI* pCmdUI)
{
    // TODO: Add your command update UI handler code here
   pCmdUI->SetCheck( m_bUseGeneric );   
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUpdateUseGetExPutEx(CCmdUI* pCmdUI) 
{
    // TODO: Add your command update UI handler code here
   pCmdUI->SetCheck( m_bUseGetEx ); 
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUseGetExPutEx() 
{
    // TODO: Add your command handler code here
   m_bUseGetEx = !m_bUseGetEx;
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUsepropertiesList() 
{
    // TODO: Add your command handler code here
   m_bUsePropertiesList = !m_bUsePropertiesList;
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::OnUpdateUsepropertiesList(CCmdUI* pCmdUI) 
{
    // TODO: Add your command update UI handler code here
   pCmdUI->SetCheck( m_bUsePropertiesList );    
}


//***********************************************************
//  Function:    
//  Arguments:   
//  Return:      
//  Purpose:     
//  Author(s):   
//  Revision:    
//  Date:        
//***********************************************************
void CMainDoc::SetUseGeneric( BOOL bUseGeneric )
{
   m_bUseGeneric  = bUseGeneric;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\maindoc.h ===
// maindoc.h : interface of the CMainDoc class
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "schclss.h"

class CQueryStatus;

class CMainDoc : public CDocument
{
protected: // create from serialization only
	CMainDoc();
	DECLARE_SERIAL(CMainDoc)

// Attributes
public:
	// an example of document specific data

// Implementation
public:
	virtual ~CMainDoc();

	virtual void   Serialize(CArchive& ar);   // overridden for document i/o

   void           SetUseGeneric( BOOL );
   void           SetCurrentItem    ( DWORD dwToken );
   void           DeleteAllItems    ( void          );
   
   DWORD          GetToken          ( void* );
   COleDsObject*  GetObject         ( void* );

   DWORD          GetChildItemList  ( DWORD dwToken, DWORD* pTokens, DWORD dwBufferSize );
   COleDsObject*  GetCurrentObject  ( void                  );
   CClass*        CreateClass       ( COleDsObject*         );
   DWORD          CreateOleDsItem   ( COleDsObject* pParent, IADs* pIOleDs );
   BOOL           GetUseGeneric     ( void );
   BOOL           GetUseGetEx       ( void );
   HRESULT        XOleDsGetObject   ( WCHAR*, REFIID, void**);
   HRESULT        XOleDsGetObject   ( CHAR*,  REFIID, void**);
   HRESULT        PurgeObject       ( IUnknown* pIUnknown, LPWSTR pszPrefix = NULL );
   BOOL           UseVBStyle        ( void );
   BOOL           UsePropertiesList ( void );


protected:
	virtual  BOOL    OnNewDocument( );
   virtual  BOOL    OnOpenDocument( LPCTSTR  );

   BOOL     NewActiveItem        ( );
   HRESULT  CreateRoot           ( );
   BOOL     CreateFakeSchema     ( );

protected:
   DWORD             m_dwToken;
   DWORD             m_dwRoot;
   
   CMapStringToOb*   m_pClasses;
   CMapStringToOb*   m_pItems;
   
   BOOL              m_bApplyFilter;
   BOOL              m_arrFilters[ LIMIT ];
   
   BOOL              m_bUseGeneric;
   BOOL              m_bUseGetEx;
   BOOL              m_bUseVBStyle;

   BOOL              m_bUseOpenObject;
   BOOL              m_bSecure;
   BOOL              m_bEncryption;
   BOOL              m_bUsePropertiesList;
   CString           m_strRoot;
   CString           m_strUser;
   CString           m_strPassword;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainDoc)
	afx_msg void OnChangeData();
	afx_msg void OnSetFilter();
	afx_msg void OnDisableFilter();
	afx_msg void OnUpdateDisablefilter(CCmdUI* pCmdUI);
	afx_msg void OnUseGeneric();
	afx_msg void OnUpdateUseGeneric(CCmdUI* pCmdUI);
	afx_msg void OnUpdateUseGetExPutEx(CCmdUI* pCmdUI);
	afx_msg void OnUseGetExPutEx();
	afx_msg void OnUsepropertiesList();
	afx_msg void OnUpdateUsepropertiesList(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\moveitem.h ===
// MoveItem.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMoveItem dialog

class CMoveItem : public CDialog
{
// Construction
public:
	CMoveItem(CWnd* pParent = NULL);   // standard constructor

public:
   void  SetContainerName( CString );

// Dialog Data
	//{{AFX_DATA(CMoveItem)
	enum { IDD = IDD_MOVEITEM };
	CString	m_strDestination;
	CString	m_strParent;
	CString	m_strSource;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMoveItem)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMoveItem)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\moveitem.cpp ===
// MoveItem.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "MoveItem.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMoveItem dialog

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CMoveItem::CMoveItem(CWnd* pParent /*=NULL*/)
	: CDialog(CMoveItem::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMoveItem)
	m_strDestination = _T("");
	m_strParent = _T("");
	m_strSource = _T("");
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:    CMoveItem::SetParentName
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CMoveItem::SetContainerName( CString strParent )
{
   m_strParent = strParent;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CMoveItem::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMoveItem)
	DDX_Text(pDX, IDC_DESTINATION, m_strDestination);
	DDX_Text(pDX, IDC_PARENT, m_strParent);
	DDX_Text(pDX, IDC_SOURCE, m_strSource);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CMoveItem, CDialog)
	//{{AFX_MSG_MAP(CMoveItem)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMoveItem message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\newobj.h ===
// NewObject.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewObject dialog

class CNewObject : public CDialog
{
// Construction
public:
	CNewObject(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewObject)
	enum { IDD = IDD_OLEDSPATH };
	CButton	m_UseExtendedSyntax;
	CComboBox	m_OpenAs;
	CComboBox	m_OleDsPath;
	CButton	m_Secure;
	CButton	m_Encryption;
	CButton	m_UseOpen;
	CEdit	   m_Password;
	//}}AFX_DATA

public:
   CString& GetObjectPath( );
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewObject)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewObject)
	virtual void OnOK();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
   void  SaveLRUList( int idCBox, TCHAR* szSection, int nMax = 100 );
   void  GetLRUList( int idCBox, TCHAR* szSection );

public:
   CString  m_strPath;
   CString  m_strOpenAs;
   CString  m_strPassword;
   BOOL     m_bUseOpen;
   BOOL     m_bSecure;
   BOOL     m_bEncryption;
   BOOL     m_bUseExtendedSyntax;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\newquery.cpp ===
// NewQuery.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "newquery.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewQuery dialog

#define  ENTRIES_HISTORY 15

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CNewQuery::CNewQuery(CWnd* pParent /*=NULL*/)
	: CDialog(CNewQuery::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewQuery)
	m_strPassword = _T("");
	m_bEncryptPassword = FALSE;
	m_bUseSQL = FALSE;
	m_strScope = _T("");
	m_strAttributes = _T("");
	m_strQuery = _T("");
	m_strSource = _T("");
	m_strUser = _T("");
	m_bUseSearch = FALSE;
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CNewQuery::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewQuery)
	DDX_Text(pDX, IDC_PASSWORD, m_strPassword);
	DDX_Check(pDX, IDC_ENCRYPT, m_bEncryptPassword);
	DDX_Check(pDX, IDC_USESQL, m_bUseSQL);
	DDX_CBString(pDX, IDC_SCOPE, m_strScope);
	DDX_Check(pDX, IDC_USESEARCH, m_bUseSearch);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewQuery, CDialog)
	//{{AFX_MSG_MAP(CNewQuery)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewQuery message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CNewQuery::OnInitDialog()
{
	CString  strLastValue;

  // GetLastProfileString( _T("LastADsQueryPassword"), m_strPassword );
   m_strPassword = _T("");
   SetLastProfileString( _T("LastADsQueryPassword"), m_strPassword);

   GetLastProfileString( _T("LastADsQueryEncryptPassword"), strLastValue );

   m_bEncryptPassword   = strLastValue.CompareNoCase( _T("No") );

   GetLastProfileString( _T("LastADsQueryUseSQL"), strLastValue );
   m_bUseSQL            = !( strLastValue.CompareNoCase( _T("Yes") ) );

   GetLastProfileString( _T("LastADsQueryUseDsSearch"), strLastValue );
   m_bUseSearch         = !( strLastValue.CompareNoCase( _T("Yes") ) );

   GetLRUList( IDC_ATTRIBUTES,  _T("Query_Attributes") );
   GetLRUList( IDC_QUERY,       _T("Query_Query")      );
   GetLRUList( IDC_SOURCE,      _T("Query_Source")     );
   GetLRUList( IDC_USER,        _T("Query_OpenAs")     );

   CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CNewQuery::OnOK()
{
	// TODO: Add extra validation here
   CString  strVal;
	
	CDialog::OnOK();

   GetDlgItemText( IDC_ATTRIBUTES,  m_strAttributes );
   GetDlgItemText( IDC_QUERY,       m_strQuery  );
   GetDlgItemText( IDC_SOURCE,      m_strSource );
   GetDlgItemText( IDC_PASSWORD,    m_strPassword );
   GetDlgItemText( IDC_USER,        m_strUser );
   GetDlgItemText( IDC_SCOPE,       m_strScope );

   m_bEncryptPassword   =  ( (CButton*)GetDlgItem( IDC_ENCRYPT ) )->GetCheck( );
   m_bUseSQL            =  ( (CButton*)GetDlgItem( IDC_USESQL ) )->GetCheck( );
   m_bUseSearch         =  ( (CButton*)GetDlgItem( IDC_USESEARCH ) )->GetCheck( );


//   SetLastProfileString( _T("LastADsQueryPassword"), m_strPassword );

   strVal   = m_bEncryptPassword ? _T("Yes") : _T("No");
   SetLastProfileString( _T("LastADsQueryEncryptPassword"), strVal );

   strVal   = m_bUseSQL ? _T("Yes") : _T("No");
   SetLastProfileString( _T("LastADsQueryUseSQL"), strVal );

   strVal   = m_bUseSearch ? _T("Yes") : _T("No");
   SetLastProfileString( _T("LastADsQueryUseDsSearch"), strVal );

   SaveLRUList( IDC_ATTRIBUTES,  _T("Query_Attributes"), 100 );
   SaveLRUList( IDC_QUERY,       _T("Query_Query"),      100 );
   SaveLRUList( IDC_SOURCE,      _T("Query_Source"),     100 );
   SaveLRUList( IDC_USER,        _T("Query_OpenAs"),     100 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CNewQuery::SaveLRUList( int idCBox, TCHAR* pszSection, int nMax )
{
   CComboBox*  pCombo;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   CString     strText, strItem;
   int         nVal, nIdx, nItems;

   pCombo   = (CComboBox*)GetDlgItem( idCBox );
   pCombo->GetWindowText( strText );

   _tcscpy( szEntry, _T("Value_1") );

   if( strText.GetLength( ) )
   {
      WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strText, ADSVW_INI_FILE );
   }

   nItems   = pCombo->GetCount( );
   nVal     = 2;

   for( nIdx = 0; nItems != CB_ERR && nIdx < nItems && nIdx < nMax ; nIdx ++ )
   {
      pCombo->GetLBText( nIdx, strItem );

      if( strItem.CompareNoCase( strText ) )
      {
         _itot( nVal++, szIndex, 10 );
         _tcscpy( szEntry, _T("Value_") );
         _tcscat( szEntry, szIndex );
         WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strItem, ADSVW_INI_FILE );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CNewQuery::GetLRUList( int idCBox, TCHAR* pszSection )
{
   CComboBox*  pCombo;
   int         nIter;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   TCHAR       szValue[ 1024 ];

   pCombo   = (CComboBox*)GetDlgItem( idCBox );

   for( nIter = 0; nIter < ENTRIES_HISTORY ; nIter++ )
   {
      _itot( nIter + 1, szIndex, 10 );
      _tcscpy( szEntry, _T("Value_") );
      _tcscat( szEntry, szIndex );
      GetPrivateProfileString( pszSection, szEntry,
                               _T(""), szValue, 1023, ADSVW_INI_FILE );
      if( _tcslen( szValue ) )
      {
         pCombo->AddString( szValue );
      }
   }

   pCombo->SetCurSel( 0 );
}
/////////////////////////////////////////////////////////////////////////////
// CSearchPreferencesDlg dialog


CSearchPreferencesDlg::CSearchPreferencesDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CSearchPreferencesDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSearchPreferencesDlg)
	m_strAsynchronous = _T("");
	m_strAttributesOnly = _T("");
	m_strDerefAliases = _T("");
	m_strPageSize = _T("");
	m_strScope = _T("");
	m_strSizeLimit = _T("");
	m_strTimeLimit = _T("");
	m_strTimeOut = _T("");
   m_strChaseReferrals = _T("");
	//}}AFX_DATA_INIT
}


void CSearchPreferencesDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSearchPreferencesDlg)
	DDX_Text(pDX, IDC_ASYNCHRONOUS, m_strAsynchronous);
	DDX_Text(pDX, IDC_ATTR_ONLY, m_strAttributesOnly);
	DDX_Text(pDX, IDC_DEREF_ALIASES, m_strDerefAliases);
	DDX_Text(pDX, IDC_PAGE_SIZE, m_strPageSize);
	DDX_Text(pDX, IDC_SCOPE, m_strScope);
	DDX_Text(pDX, IDC_SIZE_LIMIT, m_strSizeLimit);
	DDX_Text(pDX, IDC_TIME_LIMIT, m_strTimeLimit);
	DDX_Text(pDX, IDC_TIME_OUT, m_strTimeOut);
   DDX_Text(pDX, IDC_CHASE_REFERRALS, m_strChaseReferrals);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSearchPreferencesDlg, CDialog)
	//{{AFX_MSG_MAP(CSearchPreferencesDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSearchPreferencesDlg message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CSearchPreferencesDlg::OnInitDialog()
{
   GetLastProfileString( _T("SearchPref_Asynchronous"),  m_strAsynchronous );
   GetLastProfileString( _T("SearchPref_AttributesOnly"),m_strAttributesOnly );
   GetLastProfileString( _T("SearchPref_DerefAliases"),  m_strDerefAliases );
   GetLastProfileString( _T("SearchPref_PageSize"),      m_strPageSize );
   GetLastProfileString( _T("SearchPref_Scope"),         m_strScope );
   GetLastProfileString( _T("SearchPref_SizeLimit"),     m_strSizeLimit );
   GetLastProfileString( _T("SearchPref_TimeLimit"),     m_strTimeLimit );
   GetLastProfileString( _T("SearchPref_TimeOut"),       m_strTimeOut );
   GetLastProfileString( _T("SearchPref_ChaseReferrals"),m_strChaseReferrals );

   CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSearchPreferencesDlg::OnOK()
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();

   SetLastProfileString( _T("SearchPref_Asynchronous"),  m_strAsynchronous );
   SetLastProfileString( _T("SearchPref_AttributesOnly"),m_strAttributesOnly );
   SetLastProfileString( _T("SearchPref_DerefAliases"),  m_strDerefAliases );
   SetLastProfileString( _T("SearchPref_PageSize"),      m_strPageSize );
   SetLastProfileString( _T("SearchPref_Scope"),         m_strScope );
   SetLastProfileString( _T("SearchPref_SizeLimit"),     m_strSizeLimit );
   SetLastProfileString( _T("SearchPref_TimeLimit"),     m_strTimeLimit );
   SetLastProfileString( _T("SearchPref_TimeOut"),       m_strTimeOut );
   SetLastProfileString( _T("SearchPref_ChaseReferrals"),m_strChaseReferrals );
}
/////////////////////////////////////////////////////////////////////////////
// CACEDialog dialog


CACEDialog::CACEDialog(CWnd* pParent )
	: CDialog(CACEDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CACEDialog)
	m_strTrustee = _T("");
	//}}AFX_DATA_INIT
}


void CACEDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CACEDialog)
	DDX_Text(pDX, IDC_TRUSTEE, m_strTrustee);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CACEDialog, CDialog)
	//{{AFX_MSG_MAP(CACEDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\newquery.h ===
// NewQuery.h : header file
//
#include "resource.h"
/////////////////////////////////////////////////////////////////////////////
// CNewQuery dialog

class CNewQuery : public CDialog
{
// Construction
public:
	CNewQuery(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CNewQuery)
	enum { IDD = IDD_NEWQUERY };
   CString	m_strPassword;
	BOOL	m_bEncryptPassword;
	BOOL	m_bUseSQL;
	CString	m_strScope;
	BOOL	m_bUseSearch;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNewQuery)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

   private:

   void  SaveLRUList( int idCBox, TCHAR* szSection, int nMax = 100 );
   void  GetLRUList( int idCBox, TCHAR* szSection );

   
public:
   
   CString	m_strAttributes;
	CString	m_strQuery;
	CString	m_strSource;
	CString	m_strUser;


// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNewQuery)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CSearchPreferencesDlg dialog

class CSearchPreferencesDlg : public CDialog
{
// Construction
public:
	CSearchPreferencesDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSearchPreferencesDlg)
	enum { IDD = IDD_SEARCHPREFERENCES };
	CString	m_strAsynchronous;
	CString	m_strAttributesOnly;
	CString	m_strDerefAliases;
	CString	m_strPageSize;
	CString	m_strScope;
	CString	m_strSizeLimit;
	CString	m_strTimeLimit;
	CString	m_strTimeOut;
   CString	m_strChaseReferrals;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSearchPreferencesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSearchPreferencesDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
// CACEDialog dialog

class CACEDialog : public CDialog
{
// Construction
public:
	CACEDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CACEDialog)
	enum { IDD = IDD_ADDACEDLG };
	CString	m_strTrustee;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CACEDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CACEDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\objects.h ===
#ifndef  _OBJECTS_H_
#define  _OBJECTS_H_

#include "schclss.h" 

#define  MEMBERS  IADsMembers

class CMainDoc;

class CClass;

class CDeleteStatus;

class COleDsObject: public CObject
{

public:   
   COleDsObject( IUnknown* );
   COleDsObject( );
   ~COleDsObject( );

public:
   BOOL              HasChildren          (           );
   CString           GetClass             (           );
   DWORD             GetType              (           );
   CString           GetOleDsPath         (           );
   CString           GetItemName          (           );
   CString*          PtrGetItemName       (           );
   CString           GetSchemaPath        (           );
   HRESULT           SetInfo              ( void      );
   HRESULT           GetInfo              ( void      );

   HRESULT           SetInfoVB            ( void      );
   HRESULT           GetInfoVB            ( void      );

   HRESULT           SetInfoCPP           ( void      );
   HRESULT           GetInfoCPP           ( void      );

   virtual  HRESULT  PutProperty          ( int, CString&, long Code = ADS_PROPERTY_UPDATE );
   virtual  HRESULT  PutProperty          ( CString&, CString& );

   virtual  HRESULT  GetProperty          ( int, CString&, BOOL* pbIsDescriptor = NULL );
   virtual  HRESULT  GetProperty          ( CString&, CString& );


   HRESULT        PutProperty             ( CString& strName, CString& strVal, BOOL bMultiValued, ADSTYPE eType );
   HRESULT        GetProperty             ( CString& strName, CString& strVal, BOOL bMultiValued, ADSTYPE eType );

   HRESULT        PutPropertyVB           ( int, CString&, long Code = ADS_PROPERTY_UPDATE );
   HRESULT        PutPropertyVB           ( CString&, CString& );
   HRESULT        GetPropertyVB           ( int, CString&, BOOL* pbIsDescriptor = NULL );
   HRESULT        GetPropertyVB           ( CString&, CString& );

   
   HRESULT        PutPropertyCPP          ( int, CString&, long Code = ADS_PROPERTY_UPDATE );
   HRESULT        PutPropertyCPP          ( CString&, CString& );                       
   HRESULT        GetPropertyCPP          ( int, CString&, BOOL* pbIsDescriptor = NULL );
   HRESULT        GetPropertyCPP          ( CString&, CString& );                       



   virtual        void   SetDocument          ( CMainDoc* );
   
   BOOL              CreateTheObject      (           );
   BOOL              HasMandatoryProperties( );
   void              UseSchemaInformation ( BOOL      );
   COleDsObject*     GetParent            ( );
   void              SetParent            ( COleDsObject* );

   virtual  BOOL     AddItemSuported      ( );
   virtual  BOOL     DeleteItemSuported   ( );
   virtual  BOOL     MoveItemSupported    ( );
   virtual  BOOL     CopyItemSupported    ( );
   virtual  HRESULT  AddItem              ( );
   virtual  HRESULT  DeleteItem           ( );
   virtual  HRESULT  DeleteItem           ( COleDsObject* );

   virtual  HRESULT  MoveItem             ( );
   virtual  HRESULT  CopyItem             ( );
   virtual  CString  GetDeleteName        ( );

   virtual  DWORD    GetChildren( DWORD*     pTokens, DWORD dwMaxChildren,
                                  CDialog*   pQueryStatus,
                                  BOOL*      pFilters, DWORD dwFilters );


   HRESULT  CallMethod     ( int nMethod         );
   //HRESULT  CallMethod     ( CString& strFuncSet, int nMethod  );

   virtual  DWORD    GetChildren( IADsContainer*             );
   virtual  DWORD    GetChildren( IADsCollection*            );
   virtual  DWORD    GetChildren( MEMBERS*          );

   virtual  HRESULT  ReleaseIfNotTransient( void               );

   void     AddNamesFromEnum     ( IUnknown*     pIEnum         );

   HRESULT  ContainerAddItem     ( void            );
   HRESULT  ContainerDeleteItem  ( COleDsObject*   );
   HRESULT  ContainerMoveItem    ( void            );
   HRESULT  ContainerCopyItem    (                 );

   virtual  HRESULT  GetInterface        ( IUnknown** );

   /*****************************************/
   virtual  int         GetPropertyCount           (  );
   virtual  CString     VarToDisplayString         ( int, VARIANT&, BOOL );
   virtual  BOOL        DisplayStringToDispParams  ( int, CString&, DISPPARAMS&, BOOL );

   virtual  BOOL        SupportContainer( void );

   virtual  CString  GetAttribute( CLASSATTR ); 
   virtual  HRESULT  PutAttribute( CLASSATTR, CString& ); 

   virtual  CString  GetAttribute( int, PROPATTR ); 
   virtual  HRESULT  PutAttribute( int, PROPATTR, CString& ); 

   virtual  CString  GetAttribute( int, METHODATTR ); 
   virtual  HRESULT  PutAttribute( int, METHODATTR, CString& ); 

protected:
   HRESULT        GetIDispatchForFuncSet( int, IDispatch** ); 

   HRESULT        CopyAttributeValue   ( ADS_ATTR_INFO* , int nAttribute = -1 );
   HRESULT        CreateAttributeValue ( ADS_ATTR_INFO* , int nAttribute = -1 );
   void           CreateClassInfo      ( void );
   HRESULT        GetDirtyAttributes   ( PADS_ATTR_INFO* ppAttrDef, DWORD* pdwCount );
   void           FreeDirtyAttributes  ( PADS_ATTR_INFO pAttrDef, DWORD dwCount );
   HRESULT        CreatePropertiesList ( );
   HRESULT        ClearPropertiesList  ( );
   HRESULT        GetPropertyFromList  ( int nProp, CString& strPropValue );
   BOOL           IsClassObject        ( );
   BOOL           IsSecurityDescriptor ( VARIANT& rValue, BOOL bUseGetEx );
   HRESULT        PurgeObject          ( IADsContainer* pParent, 
                                         IUnknown* pIUnknown, 
                                         LPWSTR pszPrefix = NULL );

protected:
   IUnknown*      m_pIUnk;
   CString        m_strOleDsPath;
   CString        m_strClassName;
   CString        m_strItemName;
   CString        m_strSchemaPath;
   DWORD          m_dwType;
   BOOL           m_bHasChildren;
   BOOL           m_bUseSchemaInformation;
   BOOL           m_bSupportAdd;
   BOOL           m_bSupportDelete;
   BOOL           m_bSupportMove;
   BOOL           m_bSupportCopy;

   // members for enumerating children
   DWORD*         m_pTokens;
   DWORD          m_dwMaxCount;
   DWORD          m_dwCount;
   DWORD          m_dwFilters;
   BOOL*          m_pFilters;
   CDialog*       m_pQueryStatus;
   BOOL           m_bAbort;
   CClass*        m_pClass;
   COleDsObject*  m_pParent;
   CMainDoc*      m_pDoc;
   CDWordArray*   m_pChildren;
   CDeleteStatus* m_pDeleteStatus;

   // operations information;
   int            m_nOperationsCount;
   CStringArray*  m_pOperationNames;
   REFIID         m_refOperations;

   // extended syntax values
   CString*       m_pCachedValues;
   BOOL*          m_pfReadValues;
   BOOL*          m_pfDirty;
   DWORD*         m_pdwUpdateType;

   // IPropertyList stuff
   int            m_nPropertiesCount;
   IUnknown**     m_ppPropertiesEntries;
};

#include "cdomain.h"
#include "cgeneric.h"
#include "ccomp.h"
#include "cuser.h"
#include "cgroup.h"
#include "cservice.h"
#include "cfserv.h"
#include "cpqueue.h"
#include "cpjob.h"
#include "cpdevice.h"
#include "cfshare.h"
#include "csession.h"
#include "cresourc.h"
#include "cnmsp.h"
#include "cnmsps.h"



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\objprops.cpp ===
// ObjectProps.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "objprops.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CObjectProps

IMPLEMENT_DYNCREATE(CObjectProps, CFormView)

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CObjectProps::CObjectProps()
	: CFormView(CObjectProps::IDD)
{
	//{{AFX_DATA_INIT(CObjectProps)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CObjectProps::~CObjectProps()
{
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CObjectProps::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CObjectProps)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CObjectProps, CFormView)
	//{{AFX_MSG_MAP(CObjectProps)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CObjectProps diagnostics

#ifdef _DEBUG
/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CObjectProps::AssertValid() const
{
	CFormView::AssertValid();
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CObjectProps::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CObjectProps message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\newobj.cpp ===
// NewObject.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "newobj.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewObject dialog


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CNewObject::CNewObject(CWnd* pParent /*=NULL*/)
	: CDialog(CNewObject::IDD, pParent)
{
	//{{AFX_DATA_INIT(CNewObject)
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CNewObject::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNewObject)
	DDX_Control(pDX, IDC_USEEXTENDEDSYNTAX, m_UseExtendedSyntax);
	DDX_Control(pDX, IDC_OPENAS, m_OpenAs);
	DDX_Control(pDX, IDC_OLEDSPATH, m_OleDsPath);
	DDX_Control(pDX, IDC_SECUREAUTHENTICATION, m_Secure);
	DDX_Control(pDX, IDC_ENCRYPTION, m_Encryption);
	DDX_Control(pDX, IDC_USEOPEN, m_UseOpen);
	DDX_Control(pDX, IDC_PASSWORD, m_Password);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewObject, CDialog)
	//{{AFX_MSG_MAP(CNewObject)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewObject message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CNewObject::OnOK()
{
   CString strVal;

   // TODO: Add extra validation here
	m_OleDsPath.GetWindowText( m_strPath );
   SaveLRUList( IDC_OLEDSPATH, _T("Open_ADsPath"), 100 );

	m_OpenAs.GetWindowText( m_strOpenAs );
   SaveLRUList( IDC_OPENAS,  _T("Open_OpenAs"), 100 );

   m_Password.GetWindowText( m_strPassword );
   //SetLastProfileString( _T("LastPassword"), m_strPassword );

   //*******************
   m_bUseOpen  = m_UseOpen.GetCheck( );
   strVal      = m_bUseOpen ? _T("Yes") : _T("No");
   SetLastProfileString( _T("UseOpen"), strVal );

   //*******************
   m_bSecure   = m_Secure.GetCheck( );
   strVal      = m_bSecure ? _T("Yes") : _T("No");
   SetLastProfileString( _T("Secure"), strVal );

   //*******************
   m_bEncryption  = m_Encryption.GetCheck( );
   strVal         = m_bEncryption ? _T("Yes") : _T("No");
   SetLastProfileString( _T("Encryption"), strVal );

   //*******************
   m_bUseExtendedSyntax = m_UseExtendedSyntax.GetCheck( );
   strVal               = m_bUseExtendedSyntax ? _T("Yes") : _T("No");
   SetLastProfileString( _T("UseExtendedSyntax"), strVal );

   CDialog::OnOK();
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString& CNewObject::GetObjectPath()
{
	return m_strPath;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CNewObject::SaveLRUList( int idCBox, TCHAR* pszSection, int nMax )
{
   CComboBox*  pCombo;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   CString     strText, strItem;
   int         nVal, nIdx, nItems;

   pCombo   = (CComboBox*)GetDlgItem( idCBox );
   pCombo->GetWindowText( strText );

   _tcscpy( szEntry, _T("Value_1") );

   if( strText.GetLength( ) )
   {
      WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strText, ADSVW_INI_FILE );
   }

   nItems   = pCombo->GetCount( );
   nVal     = 2;

   for( nIdx = 0; nItems != CB_ERR && nIdx < nItems && nIdx < nMax ; nIdx ++ )
   {
      pCombo->GetLBText( nIdx, strItem );

      if( strItem.CompareNoCase( strText ) )
      {
         _itot( nVal++, szIndex, 10 );
         _tcscpy( szEntry, _T("Value_") );
         _tcscat( szEntry, szIndex );
         WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strItem, ADSVW_INI_FILE );
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CNewObject::GetLRUList( int idCBox, TCHAR* pszSection )
{
   CComboBox*  pCombo;
   int         nIter;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   TCHAR       szValue[ 1024 ];

   pCombo   = (CComboBox*)GetDlgItem( idCBox );

   for( nIter = 0; nIter < 100 ; nIter++ )
   {
      _itot( nIter + 1, szIndex, 10 );
      _tcscpy( szEntry, _T("Value_") );
      _tcscat( szEntry, szIndex );
      GetPrivateProfileString( pszSection, szEntry,
                               _T(""), szValue, 1023, ADSVW_INI_FILE );
      if( _tcslen( szValue ) )
      {
         pCombo->AddString( szValue );
      }
   }

   pCombo->SetCurSel( 0 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CNewObject::OnInitDialog()
{
	CString  strLastValue;

   CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
   //*******************

   GetLRUList( IDC_OLEDSPATH, _T("Open_ADsPath") );

	GetLRUList( IDC_OPENAS,  _T("Open_OpenAs") );

   //*******************
   strLastValue = _T("");
   SetLastProfileString( _T("LastPassword"), strLastValue );
   //GetLastProfileString( _T("LastPassword"), strLastValue );
   if( !strLastValue.GetLength( ) )
   {
      strLastValue   = _T("");
   }
   m_Password.SetWindowText( strLastValue );

   //*******************
   GetLastProfileString( _T("UseOpen"), strLastValue );
   if( !strLastValue.CompareNoCase( _T("No") ) )
   {
      m_UseOpen.SetCheck( 0 );
   }
   else
   {
      m_UseOpen.SetCheck( 1 );
   }

   //*******************
   GetLastProfileString( _T("Secure"), strLastValue );
   if( !strLastValue.CompareNoCase( _T("No") ) )
   {
      m_Secure.SetCheck( 0 );
   }
   else
   {
      m_Secure.SetCheck( 1 );
   }

   //*******************
   GetLastProfileString( _T("Encryption"), strLastValue );
   if( !strLastValue.CompareNoCase( _T("No") ) )
   {
      m_Encryption.SetCheck( 0 );
   }
   else
   {
      m_Encryption.SetCheck( 1 );
   }

   //*******************
   GetLastProfileString( _T("UseExtendedSyntax"), strLastValue );
   if( !strLastValue.CompareNoCase( _T("Yes") ) )
   {
      m_UseExtendedSyntax.SetCheck( 1 );
   }
   else
   {
      m_UseExtendedSyntax.SetCheck( 0 );
   }


	return FALSE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\objprops.h ===
// ObjectProps.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CObjectProps form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CObjectProps : public CFormView
{
protected:
	CObjectProps();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CObjectProps)

// Form Data
public:
	//{{AFX_DATA(CObjectProps)
	enum { IDD = IDD_SCHEMA };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CObjectProps)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CObjectProps();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CObjectProps)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\objects.cpp ===
#include "stdafx.h"
#include "resource.h"
#include "qstatus.h"
#include "createit.h"
#include "copyitem.h"
#include "moveitem.h"
#include "delitem.h"
#include "maindoc.h"
#include "objects.h"
#include "cacls.h"
#include "schemavw.h"
#include "csyntax.h"
#include "qstatus.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

#define  NEXT_COUNT  1

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
COleDsObject::COleDsObject( ):m_refOperations(IID_IUnknown)
{
   m_pIUnk                 = NULL;
   m_bUseSchemaInformation = TRUE;
   m_pClass                = NULL;
   m_pParent               = NULL;
   m_bSupportAdd           = FALSE;
   m_bSupportDelete        = TRUE;
   m_bSupportMove          = FALSE;
   m_bSupportCopy          = FALSE;
   m_dwCount               = 0L;
   m_pfReadValues          = NULL;
   m_pCachedValues         = NULL;
   m_pdwUpdateType         = NULL;
   m_pfDirty               = NULL;
   m_nPropertiesCount      = 0;
   m_ppPropertiesEntries   = NULL;
   m_pChildren             = NULL;
   m_pDeleteStatus         = NULL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  COleDsObject::SetDocument( CMainDoc* pMainDoc )
{
   m_pDoc   = pMainDoc;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
COleDsObject::COleDsObject( IUnknown*  pIUnk ):m_refOperations(IID_IUnknown)
{
   IADs*    pIOleDs  = NULL;
   BSTR     bstrClass   = NULL;
   BSTR     bstrOleDsPath  = NULL;
   BSTR     bstrName    = NULL;
   BSTR     bstrSchemaPath = NULL;
   HRESULT  hResult;


   m_nPropertiesCount      = 0;
   m_ppPropertiesEntries   = NULL;
   m_pDoc                  = NULL;
   m_pChildren             = new CDWordArray;
   m_bUseSchemaInformation = TRUE;

   m_pIUnk                 = pIUnk;
   m_pIUnk->AddRef( );

   m_pClass                = NULL;
   m_pParent               = NULL;
   m_bSupportAdd           = FALSE;
   m_bSupportDelete        = TRUE;
   m_bSupportMove          = FALSE;
   m_bSupportCopy          = FALSE;
   m_dwType                = (DWORD)-1L;
   m_pfReadValues          = NULL;
   m_pCachedValues         = NULL;
   m_pfDirty               = NULL;
   m_pdwUpdateType         = NULL;


   hResult  = pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );

   {
      IADsContainer*  pIContainer;

      if( SUCCEEDED( pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer ) ) )
      {
         pIContainer->Release( );
         m_bSupportMove          = TRUE;
         m_bSupportCopy          = TRUE;
      }
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( SUCCEEDED( hResult ))
   {
      pIOleDs->get_Class      ( &bstrClass      );
      CheckIfValidClassName   ( bstrClass );
      pIOleDs->get_ADsPath  ( &bstrOleDsPath  );
      pIOleDs->get_Name       ( &bstrName       );

      m_strClassName = bstrClass;
      m_strItemName  = bstrName;
      m_strOleDsPath = bstrOleDsPath;

      m_dwType       = TypeFromString( bstrClass );
      ASSERT( m_dwType != -1L );
      SysFreeString( bstrClass );
      SysFreeString( bstrOleDsPath );
      SysFreeString( bstrName );

      hResult           = pIOleDs->get_Schema( &bstrSchemaPath );
      if( SUCCEEDED( hResult ) )
      {
         m_strSchemaPath   = bstrSchemaPath;
         SysFreeString( bstrSchemaPath );
      }

      pIOleDs->Release( );
   }
   m_pDeleteStatus         = NULL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
COleDsObject*  COleDsObject::GetParent( )
{
   return m_pParent;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  COleDsObject::SetParent( COleDsObject* pParent )
{
   m_pParent   = pParent;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL     COleDsObject::AddItemSuported( )
{
   return   m_bSupportAdd;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::DeleteItemSuported( )
{
   return   m_bSupportDelete;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::MoveItemSupported( )
{
   return   m_bSupportMove;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::CopyItemSupported( )
{
   return   m_bSupportCopy;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::AddItem( )
{
   return E_FAIL;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::DeleteItem( )
{
   HRESULT  hResult;

   if( NULL == m_pParent )
   {
      return E_FAIL;
   }

   m_pParent->CreateTheObject( );
   hResult  = m_pParent->DeleteItem( this );
   m_pParent->ReleaseIfNotTransient( );

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::DeleteItem( COleDsObject* )
{
   return E_FAIL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::MoveItem( )
{
   CMoveItem         aMoveItem;
   BSTR              bstrSource;
   BSTR              bstrNewName;
   HRESULT           hResult  = E_FAIL;
   IADsContainer*  pIContainer;
   IDispatch*         pIUnk;
   ULONG             ulRef;

   aMoveItem.SetContainerName( m_strOleDsPath );
   if( IDOK == aMoveItem.DoModal( ) )
   {
      bstrSource        = AllocBSTR( aMoveItem.m_strSource.GetBuffer( 512 ) );
      bstrNewName       = AllocBSTR( aMoveItem.m_strDestination.GetBuffer( 512 ) );
      hResult           = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pIContainer->MoveHere( bstrSource, bstrNewName, &pIUnk );
         ulRef    = pIUnk->Release( );
         ASSERT( !ulRef );
         pIContainer->Release( );
      }
      SysFreeString( bstrSource );
      SysFreeString( bstrNewName );
   }

   return hResult;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::CopyItem( )
{
   CCopyItem         aCopyItem;
   BSTR              bstrSource;
   BSTR              bstrNewName;
   HRESULT           hResult  = E_FAIL;;
   IADsContainer*  pIContainer;
   IDispatch*         pIUnk;
   ULONG             ulRef;

   aCopyItem.SetContainerName( m_strOleDsPath );
   if( IDOK == aCopyItem.DoModal( ) )
   {
      bstrSource        = AllocBSTR( aCopyItem.m_strSource.GetBuffer( 512 ) );
      bstrNewName       = AllocBSTR( aCopyItem.m_strDestination.GetBuffer( 512 ) );
      hResult           = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pIContainer->CopyHere( bstrSource, bstrNewName, &pIUnk );
         ulRef    = pIUnk->Release( );
         ASSERT( !ulRef );
         pIContainer->Release( );
      }
      SysFreeString( bstrSource );
      SysFreeString( bstrNewName );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ContainerAddItem( void )
{
   CCreateItem       aCreateItem;
   BSTR              bstrClass;
   BSTR              bstrRelativeName;
   IADsContainer*    pIContainer;
   HRESULT           hResult;
   IDispatch*        pNewItem;
   IADs*             pNewIOleDs;
   CString           strQualifiedName;

   // build the name for diplay purposes
   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   aCreateItem.m_strParent = strQualifiedName;
   if( aCreateItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   // get object name and class
   bstrClass         = AllocBSTR( aCreateItem.m_strClass.GetBuffer(128) );
   bstrRelativeName  = AllocBSTR( aCreateItem.m_strRelativeName.GetBuffer(128) );

   // good point, check if the parent object implements the IADsContainer interface
   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return hResult;
   }

   // make the call for create
   hResult  = pIContainer->Create( bstrClass, bstrRelativeName, &pNewItem );

   if( SUCCEEDED( hResult ) )
   {
      // ask the user for values on mandatory attributes
      COleDsObject*           pOleDsObject;
      CClass*                 pClass;

      pOleDsObject   = new COleDsObject( pNewItem );
      pClass         = m_pDoc->CreateClass( pOleDsObject );

      pOleDsObject->SetDocument( m_pDoc );

      if( pClass->HasMandatoryProperties( ) )
      {
         CSetMandatoryProperties aSetMandatoryProperties;

         aSetMandatoryProperties.SetOleDsObject( pOleDsObject );
         aSetMandatoryProperties.DoModal( );
      }

      HCURSOR  oldSursor, newCursor;

      newCursor   = LoadCursor( NULL, IDC_WAIT );
      oldSursor   = SetCursor( newCursor );

      if( IsClassObject( ) || m_pDoc->UseVBStyle( ) )
      {
         hResult  = pNewItem->QueryInterface( IID_IADs, (void**) &pNewIOleDs );
         ASSERT( SUCCEEDED( hResult ) );
         hResult  = pNewIOleDs->SetInfo( );
         pNewIOleDs->Release( );
      }
      else
      {
         DWORD          dwDirty  = 0L;
         ADS_ATTR_INFO* pAttrDef;
         IDirectoryObject*     pIADsObject;

         hResult  = pOleDsObject->GetDirtyAttributes( &pAttrDef, &dwDirty );

         if( SUCCEEDED( hResult ) )
         {
            hResult  = m_pIUnk->QueryInterface( IID_IDirectoryObject,
                                                (void**)&pIADsObject );

            ASSERT( SUCCEEDED( hResult ) );

            if( SUCCEEDED( hResult ) )
            {
               hResult  = pIADsObject->CreateDSObject( bstrRelativeName,
                                                       pAttrDef,
                                                       dwDirty,
                                                       NULL );
               pIADsObject->Release( );
            }
         }
      }

      SetCursor( oldSursor );
      pNewItem->Release( );

      delete   pOleDsObject;
   }

   SysFreeString( bstrClass );
   SysFreeString( bstrRelativeName );

   pIContainer->Release( );

   return hResult;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ContainerDeleteItem  ( COleDsObject* pObject )
{
   CDeleteItem       aDeleteItem;
   BSTR              bstrClass;
   BSTR              bstrName;
   IADsContainer*    pIContainer;
   IDirectoryObject*        pDSObject;
   HRESULT           hResult;
   CString           strQualifiedName;
   BOOL              bRecursive  = FALSE;

   ASSERT( NULL != pObject );

   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   aDeleteItem.m_strParent = strQualifiedName;
   aDeleteItem.m_strName   = pObject->GetItemName( );
   aDeleteItem.m_strClass  = pObject->GetClass( );

   if( aDeleteItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   bstrClass   = AllocBSTR( aDeleteItem.m_strClass.GetBuffer(128) );
   bstrName    = AllocBSTR( aDeleteItem.m_strName.GetBuffer(128) );

   bRecursive  = aDeleteItem.m_bRecursive;


   if( IsClassObject( ) || m_pDoc->UseVBStyle( ) )
   {
      hResult     = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         return hResult;
      }
      if( !bRecursive )
      {
         hResult  = pIContainer->Delete( bstrClass, bstrName );
      }
      else
      {
         IDispatch*  pDispChild;
         IUnknown*   pDispUnk;

         hResult  = pIContainer->GetObject( bstrClass, bstrName, &pDispChild );
         if( SUCCEEDED( hResult ) )
         {
            hResult  = pDispChild->QueryInterface( IID_IUnknown, (void**)&pDispUnk );
            pDispChild->Release( );
            if( SUCCEEDED( hResult ) )
            {
               hResult  = PurgeObject( pIContainer, pDispUnk, NULL );
               pDispUnk->Release( );
            }
         }
      }
      pIContainer->Release( );
   }
   else
   {
      hResult     = m_pIUnk->QueryInterface( IID_IDirectoryObject, (void**)&pDSObject );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         return hResult;
      }
      hResult  = pDSObject->DeleteDSObject( bstrName );
      pDSObject->Release( );
   }

   SysFreeString( bstrClass );
   SysFreeString( bstrName );

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ContainerMoveItem( )
{
   CMoveItem         aMoveItem;
   BSTR              bstrSource;
   BSTR              bstrDestination;
   IADsContainer*  pIContainer;
   HRESULT           hResult;
   IDispatch*         pNewItem;
   IADs*           pNewIOleDs;
   CString           strQualifiedName;

   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   aMoveItem.m_strParent = strQualifiedName;

   if( aMoveItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   bstrSource        = AllocBSTR( aMoveItem.m_strSource.GetBuffer(128) );
   bstrDestination   = AllocBSTR( aMoveItem.m_strDestination.GetBuffer(128) );

   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return hResult;
   }

   hResult  = pIContainer->MoveHere( bstrSource, bstrDestination, &pNewItem );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = pNewItem->QueryInterface( IID_IADs, (void**) &pNewIOleDs );

      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pNewIOleDs->SetInfo( );

      pNewIOleDs->Release( );
      pNewItem->Release( );
   }

   SysFreeString( bstrSource );
   SysFreeString( bstrDestination );

   pIContainer->Release( );

   return hResult;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ContainerCopyItem( )
{
   CCopyItem         aCopyItem;
   BSTR              bstrSource;
   BSTR              bstrDestination;
   IADsContainer*  pIContainer;
   HRESULT           hResult;
   IDispatch*        pNewItem;
   IADs*           pNewIOleDs;
   CString           strQualifiedName;

   MakeQualifiedName( strQualifiedName, m_strOleDsPath, m_dwType );
   aCopyItem.m_strParent = strQualifiedName;

   if( aCopyItem.DoModal( ) != IDOK )
   {
      return E_FAIL;
   }

   bstrSource        = AllocBSTR( aCopyItem.m_strSource.GetBuffer(128) );
   bstrDestination   = AllocBSTR( aCopyItem.m_strDestination.GetBuffer(128) );

   hResult  = m_pIUnk->QueryInterface( IID_IADsContainer, (void**)&pIContainer );
   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      return hResult;
   }

   hResult  = pIContainer->CopyHere( bstrSource, bstrDestination, &pNewItem );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = pNewItem->QueryInterface( IID_IADs, (void**) &pNewIOleDs );

      ASSERT( SUCCEEDED( hResult ) );

      hResult  = pNewIOleDs->SetInfo( );

      pNewIOleDs->Release( );
      pNewItem->Release( );
   }

   SysFreeString( bstrSource );
   SysFreeString( bstrDestination );

   pIContainer->Release( );

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetInterface( IUnknown** pIUnk )
{
   if( NULL != m_pIUnk )
   {
      m_pIUnk->AddRef( );
      *pIUnk   = m_pIUnk;

      return S_OK;
   }
   else
   {
      if( CreateTheObject( ) )
      {
         *pIUnk   = m_pIUnk;
         m_pIUnk  = NULL;

         return S_OK;
      }
      else
      {
         ASSERT( FALSE );
         TRACE( _T("Could not create the object\n") );
         return E_FAIL;
      }
   }
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL     COleDsObject::CreateTheObject( )
{
   CString  m_strQualifiedName;
   HRESULT  hResult;

   if( NULL == m_pIUnk )
   {
      m_strQualifiedName   = m_strOleDsPath;
      m_strQualifiedName  += _T(',');
      m_strQualifiedName  += m_strClassName;

      hResult  = m_pDoc->XOleDsGetObject( m_strQualifiedName.GetBuffer( 128 ),
                                          IID_IUnknown, (void**)&m_pIUnk  );
      ASSERT( SUCCEEDED( hResult ) );
   }

   return ( NULL != m_pIUnk );
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ReleaseIfNotTransient( void )
{
   HRESULT        hResult  = S_OK;
   unsigned long  lRefs;

   return S_OK;
   /*hResult        = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );
   ASSERT( SUCCEEDED( hResult ) );

   hResult        = pIOleDs->get_OleDsPath( &bstrOleDsPath );
   m_strOleDsPath = bstrOleDsPath;

   ASSERT( m_strOleDsPath.GetLength( ) );

   pIOleDs->Release( );
   m_pIUnk->Release( );*/

   if( NULL != m_pIUnk )
   {
      lRefs = m_pIUnk->Release( );
      if( 0 != lRefs )
      {
         /*TRACE( _T("ReleaseIfNotTransient detected that references to this object are still maintained\n") );
         TRACE( _T("Object:%s\t References:%ld"), m_strOleDsPath.GetBuffer( 128 ), lRefs );*/

         while( lRefs != 0 )
         {
            lRefs = m_pIUnk->Release( );
         }
      }
   }
   m_pIUnk        = NULL;

   return hResult;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
COleDsObject::~COleDsObject( )
{
   int            nIter, nSize;
   DWORD          dwToken;
   COleDsObject*  pChild;

   ClearPropertiesList( );

   if( NULL != m_pIUnk )
   {
      ULONG ulRef;

      ulRef = m_pIUnk->Release( );
      if( ulRef )
      {
         TRACE( _T("ERROR! Release din't returned 0 reference count for %s\n"), m_strOleDsPath );
      }
   }

   if( NULL != m_pChildren )
   {
      nSize = (int)m_pChildren->GetSize( );
      for( nIter = 0; nIter < nSize ; nIter++ )
      {
         dwToken  = m_pChildren->GetAt( nIter );
         ASSERT( dwToken );
         if( dwToken )
         {
            pChild   = m_pDoc->GetObject( &dwToken );
         }
         delete pChild;
      }

      m_pChildren->RemoveAll( );

      delete m_pChildren;
   }



   if( NULL != m_pfReadValues )
      delete [] m_pfReadValues;

   if( NULL != m_pCachedValues )
      delete []m_pCachedValues;

   if( NULL != m_pfDirty )
      delete [] m_pfDirty;

   if( NULL != m_pdwUpdateType )
      delete [] m_pdwUpdateType;
}


/***********************************************************
  Function:    COleDsObject::ClearPropertiesList
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::ClearPropertiesList( void )
{
   int   nIdx;

   if( m_ppPropertiesEntries )
   {
      for( nIdx = 0; nIdx < m_nPropertiesCount ; nIdx++ )
      {
         if( NULL != m_ppPropertiesEntries[ nIdx ] )
         {
            m_ppPropertiesEntries[ nIdx ]->Release( );
         }
      }
      FreeADsMem( m_ppPropertiesEntries );
   }

   m_nPropertiesCount      = 0;
   m_ppPropertiesEntries   = NULL;

   return S_OK;
}


/***********************************************************
  Function:    COleDsObject::CreatePropertiesList
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::CreatePropertiesList( void )
{
   HRESULT           hResult;
   long              lPropCount, lIdx;
   IADsPropertyList* pPropList   = NULL;
   VARIANT  var;

   if( m_nPropertiesCount )
      return S_OK;

   //ClearPropertiesList( );

   hResult  = m_pIUnk->QueryInterface( IID_IADsPropertyList,
                                       (void**)&pPropList );
   if( FAILED( hResult ) )
      return hResult;

   hResult  = pPropList->get_PropertyCount( &lPropCount );

   if( 0 == lPropCount )
   {
      pPropList->Release( );
      return hResult;
   }

   m_ppPropertiesEntries   = (IUnknown**) AllocADsMem( lPropCount *
                                                       sizeof(IUnknown*) );

   m_nPropertiesCount   = (int)lPropCount;
   lIdx                 = 0;

   while( TRUE )
   {
      hResult  = pPropList->Next( &var );
      if( FAILED( hResult ) )
         break;

      if( lIdx == m_nPropertiesCount )
      {
         ASSERT( FALSE );
         break;
      }

      hResult  =  V_DISPATCH( &var )->QueryInterface( IID_IUnknown,
                                             (void**)&m_ppPropertiesEntries[ lIdx++ ] );
      VariantClear( &var );
   }

   pPropList->Release( );

   return hResult;
}


/***********************************************************
  Function:    COleDsObject::IsClassObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::IsClassObject( )
{
   return ( !m_strClassName.CompareNoCase( _T("Schema") ) ) ||
          ( !m_strClassName.CompareNoCase( _T("Class") ) ) ||
          ( !m_strClassName.CompareNoCase( _T("Property") ) ) ||
          ( !m_strClassName.CompareNoCase( _T("Syntax") ) );
}


/***********************************************************
  Function:    COleDsObject::CreateClassInfo
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  COleDsObject::CreateClassInfo( )
{
   int   nPropCount;

   if( !IsClassObject( ) && m_pDoc->UsePropertiesList( ) )
   {
      CreatePropertiesList( );
      return;
   }

   if( !m_pClass )
   {
      m_pClass    = m_pDoc->CreateClass( this );

      if( !IsClassObject( ) && !m_pDoc->UseVBStyle( ) )
      {
         nPropCount  = m_pClass->GetPropertyCount( );

         m_pCachedValues   = new CString[ nPropCount ];
         m_pfReadValues    = new BOOL[ nPropCount ];
         m_pfDirty         = new BOOL[ nPropCount ];
         m_pdwUpdateType   = new DWORD[ nPropCount ];

         for( int nIdx = 0; nIdx < nPropCount ; nIdx++ )
         {
            m_pfReadValues[ nIdx ]  = FALSE;
            m_pfDirty[ nIdx ]       = FALSE;
         }
      }
   }
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::HasChildren( )
{
   return m_bHasChildren;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetClass( )
{
   return m_strClassName;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetOleDsPath( )
{
   return m_strOleDsPath;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetItemName( )
{
   return m_strItemName;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString* COleDsObject::PtrGetItemName( )
{
   return &m_strItemName;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetSchemaPath( )
{
   return m_strSchemaPath;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetDeleteName( )
{
   return m_strItemName;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD    COleDsObject::GetChildren( DWORD*   pTokens,
                                    DWORD    dwMaxCount,
                                    CDialog* pQueryStatus,
                                    BOOL*    pFilters,
                                    DWORD    dwFilters )
{
   m_dwFilters       = dwFilters;
   m_pFilters        = pFilters;
   m_pTokens         = pTokens;
   m_dwMaxCount      = dwMaxCount;
   m_pQueryStatus    = pQueryStatus;
   m_dwCount         = 0L;

   m_bAbort = FALSE;
   ((CQueryStatus*)pQueryStatus)->SetAbortFlag( &m_bAbort );

   return 0L;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD    COleDsObject::GetChildren( IADsContainer* pIContainer )
{
   IUnknown*   pIEnum;
   HRESULT     hResult;

   SetFilter( pIContainer, m_pFilters, m_dwFilters );

   hResult  = pIContainer->get__NewEnum( &pIEnum );

   if( SUCCEEDED( hResult ) )
   {
      AddNamesFromEnum( pIEnum );
      pIEnum->Release( );
   }

   return 0L;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD    COleDsObject::GetChildren( IADsCollection* pIColl )
{
   IUnknown*   pIEnum;
   HRESULT     hResult;

   //SetFilter( pIColl, m_pFilters, m_dwFilters );

   hResult  = pIColl->get__NewEnum( &pIEnum );

   if( SUCCEEDED( hResult ) )
   {
      AddNamesFromEnum( pIEnum );
      pIEnum->Release( );
   }

   return 0L;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD    COleDsObject::GetChildren( MEMBERS* pIGroupMem )
{
   IUnknown*   pIEnum;
   HRESULT     hResult;

   SetFilter( pIGroupMem, m_pFilters, m_dwFilters );

   hResult  = pIGroupMem->get__NewEnum( &pIEnum );

   if( SUCCEEDED( hResult ) )
   {
      AddNamesFromEnum( pIEnum );
      pIEnum->Release( );
   }

   return 0L;
}


/***********************************************************
  Function:    AddNamesFromEnum
  Arguments:   pIEnum - IUnknown interface of the enumeration
                  (ususlly get through a get__NewEnum on
                  IADsContainer or IADsCollection or
                  IADsMembers)
  Return:      NA
  Purpose:     Walk the enumeration and retrieves the "child"
               objects
  Author(s):   CezarU
  Revision:    0
  Date:        04/05/1996
***********************************************************/
void  COleDsObject::AddNamesFromEnum( IUnknown* pIEnum )
{
   HRESULT        hResult;
   VARIANT        aVariant[ NEXT_COUNT ];
   IADs*          pChildOleDs;
   ULONG          ulGet, ulIdx;
   IEnumVARIANT*  pIEnumVar = NULL;
   BOOL           bDisplay;
   DWORD          dwToken;

   while( TRUE )
   {
      if( NULL == pIEnum )
      {
         break;
      }

      // query for EnumVARIANT interface
      hResult        = pIEnum->QueryInterface( IID_IEnumVARIANT, (void**)&pIEnumVar );
      if( FAILED( hResult ) )
      {
         ASSERT(FALSE);
         break;
      }

      // try dummy operations for Skip, Reset, Clone.
      {
         IEnumVARIANT*  pICloneVar   = NULL;

         hResult  = pIEnumVar->Skip( 1 );

         hResult  = pIEnumVar->Clone( &pICloneVar );
         if( pICloneVar )
         {
            pICloneVar->Release( );
         }

         hResult  = pIEnumVar->Reset( );
      }


      // ask for the next NEXT_COUNT objects
      hResult  = pIEnumVar->Next( NEXT_COUNT, aVariant, &ulGet );

      while( ulGet && m_dwCount < m_dwMaxCount )
      {
         // get the returned object
         bDisplay = FALSE;

         for( ulIdx = 0;
              m_dwCount < m_dwMaxCount && ulIdx < ulGet && !m_bAbort;
              ulIdx++ )
         {
            // query for the IADs interface
            hResult  = V_DISPATCH( &aVariant[ ulIdx ] )->QueryInterface( IID_IADs,
                                                                         (void**)&pChildOleDs );
            // Indirectly call release on IDispatch interface
            VariantClear( &aVariant[ ulIdx ] );
            if( SUCCEEDED( hResult ) )
            {
               // create an "browse" object based on the OleDs object
               dwToken  = m_pDoc->CreateOleDsItem( this, pChildOleDs );
               ASSERT( dwToken );

               // need no more the IADs interface
               pChildOleDs->Release( );

               // ad the token of the new "browse" object in the array
               m_pTokens[ m_dwCount++ ]   = dwToken;

               // make the token part of the children list
               m_pChildren->Add( dwToken );

               if( m_pQueryStatus )
               {
                  // increment object type counter in "QueryStatus" dialog
                  COleDsObject*  pObject;

                  pObject  = m_pDoc->GetObject( &dwToken );
                  ((CQueryStatus*)m_pQueryStatus)->IncrementType( pObject->GetType( ), TRUE );
               }
            }
         }
         for( ; ulIdx < ulGet ; ulIdx++ )
         {
            // get rid of the unused objects; this code is hit when
            // the user hits "Stop" in the "QueryStatus" dialog
            VariantClear( &aVariant[ ulIdx ] );
         }

         if( !m_bAbort && m_dwCount < m_dwMaxCount )
         {
            // ask for the NEXT_COUNT objects
            hResult  = pIEnumVar->Next( NEXT_COUNT, aVariant, &ulGet );
            if( m_bAbort )
            {
               for( ulIdx  = 0 ; ulIdx < ulGet ; ulIdx++ )
               {
                  // get rid of the unused objects; this code is hit when
                  // the user hits "Stop" in the "QueryStatus" dialog
                  VariantClear( &aVariant[ ulIdx ] );
               }
            }
         }

         if( m_bAbort )
            break;
      }
      break;
   }

   if( pIEnumVar )
   {
      pIEnumVar->Release( );
   }
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutProperty( int nProp, CString& strPropValue, LONG lnControlCode )
{
   CreateClassInfo( );

   if( IsClassObject( ) )
   {
      return PutPropertyVB( nProp, strPropValue, lnControlCode );
   }

   if( m_pDoc->UsePropertiesList( ) )
   {
      //return   PutPropertyList( int nProp, CString& strPropValue, LONG lnControlCode );
      return   E_FAIL;
   }

   if( m_pDoc->UseVBStyle( ) )
   {
      return PutPropertyVB( nProp, strPropValue, lnControlCode );
   }
   else
   {
      return PutPropertyCPP( nProp, strPropValue, lnControlCode );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutPropertyCPP( int nProp, CString& strPropValue,
                                       LONG lnControlCode )
{
   if( strPropValue.Compare( m_pCachedValues[ nProp ] ) )
   {
      m_pfDirty[ nProp ]         = TRUE;
      m_pCachedValues[ nProp ]   = strPropValue;
      m_pdwUpdateType[ nProp ]   = lnControlCode;
   }

   return S_OK;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutPropertyVB( int nProp,
                                      CString& strPropValue,
                                      LONG lnControlCode )
{
   HRESULT        hResult;
   IDispatch*     pIDispatchFS= NULL;
   CString        strProperty, strFuncSet;
   DISPID         dispid;
   BOOL           bRez;
   DISPPARAMS     dispParams;
   VARIANT        aVar[ 20 ];
   DISPID         adispidNamedArgs[ 20 ];
   BSTR           bstrPut;
   EXCEPINFO      aExcepInfo;
   BOOL           bUseGeneric;


    dispParams.rgdispidNamedArgs  = adispidNamedArgs;

   strProperty = GetAttribute( nProp, pa_Name );
   bUseGeneric = m_pDoc->GetUseGeneric( );
   bUseGeneric = bUseGeneric && !IsClassObject( );

   hResult     = GetIDispatchForFuncSet( 0, &pIDispatchFS );

   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      if( !bUseGeneric )
      {
         bstrPut  = AllocBSTR( strProperty.GetBuffer( 128 ) );
         hResult  = pIDispatchFS->GetIDsOfNames( IID_NULL, &bstrPut, 1,
                                                 LOCALE_SYSTEM_DEFAULT, &dispid ) ;
         SysFreeString( bstrPut );

         if( FAILED( hResult ) )
            break;
         dispParams.rgvarg = aVar;
         bRez              = DisplayStringToDispParams( nProp,
                                                        strPropValue,
                                                        dispParams,
                                                        FALSE );

         if( bRez )
         {
            hResult  = pIDispatchFS->Invoke( dispid, IID_NULL,
                                             LOCALE_SYSTEM_DEFAULT,
                                             DISPATCH_PROPERTYPUT,
                                             &dispParams,
                                             NULL, &aExcepInfo, NULL);
            if( DISP_E_EXCEPTION == hResult )
            {
               hResult  = aExcepInfo.scode;
            }

            VariantClear( &aVar[ 0 ] );
         }
      }
      else
      {
         bstrPut  = m_pDoc->GetUseGetEx( ) ?
                    AllocBSTR( _T("PutEx") ) : AllocBSTR( _T("Put") );

         hResult  = pIDispatchFS->GetIDsOfNames( IID_NULL, &bstrPut,
                                                 1, LOCALE_SYSTEM_DEFAULT,
                                                 &dispid );
         SysFreeString( bstrPut );

         ASSERT( SUCCEEDED( hResult ) );
         if( FAILED( hResult ) )
            break;

         // we got the dispid of Put method...
         dispParams.rgvarg = &aVar[ 0 ];
         bRez              = DisplayStringToDispParams( nProp,
                                                        strPropValue,
                                                        dispParams,
                                                        bUseGeneric && m_pDoc->GetUseGetEx( ) );

         VariantInit( &aVar[ 1 ] );
         V_VT( &aVar[ 1 ] )      = VT_BSTR;
         V_BSTR( &aVar[ 1 ] )    = AllocBSTR( strProperty.GetBuffer( 128 ) );

         if( m_pDoc->GetUseGetEx( ) )
         {
            VariantInit( &aVar[ 2 ] );
            V_VT( &aVar[ 2 ] )   = VT_I4;
            V_I4( &aVar[ 2 ] )   = lnControlCode;
            dispParams.cArgs     = 3;
         }
         else
         {
            dispParams.cArgs        = 2;
         }
         dispParams.rgvarg       = aVar;
         dispParams.cNamedArgs   = 0;

         if( bRez )
         {
            hResult = pIDispatchFS->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                                              DISPATCH_METHOD, &dispParams,
                                            NULL, &aExcepInfo, NULL);
            if( DISP_E_EXCEPTION == hResult )
            {
               hResult  = aExcepInfo.scode;
            }

            VariantClear( &aVar[ 0 ] );
         }
         VariantClear( &aVar[ 1 ] );
      }

      break;
   }


   if( NULL != pIDispatchFS )
   {
      pIDispatchFS->Release( );
   }

   if( FAILED( hResult ) )
   {
      ErrorOnPutProperty( strFuncSet,
                          strProperty,
                          strPropValue,
                          hResult,
                          bUseGeneric,
                          m_pDoc->GetUseGetEx( )
                          );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutProperty( CString&, CString& )
{
   return E_FAIL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetAttribute( CLASSATTR classAttr )
{
   CreateClassInfo( );

   if( !m_pDoc->UsePropertiesList( ) )
   {
      return m_pClass->GetAttribute( classAttr );
   }
   else
   {
      return CString( _T("NA") );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutAttribute( CLASSATTR classAttr, CString& rValue )
{
   CreateClassInfo( );

   return m_pClass->PutAttribute( classAttr, rValue );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetAttribute( int nProp, PROPATTR propAttr )
{
   IADsPropertyEntry*   pPropEntry;
   HRESULT              hResult;
   CString              strText;

   CreateClassInfo( );

   if( !m_pDoc->UsePropertiesList( ) )
   {
      return m_pClass->GetAttribute( nProp, propAttr );
   }

   ASSERT( nProp < m_nPropertiesCount );

   if( !( nProp < m_nPropertiesCount ) )
      return CString (_T("ERROR") );

   if( NULL == m_ppPropertiesEntries[ nProp ] )
   {
      return CString (_T("ERROR") );
   }

   hResult  = m_ppPropertiesEntries[ nProp ]->QueryInterface( IID_IADsPropertyEntry,
                                                              (void**)&pPropEntry );

   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
      return CString (_T("ERROR") );

   switch( propAttr )
   {
      case  pa_Name:
      case  pa_DisplayName:
      {
         TCHAR szName[ 256 ];
         BSTR  bstrName;

         pPropEntry->get_Name( &bstrName );
         Convert( szName, bstrName );
         SysFreeString( bstrName );
         strText  = szName;

         break;
      }

      case  pa_Type:
      {
         long  lADsType;

         pPropEntry->get_ADsType( &lADsType );
         strText  = StringFromADsType( (ADSTYPE)lADsType  );
         break;
      }

      default:
         break;
   }
   pPropEntry->Release( );

   return strText;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutAttribute( int nProp,
                                     PROPATTR propAttr, CString& rValue )
{
   CreateClassInfo( );

   return m_pClass->PutAttribute( nProp, propAttr, rValue );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::GetAttribute( int nProp, METHODATTR methAttr )
{
   CreateClassInfo( );

   return m_pClass->GetAttribute( nProp, methAttr );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutAttribute( int nProp,
                                     METHODATTR methAttr, CString& rValue )
{
   CreateClassInfo( );

   return m_pClass->PutAttribute( nProp, methAttr, rValue );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::CallMethod( int nMethod )
{
   CMethod*    pMethod;
   IDispatch*  pIDispatch;
   IUnknown*   pMethodInterf;
   HRESULT     hResult;
   CString     strCaption;
   CString     strMessage;
   BOOL        bDisplayMessage = TRUE;

   CreateClassInfo( );

   hResult  = m_pIUnk->QueryInterface( m_pClass->GetMethodsInterface( ),
                                       (void**)&pMethodInterf );

   if( FAILED( hResult ) )
      return hResult;

   pMethod  = m_pClass->GetMethod( nMethod );

   hResult  = pMethodInterf->QueryInterface( IID_IDispatch,
                                             (void**)&pIDispatch );

   pMethodInterf->Release( );

   if( SUCCEEDED( hResult ) )
   {
      void* pData;

      pData = LocalAlloc( LMEM_ZEROINIT, 100 );

      hResult  = pMethod->CallMethod( pIDispatch, &bDisplayMessage );
      pIDispatch->Release( );

      LocalFree( pData );
   }

   strCaption  = m_pClass->GetAttribute( nMethod, ma_Name );
   strMessage  = OleDsGetErrorText( hResult );


   if( ! (SUCCEEDED( hResult ) && !bDisplayMessage) )
   {
      AfxGetMainWnd()->MessageBox( strMessage, strCaption, MB_ICONINFORMATION );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetIDispatchForFuncSet( int nFuncSet,
                                               IDispatch** ppIDispatchFS )
{
   IDispatch*     pIDisp      = NULL;
   IUnknown*      pIPrimary   = NULL;
   CString        strFuncSet;
   CString        strPrimaryInterf;
   HRESULT        hResult;
   DISPPARAMS     dispparamsNoArgs = {NULL, NULL, 0, 0};
   CLSID          PrimaryIID;
   UINT           uTypeInfo;
   ITypeInfo*     pTypeInfo;

   *ppIDispatchFS = NULL;

   CreateClassInfo( );

   strPrimaryInterf  = m_pClass->GetAttribute( ca_PrimaryInterface );
   if( strPrimaryInterf != _T("NA") )
   {
      BSTR  bstrPrimaryInterface;

      bstrPrimaryInterface = AllocBSTR( strPrimaryInterf.GetBuffer( 128 ) );
      hResult  = CLSIDFromString( bstrPrimaryInterface, &PrimaryIID );
      SysFreeString( bstrPrimaryInterface );

      //ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         hResult  = S_OK;
         PrimaryIID  = IID_IADs;
         //return hResult;
      }
   }
   else
   {
      PrimaryIID  = IID_IADs;
   }

   hResult        = m_pIUnk->QueryInterface( PrimaryIID, (void**) &pIPrimary );
   ASSERT( SUCCEEDED( hResult ) );

   if( FAILED( hResult ) )
   {
      hResult        = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIPrimary );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         return hResult;
      }
   }

   hResult        = pIPrimary->QueryInterface( IID_IDispatch, (void**) &pIDisp );
   ASSERT( SUCCEEDED( hResult ) );
   if( FAILED( hResult ) )
   {
      return hResult;
   }

   {
      HRESULT  hResult_local;

      hResult_local  = pIDisp->GetTypeInfoCount( &uTypeInfo );
      hResult_local  = pIDisp->GetTypeInfo( 0, LOCALE_SYSTEM_DEFAULT, &pTypeInfo );
      if( SUCCEEDED( hResult_local ) )
      {
         pTypeInfo->Release( );
      }
   }

   *ppIDispatchFS   = pIDisp;
   pIDisp->AddRef( );

   pIDisp->Release( );
   pIPrimary->Release( );

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetPropertyFromList( int nProp, CString& strPropValue )
{
   //IADsPropertyList*  pPropList;
   IADsPropertyEntry* pPropEntry;
   HRESULT           hResult;
   long              lADsType;
   BSTR              bstrName;
   VARIANT           vValues;
   long              lValueCount = 0;

   ASSERT( 0 <= nProp && nProp < m_nPropertiesCount );

   if( 0 > nProp || nProp >= m_nPropertiesCount )
      return E_FAIL;

   hResult  = m_ppPropertiesEntries[ nProp ]->QueryInterface( IID_IADsPropertyEntry,
                                                              (void**)&pPropEntry );
   if( FAILED( hResult ) )
      return hResult;

   hResult  = pPropEntry->get_Name( &bstrName );
   hResult  = pPropEntry->get_ADsType( &lADsType );
   //hResult  = pPropEntry->get_ValueCount( &lValueCount );
   hResult  = pPropEntry->get_Values( &vValues );

   if( SUCCEEDED( hResult ) )
   {
      COleDsSyntax*  pSyntax;

      pSyntax  = GetSyntaxHandler( (ADSTYPE)lADsType, strPropValue );

      if( NULL != pSyntax )
      {
         strPropValue  = pSyntax->VarToDisplayStringEx( vValues,
                                                        (lValueCount != 1) );
         delete pSyntax;
      }
   }

   pPropEntry->Release( );

   return hResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::PutProperty( CString& strName,
                                    CString& strVal,
                                    BOOL bMultiValued,
                                    ADSTYPE eType )
{
   HRESULT           hResult;
   IADsPropertyList* pPropList   = NULL;
   COleDsSyntax*     pSyntax     = NULL;
   DISPPARAMS        dispParams;
   VARIANT           aVar[ 20 ];
   CString           strText;

   dispParams.rgvarg = aVar;

   while( TRUE )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsPropertyList,
                                          (void**)&pPropList );
      if( FAILED( hResult ) )
         break;

      pSyntax  = GetSyntaxHandler( eType, strText );

      if( NULL != pSyntax )
      {
         /*BOOL  bOK;
         VARIANT  var;

         bOK   = pSyntax->CreatePropertyItem( strVal,
                                              var,
                                              bMultiValued,
                                              eType );
         bOK   = FALSE;

         if( bOK )
         {
            bstrName = AllocBSTR( strName.GetBuffer( 256 ) );
           hResult  = pPropList->PutPropertyItem( bstrName,
                                                   (long)ADS_ATTR_UPDATE,
                                                   var );
            VariantClear( &aVar[ 0 ] );
            SysFreeString( bstrName );
         }*/
         delete pSyntax;
      }
      pPropList->Release( );
      break;
   }
   if( FAILED( hResult ) )
   {
      AfxMessageBox( OleDsGetErrorText( hResult ) );
   }

   return hResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetProperty( CString& strName,
                                    CString& strVal,
                                    BOOL     bMultiValued,
                                    ADSTYPE  eType )
{
   HRESULT           hResult;
   IADsPropertyList* pPropList   = NULL;
   COleDsSyntax*     pSyntax     = NULL;
   BSTR              bstrName;
   VARIANT           aVar;
   CString           strText;

   while( TRUE )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADsPropertyList, (void**)&pPropList );
      if( FAILED( hResult ) )
         break;

      bstrName = AllocBSTR( strName.GetBuffer( 256 ) );
      hResult  = pPropList->GetPropertyItem( bstrName, (long)eType, &aVar );
      SysFreeString( bstrName );

      if( FAILED( hResult ) )
      {
         pPropList->Release( );
         break;
      }

      pSyntax  = GetSyntaxHandler( eType, strText );

      if( NULL != pSyntax )
      {
         strVal   = pSyntax->VarToDisplayString( aVar, bMultiValued, TRUE );
         delete pSyntax;
      }

      VariantClear( &aVar );
      pPropList->Release( );
      break;
   }

   if( FAILED( hResult ) )
   {
      AfxMessageBox( OleDsGetErrorText( hResult ) );
   }

   return hResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetProperty( int nProp,
                                    CString& strPropValue,
                                    BOOL* pbSecurityDescriptor )
{
   CreateClassInfo( );

   if( IsClassObject( ) )
   {
      return GetPropertyVB( nProp,
                            strPropValue,
                            pbSecurityDescriptor );
   }

   if( m_pDoc->UsePropertiesList( ) )
      return GetPropertyFromList( nProp,
                                  strPropValue
                                  /*pbSecurityDescriptor*/ );

   if( m_pDoc->UseVBStyle( ) )
   {
      return GetPropertyVB( nProp,
                            strPropValue,
                            pbSecurityDescriptor );
   }
   else
   {
      return GetPropertyCPP( nProp,
                             strPropValue,
                             pbSecurityDescriptor );
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
HRESULT  COleDsObject::GetPropertyVB( int nProp,
                                      CString& strPropValue,
                                      BOOL* pbSecurityDescriptor )
{
   IDispatch*        pIDispatchFS   = NULL;
   CString           strProperty, strFuncSet;
   HRESULT           hResult;
   DISPID            dispid;
   VARIANT           varProp;
   DISPPARAMS        dispparamsArgs = {NULL, NULL, 0, 0};
   EXCEPINFO         aExcepInfo;
   BSTR              bstrGet;
   BOOL              bUseGeneric;
   BOOL              bSecDescriptor;

   strProperty    = GetAttribute( nProp, pa_Name );
   strPropValue   = _T("Error");
   hResult        = GetIDispatchForFuncSet( 0, &pIDispatchFS );
   bUseGeneric    = m_pDoc->GetUseGeneric( );
   bUseGeneric    = bUseGeneric && !IsClassObject( );


   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      VariantInit( &varProp );
      //if( !strFuncSet.IsEmpty( ) )
      if( !bUseGeneric )
      {
         bstrGet  = AllocBSTR( strProperty.GetBuffer( 128 ) );
         hResult  = pIDispatchFS->GetIDsOfNames( IID_NULL, &bstrGet,
                                                 1, LOCALE_SYSTEM_DEFAULT,
                                                 &dispid );
         SysFreeString( bstrGet );
         if( FAILED( hResult ) )
            break;
         hResult = pIDispatchFS->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                                           DISPATCH_PROPERTYGET, &dispparamsArgs,
                                         &varProp, &aExcepInfo, NULL);
      }
      else
      {
         // we have the case when the property id not accessed using
         // functional sets.
         bstrGet  = AllocBSTR( m_pDoc->GetUseGetEx( ) ? _T("GetEx") : _T("Get") );
         hResult  = pIDispatchFS->GetIDsOfNames( IID_NULL, &bstrGet,
                                                 1, LOCALE_SYSTEM_DEFAULT,
                                                 &dispid );
         SysFreeString( bstrGet );

         // we got the dispid of Put method...
         dispparamsArgs.rgvarg   = new VARIANT[ 1 ];

         VariantInit( &dispparamsArgs.rgvarg[ 0 ] );

         V_VT( &dispparamsArgs.rgvarg[ 0 ] )    = VT_BSTR;
         V_BSTR( &dispparamsArgs.rgvarg[ 0 ] )  = AllocBSTR( strProperty.GetBuffer( 128 ) );

         dispparamsArgs.cArgs       = 1;
         dispparamsArgs.cNamedArgs  = 0;

         hResult = pIDispatchFS->Invoke( dispid, IID_NULL, LOCALE_SYSTEM_DEFAULT,
                                           DISPATCH_METHOD, &dispparamsArgs,
                                         &varProp, &aExcepInfo, NULL);
         VariantClear( &dispparamsArgs.rgvarg[ 0 ] );

         delete (dispparamsArgs.rgvarg);
      }

      if( DISP_E_EXCEPTION == hResult )
      {
         hResult  = aExcepInfo.scode;
      }
      else
      {

         bSecDescriptor = IsSecurityDescriptor( varProp, m_pDoc->GetUseGetEx( ) );
         if( !bSecDescriptor )
         {
            strPropValue   = VarToDisplayString( nProp,
                                                 varProp,
                                                 bUseGeneric && m_pDoc->GetUseGetEx( ) );
         }
         else
         {
            strPropValue   = _T("This is a security descriptor");
         }

         VariantClear( &varProp );
         if( NULL != pbSecurityDescriptor )
         {
            *pbSecurityDescriptor   = bSecDescriptor;
         }
      }
      break;
   }

   if( FAILED( hResult ) )
   {
      strPropValue   = OleDsGetErrorText( hResult );
      //AfxMessageBox( strPropValue );
   }

   if( NULL != pIDispatchFS )
   {
      pIDispatchFS->Release( );
   }

   return hResult;
}



//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
BOOL  COleDsObject::IsSecurityDescriptor( VARIANT& rValue, BOOL bUseGetEx )
{
   BOOL     bIsSD = FALSE;
   HRESULT  hResult;
   IADsSecurityDescriptor* pDescriptor = NULL;

   if( !bUseGetEx )
   {
      switch( V_VT( &rValue ) )
      {
         case  VT_DISPATCH:
         {

            hResult  = V_DISPATCH( &rValue )->QueryInterface(
                              IID_IADsSecurityDescriptor,
                              (void**)&pDescriptor );
            if( SUCCEEDED( hResult ) )
            {
               pDescriptor->Release( );
               bIsSD = TRUE;
            }
            break;
         }

         default:
            break;
      }
   }
   else
   {
      SAFEARRAY*  pSafeArray;
      VARIANT     var;
      long        lBound, uBound;

      if( (VT_ARRAY | VT_VARIANT) != V_VT( &rValue )  )
         return FALSE;

      pSafeArray  = V_ARRAY( &rValue );

      hResult     = SafeArrayGetLBound(pSafeArray, 1, &lBound);
      ASSERT( SUCCEEDED( hResult ) );

      hResult     = SafeArrayGetUBound(pSafeArray, 1, &uBound);
      ASSERT( SUCCEEDED( hResult ) );

      hResult     = SafeArrayGetElement( pSafeArray, &lBound, &var );
      if( SUCCEEDED( hResult ) )
      {
         bIsSD = IsSecurityDescriptor( var, FALSE );
         VariantClear( &var );
      }
   }

   return bIsSD;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetPropertyCPP( int nProp, CString& strPropValue,
                                       BOOL * pbIsDescriptor )
{
   ADS_ATTR_INFO*  pAttrDef;
   BSTR           szwAttrName[ 2 ];
   HRESULT        hResult;
   DWORD          dwAttributes;
   IDirectoryObject*     pIADsObject;
   CString        strPropName;

   if( m_pfDirty[ nProp ] || m_pfReadValues[ nProp ] )
   {
      strPropValue   = m_pCachedValues[ nProp ];

      return S_OK;
   }

   hResult  = m_pIUnk->QueryInterface( IID_IDirectoryObject, (void**)&pIADsObject );

   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      strPropName = m_pClass->GetAttribute( nProp, pa_Name );

      szwAttrName[ 0 ]  = AllocBSTR( strPropName.GetBuffer( 255 ) );
      hResult  = pIADsObject->GetObjectAttributes( (LPWSTR*)szwAttrName,
                                                   1,
                                                   &pAttrDef,
                                                   &dwAttributes );
      if( FAILED( hResult ) )
      {
         strPropValue   = OleDsGetErrorText( hResult );
         break;
      }

      if( SUCCEEDED( hResult ) && !dwAttributes )
      {
         TRACE( _T("ERROR: GetObjectAttributes succeeds, but dwAttributes is 0\n") );
         strPropValue   = _T("ERROR: GetObjectAttributes succeeds, but dwAttributes is 0");
         //dwAttributes   = 1;
      }

      if( !dwAttributes )
         break;

      hResult  = CopyAttributeValue( pAttrDef, nProp );

      FreeADsMem( (void*) pAttrDef );
      break;
   }

   //ASSERT( m_pfReadValues[ nProp ] );
   if( m_pfReadValues[ nProp ] )
   {
      strPropValue   = m_pCachedValues[ nProp ];
   }

   if( pIADsObject )
   {
      pIADsObject->Release( );
   }

   return hResult;
}


/***********************************************************
  Function:    COleDsObject::CopyAttributeValue
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::CopyAttributeValue( ADS_ATTR_INFO* pAttrDef, int nAttribute )
{
   HRESULT     hResult;
   CProperty*  pProperty;

   CreateClassInfo( );

   ASSERT( pAttrDef->pszAttrName );
   if( ! pAttrDef->pszAttrName )
   {
      return E_FAIL;
   }

   if( -1 == nAttribute )
   {
      // cool, we must gues the attribute index based on attribute name
      TCHAR    szAttrName[ 128 ];
      int      nProp;
      CString  strPropName;

      Convert( szAttrName, pAttrDef->pszAttrName );
      strPropName = szAttrName;
      nProp       = m_pClass->LookupProperty( strPropName );

      ASSERT( -1 != nProp );

      return (-1 == nProp) ?
             E_FAIL : CopyAttributeValue( pAttrDef, nProp );
   }

   pProperty      = m_pClass->GetProperty( nAttribute );
   hResult        = pProperty->Native2Value( pAttrDef, m_pCachedValues[ nAttribute ] );
   m_pfReadValues[ nAttribute ] = TRUE;
   //m_pCachedValues[ nAttribute ];

   return hResult;
}


/***********************************************************
  Function:    COleDsObject::CreateAttributeValue
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::CreateAttributeValue ( ADS_ATTR_INFO* pAttrDef,
                                              int nAttribute  )
{
   HRESULT     hResult = S_OK;
   CProperty*  pProperty;
   CString     strPropName;

   pProperty               = m_pClass->GetProperty( nAttribute );
   strPropName             = m_pClass->GetAttribute( nAttribute, pa_Name );

   pAttrDef->pszAttrName   = (WCHAR*)AllocADsMem( sizeof(WCHAR) *
                                               ( strPropName.GetLength() + 1 ) );

   Convert( pAttrDef->pszAttrName, strPropName.GetBuffer( 256 ) );

   pAttrDef->dwControlCode = m_pdwUpdateType[ nAttribute ];

   if( ADS_PROPERTY_CLEAR != m_pdwUpdateType[ nAttribute ] )
   {
      hResult  = pProperty->Value2Native( pAttrDef,
                                          m_pCachedValues[ nAttribute ] );
   }

   return hResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetProperty( CString&, CString& )
{
   return E_FAIL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
//void  COleDsObject::SetClass( CClass* pClass )
//{
//   ASSERT( pClass != NULL );
//
//   m_pClass = pClass;
//}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  COleDsObject::UseSchemaInformation ( BOOL bUse )
{
   m_bUseSchemaInformation = bUse;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   COleDsObject::GetPropertyCount(  )
{
   CreateClassInfo( );

   if( !m_pDoc->UsePropertiesList( ) )
   {
      return m_pClass->GetPropertyCount( );
   }
   else
   {
      return m_nPropertiesCount;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  COleDsObject::VarToDisplayString( int  nProp, VARIANT& var, BOOL bUseEx )
{
   CreateClassInfo( );

   return m_pClass->VarToDisplayString( nProp, var, bUseEx );
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::DisplayStringToDispParams( int  nProp,
                                               CString& rString, DISPPARAMS& dp,
                                               BOOL bUseEx )
{
   CreateClassInfo( );

   return m_pClass->DisplayStringToDispParams( nProp, rString, dp, bUseEx );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  COleDsObject::SupportContainer( void )
{
   CreateClassInfo( );

   return m_pClass->SupportContainer( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD    COleDsObject::GetType( )
{
   return m_dwType;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetInfo( )
{
   HRESULT  hResult;

   if( m_pDoc->UseVBStyle( ) )
   {
      hResult  = GetInfoVB( );
   }
   else
   {
      hResult  = GetInfoCPP( );
   }

   ClearPropertiesList( );

   if( FAILED( hResult ) )
   {
      CString  strError;

      strError = OleDsGetErrorText( hResult );
      AfxGetMainWnd()->MessageBox( strError, _T("GetInfo ERROR") );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetInfoVB( )
{
   IADs*  pIOleDs;
   HRESULT  hResult;

   hResult  = E_FAIL;

   ASSERT( NULL != m_pIUnk );

   if( NULL != m_pIUnk )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         __try
         {
            hResult  = pIOleDs->GetInfo( );
         }
         __except( EXCEPTION_EXECUTE_HANDLER )
         {
            hResult  = E_FAIL;
            AfxMessageBox( _T("ERROR: AV caused by GetInfo") );
         }
         pIOleDs->Release( );
      }
   }
   else
   {
      CreateTheObject( );
      if( NULL != m_pIUnk )
      {
         hResult  = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );
         ASSERT( SUCCEEDED( hResult ) );

         if( SUCCEEDED( hResult ) )
         {
            __try
            {
               hResult  = pIOleDs->GetInfo( );
            }
            __except( EXCEPTION_EXECUTE_HANDLER )
            {
               hResult  = E_FAIL;
               AfxMessageBox( _T("ERROR: AV caused by GetInfo") );
            }
            pIOleDs->Release( );
         }

         ReleaseIfNotTransient( );
      }
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::SetInfo( )
{
   if( m_pDoc->UseVBStyle( ) )
   {
      return SetInfoVB( );
   }
   else
   {
      return SetInfoCPP( );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetInfoCPP( )
{
   HRESULT        hResult;
   ADS_ATTR_INFO* pAttrDef;
   DWORD          dwAttributes, dwIter;
   IDirectoryObject*     pIADsObject;
   CString        strPropName;


   for( dwIter = 0L ;dwIter < (DWORD)m_pClass->GetPropertyCount( );dwIter++ )
   {
      m_pfReadValues[ dwIter ]   = FALSE;
      m_pfDirty[ dwIter ]        = FALSE;
   }

   hResult  = m_pIUnk->QueryInterface( IID_IDirectoryObject, (void**)&pIADsObject );

   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      {
         ADS_OBJECT_INFO*  pInfo;
         //SMITHA HRESULT           hResult;
         TCHAR             szText[ 256 ];

         hResult  = pIADsObject->GetObjectInformation( &pInfo );

         while( TRUE )
         {
            if( FAILED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: GetObjectInformation retuns %lx\n"), hResult );
               break;
            }

            if( NULL != pInfo->pszRDN )
            {
               Convert( szText, pInfo->pszRDN );
               TRACE( _T("pszRDN = %s\n"), szText );
            }
            else
            {
               TRACE( _T("pszRDN is NULL\n") );

            }

            if( NULL != pInfo->pszObjectDN )
            {
               Convert( szText, pInfo->pszObjectDN );
               TRACE( _T("pszObjectDN = %s\n"), szText );
            }
            else
            {
               TRACE( _T("pszObjectDN is NULL\n") );
            }

            if( NULL != pInfo->pszParentDN )
            {
               Convert( szText, pInfo->pszParentDN );
               TRACE( _T("pszParentDN = %s\n"), szText );
            }
            else
            {
               TRACE( _T("pszParentDN is NULL\n") );
            }

            if( NULL != pInfo->pszSchemaDN )
            {
               Convert( szText, pInfo->pszSchemaDN );
               TRACE( _T("pszSchemaDN = %s\n"), szText );
            }
            else
            {
               TRACE( _T("pszSchemaDN is NULL\n") );
            }

            if( NULL != pInfo->pszClassName )
            {
               Convert( szText, pInfo->pszClassName );
               TRACE( _T("pszClassName = %s\n"), szText );
            }
            else
            {
               TRACE( _T("pszClassName is NULL\n") );
            }

            FreeADsMem( pInfo );
            break;
         }
      }

      hResult  = pIADsObject->GetObjectAttributes( NULL,
                                                   (ULONG)-1L,
                                                   &pAttrDef,
                                                   &dwAttributes );

      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      for( dwIter = 0L ; dwIter < dwAttributes ; dwIter++ )
      {
         CopyAttributeValue( pAttrDef + dwIter );
      }

      FreeADsMem( (void*) pAttrDef );
      break;
   }

   if( pIADsObject )
   {
      pIADsObject->Release( );
   }

   return hResult;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::SetInfoVB( )
{
   IADs*  pIOleDs;
   HRESULT  hResult;

   hResult  = E_FAIL;

   ASSERT( NULL != m_pIUnk );

   if( NULL != m_pIUnk )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pIOleDs->SetInfo( );
         if( FAILED( hResult ) )
         {
            CString  strError;

            strError = OleDsGetErrorText( hResult );
            AfxGetMainWnd()->MessageBox( strError, _T("SetInfo ERROR") );
         }
         pIOleDs->Release( );
      }
   }
   else
   {
      CreateTheObject( );
      if( NULL != m_pIUnk )
      {
         hResult  = m_pIUnk->QueryInterface( IID_IADs, (void**) &pIOleDs );
         ASSERT( SUCCEEDED( hResult ) );

         if( SUCCEEDED( hResult ) )
         {
            hResult  = pIOleDs->SetInfo( );
            pIOleDs->Release( );
         }

         ReleaseIfNotTransient( );
      }
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::GetDirtyAttributes( PADS_ATTR_INFO* ppAttrDef, DWORD* pdwCount )
{
   HRESULT           hResult = S_OK;
   DWORD             dwDirty  = 0L;
   DWORD             dwIter, dwProps;
   ADS_ATTR_INFO*    pAttrDef;
   ADS_ATTR_INFO*    pAttrDefCurrent;
   CString           strPropName;

   *ppAttrDef  = NULL;
   *pdwCount   = 0L;

   dwProps  = (DWORD)m_pClass->GetPropertyCount( );
   for( dwIter = 0L ; dwIter < dwProps ; dwIter++ )
   {
      if( m_pfDirty[ dwIter ] )
         dwDirty++;
   }

   if( !dwDirty )
      return S_FALSE;

   pAttrDef = (ADS_ATTR_INFO*) AllocADsMem( sizeof(ADS_ATTR_INFO) *dwDirty );
   ASSERT( pAttrDef );
   if( !pAttrDef )
      return E_FAIL;

   pAttrDefCurrent   = pAttrDef;

   for( dwIter = 0L ; dwIter < dwProps ; dwIter++ )
   {
      if( m_pfDirty[ dwIter ] )
      {
         CreateAttributeValue( pAttrDefCurrent, dwIter );
         pAttrDefCurrent++;
      }
   }

   *ppAttrDef  = pAttrDef;
   *pdwCount   = dwDirty;

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  COleDsObject::FreeDirtyAttributes( PADS_ATTR_INFO pAttrDef, DWORD dwCount )
{
   DWORD             dwIter;
   CProperty*        pProperty;
   CString           strPropName;
   TCHAR             szPropName[ 128 ];

   ASSERT( NULL != pAttrDef );
   if( NULL == pAttrDef )
      return;

   for( dwIter = 0L ; dwIter < dwCount ; dwIter++ )
   {
      ASSERT( NULL != pAttrDef[ dwIter ].pszAttrName );

      if( NULL != pAttrDef[ dwIter ].pszAttrName )
      {
         int   nIdx;

         Convert( szPropName, pAttrDef[ dwIter ].pszAttrName );
         strPropName = szPropName;

         nIdx  = m_pClass->LookupProperty( strPropName );
         if( -1 != nIdx )
         {
            pProperty   = m_pClass->GetProperty( nIdx );
            pProperty->FreeAttrInfo( pAttrDef + dwIter );
         }
      }
   }

   FreeADsMem( pAttrDef );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  COleDsObject::SetInfoCPP( )
{
   HRESULT        hResult;
   DWORD          dwDirty  = 0L;
   DWORD          dwAttributesModified;
   ADS_ATTR_INFO* pAttrDef;
   IDirectoryObject*     pIADsObject;

   hResult  = GetDirtyAttributes( &pAttrDef, &dwDirty );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = m_pIUnk->QueryInterface( IID_IDirectoryObject, (void**)&pIADsObject );

      if( FAILED( hResult ) )
         return hResult;

      hResult  = pIADsObject->SetObjectAttributes( pAttrDef,
                                                   dwDirty,
                                                   &dwAttributesModified );
      pIADsObject->Release( );

      FreeDirtyAttributes( pAttrDef, dwDirty );

      if( FAILED( hResult ) )
      {
         CString  strError;

         strError = OleDsGetErrorText( hResult );
         AfxGetMainWnd()->MessageBox( strError, _T("SetObjectAttributes ERROR") );
      }
   }

   return hResult;
}

/******************************************************************************
  Function:    PurgeObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT  COleDsObject::PurgeObject( IADsContainer* pParent,
                                    IUnknown*      pIUnknown,
                                    LPWSTR         pszPrefix
                                   )
{
   BSTR              bstrName       = NULL;
   BSTR              bstrClass      = NULL;
   VARIANT           var;
   HRESULT           hResult;
   IUnknown*         pIChildUnk     = NULL;
   IADs*             pIChildOleDs   = NULL;
   IADs*             pADs;
   BSTR              bstrObjName, bstrObjClass;
   IEnumVARIANT*     pIEnumVar   = NULL;
   IADsContainer*    pIContainer = NULL;
   ULONG             ulFetch     = 0L;
   BOOL              bFirst      = FALSE;
   TCHAR             szName[ 128 ];

   if( NULL == pParent || NULL == pIUnknown )
      return E_FAIL;

   hResult  = pIUnknown->QueryInterface( IID_IADs,
                                         (void**)&pADs );
   if( FAILED( hResult ) )
      return E_FAIL;

   if( NULL == m_pDeleteStatus )
   {
      m_bAbort          = FALSE;
      m_pDeleteStatus   = new CDeleteStatus;
      m_pDeleteStatus->SetAbortFlag( &m_bAbort );
      m_pDeleteStatus->Create( IDD_DELETESTATUS );
      m_pDeleteStatus->ShowWindow( SW_SHOW );
      m_pDeleteStatus->UpdateWindow( );
      bFirst            = TRUE;
   }

   if( !m_bAbort )
   {
      pADs->get_Name( &bstrObjName );
      pADs->get_Class( &bstrObjClass );
      pADs->Release( );

      hResult  = pIUnknown->QueryInterface( IID_IADsContainer,
                                            (void**)&pIContainer );
      if( FAILED( hResult ) )
      {
         Convert( szName, bstrObjName );

         if( NULL != pszPrefix && !_wcsnicmp( bstrObjName, pszPrefix, wcslen(pszPrefix) ) )
         {
            m_pDeleteStatus->SetCurrentObjectText( szName );
            m_pDeleteStatus->SetStatusText( _T("Pending") );

            hResult  = pParent->Delete( bstrObjClass, bstrObjName );

            m_pDeleteStatus->SetStatusText( SUCCEEDED( hResult) ?
                                            _T("OK"):_T("FAIL") );
            TRACE( _T("Delete %S returns %lx\n"), bstrObjName, hResult );
         }
         if( NULL == pszPrefix )
         {
            m_pDeleteStatus->SetCurrentObjectText( szName );
            m_pDeleteStatus->SetStatusText( _T("Pending") );

            hResult  = pParent->Delete( bstrObjClass, bstrObjName );

            m_pDeleteStatus->SetStatusText( SUCCEEDED( hResult) ?
                                            _T("OK"):_T("FAIL") );
            TRACE( _T("Delete %S returns %lx\n"), bstrObjName, hResult );
         }

         SysFreeString( bstrObjClass );
         SysFreeString( bstrObjName );
         return S_OK;
      }
   }
   if( !m_bAbort )
   {

      hResult  = ADsBuildEnumerator( pIContainer, &pIEnumVar );

      while( SUCCEEDED( hResult ) && !m_bAbort )
      {
         ulFetch  = 0L;

         hResult  = ADsEnumerateNext( pIEnumVar, 1, &var, &ulFetch );
         if( FAILED( hResult ) )
            continue;

         if( !ulFetch )
            break;

         V_DISPATCH( &var )->QueryInterface( IID_IUnknown, (void**)&pIChildUnk );

         VariantClear( &var );

         if( NULL != pIChildUnk )
         {
            PurgeObject( pIContainer, pIChildUnk, pszPrefix );
            pIChildUnk->Release( );
         }
         pIChildUnk  = NULL;
      }

      if( NULL != pIEnumVar )
      {
         ADsFreeEnumerator( pIEnumVar );
      }
      pIContainer->Release( );
   }

   if( !m_bAbort )
   {

      Convert( szName, bstrObjName );

      m_pDeleteStatus->SetCurrentObjectText( szName );
      m_pDeleteStatus->SetStatusText( _T("Pending") );

      hResult  = pParent->Delete( bstrObjClass, bstrObjName );

      m_pDeleteStatus->SetStatusText( SUCCEEDED( hResult) ?
                                      _T("OK"):_T("FAIL") );

      TRACE( _T("\tDelete %S (%S) ends with %lx\n"), bstrObjName, bstrObjClass );

      SysFreeString( bstrObjClass );
      SysFreeString( bstrObjName );
   }

   if( bFirst )
   {
      m_pDeleteStatus->DestroyWindow( );
      delete m_pDeleteStatus;
      m_pDeleteStatus   = NULL;
   }

   return hResult;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\prmsdlg.h ===
// prmsdlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CParamsDialog dialog

class CParamsDialog : public CDialog
{
// Construction
public:
	CParamsDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CParamsDialog)
	enum { IDD = IDD_CALLMETHOD };
	CStatic	m_strMethodName;
	CEdit	m_eParamValue6;
	CEdit	m_eParamValue5;
	CEdit	m_eParamValue4;
	CEdit	m_eParamValue3;
	CEdit	m_eParamValue2;
	CEdit	m_eParamValue1;
	CStatic	m_strParamName6;
	CStatic	m_strParamName5;
	CStatic	m_strParamName4;
	CStatic	m_strParamName3;
	CStatic	m_strParamName2;
	CStatic	m_strParamName1;
	//}}AFX_DATA

public:
   void  SetMethodName  ( CString& );
   void  SetArgNames    ( CStringArray* );
   void  SetArgValues   ( CStringArray* );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CParamsDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CParamsDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
//   CStringArray   m_ArgNames;
//   CStringArray   m_ArgValues;
   int            m_nArgs;
   CString        m_strMethName;
   CStringArray*  m_pArgNames;
   CStringArray*  m_pArgValues;
   CEdit*         m_pValues[ 100 ];
   CStatic*       m_pNames[ 100 ];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\qstatus.cpp ===
// QueryStatus.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "qstatus.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CQueryStatus dialog


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CQueryStatus::CQueryStatus(CWnd* pParent /*=NULL*/)
	: CDialog(CQueryStatus::IDD, pParent)
{
	//{{AFX_DATA_INIT(CQueryStatus)
	//}}AFX_DATA_INIT

   m_nUser           = 0;
   m_nGroup          = 0;
   m_nService        = 0;
   m_nFileService    = 0;
   m_nPrintQueue     = 0;
   m_nToDisplay      = 0;
   m_nComputer       = 0;
   m_nOtherObjects   = 0;

   m_pbAbort         = NULL;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CQueryStatus::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQueryStatus)
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CQueryStatus, CDialog)
	//{{AFX_MSG_MAP(CQueryStatus)
	ON_BN_CLICKED(IDCANCEL, OnStop)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueryStatus message handlers

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CQueryStatus::IncrementType( DWORD  dwType, BOOL bDisplay )
{
   switch(  dwType )
   {
      case  USER:
         m_nUser++;
         break;
         
      case GROUP:
         m_nGroup++;
         break;

      case  SERVICE:
         m_nService++;
         break;

      case  FILESERVICE:
         m_nFileService++;
         break;

      case  PRINTQUEUE:
         m_nPrintQueue++;
         break;

      case  COMPUTER:
         m_nComputer++;
         break;

      default:
         m_nOtherObjects++;
         break;
   }

   if( bDisplay )
   {
      m_nToDisplay++;
   }

   DisplayStatistics( );
   UpdateWindow( );

   MSG   aMsg;

   while( PeekMessage( &aMsg, NULL, 0, 0, PM_REMOVE ) && 
          !IsDialogMessage( &aMsg ) )
   {
      TranslateMessage( &aMsg );
      DispatchMessage( &aMsg );
   }
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CQueryStatus::DisplayStatistics( void )
{
   SetDlgItemInt( IDS_USER,            m_nUser           );
   SetDlgItemInt( IDS_GROUP,           m_nGroup          );
   SetDlgItemInt( IDS_SERVICE,         m_nService        );
   SetDlgItemInt( IDS_FILESERVICE,     m_nFileService    );
   SetDlgItemInt( IDS_PRINTQUEUE,      m_nPrintQueue     );
   SetDlgItemInt( IDS_OTHEROBJECTS,    m_nOtherObjects   );
   SetDlgItemInt( IDS_COMPUTER,        m_nComputer       );
   SetDlgItemInt( IDC_ITEMSTODISPLAY,  m_nToDisplay      );
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CQueryStatus::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
	
   DisplayStatistics( );

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CQueryStatus::SetAbortFlag( BOOL* pAbort )
{
   m_pbAbort   = pAbort;
   *pAbort     = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CQueryStatus::OnStop() 
{
	// TODO: Add your control notification handler code here

   if( NULL != m_pbAbort )
   {
      *m_pbAbort = TRUE;
   }
}
/////////////////////////////////////////////////////////////////////////////
// CDeleteStatus dialog


CDeleteStatus::CDeleteStatus(CWnd* pParent /*=NULL*/)
	: CDialog(CDeleteStatus::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDeleteStatus)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
   m_pbAbort   = NULL;
}


void CDeleteStatus::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDeleteStatus)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDeleteStatus, CDialog)
	//{{AFX_MSG_MAP(CDeleteStatus)
	ON_BN_CLICKED(IDCANCEL, OnStop)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CDeleteStatus::SetAbortFlag( BOOL* pAbort )
{
   m_pbAbort   = pAbort;
   *pAbort     = FALSE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CDeleteStatus::SetCurrentObjectText ( TCHAR* szName )
{
   SetDlgItemText( IDC_CURRENTDELETEOBJECT, szName );   

   UpdateWindow( );

   MSG   aMsg;

   while( PeekMessage( &aMsg, NULL, 0, 0, PM_REMOVE ) && 
          !IsDialogMessage( &aMsg ) )
   {
      TranslateMessage( &aMsg );
      DispatchMessage( &aMsg );
   }
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void  CDeleteStatus::SetStatusText( TCHAR* szStatus )
{
   //SetDlgItemText( IDC_DELETESTATUS, szStatus );   
   GetDlgItem( IDC_DELETESTATUS )->ShowWindow( SW_HIDE );

   //UpdateWindow( );

   /*MSG   aMsg;

   while( PeekMessage( &aMsg, NULL, 0, 0, PM_REMOVE ) && 
          !IsDialogMessage( &aMsg ) )
   {
      TranslateMessage( &aMsg );
      DispatchMessage( &aMsg );
   }*/
}

/////////////////////////////////////////////////////////////////////////////
// CDeleteStatus message handlers

void CDeleteStatus::OnStop() 
{
	// TODO: Add your control notification handler code here
   if( NULL != m_pbAbort )
   {
      *m_pbAbort = TRUE;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\prmsdlg.cpp ===
// prmsdlg.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "resource.h"
#include "prmsdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CParamsDialog dialog


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CParamsDialog::CParamsDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CParamsDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CParamsDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
   m_nArgs  = 0;

   m_pValues[ 0 ] = &m_eParamValue1;
   m_pValues[ 1 ] = &m_eParamValue2;
   m_pValues[ 2 ] = &m_eParamValue3;
   m_pValues[ 3 ] = &m_eParamValue4;
   m_pValues[ 4 ] = &m_eParamValue5;
   m_pValues[ 5 ] = &m_eParamValue6;

   m_pNames[ 0 ]  = &m_strParamName1;
   m_pNames[ 1 ]  = &m_strParamName2;
   m_pNames[ 2 ]  = &m_strParamName3;
   m_pNames[ 3 ]  = &m_strParamName4;
   m_pNames[ 4 ]  = &m_strParamName5;
   m_pNames[ 5 ]  = &m_strParamName6;

   m_pArgNames    = NULL;
   m_pArgValues   = NULL;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CParamsDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CParamsDialog)
	DDX_Control(pDX, IDC_METHOD, m_strMethodName);
	DDX_Control(pDX, IDE_PARAM6, m_eParamValue6);
	DDX_Control(pDX, IDE_PARAM5, m_eParamValue5);
	DDX_Control(pDX, IDE_PARAM4, m_eParamValue4);
	DDX_Control(pDX, IDE_PARAM3, m_eParamValue3);
	DDX_Control(pDX, IDE_PARAM2, m_eParamValue2);
	DDX_Control(pDX, IDE_PARAM1, m_eParamValue1);
	DDX_Control(pDX, IDC_PARAM6, m_strParamName6);
	DDX_Control(pDX, IDC_PARAM5, m_strParamName5);
	DDX_Control(pDX, IDC_PARAM4, m_strParamName4);
	DDX_Control(pDX, IDC_PARAM3, m_strParamName3);
	DDX_Control(pDX, IDC_PARAM2, m_strParamName2);
	DDX_Control(pDX, IDC_PARAM1, m_strParamName1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CParamsDialog, CDialog)
	//{{AFX_MSG_MAP(CParamsDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CParamsDialog message handlers


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CParamsDialog::SetMethodName  ( CString& strMethodName )
{
   m_strMethName  = strMethodName;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CParamsDialog::SetArgNames( CStringArray* pArgNames )
{
   m_pArgNames = pArgNames;
   m_nArgs     = (int)pArgNames->GetSize( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CParamsDialog::SetArgValues( CStringArray* pArgValues )
{
   m_pArgValues   = pArgValues;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CParamsDialog::OnInitDialog()
{
	CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here

   int nIdx;

   for( nIdx = 0; nIdx < m_nArgs && nIdx < 6 ; nIdx++ )
   {
      m_pNames[ nIdx ]->SetWindowText( m_pArgNames->GetAt( nIdx ) );
      m_pValues[ nIdx ]->SetWindowText( _T("") );
   }

   for( ; nIdx < 6 ; nIdx++ )
   {
      m_pNames[ nIdx ]->ShowWindow( SW_HIDE );
      m_pValues[ nIdx ]->ShowWindow( SW_HIDE );
   }
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CParamsDialog::OnOK()
{
	// TODO: Add extra validation here
	for( int nIdx = 0; nIdx < m_nArgs && m_nArgs < 6; nIdx++ )
   {
      CString  strValue;

      m_pValues[ nIdx ]->GetWindowText( strValue );
      m_pArgValues->Add( strValue );
   }

	CDialog::OnOK();
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\qstatus.h ===
// QueryStatus.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQueryStatus dialog

#ifndef __QSTATUS_H__
#define __QSTATUS_H__

class CQueryStatus : public CDialog
{
// Construction
public:
	CQueryStatus(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CQueryStatus)
	enum { IDD = IDD_QUERYSTATUS };
	//}}AFX_DATA

public:
   void  SetAbortFlag   ( BOOL*      );
   void  IncrementType  ( DWORD, BOOL );
   
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQueryStatus)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CQueryStatus)
	virtual BOOL OnInitDialog();
	afx_msg void OnStop();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
   void  DisplayStatistics( );

protected:
   int   m_nUser;
   int   m_nGroup;
   int   m_nComputer;
   int   m_nService;
   int   m_nFileService;
   int   m_nPrintQueue;
   int   m_nToDisplay;
   int   m_nOtherObjects;

   BOOL* m_pbAbort;  

};
/////////////////////////////////////////////////////////////////////////////
// CDeleteStatus dialog

class CDeleteStatus : public CDialog
{
// Construction
public:
	CDeleteStatus(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDeleteStatus)
	enum { IDD = IDD_DELETESTATUS };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDeleteStatus)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

   public:
      void  SetAbortFlag         ( BOOL*     );
      void  SetCurrentObjectText ( TCHAR*    );
      void  SetStatusText        ( TCHAR*    );

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDeleteStatus)
	afx_msg void OnStop();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
   BOOL* m_pbAbort;  
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\schemavw.cpp ===
// schemavw.cpp : implementation file
//

#include "stdafx.h"
#include "viewex.h"
#include "cacls.h"
#include "schemavw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


extern   IDispatch*  pACEClipboard;
extern   IDispatch*  pACLClipboard;
extern   IDispatch*  pSDClipboard;

/////////////////////////////////////////////////////////////////////////////
// CSchemaView

IMPLEMENT_DYNCREATE(CSchemaView, CFormView)

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CSchemaView::CSchemaView()
	: CFormView(CSchemaView::IDD)
{
	//{{AFX_DATA_INIT(CSchemaView)
	//}}AFX_DATA_INIT

   int nIdx;

   m_nProperty    = -1;
   m_bDirty       = FALSE;
   m_bInitialized = FALSE;
   pSecurityDescriptor  = NULL;

   m_nLastSD         = -1;
   m_nLastSDValue    = -1;
   m_nLastACE        = -1;
   m_nLastACEValue   = -1;
   m_nLastACL        = acl_Invalid;
   m_bACLDisplayed   = FALSE;


   for( nIdx = 0; nIdx < 32 ; nIdx++ )
   {
      m_arrNormalControls[ 32 ]     = -1;
      m_arrSecurityControls[ 32 ]   = -1;
   }

   nIdx  = 0;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICCLASS;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICCLSID;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICPRIMARYINTERFACE;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICDERIVEDFROM;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICCONTAINMENT;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICCONTAINER;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICHELPFILENAME;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICSTATICHELPFILECONTEXT;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICOID;
   m_arrNormalControls[ nIdx++ ] = IDC_STATICABSTRACT;

   m_arrNormalControls[ nIdx++ ] = IDC_CLASSTYPE;
   m_arrNormalControls[ nIdx++ ] = IDC_CLSID;
   m_arrNormalControls[ nIdx++ ] = IDC_PRIMARYINTERFACE;
   m_arrNormalControls[ nIdx++ ] = IDC_DERIVEDFROM;
   m_arrNormalControls[ nIdx++ ] = IDC_CONTAINEMENT;
   m_arrNormalControls[ nIdx++ ] = IDC_CONTAINER;
   m_arrNormalControls[ nIdx++ ] = IDC_HELPFILENAME;
   m_arrNormalControls[ nIdx++ ] = IDC_HELPFILECONTEXT;
   m_arrNormalControls[ nIdx++ ] = IDC_CLASSOID;
   m_arrNormalControls[ nIdx++ ] = IDC_CLASSABSTRACT;

   nIdx  = 0;
   m_arrSecurityControls[ nIdx++ ]  = IDC_GBSECURITYDESCRIPTORSTATIC;
   m_arrSecurityControls[ nIdx++ ]  = IDC_SECURITYDESCRIPTORPROPERTIES;
   m_arrSecurityControls[ nIdx++ ]  = IDC_SECURITYDESCRIPTORPROPERTYVALUE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_GBACCESSCONTROLENTRIES;
   m_arrSecurityControls[ nIdx++ ]  = IDC_DACLSACL_LIST;
   m_arrSecurityControls[ nIdx++ ]  = IDC_ACELIST;
   m_arrSecurityControls[ nIdx++ ]  = IDC_ACEPROPERTIESLIST;
   m_arrSecurityControls[ nIdx++ ]  = IDC_ACEPROPERTYVALUE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_COPYACE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_PASTEACE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_DELACE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_ADDACE;
   m_arrSecurityControls[ nIdx++ ]  = IDC_COPYACL;
   m_arrSecurityControls[ nIdx++ ]  = IDC_PASTEACL;
   m_arrSecurityControls[ nIdx++ ]  = IDC_COPYSD;
   m_arrSecurityControls[ nIdx++ ]  = IDC_PASTESD;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CSchemaView::~CSchemaView()
{
   if( NULL != pSecurityDescriptor )
   {
      m_pDescriptor->Release( );
      delete pSecurityDescriptor;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSchemaView)
	DDX_Control(pDX, IDC_CLASSOID, m_ClassOID);
	DDX_Control(pDX, IDC_CLASSABSTRACT, m_Abstract);
	DDX_Control(pDX, IDC_MULTIVALUED, m_MultiValued);
	DDX_Control(pDX, IDC_PROPDSNAMES, m_DsNames);
	DDX_Control(pDX, IDC_PROPOID, m_PropOID);
	DDX_Control(pDX, IDC_PROPERTYMANDATORY, m_Mandatory);
	DDX_Control(pDX, IDC_CONTAINEMENT, m_Containment);
	DDX_Control(pDX, IDC_ITEMOLEDSPATH, m_ItemOleDsPath);
	DDX_Control(pDX, IDC_PROPERTYMINRANGE, m_PropertyMinRange);
	DDX_Control(pDX, IDC_PROPERTYMAXRANGE, m_PropertyMaxRange);
	DDX_Control(pDX, IDC_PROPERTYTYPE, m_PropertyType);
	DDX_Control(pDX, IDC_PRIMARYINTERFACE, m_PrimaryInterface);
	DDX_Control(pDX, IDC_HELPFILECONTEXT, m_HelpFileContext);
	DDX_Control(pDX, IDC_DERIVEDFROM, m_DerivedFrom);
	DDX_Control(pDX, IDC_HELPFILENAME, m_HelpFileName);
	DDX_Control(pDX, IDC_CLSID, m_CLSID);
	DDX_Control(pDX, IDC_CONTAINER, m_Container);
	DDX_Control(pDX, IDC_CLASSTYPE, m_ClassType);
	DDX_Control(pDX, IDC_PROPVALUE, m_PropValue);
	DDX_Control(pDX, IDC_PROPLIST, m_PropList);
	//DDX_Control(pDX, IDC_PROPERTIES, m_Schema);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSchemaView, CFormView)
	//{{AFX_MSG_MAP(CSchemaView)
	ON_CBN_SELCHANGE(IDC_PROPLIST, OnSelchangeProplist)
	ON_BN_CLICKED(IDRELOAD, OnReload)
	ON_BN_CLICKED(IDAPPLY, OnApply)
	ON_EN_SETFOCUS(IDC_PROPVALUE, OnSetfocusPropvalue)
	ON_BN_CLICKED(IDC_METHOD1, OnMethod1)
	ON_BN_CLICKED(IDC_METHOD2, OnMethod2)
	ON_BN_CLICKED(IDC_METHOD3, OnMethod3)
	ON_BN_CLICKED(IDC_METHOD4, OnMethod4)
	ON_BN_CLICKED(IDC_METHOD5, OnMethod5)
	ON_BN_CLICKED(IDC_METHOD6, OnMethod6)
	ON_BN_CLICKED(IDC_METHOD7, OnMethod7)
	ON_BN_CLICKED(IDC_METHOD8, OnMethod8)
	ON_BN_CLICKED(IDC_APPEND, OnAppend)
   ON_BN_CLICKED(IDC_DELETE, OnDelete)
	ON_BN_CLICKED(IDC_CHANGE, OnChange)
	ON_BN_CLICKED(IDC_CLEAR, OnClear)
	ON_BN_CLICKED(IDC_GETPROPERTY, OnGetProperty)
	ON_BN_CLICKED(IDC_PUTPROPERTY, OnPutProperty)
	ON_CBN_SELCHANGE(IDC_ACELIST, OnACEChange)
	ON_CBN_SELCHANGE(IDC_ACEPROPERTIESLIST, OnACEPropertyChange)
	ON_CBN_SELCHANGE(IDC_DACLSACL_LIST, OnACLChange)
	ON_CBN_SELCHANGE(IDC_SECURITYDESCRIPTORPROPERTIES, OnSDPropertyChange)
	ON_BN_CLICKED(IDC_ADDACE, OnAddACE)
	ON_BN_CLICKED(IDC_COPYACE, OnCopyACE)
	ON_BN_CLICKED(IDC_PASTEACE, OnPasteACE)
	ON_BN_CLICKED(IDC_DELACE, OnRemoveACE)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSchemaView diagnostics

#ifdef _DEBUG
void CSchemaView::AssertValid() const
{
	CFormView::AssertValid();
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CSchemaView message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::ResetObjectView( )
{
   COleDsObject*  pObject;
   int            nIndex;
   TC_ITEM        tcItem;
   CString        strName;
   CString        strMethCount;
   CString        strMethName;
   int            nMethCount;
   CHAR           szText[ 128 ];
   int            nFirst = 0;

   pObject   = GetDocument( )->GetCurrentObject( );
   if( NULL == pObject )
      return;

   //m_Schema.DeleteAllItems( );
   m_PropList.ResetContent( );

   memset( &tcItem, 0, sizeof(tcItem) );
   tcItem.mask       = TCIF_TEXT;
   tcItem.pszText    = (LPTSTR)szText;
   strName           = _T("");
   tcItem.pszText    = strName.GetBuffer( 128 );

   //bRez     = m_Schema.InsertItem( nIndex, &tcItem );

   // next, we'll get methods count/names
   nIndex   = 0;

   strMethCount   = pObject->GetAttribute( ca_MethodsCount );
   nMethCount     = _ttoi( strMethCount.GetBuffer( 128 ) );
   for( nIndex = 0; nIndex < nMethCount && nIndex < 8; nIndex++ )
   {
      GetDlgItem( nIndex + IDC_METHOD1 )->ShowWindow( SW_SHOW );
      GetDlgItem( nIndex + IDC_METHOD1 )->SetWindowText
            ( pObject->GetAttribute( nIndex, ma_Name ) );
   }

   for( ;nIndex < 8;nIndex++ )
   {
      GetDlgItem( nIndex + IDC_METHOD1 )->ShowWindow( SW_HIDE );
   }

   m_nProperty = -1;

   m_ItemOleDsPath.SetWindowText ( pObject->GetOleDsPath( ) );

   m_ClassType.SetWindowText     ( pObject->GetAttribute( ca_Name ) );
   m_CLSID.SetWindowText         ( pObject->GetAttribute( ca_CLSID ) );
   m_HelpFileName.SetWindowText  ( pObject->GetAttribute( ca_HelpFileName ) );
   m_HelpFileContext.SetWindowText ( pObject->GetAttribute( ca_HelpFileContext ) );
   m_PrimaryInterface.SetWindowText( pObject->GetAttribute( ca_PrimaryInterface ) );
   m_Containment.SetWindowText   ( pObject->GetAttribute( ca_Containment ) );
   m_Container.SetWindowText     ( pObject->GetAttribute( ca_Container ) );
   m_DerivedFrom.SetWindowText   ( pObject->GetAttribute( ca_DerivedFrom ) );
   m_ClassOID.SetWindowText      ( pObject->GetAttribute( ca_OID ) );
   m_Abstract.SetWindowText      ( pObject->GetAttribute( ca_Abstract ) );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint)
{
   if( !m_bInitialized )
   {
      return;
   }
   ResetObjectView( );

   DisplayPropertiesList( );
   m_PropList.SetCurSel( 0 );
   DisplayCurrentPropertyText( );
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::DisplayPropertiesList( )
{
	// TODO: Add your control notification handler code here
	int            nItems, nIter;
   COleDsObject*  pObject;
   CString        strPropName;
   CString        strPropValue;

   PutPropertyValue( );

   pObject  = GetDocument( )->GetCurrentObject( );
   if( NULL == pObject )
   {
      return;
   }

   m_PropList.ResetContent( );

   nItems   = pObject->GetPropertyCount( );

   for( nIter = 0; nIter < nItems ; nIter++ )
   {
      int   nIdx;

      strPropName = pObject->GetAttribute( nIter, pa_DisplayName );
      nIdx  = m_PropList.AddString( strPropName );
      m_PropList.SetItemData( nIdx, (DWORD)nIter );
   }

   m_PropValue.SetWindowText( _T("") );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::DisplayCurrentPropertyText()
{
	// TODO: Add your control notification handler code here
   int            nProp;
   COleDsObject*  pObject;
   HRESULT        hResult;
   CString        strPropValue, strTemp;
   CString        strName;
   BOOL           bSecurityDescriptor  = FALSE;
//   BOOL           bIsACL;

   nProp       = m_PropList.GetCurSel( );
   if( CB_ERR == nProp  )
   {
      return;
   }

   m_nProperty = nProp;

   pObject     = GetDocument()->GetCurrentObject( );
   hResult     = pObject->GetProperty( nProp, strPropValue, &bSecurityDescriptor );

   m_PropValue.SetWindowText( strPropValue );

   //*************

   strName  = pObject->GetAttribute( nProp, pa_Name );

   strTemp  = pObject->GetAttribute( nProp, pa_Type );
   m_PropertyType.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_MinRange );
   m_PropertyMinRange.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_MaxRange );
   m_PropertyMaxRange.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_MultiValued );
   m_MultiValued.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_OID );
   m_PropOID.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_DsNames );
   m_DsNames.SetWindowText( strTemp );

   //*************
   strTemp  = pObject->GetAttribute( nProp, pa_Mandatory );
   m_Mandatory.SetWindowText( strTemp );

   strTemp  = pObject->GetAttribute( nProp, pa_Type );
   if( bSecurityDescriptor )
   {
      // we need to display the security descriptor stuff...
      if( !m_bACLDisplayed )
      {
         HideControls( TRUE );
         ShowControls( FALSE );
      }
	  if( NULL != pSecurityDescriptor )
	  {
		delete pSecurityDescriptor;
	  }
      if( NULL != m_pDescriptor )
	  {
		m_pDescriptor->Release( );	
	  }
      m_bACLDisplayed   = TRUE;
      DisplayACL( pObject, strName );
   }
   else
   {
      if( m_bACLDisplayed )
      {
         HideControls( FALSE );
         ShowControls( TRUE );
         delete pSecurityDescriptor;
         m_pDescriptor->Release( );
      }
      m_bACLDisplayed      = FALSE;
      m_pDescriptor        = NULL;
      pSecurityDescriptor  = NULL;

   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnSelchangeProplist()
{
	// TODO: Add your control notification handler code here
   PutPropertyValue( );
   DisplayCurrentPropertyText( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnReload()
{
   HRESULT        hResult;
   COleDsObject*  pObject;
   HCURSOR        aCursor, oldCursor;

   pObject  = GetDocument()->GetCurrentObject( );

   if( NULL == pObject )
   {
      return;
   }

   aCursor     = LoadCursor( NULL, IDC_WAIT );
   oldCursor   = SetCursor( aCursor );

   hResult  = pObject->GetInfo( );

   DisplayPropertiesList( );

   if( -1 != m_nProperty )
   {
      m_PropList.SetCurSel( m_nProperty );
   }
   else
   {
      m_PropList.SetCurSel( 0 );
   }

   DisplayCurrentPropertyText( );

   m_bDirty = FALSE;

   SetCursor( oldCursor );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CSchemaView::PutPropertyValue()
{
   COleDsObject*  pObject;
   HRESULT        hResult;
   CString        strPropValue;

   // if we're displaying security descriptors, we'll force the dirty flag
   m_bDirty = m_bDirty || (NULL != pSecurityDescriptor);

   if( -1 == m_nProperty || !m_bDirty )
   {
      return S_OK;
   }

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return S_OK;

   if( NULL != pSecurityDescriptor )
   {
      // OK, so we need to set the security descriptor
      VARIANT     var;
      IUnknown*   pUnk;
      IADs*       pADs;
      CString     strName;
      BSTR        bstrName;

      strName  = pObject->GetAttribute( m_nProperty, pa_Name );
      bstrName = AllocBSTR( strName.GetBuffer( 128 ) );

      VariantInit( &var );
      V_VT( &var )         = VT_DISPATCH;
      V_DISPATCH( &var )   = m_pDescriptor;
      m_pDescriptor->AddRef( );

      pObject->GetInterface( &pUnk );
      pUnk->QueryInterface( IID_IADs, (void**)&pADs );

      hResult  = pADs->Put( bstrName, var );

      SysFreeString( bstrName );

      VariantClear( &var );

      if( FAILED( hResult ) )
      {
         AfxMessageBox( OleDsGetErrorText( hResult ) );
      }
   }
   else
   {
      m_PropValue.GetWindowText( strPropValue );

      hResult  = pObject->PutProperty( m_nProperty,
                                       strPropValue );
   }

   m_bDirty = FALSE;

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnApply()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;
   HCURSOR        aCursor, oldCursor;

   pObject  = GetDocument()->GetCurrentObject( );

   if( NULL == pObject )
   {
      return;
   }

   aCursor        = LoadCursor( NULL, IDC_WAIT );
   oldCursor      = SetCursor( aCursor );

   hResult        = PutPropertyValue( );

   hResult        = pObject->SetInfo( );
   //hResult        = pObject->GetInfo( );

   m_bDirty       = FALSE;

   DisplayPropertiesList( );

   if( -1 != m_nProperty )
   {
      m_PropList.SetCurSel( m_nProperty );
   }
   else
   {
      m_PropList.SetCurSel( 0 );
   }

   DisplayCurrentPropertyText( );

   SetCursor( oldCursor );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod1()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 0 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod2()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 1 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod3()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 2 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod4()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 3 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod5()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 4 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod6()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 5 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod7()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 6 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnMethod8()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   COleDsObject*  pObject;

   pObject  = GetDocument()->GetCurrentObject( );

   hResult  = pObject->CallMethod( 7 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnSetfocusPropvalue()
{
	// TODO: Add your control notification handler code here
	m_bDirty = TRUE;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnInitialUpdate()
{
	m_bInitialized   = TRUE;

   CFormView::OnInitialUpdate();
	// TODO: Add your specialized code here and/or call the base class

   HideControls( FALSE );
   ShowControls( TRUE );
   m_bACLDisplayed   = FALSE;

   OnUpdate( NULL, 0L, NULL);
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::ShowControls( BOOL bNormal )
{
   int*  pControlArray;
   int   nIdx;

   pControlArray  = bNormal ? m_arrNormalControls : m_arrSecurityControls;
   for( nIdx = 0; nIdx < 32 ; nIdx++ )
   {
      CWnd* pWnd;

      if( pControlArray[ nIdx ] > 0 )
      {
         pWnd  = GetDlgItem( pControlArray[ nIdx ] );
         if( NULL != pWnd )
         {
            pWnd->ShowWindow( SW_SHOW );
         }
      }
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::HideControls(BOOL bNormal)
{
   int*  pControlArray;
   int   nIdx;

   pControlArray  = bNormal ? m_arrNormalControls : m_arrSecurityControls;
   for( nIdx = 0; nIdx < 32 ; nIdx++ )
   {
      CWnd* pWnd;

      if( pControlArray[ nIdx ] > 0 )
      {
         pWnd  = GetDlgItem( pControlArray[ nIdx ] );
         if( NULL != pWnd )
         {
            pWnd->ShowWindow( SW_HIDE );
         }
      }
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnAppend()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   CString        strPropValue;
   COleDsObject*  pObject;

   if( -1 == m_nProperty )
   {
      return;
   }

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;


   m_PropValue.GetWindowText( strPropValue );
   hResult     = pObject->PutProperty(
                                       (int)( m_PropList.GetItemData( m_nProperty ) ),
                                       strPropValue,
                                       ADS_ATTR_APPEND
                                     );
   m_bDirty    = FALSE;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnDelete()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   CString        strPropValue;
   COleDsObject*  pObject;

   if( -1 == m_nProperty )
   {
      return;
   }

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;


   m_PropValue.GetWindowText( strPropValue );
   hResult     = pObject->PutProperty(
                                       (int)( m_PropList.GetItemData( m_nProperty ) ),
                                       strPropValue,
                                       ADS_ATTR_DELETE
                                     );
   m_bDirty    = FALSE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnChange()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   CString        strPropValue;
   COleDsObject*  pObject;

   if( -1 == m_nProperty )
   {
      return;
   }

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;


   m_PropValue.GetWindowText( strPropValue );
   hResult     = pObject->PutProperty(
                                      (int)( m_PropList.GetItemData( m_nProperty ) ),
                                      strPropValue,
                                      ADS_PROPERTY_UPDATE );
   m_bDirty = TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnClear()
{
	// TODO: Add your control notification handler code here
   HRESULT        hResult;
   CString        strPropValue;
   COleDsObject*  pObject;

   if( -1 == m_nProperty  )
   {
      return;
   }

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;


   m_PropValue.GetWindowText( strPropValue );
   hResult     = pObject->PutProperty(
                                      (int)( m_PropList.GetItemData( m_nProperty ) ),
                                      strPropValue,
                                      ADS_PROPERTY_CLEAR );
   m_bDirty = FALSE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnGetProperty()
{
	// TODO: Add your control notification handler code here
   CPropertyDialog   pPropDialog;
   COleDsObject*     pObject;
   HRESULT           hResult;
   CString           strValue;

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;

   //pPropDialog.PutFlag( FALSE );
   if( pPropDialog.DoModal( ) != IDOK )
      return;


   hResult  = pObject->GetProperty( pPropDialog.m_PropertyName,
                                    strValue,
                                    TRUE,
                                    ADsTypeFromString( pPropDialog.m_PropertyType ) );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSchemaView::OnPutProperty()
{
	// TODO: Add your control notification handler code here
// TODO: Add your control notification handler code here
   CPropertyDialog   pPropDialog;
   COleDsObject*     pObject;
   HRESULT           hResult;
   CString           strValue;

   pObject      = GetDocument()->GetCurrentObject( );
   if( NULL == pObject )
      return;

   //pPropDialog.PutFlag( FALSE );
   if( pPropDialog.DoModal( ) != IDOK )
      return;

   hResult  = pObject->PutProperty( pPropDialog.m_PropertyName,
                                    pPropDialog.m_PropertyValue,
                                    TRUE,
                                    ADsTypeFromString( pPropDialog.m_PropertyType ) );
}

/////////////////////////////////////////////////////////////////////////////
// CSetMandatoryProperties dialog


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CSetMandatoryProperties::CSetMandatoryProperties(CWnd* pParent /*=NULL*/)
	: CDialog(CSetMandatoryProperties::IDD, pParent)
{
	//{{AFX_DATA_INIT(CSetMandatoryProperties)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
   m_nFuncSet     = -1;
   m_nProperty    = -1;
   m_bDirty       = FALSE;
   m_bInitialized = FALSE;
   m_pObject      = NULL;

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSetMandatoryProperties)
   DDX_Control(pDX, IDC_CONTAINEMENT, m_Containment);
	DDX_Control(pDX, IDC_ITEMOLEDSPATH, m_ItemOleDsPath);
	DDX_Control(pDX, IDC_PROPERTYOPTIONAL, m_PropertyOptional);
	DDX_Control(pDX, IDC_PROPERTYNORMAL, m_PropertyNormal);
	DDX_Control(pDX, IDC_PROPERTYMINRANGE, m_PropertyMinRange);
	DDX_Control(pDX, IDC_PROPERTYMAXRANGE, m_PropertyMaxRange);
	DDX_Control(pDX, IDC_PROPERTYTYPE, m_PropertyType);
	DDX_Control(pDX, IDC_PRIMARYINTERFACE, m_PrimaryInterface);
	DDX_Control(pDX, IDC_HELPFILECONTEXT, m_HelpFileContext);
	DDX_Control(pDX, IDC_DERIVEDFROM, m_DerivedFrom);
	DDX_Control(pDX, IDC_HELPFILENAME, m_HelpFileName);
	DDX_Control(pDX, IDC_CLSID, m_CLSID);
	DDX_Control(pDX, IDC_CONTAINER, m_Container);
	DDX_Control(pDX, IDC_CLASSTYPE, m_ClassType);
	DDX_Control(pDX, IDC_PROPVALUE, m_PropValue);
	DDX_Control(pDX, IDC_PROPLIST, m_PropList);
	DDX_Control(pDX, IDC_PROPERTIES, m_Schema);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSetMandatoryProperties, CDialog)
	//{{AFX_MSG_MAP(CSetMandatoryProperties)
   ON_NOTIFY(TCN_SELCHANGE, IDC_PROPERTIES, OnSelchangeProperties)
	ON_CBN_SELCHANGE(IDC_PROPLIST, OnSelchangeProplist)
	ON_EN_SETFOCUS(IDC_PROPVALUE, OnSetfocusPropvalue)
	ON_BN_CLICKED(IDOK, OnOK)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSetMandatoryProperties message handlers

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::SetOleDsObject( COleDsObject* pObject )
{
   m_pObject   = pObject;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::OnSelchangeProperties(NMHDR* pNMHDR, LRESULT* pResult)
{
	// TODO: Add your control notification handler code here
	int            nSel, nItems, nIter;
   CString        strPropName;
   CString        strPropValue;
   CString        strMandatory;

	*pResult = 0;

   PutPropertyValue( );
   nSel        = m_Schema.GetCurSel( );
   if( nSel == LB_ERR )
   {
      return;
   }
   m_nFuncSet  = nSel;
   m_nProperty = -1;

   m_PropList.ResetContent( );

   nItems   = m_pObject->GetPropertyCount( );

   for( nIter = 0; nIter < nItems ; nIter++ )
   {
      int   nIdx;

      strMandatory   = m_pObject->GetAttribute( nIter, pa_Mandatory );
      if( strMandatory == _T("Yes") )
      //if( TRUE )
      {
         strPropName = m_pObject->GetAttribute( nIter, pa_DisplayName );
         nIdx  = m_PropList.AddString( strPropName );
         m_PropList.SetItemData( nIdx, nIter );
      }
   }

   m_PropList.SetCurSel( 0 );

   OnSelchangeProplist( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::OnSelchangeProplist()
{
	// TODO: Add your control notification handler code here
   int            nMandProp, nProp, nFuncSet;
   HRESULT        hResult;
   CString        strPropValue;
   CString        strTemp;


   PutPropertyValue( );
   m_PropValue.SetWindowText( _T("") );
   nProp       = m_PropList.GetCurSel( );
   nMandProp   = (int)m_PropList.GetItemData( nProp );
   nFuncSet    = m_Schema.GetCurSel( );

   if( CB_ERR == nProp  || CB_ERR == nFuncSet )
   {
      return;
   }

   m_nProperty = nProp;
   m_nFuncSet  = nFuncSet;

   hResult  = m_pObject->GetProperty( nMandProp, strPropValue );

   m_PropValue.SetWindowText( strPropValue );

   //******************
   strTemp  = m_pObject->GetAttribute( nMandProp, pa_Type );
   m_PropertyType.SetWindowText( strTemp );

   //******************
   strTemp  = m_pObject->GetAttribute( nMandProp, pa_MinRange );
   m_PropertyMinRange.SetWindowText( strTemp );

   //******************
   strTemp  = m_pObject->GetAttribute( nMandProp, pa_MaxRange );
   m_PropertyMaxRange.SetWindowText( strTemp );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::OnSetfocusPropvalue()
{
	// TODO: Add your control notification handler code here
	m_bDirty = TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CSetMandatoryProperties::OnOK()
{
	// TODO: Add your control notification handler code here
   PutPropertyValue( );
   CDialog::OnOK( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CSetMandatoryProperties::PutPropertyValue()
{
   HRESULT        hResult;
   CString        strPropValue;

   if( -1 == m_nProperty || -1 == m_nFuncSet || !m_bDirty )
   {
      return S_OK;
   }
   m_PropValue.GetWindowText( strPropValue );
   hResult  = m_pObject->PutProperty( (int)( m_PropList.GetItemData( m_nProperty ) ),
                                      strPropValue );
   m_bDirty = FALSE;

   return S_OK;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CSetMandatoryProperties::OnInitDialog()
{
   int         nIndex;
   TC_ITEM     tcItem;
   CString     strName;
   CHAR        szText[ 128 ];
   BOOL        bRez;
   LRESULT     lResult;

   CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
   m_Schema.DeleteAllItems( );

   memset( &tcItem, 0, sizeof(tcItem) );
   tcItem.mask       = TCIF_TEXT;
   tcItem.pszText    = (LPTSTR)szText;


   nIndex = 0;

   strName           = _T("");
   tcItem.pszText    = strName.GetBuffer( 128 );
   bRez              = m_Schema.InsertItem( nIndex, &tcItem );

   m_nFuncSet  = -1;
   m_nProperty = -1;
   m_Schema.SetCurSel( 0 );

   m_ItemOleDsPath.SetWindowText( m_pObject->GetOleDsPath( ) );

   m_ClassType.SetWindowText( m_pObject->GetAttribute( ca_Name ) );

   m_CLSID.SetWindowText( m_pObject->GetAttribute( ca_CLSID ) );

   m_HelpFileName.SetWindowText( m_pObject->GetAttribute( ca_HelpFileName ) );

   m_PrimaryInterface.SetWindowText( m_pObject->GetAttribute( ca_PrimaryInterface ) );

   m_Containment.SetWindowText( m_pObject->GetAttribute( ca_Containment ) );

   m_Container.SetWindowText  ( m_pObject->GetAttribute( ca_Container ) );

   m_DerivedFrom.SetWindowText( m_pObject->GetAttribute( ca_DerivedFrom ) );

   OnSelchangeProperties( NULL, &lResult );
	
	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CPropertyDialog dialog


CPropertyDialog::CPropertyDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CPropertyDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPropertyDialog)
	m_PropertyName = _T("");
	m_PropertyType = _T("");
	m_PropertyValue = _T("");
	//}}AFX_DATA_INIT
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CPropertyDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropertyDialog)
	DDX_CBString(pDX, IDC_NEWPROPERTYNAME, m_PropertyName);
	DDX_CBString(pDX, IDC_NEWPROPERTYTYPE, m_PropertyType);
	DDX_CBString(pDX, IDC_NEWPROPERTYVALUE, m_PropertyValue);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CPropertyDialog, CDialog)
	//{{AFX_MSG_MAP(CPropertyDialog)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPropertyDialog message handlers


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL CPropertyDialog::OnInitDialog()
{
	
   CString     strLastValue;
   CComboBox*  pCombo;

   CDialog::OnInitDialog();
	
	// TODO: Add extra initialization here
   //*******************

   GetLRUList( IDC_NEWPROPERTYNAME,  _T("PropertyDialog_Name") );

	// TODO: Add extra initialization here
   //*******************
   pCombo   = (CComboBox*)GetDlgItem( IDC_NEWPROPERTYTYPE );
   pCombo->AddString( _T("ADSTYPE_DN_STRING") );
	pCombo->AddString( _T("ADSTYPE_CASE_EXACT_STRING") );
   pCombo->AddString( _T("ADSTYPE_CASE_IGNORE_STRING") );
	pCombo->AddString( _T("ADSTYPE_PRINTABLE_STRING") );
	pCombo->AddString( _T("ADSTYPE_NUMERIC_STRING") );
	pCombo->AddString( _T("ADSTYPE_BOOLEAN") );
	pCombo->AddString( _T("ADSTYPE_INTEGER") );
	pCombo->AddString( _T("ADSTYPE_OCTET_STRING") );
	pCombo->AddString( _T("ADSTYPE_UTC_TIME") );
	pCombo->AddString( _T("ADSTYPE_LARGE_INTEGER") );
	pCombo->AddString( _T("ADSTYPE_PROV_SPECIFIC") );

	
	// TODO: Add extra initialization here
   //*******************
   GetLRUList( IDC_NEWPROPERTYVALUE, _T("PropertyDialog_Value") );

   //GetLastProfileString( _T("PropertyDialog_IsMultiValued"),
   //                      strLastValue );
   //if( strLastValue.CompareNoCase( _T("Yes") ) )
   //{
      //m_Secure.SetCheck( 0 );
   //}

	return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CPropertyDialog::OnOK()
{
   // TODO: Add extra validation here
   //*******************
	GetDlgItemText( IDC_NEWPROPERTYNAME, m_PropertyName );
   SaveLRUList( IDC_NEWPROPERTYNAME,  _T("PropertyDialog_Name"), 20 );

	//*******************
   GetDlgItemText( IDC_NEWPROPERTYTYPE, m_PropertyType );

   //*******************
   GetDlgItemText( IDC_NEWPROPERTYVALUE, m_PropertyValue );
   SaveLRUList( IDC_NEWPROPERTYVALUE, _T("PropertyDialog_Value"), 20 );

   CDialog::OnOK();
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CPropertyDialog::SaveLRUList( int idCBox, TCHAR* pszSection, int nMax )
{
   CComboBox*  pCombo;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   CString     strText, strItem;
   int         nVal, nIdx, nItems;

   pCombo   = (CComboBox*)GetDlgItem( idCBox );
   pCombo->GetWindowText( strText );

   _tcscpy( szEntry, _T("Value_1") );

   if( strText.GetLength( ) )
   {
      WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strText, ADSVW_INI_FILE );
   }

   nItems   = pCombo->GetCount( );
   nVal     = 2;

   for( nIdx = 0; nItems != CB_ERR && nIdx < nItems && nIdx < nMax ; nIdx ++ )
   {
      pCombo->GetLBText( nIdx, strItem );

      if( strItem.CompareNoCase( strText ) )
      {
         _itot( nVal++, szIndex, 10 );
         _tcscpy( szEntry, _T("Value_") );
         _tcscat( szEntry, szIndex );
         WritePrivateProfileString( pszSection, szEntry, (LPCTSTR)strItem, ADSVW_INI_FILE );
      }
   }
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CPropertyDialog::GetLRUList( int idCBox, TCHAR* pszSection )
{
   CComboBox*  pCombo;
   int         nIter;
   TCHAR       szEntry[ MAX_PATH ];
   TCHAR       szIndex[ 8 ];
   TCHAR       szValue[ 1024 ];

   pCombo   = (CComboBox*)GetDlgItem( idCBox );

   for( nIter = 0; nIter < 100 ; nIter++ )
   {
      _itot( nIter + 1, szIndex, 10 );
      _tcscpy( szEntry, _T("Value_") );
      _tcscat( szEntry, szIndex );
      GetPrivateProfileString( pszSection, szEntry,
                               _T(""), szValue, 1023, ADSVW_INI_FILE );
      if( _tcslen( szValue ) )
      {
         pCombo->AddString( szValue );
      }
   }

   pCombo->SetCurSel( 0 );
}


//***********************************************************
//  Function:
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplayACL(COleDsObject * pObject, CString strAttrName)
{
   VARIANT     var;
   BSTR        bstrName;
   IADs*       pIADs = NULL;
   IUnknown*   pIUnk = NULL;
   HRESULT     hResult;

   while( TRUE )
   {
      hResult  = pObject->GetInterface( &pIUnk );
      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      hResult  = pIUnk->QueryInterface( IID_IADs, (void**)&pIADs );
      pIUnk->Release( );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      bstrName = AllocBSTR( strAttrName.GetBuffer( 128 ) );
      hResult  = pIADs->Get( bstrName, &var );
      SysFreeString( bstrName );
      pIADs->Release( );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      m_pDescriptor  = CopySD( V_DISPATCH( &var ) );
      VariantClear( &var );
      {
         //SMITHA IUnknown*   pIUnk;

         hResult  = m_pDescriptor->QueryInterface( IID_IUnknown,
                                                   (void**)&pIUnk );
         pSecurityDescriptor  = new CADsSecurityDescriptor( pIUnk );
		 pIUnk->Release( );
         pSecurityDescriptor->SetDocument( GetDocument( ) );
      }

      VariantClear( &var );



      FillACLControls( );

      break;
   }
}


//***********************************************************
//  Function:    CSchemaView::FillACLControls
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void  CSchemaView::FillACLControls()
{
   DisplaySDPropertiesList( 0 );

   DisplaySDPropertyValue( );

   DisplayACLNames( 0 );

   DisplayACENames( 0 );

   DisplayACEPropertiesList( 0 );

   DisplayACEPropertyValue( );


}


//***********************************************************
//  Function:    CSchemaView::DisplayACLNames
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplayACLNames( int nSelect )
{
   CComboBox*   pACLNames;

   pACLNames   = (CComboBox*)GetDlgItem( IDC_DACLSACL_LIST );
   pACLNames->ResetContent( );

   pACLNames->AddString( _T("DACL") );
   pACLNames->AddString( _T("SACL") );

   pACLNames->SetCurSel( nSelect );

   m_nLastACL  = GetCurrentACL( );
}


//***********************************************************
//  Function:    CSchemaView::DisplayACENames
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplayACENames( int nSelect )
{
   ACLTYPE                    eType;
   int                        nACECount, nIdx;
   CComboBox*                 pACENames;
   CString                    strACEName;
   CADsAccessControlEntry*    pACE;
   CADsAccessControlList*     pACL;

   eType       = GetCurrentACL( );

   pACENames   = (CComboBox*)GetDlgItem( IDC_ACELIST );
   pACENames->ResetContent( );

   pACL        = pSecurityDescriptor->GetACLObject( eType );
   if( NULL != pACL )
   {
	   nACECount   = pACL->GetACECount( );

	   for( nIdx = 0; nIdx < nACECount ; nIdx++ )
	   {
	      pACE        = pACL->GetACEObject( nIdx );
         if( NULL != pACE )
         {
            strACEName  = pACE->GetItemName(  );
            pACENames->AddString( strACEName );
         }
      }
   }

   m_nLastACE  = nSelect;

   pACENames->SetCurSel( nSelect );
}


//***********************************************************
//  Function:    CSchemaView::DisplayACEPropertiesList
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplayACEPropertiesList( int nSelect )
{
   ACLTYPE                    eType;
   int                        nACE;
   CComboBox*                 pACEPropList;
   int                        nAttrCount, nIdx;
   CString                    strPropName;
   CADsAccessControlEntry*    pACE;
   CADsAccessControlList*     pACL;

   eType       = GetCurrentACL( );
   nACE        = GetCurrentACE( );
   if( -1 == nACE )
   {
      return;
   }

   pACEPropList= (CComboBox*)GetDlgItem( IDC_ACEPROPERTIESLIST );
   pACEPropList->ResetContent( );

   pACL        = pSecurityDescriptor->GetACLObject( eType );
	if(NULL == pACL)
		return;

   pACE        = pACL->GetACEObject( nACE );
	if(NULL == pACE)
		return;

   nAttrCount  = pACE->GetPropertyCount( );
   for( nIdx = 0; nIdx < nAttrCount ; nIdx++ )
   {
      int   nPos;

      strPropName = pACE->GetAttribute( nIdx, pa_DisplayName );
      nPos        = pACEPropList->AddString( strPropName );
      m_PropList.SetItemData( nPos, (DWORD)nIdx );
   }

   pACEPropList->SetCurSel( nSelect );
}


//***********************************************************
//  Function:    CSchemaView::DisplaySDPropertiesList
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplaySDPropertiesList(int nSelect)
{
   CComboBox*  pSDPropList;
   int         nAttrCount, nIdx;
   CString     strPropName;

   pSDPropList = (CComboBox*)GetDlgItem( IDC_SECURITYDESCRIPTORPROPERTIES );
   pSDPropList->ResetContent( );

   nAttrCount  = pSecurityDescriptor->GetPropertyCount( );

   for( nIdx = 0; nIdx < nAttrCount ; nIdx++ )
   {
      int   nPos;

      strPropName = pSecurityDescriptor->GetAttribute( nIdx, pa_DisplayName );
      nPos        = pSDPropList->AddString( strPropName );
      m_PropList.SetItemData( nPos, (DWORD)nIdx );
   }

   pSDPropList->SetCurSel( nSelect );
}


//***********************************************************
//  Function:    CSchemaView::DisplayACEPropertyValue
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplayACEPropertyValue( )
{
   CString                    strPropValue;
   HRESULT                    hResult;
   CADsAccessControlEntry*    pACE;
   CADsAccessControlList*     pACL;
   LONG                       lValue;
   TCHAR                      szHex[ 128 ];

   m_nLastACEValue = GetCurrentACEProperty( );

   if( -1 == m_nLastACEValue )
      return;

   if( acl_Invalid == m_nLastACL )
      return;

   if( -1 == m_nLastACE )
      return;

   pACL        = pSecurityDescriptor->GetACLObject( m_nLastACL );
   if( NULL == pACL )
   {
      return;
   }

   pACE        = pACL->GetACEObject( m_nLastACE );

   if( NULL == pACE )
      return;

   hResult     = pACE->GetProperty( m_nLastACEValue, strPropValue );

   switch( m_nLastACEValue )
   {
      case  1:
      case  2:
      case  3:
      case  4:
         lValue   = _ttol( strPropValue.GetBuffer( 128 ) );
         _tcscpy( szHex, _T("0x" ) );
         _ltot( lValue, szHex + _tcslen(szHex), 16 );
         strPropValue   = szHex;
         break;

      default:
         break;
   }


   GetDlgItem( IDC_ACEPROPERTYVALUE )->SetWindowText(
               strPropValue );

}


//***********************************************************
//  Function:    CSchemaView::DisplaySDPropertyValue
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::DisplaySDPropertyValue( )
{
   CString  strPropValue, strEditValue;
   HRESULT  hResult;

   m_nLastSDValue = GetCurrentSDProperty( );

   hResult     = pSecurityDescriptor->GetProperty( m_nLastSDValue,
                                                   strPropValue );
   GetDlgItem( IDC_SECURITYDESCRIPTORPROPERTYVALUE )->SetWindowText(
               strPropValue );

}


//***********************************************************
//  Function:    CSchemaView::PutACEPropertyValue
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::PutACEPropertyValue( )
{
   ACLTYPE                    eType;
   int                        nACE;
   CString                    strPropValue, strEditValue;
   CADsAccessControlEntry*    pACE;
   CADsAccessControlList*     pACL;
   HRESULT                    hResult;

   if( -1 == m_nLastACEValue )
      return;

   if( acl_Invalid == m_nLastACL )
      return;

   if( -1 == m_nLastACE )
      return;

   eType       = m_nLastACL;
   nACE        = m_nLastACE;

   pACL        = pSecurityDescriptor->GetACLObject( eType );
   if( NULL == pACL )
      return;

   pACE        = pACL->GetACEObject( nACE );

   GetDlgItem( IDC_ACEPROPERTYVALUE )->GetWindowText( strEditValue );

   switch( m_nLastACEValue )
   {
      case  1:
      case  2:
      case  3:
      case  4:
      {
         LONG  lValue   = 0;
         TCHAR szText[ 16 ];
         int nRet = 0;

         nRet = _stscanf( strEditValue.GetBuffer( 128 ), _T("%lx"), &lValue );

         _ltot( lValue, szText, 10 );
         strEditValue   = szText;
         break;
      }

      default:
         break;
   }
   hResult     = pACE->GetProperty( m_nLastACEValue, strPropValue );


   if( strEditValue.Compare( strPropValue ) )
   {
      hResult  = pACE->PutProperty( m_nLastACEValue, strEditValue );
   }
}


//***********************************************************
//  Function:    CSchemaView::PutSDPropertyValue
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::PutSDPropertyValue()
{
   CString  strPropValue, strEditValue;
   HRESULT  hResult;

   if( -1 == m_nLastSDValue )
      return;

   hResult     = pSecurityDescriptor->GetProperty( m_nLastSDValue,
                                                   strPropValue );

   GetDlgItem( IDC_SECURITYDESCRIPTORPROPERTYVALUE )->GetWindowText(
               strEditValue );

   if( strEditValue.Compare( strPropValue ) )
   {
      hResult  = pSecurityDescriptor->PutProperty( m_nLastACEValue,
                                                   strEditValue );
   }

}


//***********************************************************
//  Function:    CSchemaView::GetCurrentACL
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
ACLTYPE CSchemaView::GetCurrentACL()
{
   CComboBox*  pList;

   pList = (CComboBox*) GetDlgItem( IDC_DACLSACL_LIST );

   return (ACLTYPE) ( 1 + pList->GetCurSel( ) );
}


//***********************************************************
//  Function:    CSchemaView::GetCurrentACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
int   CSchemaView::GetCurrentACE()
{
   CComboBox*  pList;

   pList = (CComboBox*) GetDlgItem( IDC_ACELIST );

   return pList->GetCurSel( );

}


//***********************************************************
//  Function:    CSchemaView::GetCurrentSDProperty
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
int   CSchemaView::GetCurrentSDProperty( )
{
   CComboBox*  pList;

   pList = (CComboBox*) GetDlgItem( IDC_SECURITYDESCRIPTORPROPERTIES );

   return pList->GetCurSel( );
}


//***********************************************************
//  Function:    CSchemaView::GetCurrentACEProperty
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
int   CSchemaView::GetCurrentACEProperty( )
{
   CComboBox*  pList;

   pList = (CComboBox*) GetDlgItem( IDC_ACEPROPERTIESLIST );

   return pList->GetCurSel( );
}


//***********************************************************
//  Function:    CSchemaView::OnACEChange
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnACEChange( )
{
	// TODO: Add your control notification handler code here
	PutACEPropertyValue( );

   m_nLastACE  = GetCurrentACE( );

   DisplayACEPropertiesList( 0 );

   DisplayACEPropertyValue( );
}


//***********************************************************
//  Function:    CSchemaView::OnACEPropertyChange
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnACEPropertyChange()
{
	// TODO: Add your control notification handler code here
   PutACEPropertyValue( );

   DisplayACEPropertyValue( );
}


//***********************************************************
//  Function:    CSchemaView::OnACLChange
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnACLChange()
{
	// TODO: Add your control notification handler code here
   PutACEPropertyValue( );

   m_nLastACL  = GetCurrentACL( );

   DisplayACENames( 0 );

   DisplayACEPropertiesList( 0 );

   DisplayACEPropertyValue( );
}


//***********************************************************
//  Function:    CSchemaView::OnSDPropertyChange
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnSDPropertyChange()
{
	// TODO: Add your control notification handler code here
	PutSDPropertyValue( );

   DisplaySDPropertyValue( );
}


//***********************************************************
//  Function:    CSchemaView::OnAddACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnAddACE()
{
	// TODO: Add your control notification handler code here
   ACLTYPE  aclType;
   HRESULT  hResult;

   aclType  = GetCurrentACL( );

   if( acl_Invalid != aclType )
   {
      IDispatch*  pACEDisp;
      IUnknown*   pACEUnk;
      CADsAccessControlEntry* pACE  = new CADsAccessControlEntry;

      pACEDisp = pACE->CreateACE( );

      delete   pACE;

      if( NULL != pACEDisp )
      {
         hResult  = pACEDisp->QueryInterface( IID_IUnknown, (void**)&pACEUnk );
         pACEDisp->Release( );

         hResult  = pSecurityDescriptor->AddACE( aclType, pACEUnk );
         pACEUnk->Release( );
         FillACLControls( );
      }
   }
}


//***********************************************************
//  Function:    CSchemaView::OnCopyACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnCopyACE()
{
	// TODO: Add your control notification handler code here
   int         nACE;
   IDispatch*  pDisp;
   ACLTYPE     aclType;

   aclType  = GetCurrentACL( );	
   nACE     = GetCurrentACE( );

   pDisp    = CopyACE( pSecurityDescriptor->GetACLObject( aclType )->GetACEObject( nACE )->GetACE( ) );

   if( NULL != pACEClipboard )
   {
      pACEClipboard->Release( );
   }

   pACEClipboard  = pDisp;
}


//***********************************************************
//  Function:    CSchemaView::OnPasteACE
//  Arguments:
//  Return:
//  Purpose:
//  Author(s):
//  Revision:
//  Date:
//***********************************************************
void CSchemaView::OnPasteACE()
{
   // TODO: Add your control notification handler code here
   IUnknown*   pACEUnk;
   ACLTYPE     aclType;
   HRESULT     hResult;

   aclType  = GetCurrentACL( );	
   if( NULL != pACEClipboard )
   {
      hResult  = pACEClipboard->QueryInterface( IID_IUnknown, (void**)&pACEUnk );

      hResult  = pSecurityDescriptor->AddACE( aclType, pACEUnk );
      pACEUnk->Release( );
      FillACLControls( );
   }
}

void CSchemaView::OnRemoveACE()
{
	// TODO: Add your control notification handler code here
	// TODO: Add your control notification handler code here
   ACLTYPE  aclType;
   HRESULT  hResult;
   int      nCurrentACE;

   aclType     = GetCurrentACL( );
   nCurrentACE = GetCurrentACE( );

   if( acl_Invalid != aclType )
   {
      IDispatch*  pACEDisp;
      IUnknown*   pACEUnk;

      pACEDisp = pSecurityDescriptor->GetACLObject( aclType )->GetACEObject( nCurrentACE )->GetACE( );

      if( NULL != pACEDisp )
      {
         hResult  = pACEDisp->QueryInterface( IID_IUnknown, (void**)&pACEUnk );
         pACEDisp->Release( );

         hResult  = pSecurityDescriptor->RemoveACE( aclType, pACEUnk );
         pACEUnk->Release( );
         FillACLControls( );
      }
   }
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\schclss.h ===
#ifndef  _SCHEMACLASSES_H_
#define  _SCHEMACLASSES_H_

//#include "csyntax.h"

class COleDsSyntax;
class CMainDoc;

typedef enum _tagCLASSATTR
{
   ca_ERROR=0,
   ca_Name,
   ca_DisplayName,
   ca_CLSID,
   ca_PrimaryInterface,
   ca_OID,
   ca_Abstract,
   ca_DerivedFrom,
   ca_Containment,
   ca_Container,
   ca_HelpFileName,
   ca_HelpFileContext,
   ca_MethodsCount,
   ca_Limit
} CLASSATTR;

typedef enum _tagFUNCSETATTR
{
   fa_ERROR=0,
   fa_Name,
   fa_DisplayName,
   fa_Limit
} FUNCSETATTR;


typedef enum _tagMETHODATTR
{
   ma_ERROR=0,
   ma_Name,
   ma_DisplayName,
   ma_Limit
} METHODATTR;


typedef enum _tagPROPATTR
{
   pa_ERROR=0,
   pa_Name,
   pa_DisplayName,
   pa_Type,
   pa_DsNames,
   pa_OID,
   pa_MaxRange,
   pa_MinRange,
   pa_Mandatory,
   pa_MultiValued,
   pa_Limit
} PROPATTR;


class CMethod: public CObject
{
   public:
      CMethod( );
      CMethod( ITypeInfo*, FUNCDESC* );
      ~CMethod( );

      CString  GetName( );
      int      GetArgCount( );
      int      GetArgOptionalCount( );
      VARTYPE  GetMethodReturnType( );
      BOOL     ConvertArgument( int nArg, CString strArg, VARIANT* );
      HRESULT  CallMethod     ( IDispatch* pIDispatch, BOOL* pDisplay );
      CString  GetAttribute   ( METHODATTR  );
      HRESULT  PutAttribute   ( METHODATTR, CString& );

   private:
      int            m_nArgs;
      int            m_nArgsOpt;
      CString        m_strName;
      VARTYPE*       m_pArgTypes;
      VARTYPE        m_ReturnType;
      CStringArray   m_strArgNames;
      CString        m_strAttributes[ ma_Limit ];
};

class CProperty: public CObject
{
   public:
      CProperty   ( IADs*         );
      CProperty   (                 );
      ~CProperty  (                 );
		CProperty	( TCHAR* pszName, TCHAR* pszSyntax, BOOL bMultiValued = FALSE );

   //methods
      CString     VarToDisplayString( VARIANT&, BOOL bUseEx );
      BOOL        DisplayStringToDispParams( CString&, DISPPARAMS&, BOOL bEx );
      BOOL        SetMandatory         ( BOOL      );
      BOOL        GetMandatory         (           );
      CString     GetAttribute         ( PROPATTR  );
      HRESULT     PutAttribute         ( PROPATTR, CString& );
      BOOL        SetSyntaxID          ( DWORD );
      DWORD       GetSyntaxID          ( );
      
      HRESULT     Native2Value         ( ADS_ATTR_INFO*, CString& );
      HRESULT     Value2Native         ( ADS_ATTR_INFO*, CString& );
      void        FreeAttrInfo         ( ADS_ATTR_INFO* );

   protected:
	   void CreateSyntax( ADSTYPE );
      BOOL        m_bMandatory;
      BOOL        m_bMultiValued;
      DWORD       m_dwSyntaxID;
      CString     m_strAttributes[ pa_Limit ];
      BOOL        m_bDefaultSyntax;

      COleDsSyntax*    m_pSyntax;
};


/*class CFuncSet: public CObject
{
   public:
      CFuncSet ( CString&   );
      CFuncSet (                             );
      ~CFuncSet(                             );

   //methods
      BOOL           HasMandatoryProperties     (              );
      void           AddProperty                ( CProperty*   );
      int            GetPropertyCount           (               );
      
      CString        GetAttribute               ( int, PROPATTR );
      HRESULT        PutAttribute               ( int, PROPATTR, CString& );

      CString        GetAttribute               ( int, METHODATTR );
      HRESULT        PutAttribute               ( int, METHODATTR, CString& );
      
      CString        GetAttribute               ( FUNCSETATTR );
      HRESULT        PutAttribute               ( FUNCSETATTR, CString& );

      CString        VarToDisplayString         ( int, VARIANT&, BOOL bUseEx );
      BOOL           DisplayStringToDispParams  ( int, CString&, DISPPARAMS&, BOOL bUseEx  );
      int            LookupProperty					( CString& );
      CProperty*     GetProperty						( int        );   
      CMethod*       GetMethod                  ( int        );   
      HRESULT        LoadMethodsInformation     ( ITypeInfo* );

   protected:
      CProperty*     GetProperty( CString&   );

   
   protected:
      CString     m_strAttributes[ fa_Limit ];
      CObArray*   m_pProperties;
      CObArray*   m_pMethods;
};*/

class CClass: public CObject
{

   public:   
      CClass   ( CString&, CMainDoc* pMainDoc );
      CClass   (           );
      ~CClass  (           );   
		CClass	( TCHAR* pszClass, REFIID rPrimaryInterface );

   //methods
      BOOL           HasMandatoryProperties              ( void );
      void           AddProperty                         ( CProperty*   );
      //**************
      CString        GetAttribute                        ( CLASSATTR );
      HRESULT        PutAttribute                        ( CLASSATTR, CString& );

      //**************
      CString        GetAttribute                        ( int, METHODATTR );
      HRESULT        PutAttribute                        ( int, METHODATTR,  CString& );
                                                         
      //**************                                   
      CString        GetAttribute                        ( int, PROPATTR );
      HRESULT        PutAttribute                        ( int, PROPATTR, CString& );

      int            GetPropertyCount                    ( void );
      int            GetMethodsCount                     ( void );
      
      CMethod*       GetMethod                           ( int );
      CProperty*     GetProperty						         ( int        );   

      CString        VarToDisplayString                  ( int, VARIANT&, BOOL bUseEx );
      
      BOOL           DisplayStringToDispParams           ( int, CString&, DISPPARAMS&, BOOL bUseEx );
      BOOL           SupportContainer                    ( void ) 
                           { return m_bContainer; };
      HRESULT        LoadMethodsInformation  ( TCHAR* );
      HRESULT        LoadMethodsInformation  ( ITypeInfo* );
      int            LookupProperty				( CString& );
      REFIID         GetMethodsInterface     ( );
      

   protected:
      HRESULT        ReadMandatoryPropertiesInformation  ( VARIANT* );
      HRESULT        BuildOptionalPropertiesList         ( IADsClass* );
      HRESULT        BuildOptionalPropertiesList         ( IADsContainer* );
      HRESULT        BuildMandatoryPropertiesList        ( IADsClass* );
      HRESULT        AddProperties                       ( IADsClass*, VARIANT&, BOOL bMandatory );
      HRESULT        AddProperty                         ( BSTR,        BSTR,     BOOL bMandatory );
      CProperty*     GetProperty( CString&   );


   protected:
      BOOL           m_bContainer;
      CString        m_strAttributes[ ca_Limit ];
      CMainDoc*      m_pMainDoc;
      REFIID         m_refMethods;

   public:
      CObArray*   m_pProperties;
      CObArray*   m_pMethods;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Viewex.rc
//
#define IDR_COLORTYPE                   4
#define IDR_INPUTTYPE                   5
#define IDR_SPLIT2TYPE                  6
#define IDR_SPLIT3TYPE                  7
#define IDR_QUERYVIEW                   7
#define IDC_EDIT1                       100
#define IDC_QUERY                       101
#define IDC_ATTRIBUTES                  102
#define IDC_SCOPE                       103
#define IDD_SCHEMA                      104
#define IDD_FILTER                      105
#define IDD_QUERYSTATUS                 106
#define IDD_OLEDSPATH                   107
#define IDD_DEBUG                       109
#define IDD_CREATEITEM                  110
#define IDD_GROUPCREATEITEM             111
#define IDD_GROUPDELETEITEM             112
#define IDD_DELETEITEM                  113
#define IDD_COPYITEM                    114
#define IDD_MOVEITEM                    115
#define IDD_TYPEADDITEM                 116
#define IDD_TYPEDELETEITEM              117
#define IDD_ERRORPUTPROP                119
#define IDB_USER                        120
#define IDB_DOMAIN                      121
#define IDB_COMPUTER                    122
#define IDB_PRINTQUEUE                  123
#define IDB_DUMMY                       124
#define IDB_FILESHARE                   125
#define IDR_MAINFRAME                   128
#define IDB_GROUP                       128
#define IDR_TEXTTYPE                    129
#define IDB_SERVICE                     130
#define IDB_PRINTJOB                    132
#define IDB_SESSION                     133
#define IDB_RESOURCE                    134
#define IDD_SETPROPERTIES               135
#define IDB_ROOT                        137
#define IDB_ORGANISATION                138
#define IDB_ORGANISATIONUNIT            139
#define IDB_NAMESPACES                  140
#define IDB_NAMESPACE                   141
#define IDB_NDS_DIRECTORY_MAP           142
#define IDB_NDS_DISTRIBUTION_LIST       143
#define IDB_NDS_ALIAS                   144
#define IDB_NDS_AFP_SERVER              145
#define IDB_NDS_COMMUNICATIONS_SERVER   146
#define IDB_NDS_MESSAGE_ROUTING_GROUP   147
#define IDB_NDS_NETWARE_SERVER          148
#define IDB_NDS_ORGANIZATIONAL_ROLE     149
#define IDB_NDS_PRINT_QUEUE             150
#define IDB_NDS_PRINT_SERVER            151
#define IDB_NDS_PROFILE                 152
#define IDB_NDS_VOLUME                  153
#define IDB_CLASS                       155
#define IDB_PROPERTY                    156
#define IDB_SYNTAX                      157
#define IDD_CALLMETHOD                  158
#define IDD_COLLECTION                  159
#define IDI_ICON1                       161
#define IDD_QUERYVIEW                   162
#define IDD_NEWQUERY                    163
#define IDD_SEARCHPREFERENCES           165
#define IDD_ADDPROPERTY                 166
#define IDD_DIALOG1                     167
#define IDD_ADDACEDLG                   167
#define IDD_DELETESTATUS                168
#define IDC_RADIO1                      201
#define IDC_RADIO2                      202
#define IDC_RADIO3                      203
#define IDC_RADIO_DELET_VALUES          204
#define IDM_CHANGEDATA                  1001
#define IDC_GROUPBOX1                   1005
#define IDC_PROPERTIES                  1025
#define IDAPPLY                         1026
#define IDRELOAD                        1027
#define IDC_PROPLIST                    1030
#define IDC_PROPVALUE                   1031
#define IDC_CLASSTYPE                   1033
#define IDC_CLSID                       1034
#define IDC_PRIMARYINTERFACE            1035
#define IDC_DERIVEDFROM                 1036
#define IDC_CONTAINEMENT                1037
#define IDC_CONTAINER                   1038
#define IDC_HELPFILENAME                1039
#define IDC_HELPFILECONTEXT             1040
#define IDC_ITEMOLEDSPATH               1041
#define IDC_PROPERTYTYPE                1042
#define IDC_DISPLAYTHIS                 1043
#define IDC_DONOTDISPLAYTHIS            1044
#define IDC_TODISPLAY                   1045
#define IDC_TONOTDISPLAY                1046
#define IDS_USER                        1047
#define IDS_GROUP                       1048
#define IDS_PRINTQUEUE                  1049
#define IDS_SERVICE                     1050
#define IDS_FILESERVICE                 1051
#define IDC_FUNCSETCLSID                1051
#define IDS_COMPUTER                    1052
#define IDC_FUNCSETPRIMARYINTERFACE     1052
#define IDC_ITEMSTODISPLAY              1053
#define IDC_FUNCSETDERIVEDFROM          1053
#define IDS_OTHEROBJECTS                1054
#define IDC_PROPERTYMINRANGE            1056
#define IDC_PROPERTYMAXRANGE            1057
#define IDC_PROPERTYNORMAL              1058
#define IDC_PROPERTYOPTIONAL            1059
#define IDC_FUNCSETHELPFILENAME2        1060
#define IDC_OLEDSPATH                   1060
#define IDC_FUNCSETHELPFILECONTEXT      1061
#define IDC_PROMPTPUTPROPERTY           1061
#define IDC_PROMPTGETPROPERTY2          1062
#define IDC_RELATIVENAME                1062
#define IDC_CLASS                       1063
#define IDC_ITEMNAME                    1064
#define IDC_PARENTNAME                  1065
#define IDC_PARENT                      1066
#define IDC_SOURCE                      1067
#define IDC_DESTINATION                 1068
#define IDC_USER                        1068
#define IDC_ITEMTYPE                    1069
#define IDC_ERROROPERATION              1070
#define IDC_ERRORFUNCTIONALSET          1071
#define IDC_ERRORVALUE                  1072
#define IDC_ERRORRESULT                 1073
#define IDC_MULTIVALUED                 1075
#define IDC_PROPOID                     1076
#define IDC_PROPDSNAMES                 1077
#define IDC_CLASSOID                    1078
#define IDC_CLASSABSTRACT               1079
#define IDC_PROPERTYMANDATORY           1080
#define IDC_COLLECTONITEMSLIST          1082
#define IDC_ADD                         1083
#define IDC_REMOVE                      1084
#define IDC_REFRESH                     1085
#define IDC_METHOD                      1086
#define IDC_PARAM1                      1087
#define IDC_PARAM2                      1088
#define IDC_PARAM3                      1089
#define IDC_PARAM4                      1090
#define IDC_PARAM5                      1091
#define IDC_PARAM6                      1092
#define IDE_PARAM1                      1093
#define IDE_PARAM2                      1094
#define IDE_PARAM3                      1095
#define IDE_PARAM4                      1096
#define IDE_PARAM5                      1097
#define IDE_PARAM6                      1098
#define IDC_METHOD1                     2000
#define IDD_ABOUTBOX                    2000
#define IDC_METHOD2                     2001
#define IDD_INPUTFORM                   2001
#define IDC_METHOD3                     2002
#define IDD_CHANGEDATA                  2002
#define IDC_METHOD4                     2003
#define IDC_METHOD5                     2004
#define IDC_METHOD6                     2005
#define IDC_METHOD7                     2006
#define IDC_METHOD8                     2007
#define IDC_CLEAR                       2009
#define IDC_APPEND                      2010
#define IDC_CHANGE                      2011
#define IDC_PASSWORD                    2012
#define IDC_OPENAS                      2013
#define IDC_USEOPEN                     2015
#define IDC_SECUREAUTHENTICATION        2016
#define IDC_ENCRYPTION                  2017
#define IDC_ENCRYPT                     2018
#define IDC_COMBO1                      2019
#define IDC_NEWPROPERTYTYPE             2019
#define IDC_ACELIST                     2019
#define IDC_USESQL                      2025
#define IDC_USEEXTENDEDSYNTAX           2026
#define IDC_USESEARCH                   2027
#define IDC_ASYNCHRONOUS                2028
#define IDC_DEREF_ALIASES               2029
#define IDC_SIZE_LIMIT                  2030
#define IDC_TIME_LIMIT                  2031
#define IDC_ATTR_ONLY                   2032
#define IDC_TIME_OUT                    2034
#define IDC_PAGE_SIZE                   2035
#define IDC_NEWPROPERTYMULTIVALUED      2038
#define IDC_NEWPROPERTYNAME             2040
#define IDC_NEWPROPERTYVALUE            2041
#define IDC_ADDPROPERTY                 2042
#define IDC_GETPROPERTY                 2044
#define IDC_PUTPROPERTY                 2045
#define IDC_STATICCLASS                 2046
#define IDC_STATICCLSID                 2047
#define IDC_STATICPRIMARYINTERFACE      2048
#define IDC_STATICDERIVEDFROM           2049
#define IDC_GBSECURITYDESCRIPTORSTATIC  2050
#define IDC_GBACCESSCONTROLENTRIES      2051
#define IDC_SECURITYDESCRIPTORPROPERTIES 2053
#define IDC_SECURITYDESCRIPTORPROPERTYVALUE 2054
#define IDC_ACEPROPERTIESLIST           2055
#define IDC_ACEPROPERTYVALUE            2056
#define IDC_STATICCONTAINMENT           2057
#define IDC_STATICCONTAINER             2058
#define IDC_STATICHELPFILENAME          2059
#define IDC_STATICSTATICHELPFILECONTEXT 2060
#define IDC_STATICOID                   2061
#define IDC_STATICABSTRACT              2062
#define IDC_DACLSACL_LIST               2063
#define IDC_CHASE_REFERRALS             2064
#define IDC_COPYACE                     2066
#define IDC_PASTEACE                    2067
#define IDC_DELACE                      2068
#define IDC_ADDACE                      2069
#define IDC_TRUSTEE                     2070
#define IDC_COPYACL                     2071
#define IDC_PASTEACL                    2072
#define IDC_COPYSD                      2073
#define IDC_PASTESD                     2074
#define IDC_RADIO_CLEAR_VALUE           2075
#define IDC_RADIO_UPDATE_VALUE          2076
#define IDC_RADIO_ADD_VALUES            2077
#define IDC_DELETE                      2078
#define IDC_DELETERECURSIVE             2079
#define IDC_CURRENTDELETEOBJECT         2080
#define IDC_DELETESTATUS                2081
#define IDM_FILTER                      32769
#define IDM_DISABLEFILTER               32770
#define IDM_ADD                         32771
#define IDM_DELETE                      32772
#define IDM_MOVEITEM                    32773
#define IDM_COPYITEM                    32774
#define IDM_REFRESH                     32775
#define IDM_USEGENERIC                  32776
#define IDM_NEWQUERY                    32777
#define IDM_USEGETEXPUTEX               32778
#define IDM_USEPROPERTIESLIST           32779

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        169
#define _APS_NEXT_COMMAND_VALUE         32780
#define _APS_NEXT_CONTROL_VALUE         2082
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\service.h ===
#ifndef  _CSERVICE_H_
#define  _CSERVICE_H_

class COleDsService: public COleDsObject
{

public:   
   COleDsService( IUnknown* );
   COleDsService( );
   ~COleDsService( );

public:
   virtual  HRESULT  PutProperty( int, int, CString& );
   virtual  HRESULT  PutProperty( CString&, CString&, CString& );
   virtual  HRESULT  GetProperty( int, int, CString& );
   virtual  HRESULT  GetProperty( CString&, CString&, CString& );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\schclss.cpp ===
#include "stdafx.h"
#include "schclss.h"
#include "maindoc.h"
#include "resource.h"
#include "bwsview.h"
#include "ole2.h"
#include "csyntax.h"
#include "colldlg.h"
#include "prmsdlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CMethod::CMethod( )
{
   m_nArgs     = 0;
   m_pArgTypes = NULL;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CMethod::~CMethod( )
{
   if( m_pArgTypes != NULL )
      delete[] m_pArgTypes;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CMethod::GetName( )
{
   return m_strName;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CMethod::CMethod( ITypeInfo* pITypeInfo, FUNCDESC* pFuncDesc )
{
   HRESULT  hResult;
   BSTR     bstrNames[ 256 ];
   UINT     cNames;
   UINT     nIdx;
   TCHAR    szTemp[ 128 ];

   m_nArgs     = 0;
   m_pArgTypes = NULL;

   hResult  = pITypeInfo->GetNames( pFuncDesc->memid, bstrNames,
                                    256, &cNames );



   if( SUCCEEDED( hResult ) )
   {
      m_strName                  = bstrNames[ 0 ];
      m_strAttributes[ ma_Name ] = bstrNames[ 0 ];
      m_strAttributes[ ma_DisplayName ] = bstrNames[ 0 ];
      m_nArgs                    = pFuncDesc->cParams;
      m_nArgsOpt                 = pFuncDesc->cParamsOpt;
      m_ReturnType               = pFuncDesc->elemdescFunc.tdesc.vt;
      if( m_nArgs )
      {
         m_pArgTypes = new VARTYPE[ m_nArgs ];
         for( nIdx = 0; nIdx < (UINT)m_nArgs ; nIdx++ )
         {
            m_pArgTypes[ nIdx ]  =
               pFuncDesc->lprgelemdescParam[ nIdx ].tdesc.vt;
            _tcscpy( szTemp, _T("") );
            StringCat( szTemp, bstrNames[ nIdx + 1] );
            m_strArgNames.Add( szTemp );
         }
      }
      for( nIdx = 0; nIdx < cNames ; nIdx++ )
      {
         SysFreeString( bstrNames[ nIdx ] );
      }

   }
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   CMethod::GetArgCount( )
{
   return m_nArgs;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   CMethod::GetArgOptionalCount( )
{
   return m_nArgsOpt;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
VARTYPE  CMethod::GetMethodReturnType( )
{
   return m_ReturnType;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CMethod::ConvertArgument( int nArg, CString strArg, VARIANT* )
{
   return FALSE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CMethod::GetAttribute( METHODATTR methAttr )
{
   switch( methAttr )
   {
      case  ma_Name:
      case  ma_DisplayName:
         return m_strAttributes[ methAttr ];

      default:
         ASSERT( FALSE );
         return CString( _T("???") );
   }

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CMethod::PutAttribute( METHODATTR methAttr, CString& rValue )
{
   return E_FAIL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CMethod::CallMethod( IDispatch* pIDispatch, BOOL* pbDisplayMessage )
{
   CStringArray      aParamValues;
   int               nIdx;
   DISPPARAMS        dispparamsArgs    = {NULL, NULL, 0, 0};
   DISPPARAMS        dispparamsNoArgs  = {NULL, NULL, 0, 0};
   DISPID            dispid;
   OLECHAR FAR*      szName;
   BSTR              bstrName;
   VARIANT           var;
   EXCEPINFO         aExcepInfo;
   UINT              uErr;
   HRESULT           hResult, hResultX;
   IADsCollection* pICollection;
   IADsMembers*    pIMembers;
   IDispatch*        pIResult;

   if( m_nArgs )
   {
      CParamsDialog  aParamsDialog;

      aParamsDialog.SetMethodName( m_strName );
      aParamsDialog.SetArgNames( &m_strArgNames );
      aParamsDialog.SetArgValues( &aParamValues );
      if( aParamsDialog.DoModal( ) != IDOK )
         return E_FAIL;

      dispparamsArgs.rgvarg   = new VARIANT[ m_nArgs ];

      for( nIdx = 0; nIdx < m_nArgs ; nIdx++ )
      {
         VARIANT  varString;

         VariantInit( &dispparamsArgs.rgvarg[ m_nArgs - nIdx - 1] );
         VariantInit( &varString );
         V_VT( &varString )   = VT_BSTR;
         V_BSTR( &varString ) = AllocBSTR( aParamValues[ nIdx ].GetBuffer( 128 ) );
         if( VT_VARIANT != m_pArgTypes[ nIdx ] )
         {
            hResult  = VariantChangeType( &dispparamsArgs.rgvarg[ m_nArgs - nIdx - 1],
                                          &varString,
                                          VARIANT_NOVALUEPROP,
                                          m_pArgTypes[ nIdx ] );
         }
         else
         {
            BuildVariantArray( VT_BSTR, aParamValues[ nIdx ], dispparamsArgs.rgvarg[ m_nArgs - nIdx - 1] );
         }
         VariantClear( &varString );
      }
   }

   bstrName    = AllocBSTR( m_strName.GetBuffer( 128 ) );
   szName      = (OLECHAR FAR*) bstrName;
   hResult     = pIDispatch->GetIDsOfNames( IID_NULL, &szName, 1,
                                            LOCALE_SYSTEM_DEFAULT, &dispid ) ;
   SysFreeString( bstrName );

   ASSERT( SUCCEEDED( hResult ) );
   while( TRUE )
   {
      HCURSOR  aCursor, oldCursor;

      if( FAILED( hResult ) )
         break;

      memset( &aExcepInfo, 0, sizeof( aExcepInfo) );
      dispparamsArgs.cArgs       = m_nArgs;
      dispparamsArgs.cNamedArgs  = 0;

      aCursor     = LoadCursor( NULL, IDC_WAIT );
      oldCursor   = SetCursor( aCursor );
      hResult     = pIDispatch->Invoke( dispid,
                                        IID_NULL,
                                        LOCALE_SYSTEM_DEFAULT,
                                          DISPATCH_METHOD,
                                        &dispparamsArgs,
                                        &var,
                                        &aExcepInfo,
                                        &uErr );
      SetCursor( oldCursor );

      if( DISP_E_EXCEPTION == hResult )
      {
         hResult  = aExcepInfo.scode;
      }

      if( FAILED( hResult ) )
      {
         break;
      }

      if( VT_VOID == m_ReturnType )
         break;

      // now, we have a return value we must work on.

      switch( m_ReturnType )
      {
         case  VT_DISPATCH:
         case  VT_PTR:
            pIResult = V_DISPATCH( &var );
            pIResult->AddRef( );

            hResultX = pIResult->QueryInterface( IID_IADsCollection,
                                                 (void**)&pICollection );
            if( SUCCEEDED( hResultX ) )
            {
               CCollectionDialog aCollectionDialog;

               aCollectionDialog.SetCollectionInterface( pICollection );
               aCollectionDialog.DoModal( );

               pICollection->Release( );
               *pbDisplayMessage = FALSE;
            }
            else
            {
               hResult  = pIResult->QueryInterface( IID_IADsMembers,
                                                    (void**)&pIMembers );
               if( SUCCEEDED( hResult ) )
               {
                  CCollectionDialog aCollectionDialog;
                  IADsGroup*  pGroup;
                  //SMITHA HRESULT     hResult;

                  hResult  = pIDispatch->QueryInterface( IID_IADsGroup,
                                                         (void**)&pGroup );
                  if( SUCCEEDED( hResult ) )
                  {
                     aCollectionDialog.SetGroup( pGroup );
                  }
                  else
                  {
                     aCollectionDialog.SetMembersInterface( pIMembers );
                  }
                  aCollectionDialog.DoModal( );

                  if( SUCCEEDED( hResult ) )
                     pGroup->Release( );

                  pIMembers->Release( );
                  *pbDisplayMessage = FALSE;
               }
            }
            pIResult->Release( );
            break;

         case  VT_BOOL:
            AfxGetMainWnd()->MessageBox(  VARIANT_FALSE == V_BOOL( &var ) ?
                                          _T("Result: FALSE") :
                                          _T("Result: TRUE"),
                                          m_strName,
                                          MB_ICONINFORMATION );
            *pbDisplayMessage = FALSE;

            break;

         default:
            ASSERT( FALSE );
      }

      VariantClear( &var );
      break;
   }

   if( dispparamsArgs.rgvarg )
   {
      for( nIdx = 0; nIdx < m_nArgs ; nIdx++ )
      {
         if( V_VT( &dispparamsArgs.rgvarg[ nIdx ] ) != VT_EMPTY )
         {
            VariantClear( &dispparamsArgs.rgvarg[ nIdx ] );
         }
      }

      delete [] dispparamsArgs.rgvarg;
   }

   return hResult;
}




/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CProperty::CProperty( )
{
   m_bMandatory   = FALSE;
   m_dwSyntaxID   = 0L;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CProperty::CProperty    ( TCHAR* pszName, TCHAR* szSyntax, BOOL bMultiValued )
{
   HRESULT  hResult  = S_OK;
   BSTR     pszSyntax;

   for( int nIdx = 0; nIdx < pa_Limit ; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("NA");
   }

   m_bMandatory   = FALSE;
   m_bDefaultSyntax  = TRUE;
   m_bMultiValued = bMultiValued;
   m_dwSyntaxID   = 0L;

   m_strAttributes[ pa_Name ]          = pszName;
   m_strAttributes[ pa_DisplayName ]   = pszName;

   pszSyntax   = AllocBSTR( szSyntax );

   m_pSyntax   = GetSyntaxHandler( pszSyntax );

   /*if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"String" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Counter" ) )
   {
      m_pSyntax   = new COleDsLONG;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"OleDsPath" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"EmailAddress" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"FaxNumber" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Integer" ) )
   {
      m_pSyntax   = new COleDsLONG;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Interval" ) )
   {
      m_pSyntax   = new COleDsLONG;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"List" ) )
   {
      m_pSyntax   = new COleDsVARIANT;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"NetAddress" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"OctetString" ) )
   {
      m_pSyntax   = new COleDsVARIANT;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Path" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"PhoneNumber" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"PostalAddress" ) )
   {
      m_pSyntax   = new COleDsString;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"SmallInterval" ) )
   {
      m_pSyntax   = new COleDsLONG;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Time" ) )
   {
      m_pSyntax   = new COleDsDATE;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"boolean" ) )
   {
      m_pSyntax   = new COleDsBOOL;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"TimeStamp" ) )
   {
      m_pSyntax   = new COleDsNDSTimeStamp;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"UTCTime" ) )
   {
      //m_pSyntax   = new COleDsString;
       m_pSyntax   = new COleDsDATE;
   }

   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"GeneralizedTime" ) )
   {
      //m_pSyntax   = new COleDsString;
       m_pSyntax   = new COleDsDATE;
   }
   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Integer8" ) )
   {
      m_pSyntax   = new COleDsLargeInteger;
   }

   else if( SUCCEEDED( hResult ) && !_wcsicmp( pszSyntax, L"Postal Address" ) )
   {
      m_pSyntax   = new COleDsNDSPostalAddress;
   }

   else
   {
      ASSERT( FALSE );
      m_pSyntax   = new COleDsString;
   }*/

   m_strAttributes[ pa_Type ] = szSyntax;

   m_strAttributes[ pa_MultiValued ] = bMultiValued ? _T("Yes") : _T("No");

   SysFreeString( pszSyntax );
}


/***********************************************************
  Function:    CProperty::CreateSyntax
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void CProperty::CreateSyntax( ADSTYPE eType )
{
   COleDsSyntax*  pNewSyntax  = NULL;
   CString        strText;

   if( !m_bDefaultSyntax )
      return;

   pNewSyntax  = GetSyntaxHandler( eType, strText );

   if( NULL != pNewSyntax )
   {
      delete m_pSyntax;

      m_pSyntax         = pNewSyntax;
      m_bDefaultSyntax  = FALSE;
   }

}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CProperty::CProperty( IADs* pIOleDs )
{
   HRESULT        hResult;
   BSTR           bstrText;
   CString        strTemp;
   TCHAR          szText[ 128 ];
   long           lTemp;
   VARIANT        aVar, vGet;
   VARIANT_BOOL   aBool;
   IADsProperty* pIProp  = NULL;

   m_bMandatory   = FALSE;
   m_bMultiValued = FALSE;
   m_bDefaultSyntax  = TRUE;
   m_dwSyntaxID   = 0L;
   //**************
   hResult                             = pIOleDs->get_Name( &bstrText );
   m_strAttributes[ pa_Name ]          = bstrText;
   m_strAttributes[ pa_DisplayName ]   = bstrText;
   SysFreeString( bstrText );

   //**************

   m_strAttributes[ pa_Mandatory ]     = _T("No");

   //**************

   hResult  = pIOleDs->QueryInterface( IID_IADsProperty, (void**) &pIProp );

   if( pIProp )
   {

      VariantInit( &vGet );
      hResult  = Get( pIOleDs, L"Syntax", &vGet );
      bstrText = V_BSTR( &vGet );
      if( FAILED( hResult ) )
      {
         hResult  = pIProp->get_Syntax( &bstrText );
         if( FAILED( hResult ) )
         {
            bstrText = AllocBSTR( _T("Unknown") );
         }
      }
      m_strAttributes[ pa_Type ] = bstrText;

      m_pSyntax   = GetSyntaxHandler( bstrText );

      SysFreeString( bstrText );

      //**************

      /*
      hResult  = Get( pIOleDs, _T("MaxRange"), &vGet );
      lTemp    = V_I4( &vGet );
      if( FAILED( hResult ) )
      {
         hResult  = pIProp->get_MaxRange( &lTemp );
      }

      if( SUCCEEDED( hResult ) )
      {
         _ltot( lTemp, szText, 10 );
         m_strAttributes[ pa_MaxRange ] = szText;
      }
      else
      {
         m_strAttributes[ pa_MaxRange ] = _T("NA");
      }

      //**************
      hResult  = Get( pIOleDs, _T("MinRange"), &vGet );
      lTemp    = V_I4( &vGet );
      if( FAILED( hResult ) )
      {
         hResult     = pIProp->get_MinRange( &lTemp );
      }
      if( SUCCEEDED( hResult ) )
      {
         _ltot( lTemp, szText, 10 );
         m_strAttributes[ pa_MinRange ] = szText;
      }
      else
      {
         m_strAttributes[ pa_MinRange ] = _T("NA");
      }
      */

      //**************
      V_BOOL( &vGet )   = FALSE;
      hResult           = Get( pIOleDs, _T("MultiValued"), &vGet );
      aBool             = V_BOOL( &vGet );
      if( FAILED( hResult ) )
      {
         hResult     = pIProp->get_MultiValued( &aBool );
      }
      m_bMultiValued = aBool;
      if( SUCCEEDED( hResult ) )
      {
         m_strAttributes[ pa_MultiValued ] = aBool ? _T("Yes") : _T("No");
      }
      else
      {
         m_strAttributes[ pa_MultiValued ] = _T("NA");
      }

      //**************
      hResult  = Get( pIOleDs, _T("OID"), &vGet );
      bstrText = V_BSTR( &vGet );
      if( FAILED( hResult ) )
      {
         hResult  = pIProp->get_OID( &bstrText );
      }
      if( bstrText && SUCCEEDED( hResult ) )
      {
         m_strAttributes[ pa_OID ]  = bstrText;
         SysFreeString( bstrText );
      }
      else
      {
         m_strAttributes[ pa_OID ]  = _T("NA");
      }

      //**************
      hResult  = Get( pIOleDs, _T("DsNames"), &aVar );
      if( FAILED( hResult ) )
      {
         //hResult  = pIProp->get_DsNames( &aVar );
      }
      if( SUCCEEDED( hResult ) )
      {
         m_strAttributes[ pa_DsNames ] = FromVariantToString( aVar );
         VariantClear( &aVar );
      }
      else
      {
         m_strAttributes[ pa_DsNames ] = _T("NA");
      }
      pIProp->Release( );
   }
   else
   {
       m_pSyntax   = new COleDsString;
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CProperty::~CProperty( )
{
   delete   m_pSyntax;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CProperty::GetAttribute( PROPATTR propAttr )
{
   switch( propAttr )
   {
      case  pa_Name:
      case  pa_DisplayName:
      case  pa_Type:
      case  pa_DsNames:
      case  pa_OID:
      case  pa_MaxRange:
      case  pa_MinRange:
      case  pa_Mandatory:
      case  pa_MultiValued:
         return m_strAttributes[ propAttr ];

      default:
         ASSERT( FALSE );
         return CString( _T("???") );
   }
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CProperty::PutAttribute( PROPATTR propAttr, CString& )
{
   return E_FAIL;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CProperty::SetMandatory( BOOL bMandatory )
{
   m_bMandatory   = bMandatory;

   m_strAttributes[ pa_Mandatory ]  = bMandatory ? _T("Yes") : _T("No");

   return TRUE;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CProperty::GetMandatory( )
{
   return m_bMandatory;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString CProperty::VarToDisplayString( VARIANT& var, BOOL bUseEx )
{
   return m_pSyntax->VarToDisplayString( var, m_bMultiValued, bUseEx );
}

/***********************************************************
  Function:    CProperty::Value2Native
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT CProperty::Value2Native( ADS_ATTR_INFO* pAttr, CString& rVal )
{
   HRESULT  hResult;
   ADSTYPE  eADsType;

   hResult  = m_pSyntax->Value2Native( pAttr, rVal );

   eADsType = (ADSTYPE)(m_pSyntax->m_dwSyntaxID);

   if( ADSTYPE_INVALID != eADsType )
   {
      pAttr->dwADsType  = eADsType;

      if( SUCCEEDED( hResult ) )
      {
         for( DWORD idx = 0; idx < pAttr->dwNumValues ; idx++ )
         {
            pAttr->pADsValues[ idx ].dwType  = eADsType;
         }
      }
   }

   return hResult;
}


/***********************************************************
  Function:    CProperty::Value2Native
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CProperty::FreeAttrInfo( ADS_ATTR_INFO* pAttrInfo )
{
   m_pSyntax->FreeAttrInfo( pAttrInfo );
}


/***********************************************************
  Function:    CProperty::Native2Value
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT CProperty::Native2Value( ADS_ATTR_INFO* pAttr, CString& rVal )
{
   if( pAttr->dwNumValues )
   {
      SetSyntaxID( pAttr->dwADsType );
      if( pAttr->pADsValues[ 0 ].dwType != pAttr->dwADsType )
      {
         TRACE( _T("ERROR: Property type differs from value type\n") );
      }
   }
   //if( ADSTYPE_INVALID != pAttr->dwADsType )
   //{
   CreateSyntax( (ADSTYPE) pAttr->dwADsType );

   return m_pSyntax->Native2Value( pAttr, rVal );
   //}
   //else
   //{
   //   rVal  = _T("ERROR: ADSTYPE_INVALID") ;
   //   return S_OK;
   //}
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CProperty::DisplayStringToDispParams( CString& rText, DISPPARAMS& dispParams, BOOL bUseEx )
{
   return m_pSyntax->DisplayStringToDispParams( rText, dispParams, m_bMultiValued, bUseEx );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CProperty::SetSyntaxID( DWORD dwSyntaxID )
{
   if( m_dwSyntaxID )
   {
      ASSERT( dwSyntaxID == m_dwSyntaxID );
   }
   m_dwSyntaxID   = dwSyntaxID;

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD CProperty::GetSyntaxID( )
{
   ASSERT( m_dwSyntaxID );

   return m_dwSyntaxID;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
/*CFuncSet::CFuncSet( )
{
   m_pProperties  = new CObArray;
   m_pMethods     = new CObArray;

   for( int nIdx = fa_ERROR; nIdx < fa_Limit ; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("???");
   }

   m_strAttributes[ fa_MethodsCount ] = _T("0");
} */


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
/*CFuncSet::CFuncSet( CString& strName )
{
   m_pProperties     = new CObArray;
   m_pMethods        = new CObArray;

   for( int nIdx = fa_ERROR; nIdx < fa_Limit ; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("???");
   }

   m_strAttributes[ fa_MethodsCount ] = _T("0");

   m_strAttributes[ fa_Name ]          = strName;
   m_strAttributes[ fa_DisplayName ]   = strName;
}*/



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  CClass::AddProperty( CProperty* pProperty )
{
   m_pProperties->Add( pProperty );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
/*CFuncSet::~CFuncSet( )
{
   int nSize, nIdx;

   nSize = m_pProperties->GetSize( );

   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      delete m_pProperties->GetAt( nIdx );
   }

   m_pProperties->RemoveAll( );
   delete m_pProperties;

   // ****
   nSize = m_pMethods->GetSize( );

   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      delete m_pMethods->GetAt( nIdx );
   }

   m_pMethods->RemoveAll( );
   delete m_pMethods;
}*/


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   CClass::GetPropertyCount( )
{
   return (int)m_pProperties->GetSize( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CClass::GetAttribute( int nProp, PROPATTR propAttr )
{
   CProperty*  pProperty;

   pProperty   = GetProperty( nProp );

   return pProperty->GetAttribute( propAttr );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::PutAttribute( int nProp, PROPATTR propAttr, CString& rValue )
{
   CProperty*  pProperty;

   pProperty   = GetProperty( nProp );

   return pProperty->PutAttribute( propAttr, rValue );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CClass::GetAttribute( int nMethod, METHODATTR methAttr )
{
   CMethod*  pMethod;

   pMethod   = GetMethod( nMethod );

   return pMethod->GetAttribute( methAttr );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::PutAttribute( int nMethod, METHODATTR methAttr, CString& rValue )
{
   CMethod*  pMethod;

   pMethod   = GetMethod( nMethod );

   return pMethod->PutAttribute( methAttr, rValue );
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CClass::VarToDisplayString( int nPropIndex, VARIANT& var, BOOL bUseEx )
{
   return GetProperty( nPropIndex )->VarToDisplayString( var, bUseEx );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CClass::DisplayStringToDispParams( int nPropIndex, CString& strText, DISPPARAMS& var, BOOL bUseEx )
{
   return GetProperty( nPropIndex )->DisplayStringToDispParams( strText, var, bUseEx );
}


/***********************************************************
  Function: CClass::GetFunctionalSet
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   CClass::LookupProperty( CString&  strProperty )
{
   int         nMax, nIter;
   CProperty*  pProperty;
   BOOL        bFound   = FALSE;

   nMax  = (int)m_pProperties->GetSize( );

   for( nIter = 0; nIter < nMax && !bFound ; nIter++ )
   {
      pProperty   = (CProperty*) ( m_pProperties->GetAt( nIter ) );
      bFound        = bFound || ( strProperty == pProperty->GetAttribute( pa_Name ) );
      if( bFound )
         break;
   }

   return ( bFound ? nIter : -1 );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CProperty*  CClass::GetProperty( int nIndex )
{
   int         nMax;
   CProperty*  pProp;

   nMax  = (int)m_pProperties->GetSize( );

   ASSERT( nIndex >= 0 && nIndex < nMax );

   pProp = (CProperty*) ( m_pProperties->GetAt( nIndex  ) );

   return pProp;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CMethod*  CClass::GetMethod( int nIndex )
{
   int         nMax;
   CMethod*  pProp;

   nMax  = (int)m_pMethods->GetSize( );

   ASSERT( nIndex >= 0 && nIndex < nMax );

   pProp = (CMethod*) ( m_pMethods->GetAt( nIndex  ) );

   return pProp;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
REFIID   CClass::GetMethodsInterface( )
{
   return m_refMethods;
}

/***********************************************************
  Function:    CClass::HasMandatoryProperties
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL     CClass::HasMandatoryProperties( )
{
   BOOL  bHas  = FALSE;
   int   nIter, nSize;

   nSize = (int)m_pProperties->GetSize( );

   for( nIter = 0; nIter < nSize && !bHas ; nIter++ )
   {
      bHas |= GetProperty( nIter )->GetMandatory( );
   }

   return bHas;
}


/***********************************************************
  Function:    CFuncSet::LoadMethodsInformation
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::LoadMethodsInformation( ITypeInfo* pITypeInfo )
{
   HRESULT     hResult= S_OK;
   int         nIdx;
   CString     strMethodName;
   FUNCDESC*   pFuncDesc;
   CMethod*    pMethod;
   TCHAR       szCount[ 16 ];

   while( TRUE )
   {
      for( nIdx = 0; nIdx < 200 ; nIdx++ )
      {
         hResult  = pITypeInfo->GetFuncDesc( nIdx, &pFuncDesc );
         // now, we have function description, we must search for function type
         if( FAILED( hResult ) )
            continue;

         if( INVOKE_FUNC != pFuncDesc->invkind || pFuncDesc->memid > 1000 )
         {
            pITypeInfo->ReleaseFuncDesc( pFuncDesc );
            continue;
         }

         pMethod  = new CMethod( pITypeInfo, pFuncDesc );

         pITypeInfo->ReleaseFuncDesc( pFuncDesc );

         strMethodName  = pMethod->GetAttribute( ma_Name );
         if( !strMethodName.CompareNoCase( _T("Get") ) )
         {
            delete pMethod;
            continue;
         }

         if( !strMethodName.CompareNoCase( _T("GetEx") ) )
         {
            delete pMethod;
            continue;
         }

         if( !strMethodName.CompareNoCase( _T("Put") ) )
         {
            delete pMethod;
            continue;
         }

         if( !strMethodName.CompareNoCase( _T("PutEx") ) )
         {
            delete pMethod;
            continue;
         }

         if( !strMethodName.CompareNoCase( _T("GetInfo") ) )
         {
            delete pMethod;
            continue;
         }

         if( !strMethodName.CompareNoCase( _T("SetInfo") ) )
         {
            delete pMethod;
            continue;
         }

         m_pMethods->Add( pMethod );
      }

      break;
   }

   _itot( (int)m_pMethods->GetSize( ), szCount, 10 );

   m_strAttributes [ ca_MethodsCount ] = szCount;

   return hResult;
}

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  GetFuncSetName( VARIANT& v, CString& strFuncSet, int nIdx )
{
   SAFEARRAY*  pSafeArray;
   TCHAR       szText[ 256 ];
   VARIANT     varString;
   long        lBound, uBound, lItem;
   HRESULT     hResult;
   BOOL        bFirst;
   BSTR        bstrVal;
   CString     strTemp;


   strFuncSet.Empty( );

   ASSERT( V_VT( &v ) & VT_ARRAY );

   pSafeArray   = V_ARRAY( &v );

   hResult = SafeArrayGetLBound(pSafeArray, 1, &lBound);
   hResult = SafeArrayGetUBound(pSafeArray, 1, &uBound);

   VariantInit( &varString );
   szText[ 0 ]    = _T('\0');
   bFirst         = TRUE;

   lItem    = lBound + nIdx;
   hResult  = SafeArrayGetElement( pSafeArray, &lItem, &bstrVal );
   if( FAILED( hResult ) )
   {
      return FALSE;
   }

   strTemp  = bstrVal;
   SysFreeString( bstrVal );
   if( -1 != strTemp.Find( _T('.') ) )
   {
      strFuncSet  = strTemp.SpanExcluding( _T(".") );
   }

   strFuncSet.TrimLeft( );

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CClass::CClass  ( TCHAR* pszClass, REFIID rPrimaryInterface )
:m_refMethods( IID_IADs )
{
   LPOLESTR pOleStr;
   HRESULT  hResult;

   m_pProperties     = new CObArray;
   m_pMethods        = new CObArray;

   for( int nIdx = ca_ERROR; nIdx < ca_Limit; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("NA");
   }

   m_strAttributes[ ca_Name ] = pszClass;

   hResult  = StringFromIID( rPrimaryInterface, &pOleStr );

   if( SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_PrimaryInterface ] = pOleStr;
      //SysFreeString( pOleStr );
      CoTaskMemFree( pOleStr );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CClass::CClass( CString& strSchema, CMainDoc* pMainDoc )
:m_refMethods( IID_IADs )
{
   HRESULT           hResult;
   IADsClass*      pIOleDsClass   = NULL;
   IADs*           pIOleDsCls     = NULL;
   IADsContainer*  pContainer     = NULL;
   IUnknown*         pEnum          = NULL;
   IEnumVARIANT*     pIEnumVar      = NULL;
   BSTR              bstrText= NULL;
   VARIANT           aVar;
   CString           strAliased;
   IADsProperty*   pIProperty     = NULL;
   IADs*           pIOleDs        = NULL;
   VARIANT_BOOL      varBOOL;
   CString           strFuncSet;
   CString           strProperty;
   CString           strTemp;
   long              lTemp;
   VARIANT           vGet;

   m_pMainDoc        = pMainDoc;
   m_pProperties     = new CObArray;
   m_pMethods        = new CObArray;

   for( int nIdx = ca_ERROR; nIdx < ca_Limit; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("???");
   }


   {
      TCHAR szPath [ 512 ];

      hResult        = m_pMainDoc->XOleDsGetObject( strSchema.GetBuffer( 128 ),
                                                    IID_IADsClass,
                                                    (void**) &pIOleDsClass );
      if( FAILED( hResult ) )
      {
         _tcscpy( szPath, strSchema.GetBuffer( 256 ) );
         _tcscat( szPath, _T(",Class") );
         hResult  = m_pMainDoc->XOleDsGetObject( szPath, IID_IADsClass, (void**) &pIOleDsClass );
      }
   }

   if( FAILED( hResult ) )
   {
      TRACE( _T("Could not open schema object\n") );
      return;
   }

   hResult  = pIOleDsClass->QueryInterface( IID_IADs, (void**) &pIOleDsCls );

   //*******************
   hResult                    = pIOleDsClass->get_Name( &bstrText );
   ASSERT( SUCCEEDED( hResult ) );
   m_strAttributes[ ca_Name ] = bstrText;
   SysFreeString( bstrText );
   bstrText       = NULL;

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("CLSID"), &vGet );
   bstrText = V_BSTR( &vGet );
   if( FAILED(  hResult ) )
   {
      hResult  = pIOleDsClass->get_CLSID( &bstrText );
   }
   if( bstrText && SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_CLSID ]   = bstrText;
      SysFreeString( bstrText );
   }
   else
   {
      m_strAttributes[ ca_CLSID ]   = _T("NA");
   }

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("PrimaryInterface"), &vGet );
   bstrText = V_BSTR( &vGet );
   if( FAILED( hResult ) )
   {
      hResult  = pIOleDsClass->get_PrimaryInterface( &bstrText );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( bstrText && SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_PrimaryInterface ]   = bstrText;
      SysFreeString( bstrText );
   }
   else
   {
      m_strAttributes[ ca_PrimaryInterface ]   = _T("NA");
   }

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("HelpFileName"), &vGet );
   bstrText = V_BSTR( &vGet );
   if( FAILED( hResult ) )
   {
      hResult        = pIOleDsClass->get_HelpFileName( &bstrText );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( bstrText && SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_HelpFileName ]   = bstrText;
      SysFreeString( bstrText );
   }
   else
   {
      m_strAttributes[ ca_HelpFileName ]   = _T("NA");
   }

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("HelpFileContext"), &vGet );
   lTemp    = V_I4( &vGet );
   if( FAILED( hResult ) )
   {
      hResult        = pIOleDsClass->get_HelpFileContext( &lTemp );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( SUCCEEDED( hResult ) )
   {
      TCHAR szText[ 128 ];

      _ltot( lTemp, szText, 10 );
      m_strAttributes[ ca_HelpFileContext ]   = szText;
   }
   else
   {
      m_strAttributes[ ca_HelpFileContext ]   = _T("NA");
   }

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("OID"), &vGet );
   bstrText = V_BSTR( &vGet );
   if( FAILED( hResult ) )
   {
      hResult        = pIOleDsClass->get_OID( &bstrText );
   }
   //ASSERT( bstrText && SUCCEEDED( hResult ) );
   if( bstrText && SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_OID ]   = bstrText;
      SysFreeString( bstrText );
   }
   else
   {
      m_strAttributes[ ca_OID ]   = _T("NA");
   }


   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("Container"), &vGet );
   varBOOL  = V_BOOL( &vGet );
   if( FAILED( hResult ) )
   {
      hResult  = pIOleDsClass->get_Container( (VARIANT_BOOL*)&varBOOL );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( SUCCEEDED( hResult ) )
   {
      m_bContainer   = (BOOL)varBOOL;
      m_strAttributes[ ca_Container ]  = m_bContainer ? _T("YES") :_T("No");
   }
   else
   {
      m_strAttributes[ ca_Container ]  = _T("NA");
   }

   //*******************
   VariantInit( &vGet );
   V_BSTR( &vGet )   = NULL;
   hResult  = Get( pIOleDsCls, _T("Abstract"), &vGet );
   varBOOL  = V_BOOL( &vGet );
   if( FAILED( hResult ) )
   {
      hResult        = pIOleDsClass->get_Abstract( (VARIANT_BOOL*)&varBOOL );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_Abstract ]  = varBOOL ? _T("YES") :_T("No");
   }
   else
   {
      m_strAttributes[ ca_Abstract ]  = _T("NA");
   }


   //*******************
   hResult  = Get( pIOleDsCls, _T("DerivedFrom"), &aVar );
   if( FAILED( hResult ) )
   {
      hResult  = pIOleDsClass->get_DerivedFrom( &aVar );
   }
   if( SUCCEEDED( hResult ) )
   {
      m_strAttributes[ ca_DerivedFrom ]   = FromVariantToString( aVar );
      VariantClear( &aVar );
   }
   else
   {
      m_strAttributes[ ca_DerivedFrom ]   = _T("NA");
   }

   //*******************
   hResult  = Get( pIOleDsCls, _T("Containment"), &aVar );
   if( FAILED( hResult ) )
   {
      hResult           = pIOleDsClass->get_Containment( &aVar );
   }
   //ASSERT( SUCCEEDED( hResult ) );
   if( SUCCEEDED( hResult ) )
   {
      //m_strAttributes[ ca_Containment ]   = FromVariantToString( aVar );
      m_strAttributes[ ca_Containment ]   = FromVariantArrayToString( aVar );
      VariantClear( &aVar );
   }
   else
   {
      m_strAttributes[ ca_Containment ]   = _T("NA");
   }

   //strFuncSet.Empty( );
   //pFuncSet = new CFuncSet( strFuncSet );
   //m_pFuncSets->Add( pFuncSet );

   BuildMandatoryPropertiesList( pIOleDsClass );

   //********************
   BuildOptionalPropertiesList( pIOleDsClass );

   pIOleDsClass->Release( );
   pIOleDsCls->Release( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::BuildOptionalPropertiesList( IADsClass* pIClass )
{
   HRESULT  hResult;
   VARIANT  aOptionalProperty;

   hResult  = Get( pIClass, _T("OptionalProperties"), &aOptionalProperty );
   if( FAILED( hResult ) )
   {
      hResult  = pIClass->get_OptionalProperties( &aOptionalProperty );
   }
   if( SUCCEEDED( hResult ) )
   {
      AddProperties( pIClass, aOptionalProperty, FALSE );
      VariantClear( &aOptionalProperty );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::AddProperties( IADsClass* pIClass, VARIANT& rVar, BOOL bMandatory )
{
   HRESULT  hResult;
   IADs*  pIOleDs  = NULL;
   BSTR     bstrParent;

   while( TRUE )
   {
      hResult  = pIClass->QueryInterface( IID_IADs, (void**)&pIOleDs );
      if( FAILED( hResult ) )
         break;

      hResult  = pIClass->get_Parent( &bstrParent );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      if( VT_BSTR == V_VT( &rVar ) )
      {
         AddProperty( bstrParent, V_BSTR( &rVar ), bMandatory );
      }
      else
      {
         SAFEARRAY*  pSafeArray;
         VARIANT     varString;
         long        lBound, uBound, lItem;
         //SMITHA HRESULT     hResult;

         ASSERT( V_VT( &rVar ) & (VT_VARIANT | VT_ARRAY) );

         pSafeArray   = V_ARRAY( &rVar );

         hResult = SafeArrayGetLBound(pSafeArray, 1, &lBound);
         hResult = SafeArrayGetUBound(pSafeArray, 1, &uBound);

         VariantInit( &varString );
         for( lItem = lBound; lItem <= uBound ; lItem++ )
         {
            hResult  = SafeArrayGetElement( pSafeArray, &lItem, &varString );
            ASSERT( VT_BSTR == V_VT( &varString ) );

            if( FAILED( hResult ) )
            {
               break;
            }
            AddProperty( bstrParent, V_BSTR( &varString ), bMandatory );
            VariantClear( &varString );
         }
      }
      SysFreeString( bstrParent );

      break;
   }

   if( pIOleDs )
      pIOleDs->Release( );

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::AddProperty( BSTR bstrSchema, BSTR bstrName, BOOL bMandatory )
{
   HRESULT  hResult;
   WCHAR    szPath[ 1024 ];
   IADs*  pIOleDs;

   if ((sizeof(szPath)/2) < (wcslen(bstrSchema) + wcslen(bstrName) + 2)) //we divide sizeof by 2 because WCHAR takes 2 bytes
        return E_FAIL;

   szPath[0] = L'\0';
   wcscpy( szPath, bstrSchema );
   wcscat( szPath, L"/" );
   wcscat( szPath, bstrName );

   hResult  = m_pMainDoc->XOleDsGetObject( szPath, IID_IADs, (void**)&pIOleDs );
   if( FAILED( hResult ) )
   {
      // OK, let's qualify it...
      wcscat( szPath, L",Property" );
      hResult  = m_pMainDoc->XOleDsGetObject( szPath, IID_IADs, (void**)&pIOleDs );
   }
   if( SUCCEEDED( hResult ) )
   {
      CProperty*  pProperty;

      //hResult     = pIOleDs->GetInfo( );
      pProperty   = new CProperty( pIOleDs );
      pProperty->SetMandatory( bMandatory );
      AddProperty( pProperty );

      pIOleDs->Release( );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::BuildOptionalPropertiesList( IADsContainer* pIContainer )
{
   return S_OK;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::BuildMandatoryPropertiesList( IADsClass* pIClass )
{
   HRESULT  hResult;
   VARIANT  aMandatoryProperties;

   hResult  = Get( pIClass, _T("MandatoryProperties"), &aMandatoryProperties );
   if( FAILED( hResult ) )
   {
      hResult  = pIClass->get_MandatoryProperties( &aMandatoryProperties );
   }
   if( SUCCEEDED( hResult ) )
   {
      AddProperties( pIClass, aMandatoryProperties, TRUE );
      VariantClear( &aMandatoryProperties );
   }

   return hResult;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::LoadMethodsInformation( TCHAR* pszOperationsInterface )
{
   HRESULT     hResult= S_OK;
   ITypeLib*   pITypeLib   = NULL;
   ITypeInfo*  pITypeInfo  = NULL;
   BSTR        bstrPath;
   BSTR        bstrOperationsInterface;
   CString     strGUID;
   MEMBERID    aMemId;
   unsigned short     aFind = 1;

   while( TRUE )
   {
      hResult  = QueryPathOfRegTypeLib( LIBID_ADs, 1, 0,
                                        LOCALE_SYSTEM_DEFAULT, &bstrPath );
      if( FAILED( hResult ) )
         break;

      hResult  = LoadTypeLib( bstrPath, &pITypeLib );
      SysFreeString( bstrPath );

      if( FAILED( hResult ) )
         break;

      bstrOperationsInterface = AllocBSTR( pszOperationsInterface );
      hResult  = pITypeLib->FindName( (OLECHAR FAR* )bstrOperationsInterface,
                                      0,
                                      &pITypeInfo,
                                      &aMemId,
                                      &aFind );
      SysFreeString( bstrOperationsInterface );

      if( FAILED( hResult ) || !aFind )
         break;

      LoadMethodsInformation( pITypeInfo );

      break;
   }

   if( NULL != pITypeInfo )
      pITypeInfo->Release( );

   if( NULL != pITypeLib )
      pITypeLib->Release( );

   return hResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::ReadMandatoryPropertiesInformation( VARIANT* pVar )
{
   CString     strTemp;
   CString     strWork;
   CString     strProperty;
   CProperty*  pProperty;
   int         nProp;

   strTemp  = FromVariantToString( *pVar );
   strTemp.TrimLeft( );

   while( strTemp.GetLength( ) )
   {
      CString  strMandProp;
      int      nPos;

      strMandProp = strTemp.SpanExcluding( _T("#") );
      nPos        = strMandProp.Find( _T('.') );

      nPos++;
      strProperty    = strMandProp.GetBuffer( 128 ) + nPos;

      // get rid of leading spaces
      strProperty.TrimLeft( );

      nProp    = LookupProperty( strProperty );
      ASSERT( -1 != nProp    );

      if( -1 == nProp  )
         break;

      pProperty   = GetProperty( nProp );

      pProperty->SetMandatory( TRUE );

      strWork     = strTemp;
      nPos        = strWork.Find( _T('#') );
      if( -1 == nPos )
      {
         strWork.Empty( );
      }
      nPos++;
      strTemp     = strWork.GetBuffer( 128 ) + nPos;

      strTemp.TrimLeft( );
   }

   //SMITHA return TRUE;
   return S_OK;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CClass::CClass( )
:m_refMethods( IID_IADs )

{
   for( int nIdx = ca_ERROR; nIdx < ca_Limit; nIdx++ )
   {
      m_strAttributes[ nIdx ] = _T("???");
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CClass::~CClass( )
{
   int   nSize, nIdx;

   nSize = (int)m_pProperties->GetSize( );
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      delete m_pProperties->GetAt( nIdx );
   }

   m_pProperties->RemoveAll( );
   delete m_pProperties;

   // ****
   nSize = (int)m_pMethods->GetSize( );
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      delete m_pMethods->GetAt( nIdx );
   }

   m_pMethods->RemoveAll( );
   delete m_pMethods;
}


/***********************************************************
  Function:    CClass::GetAttribute
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  CClass::GetAttribute( CLASSATTR classAttr )
{
   switch( classAttr )
   {
      case  ca_Name:
      case  ca_DisplayName:
      case  ca_CLSID:
      case  ca_OID:
      case  ca_Abstract:
      case  ca_DerivedFrom:
      case  ca_Containment:
      case  ca_Container:
      case  ca_PrimaryInterface:
      case  ca_HelpFileName:
      case  ca_HelpFileContext:
      case  ca_MethodsCount:
         return m_strAttributes[ classAttr ];

      default:
         ASSERT( FALSE );
         return m_strAttributes[ ca_ERROR ];
   }
}


/***********************************************************
  Function:    CClass::PutAttribute
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  CClass::PutAttribute( CLASSATTR classAttr, CString& )
{
   return E_FAIL;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\simpvw.cpp ===
// simpvw.cpp : implementation of the simple view classes
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.



#include "stdafx.h"
#include "viewex.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CTextView

IMPLEMENT_DYNCREATE(CTextView, CView)

BEGIN_MESSAGE_MAP(CTextView, CView)
	//{{AFX_MSG_MAP(CTextView)
	ON_WM_MOUSEACTIVATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CTextView construction/destruction

CTextView::CTextView()
{
}

CTextView::~CTextView()
{
}

/////////////////////////////////////////////////////////////////////////////
// CTextView drawing

void CTextView::OnDraw(CDC* pDC)
{
	CMainDoc* pDoc = GetDocument();

	CRect rect;
	GetClientRect(rect);
	pDC->SetTextAlign(TA_BASELINE | TA_CENTER);
	pDC->SetBkMode(TRANSPARENT);
	// center in the window
	/*pDC->TextOut(rect.Width() / 2, rect.Height() / 2,
		pDoc->m_strData, pDoc->m_strData.GetLength());*/
}


int CTextView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	// side-step CView's implementation since we don't want to activate
	//  this view
	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

/////////////////////////////////////////////////////////////////////////////
// CColorView

IMPLEMENT_DYNCREATE(CColorView, CView)

BEGIN_MESSAGE_MAP(CColorView, CView)
	//{{AFX_MSG_MAP(CColorView)
	ON_WM_MOUSEACTIVATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CColorView construction/destruction

CColorView::CColorView()
{
}

CColorView::~CColorView()
{
}

/////////////////////////////////////////////////////////////////////////////
// CColorView drawing

void CColorView::OnDraw(CDC* pDC)
{
	CMainDoc* pDoc = GetDocument();

	CRect rect;
	GetClientRect(rect);

	// fill the view with the specified color

}

int CColorView::OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message)
{
	// side-step CView's implementation since we don't want to activate
	//  this view
	return CWnd::OnMouseActivate(pDesktopWnd, nHitTest, message);
}

void CColorView::OnActivateView(BOOL, CView*, CView*)
{
	ASSERT(FALSE);      // output only view - should never be active
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CNameView

IMPLEMENT_DYNCREATE(CNameView, CEditView)

CNameView::CNameView()
{
}

CNameView::~CNameView()
{
}


BEGIN_MESSAGE_MAP(CNameView, CEditView)
	//{{AFX_MSG_MAP(CNameView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNameView drawing


/////////////////////////////////////////////////////////////////////////////
// CNameView diagnostics

#ifdef _DEBUG
void CNameView::AssertValid() const
{
	CEditView::AssertValid();
}

void CNameView::Dump(CDumpContext& dc) const
{
	CEditView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CNameView message handlers

void CNameView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	// TODO: Add your specialized code here and/or call the base class
	//CString  strText;

   //GetDocument( )->GetItemName( strText );
   
   //GetEditCtrl().SetWindowText( strText );

   CEditView::OnUpdate( pSender, lHint, pHint );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\schemavw.h ===
// schemavw.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSchemaView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

#include "cacls.h"

class CSchemaView : public CFormView
{
protected:
	CSchemaView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CSchemaView)

// Form Data
public:
	//{{AFX_DATA(CSchemaView)
	enum { IDD = IDD_SCHEMA };
	CStatic	m_ClassOID;
	CStatic	m_Abstract;
	CStatic	m_MultiValued;
	CStatic	m_DsNames;
	CStatic	m_PropOID;
	CStatic	m_Mandatory;
	CStatic	m_Containment;
	CStatic	m_ItemOleDsPath;
	CStatic	m_PropertyMinRange;
	CStatic	m_PropertyMaxRange;
	CStatic	m_PropertyType;
	CStatic	m_PrimaryInterface;
	CStatic	m_HelpFileContext;
	CStatic	m_DerivedFrom;
	CStatic	m_HelpFileName;
	CStatic	m_CLSID;
	CStatic	m_Container;
	CStatic	m_ClassType;
	CEdit	m_PropValue;
	CComboBox	m_PropList;
	//CTabCtrl	m_Schema;
	//}}AFX_DATA

// Attributes
public:
	CMainDoc* GetDocument()
			{
				ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
				return (CMainDoc*) m_pDocument;
			}

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSchemaView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual  ~CSchemaView         ( );
   HRESULT  PutPropertyValue     ( );
   void     ResetObjectView      ( );
   void     DisplayPropertiesList( );
   void     DisplayCurrentPropertyText( );
   ADSTYPE  ConvertToADsType     ( CString strText );

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CSchemaView)
	afx_msg void OnSelchangeProplist();
	afx_msg void OnReload();
	afx_msg void OnApply();
	afx_msg void OnSetfocusPropvalue();
	afx_msg void OnMethod1();
	afx_msg void OnMethod2();
	afx_msg void OnMethod3();
	afx_msg void OnMethod4();
	afx_msg void OnMethod5();
	afx_msg void OnMethod6();
	afx_msg void OnMethod7();
	afx_msg void OnMethod8();
	afx_msg void OnAppend();
   afx_msg void OnDelete();
	afx_msg void OnChange();
	afx_msg void OnClear();
	afx_msg void OnGetProperty();
	afx_msg void OnPutProperty();
	afx_msg void OnACEChange();
	afx_msg void OnACEPropertyChange();
	afx_msg void OnACLChange();
	afx_msg void OnSDPropertyChange();
	afx_msg void OnAddACE();
	afx_msg void OnCopyACE();
	afx_msg void OnPasteACE();
	afx_msg void OnRemoveACE();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

// Other members
protected:
	void  FillACLControls( void );
	IDispatch* m_pDescriptor;

	ACLTYPE  GetCurrentACL( void );
   int      GetCurrentACE( void );
   int      GetCurrentSDProperty( void );
   int      GetCurrentACEProperty( void );
   
   void DisplayACL   ( COleDsObject* pObject, CString strAttrName );
	void HideControls ( BOOL bNormal );
	void ShowControls ( BOOL bNormal );

   void PutACEPropertyValue       ( void );
   void PutSDPropertyValue       ( void );

	void DisplaySDPropertyValue   ( void );
	void DisplayACEPropertyValue  ( void );

   void DisplaySDPropertiesList  ( int nSelect = 0 );
	void DisplayACEPropertiesList ( int nSelect = 0 );

   void DisplayACLNames          ( int nSelect = 0 );
   void DisplayACENames          ( int nSelect = 0 );

protected:
	void MoveSecurityWindows( void );
	ACLTYPE GetSelectedACL( void );
	BOOL              m_bACLDisplayed;
   int               m_nProperty;
   BOOL              m_bStatus;
   BOOL              m_bDirty;
   BOOL              m_bInitialized;
	int               m_arrNormalControls[ 64 ];
   int               m_arrSecurityControls[ 64 ];
   
   CADsSecurityDescriptor*     pSecurityDescriptor;

   int               m_nLastSD;
   int               m_nLastSDValue;
   
   int               m_nLastACE;
   int               m_nLastACEValue;

   ACLTYPE           m_nLastACL;
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CSetMandatoryProperties dialog

class CSetMandatoryProperties : public CDialog
{
// Construction
public:
	CSetMandatoryProperties(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSetMandatoryProperties)
	enum { IDD = IDD_SETPROPERTIES };
	CStatic	m_Containment;
	CStatic	m_ItemOleDsPath;
	CStatic	m_PropertyOptional;
	CStatic	m_PropertyNormal;
	CStatic	m_PropertyMinRange;
	CStatic	m_PropertyMaxRange;
	CStatic	m_PropertyType;
	CStatic	m_PrimaryInterface;
	CStatic	m_HelpFileContext;
	CStatic	m_DerivedFrom;
	CStatic	m_HelpFileName;
	CStatic	m_CLSID;
	CStatic	m_Container;
	CStatic	m_ClassType;
	CEdit	m_PropValue;
	CComboBox	m_PropList;
	CTabCtrl	m_Schema;

		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSetMandatoryProperties)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

public:
   void  SetOleDsObject( COleDsObject* );

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSetMandatoryProperties)
	afx_msg void OnSelchangeProperties(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchangeProplist();
	afx_msg void OnOK();
	afx_msg void OnSetfocusPropvalue();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:   
   HRESULT  PutPropertyValue( );

protected:
   COleDsObject*  m_pObject;
   int   m_nFuncSet;
   int   m_nProperty;
   BOOL  m_bStatus;
   BOOL  m_bDirty;
   BOOL  m_bInitialized;

};
/////////////////////////////////////////////////////////////////////////////
// CPropertyDialog dialog

class CPropertyDialog : public CDialog
{
// Construction
public:
	CPropertyDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPropertyDialog)
	enum { IDD = IDD_ADDPROPERTY };
	CString	m_PropertyName;
	CString	m_PropertyType;
	CString	m_PropertyValue;
	//}}AFX_DATA

   void  SaveLRUList ( int idCBox, TCHAR* szSection, int nMax = 100 );
   void  GetLRUList  ( int idCBox, TCHAR* szSection );

public:
   BOOL  m_bMultiValued;


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropertyDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CPropertyDialog)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\splitter.cpp ===
// splitter.cpp : implementation file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "viewex.h"
#include "schemavw.h"
#include "bwsview.h"
//#include "queryvw.h"
#include "splitter.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CSplitterFrame

// Create a splitter window which splits an output text view and an input view
//                           |
//    TEXT VIEW (CTextView)  | INPUT VIEW (CInputView)
//                           |

IMPLEMENT_DYNCREATE(CSplitterFrame, CMDIChildWnd)

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CSplitterFrame::CSplitterFrame()
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CSplitterFrame::~CSplitterFrame()
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CSplitterFrame::OnCreateClient(LPCREATESTRUCT,
	 CCreateContext* pContext)
{
	// create a splitter with 1 row, 2 columns
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
	{
		TRACE0("Failed to CreateStaticSplitter\n");
		return FALSE;
	}

	// add the first splitter pane - the default view in column 0
	if (!m_wndSplitter.CreateView(0, 0,
		pContext->m_pNewViewClass, CSize(150, 180), pContext))
	{
		TRACE0("Failed to create first pane\n");
		return FALSE;
	}

	// add the second splitter pane - an input view in column 1
	if (!m_wndSplitter.CreateView(0, 1,
		RUNTIME_CLASS(CSchemaView), CSize(0, 0), pContext))
	{
		TRACE0("Failed to create second pane\n");
		return FALSE;
	}

	// activate the input view
	SetActiveView((CView*)m_wndSplitter.GetPane(0,1));

	return TRUE;
}

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
int CSplitterFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// TODO: Add your specialized creation code here

   //ShowWindow( SW_MAXIMIZE ); 
	return 0;
}


BEGIN_MESSAGE_MAP(CSplitterFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CSplitterFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CQuerySplitterFrame

// Create a splitter window which splits an output text view and an input view
//                           |
//    TEXT VIEW (CTextView)  | INPUT VIEW (CInputView)
//                           |

IMPLEMENT_DYNCREATE(CQuerySplitterFrame, CMDIChildWnd)

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CQuerySplitterFrame::CQuerySplitterFrame()
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CQuerySplitterFrame::~CQuerySplitterFrame()
{
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CQuerySplitterFrame::OnCreateClient(LPCREATESTRUCT,
	 CCreateContext* pContext)
{
	// create a splitter with 1 row, 2 columns
	if (!m_wndSplitter.CreateStatic(this, 1, 2))
	{
		TRACE0("Failed to CreateStaticSplitter\n");
		return FALSE;
	}

	// add the first splitter pane - the default view in column 0
	if (!m_wndSplitter.CreateView(0, 0,
		pContext->m_pNewViewClass, CSize(150, 180), pContext))
	{
		TRACE0("Failed to create first pane\n");
		return FALSE;
	}

	// add the second splitter pane - an input view in column 1
//#ifdef   TRIAL
//	if (!m_wndSplitter.CreateView(0, 1,
//		RUNTIME_CLASS(CQueryView), CSize(0, 0), pContext))
//	{
//		TRACE0("Failed to create second pane\n");
//		return FALSE;
//	}
//#endif

	// activate the input view
	SetActiveView((CView*)m_wndSplitter.GetPane(0,1));

	return TRUE;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
int CQuerySplitterFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CMDIChildWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	// TODO: Add your specialized creation code here

   //ShowWindow( SW_MAXIMIZE ); 
	return 0;
}


BEGIN_MESSAGE_MAP(CQuerySplitterFrame, CMDIChildWnd)
	//{{AFX_MSG_MAP(CQuerySplitterFrame)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\stdafx.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#define VC_EXTRALEAN

#pragma warning( disable: 4237 )
#pragma warning( disable: 4005 )
#include "dswarn.h"

//#define  UNICODE
//#define  _UNICODE

//#define  _DEBUG
//#define  DEBUG


#include <afxwin.h>
#include <afxext.h>         // MFC extensions like CFormView, CSplitterWnd
#include <afxcview.h>
#include <ole2.h>
#include <activeds.h>
#include <oledb.h>
#include "objects.h"
#include "testcore.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\simpvw.h ===
// simpvw.h : interface of the simple view classes
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// CTextView - text output
// CColorView - color output

/////////////////////////////////////////////////////////////////////////////

class CTextView : public CView
{
protected: // create from serialization only
	CTextView();
	DECLARE_DYNCREATE(CTextView)

// Attributes
public:
	CMainDoc* GetDocument()
			{
				ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
				return (CMainDoc*) m_pDocument;
			}

// Operations
public:

// Implementation
public:
	virtual ~CTextView();
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view

// Generated message map functions
protected:
	//{{AFX_MSG(CTextView)
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

class CColorView : public CView
{
protected: // create from serialization only
	CColorView();
	DECLARE_DYNCREATE(CColorView)

// Attributes
public:
	CMainDoc* GetDocument()
			{
				ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
				return (CMainDoc*) m_pDocument;
			}

// Operations
public:

// Implementation
public:
	virtual ~CColorView();
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView);

// Generated message map functions
protected:
	//{{AFX_MSG(CColorView)
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};





/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CNameView view

class CNameView : public CEditView
{
protected:
	CNameView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CNameView)

// Attributes
public:
	CMainDoc* GetDocument()
			{
				ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMainDoc)));
				return (CMainDoc*) m_pDocument;
			}


// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNameView)
	protected:
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CNameView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CNameView)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\stdafx.cpp ===
// stdafx.cpp : pre-compiled header and types file
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\testcore.h ===
#ifndef  _TESTCORE_H_
#define  _TESTCORE_H_

#define  FIRST       0x00000000L
#define  NAMESPACE   0x00000000L
#define  NAMESPACES  0x00000001L
#define  USER        0x00000002L
#define  GROUP       0x00000003L
#define  DOMAIN      0x00000004L
#define  COMPUTER    0x00000005L
#define  SERVICE     0x00000006L
#define  FILESERVICE 0x00000007L
#define  SCHEMA      0x00000008L
#define  PRINTJOB    0x00000009L
#define  PRINTER     0x0000000AL
#define  PRINTQUEUE  0x0000000BL
#define  PRINTDEVICE 0x0000000CL
#define  SESSION     0x0000000DL
#define  RESOURCE    0x0000000EL
#define  FILESHARE   0x0000000FL
#define  OTHER       0x00000010L
#define  NDSROOT     0x00000011L
#define  NDSORG      0x00000012L
#define  NDSOU       0x00000013L

#define  NDSALIAS             0x00000014L
#define  NDSDIRECTORYMAP      0x00000015L
#define  NDSDISTRIBUTIONLIST  0x00000016L
#define  NDSAFPSERVER         0x00000017L
#define  NDSCOMMUNICATIONSSERVER    0x00000018L
#define  NDSMESSAGEROUTINGGROUP     0x00000019L
#define  NDSNETWARESERVER           0x0000001AL
#define  NDSORGANIZATIONALROLE      0x0000001BL
#define  NDSPRINTQUEUE              0x0000001CL
#define  NDSPRINTSERVER             0x0000001DL
#define  NDSPROFILE                 0x0000001EL
#define  NDSVOLUME                  0x0000001FL
#define  CLASS                      0x00000020L
#define  PROPERTY                   0x00000021L
#define  SYNTAX                     0x00000022L

#define  LIMIT                      0x00000023L

#define  ADSVW_INI_FILE             _T("adsvw.ini")
#define  LBOUND                     0

#define  SEPARATOR_S   _T("# ")
#define  SEPARATOR_C   _T('#')


#define  RELEASE( p )            \
   if( NULL != p )               \
   {                             \
      p->Release( );             \
   }

#define  FREE_MEMORY( mem )       \
   if( NULL != mem )              \
   {                              \
      FreeADsMem( mem );          \
   }

#define  FREE_ARRAY( mem, count )  \
   if( NULL != mem )               \
   {                               \
      FreeADsMem( mem );           \
   }

//*******************************************************************


ADSTYPE        ADsTypeFromSyntaxString( WCHAR* pszSyntax );
ADSTYPE        ADsTypeFromString( CString& strText );
CString        StringFromADsType( ADSTYPE );
DWORD          TypeFromString( WCHAR* );
DWORD          TypeFromString( CHAR*  );

void           StringFromType( DWORD, WCHAR* );
void           StringFromType( DWORD, CHAR* );
void           StringFromType( DWORD, CString& );

BOOL           MakeQualifiedName ( CHAR*,    CHAR*, DWORD );
BOOL           MakeQualifiedName ( WCHAR*,   WCHAR*, DWORD );
BOOL           MakeQualifiedName ( CString&, CString&, DWORD );

CString        OleDsGetErrorText ( HRESULT );

HRESULT        BuildFilter( BOOL*, DWORD, VARIANT* );
BOOL           GetFilter( DWORD, VARIANT*, VARIANT*   );
BOOL           SetFilter( MEMBERS*, BOOL*, DWORD );
BOOL           SetFilter( IADsContainer*, BOOL*, DWORD );

CString        FromVariantToString( VARIANT& );
CString        FromVariantArrayToString( VARIANT& v, TCHAR* pszSeparator = NULL );
HRESULT        BuildVariantArray( VARTYPE, CString&, VARIANT&, TCHAR cSeparator = SEPARATOR_C );


COleDsObject*  CreateOleDsObject ( DWORD  dwType, IUnknown* );

void           ErrorOnPutProperty( CString& strFuncSet, 
                                   CString& strProperty, 
                                   CString& strPropValue, 
                                   HRESULT  hResult,
                                   BOOL     bUseGeneric,
                                   BOOL     bUserEx ); 

BOOL           CheckIfValidClassName( CHAR*  );
BOOL           CheckIfValidClassName( WCHAR*  );

int            GetImageListIndex ( DWORD );
UINT           GetBitmapImageId  ( DWORD );

BSTR           AllocBSTR      ( WCHAR* );
BSTR           AllocBSTR      ( CHAR*  );

TCHAR*         AllocTCHAR     ( CHAR* );
TCHAR*         AllocTCHAR     ( WCHAR* );

WCHAR*         AllocWCHAR     ( CHAR* );
WCHAR*         AllocWCHAR     ( WCHAR* );

HRESULT        Get( IADs*, CHAR*, VARIANT* );
HRESULT        Get( IADs*, WCHAR*, VARIANT* );

HRESULT        Put( IADs*, CHAR*, VARIANT );
HRESULT        Put( IADs*, WCHAR*, VARIANT );

void           StringCat( CHAR*, BSTR );
void           StringCat( WCHAR*, BSTR );

void           GetLastProfileString( TCHAR*, CString& );
void           SetLastProfileString( TCHAR*, CString& );

HRESULT        CreateBlobArrayFromFile ( CString&, VARIANT& );
HRESULT        CreateBlobArray         ( CString&, VARIANT& );
HRESULT        CreateBlobArrayEx       ( CString&, VARIANT&, TCHAR cSeparator = SEPARATOR_C );

CString        Blob2String             ( void*,  DWORD );
HRESULT        String2Blob             ( TCHAR*, void**, DWORD* );

void           Convert             ( CHAR*  , CHAR*  );
void           Convert             ( WCHAR* , CHAR*  );
void           Convert             ( CHAR*  , WCHAR* );
void           Convert             ( WCHAR* , WCHAR* );

IDispatch*     CopyACE  ( IDispatch* );
IDispatch*     CopyACL  ( IDispatch* );
IDispatch*     CopySD   ( IDispatch* );


HRESULT        LARGE_INTEGERToString( TCHAR* szString, LARGE_INTEGER* pValue );
HRESULT        StringToLARGE_INTEGER( TCHAR* szString, LARGE_INTEGER* pValue );

BOOL           ConvertFromPropertyValue( VARIANT& rVar, TCHAR* szText );

long           GetVARIANTSize ( VARIANT &rVar );
HRESULT        GetVARIANTAt   ( long lIdx, VARIANT& vArray, VARIANT &vItem );

CString        FromLargeInteger( IDispatch* pDisp );
IDispatch*     CreateLargeInteger( CString& strText );
CString        GetValueAt( CString& szText, TCHAR cSep, long lValue );
long           GetValuesCount( CString& szText, TCHAR cSep  );

#ifdef _DEBUG
   #define  ERROR_HERE( szText )                            \
   {                                                        \
      TCHAR* pszText;                                       \
                                                            \
      pszText  = szText;                                    \
      Convert( pszText, __FILE__ );                         \
      _tcscat( pszText, _T( "  Line: " ) );                 \
      _itot( __LINE__, pszText + _tcslen( pszText ), 10 );  \
   }
#else
   #define  ERROR_HERE( szText ) NULL   
#endif

HRESULT  PurgeObject( IADsContainer* pParent, IUnknown* pIUnknown, LPWSTR pszPrefix = NULL );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\viewex.cpp ===
// viewex.cpp : Defines the class behaviors for the application.
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "adsqdoc.h"
#include "viewex.h"
#include "schemavw.h"
#include "adsqview.h"
#include "bwsview.h"

#include "splitter.h"
#include "schclss.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IDispatch*  pACEClipboard;
IDispatch*  pACLClipboard;
IDispatch*  pSDClipboard;

/////////////////////////////////////////////////////////////////////////////
// CViewExApp

BEGIN_MESSAGE_MAP(CViewExApp, CWinApp)
	//{{AFX_MSG_MAP(CViewExApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CViewExApp construction
// Place all significant initialization in InitInstance

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CViewExApp::CViewExApp()
{
   //afxMemDF |= delayFreeMemDF | checkAlwaysMemDF;
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
CViewExApp::~CViewExApp()
{
//   DUMP_TRACKING_INFO();
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CViewExApp object

CViewExApp NEAR theApp;

/////////////////////////////////////////////////////////////////////////////
// CViewExApp initialization

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
BOOL CViewExApp::InitInstance()
{
   // Standard initialization
	Enable3dControls();

   
   if( FAILED(OleInitialize( NULL )) )
   {
      TRACE0( "OleInitialize failed" );
      return 0;
   }


	// splitter frame with both simple text output and form input view
	AddDocTemplate(new CMultiDocTemplate(IDR_SPLIT2TYPE,
			RUNTIME_CLASS(CMainDoc),
			RUNTIME_CLASS(CSplitterFrame),
			RUNTIME_CLASS(CBrowseView)));

   AddDocTemplate( new CMultiDocTemplate(
		   IDR_QUERYVIEW,
		   RUNTIME_CLASS(CAdsqryDoc),
		   RUNTIME_CLASS(CMDIChildWnd), // custom MDI child frame
		   RUNTIME_CLASS(CAdsqryView)) );

	// create main MDI Frame window
	// Please note that for simple MDI Frame windows with no toolbar,
	//   status bar or other special behavior, the CMDIFrameWnd class
	//   can be used directly for the main frame window just as the
	//   CMDIChildWnd can be use for a document frame window.

	CMDIFrameWnd* pMainFrame = new CMDIFrameWnd;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;

	// Also in this example, there is only one menubar shared between
	//  all the views.  The automatic menu enabling support of MFC
	//  will disable the menu items that don't apply based on the
	//  currently active view.  The one MenuBar is used for all
	//  document types, including when there are no open documents.

	// Now finally show the main menu
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();
	m_pMainWnd = pMainFrame;

	#ifndef _MAC
	// command line arguments are ignored, create a new (empty) document
	OnFileNew();
	#endif

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CViewExApp commands

/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
void CViewExApp::OnAppAbout()
{
	CDialog(IDD_ABOUTBOX).DoModal();
}


/***********************************************************
  Function:    
  Arguments:   
  Return:      
  Purpose:     
  Author(s):   
  Revision:    
  Date:        
***********************************************************/
int CViewExApp::ExitInstance()
{
   if( NULL != pACEClipboard )
   {
      pACEClipboard->Release( );
   }

   if( NULL != pACLClipboard )
   {
      pACLClipboard->Release( );
   }

   if( NULL != pSDClipboard )
   {
      pSDClipboard->Release( );
   }

   OleUninitialize( );

   return CWinApp::ExitInstance( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\testcore.cpp ===
#define _LARGE_INTEGER_SUPPORT_
#include "stdafx.h"
#include "winnls.h"
#include "resource.h"
#include "errordlg.h"

typedef DWORD ( *LARGEINTTOSTRING )( LARGE_INTEGER*, ULONG, LONG, PSZ );

LARGEINTTOSTRING LargeIntegerToString;

/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
ADSTYPE  ADsTypeFromString( CString& strText )
{
   if( !strText.CompareNoCase( _T("ADSTYPE_DN_STRING") ) )
      return ADSTYPE_DN_STRING;

	if( !strText.CompareNoCase( _T("ADSTYPE_CASE_EXACT_STRING") ) )
      return ADSTYPE_CASE_EXACT_STRING;

   if( !strText.CompareNoCase( _T("ADSTYPE_CASE_IGNORE_STRING") ) )
      return ADSTYPE_CASE_IGNORE_STRING;


	if( !strText.CompareNoCase( _T("ADSTYPE_PRINTABLE_STRING") ) )
      return ADSTYPE_PRINTABLE_STRING;


	if( !strText.CompareNoCase( _T("ADSTYPE_NUMERIC_STRING") ) )
      return ADSTYPE_NUMERIC_STRING;


	if( !strText.CompareNoCase( _T("ADSTYPE_BOOLEAN") ) )
      return ADSTYPE_BOOLEAN;


	if( !strText.CompareNoCase( _T("ADSTYPE_INTEGER") ) )
      return ADSTYPE_INTEGER;


	if( !strText.CompareNoCase( _T("ADSTYPE_OCTET_STRING") ) )
      return ADSTYPE_OCTET_STRING;


	if( !strText.CompareNoCase( _T("ADSTYPE_UTC_TIME") ) )
      return ADSTYPE_UTC_TIME;


	if( !strText.CompareNoCase( _T("ADSTYPE_LARGE_INTEGER") ) )
      return ADSTYPE_LARGE_INTEGER;


	if( !strText.CompareNoCase( _T("ADSTYPE_PROV_SPECIFIC") ) )
      return ADSTYPE_PROV_SPECIFIC;

   if( !strText.CompareNoCase( _T("ADSTYPE_CASEIGNORE_LIST") ) )
      return ADSTYPE_CASEIGNORE_LIST;

   if( !strText.CompareNoCase( _T("ADSTYPE_POSTALADDRESS") ) )
      return ADSTYPE_POSTALADDRESS;

	if( !strText.CompareNoCase( _T("ADSTYPE_OCTET_LIST") ) )
      return ADSTYPE_OCTET_LIST;

	if( !strText.CompareNoCase( _T("ADSTYPE_PATH") ) )
      return ADSTYPE_PATH;

	if( !strText.CompareNoCase( _T("ADSTYPE_POSTALADDRESS") ) )
      return ADSTYPE_POSTALADDRESS;

	if( !strText.CompareNoCase( _T("ADSTYPE_TIMESTAMP") ) )
      return ADSTYPE_TIMESTAMP;

	if( !strText.CompareNoCase( _T("ADSTYPE_BACKLINK") ) )
      return ADSTYPE_BACKLINK;

	if( !strText.CompareNoCase( _T("ADSTYPE_TYPEDNAME") ) )
      return ADSTYPE_TYPEDNAME;

	if( !strText.CompareNoCase( _T("ADSTYPE_HOLD") ) )
      return ADSTYPE_HOLD;

	if( !strText.CompareNoCase( _T("ADSTYPE_NETADDRESS") ) )
      return ADSTYPE_NETADDRESS;

	if( !strText.CompareNoCase( _T("ADSTYPE_REPLICAPOINTER") ) )
      return ADSTYPE_REPLICAPOINTER;

	if( !strText.CompareNoCase( _T("ADSTYPE_FAXNUMBER") ) )
      return ADSTYPE_FAXNUMBER;

	if( !strText.CompareNoCase( _T("ADSTYPE_EMAIL") ) )
      return ADSTYPE_EMAIL;

   return ADSTYPE_INVALID;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
ADSTYPE  ADsTypeFromSyntaxString( WCHAR* pszSyntax )
{
   ADSTYPE  eType = ADSTYPE_CASE_IGNORE_STRING;

   if( !_wcsicmp( pszSyntax, L"String" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"DN" ) )
   {
      eType = ADSTYPE_DN_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"ObjectSecurityDescriptor" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"OID" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"Object Class" ) )
   {
      eType = ADSTYPE_OBJECT_CLASS;
   }
   else if( !_wcsicmp( pszSyntax, L"DirectoryString" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"ORName" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"IA5String" ) )
   {
      eType = ADSTYPE_NUMERIC_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"NumericString" ) )
   {
      eType = ADSTYPE_NUMERIC_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"CaseIgnoreString" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"PrintableString" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"Counter" ) )
   {
      eType = ADSTYPE_INTEGER;
   }
   else if( !_wcsicmp( pszSyntax, L"OleDsPath" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"Email" ) )
   {
      eType = ADSTYPE_EMAIL;
   }
   else if( !_wcsicmp( pszSyntax, L"Hold" ) )
   {
      eType = ADSTYPE_HOLD;
   }
   else if( !_wcsicmp( pszSyntax, L"Octet" ) )
   {
      eType = ADSTYPE_OCTET_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"Back Link" ) )
   {
      eType = ADSTYPE_BACKLINK;
   }
   else if( !_wcsicmp( pszSyntax, L"Typed Name" ) )
   {
      eType = ADSTYPE_TYPEDNAME;
   }
   else if( !_wcsicmp( pszSyntax, L"EmailAddress" ) )
   {
      eType = ADSTYPE_EMAIL;
   }
   else if( !_wcsicmp( pszSyntax, L"Path" ) )
   {
      eType = ADSTYPE_PATH;
   }
   else if( !_wcsicmp( pszSyntax, L"Case Ignore List" ) )
   {
      eType = ADSTYPE_CASEIGNORE_LIST;
   }
   else if( !_wcsicmp( pszSyntax, L"Octet List" ) )
   {
      eType = ADSTYPE_OCTET_LIST;
   }
   else if( !_wcsicmp( pszSyntax, L"FaxNumber" ) )
   {
      eType = ADSTYPE_FAXNUMBER;
   }
   else if( !_wcsicmp( pszSyntax, L"Integer" ) )
   {
      eType = ADSTYPE_INTEGER;
   }
   else if( !_wcsicmp( pszSyntax, L"Integer8" ) )
   {
      eType = ADSTYPE_LARGE_INTEGER;
   }
   else if( !_wcsicmp( pszSyntax, L"Postal Address" ) )
   {
      eType = ADSTYPE_POSTALADDRESS;
   }
   else if( !_wcsicmp( pszSyntax, L"Interval" ) )
   {
      eType = ADSTYPE_INTEGER;
   }
   else if( !_wcsicmp( pszSyntax, L"List" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"NetAddress" ) )
   {
      eType = ADSTYPE_NETADDRESS;
   }
   else if( !_wcsicmp( pszSyntax, L"OctetString" ) )
   {
      eType = ADSTYPE_OCTET_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"Path" ) )
   {
      eType = ADSTYPE_PATH;
   }
   else if( !_wcsicmp( pszSyntax, L"PhoneNumber" ) )
   {
      eType = ADSTYPE_CASE_IGNORE_STRING;
   }
   else if( !_wcsicmp( pszSyntax, L"PostalAddress" ) )
   {
      eType = ADSTYPE_POSTALADDRESS;
   }
   else if( !_wcsicmp( pszSyntax, L"SmallInterval" ) )
   {
      eType = ADSTYPE_INTEGER;
   }
   else if( !_wcsicmp( pszSyntax, L"Time" ) )
   {
      eType = ADSTYPE_UTC_TIME;
   }
   else if( !_wcsicmp( pszSyntax, L"TimeStamp" ) )
   {
      eType = ADSTYPE_TIMESTAMP;
   }
  else if( !_wcsicmp( pszSyntax, L"UTCTime" ) )
   {
      eType = ADSTYPE_UTC_TIME;
   }
  else if( !_wcsicmp( pszSyntax, L"GeneralizedTime" ) )
   {
      eType = ADSTYPE_UTC_TIME;
   }
   else if( !_wcsicmp( pszSyntax, L"boolean" ) )
   {
      eType = ADSTYPE_BOOLEAN;
   }
   else
   {
      TCHAR szText[ 128 ];

      Convert( szText, pszSyntax );
      TRACE( _T("ERROR: unknown %s syntax\n"), szText );
      //ASSERT( FALSE );
   }

   return eType;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  StringFromADsType( ADSTYPE eType )
{

   switch( eType )
   {
      case  ADSTYPE_DN_STRING:
         return CString( _T("ADSTYPE_DN_STRING") );

      case  ADSTYPE_CASE_EXACT_STRING:
	      return CString( _T("ADSTYPE_CASE_EXACT_STRING") );

      case  ADSTYPE_CASE_IGNORE_STRING:
         return CString( _T("ADSTYPE_CASE_IGNORE_STRING") );

      case  ADSTYPE_PRINTABLE_STRING:
	      return CString( _T("ADSTYPE_PRINTABLE_STRING") );

      case  ADSTYPE_NUMERIC_STRING:
	      return CString( _T("ADSTYPE_NUMERIC_STRING") );

      case  ADSTYPE_BOOLEAN:
	      return CString( _T("ADSTYPE_BOOLEAN") );

      case  ADSTYPE_INTEGER:
	      return CString( _T("ADSTYPE_INTEGER") );

      case  ADSTYPE_OCTET_STRING:
	      return CString( _T("ADSTYPE_OCTET_STRING") );

      case  ADSTYPE_UTC_TIME:
	      return CString( _T("ADSTYPE_UTC_TIME") );


      case  ADSTYPE_LARGE_INTEGER:
	      return CString( _T("ADSTYPE_LARGE_INTEGER") );


      case  ADSTYPE_PROV_SPECIFIC:
	      return CString( _T("ADSTYPE_PROV_SPECIFIC") );

      default:
         return CString( _T("ADSTYPE_UNKNOWN") );

   }
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD TypeFromString( LPWSTR lpszBuffer )
{
   if( !lpszBuffer )
      return OTHER;

   if( !_wcsicmp( lpszBuffer, L"Namespace" ) )
      return NAMESPACE;

   if( !_wcsicmp(  lpszBuffer, L"Namespaces" ) )
      return NAMESPACES;

   if( !_wcsicmp( lpszBuffer, L"User" ) )
      return USER;

   if( !_wcsicmp( lpszBuffer, L"Group" ) )
      return GROUP;

   if( !_wcsicmp( lpszBuffer, L"LocalGroup" ) )
      return GROUP;

   if( !_wcsicmp( lpszBuffer, L"GlobalGroup" ) )
      return GROUP;

   if( !_wcsicmp( lpszBuffer, L"groupofuniquenames" ) )
      return GROUP;

   if( !_wcsicmp( lpszBuffer, L"Domain" ) )
      return DOMAIN;

   if( !_wcsicmp( lpszBuffer, L"Computer" ) )
      return  COMPUTER;

   if( !_wcsicmp( lpszBuffer, L"Service" ) )
      return  SERVICE;

   if( !_wcsicmp( lpszBuffer, L"FileService" ) )
      return  FILESERVICE;

   if( !_wcsicmp( lpszBuffer, L"Printqueue" ) )
      return  PRINTQUEUE;

   if( !_wcsicmp( lpszBuffer, L"Printer" ) )
      return  PRINTER;

   if( !_wcsicmp( lpszBuffer, L"Printjob" ) )
      return  PRINTJOB;

   if( !_wcsicmp( lpszBuffer, L"PrintDevice" ) )
      return  PRINTDEVICE;

   if( !_wcsicmp( lpszBuffer, L"Session" ) )
      return   SESSION;

   if( !_wcsicmp( lpszBuffer, L"Resource" ) )
      return   RESOURCE;

   if( !_wcsicmp( lpszBuffer, L"FileShare" ) )
      return   FILESHARE;

   if( !_wcsicmp( lpszBuffer, L"Organization" ) )
      return NDSORG;

   if( !_wcsicmp( lpszBuffer, L"Root" ) )
      return NDSROOT;

   if( !_wcsicmp( lpszBuffer, L"Tree" ) )
      return NDSROOT;

   if( !_wcsicmp( lpszBuffer, L"Top" ) )
      return NDSROOT;

   if( !_wcsicmp( lpszBuffer, L"Organizational Unit" ) )
      return NDSOU;

   if( !_wcsicmp( lpszBuffer, L"OrganizationalUnit" ) )
      return NDSOU;

   if( !_wcsicmp( lpszBuffer, L"DomainOrganizationalUnit" ) )
      return NDSOU;

   if( !_wcsicmp( lpszBuffer, L"Alias" ) )
      return   NDSALIAS;

   if( !_wcsicmp( lpszBuffer, L"Directory Map" ) )
      return   NDSDIRECTORYMAP;

   if( !_wcsicmp( lpszBuffer, L"Distribution List" ) )
      return   NDSDISTRIBUTIONLIST;

   if( !_wcsicmp( lpszBuffer, L"AFP Server" ) )
      return   NDSAFPSERVER;

   if( !_wcsicmp( lpszBuffer, L"Communications Server" ) )
      return   NDSCOMMUNICATIONSSERVER;

   if( !_wcsicmp( lpszBuffer, L"Message Routing Group" ) )
      return   NDSMESSAGEROUTINGGROUP;

   if( !_wcsicmp( lpszBuffer, L"NCP Server" ) )
      return   NDSNETWARESERVER;

   if( !_wcsicmp( lpszBuffer, L"Organizational Role" ) )
      return   NDSORGANIZATIONALROLE;

   if( !_wcsicmp( lpszBuffer, L"Queue" ) )
      return   NDSPRINTQUEUE;

   if( !_wcsicmp( lpszBuffer, L"Print Server" ) )
      return   NDSPRINTSERVER;

   if( !_wcsicmp( lpszBuffer, L"Profile" ) )
      return   NDSPROFILE;

   if( !_wcsicmp( lpszBuffer, L"Volume" ) )
      return   NDSVOLUME;

   if( !_wcsicmp( lpszBuffer, L"Class" ) )
      return   CLASS;

   if( !_wcsicmp( lpszBuffer, L"Schema" ) )
      return   SCHEMA;

   if( !_wcsicmp( lpszBuffer, L"Syntax" ) )
      return   SYNTAX;

   if( !_wcsicmp( lpszBuffer, L"Property" ) )
      return   PROPERTY;

   return OTHER;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
DWORD TypeFromString( LPSTR lpszBuffer )
{
   int      nLength;
   WCHAR*   pszwType;
   DWORD    dwType;

   nLength  = strlen( lpszBuffer );

   pszwType = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
 
   if ( pszwType ) {
       memset( pszwType, 0, ( nLength + 1 ) * sizeof(WCHAR) );

       MultiByteToWideChar( CP_ACP,
                            MB_PRECOMPOSED,
                            lpszBuffer,
                            nLength,
                            pszwType,
                            nLength + 1 );
   }
   dwType   = TypeFromString( pszwType );
   if ( pszwType ) 
	   free( pszwType );

   return dwType;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  StringFromType( DWORD dwType, CString& rString )
{
   TCHAR szText[ 128 ];

   StringFromType( dwType, szText );

   rString  = szText;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  StringFromType( DWORD dwType, TCHAR* lpszBuffer )
{
   switch( dwType )
   {
      case  NAMESPACE:
         _tcscpy( lpszBuffer, _T("Namespace") );
         break;

      case  NAMESPACES:
         _tcscpy( lpszBuffer, _T("Namespaces") );
         break;

      case  USER:
         _tcscpy( lpszBuffer, _T("User") );
         break;

      case  GROUP:
         _tcscpy( lpszBuffer, _T("Group") );
         break;

      case  DOMAIN:
         _tcscpy( lpszBuffer, _T("Domain") );
         break;

      case  COMPUTER:
         _tcscpy( lpszBuffer, _T("Computer") );
         break;

      case  SERVICE:
         _tcscpy( lpszBuffer, _T("Service") );
         break;

      case  FILESERVICE:
         _tcscpy( lpszBuffer, _T("FileService") );
         break;

      case  PRINTQUEUE:
         _tcscpy( lpszBuffer, _T("Printqueue") );
         break;

      case  PRINTER:
         _tcscpy( lpszBuffer, _T("Printer") );
         break;

      case  PRINTJOB:
         _tcscpy( lpszBuffer, _T("PrintJob") );
         break;

      case  PRINTDEVICE:
         _tcscpy( lpszBuffer, _T("PrintDevice") );
         break;

      case  SESSION:
         _tcscpy( lpszBuffer, _T("Session") );
         break;

      case  FILESHARE:
         _tcscpy( lpszBuffer, _T("FileShare") );
         break;

      case  RESOURCE:
         _tcscpy( lpszBuffer, _T("Resource") );
         break;

      case  NDSORG:
         _tcscpy( lpszBuffer, _T("Organization") );
         break;

      case  NDSROOT:
         _tcscpy( lpszBuffer, _T("Tree") );
         break;

      case  NDSOU:
         _tcscpy( lpszBuffer, _T("Organizational Unit") );
         break;

      case  NDSALIAS:
         _tcscpy( lpszBuffer, _T("Alias") );
         break;

      case  NDSDIRECTORYMAP:
         _tcscpy( lpszBuffer, _T("Directory Map") );
         break;

      case  NDSDISTRIBUTIONLIST:
         _tcscpy( lpszBuffer, _T("Distribution List") );
         break;

      case  NDSAFPSERVER:
         _tcscpy( lpszBuffer, _T("AFP Server") );
         break;

      case  NDSCOMMUNICATIONSSERVER:
         _tcscpy( lpszBuffer, _T("Communications Server") );
         break;

      case  NDSMESSAGEROUTINGGROUP:
         _tcscpy( lpszBuffer, _T("Message Routing Group") );
         break;

      case  NDSNETWARESERVER:
         _tcscpy( lpszBuffer, _T("NCP Server") );
         break;

      case  NDSORGANIZATIONALROLE:
         _tcscpy( lpszBuffer, _T("Organizational Role") );
         break;

      case  NDSPRINTQUEUE:
         _tcscpy( lpszBuffer, _T("Queue") );
         break;

      case  NDSPRINTSERVER:
         _tcscpy( lpszBuffer, _T("Print Server") );
         break;

      case  NDSPROFILE:
         _tcscpy( lpszBuffer, _T("Profile") );
         break;

      case  NDSVOLUME:
         _tcscpy( lpszBuffer, _T("Volume") );
         break;

      case  SCHEMA:
         _tcscpy( lpszBuffer, _T("Schema") );
         break;

      case  OTHER:
         _tcscpy( lpszBuffer, _T("Other") );
         break;

      case  CLASS:
         _tcscpy( lpszBuffer, _T("Class") );
         break;

      case  PROPERTY:
         _tcscpy( lpszBuffer, _T("Property") );
         break;

      case  SYNTAX:
         _tcscpy( lpszBuffer, _T("Syntax") );
         break;

      default:
         ASSERT( FALSE );
         _tcscpy( lpszBuffer, _T("") );
   }
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  MakeQualifiedName( TCHAR* strDest, TCHAR* strName, DWORD dwType )
{
   TCHAR szTemp[ 128 ];

   _tcscpy( strDest, strName );

   if( OTHER == dwType )
      return TRUE;

   StringFromType( dwType, szTemp );

   if( _tcslen( szTemp ) )
   {
      _tcscat( strDest, _T(",") );
   }
   _tcscat( strDest, szTemp );

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  MakeQualifiedName ( CString& strDest, CString& strName, DWORD dwType )
{
   TCHAR szTemp[ 128 ];

   strDest  = strName;

   if( OTHER != dwType )
   {
      StringFromType( dwType, szTemp );
      strDest  = strDest + _T(',');
      strDest  = strDest + CString( szTemp );
   }

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL     TryThisFilter( BSTR bstrObjectType, MEMBERS* pIGroup )
{
   VARIANT        v, varFilter, varOld;
   SAFEARRAY      *psaTry     = NULL;
   SAFEARRAYBOUND sabTryArray;
   HRESULT        hr;
   long           i;

   sabTryArray.cElements   = 1;
   sabTryArray.lLbound     = LBOUND;
   psaTry = SafeArrayCreate( VT_VARIANT, 1, &sabTryArray );

   if (!psaTry)
   {
      return FALSE;
   }

   VariantInit(&v);
   V_VT(&v)    = VT_BSTR;
   V_BSTR(&v)  = SysAllocString( bstrObjectType );
   i           = LBOUND;
   hr          = SafeArrayPutElement( psaTry, (long FAR *)&i, &v );

   while( TRUE )
   {
      if( FAILED( hr ) )
         break;

      hr = pIGroup->get_Filter( &varOld );
      if( FAILED( hr ) )
         break;

      VariantInit(&varFilter);

      V_VT(&varFilter)     = VT_VARIANT | VT_ARRAY;
      V_ARRAY( &varFilter)   = psaTry;
      hr = pIGroup->put_Filter( varFilter );
      if( FAILED( hr ) )
         break;

      hr = pIGroup->put_Filter( varOld );
      ASSERT( SUCCEEDED( hr ) );

      hr = VariantClear( &varOld );
      ASSERT( SUCCEEDED( hr ) );
      break;
   }
   SafeArrayDestroy( psaTry );

   return SUCCEEDED( hr );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  BuildFilter( BOOL* pFilters, DWORD dwFilters, VARIANT* pvarFilter )
{
   VARIANT        varFilter;
   DWORD          dwIter, dwCount, dwType;
   SAFEARRAY      *psaFilter  = NULL;
   HRESULT        hResult;
   SAFEARRAYBOUND sabFilterArray;
   BSTR           bstrTexts[ LIMIT ];
   TCHAR          szType[ 128 ];

   dwCount  = 0L;

   for( dwType = 0L ; dwType < dwFilters ; dwType++ )
   {
      if( OTHER == dwType )
         continue;

      if( pFilters[ dwType ] )
      {
         StringFromType( dwType, szType );
         bstrTexts[ dwCount++ ]  = AllocBSTR( szType );
      }
   }

   sabFilterArray.cElements   = dwCount;
   sabFilterArray.lLbound     = LBOUND;
   psaFilter                  = SafeArrayCreate( VT_VARIANT, 1, &sabFilterArray );

   if ( psaFilter )
   {
      for( dwIter = LBOUND; dwIter < ( LBOUND + dwCount ); dwIter++ )
      {
         VariantInit(&varFilter);
         V_VT(&varFilter)    = VT_BSTR;

         V_BSTR(&varFilter)  = bstrTexts[ dwIter ];
         hResult     = SafeArrayPutElement( psaFilter,
                                            (long FAR *)&dwIter, &varFilter );
         ASSERT( SUCCEEDED( hResult ) );
         VariantClear( &varFilter );
      }

      V_VT(pvarFilter)     = VT_VARIANT | VT_ARRAY;
      V_ARRAY(pvarFilter)  = psaFilter;
   }
   else {
	  hResult = E_OUTOFMEMORY ;
   }

   // return SUCCEEDED( hResult );
   return hResult ;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL     SetFilter( IADsCollection* pIColl, BOOL* pFilters, DWORD dwFilters )
{
   VARIANT        v;
   HRESULT        hResult;

   hResult  = BuildFilter( pFilters, dwFilters, &v );

   if( SUCCEEDED( hResult ) )
   {
      /*hResult  = pIColl->put_Filter( v );
      if( FAILED( hResult ) )
      {
         TRACE( _T( "ERROR! put_Filter failed") );
      } */

      VariantClear( &v );
   }

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  SetFilter( MEMBERS* pIGroup, BOOL* pFilters, DWORD dwFilters )
{
   VARIANT        v;
   HRESULT        hResult;

   hResult  = BuildFilter( pFilters, dwFilters, &v );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = pIGroup->put_Filter( v );
      if( FAILED( hResult ) )
      {
         TRACE( _T( "ERROR! put_Filter failed") );
      }

      VariantClear( &v );
   }

   return SUCCEEDED( hResult );
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  SetFilter( IADsContainer* pIContainer, BOOL* pFilters, DWORD dwFilters )
{
   VARIANT        v;
   HRESULT        hResult;

   hResult  = BuildFilter( pFilters, dwFilters, &v );

   if( SUCCEEDED( hResult ) )
   {
      hResult  = pIContainer->put_Filter( v );
      if( FAILED( hResult ) )
      {
         TRACE( _T( "ERROR! put_Filter failed") );
      }

      VariantClear( &v );
   }

   return SUCCEEDED( hResult );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  OleDsGetErrorText ( HRESULT  hResult  )
{
   TCHAR szText[ 128 ];

   switch( hResult )
   {
      case  E_ADS_BAD_PATHNAME:
         return CString( _T("E_ADS_BAD_PATHNAME") );
         break;

      case  E_ADS_INVALID_DOMAIN_OBJECT:
         return CString( _T("E_ADS_INVALID_DOMAIN_OBJECT") );
         break;

      case  E_ADS_INVALID_USER_OBJECT:
         return CString( _T("E_ADS_INVALID_USER_OBJECT") );
         break;

      case  E_ADS_INVALID_COMPUTER_OBJECT:
         return CString( _T("E_ADS_INVALID_COMPUTER_OBJECT") );
         break;

      case  E_ADS_UNKNOWN_OBJECT:
         return CString( _T("E_ADS_UNKNOWN_OBJECT") );
         break;

      case  E_ADS_PROPERTY_NOT_SET:
         return CString( _T("E_ADS_PROPERTY_NOT_SET") );
         break;

      case  E_ADS_PROPERTY_NOT_SUPPORTED:
         return CString( _T("E_ADS_PROPERTY_NOT_SUPPORTED") );
         break;

      case  E_ADS_PROPERTY_INVALID:
         return CString( _T("E_ADS_PROPERTY_INVALID") );
         break;

      case  E_ADS_BAD_PARAMETER:
         return CString( _T("E_ADS_BAD_PARAMETER") );
         break;

      case  E_ADS_OBJECT_UNBOUND:
         return CString( _T("E_ADS_OBJECT_UNBOUND") );
         break;

      case  E_ADS_PROPERTY_NOT_MODIFIED:
         return CString( _T("E_ADS_PROPERTY_NOT_MODIFIED") );
         break;

      case  E_ADS_PROPERTY_MODIFIED:
         return CString( _T("E_ADS_PROPERTY_MODIFIED") );
         break;

      case  E_ADS_CANT_CONVERT_DATATYPE:
         return CString( _T("E_ADS_CANT_CONVERT_DATATYPE") );
         break;

      case  E_ADS_PROPERTY_NOT_FOUND:
         return CString( _T("E_ADS_PROPERTY_NOTFOUND") );
         break;

      case  E_ADS_OBJECT_EXISTS:
         return CString( _T("E_ADS_OBJECT_EXISTS") );
         break;

      case  E_ADS_SCHEMA_VIOLATION:
         return CString( _T("E_ADS_SCHEMA_VIOLATION") );
         break;

      case  E_ADS_COLUMN_NOT_SET:
         return CString( _T("E_ADS_COLUMN_NOT_SET") );
         break;

      case  E_ADS_INVALID_FILTER:
         return CString( _T("E_ADS_INVALID_FILTER") );
         break;

      //case  E_ADS_LDAP_BASE:
      //   return CString( _T("E_ADS_LDAP_BASE") );
      //   break;

      case  HRESULT_FROM_WIN32(ERROR_DS_OPERATIONS_ERROR):
         return CString( _T("ERROR_DS_OPERATIONS_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_PROTOCOL_ERROR):
         return CString( _T("ERROR_DS_PROTOCOL_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_TIMELIMIT_EXCEEDED):
         return CString( _T("ERROR_DS_TIMELIMIT_EXCEEDED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_SIZELIMIT_EXCEEDED):
         return CString( _T("ERROR_DS_SIZELIMIT_EXCEEDED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_COMPARE_FALSE):
         return CString( _T("ERROR_DS_COMPARE_FALSE") );
         break;


      case  HRESULT_FROM_WIN32(ERROR_DS_COMPARE_TRUE):
         return CString( _T("ERROR_DS_COMPARE_TRUE") );
         break;


      case  HRESULT_FROM_WIN32(ERROR_DS_AUTH_METHOD_NOT_SUPPORTED):
         return CString( _T("ERROR_DS_AUTH_METHOD_NOT_SUPPORTED") );
         break;


      case  HRESULT_FROM_WIN32(ERROR_DS_STRONG_AUTH_REQUIRED):
         return CString( _T("ERROR_DS_STRONG_AUTH_REQUIRED") );
         break;


      case  HRESULT_FROM_WIN32(ERROR_MORE_DATA):
         return CString( _T("ERROR_MORE_DATA") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_REFERRAL):
         return CString( _T("(ERROR_DS_REFERRAL") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_ADMIN_LIMIT_EXCEEDED):
         return CString( _T("ERROR_DS_ADMIN_LIMIT_EXCEEDED") );
         break;


      case  HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE_CRIT_EXTENSION):
         return CString( _T("(ERROR_DS_UNAVAILABLE_CRIT_EXTENSION") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CONFIDENTIALITY_REQUIRED):
         return CString( _T("HRESULT_FROM_WIN32(ERROR_DS_CONFIDENTIALITY_REQUIRED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_NO_ATTRIBUTE_OR_VALUE):
         return CString( _T("ERROR_DS_NO_ATTRIBUTE_OR_VALUE") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED):
         return CString( _T("(ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_INAPPROPRIATE_MATCHING):
         return CString( _T("(ERROR_DS_INAPPROPRIATE_MATCHING") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CONSTRAINT_VIOLATION):
         return CString( _T("ERROR_DS_CONSTRAINT_VIOLATION") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS):
         return CString( _T("ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX):
         return CString( _T("ERROR_DS_INVALID_ATTRIBUTE_SYNTAX") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT):
         return CString( _T("ERROR_DS_NO_SUCH_OBJECT") );
         break;

      // case  HRESULT_FROM_WIN32(E_ADS_LDAP_ALIAS_PROBLEM:
         // return CString( _T("HRESULT_FROM_WIN32(E_ADS_LDAP_ALIAS_PROBLEM") );
         // break;

      case  HRESULT_FROM_WIN32(ERROR_DS_INVALID_DN_SYNTAX):
         return CString( _T("(ERROR_DS_INVALID_DN_SYNTAX") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_IS_LEAF):
         return CString( _T("(ERROR_DS_IS_LEAF") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_ALIAS_DEREF_PROBLEM):
         return CString( _T("(ERROR_DS_ALIAS_DEREF_PROBLEM") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_INAPPROPRIATE_AUTH):
         return CString( _T("(ERROR_DS_INAPPROPRIATE_AUTH") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD):
         return CString( _T("(ERROR_INVALID_PASSWORD") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED):
         return CString( _T("ERROR_ACCESS_DENIED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_BUSY):
         return CString( _T("ERROR_DS_BUSY") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_UNAVAILABLE):
         return CString( _T("ERROR_DS_UNAVAILABLE") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_UNWILLING_TO_PERFORM):
         return CString( _T("ERROR_DS_UNWILLING_TO_PERFORM") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_LOOP_DETECT):
         return CString( _T("ERROR_DS_LOOP_DETECT") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_NAMING_VIOLATION):
         return CString( _T("ERROR_DS_NAMING_VIOLATION") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_OBJ_CLASS_VIOLATION):
         return CString( _T("ERROR_DS_OBJ_CLASS_VIOLATION") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CANT_ON_NON_LEAF):
         return CString( _T("ERROR_DS_CANT_ON_NONLEAF") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CANT_ON_RDN):
         return CString( _T("ERROR_DS_CANT_ON_RDN") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS):
         return CString( _T("ERROR_ALREADY_EXISTS") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CANT_MOD_OBJ_CLASS):
         return CString( _T("ERROR_DS_CANT_MOD_OBJ_CLASS") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_OBJECT_RESULTS_TOO_LARGE):
         return CString( _T("ERROR_DS_OBJECT_RESULTS_TOO_LARGE") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_AFFECTS_MULTIPLE_DSAS):
         return CString( _T("ERROR_DS_AFFECTS_MULTIPLE_DSAS") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_GEN_FAILURE):
         return CString( _T("(ERROR_GEN_FAILURE") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_SERVER_DOWN):
         return CString( _T("ERROR_DS_SERVER_DOWN") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_LOCAL_ERROR):
         return CString( _T("ERROR_DS_LOCAL_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_ENCODING_ERROR):
         return CString( _T("ERROR_DS_ENCODING_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_DECODING_ERROR):
         return CString( _T("(ERROR_DS_DECODING_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_TIMEOUT):
         return CString( _T("(ERROR_TIMEOUT") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN):
         return CString( _T("ERROR_DS_AUTH_UNKNOWN") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_FILTER_UNKNOWN):
         return CString( _T("(ERROR_DS_FILTER_UNKNOWN") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_CANCELLED):
         return CString( _T("(ERROR_CANCELLED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_PARAM_ERROR):
         return CString( _T("ERROR_DS_PARAM_ERROR") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY):
         return CString( _T("ERROR_NOT_ENOUGH_MEMORY") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_CONNECTION_REFUSED):
         return CString( _T("ERROR_CONNECTION_REFUSED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_NOT_SUPPORTED):
         return CString( _T("ERROR_DS_NOT_SUPPORTED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_NO_RESULTS_RETURNED):
         return CString( _T("ERROR_DS_NO_RESULTS_RETURNED") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CONTROL_NOT_FOUND):
         return CString( _T("ERROR_DS_CONTROL_NOT_FOUND") );
         break;

      // case  HRESULT_FROM_WIN32(E_ADS_LDAP_MORE_RESULTS_TO_RETURN:
         // return CString( _T("HRESULT_FROM_WIN32(E_ADS_LDAP_MORE_RESULTS_TO_RETURN") );
         // break;

      case  HRESULT_FROM_WIN32(ERROR_DS_CLIENT_LOOP):
         return CString( _T("(ERROR_DS_CLIENT_LOOP") );
         break;

      case  HRESULT_FROM_WIN32(ERROR_DS_REFERRAL_LIMIT_EXCEEDED):
         return CString( _T("ERROR_DS_REFERRAL_LIMIT_EXCEEDED") );
         break;

      // case  HRESULT_FROM_WIN32(E_ADS_LDAP_LAST:
         // return CString( _T("HRESULT_FROM_WIN32(E_ADS_LDAP_LAST") );
         // break;

      case  E_FAIL:
         return CString( _T("E_FAIL") );
         break;

      case  E_NOTIMPL:
         return CString( _T("E_NOIMPL") );
         break;

      case  S_OK:
         return CString( _T("OK") );
         break;

      case  0x800704b8:
      // we have an extended error
      {
         TCHAR szError[ 1024 ];
         WCHAR szErrorBuff[ 1024 ];
         WCHAR szNameBuff[ 1024 ];
         DWORD dwError;

         ADsGetLastError( &dwError,
                          szErrorBuff,
                          1023,
                          szNameBuff,
                          1023 );
         wcscat( szNameBuff, L" : " );
         wcscat( szNameBuff, szErrorBuff );

         _tcscpy( szError, _T("ERROR: ") );
         Convert( szError + _tcslen( szError ), szNameBuff );

         return CString( szError );
      }

      default:
      {
         LPVOID lpMsgBuf;
         UINT   nChars;

         nChars   = FormatMessage(
                            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                            NULL,
                            SCODE_CODE(hResult),
                            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                            (LPTSTR) &lpMsgBuf,
                            0,
                            NULL
                           );

         if( nChars )
         {
            if( nChars != _tcslen( (LPTSTR)lpMsgBuf ) )
            {
               ((LPTSTR)lpMsgBuf)[nChars]  = _T('\0');
            }
            wsprintf( szText, _T("ERROR: %lx - %s"), hResult, (LPTSTR)lpMsgBuf );
            LocalFree( lpMsgBuf );

         }
         else
         {
            DWORD dwLastError;

            wsprintf( szText, _T("ERROR: %lx"), hResult );
            dwLastError = GetLastError();
         }
         return CString( szText );
         break;
      }
   }
}


/***********************************************************
  Function: BuildVariantArray
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
HRESULT  BuildVariantArray( VARTYPE vType,
                            CString& rText,
                            VARIANT& varRes,
                            TCHAR cSeparator )
{
   VARIANT        vTemp, vTyped;
   SAFEARRAY*     psa;
   SAFEARRAYBOUND sab;
   CStringArray   strArray;
   TCHAR*         strText;
   int            nItems   = 0;
   int            nIdx;
   int            nSize;
   LPTSTR         lpName;
   HRESULT        hResult;

   strText  = (TCHAR*) new TCHAR[ rText.GetLength( ) + 1 ];

   if( !strText )
   {
      return E_FAIL;
   }

   if( VT_I8 == vType )
   {
      vType = VT_R8;
   }

   _tcscpy( strText, rText.GetBuffer( rText.GetLength( ) ) );

   nSize    = rText.GetLength( );
   nItems   = nSize ? 1 : 0;
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      if( strText[ nIdx ] == cSeparator )
      {
         nItems++;
         strText[ nIdx ] = _T('\0');
      }
   }

   sab.cElements   = nItems;
   sab.lLbound     = LBOUND;
   psa             = SafeArrayCreate( VT_VARIANT, 1, &sab );

   ASSERT( NULL != psa );

   if ( psa )
   {

      lpName      = strText;
      for( nIdx = LBOUND; nIdx < ( LBOUND + nItems ) ; nIdx++ )
      {
         while( *lpName == _T(' ') )
         {
            lpName++;
         }

         VariantInit( &vTemp );
         V_VT(&vTemp)  = VT_BSTR;

         V_BSTR(&vTemp) = AllocBSTR( lpName );
         lpName         = lpName + ( _tcslen( lpName ) + 1 );

         VariantInit( &vTyped );
         hResult  = VariantChangeType( &vTyped, &vTemp, VARIANT_NOVALUEPROP, vType );

         hResult  = SafeArrayPutElement( psa, (long FAR *)&nIdx, &vTyped );

         VariantClear( &vTyped );
         VariantClear( &vTemp );
         ASSERT( SUCCEEDED( hResult ) );
      }

      V_VT( &varRes )     = VT_VARIANT | VT_ARRAY;
      V_ARRAY( &varRes )  = psa;
   }
   else {
	  hResult = E_OUTOFMEMORY ;
   } ;

   delete [] strText;

   //return SUCCEEDED( hResult );
   return hResult ;

}


/***********************************************************
  Function: FromVariantArrayToString
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  FromVariantArrayToString( VARIANT& v, TCHAR* pszSeparator )
{
   SAFEARRAY*  pSafeArray;
   TCHAR       szText[ 2048 ];
   VARIANT     var, varString;
   long        lBound, uBound, lItem;
   HRESULT     hResult;
   BOOL        bFirst;
   CString     strResult;


   // array of VT_UI1 (probably OctetString)
   if( (VT_ARRAY | VT_UI1) == V_VT( &v ) )
   {
      BYTE        bValue;

      pSafeArray  = V_ARRAY( &v );

      hResult     = SafeArrayGetLBound(pSafeArray, 1, &lBound);
      hResult     = SafeArrayGetUBound(pSafeArray, 1, &uBound);

      szText[ 0 ]    = _T('\0');

      for( lItem = lBound; lItem <= uBound ; lItem++ )
      {
         hResult  = SafeArrayGetElement( pSafeArray, &lItem, &bValue );
         if( FAILED( hResult ) )
         {
            break;
         }

         _stprintf( szText + _tcslen(szText), _T(" x%02x"), bValue );
         if( _tcslen( szText ) > 2044 )
            break;
      }

      return CString( szText );
   }

   if( V_VT( &v ) != (VT_VARIANT | VT_ARRAY) )
   {
      VARIANT  vString;

      TRACE( _T("Warning: Non array variant!!!\n") );
      VariantInit( &vString );

      hResult  = VariantChangeType( &vString, &v, VARIANT_NOVALUEPROP, VT_BSTR );
      if( FAILED( hResult ) )
      {
         V_VT( &vString )     = VT_BSTR;
         V_BSTR( &vString )   = AllocBSTR( _T("ERROR on conversion") );
      }
      _tcscpy( szText, _T("") );
      StringCat( szText, V_BSTR(&vString) );
      VariantClear( &vString);

      return CString( szText );
   }

   pSafeArray   = V_ARRAY( &v );

   hResult = SafeArrayGetLBound(pSafeArray, 1, &lBound);
   hResult = SafeArrayGetUBound(pSafeArray, 1, &uBound);

   VariantInit( &varString );
   szText[ 0 ]    = _T('\0');
   bFirst         = TRUE;

   for( lItem = lBound; lItem <= uBound ; lItem++ )
   {
      hResult  = SafeArrayGetElement( pSafeArray, &lItem, &var );
      if( FAILED( hResult ) )
      {
         break;
      }

      if( ConvertFromPropertyValue( var, szText ) )
      {
         V_VT( &varString )   = VT_BSTR;
         V_BSTR( &varString ) = AllocBSTR( szText );
         hResult  = S_OK;
      }
      else
      {
         hResult  = VariantChangeType( &varString, &var,
                                       VARIANT_NOVALUEPROP, VT_BSTR );
      }

      if( SUCCEEDED( hResult ) )
      {
         _tcscpy( szText, _T("") );
         if( !bFirst )
         {
            if( NULL == pszSeparator )
            {
               _tcscat( szText, SEPARATOR_S );
            }
            else
            {
               _tcscat( szText, pszSeparator );
            }
         }

         StringCat( szText, V_BSTR( &varString ) );

         bFirst   = FALSE;
         VariantClear( &varString );

         strResult  += szText;
      }

      VariantClear( &var );
   }

   return strResult;
}



/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
CString  FromVariantToString( VARIANT& v)
{
   return FromVariantArrayToString( v );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
COleDsObject*  CreateOleDsObject( DWORD  dwType, IUnknown* pIUnk )
{
   COleDsObject*  pObject;

   switch( dwType )
   {
      case  DOMAIN:
         pObject  = new COleDsDomain( pIUnk );
         break;

      case  COMPUTER:
         pObject  = new COleDsComputer( pIUnk );
         break;

      case  USER:
         pObject  = new COleDsUser( pIUnk );
         break;

      case  GROUP:
         pObject  = new COleDsGroup( pIUnk );
         break;

      case  SERVICE:
         pObject  = new COleDsService( pIUnk );
         break;

      case  FILESERVICE:
         pObject  = new COleDsFileService( pIUnk );
         break;

      case  PRINTQUEUE:
         pObject  = new COleDsPrintQueue( pIUnk );
         break;

      case  PRINTJOB:
         pObject  = new COleDsPrintJob( pIUnk );
         break;

      case  PRINTDEVICE:
         pObject  = new COleDsPrintDevice( pIUnk );
         break;

      case  SESSION:
         pObject  = new COleDsSession( pIUnk );
         break;

      case  FILESHARE:
         pObject  = new COleDsFileShare( pIUnk );
         break;

      case  RESOURCE:
         pObject  = new COleDsResource( pIUnk );
         break;

      case  NAMESPACE:
         pObject  = new COleDsNamespace( pIUnk );
         break;

      case  NAMESPACES:
         pObject  = new COleDsNamespaces( pIUnk );
         break;
      case  NDSROOT:
      case  NDSORG:
      case  NDSOU:
      case  PRINTER:
      case  NDSALIAS:
      case  NDSDIRECTORYMAP:
      case  NDSDISTRIBUTIONLIST:
      case  NDSAFPSERVER:
      case  NDSCOMMUNICATIONSSERVER:
      case  NDSMESSAGEROUTINGGROUP:
      case  NDSNETWARESERVER:
      case  NDSORGANIZATIONALROLE:
      case  NDSPRINTQUEUE:
      case  NDSPRINTSERVER:
      case  NDSPROFILE:
      case  NDSVOLUME:
      case  OTHER:
      case  CLASS:
      case  SCHEMA:
      case  PROPERTY:
      case  SYNTAX:
         pObject  = new COleDsGeneric( pIUnk );
         break;

      default:
         ASSERT( FALSE );
         pObject  = new COleDsObject( pIUnk );
         break;

   }

   return pObject;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
void  ErrorOnPutProperty( CString& strFuncSet,
						        CString& strProperty,
                          CString& strPropValue,
                          HRESULT  hResult,
                          BOOL     bGeneric,
                          BOOL     bUseEx )
{
   CErrorDialog   aErrorDialog;
   CString        strOperation;

   if( !bGeneric )
   {
      strOperation   = _T("put_");
      strOperation  += strProperty;
   }
   else
   {
      strOperation   = _T("Put");
      if( bUseEx )
      {
         strOperation  += _T("Ex");
      }
      strOperation  += _T("( ");
      strOperation  += strProperty;
      strOperation  += _T(", ...)");
   }


   //aErrorDialog.m_FuncSet  = strFuncSet;
   aErrorDialog.m_Operation   = strOperation;
   aErrorDialog.m_Value       = strPropValue;
   aErrorDialog.m_Result      = OleDsGetErrorText( hResult );

   aErrorDialog.DoModal( );
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CheckIfValidClassName( WCHAR* lpszClassName )
{
   TCHAR szClassName[ 512 ];
   BSTR bszClassName = NULL ;

   if( !lpszClassName )
   {
      TRACE( _T("Oops! Found NULL class name: %s\n"), lpszClassName );
      return TRUE;
   }

   if( !_wcsicmp( lpszClassName, L"Namespace") )
      return TRUE;

   if( !_wcsicmp( lpszClassName, L"Namespaces") )
      return TRUE;

   if( !_wcsicmp( lpszClassName, L"User") )
      return TRUE;

   if( !_wcsicmp( lpszClassName, L"Group") )
      return TRUE;

   if( !_wcsicmp( lpszClassName, L"Domain") )
      return TRUE;

   if( !_wcsicmp( lpszClassName, L"Computer") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"Service") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"FileService") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"Printqueue") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"Printjob") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"PrintDevice") )
      return  TRUE;

   if( !_wcsicmp( lpszClassName, L"Session") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Resource") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"FileShare") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Tree") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Organization") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Organizational Unit") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"OrganizationalUnit") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Printer") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Class") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Property") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Syntax") )
      return   TRUE;

   if( !_wcsicmp( lpszClassName, L"Schema") )
      return   TRUE;

   _tcscpy( szClassName, _T("") );
   bszClassName = ::SysAllocString( lpszClassName ) ;
   StringCat( szClassName, bszClassName );
   if ( bszClassName ) {
	   ::SysFreeString( bszClassName ) ;
   }

   TRACE( _T("Oops! Found unknown class name: %s\n"), szClassName );

   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BOOL  CheckIfValidClassName( CHAR* pszClassName )
{
   int      nLength;
   WCHAR*   pszwClassName;
   BOOL     bRez = FALSE ;

   nLength        = strlen( pszClassName );

   pszwClassName  = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   if ( pszwClassName ) {
	   memset( pszwClassName, 0, ( nLength + 1 ) * sizeof(WCHAR) );

       MultiByteToWideChar( CP_ACP,
                            MB_PRECOMPOSED,
                            pszClassName,
                            nLength,
                            pszwClassName,
                            nLength + 1 );

       bRez  = CheckIfValidClassName( pszwClassName );

       free( pszwClassName );
   }

   return bRez;


   return TRUE;
}


/***********************************************************
  Function:
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
int   GetImageListIndex( DWORD dwObjectType )
{
   int   nIndex;

   nIndex   = 0;
   dwObjectType   = dwObjectType >> 1;
   while( dwObjectType )
   {
      nIndex++;
      dwObjectType   = dwObjectType >> 1;
   }

   return nIndex;
}


/***********************************************************
  Function:    GetBitmapImageId
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
UINT  GetBitmapImageId( DWORD dwObjectType )
{
   switch( dwObjectType )
   {
      case  USER:
         return IDB_USER;

      case  SERVICE:
         return IDB_SERVICE;

      case  DOMAIN:
         return IDB_DOMAIN;

      case  COMPUTER:
         return IDB_COMPUTER;

      case  PRINTQUEUE:
      case  PRINTER:
         return IDB_PRINTQUEUE;

      case  FILESHARE:
         return IDB_FILESHARE;

      case  GROUP:
         return IDB_GROUP;

      case  SESSION:
         return IDB_SESSION;

      case  RESOURCE:
         return IDB_RESOURCE;

      case  PRINTJOB:
         return IDB_PRINTJOB;

      case  NDSROOT:
         return IDB_ROOT;

      case  NDSORG:
         return IDB_ORGANISATION;

      case  NDSOU:
         return IDB_ORGANISATIONUNIT;

      case  NAMESPACES:
         return IDB_NAMESPACES;

      case  NAMESPACE:
         return IDB_NAMESPACE;

      case  NDSALIAS:
         return IDB_NDS_ALIAS;

      case  NDSDIRECTORYMAP:
         return IDB_NDS_DIRECTORY_MAP;

      case  NDSDISTRIBUTIONLIST:
         return IDB_NDS_DISTRIBUTION_LIST;

      case  NDSAFPSERVER:
         return IDB_NDS_AFP_SERVER;

      case  NDSCOMMUNICATIONSSERVER:
         return IDB_NDS_COMMUNICATIONS_SERVER;

      case  NDSMESSAGEROUTINGGROUP:
         return IDB_NDS_MESSAGE_ROUTING_GROUP;

      case  NDSNETWARESERVER:
         return IDB_NDS_NETWARE_SERVER;

      case  NDSORGANIZATIONALROLE:
         return IDB_NDS_ORGANIZATIONAL_ROLE;

      case  NDSPRINTQUEUE:
         return IDB_NDS_PRINT_QUEUE;

      case  NDSPRINTSERVER:
         return IDB_NDS_PRINT_SERVER;

      case  NDSPROFILE:
         return IDB_NDS_PROFILE;

      case  NDSVOLUME:
         return IDB_NDS_VOLUME;

      case  SYNTAX:
         return IDB_SYNTAX;

      case  PROPERTY:
         return IDB_PROPERTY;

      case  CLASS:
      case  SCHEMA:
         return IDB_CLASS;

      default:
         return IDB_DUMMY;
   }
}


/***********************************************************
  Function:    AllocBSTR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BSTR  AllocBSTR( WCHAR* pszwString )
{
   return SysAllocString( pszwString );
}


/***********************************************************
  Function:    AllocBSTR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
***********************************************************/
BSTR  AllocBSTR( CHAR* pszString )
{
   int      nLength;
   WCHAR*   pszwString;
   BSTR     bstrText;

   nLength     = strlen( pszString );

   pszwString  = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );

   if ( pszwString ) {
       memset( pszwString, 0, ( nLength + 1 ) * sizeof(WCHAR) );

       MultiByteToWideChar( CP_ACP,
                            MB_PRECOMPOSED,
                            pszString,
                            nLength,
                            pszwString,
                            nLength + 1 );
   }
   bstrText    = AllocBSTR( pszwString );
   if ( pszwString ) {
       free( pszwString );
   }

   return bstrText;
}


/*******************************************************************
  Function:    Get
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  Get( IADs* pIOleDs, CHAR* pszProperty, VARIANT* pVar)
{
   int      nLength;
   WCHAR*   pszwProperty;
   HRESULT  hResult;

   nLength        = strlen( pszProperty );

   pszwProperty   = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   if ( pszwProperty ) {
       memset( pszwProperty, 0, ( nLength + 1 ) * sizeof(WCHAR) );

       MultiByteToWideChar( CP_ACP,
                            MB_PRECOMPOSED,
                            pszProperty,
                            nLength,
                            pszwProperty,
                            nLength + 1 );

       hResult  = Get( pIOleDs, pszwProperty, pVar );
       free( pszwProperty );
   }
   else {
	   hResult = E_OUTOFMEMORY ;
   }

   return hResult;
}


/*******************************************************************
  Function:    Get
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  Get( IADs* pIOleDs, WCHAR* pszwProperty, VARIANT* pVar)
{
   HRESULT  hResult;
   BSTR bszProperty = ::SysAllocString( pszwProperty ) ;

   VariantInit( pVar );

   hResult  = pIOleDs->Get( bszProperty, pVar );
   if ( bszProperty ) {
	   ::SysFreeString( bszProperty ) ;
   }

   return hResult;
}


/*******************************************************************
  Function:    Put
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  Put( IADs* pIOleDs, CHAR* pszProperty, VARIANT Var)
{
   int      nLength;
   WCHAR*   pszwProperty;
   HRESULT  hResult;

   nLength        = strlen( pszProperty );

   pszwProperty   = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   if ( pszwProperty ) {
       memset( pszwProperty, 0, ( nLength + 1 ) * sizeof(WCHAR) );

       MultiByteToWideChar( CP_ACP,
                            MB_PRECOMPOSED,
                            pszProperty,
                            nLength,
                            pszwProperty,
                            nLength + 1 );

       hResult  = Put( pIOleDs, pszwProperty, Var ) ;
       free( pszwProperty );
   }
   else {
	   hResult = E_OUTOFMEMORY ;
   } ;

   return hResult;
}


/*******************************************************************
  Function:    Put
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  Put( IADs* pIOleDs, WCHAR* pszwProperty, VARIANT Var)
{
   HRESULT  hResult;
   BSTR bszProperty = ::SysAllocString( pszwProperty ) ;
   hResult  = pIOleDs->Put( bszProperty, Var );
   if ( bszProperty ) {
	   ::SysFreeString( bszProperty ) ;
   }

   return hResult;
}


/*******************************************************************
  Function:    XGetOleDsObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  XOleDsGetObject( WCHAR* pszwPath, REFIID refiid, void** pVoid )
{
   // cahged to add the hack for Win95.
   HRESULT  hResult;

   hResult  = ADsGetObject( pszwPath, refiid, pVoid );
   if( FAILED( hResult ) )
   {
      // now's the hack.
      // Danilo says take OLE DS paths and prepent a "@"
      // to and change the first ":" into a "!"
      WCHAR szHackPath[ 256 ];

      // first, add @
      wcscpy( szHackPath, L"@" );
      wcscat( szHackPath, pszwPath );

      // second, change the first ":" into a "!"
      for( UINT nIdx = 0 ; nIdx < wcslen( szHackPath ); nIdx++ )
      {
         if( szHackPath[ nIdx ] == L':' )
         {
            szHackPath[ nIdx ] = L'!';
            break;
         }
      }

      hResult  = ADsGetObject( szHackPath, refiid, pVoid );
   }

   return hResult;
}


/*******************************************************************
  Function:    XGetOleDsObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  XOleDsGetObject( CHAR* pszPath, REFIID refiid, void** pVoid )
{
   int      nLength;
   WCHAR*   pszwPath;
   HRESULT  hResult;

   nLength  = strlen( pszPath );

   pszwPath = (WCHAR*) malloc( ( nLength + 1 ) * sizeof(WCHAR) );
   if ( pszwPath ) {
       memset( pszwPath, 0, ( nLength + 1 ) * sizeof(WCHAR) );

       MultiByteToWideChar( CP_ACP,
                            MB_PRECOMPOSED,
                            pszPath,
                            nLength,
                            pszwPath,
                            nLength + 1 );

       hResult  = XOleDsGetObject( pszwPath, refiid, pVoid );
       free( pszwPath );
   }
   else {
	   hResult = E_OUTOFMEMORY ;
   }

   return hResult;
}


/*******************************************************************
  Function:    XOleDsOpenObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  XOleDsOpenObject( WCHAR* lpszPathName,
                           WCHAR* lpszUserName,
                           WCHAR* lpszPassword,
                           REFIID refiid,
                           void** pVoid )
{
   HRESULT  hResult;

   hResult  = ADsOpenObject(
                             lpszPathName,
                             lpszUserName,
                             lpszPassword,
                             NULL,
                             refiid,
                             pVoid );
   if( FAILED( hResult ) )
   {
      // now's the hack.
      // Danilo says take OLE DS paths and prepent a "@"
      // to and change the first ":" into a "!"
      WCHAR szHackPath[ 256 ];

      // first, add @
      wcscpy( szHackPath, L"@" );
      wcscat( szHackPath, lpszPathName );

      // second, change the first ":" into a "!"
      for( UINT nIdx = 0 ; nIdx < wcslen( szHackPath ); nIdx++ )
      {
         if( szHackPath[ nIdx ] == L':' )
         {
            szHackPath[ nIdx ] = L'!';
            break;
         }
      }
      hResult  = ADsOpenObject( szHackPath,
                                lpszUserName,
                                lpszPassword,
                                NULL,
                                refiid,
                                pVoid );
   }

   return hResult;
}


/*******************************************************************
  Function:    XOleDsOpenObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  XOleDsOpenObject( CHAR* lpszPathName,
                           CHAR* lpszUserName,
                           CHAR* lpszPassword,
                           REFIID refiid,
                           void** pVoid )
{
   BSTR     bstrPathName, bstrUserName, bstrPassword;
   HRESULT  hResult;

   bstrPathName   = AllocBSTR( lpszPathName );
   bstrUserName   = AllocBSTR( lpszUserName );
   bstrPassword   = AllocBSTR( lpszPassword );

   hResult  = XOleDsOpenObject( bstrPathName, bstrUserName, bstrPassword,
                                refiid, pVoid );

   SysFreeString( bstrPathName );
   SysFreeString( bstrUserName );
   SysFreeString( bstrPassword );

   return hResult;
}



/*******************************************************************
  Function:    StringCat
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
void  StringCat( WCHAR* pszString, BSTR bstrText )
{
   wcscat( pszString, bstrText );
}


/*******************************************************************
  Function:    StringCat
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
void  StringCat( CHAR* pszString, BSTR bstrText )
{
   CHAR* pszText;
   UINT  nLength;
   CHAR  defChar  = ' ';
   BOOL  bUseDefault;
   int   nRez;
   DWORD dwError;

   nLength  = SysStringLen( bstrText );
   pszText  = (CHAR*) malloc( (nLength + 1) * sizeof(CHAR) );
   if ( pszText ) {
       memset( pszText, 0, (nLength + 1) * sizeof(CHAR) );

	   nRez  = WideCharToMultiByte( CP_ACP,
                                    0L,
                                    bstrText,
                                    nLength,
                                    pszText,
                                    nLength + 1,
                                    &defChar,
                                    &bUseDefault );
       if( !nRez )
       {
          dwError  = GetLastError( );
       }

       strcat( pszString, pszText );
   }

   free( pszText );
}


/*******************************************************************
  Function:    XGetOleDsObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
void  SetLastProfileString( TCHAR* szSection, CString& rValue )
{
   WritePrivateProfileString( _T("LastParameters"), szSection,
                              rValue.GetBuffer( 256 ), _T("adsvw.ini") );
}


/*******************************************************************
  Function:    SetLastProfileString
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
void  GetLastProfileString( TCHAR* szSection, CString& rValue )
{
   TCHAR szValue[ 256 ];

   GetPrivateProfileString( _T("LastParameters"), szSection,
                            _T(""), szValue, 255, _T("adsvw.ini") );

   rValue   = szValue;
}


/*******************************************************************
  Function:    GetByteValue
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
BYTE  GetByteValue( TCHAR* szString )
{
   BYTE  bBytes[ 2 ];

   bBytes[ 0 ] = bBytes[ 1 ]  = 0;

   for( int i = 0; i < 2 ; i++ )
   {
      if( !szString[ i ] )
         break;

#ifdef UNICODE
      if( !iswdigit( szString[ i ] ) )
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x37;
      }
#else
      if( !isdigit( szString[ i ] ) )
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x37;
      }
#endif
      else
      {
         bBytes[ i ] = ( (BYTE) ( szString[ i ] ) ) - 0x30;
      }
   }

   return ( bBytes[ 0 ] << 4 ) + bBytes[ 1 ];
}

/*******************************************************************
  Function:    CreateBlobArray
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  CreateBlobArrayFromFile( CString& rText, VARIANT& rBlob )
{
   TCHAR*         pszFileName;
   TCHAR          pszTemp[ 2 * MAX_PATH ];
   CFile          aFile;
   CFileException e;

   rText.TrimLeft( );

   _tcscpy( pszTemp, (LPCTSTR)rText );
   pszFileName = pszTemp;

   pszFileName   += _tcslen( _T("[FILE]") );
   while( *pszFileName == _T(' ') )
      pszFileName++;

   if( !aFile.Open( pszFileName, CFile::modeRead, &e ) )
   {

#ifdef _DEBUG
      afxDump << "File could not be opened " << e.m_cause << "\n";
#endif
   }
   else
   {
      SAFEARRAY*     psa;
      SAFEARRAYBOUND sab;
      LONG           lItem;
      DWORD          dwIdx;
      DWORD          dwRead;
      HRESULT        hResult;
      BYTE           bBuffer[ 128 ];

      sab.cElements  = (ULONG)(aFile.GetLength( ));
      sab.lLbound    = LBOUND;
      psa            = SafeArrayCreate( VT_UI1, 1, &sab );
      lItem          = LBOUND;

      while( TRUE )
      {
         dwRead   = aFile.Read( (LPVOID)bBuffer, 128 );

         for( dwIdx = 0; dwIdx < dwRead ; dwIdx++ )
         {
            hResult  = SafeArrayPutElement( psa, &lItem, bBuffer + dwIdx );
            ASSERT( SUCCEEDED( hResult ) );
         }
         if( dwRead != 128 )
            break;
      }

      V_VT( &rBlob )     = VT_UI1 | VT_ARRAY;
      V_ARRAY( &rBlob )  = psa;

      aFile.Close( );
   }

   return S_OK;
}


/*******************************************************************
  Function:    CreateBlobArray
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  CreateBlobArray( CString& rText, VARIANT& rBlob )
{
   SAFEARRAY*     psa;
   SAFEARRAYBOUND sab;
   TCHAR*         strText;
   int            nItems   = 0;
   int            nIdx;
   int            nSize;
   HRESULT        hResult;
   BYTE           bVal;

   rText.MakeUpper( );
   rText.TrimLeft( );

   if( !_tcsnicmp( (LPCTSTR)rText,
                   _T("[FILE]"),
                   min( (int)rText.GetLength( ), (int)_tcslen( _T("[FILE]") ) )
                 )
     )
   {
      hResult  = CreateBlobArrayFromFile( rText, rBlob );
      return hResult;
   }

   strText  = (TCHAR*) new TCHAR[ rText.GetLength( ) + 1 ];
   if( !strText )
   {
      return E_FAIL;
   }

   _tcscpy( strText, rText.GetBuffer( rText.GetLength( ) ) );
   nSize    = rText.GetLength( );
   nItems   = 0;
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      if( strText[ nIdx ] == _T('X') )
      {
         nItems++;
      }
   }

   sab.cElements   = nItems;
   sab.lLbound     = LBOUND;
   psa             = SafeArrayCreate( VT_UI1, 1, &sab );
   ASSERT( NULL != psa );
   if ( psa )
   {
      nItems = 0;

      for( nIdx = LBOUND; nIdx < ( LBOUND + nSize ); nIdx++ )
      {
         if( strText[ nIdx ] == _T('X') )
         {
            bVal  = GetByteValue( strText + nIdx + 1 );
            hResult  = SafeArrayPutElement( psa, (long FAR *)&nItems, &bVal );
            nIdx += 3;
            nItems++;
         }
      }
      V_VT( &rBlob )     = VT_UI1 | VT_ARRAY;
      V_ARRAY( &rBlob )  = psa;
   }

   delete [] strText;

   return hResult;
}


/*******************************************************************
  Function:    CreateBlobArrayEx
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
*******************************************************************/
HRESULT  CreateBlobArrayEx( CString& rText, VARIANT& rBlob, TCHAR cSeparator )
{
   SAFEARRAY*     psa;
   SAFEARRAYBOUND sab;
   TCHAR*         strText;
   TCHAR*         strStore;
   int            nItems   = 0;
   int            nIdx;
   int            nSize;
   HRESULT        hResult;

   rText.MakeUpper( );

   strText  = (TCHAR*) new TCHAR[ rText.GetLength( ) + 1 ];
   strStore = strText;
   if( !strText )
   {
      return E_FAIL;
   }

   _tcscpy( strText, rText.GetBuffer( rText.GetLength( ) ) );
   nSize    = rText.GetLength( );
   nItems   = 1;
   for( nIdx = 0; nIdx < nSize ; nIdx++ )
   {
      if( strText[ nIdx ] == cSeparator )
      {
         strText[ nIdx ]   = _T('\0');
         nItems++;
      }
   }

   sab.cElements   = nItems;
   sab.lLbound     = LBOUND;
   psa             = SafeArrayCreate( VT_VARIANT, 1, &sab );
   ASSERT( NULL != psa );
   if ( psa )
   {
      for( nIdx = LBOUND; nIdx < ( LBOUND + nItems ) ; nIdx++ )
      {
         VARIANT  var;
         CString  strTemp;

         strTemp  = strText;
         strText += _tcslen( strText ) + 1;

         CreateBlobArray( strTemp, var );
         hResult  = SafeArrayPutElement( psa, (long FAR *)&nIdx, &var );
         VariantClear( &var );
      }

      V_VT( &rBlob )     = VT_VARIANT | VT_ARRAY;
      V_ARRAY( &rBlob )  = psa;
   }
   else {
	   hResult = E_OUTOFMEMORY ;
   }

   delete [] strStore;

   return hResult;
}


/******************************************************************************
  Function:    Convert
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
void  Convert( CHAR* pszDest, WCHAR* pszwSrc )
{
   int   nRes  = 0;

   if( wcslen( pszwSrc ) )
   {
      nRes  = WideCharToMultiByte( CP_ACP,
                                   WC_COMPOSITECHECK,
                                   pszwSrc,
                                   wcslen( pszwSrc ),
                                   pszDest,
                                   wcslen( pszwSrc ) + 1,
                                   NULL,
                                   NULL );
      ASSERT( nRes );
   }

   pszDest[ nRes ]	= '\0';

}


/******************************************************************************
  Function:    Convert
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
void  Convert  ( WCHAR* pszwDest, CHAR* pszSrc )
{
   BSTR  bstrTemp;

   bstrTemp = AllocBSTR( pszSrc );
   wcscpy( pszwDest, bstrTemp );
   SysFreeString( bstrTemp );
}


/******************************************************************************
  Function:    Convert
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
void  Convert  ( WCHAR* pszwDest, WCHAR* pszwSrc )
{
   wcscpy( pszwDest, pszwSrc );
}


/******************************************************************************
  Function:    Convert
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
void  Convert( CHAR* pszDest, CHAR* pszSrc )
{
   strcpy( pszDest, pszSrc );
}


/******************************************************************************
  Function:    StringToLARGE_INTEGER
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT     StringToLARGE_INTEGER( TCHAR* szString, LARGE_INTEGER* pValue )
{
	if ( 0 == _stscanf( szString, _T("%I64d"), pValue ) ) {
		pValue = NULL ;
	}

   return S_OK;

   HRESULT  hResult;
   VARIANT  vString, vR8;
   double   dLowPart, dHighPart;
   ULONG    ulLowPart, ulHighPart;
   WCHAR    szValue[ 32 ];

   VariantInit( &vString );
   VariantInit( &vR8 );

   V_VT( &vString )   = VT_BSTR;
   Convert( szValue, szString );
   V_BSTR( &vString ) = szValue;

   hResult  = VariantChangeType( &vR8, &vString, VARIANT_NOVALUEPROP, VT_R8 );
   if( SUCCEEDED( hResult ) )
   {
      dHighPart   = V_R8( &vR8 ) / ((double) 1.0 + (double)(ULONG_MAX));
      ulHighPart  = (ULONG)dHighPart;
      dHighPart   = (double)ulHighPart;
      dLowPart    = V_R8( &vR8 ) - dHighPart*((double) 1.0 + (double)(ULONG_MAX));
      ulLowPart   = (ULONG)dLowPart;

      pValue->HighPart= (LONG)ulHighPart;
      pValue->LowPart = ulHighPart;
   }

   return hResult;
}


/******************************************************************************
  Function:    StringToLARGE_INTEGER
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT     LARGE_INTEGERToString( TCHAR* szString,
                                   LARGE_INTEGER* pValue )
{
   if ( pValue ) {
	   _stprintf( szString, _T("%I64d"), pValue->QuadPart );
   }
   return S_OK;

   /*TCHAR    szText[ 32 ];
   DWORD    dwStatus;
   BOOL     bOK   = FALSE;

   HMODULE  hModule;

   while( TRUE )
   {
      hModule  = LoadLibrary( _T("NTDLL.DLL" ) );
      if( NULL == hModule )
         break;

      LargeIntegerToString = (LARGEINTTOSTRING)GetProcAddress( hModule, _T("RtlLargeIntegerToChar") );
      if( NULL == LargeIntegerToString )
         break;

      dwStatus = LargeIntegerToString( pValue, 10, 31, szText );
      if( 0 == dwStatus )
      {
         Convert( szString, szText );
         bOK   = TRUE;
      }

      break;
   }

   if( NULL != hModule )
   {
      FreeLibrary( hModule );
   }

   if( bOK )
   {
      return S_OK;
   }


   HRESULT  hResult;
   double   dVal;
   VARIANT  vString, vR8;

   dVal  = (double)pValue->HighPart;
   dVal  = dVal * ( (double) 1.0 + (double)(ULONG_MAX) );

   dVal  = dVal + (double)pValue->LowPart;


   VariantInit( &vString );
   VariantInit( &vR8 );

   V_VT( &vR8 )   = VT_R8;
   V_R8( &vR8 )   = dVal;

   hResult  = VariantChangeType( &vString, &vR8, VARIANT_NOVALUEPROP, VT_BSTR );
   ASSERT( SUCCEEDED( hResult ) );

   if( SUCCEEDED( hResult ) )
   {

      Convert( szString, V_BSTR( &vString ) );
      VariantClear( &vString );
   }

   return hResult;*/
}


/******************************************************************************
  Function:    CopyACE
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
IDispatch*  CopyACE( IDispatch*  pSrc )
{
   IADsAccessControlEntry* pACE;
   IADsAccessControlEntry* pSrcACE;
   IDispatch*              pNewACE  = NULL;
   HRESULT                 hResult;
   LONG                    lValue;
   BSTR                    bstrValue   = NULL;

   hResult  = pSrc->QueryInterface( IID_IADsAccessControlEntry, (void**)&pSrcACE );

   if( FAILED( hResult ) )
      return NULL;


   hResult = CoCreateInstance(
                               CLSID_AccessControlEntry,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IADsAccessControlEntry,
                               (void **)&pACE );
   if( SUCCEEDED( hResult ) )
   {
      //******************************************
      hResult  = pSrcACE->get_AccessMask( &lValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_AccessMask( lValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_AccessMask returns %lx\n"), hResult );
         }
      }

      //******************************************
      hResult  = pSrcACE->get_AceType( &lValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_AceType( lValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_AceType returns %lx\n"), hResult );
         }
      }

      //******************************************
      hResult  = pSrcACE->get_AceFlags( &lValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_AceFlags( lValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_AceFlags returns %lx\n"), hResult );
         }
      }

      //******************************************
      hResult  = pSrcACE->get_Flags( &lValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_Flags( lValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_Flags returns %lx\n"), hResult );
         }
      }

      //******************************************
      hResult  = pSrcACE->get_ObjectType( &bstrValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_ObjectType( bstrValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_ObjectType returns %lx\n"), hResult );
         }
         SysFreeString( bstrValue );
         bstrValue   = NULL;

      }

      //******************************************
      hResult  = pSrcACE->get_InheritedObjectType( &bstrValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_InheritedObjectType( bstrValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_InheritedObjectType returns %lx\n"), hResult );
         }
         SysFreeString( bstrValue );
         bstrValue   = NULL;
      }


      //******************************************
      hResult  = pSrcACE->get_Trustee( &bstrValue );
      ASSERT( SUCCEEDED( hResult ) );

      if( SUCCEEDED( hResult ) )
      {
         hResult  = pACE->put_Trustee( bstrValue );
         if( FAILED( hResult ) )
         {
            TRACE( _T("[ADSI] Error: put_Trustee returns %lx\n"), hResult );
         }
         SysFreeString( bstrValue );
         bstrValue   = NULL;
      }
      hResult  = pACE->QueryInterface( IID_IDispatch, (void**)&pNewACE );
      pACE->Release( );

   }

   pSrcACE->Release( );

   return pNewACE;
}


/******************************************************************************
  Function:    CopyACL
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
IDispatch*  CopyACL( IDispatch*  pSrcACL )
{
   IADsAccessControlList*  pACL        = NULL;
   IADsAccessControlList*  pADsNewACL  = NULL;
   IDispatch*              pNewACL     = NULL;
   IUnknown*               pEnum       = NULL;
   IEnumVARIANT*           pEnumVAR    = NULL;
   HRESULT                 hResult;
   LONG                    lValue;
   ULONG                   lGet;
   VARIANT                 var;

   hResult  = pSrcACL->QueryInterface( IID_IADsAccessControlList, (void**)&pACL );

   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      hResult  = pACL->CopyAccessList( &pNewACL );
      if( FAILED( hResult ) )
      {
         TRACE( _T("[ADSI] Error: CopyAccessList returns %lx\n"), hResult );
      }

      if( SUCCEEDED( hResult ) )
         break;

      hResult  = CoCreateInstance(
                                   CLSID_AccessControlList,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IADsAccessControlList,
                                   (void **)&pADsNewACL );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pACL->get_AclRevision( &lValue );
      if( SUCCEEDED( hResult ) )
      {
         hResult  = pADsNewACL->put_AclRevision( lValue );
         ASSERT( SUCCEEDED( hResult ) );
      }

      hResult  = pACL->get__NewEnum( &pEnum );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      hResult  = pEnum->QueryInterface( IID_IEnumVARIANT, (void**)&pEnumVAR );
      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
         break;

      while( TRUE )
      {
         lGet  = 0;
         VariantInit( &var );

         hResult  = pEnumVAR->Next( 1, &var,  &lGet );
         if( 0 == lGet )
            break;

         hResult  = pADsNewACL->AddAce( CopyACE( V_DISPATCH( &var ) ) );
         VariantClear( &var );
      }

      hResult  = pADsNewACL->QueryInterface( IID_IDispatch, (void**)& pNewACL );
      break;
   }

   if( NULL != pACL )
      pACL->Release( );

   if( NULL != pADsNewACL )
      pADsNewACL->Release( );

   if( NULL != pEnum )
      pEnum->Release( );

   if( NULL != pEnumVAR )
      pEnumVAR->Release( );

   return pNewACL;
}


/******************************************************************************
  Function:    CopySD
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
IDispatch*  CopySD( IDispatch*  pSrcSD )
{
   IADsSecurityDescriptor* pSD;
   IDispatch*              pNewSD  = NULL;
   IADsSecurityDescriptor* pADsNewSD  = NULL;
   HRESULT                 hResult;
   LONG                    lValue;
   BSTR                    bstrValue;
   IDispatch*              pACL;

   //hResult  = pSrcSD->QueryInterface( IID_IDispatch, (void**)&pNewSD );

   //return pNewSD;

   hResult  = pSrcSD->QueryInterface( IID_IADsSecurityDescriptor, (void**)&pSD );

   while( TRUE )
   {
      if( FAILED( hResult ) )
         break;

      hResult  = pSD->CopySecurityDescriptor( &pNewSD );
      if( FAILED( hResult ) )
      {
         TRACE( _T("[ADSI] Error: CopySecurityDescriptor returns %lx\n"), hResult );
      }

      if( SUCCEEDED( hResult ) )
      {
         pSD->Release( );
         break;
      }

      hResult  = CoCreateInstance(
                                   CLSID_SecurityDescriptor,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IADsSecurityDescriptor,
                                   (void **)&pADsNewSD );

      ASSERT( SUCCEEDED( hResult ) );

      if( FAILED( hResult ) )
         break;

      hResult  = pSD->get_Revision( &lValue );
      if( SUCCEEDED( hResult ) )
      {
         hResult  = pADsNewSD->put_Revision( lValue );
         ASSERT( SUCCEEDED( hResult ) );
      }

      hResult  = pSD->get_Control( &lValue );
      if( SUCCEEDED( hResult ) )
      {
         hResult  = pADsNewSD->put_Control( lValue );
         ASSERT( SUCCEEDED( hResult ) );
      }

      hResult  = pSD->get_Owner( &bstrValue );
      if( SUCCEEDED( hResult ) )
      {
         hResult  = pADsNewSD->put_Owner( bstrValue );
         ASSERT( SUCCEEDED( hResult ) );
         SysFreeString( bstrValue );
      }

      hResult  = pSD->get_Group( &bstrValue );
      if( SUCCEEDED( hResult ) )
      {
         hResult  = pADsNewSD->put_Group( bstrValue );
         ASSERT( SUCCEEDED( hResult ) );
         SysFreeString( bstrValue );
      }

      hResult  = pSD->get_DiscretionaryAcl( &pACL );
      if( SUCCEEDED( hResult ) && NULL != pACL )
      {
         IDispatch*  pCopy;

         pCopy = CopyACL( pACL );
         if( NULL != pCopy )
         {
            hResult  = pADsNewSD->put_DiscretionaryAcl( pCopy );
            ASSERT( SUCCEEDED( hResult ) );
            pCopy->Release( );
         }
         pACL->Release( );
      }

      hResult  = pSD->get_SystemAcl( &pACL );
      if( SUCCEEDED( hResult ) && NULL != pACL )
      {
         IDispatch*  pCopy;

         pCopy = CopyACL( pACL );
         if( NULL != pCopy )
         {
            hResult  = pADsNewSD->put_SystemAcl( pCopy );
            ASSERT( SUCCEEDED( hResult ) );
            pCopy->Release( );
         }
         pACL->Release( );
      }

      hResult  = pADsNewSD->QueryInterface( IID_IDispatch, (void**)&pNewSD );
      ASSERT( SUCCEEDED( hResult ) );

      pADsNewSD->Release( );

      break;
   }

   return pNewSD;
}

/******************************************************************************
  Function:    ConvertFromPropertyValue
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
BOOL  ConvertFromPropertyValue( VARIANT& rVar, TCHAR* szText )
{
   IADsPropertyValue*   pPropValue  = NULL;
   HRESULT              hResult;
   long                 lType;
   BSTR                 bstrVal = NULL;

   if( VT_DISPATCH != V_VT(&rVar ) )
      return FALSE;

   hResult  = V_DISPATCH( &rVar )->QueryInterface( IID_IADsPropertyValue, (void**)&pPropValue );
   if( FAILED( hResult ) )
      return FALSE;

   while( TRUE )
   {
      hResult  = pPropValue->get_ADsType( &lType );
      if( FAILED( hResult ) )
         break;

      switch( (ADSTYPEENUM)lType )
      {
         case  ADSTYPE_DN_STRING:
         {
            hResult  = pPropValue->get_DNString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               Convert( szText, bstrVal );
               SysFreeString( bstrVal );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_DNString returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_CaseExactString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_CaseExactString should fail\n") );
               SysFreeString( bstrVal );
            }

            break;
         }

         case  ADSTYPE_CASE_EXACT_STRING:
         {
            hResult  = pPropValue->get_CaseExactString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               Convert( szText, bstrVal );
               SysFreeString( bstrVal );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_CaseExactString returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_DNString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_DNString should fail\n") );
               SysFreeString( bstrVal );
            }

            break;
         }

         case  ADSTYPE_CASE_IGNORE_STRING:
         {
            hResult  = pPropValue->get_CaseIgnoreString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               Convert( szText, bstrVal );
               SysFreeString( bstrVal );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_CaseIgnoreString returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_DNString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_DNString should fail\n") );
               SysFreeString( bstrVal );
            }

            break;
         }

         case  ADSTYPE_PRINTABLE_STRING:
         {
            hResult  = pPropValue->get_PrintableString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               Convert( szText, bstrVal );
               SysFreeString( bstrVal );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_PrintableString returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_DNString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_DNString should fail\n") );
               SysFreeString( bstrVal );
            }

            break;
         }

         case  ADSTYPE_NUMERIC_STRING:
         {
            hResult  = pPropValue->get_NumericString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               Convert( szText, bstrVal );
               SysFreeString( bstrVal );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_NumericString returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_DNString( &bstrVal );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_DNString should fail\n") );
               SysFreeString( bstrVal );
            }

            break;
         }

         case  ADSTYPE_BOOLEAN:
         {
            long  lValue;

            hResult  = pPropValue->get_Boolean( &lValue );
            if( SUCCEEDED( hResult ) )
            {
               _ltot( lValue, szText, 10 );
            }
            else
            {
               TRACE( _T("[ADSVW] Error: get_Boolean returns %lx\n"), hResult );
            }
            hResult  = pPropValue->get_Integer( &lValue );
            if( SUCCEEDED( hResult ) )
            {
               TRACE( _T("[ADSVW] Error: get_Integer should fail\n") );
            }

            break;
         }


         default:
            ASSERT( FALSE );
            break;
      }

      break;
   }

   pPropValue->Release( );

   return TRUE;
}


/******************************************************************************
  Function:    PurgeObject
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT  PurgeObject( IADsContainer* pParent, IUnknown* pIUnknown, LPWSTR pszPrefix )
{
   BSTR              bstrName       = NULL;
   BSTR              bstrClass      = NULL;
   VARIANT           var;
   HRESULT           hResult;
   IUnknown*         pIChildUnk     = NULL;
   IADs*             pIChildOleDs   = NULL;
   IADs*             pADs;
   BSTR              bstrObjName, bstrObjClass;
   IEnumVARIANT*     pIEnumVar   = NULL;
   IADsContainer*    pIContainer = NULL;
   ULONG             ulFetch     = 0L;
   //BOOL              bDelete;

   if( NULL == pParent || NULL == pIUnknown )
      return FALSE;

   hResult  = pIUnknown->QueryInterface( IID_IADs,
                                         (void**)&pADs );
   if( FAILED( hResult ) )
      return FALSE;

   pADs->get_Name( &bstrObjName );
   pADs->get_Class( &bstrObjClass );
   pADs->Release( );


   hResult  = pIUnknown->QueryInterface( IID_IADsContainer,
                                         (void**)&pIContainer );
   if( FAILED( hResult ) )
   {
      if( NULL != pszPrefix && !_wcsnicmp( bstrObjName, pszPrefix, wcslen(pszPrefix) ) )
      {
         hResult  = pParent->Delete( bstrObjClass, bstrObjName );
         TRACE( _T("Delete %S returns %lx\n"), bstrObjName, hResult );
      }
      if( NULL == pszPrefix )
      {
         hResult  = pParent->Delete( bstrObjClass, bstrObjName );
         TRACE( _T("Delete %S returns %lx\n"), bstrObjName, hResult );
      }

      SysFreeString( bstrObjClass );
      SysFreeString( bstrObjName );
      return S_OK;
   }


   hResult  = ADsBuildEnumerator( pIContainer, &pIEnumVar );

   while( SUCCEEDED( hResult ) )
   {
      ulFetch  = 0L;

      hResult  = ADsEnumerateNext( pIEnumVar, 1, &var, &ulFetch );
      if( FAILED( hResult ) )
         continue;

      if( !ulFetch )
         break;

      V_DISPATCH( &var )->QueryInterface( IID_IUnknown, (void**)&pIChildUnk );

      VariantClear( &var );

      if( NULL != pIChildUnk )
      {
         PurgeObject( pIContainer, pIChildUnk, pszPrefix );
         pIChildUnk->Release( );
      }
      pIChildUnk  = NULL;
   }

   if( NULL != pIEnumVar )
   {
      ADsFreeEnumerator( pIEnumVar );
   }
   pIContainer->Release( );

   hResult  = pParent->Delete( bstrObjClass, bstrObjName );

   TRACE( _T("\tDelete %S (%S) ends with %lx\n"), bstrObjName, bstrObjClass );

   SysFreeString( bstrObjClass );
   SysFreeString( bstrObjName );

   return hResult;
}


/******************************************************************************
  Function:    Bolb2String
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
CString  Blob2String( void* pData, DWORD dwSize )
{
   DWORD    dwIdx;
   TCHAR*   pText;
   BYTE*    pByte = (BYTE*)pData;
   CString  strText;

   pText = (TCHAR*)AllocADsMem( 1 + dwSize * 3 * sizeof( TCHAR ) );
   memset( pText, 0, 1 + dwSize * 3 * sizeof( TCHAR ) );


   for( dwIdx = 0; dwIdx < dwSize ; dwIdx++ )
   {
      _stprintf( pText + _tcslen(pText),
                 _T("%02x"),
                 ((BYTE*)pData)[ dwIdx ] );
   }

   strText  = pText;
   FreeADsMem( pText );

   return strText;
}


/******************************************************************************
  Function:    String2Blob
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT  String2Blob( TCHAR* pszText, void** ppData, DWORD* pdwLength )
{
   HRESULT     hResult;
   CString     strText;
   VARIANT     vBlob;
   SAFEARRAY*  pSafeArray;
   long        lBound, uBound, lItem;
   BYTE*       pbData;

   strText     = pszText;
   *pdwLength  = 0;

   hResult     = CreateBlobArray( strText, vBlob );
   if( FAILED( hResult ) )
   {
      return hResult;
   }

   pSafeArray  = V_ARRAY( &vBlob );

   hResult     = SafeArrayGetLBound(pSafeArray, 1, &lBound);
   hResult     = SafeArrayGetUBound(pSafeArray, 1, &uBound);
   *pdwLength  = (uBound - lBound + 1);

   pbData      = (BYTE*) AllocADsMem( sizeof(BYTE) * (uBound - lBound + 1) );

   for( lItem = lBound; lItem <= uBound ; lItem++ )
   {
      hResult  = SafeArrayGetElement( pSafeArray,
                                      &lItem,
                                      pbData + (lItem - lBound) );
      if( FAILED( hResult ) )
      {
         ASSERT( FALSE );
         break;
      }
   }

   *ppData  = (void*)pbData;

   return hResult;
}


/******************************************************************************
  Function:    AllocTCHAR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
TCHAR*   AllocTCHAR ( CHAR* pszText )
{
   TCHAR*   pszAlloc = NULL;

   while( TRUE )
   {
      ASSERT( NULL != pszText );
      if( NULL == pszText )
         break;

      pszAlloc = (TCHAR*) AllocADsMem( sizeof(TCHAR)*(strlen(pszText) + 1) );
      if( NULL == pszAlloc )
         break;

      Convert( pszAlloc, pszText );
      break;
   }

   return pszAlloc;
}



/******************************************************************************
  Function:    AllocTCHAR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
WCHAR*   AllocWCHAR ( CHAR* pszText )
{
   WCHAR*   pszAlloc = NULL;

   while( TRUE )
   {
      ASSERT( NULL != pszText );
      if( NULL == pszText )
         break;

      pszAlloc = (WCHAR*) AllocADsMem( sizeof(WCHAR)*(strlen(pszText) + 1) );
      if( NULL == pszAlloc )
         break;

      Convert( pszAlloc, pszText );
      break;
   }

   return pszAlloc;
}


/******************************************************************************
  Function:    AllocTCHAR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
TCHAR*   AllocTCHAR( WCHAR* pszText )
{
   TCHAR*   pszAlloc = NULL;

   while( TRUE )
   {
      ASSERT( NULL != pszText );
      if( NULL == pszText )
         break;

      pszAlloc = (TCHAR*) AllocADsMem( sizeof(TCHAR)*(wcslen(pszText) + 1) );
      if( NULL == pszAlloc )
         break;

      Convert( pszAlloc, pszText );
      break;
   }

   return pszAlloc;
}

/******************************************************************************
  Function:    AllocTCHAR
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
WCHAR*   AllocWCHAR( WCHAR* pszText )
{
   WCHAR*   pszAlloc = NULL;

   while( TRUE )
   {
      ASSERT( NULL != pszText );
      if( NULL == pszText )
         break;

      pszAlloc = (WCHAR*) AllocADsMem( sizeof(WCHAR)*(wcslen(pszText) + 1) );
      if( NULL == pszAlloc )
         break;

      Convert( pszAlloc, pszText );
      break;
   }

   return pszAlloc;
}


/*****************************************************************************
  Function:    GetVARIANTSize
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
long  GetVARIANTSize( VARIANT &rVar )
{
   SAFEARRAY      *psa = NULL;
   HRESULT        hResult;
   long           lLow, lUp;

   ASSERT( VT_ARRAY & V_VT( &rVar ) );

   if( !( VT_ARRAY & V_VT( &rVar ) ) )
      return -1;

   psa   = V_ARRAY(&rVar);

   if( NULL == psa )
      return 0;

   hResult  = SafeArrayGetLBound( psa, 1, &lLow );
   hResult  = SafeArrayGetUBound( psa, 1, &lUp );

   return (lUp - lLow + 1);
}

/*****************************************************************************
  Function:    GetVARIANTAt
  Arguments:
  Return:
  Purpose:
  Author(s):
  Revision:
  Date:
******************************************************************************/
HRESULT  GetVARIANTAt( long lIdx, VARIANT& vArray, VARIANT &vItem )
{
   SAFEARRAY      *psa = NULL;
   HRESULT        hResult;
   long           lLow, lUp, lPos;

   if( !( VT_ARRAY & V_VT( &vArray ) ) )
      return E_FAIL;

   psa   = V_ARRAY(&vArray);

   if( NULL == psa )
      return E_FAIL;

   VariantInit( &vItem );

   hResult  = SafeArrayGetLBound( psa, 1, &lLow );
   hResult  = SafeArrayGetUBound( psa, 1, &lUp );

   lPos     = lLow + lIdx;
   hResult  = SafeArrayGetElement( psa, &lPos, &vItem );

   return hResult;
}


/******************************************************************************
  Function:    GetValuesCount
  Arguments:   szText   - ptr to TCHAR string to be "tokanized"
               cSep     - Token separator
  Return:      number of tokens in szText (cSep being the token separator)
  Purpose:     The method id used to parse strings. The most common usage is for
               a string containing multiple values.
  Author(s):   cezaru
  Revision:    1
  Date:        08/10/97
******************************************************************************/
long  GetValuesCount( CString& szText, TCHAR cSep  )
{
   int   nIter;
   long  lCount   = 0;

   for( nIter = 0; nIter < szText.GetLength( ) ; nIter++ )
   {
      if( cSep == szText.GetAt( nIter ) )
         lCount++;
   }

   return ++lCount;
}


/******************************************************************************
  Function:    GetElements
  Arguments:   szText   string to be parsed
               cSep     token separator character
               lValues  tokens count
  Return:      an array of strings, each string being a token
  Purpose:     breaks a string into multiple tokens
  Author(s):   cezaru
  Revision:    1
  Date:        08/10/97
******************************************************************************/
CString GetValueAt( CString& szText, TCHAR cSep, long lValue )
{
   TCHAR*  pszString;
   long    lIter, lPos, lVal, lLength;
   TCHAR*  pszTemp;
   CString  strRes;

   if( lValue >=  GetValuesCount( szText, cSep ) )
      return _T("");

   lIter = 0;
   lPos  = 0;
   lLength     = sizeof(TCHAR) * ( 1 + szText.GetLength( ) );
   pszTemp     = (TCHAR*)  AllocADsMem( lLength );

   pszString   = (TCHAR*) AllocADsMem( lLength );


   while( lIter < lValue )
   {
      if( szText.GetAt( lPos++ ) == cSep )
         lIter++;
   }

   lVal  = 0;

   while( lPos < szText.GetLength( ) && szText.GetAt( lPos ) != cSep )
   {
      pszTemp[ lVal++ ] = szText.GetAt( lPos );
      pszTemp[ lVal ]   = _T('\0');
      lPos++;
   }

   strRes   = pszTemp;

   FreeADsMem( pszTemp );

   return strRes;
}


/******************************************************************************
  Function:    CreateLargeInteger
  Arguments:
  Return:
  Purpose:
  Author(s):   cezaru
  Revision:    1
  Date:        08/10/97
******************************************************************************/
IDispatch* CreateLargeInteger( CString& strText )
{
   LARGE_INTEGER     aLargeInteger;
   IADsLargeInteger* pLInt = NULL;
   IDispatch*        pDisp = NULL;
   HRESULT           hResult;


   while( TRUE )
   {
      hResult  = StringToLARGE_INTEGER( strText.GetBuffer( 128 ), &aLargeInteger );

      hResult = CoCreateInstance(
                               CLSID_LargeInteger,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_IADsLargeInteger,
                               (void **)&pLInt );

      ASSERT( SUCCEEDED( hResult ) );
      if( FAILED( hResult ) )
      {
         TRACE( "\tERROR: CoCreateInstance(CLSID_LargeInteger,...) fails with %lx\n", hResult );
         break;
      }

      pLInt->put_HighPart( (LONG)aLargeInteger.HighPart );
      pLInt->put_LowPart(  (LONG)aLargeInteger.LowPart );

      hResult  = pLInt->QueryInterface( IID_IDispatch, (void**)&pDisp );

      pLInt->Release( );
      break;
   }

   return pDisp;
}



/******************************************************************************
  Function:    FromLargeInteger
  Arguments:
  Return:
  Purpose:
  Author(s):   cezaru
  Revision:    1
  Date:        08/10/97
******************************************************************************/
CString FromLargeInteger( IDispatch* pDisp )
{
   LARGE_INTEGER     aLargeInteger;
   IADsLargeInteger* pLInt = NULL;
   HRESULT           hResult;
   TCHAR             szText[ 128 ];

   _tcscpy( szText, _T("") );

   while( TRUE )
   {
      hResult  = pDisp->QueryInterface( IID_IADsLargeInteger, (void**)&pLInt );
      if( FAILED( hResult ) )
         break;

      hResult  = pLInt->get_HighPart( &aLargeInteger.HighPart );
      hResult  = pLInt->get_LowPart( (long*) &aLargeInteger.LowPart );
      pLInt->Release( );

      hResult  = LARGE_INTEGERToString( szText, &aLargeInteger );
      break;
   }

   return szText;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\viewex.h ===
// viewex.h : main header file for the VIEWEX application
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#if !defined(__AFXWIN_H__) || !defined(__AFXEXT_H__)
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

#include "maindoc.h"        // main document data
#include "simpvw.h"         // simple read-only view
#include "inputvw.h"        // editable view

/////////////////////////////////////////////////////////////////////////////
// CViewExApp:
// See viewex.cpp for the implementation of this class
//

class CViewExApp : public CWinApp
{
public:
	int ExitInstance( void );
	CViewExApp();
   ~CViewExApp();

// Overrides
	virtual BOOL InitInstance();

// Implementation

	//{{AFX_MSG(CViewExApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class foo  
{
public:
	foo();
	virtual ~foo();

};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\adsrc.h ===
#ifndef __ADSRC_H__
#define __ADSRC_H__

#define ADS_BUILTIN             500000
#define ADS_NT_AUTHORITY        500001
#define ADS_ACCOUNT_OPERATORS   500002
#define ADS_PRINT_OPERATORS     500003
#define ADS_BACKUP_OPERATORS    500004
#define ADS_SERVER_OPERATORS    500005
#define ADS_PRE_WIN2000         500006

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\oledsvw\splitter.h ===
// splitter.h : custom splitter control and frame that contains it
//
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1995 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
// CSplitterFrame frame with splitter/wiper

class CSplitterFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CSplitterFrame)
protected:
	CSplitterFrame();   // protected constructor used by dynamic creation

// Attributes
protected:
	CSplitterWnd m_wndSplitter;

// Implementation
public:
	virtual ~CSplitterFrame();
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

	// Generated message map functions
	//{{AFX_MSG(CSplitterFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

class CQuerySplitterFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(CQuerySplitterFrame)
protected:
	CQuerySplitterFrame();   // protected constructor used by dynamic creation

// Attributes
protected:
	CSplitterWnd m_wndSplitter;

// Implementation
public:
	virtual ~CQuerySplitterFrame();
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

	// Generated message map functions
	//{{AFX_MSG(CSplitterFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

class C3WaySplitterFrame : public CMDIChildWnd
{
	DECLARE_DYNCREATE(C3WaySplitterFrame)
protected:
	C3WaySplitterFrame();   // protected constructor used by dynamic creation

// Attributes
protected:
	CSplitterWnd m_wndSplitter;
	CSplitterWnd m_wndSplitter2;        // embedded in the first

// Implementation
public:
	virtual ~C3WaySplitterFrame();
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

	// Generated message map functions
	//{{AFX_MSG(C3WaySplitterFrame)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\adscopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       adscopy.cxx
//
//  Contents:   NDS Object to Variant Copy Routines
//
//  Functions:
//
//  History:      25-Apr-96   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"


HRESULT
AdsClear(
    PADSVALUE lpAdsValue
    )
{
    HRESULT hr = S_OK;
    switch (lpAdsValue->dwType){

    case ADSTYPE_DN_STRING:
        FreeADsStr(lpAdsValue->DNString);
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        FreeADsStr(lpAdsValue->CaseExactString);
        break;

    case ADSTYPE_CASE_IGNORE_STRING:
        FreeADsStr(lpAdsValue->CaseIgnoreString);
        break;

    case ADSTYPE_PRINTABLE_STRING:
        FreeADsStr(lpAdsValue->PrintableString);
        break;

    case ADSTYPE_NUMERIC_STRING:
        FreeADsStr(lpAdsValue->NumericString);
        break;

    case ADSTYPE_BOOLEAN:
        break;

    case ADSTYPE_INTEGER:
        break;

    case ADSTYPE_OCTET_STRING:
        if (lpAdsValue->OctetString.lpValue) {
            FreeADsMem(lpAdsValue->OctetString.lpValue);
        }
        break;

    case ADSTYPE_PROV_SPECIFIC:
        if (lpAdsValue->ProviderSpecific.lpValue) {
            FreeADsMem(lpAdsValue->ProviderSpecific.lpValue);
        }
        break;

    case ADSTYPE_UTC_TIME:
        break;

    case ADSTYPE_CASEIGNORE_LIST:
    {
        PADS_CASEIGNORE_LIST pCurrent = NULL;
        PADS_CASEIGNORE_LIST pNext = NULL;

        pNext = lpAdsValue->pCaseIgnoreList;
        while (pNext) {
            pCurrent = pNext;
            pNext = pCurrent->Next;
            if (pCurrent->String) {
                FreeADsStr(pCurrent->String);
            }
            FreeADsMem(pCurrent);
        }
        break;
    }

    case ADSTYPE_FAXNUMBER:
        if (lpAdsValue->pFaxNumber) {
            if (lpAdsValue->pFaxNumber->Parameters) {
                FreeADsMem(lpAdsValue->pFaxNumber->Parameters);
            }
            if (lpAdsValue->pFaxNumber->TelephoneNumber) {
                FreeADsMem(lpAdsValue->pFaxNumber->TelephoneNumber);
            }
            FreeADsMem(lpAdsValue->pFaxNumber);
        }
        break;

    case ADSTYPE_NETADDRESS:
        if (lpAdsValue->pNetAddress) {
            if (lpAdsValue->pNetAddress->Address) {
                FreeADsMem(lpAdsValue->pNetAddress->Address);
            }
            FreeADsMem(lpAdsValue->pNetAddress);
        }
        break;

    case ADSTYPE_OCTET_LIST:
    {
        PADS_OCTET_LIST pCurrent = NULL;
        PADS_OCTET_LIST pNext = NULL;

        pNext = lpAdsValue->pOctetList;
        while (pNext) {
            pCurrent = pNext;
            pNext = pCurrent->Next;
            if (pCurrent->Data) {
                FreeADsMem(pCurrent->Data);
            }
            FreeADsMem(pCurrent);
        }
        break;
    }

    case ADSTYPE_EMAIL:
        if (lpAdsValue->Email.Address) {
            FreeADsStr(lpAdsValue->Email.Address);
        }
        break;

    case ADSTYPE_PATH:
        if (lpAdsValue->pPath) {
            if (lpAdsValue->pPath->VolumeName) {
                FreeADsStr(lpAdsValue->pPath->VolumeName);
            }
            if (lpAdsValue->pPath->Path) {
                FreeADsStr(lpAdsValue->pPath->Path);
            }
            FreeADsMem(lpAdsValue->pPath);
        }
        break;

    case ADSTYPE_REPLICAPOINTER:
        if (lpAdsValue->pReplicaPointer) {
            if (lpAdsValue->pReplicaPointer->ServerName) {
                FreeADsStr(lpAdsValue->pReplicaPointer->ServerName );
            }
            if (lpAdsValue->pReplicaPointer->ReplicaAddressHints->Address) {
                FreeADsMem(lpAdsValue->pReplicaPointer->ReplicaAddressHints->Address);
            }
            FreeADsMem(lpAdsValue->pReplicaPointer);
        }
        break;


    case ADSTYPE_TIMESTAMP:
        break;

    case ADSTYPE_POSTALADDRESS:
    {
        long i;
        if (lpAdsValue->pPostalAddress) {
            for (i=0;i<6;i++) {
                if (lpAdsValue->pPostalAddress->PostalAddress[i]) {
                    FreeADsStr(lpAdsValue->pPostalAddress->PostalAddress[i]);
                }
            }
            FreeADsMem(lpAdsValue->pPostalAddress);
        }
        break;
    }

    case ADSTYPE_BACKLINK:
        if (lpAdsValue->BackLink.ObjectName) {
            FreeADsStr(lpAdsValue->BackLink.ObjectName);
        }
        break;

    case ADSTYPE_TYPEDNAME:
        if (lpAdsValue->pTypedName) {
            if (lpAdsValue->pTypedName->ObjectName) {
                FreeADsStr(lpAdsValue->pTypedName->ObjectName);
            }
            FreeADsMem(lpAdsValue->pTypedName);
        }

        break;

    case ADSTYPE_HOLD:
        if (lpAdsValue->Hold.ObjectName) {
            FreeADsStr(lpAdsValue->Hold.ObjectName);
        }
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        if (lpAdsValue->SecurityDescriptor.lpValue) {
            FreeADsMem(lpAdsValue->SecurityDescriptor.lpValue);
        }
        break;

    case ADSTYPE_OBJECT_CLASS:
        FreeADsStr(lpAdsValue->ClassName);
        break;

    case ADSTYPE_DN_WITH_BINARY:
        if (lpAdsValue->pDNWithBinary) {

            if (lpAdsValue->pDNWithBinary->lpBinaryValue) {
                FreeADsMem(lpAdsValue->pDNWithBinary->lpBinaryValue);
            }

            if (lpAdsValue->pDNWithBinary->pszDNString) {
                FreeADsStr(lpAdsValue->pDNWithBinary->pszDNString);
            }
            FreeADsMem(lpAdsValue->pDNWithBinary);
        }
        break;

    case ADSTYPE_DN_WITH_STRING:
        if (lpAdsValue->pDNWithString) {
            if (lpAdsValue->pDNWithString->pszStringValue) {
                FreeADsMem(lpAdsValue->pDNWithString->pszStringValue);
            }

            if (lpAdsValue->pDNWithString->pszDNString) {
                FreeADsStr(lpAdsValue->pDNWithString->pszDNString);
            }
            FreeADsMem(lpAdsValue->pDNWithString);
        }
        break;

    default:
        break;
    }

    memset(lpAdsValue, 0, sizeof(ADSVALUE));
    RRETURN(S_OK);
}

HRESULT
AdsCopyDNString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_DN_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_DN_STRING;

    lpAdsDestValue->DNString =
                        AllocADsStr(
                            lpAdsSrcValue->DNString
                        );

    if (lpAdsSrcValue->DNString
        && !lpAdsDestValue->DNString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
AdsCopyCaseExactString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_EXACT_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_EXACT_STRING;

    lpAdsDestValue->CaseExactString =
                        AllocADsStr(
                            lpAdsSrcValue->CaseExactString
                        );

    if (lpAdsSrcValue->CaseExactString
        && !lpAdsDestValue->CaseExactString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}


HRESULT
AdsCopyCaseIgnoreString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )

{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASE_IGNORE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASE_IGNORE_STRING;

    lpAdsDestValue->CaseIgnoreString =
                        AllocADsStr(
                            lpAdsSrcValue->CaseIgnoreString
                        );
    if (lpAdsSrcValue->CaseIgnoreString
        && !lpAdsDestValue->CaseIgnoreString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);

}


HRESULT
AdsCopyPrintableString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PRINTABLE_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_PRINTABLE_STRING;

    lpAdsDestValue->PrintableString =
                        AllocADsStr(
                            lpAdsSrcValue->PrintableString
                        );

    if (lpAdsSrcValue->PrintableString
        && !lpAdsDestValue->PrintableString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}

HRESULT
AdsCopyNumericString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_NUMERIC_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_NUMERIC_STRING;

    lpAdsDestValue->NumericString =
                        AllocADsStr(
                                lpAdsSrcValue->NumericString
                        );

    if (lpAdsSrcValue->NumericString
        && !lpAdsDestValue->NumericString) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}



HRESULT
AdsCopyBoolean(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BOOLEAN){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_BOOLEAN;

    lpAdsDestValue->Boolean =
                        lpAdsSrcValue->Boolean;

    RRETURN(hr);
}


HRESULT
AdsCopyInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_INTEGER;

    lpAdsDestValue->Integer =
                                lpAdsSrcValue->Integer;

    RRETURN(hr);
}


HRESULT
AdsCopyLargeInteger(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_LARGE_INTEGER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_LARGE_INTEGER;

    lpAdsDestValue->LargeInteger =
                                lpAdsSrcValue->LargeInteger;



    RRETURN(hr);
}

HRESULT
AdsCopyOctetString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_STRING){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);

    if (dwNumBytes && !lpByteStream) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );

    lpAdsDestValue->OctetString.dwLength = dwNumBytes;

    lpAdsDestValue->OctetString.lpValue =  lpByteStream;

error :

    RRETURN(hr);
}


HRESULT
AdsCopyProvSpecific(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PROV_SPECIFIC){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_PROV_SPECIFIC;

    dwNumBytes =  lpAdsSrcValue->ProviderSpecific.dwLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);

    if (!lpByteStream && dwNumBytes) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->ProviderSpecific.lpValue,
        dwNumBytes
        );    

    lpAdsDestValue->ProviderSpecific.dwLength = dwNumBytes;

    lpAdsDestValue->ProviderSpecific.lpValue =  lpByteStream;

    RRETURN(hr);
error:


    RRETURN(hr);
}


//
// Was overloaded to handle IDispatch.
// Removed overloading during code cleanup.
//
HRESULT
AdsCopyNTSecurityDescriptor(
    PADSVALUE lpAdsSrcValue,
    CPropertyValue * lpPropValue,
    LPWSTR pszServerName,
    CCredentials& Credentials,
    BOOL fNTDSType
    )
{
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;
    HRESULT hr = S_OK;
    PADSVALUE lpAdsDestValue = lpPropValue->getADsValue();
    VARIANT vVarSec;

    VariantInit(&vVarSec);

    if(lpAdsSrcValue->dwType != ADSTYPE_NT_SECURITY_DESCRIPTOR){
        VariantClear(&vVarSec);
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;

    dwNumBytes =  lpAdsSrcValue->OctetString.dwLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);

    if (!lpByteStream && dwNumBytes) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->OctetString.lpValue,
        dwNumBytes
        );
    

    //
    // Now attempt to conver to security descriptor
    //
    hr = ConvertSecDescriptorToVariant(
             pszServerName,
             Credentials,
             lpAdsSrcValue->OctetString.lpValue,
             &vVarSec,
             fNTDSType
             );

    BAIL_ON_FAILURE(hr);

    hr = lpPropValue->put_SecurityDescriptor(V_DISPATCH(&vVarSec));

    BAIL_ON_FAILURE(hr);

    lpAdsDestValue->OctetString.dwLength = dwNumBytes;

    lpAdsDestValue->OctetString.lpValue =  lpByteStream;

    VariantClear(&vVarSec);

    RRETURN(hr);

error:

    if(lpByteStream){
        FreeADsMem(lpByteStream);
    }

    VariantClear(&vVarSec);

    RRETURN(hr);
}


HRESULT
AdsCopyTime(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_UTC_TIME){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_UTC_TIME;

    lpAdsDestValue->UTCTime = lpAdsSrcValue->UTCTime;

    RRETURN(hr);

}

HRESULT
AdsCopyEmail(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_EMAIL){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_EMAIL;

    lpAdsDestValue->Email.Type = lpAdsSrcValue->Email.Type;
    lpAdsDestValue->Email.Address = AllocADsStr(lpAdsSrcValue->Email.Address);
    if (!lpAdsDestValue->Email.Address && lpAdsSrcValue->Email.Address) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);

}


HRESULT
AdsCopyNetAddress(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_NETADDRESS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pNetAddress) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->dwType = ADSTYPE_NETADDRESS;

    lpAdsDestValue->pNetAddress = (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS));
    if (!lpAdsDestValue->pNetAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pNetAddress->AddressType = lpAdsSrcValue->pNetAddress->AddressType;

    dwNumBytes =  lpAdsSrcValue->pNetAddress->AddressLength;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
    if (!lpByteStream && dwNumBytes) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->pNetAddress->Address,
        dwNumBytes
        );

    lpAdsDestValue->pNetAddress->AddressLength = dwNumBytes;
    lpAdsDestValue->pNetAddress->Address =  lpByteStream;

    RRETURN(hr);

error:

    if(lpAdsDestValue->pNetAddress) {
        FreeADsMem(lpAdsDestValue->pNetAddress);
    }

    RRETURN(hr);

}

HRESULT
AdsCopyOctetList(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    PADS_OCTET_LIST pCurrent = NULL;
    PADS_OCTET_LIST pResult = NULL;
    PADS_OCTET_LIST pNext = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_OCTET_LIST){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }
    if (!lpAdsSrcValue->pOctetList) {
        RRETURN(hr = E_FAIL);
    }


    lpAdsDestValue->dwType = ADSTYPE_OCTET_LIST;

    lpAdsDestValue->pOctetList = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
    if (!lpAdsDestValue->pOctetList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = lpAdsSrcValue->pOctetList;
    pResult = lpAdsDestValue->pOctetList;
    hr = CopyOctetString(
                    pCurrent->Length,
                    pCurrent->Data,
                    &pResult->Length,
                    &pResult->Data);
    BAIL_ON_FAILURE(hr);
    while (pCurrent->Next) {
        pResult->Next = (PADS_OCTET_LIST)AllocADsMem(
                                        sizeof(ADS_OCTET_LIST));
        if (!pResult->Next) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pResult = pResult->Next;
        pCurrent = pCurrent->Next;
        hr = CopyOctetString(
                        pCurrent->Length,
                        pCurrent->Data,
                        &pResult->Length,
                        &pResult->Data);
        BAIL_ON_FAILURE(hr);
    }
    pResult->Next = NULL;
    RRETURN(hr);

error:
    
    pResult = lpAdsDestValue->pOctetList;
    while ( pResult) {
        pNext = pResult->Next;
        FreeADsMem(pResult);
        pResult = pNext;
    }
    RRETURN(hr);
}

HRESULT
AdsCopyCaseIgnoreList(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    PADS_CASEIGNORE_LIST pCurrent = NULL;
    PADS_CASEIGNORE_LIST pResult = NULL;
    PADS_CASEIGNORE_LIST pNext = NULL;

    if(lpAdsSrcValue->dwType != ADSTYPE_CASEIGNORE_LIST){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pCaseIgnoreList) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->pCaseIgnoreList = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
    if (!lpAdsDestValue->pCaseIgnoreList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->dwType = ADSTYPE_CASEIGNORE_LIST;
    pCurrent = lpAdsSrcValue->pCaseIgnoreList;
    pResult = lpAdsDestValue->pCaseIgnoreList;
    pResult->String = AllocADsStr(pCurrent->String);
    if (!pResult->String && pCurrent->String) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    while (pCurrent->Next) {
        pResult->Next = (PADS_CASEIGNORE_LIST)AllocADsMem(
                                        sizeof(ADS_CASEIGNORE_LIST));
        if (!pResult->Next) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pResult = pResult->Next;
        pCurrent = pCurrent->Next;
        pResult->String = AllocADsStr(pCurrent->String);
        if (!pResult->String && pCurrent->String) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    pResult->Next = NULL;
    RRETURN(hr);

error:
    
    pResult = lpAdsDestValue->pCaseIgnoreList;
    while ( pResult) {
        pNext = pResult->Next;
        if (pResult->String) {
            FreeADsStr(pResult->String);
        }
        FreeADsMem(pResult);
        pResult = pNext;
    }
    RRETURN(hr);
}

HRESULT
AdsCopyPath(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_PATH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pPath) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->dwType = ADSTYPE_PATH;
    lpAdsDestValue->pPath = (PADS_PATH)AllocADsMem(sizeof(ADS_PATH));
    if (!lpAdsDestValue->pPath) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->Type = lpAdsSrcValue->pPath->Type;
    lpAdsDestValue->pPath->VolumeName = AllocADsStr(lpAdsSrcValue->pPath->VolumeName);
    if (!lpAdsDestValue->pPath->VolumeName && lpAdsSrcValue->pPath->VolumeName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pPath->Path = AllocADsStr(lpAdsSrcValue->pPath->Path);
    if (!lpAdsDestValue->pPath->Path && lpAdsSrcValue->pPath->Path) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    
    RRETURN(hr);

error:

    if (lpAdsDestValue->pPath) {
        if (lpAdsDestValue->pPath->VolumeName) {
            FreeADsStr(lpAdsDestValue->pPath->VolumeName);     
        }
        FreeADsMem(lpAdsDestValue->pPath);
    }
    RRETURN(hr);

}

HRESULT
AdsCopyPostalAddress(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    long i;

    if(lpAdsSrcValue->dwType != ADSTYPE_POSTALADDRESS){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pPostalAddress) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->pPostalAddress = (PADS_POSTALADDRESS)AllocADsMem(sizeof(ADS_POSTALADDRESS));
    if (!lpAdsDestValue->pPostalAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    lpAdsDestValue->dwType = ADSTYPE_POSTALADDRESS;

    for (i=0;i<6;i++) {
        lpAdsDestValue->pPostalAddress->PostalAddress[i] = AllocADsStr(lpAdsSrcValue->pPostalAddress->PostalAddress[i]);
        if (!lpAdsDestValue->pPostalAddress->PostalAddress[i] &&
            lpAdsSrcValue->pPostalAddress->PostalAddress[i]) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    RRETURN(hr);

error:

    if (lpAdsDestValue->pPostalAddress) {
        
        //
        // Ideally I would need to loop only until i<5
        // Being extra cautious over here in case some other code gets
        // added after the for loop that returns an error which would
        // bring us over here
        //
        
        for (i=0;i<6;i++) {
            if (lpAdsDestValue->pPostalAddress->PostalAddress[i]) {
                FreeADsStr(lpAdsDestValue->pPostalAddress->PostalAddress[i]);
            }
        }

        FreeADsMem(lpAdsDestValue->pPostalAddress);
    }

    RRETURN(hr);

}

HRESULT
AdsCopyBackLink(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_BACKLINK){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_BACKLINK;

    lpAdsDestValue->BackLink.RemoteID = lpAdsSrcValue->BackLink.RemoteID;
    lpAdsDestValue->BackLink.ObjectName = AllocADsStr(lpAdsSrcValue->BackLink.ObjectName);
    if (!lpAdsDestValue->BackLink.ObjectName &&
        lpAdsSrcValue->BackLink.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);

}

HRESULT
AdsCopyTypedName(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

    if(lpAdsSrcValue->dwType != ADSTYPE_TYPEDNAME){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pTypedName) {
        RRETURN(hr = E_FAIL);
    }
    lpAdsDestValue->dwType = ADSTYPE_TYPEDNAME;
    lpAdsDestValue->pTypedName = (PADS_TYPEDNAME)AllocADsMem(sizeof(ADS_TYPEDNAME));
    if (!lpAdsDestValue->pTypedName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pTypedName->Level = lpAdsSrcValue->pTypedName->Level;
    lpAdsDestValue->pTypedName->Interval = lpAdsSrcValue->pTypedName->Interval;
    lpAdsDestValue->pTypedName->ObjectName = AllocADsStr(lpAdsSrcValue->pTypedName->ObjectName);
    if (!lpAdsDestValue->pTypedName->ObjectName &&
        lpAdsSrcValue->pTypedName->ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    
    RRETURN(hr);

error:
    if (lpAdsDestValue->pTypedName) {
        FreeADsMem(lpAdsDestValue->pTypedName);
    }

    RRETURN(hr);

}

HRESULT
AdsCopyHold(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_HOLD){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_HOLD;

    lpAdsDestValue->Hold.Amount = lpAdsSrcValue->Hold.Amount;
    lpAdsDestValue->Hold.ObjectName = AllocADsStr(lpAdsSrcValue->Hold.ObjectName);
    if (!lpAdsDestValue->Hold.ObjectName &&
        lpAdsSrcValue->Hold.ObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
error:
    RRETURN(hr);

}

HRESULT
AdsCopyReplicaPointer(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_REPLICAPOINTER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pReplicaPointer) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->dwType = ADSTYPE_REPLICAPOINTER;
    lpAdsDestValue->pReplicaPointer = (PADS_REPLICAPOINTER)AllocADsMem(sizeof(ADS_REPLICAPOINTER));
    if (!lpAdsDestValue->pReplicaPointer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ReplicaType = lpAdsSrcValue->pReplicaPointer->ReplicaType;
    lpAdsDestValue->pReplicaPointer->ReplicaNumber = lpAdsSrcValue->pReplicaPointer->ReplicaNumber;
    lpAdsDestValue->pReplicaPointer->Count = lpAdsSrcValue->pReplicaPointer->Count;
    lpAdsDestValue->pReplicaPointer->ServerName = AllocADsStr(lpAdsSrcValue->pReplicaPointer->ServerName);
    if (!lpAdsDestValue->pReplicaPointer->ServerName &&
        lpAdsSrcValue->pReplicaPointer->ServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Doing NetAddress
    //

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints = (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS));
    if (!lpAdsDestValue->pReplicaPointer->ReplicaAddressHints) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->AddressType = lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressType;

    hr = CopyOctetString(
                lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->AddressLength,
                lpAdsSrcValue->pReplicaPointer->ReplicaAddressHints->Address,
                &lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->AddressLength,
                &lpAdsDestValue->pReplicaPointer->ReplicaAddressHints->Address);
    BAIL_ON_FAILURE(hr);
    
    RRETURN(hr);
    
error:
    if (lpAdsDestValue->pReplicaPointer) {
        if (lpAdsDestValue->pReplicaPointer->ServerName) {
            FreeADsStr(lpAdsDestValue->pReplicaPointer->ServerName);     
        }
        if (lpAdsDestValue->pReplicaPointer->ReplicaAddressHints) {
            FreeADsMem(lpAdsDestValue->pReplicaPointer->ReplicaAddressHints);
        }
        FreeADsMem(lpAdsDestValue->pReplicaPointer);
    }

    RRETURN(hr);

}

HRESULT
AdsCopyFaxNumber(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    LPBYTE lpByteStream = NULL;
    DWORD dwNumBytes = 0;

    if(lpAdsSrcValue->dwType != ADSTYPE_FAXNUMBER){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pFaxNumber) {
        RRETURN(hr = E_FAIL);
    }

    lpAdsDestValue->pFaxNumber = (PADS_FAXNUMBER)AllocADsMem(sizeof(ADS_FAXNUMBER));
    if (!lpAdsDestValue->pFaxNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    lpAdsDestValue->dwType = ADSTYPE_FAXNUMBER;

    dwNumBytes =  lpAdsSrcValue->pFaxNumber->NumberOfBits;
    lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
    if (!lpByteStream && dwNumBytes) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(
        lpByteStream,
        lpAdsSrcValue->pFaxNumber->Parameters,
        dwNumBytes
        );

    lpAdsDestValue->pFaxNumber->NumberOfBits = dwNumBytes;
    lpAdsDestValue->pFaxNumber->Parameters =  lpByteStream;

    lpAdsDestValue->pFaxNumber->TelephoneNumber = AllocADsStr(lpAdsSrcValue->pFaxNumber->TelephoneNumber);
    if (!lpAdsDestValue->pFaxNumber->TelephoneNumber &&
        lpAdsSrcValue->pFaxNumber->TelephoneNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    RRETURN(hr);

error:

    if (lpAdsDestValue->pFaxNumber) {
        FreeADsMem(lpAdsDestValue->pFaxNumber);
    }
    if (lpByteStream) {
        FreeADsMem(lpByteStream);
    }
    RRETURN(hr);

}

HRESULT
AdsCopyNDSTimestamp(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;

    if(lpAdsSrcValue->dwType != ADSTYPE_TIMESTAMP){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpAdsDestValue->dwType = ADSTYPE_TIMESTAMP;

    lpAdsDestValue->Timestamp.WholeSeconds = lpAdsSrcValue->Timestamp.WholeSeconds;
    lpAdsDestValue->Timestamp.EventID = lpAdsSrcValue->Timestamp.EventID;
    RRETURN(hr);

}

HRESULT
AdsCopyDNWithBinary(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    PADS_DN_WITH_BINARY pDestDNBin = NULL;
    PADS_DN_WITH_BINARY pSrcDNBin  = NULL;

    if (lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_BINARY) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pDNWithBinary) {
        //
        // No source object so return
        //
        RRETURN(hr);
    }

    pSrcDNBin = lpAdsSrcValue->pDNWithBinary;

    pDestDNBin = (PADS_DN_WITH_BINARY)
                    AllocADsMem(sizeof(ADS_DN_WITH_BINARY));

    if (!pDestDNBin) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (pSrcDNBin->dwLength) {

        //
        // Copy the octet string over.
        //
        pDestDNBin->lpBinaryValue = (LPBYTE) AllocADsMem(pSrcDNBin->dwLength);
        if (!pDestDNBin->lpBinaryValue && pSrcDNBin->dwLength) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        pDestDNBin->dwLength = pSrcDNBin->dwLength;

        memcpy(
            pDestDNBin->lpBinaryValue,
            pSrcDNBin->lpBinaryValue,
            pSrcDNBin->dwLength
            );
    }

    if (pSrcDNBin->pszDNString) {
        //
        // Copy the DNString value over
        //
        pDestDNBin->pszDNString = AllocADsStr(pSrcDNBin->pszDNString);
        if (!pDestDNBin->pszDNString && pSrcDNBin->pszDNString) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    lpAdsDestValue->pDNWithBinary = pDestDNBin;
    lpAdsDestValue->dwType = ADSTYPE_DN_WITH_BINARY;

    RRETURN(hr);

error:

    if (pDestDNBin) {
        //
        // Clean up the mem for string and byte array
        //
        if (pDestDNBin->pszDNString) {
            FreeADsStr(pDestDNBin->pszDNString);
        }

        if (pDestDNBin->lpBinaryValue) {
            FreeADsMem(pDestDNBin->lpBinaryValue);
        }
        FreeADsMem(pDestDNBin);
    }

    RRETURN(hr);

}


HRESULT
AdsCopyDNWithString(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = S_OK;
    PADS_DN_WITH_STRING pDestDNStr = NULL;
    PADS_DN_WITH_STRING pSrcDNStr  = NULL;

    if (lpAdsSrcValue->dwType != ADSTYPE_DN_WITH_STRING) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!lpAdsSrcValue->pDNWithString) {
        //
        // No source object so return
        //
        RRETURN(hr);
    }

    pSrcDNStr = lpAdsSrcValue->pDNWithString;

    pDestDNStr = (PADS_DN_WITH_STRING)
                    AllocADsMem(sizeof(ADS_DN_WITH_STRING));

    if (!pDestDNStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (pSrcDNStr->pszStringValue) {

        //
        // Copy the string over.
        //
        pDestDNStr->pszStringValue = AllocADsStr(pSrcDNStr->pszStringValue);
        if (!pDestDNStr->pszStringValue && pSrcDNStr->pszStringValue) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

    }

    if (pSrcDNStr->pszDNString) {
        //
        // Copy the DNString value over
        //
        pDestDNStr->pszDNString = AllocADsStr(pSrcDNStr->pszDNString);
        if (!pDestDNStr->pszDNString && pSrcDNStr->pszDNString) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    lpAdsDestValue->pDNWithString = pDestDNStr;
    lpAdsDestValue->dwType = ADSTYPE_DN_WITH_STRING;

    RRETURN(hr);

error:

    if (pDestDNStr) {
        //
        // Clean up the mem for string and byte array
        //
        if (pDestDNStr->pszDNString) {
            FreeADsStr(pDestDNStr->pszDNString);
        }

        if (pDestDNStr->pszStringValue) {
            FreeADsMem(pDestDNStr->pszStringValue);
        }
        FreeADsMem(pDestDNStr);
    }

    RRETURN(hr);
}

HRESULT
AdsCopy(
    PADSVALUE lpAdsSrcValue,
    PADSVALUE lpAdsDestValue
    )
{
    HRESULT hr = E_FAIL;

    switch (lpAdsSrcValue->dwType){

    case ADSTYPE_DN_STRING:
        hr = AdsCopyDNString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        hr = AdsCopyCaseExactString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;


    case ADSTYPE_CASE_IGNORE_STRING:
        hr = AdsCopyCaseIgnoreString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_PRINTABLE_STRING:
        hr = AdsCopyPrintableString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_NUMERIC_STRING:
        hr = AdsCopyNumericString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;


    case ADSTYPE_BOOLEAN:
        hr = AdsCopyBoolean(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_INTEGER:
        hr = AdsCopyInteger(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_LARGE_INTEGER:
        hr = AdsCopyLargeInteger(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_OCTET_STRING:
        hr = AdsCopyOctetString(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_PROV_SPECIFIC:
        hr = AdsCopyProvSpecific(
                 lpAdsSrcValue,
                 lpAdsDestValue
                 );
        break;

    case ADSTYPE_UTC_TIME:
        hr = AdsCopyTime(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_CASEIGNORE_LIST:
        hr = AdsCopyCaseIgnoreList(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_FAXNUMBER:
        hr = AdsCopyFaxNumber(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_NETADDRESS:
        hr = AdsCopyNetAddress(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_OCTET_LIST:
        hr = AdsCopyOctetList(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_EMAIL:
        hr = AdsCopyEmail(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_PATH:
        hr = AdsCopyPath(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_REPLICAPOINTER:
        hr = AdsCopyReplicaPointer(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_TIMESTAMP:
        hr = AdsCopyNDSTimestamp(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;

    case ADSTYPE_POSTALADDRESS:
        hr = AdsCopyPostalAddress(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_BACKLINK:
        hr = AdsCopyBackLink(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_TYPEDNAME:
        hr = AdsCopyTypedName(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;
    case ADSTYPE_HOLD:
        hr = AdsCopyHold(
                lpAdsSrcValue,
                lpAdsDestValue
                );
        break;


    case ADSTYPE_DN_WITH_BINARY:
        hr = AdsCopyDNWithBinary(
                 lpAdsSrcValue,
                 lpAdsDestValue
                 );
        break;

    case ADSTYPE_DN_WITH_STRING:
        hr = AdsCopyDNWithString(
                 lpAdsSrcValue,
                 lpAdsDestValue
                 );
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        //
        // This should be handled elsewhere not here !
        //
        ADsAssert(!"Invalid option to adscopy");
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);

}
//
// This routine is typically used by GetPropertyItem calls.
//
HRESULT
AdsCopyADsValueToPropObj(
    PADSVALUE lpAdsSrcValue,
    CPropertyValue* lpPropObj,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    )
{
    HRESULT hr = S_OK;
    PADSVALUE lpAdsDestValue = lpPropObj->getADsValue();
    CCredentials localCredentials(NULL, NULL, 0);

    switch (lpAdsSrcValue->dwType){


    case ADSTYPE_NT_SECURITY_DESCRIPTOR:

        if (pCredentials) {
            localCredentials = *pCredentials;
        }
        hr = AdsCopyNTSecurityDescriptor(
                    lpAdsSrcValue,
                    lpPropObj,
                    pszServerName,
                    localCredentials,
                    fNTDSType
                    );
        break;


    default:
        hr = AdsCopy(
                 lpAdsSrcValue,
                 lpAdsDestValue
                 );

        break;
    }

    RRETURN(hr);
}

//
// This routine is typically used from PutPropertyItem.
//
HRESULT
AdsCopyPropObjToADsValue(
    CPropertyValue *lpPropObj,
    PADSVALUE lpAdsDestValue,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    )
{
    HRESULT hr = E_FAIL;
    PADSVALUE lpAdsSrcValue = lpPropObj->getADsValue();
    DWORD dwDataType = 0;
    DWORD dwSDLength = 0;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    CCredentials locCredentials(NULL, NULL, 0);
    IDispatch *pIDispatch = NULL;
    IADsSecurityDescriptor *pIADsSecDesc = NULL;

    switch (lpAdsSrcValue->dwType) {

    case ADSTYPE_NT_SECURITY_DESCRIPTOR :

        dwDataType = lpPropObj->getExtendedDataTypeInfo();
        //
        // if we have the octet blob send it back
        //
        if (dwDataType == CPropertyValue::VAL_IDISPATCH_SECDESC_ALL) {

            hr = AdsCopyOctetString(
                     lpAdsSrcValue,
                     lpAdsDestValue
                     );
            BAIL_ON_FAILURE(hr);
        }
        else if (dwDataType == CPropertyValue::VAL_IDISPATCH_SECDESC_ONLY) {

            if (pCredentials) {
                locCredentials = *pCredentials;
            }

            pIDispatch = lpPropObj->getDispatchPointer();

            if (pIDispatch) {

                hr = pIDispatch->QueryInterface(
                                     IID_IADsSecurityDescriptor,
                                     (void **) &pIADsSecDesc
                                     );

                BAIL_ON_FAILURE(hr);
            }

            hr = ConvertSecurityDescriptorToSecDes(
                     pszServerName,
                     locCredentials,
                     pIADsSecDesc,
                     &pSecurityDescriptor,
                     &dwSDLength,
                     fNTDSType
                     );
            BAIL_ON_FAILURE(hr);

            lpAdsDestValue->OctetString.lpValue
                                = (LPBYTE) AllocADsMem(dwSDLength);

            if (!(lpAdsDestValue->OctetString.lpValue) && dwSDLength) {
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
            }

            memcpy(
                lpAdsDestValue->OctetString.lpValue,
                pSecurityDescriptor,
                dwSDLength
                );

            lpAdsDestValue->dwType = ADSTYPE_OCTET_STRING;
            lpAdsDestValue->OctetString.dwLength = dwSDLength;

        } // secdesc idispatch only
        break;

    default:

        hr = AdsCopy(
                 lpAdsSrcValue,
                 lpAdsDestValue
                 );
        break;
    } // end case

error :

    //
    // Needs to be executed in all cases, currently only ret is below
    //
    if (pIADsSecDesc) {
        pIADsSecDesc->Release();
    }

    if (pSecurityDescriptor) {
        FreeADsMem(pSecurityDescriptor);
    }

    RRETURN(hr);

}


HRESULT
PropVariantToAdsType(
    PVARIANT pVariant,
    DWORD dwNumVariant,
    PADSVALUE *ppAdsValues,
    PDWORD pdwNumValues
    )
{
    return(PropVariantToAdsType2(
               pVariant,
               dwNumVariant,
               ppAdsValues,
               pdwNumValues,
               NULL,        // serverName,
               NULL,        // pCredentials
               TRUE         // NTDS Type
               ));

}


HRESULT
PropVariantToAdsType2(
    PVARIANT pVariant,
    DWORD dwNumVariant,
    PADSVALUE *ppAdsValues,
    PDWORD pdwNumValues,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    )
{
    DWORD i = 0;
    VARIANT * pVar = NULL;
    DWORD dwCount = 0;
    IDispatch FAR * pDispatch = NULL;
    IADsValue FAR * pPropValue = NULL;
    PADSVALUE pADsValues = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassWord = NULL;
    DWORD dwFlags = 0;

    pADsValues = (PADSVALUE)AllocADsMem(dwNumVariant * sizeof(ADSVALUE));
    if (!pADsValues && dwNumVariant) {
        RRETURN(E_OUTOFMEMORY);
    }

    //
    // If !pCredentials, use the initialized values as they
    // represent an object with CCredentials(NULL, NULL, 0)
    //
    if (pCredentials) {

        hr = pCredentials->GetUserName(&pszUserName);

        BAIL_ON_FAILURE(hr);

        hr = pCredentials->GetPassword(&pszPassWord);

        BAIL_ON_FAILURE(hr);

        dwFlags = pCredentials->GetAuthFlags();

    }

    for (i = 0; i < dwNumVariant; i++ ) {

        pVar = pVariant + i;

        pDispatch = V_DISPATCH(pVar);

        hr = pDispatch->QueryInterface(
                    IID_IADsValue,
                    (void **)&pPropValue
                    );
        CONTINUE_ON_FAILURE(hr);


        hr = pPropValue->ConvertPropertyValueToADsValue2(
                                    (pADsValues + dwCount),
                                    pszServerName,
                                    pszUserName,
                                    pszPassWord,
                                    dwFlags,
                                    fNTDSType
                                    );
        pPropValue->Release();
        BAIL_ON_FAILURE(hr);

        dwCount++;

    }

    *ppAdsValues = pADsValues;
    *pdwNumValues = dwCount;

error:

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassWord) {
        SecureZeroMemory(pszPassWord, wcslen(pszPassWord)*sizeof(WCHAR));
        FreeADsStr(pszPassWord);
    }

    if (FAILED(hr) && pADsValues) {
        FreeADsMem(pADsValues);
    }

    RRETURN(hr);

}



HRESULT
AdsTypeToPropVariant2(
    PADSVALUE pAdsValues,
    DWORD dwNumValues,
    PVARIANT pVarDestObjects,
    LPWSTR pszServerName,
    CCredentials* pCredentials,
    BOOL fNTDSType
    )
{

    long i = 0;
    HRESULT hr = S_OK;
    CPropertyValue * pAdsValue = NULL;

    VariantInit( pVarDestObjects );

    //
    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumValues;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long)dwNumValues; i++ )
    {
        VARIANT v;
        IDispatch FAR * pDispatch = NULL;

        VariantInit(&v);

        hr = CPropertyValue::AllocatePropertyValueObject(&pAdsValue);

        BAIL_ON_FAILURE(hr);

        hr = pAdsValue->ConvertADsValueToPropertyValue2(
                    pAdsValues + i,
                    pszServerName,
                    pCredentials,
                    fNTDSType
                    );
        BAIL_ON_FAILURE(hr);

        hr = pAdsValue->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
        BAIL_ON_FAILURE(hr);


        V_DISPATCH(&v) = pDispatch;
        V_VT(&v) = VT_DISPATCH;

        if (pAdsValue) {
           pAdsValue->Release();
           pAdsValue = NULL;
        }

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        pDispatch = NULL;


        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    if(pAdsValue)
    {
        pAdsValue->Release();
        pAdsValue = NULL;
    }

    RRETURN(hr);
}


HRESULT
AdsTypeToPropVariant(
    PADSVALUE pAdsValues,
    DWORD dwNumValues,
    PVARIANT pVarDestObjects
    )
{
    RRETURN( AdsTypeToPropVariant2(
                 pAdsValues,
                 dwNumValues,
                 pVarDestObjects,
                 NULL,  // serverName
                 NULL,  // pCredentials
                 TRUE   // serverType
                 )
             );
}


void
AdsFreeAdsValues(
    PADSVALUE pAdsValues,
    DWORD dwNumValues
    )
{
   LPBYTE pMem = NULL;

   for ( DWORD i = 0; i < dwNumValues; i++ )
   {
      AdsClear(&pAdsValues[i]);
   }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\atl.cxx ===
// stdafx.cpp : source file that includes just the standard includes

#include "oleds.hxx"
#include "atl.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\atl.h ===
#if (!defined(BUILD_FOR_NT40))
#pragma once

//#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include "atlbase.h"
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include "atlcom.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\acledit.cxx ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    Acledit.c

Abstract:

    This Module implements the Acl rtl editing functions that are defined in
    ntseapi.h

Author:

    Gary Kimura     (GaryKi)    9-Nov-1989

Environment:

    Pure Runtime Library Routine

Revision History:

--*/

#include "oleds.hxx"
#pragma hdrstop

#include "seopaque.h"

//
// This is used to determine if we are going to call our private
// security API's (ADSIRtlFucntions) or if we should use the standard
// Win32 API's. By default we will assume we are running on Win2k+
// Win9x is not an issue for this as there is no sec api support.
//
BOOL g_fPlatformNotNT4 = TRUE;
BOOL g_fPlatformDetermined = FALSE;

//
// Helper routine that updates the g_fPlatformNotNt4 variable
// to the correct value.
//
void 
UpdatePlatformInfo()
{
    DWORD dwError;
    OSVERSIONINFO osVerInfo;

    //
    // Needed for the GetVersionEx call.
    //
    osVerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if (!GetVersionEx(&osVerInfo)) {
        //
        // Call failed, so we will default to Win2k
        //
        g_fPlatformNotNT4 = TRUE;
    }
    else {
        //
        // !(is this NT4).
        //
        g_fPlatformNotNT4 = 
            ! ((osVerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) 
              && (osVerInfo.dwMajorVersion == 4));
    }

    g_fPlatformDetermined = TRUE;
    return;
}

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    );

//
//  Define the local macros and procedure for this module
//

//
//  Return a pointer to the first Ace in an Acl (even if the Acl is empty).
//
//      PACE_HEADER
//      FirstAce (
//          IN PACL Acl
//          );
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Return a pointer to the next Ace in a sequence (even if the input
//  Ace is the one in the sequence).
//
//      PACE_HEADER
//      NextAce (
//          IN PACE_HEADER Ace
//          );
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

#define LongAligned( ptr )  (LongAlign(ptr) == ((PVOID)(ptr)))
#define WordAligned( ptr )  (WordAlign(ptr) == ((PVOID)(ptr)))


//++
//
//  ULONG
//  SeLengthSid(
//      IN PSID Sid
//      );
//
//  Routine Description:
//
//      This routine computes the length of a SID.
//
//  Arguments:
//
//      Sid - Points to the SID whose length is to be returned.
//
//  Return Value:
//
//      The length, in bytes of the SID.
//
//--

#define SeLengthSid( Sid ) \
    (8 + (4 * ((SID *)Sid)->SubAuthorityCount))


VOID
ADSIRtlpAddData (
    IN PVOID From,
    IN ULONG FromSize,
    IN PVOID To,
    IN ULONG ToSize
    );

VOID
ADSIRtlpDeleteData (
    IN PVOID Data,
    IN ULONG RemoveSize,
    IN ULONG TotalSize
    );



NTSTATUS
ADSIRtlCreateAcl (
    IN PACL Acl,
    IN ULONG AclLength,
    IN ULONG AclRevision
    )

/*++

Routine Description:

    This routine initializes an ACL data structure.  After initialization
    it is an ACL with no ACE (i.e., a deny all access type ACL)

Arguments:

    Acl - Supplies the buffer containing the ACL being initialized

    AclLength - Supplies the length of the ace buffer in bytes

    AclRevision - Supplies the revision for this Acl

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful

               STATUS_BUFFER_TOO_SMALL if the AclLength is too small,

               STATUS_INVALID_PARAMETER if the revision is out of range

--*/

{

    //
    //  Check to see the size of the buffer is large enough to hold at
    //  least the ACL header
    //

    if (AclLength < sizeof(ACL)) {

        //
        //  Buffer to small even for the ACL header
        //

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    //  Check to see if the revision is currently valid.  Later versions
    //  of this procedure might accept more revision levels
    //

    if (AclRevision < MIN_ACL_REVISION || AclRevision > MAX_ACL_REVISION) {

        //
        //  Revision not current
        //

        return STATUS_INVALID_PARAMETER;

    }

    if ( AclLength > MAXUSHORT ) {

        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Initialize the ACL
    //

    Acl->AclRevision = (UCHAR)AclRevision;  // Used to hardwire ACL_REVISION2 here
    Acl->Sbz1 = 0;
    Acl->AclSize = (USHORT) (AclLength & 0xfffc);
    Acl->AceCount = 0;
    Acl->Sbz2 = 0;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


BOOLEAN
ADSIRtlValidAcl (
    IN PACL Acl
    )

/*++

Routine Description:

    This procedure validates an ACL.

    This involves validating the revision level of the ACL and ensuring
    that the number of ACEs specified in the AceCount fit in the space
    specified by the AclSize field of the ACL header.

Arguments:

    Acl - Pointer to the ACL structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of Acl is valid.

--*/

{
    PACE_HEADER Ace;
    PISID Sid;
    PISID Sid2;
    ULONG i;
    UCHAR AclRevision = ACL_REVISION2;


    //
    //  Check the ACL revision level
    //
    if (!ValidAclRevision(Acl)) {
        return(FALSE);
    }


    if (!LongAligned(Acl->AclSize)) {
        return(FALSE);
    }

    //
    // Validate all of the ACEs.
    //

    Ace = (PACE_HEADER)((PVOID)((PUCHAR)(Acl) + sizeof(ACL)));

    for (i = 0; i < Acl->AceCount; i++) {

        //
        //  Check to make sure we haven't overrun the Acl buffer
        //  with our ace pointer.  Make sure the ACE_HEADER is in
        //  the ACL also.
        //

        if ((PUCHAR)Ace + sizeof(ACE_HEADER) >= ((PUCHAR)Acl + Acl->AclSize)) {
            return(FALSE);
        }

        if (!WordAligned(&Ace->AceSize)) {
            return(FALSE);
        }

        if ((PUCHAR)Ace + Ace->AceSize > ((PUCHAR)Acl + Acl->AclSize)) {
            return(FALSE);
        }

        //
        // It is now safe to reference fields in the ACE header.
        //

        //
        // The ACE header fits into the ACL, if this is a known type of ACE,
        // make sure the SID is within the bounds of the ACE
        //

        if (IsKnownAceType(Ace)) {

            if (!LongAligned(Ace->AceSize)) {
                return(FALSE);
            }

            if (Ace->AceSize < sizeof(KNOWN_ACE) - sizeof(ULONG) + sizeof(SID)) {
                return(FALSE);
            }

            //
            // It's now safe to reference the parts of the SID structure, though
            // not the SID itself.
            //

            Sid = (PISID) & (((PKNOWN_ACE)Ace)->SidStart);

            if (Sid->Revision != SID_REVISION) {
                return(FALSE);
            }

            if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return(FALSE);
            }

            //
            // SeLengthSid computes the size of the SID based on the subauthority count,
            // so it is safe to use even though we don't know that the body of the SID
            // is safe to reference.
            //

            if (Ace->AceSize < sizeof(KNOWN_ACE) - sizeof(ULONG) + SeLengthSid( Sid )) {
                return(FALSE);
            }


        //
        // If it's a compound ACE, then perform roughly the same set of tests, but
        // check the validity of both SIDs.
        //

        } else if (IsCompoundAceType(Ace)) {

            //
            // Compound ACEs became valid in revision 3
            //
            if ( Acl->AclRevision < ACL_REVISION3 ) {
                return FALSE;
            }

            if (!LongAligned(Ace->AceSize)) {
                return(FALSE);
            }

            if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + sizeof(SID)) {
                return(FALSE);
            }

            //
            // The only currently defined Compound ACE is an Impersonation ACE.
            //

            if (((PKNOWN_COMPOUND_ACE)Ace)->CompoundAceType != COMPOUND_ACE_IMPERSONATION) {
                return(FALSE);
            }

            //
            // Examine the first SID and make sure it's structurally valid,
            // and it lies within the boundaries of the ACE.
            //

            Sid = (PISID) & (((PKNOWN_COMPOUND_ACE)Ace)->SidStart);

            if (Sid->Revision != SID_REVISION) {
                return(FALSE);
            }

            if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return(FALSE);
            }

            //
            // Compound ACEs contain two SIDs.  Make sure this ACE is large enough to contain
            // not only the first SID, but the body of the 2nd.
            //

            if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + SeLengthSid( Sid ) + sizeof(SID)) {
                return(FALSE);
            }

            //
            // It is safe to reference the interior of the 2nd SID.
            //

            Sid2 = (PISID) ((PUCHAR)Sid + SeLengthSid( Sid ));

            if (Sid2->Revision != SID_REVISION) {
                return(FALSE);
            }

            if (Sid2->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return(FALSE);
            }

            if (Ace->AceSize < sizeof(KNOWN_COMPOUND_ACE) - sizeof(ULONG) + SeLengthSid( Sid ) + SeLengthSid( Sid2 )) {
                return(FALSE);
            }


        //
        // If it's an object ACE, then perform roughly the same set of tests.
        //

        } else if (IsObjectAceType(Ace)) {
            ULONG GuidSize=0;

            //
            // Object ACEs became valid in revision 4
            //
            if ( Acl->AclRevision < ACL_REVISION4 ) {
                return FALSE;
            }

            if (!LongAligned(Ace->AceSize)) {
                return(FALSE);
            }

            //
            // Ensure there is room for the ACE header.
            //
            if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG)) {
                return(FALSE);
            }


            //
            // Ensure there is room for the GUIDs and SID header
            //
            if ( RtlObjectAceObjectTypePresent( Ace ) ) {
                GuidSize += sizeof(GUID);
            }

            if ( RtlObjectAceInheritedObjectTypePresent( Ace ) ) {
                GuidSize += sizeof(GUID);
            }

            if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG) + GuidSize + sizeof(SID)) {
                return(FALSE);
            }

            //
            // It's now safe to reference the parts of the SID structure, though
            // not the SID itself.
            //

            Sid = (PISID) RtlObjectAceSid( Ace );

            if (Sid->Revision != SID_REVISION) {
                return(FALSE);
            }

            if (Sid->SubAuthorityCount > SID_MAX_SUB_AUTHORITIES) {
                return(FALSE);
            }

            if (Ace->AceSize < sizeof(KNOWN_OBJECT_ACE) - sizeof(ULONG) + GuidSize + SeLengthSid( Sid ) ) {
                return(FALSE);
            }
        }

        //
        //  And move Ace to the next ace position
        //

        Ace = (PACE_HEADER)((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize));
    }

    return(TRUE);

}


NTSTATUS
ADSIRtlQueryInformationAcl (
    IN PACL Acl,
    OUT PVOID AclInformation,
    IN ULONG AclInformationLength,
    IN ACL_INFORMATION_CLASS AclInformationClass
    )

/*++

Routine Description:

    This routine returns to the caller information about an ACL.  The requested
    information can be AclRevisionInformation, or AclSizeInformation.

Arguments:

    Acl - Supplies the Acl being examined

    AclInformation - Supplies the buffer to receive the information being
        requested

    AclInformationLength - Supplies the length of the AclInformation buffer
        in bytes

    AclInformationClass - Supplies the type of information being requested

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PACL_REVISION_INFORMATION RevisionInfo;
    PACL_SIZE_INFORMATION SizeInfo;


    PVOID FirstFree;
    NTSTATUS Status;


    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision( Acl )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Case on the information class being requested
    //

    switch (AclInformationClass) {

    case AclRevisionInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_REVISION_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Get the Acl revision and return
        //

        RevisionInfo = (PACL_REVISION_INFORMATION)AclInformation;
        RevisionInfo->AclRevision = Acl->AclRevision;

        break;

    case AclSizeInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_SIZE_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Locate the first free spot in the Acl
        //

        if (!RtlFirstFreeAce( Acl, &FirstFree )) {

            //
            //  The input Acl is ill-formed
            //

            return STATUS_INVALID_PARAMETER;

        }

        //
        //  Given a pointer to the first free spot we can now easily compute
        //  the number of free bytes and used bytes in the Acl.
        //

        SizeInfo = (PACL_SIZE_INFORMATION)AclInformation;
        SizeInfo->AceCount = Acl->AceCount;

        if (FirstFree == NULL) {

            //
            //  With a null first free we don't have any free space in the Acl
            //

            SizeInfo->AclBytesInUse = Acl->AclSize;

            SizeInfo->AclBytesFree = 0;

        } else {

            //
            //  The first free is not null so we have some free room left in
            //  the acl
            //

            SizeInfo->AclBytesInUse = (ULONG)((PUCHAR)FirstFree - (PUCHAR)Acl);

            SizeInfo->AclBytesFree = Acl->AclSize - SizeInfo->AclBytesInUse;

        }

        break;

    default:

        return STATUS_INVALID_INFO_CLASS;

    }

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
ADSIRtlSetInformationAcl (
    IN PACL Acl,
    IN PVOID AclInformation,
    IN ULONG AclInformationLength,
    IN ACL_INFORMATION_CLASS AclInformationClass
    )

/*++

Routine Description:

    This routine sets the state of an ACL.  For now only the revision
    level can be set and for now only a revision level of 1 is accepted
    so this procedure is rather simple

Arguments:

    Acl - Supplies the Acl being altered

    AclInformation - Supplies the buffer containing the information being
        set

    AclInformationLength - Supplies the length of the Acl information buffer

    AclInformationClass - Supplies the type of information begin set

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PACL_REVISION_INFORMATION RevisionInfo;


    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision( Acl )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Case on the information class being requested
    //

    switch (AclInformationClass) {

    case AclRevisionInformation:

        //
        //  Make sure the buffer size is correct
        //

        if (AclInformationLength < sizeof(ACL_REVISION_INFORMATION)) {

            return STATUS_BUFFER_TOO_SMALL;

        }

        //
        //  Get the Acl requested ACL revision level
        //

        RevisionInfo = (PACL_REVISION_INFORMATION)AclInformation;

        //
        //  Don't let them lower the revision of an ACL.
        //

        if (RevisionInfo->AclRevision < Acl->AclRevision ) {

            return STATUS_INVALID_PARAMETER;
        }

        //
        // Assign the new revision.
        //

        Acl->AclRevision = (UCHAR)RevisionInfo->AclRevision;

        break;

    default:

        return STATUS_INVALID_INFO_CLASS;

    }

    //
    //  and return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
ADSIRtlAddAce (
    IN OUT PACL Acl,
    IN ULONG AceRevision,
    IN ULONG StartingAceIndex,
    IN PVOID AceList,
    IN ULONG AceListLength
    )

/*++

Routine Description:

    This routine adds a string of ACEs to an ACL.

Arguments:

    Acl - Supplies the Acl being modified

    AceRevision - Supplies the Acl/Ace revision of the ACE being added

    StartingAceIndex - Supplies the ACE index which will be the index of
        the first ace inserted in the acl. 0 for the beginning of the list
        and MAXULONG for the end of the list.

    AceList - Supplies the list of Aces to be added to the Acl

    AceListLength - Supplies the size, in bytes, of the AceList buffer

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful, and an appropriate error
        status otherwise

--*/

{
    PVOID FirstFree;

    PACE_HEADER Ace;
    ULONG NewAceCount;

    PVOID AcePosition;
    ULONG i;
    UCHAR NewRevision;


    //
    //  Check the ACL structure
    //

    if (!ADSIRtlValidAcl(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Locate the first free ace and check to see that the Acl is
    //  well formed.
    //

    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    // If the AceRevision is greater than the ACL revision, then we want to
    // increase the ACL revision to be the same as the new ACE revision.
    // We can do this because our previously defined ACE types ( 0 -> 3 ) have
    // not changed structure nor been discontinued in the new revision.  So
    // we can bump the revision and the older types will not be misinterpreted.
    //
    // Compute what the final revision of the ACL is going to be, and save it
    // for later so we can update it once we know we're going to succeed.
    //

    NewRevision = (UCHAR)AceRevision > Acl->AclRevision ? (UCHAR)AceRevision : Acl->AclRevision;

    //
    // Check that the AceList is well formed, we do this by simply zooming
    // down the Ace list until we're equal to or have exceeded the ace list
    // length.  If we are equal to the length then we're well formed otherwise
    // we're ill-formed.  We'll also calculate how many Ace's there are
    // in the AceList
    //
    // In addition, now we have to make sure that we haven't been handed an
    // ACE type that is inappropriate for the AceRevision that was passed
    // in.
    //

    for (Ace = (PACE_HEADER)AceList, NewAceCount = 0;
         Ace < (PACE_HEADER)((PUCHAR)AceList + AceListLength);
         Ace = (PACE_HEADER)NextAce( Ace ), NewAceCount++) {

        //
        // Ensure the ACL revision allows this ACE type.
        //

        if ( Ace->AceType <= ACCESS_MAX_MS_V2_ACE_TYPE ) {
            // V2 ACE are always valid.
        } else if ( Ace->AceType <= ACCESS_MAX_MS_V3_ACE_TYPE ) {
            if ( AceRevision < ACL_REVISION3 ) {
                return STATUS_INVALID_PARAMETER;
            }
        } else if ( Ace->AceType <= ACCESS_MAX_MS_V4_ACE_TYPE ) {
            if ( AceRevision < ACL_REVISION4 ) {
                return STATUS_INVALID_PARAMETER;
            }
        }
    }

    //
    //  Check to see if we've exceeded the ace list length
    //

    if (Ace > (PACE_HEADER)((PUCHAR)AceList + AceListLength)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Check to see if there is enough room in the Acl to store the additional
    //  Ace list
    //

    if (FirstFree == NULL ||
        (PUCHAR)FirstFree + AceListLength > (PUCHAR)Acl + Acl->AclSize) {

        return STATUS_BUFFER_TOO_SMALL;

    }

    //
    //  All of the input has checked okay, we now need to locate the position
    //  where to insert the new ace list.  We won't check the acl for
    //  validity because we did earlier when got the first free ace position.
    //

    AcePosition = FirstAce( Acl );

    for (i = 0; i < StartingAceIndex && i < Acl->AceCount; i++) {

        AcePosition = NextAce( AcePosition );

    }

    //
    //  Now Ace points to where we want to insert the ace list,  We do the
    //  insertion by adding ace list to the acl and shoving over the remainder
    //  of the list down the acl.  We know this will work because we earlier
    //  check to make sure the new acl list will fit in the acl size
    //

    ADSIRtlpAddData( AceList, AceListLength,
             AcePosition, (ULONG)((PUCHAR)FirstFree - (PUCHAR)AcePosition));

    //
    //  Update the Acl Header
    //

    Acl->AceCount = (USHORT)(Acl->AceCount + NewAceCount);

    Acl->AclRevision = NewRevision;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
ADSIRtlDeleteAce (
    IN OUT PACL Acl,
    IN ULONG AceIndex
    )

/*++

Routine Description:

    This routine deletes one ACE from an ACL.

Arguments:

    Acl - Supplies the Acl being modified

    AceIndex - Supplies the index of the Ace to delete.

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    PVOID FirstFree;

    PACE_HEADER Ace;
    ULONG i;


    //
    //  Check the ACL structure
    //

    if (!ADSIRtlValidAcl(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Make sure the AceIndex is within proper range, it's ulong so we know
    //  it can't be negative
    //

    if (AceIndex >= Acl->AceCount) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Locate the first free spot, this will tell us how much data
    //  we'll need to colapse.  If the results is false then the acl is
    //  ill-formed
    //

    if (!RtlFirstFreeAce( Acl, &FirstFree )) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Now locate the ace that we're going to delete.  This loop
    //  doesn't need to check the acl for being well formed.
    //

    Ace = (PACE_HEADER)FirstAce( Acl );

    for (i = 0; i < AceIndex; i++) {

        Ace = (PACE_HEADER)NextAce( Ace );

    }

    //
    //  We've found the ace to delete to simply copy over the rest of
    //  the acl over this ace.  The delete data procedure also deletes
    //  rest of the string that it's moving over so we don't have to
    //

    ADSIRtlpDeleteData( Ace, Ace->AceSize, (ULONG)((PUCHAR)FirstFree - (PUCHAR)Ace));

    //
    //  Update the Acl header
    //

    Acl->AceCount--;

    //
    //  And return to our caller
    //

    return STATUS_SUCCESS;
}


NTSTATUS
ADSIRtlGetAce (
    IN PACL Acl,
    ULONG AceIndex,
    OUT PVOID *Ace
    )

/*++

Routine Description:

    This routine returns a pointer to an ACE in an ACl referenced by
    ACE index

Arguments:

    Acl - Supplies the ACL being queried

    AceIndex - Supplies the Ace index to locate

    Ace - Receives the address of the ACE within the ACL

Return Value:

    NTSTATUS - STATUS_SUCCESS if successful and an appropriate error
        status otherwise

--*/

{
    ULONG i;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return GetAce(Acl, AceIndex, Ace);
    }   

    //
    //  Check the ACL revision level
    //

    if (!ValidAclRevision(Acl)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  Check the AceIndex against the Ace count of the Acl, it's ulong so
    //  we know it can't be negative
    //

    if (AceIndex >= Acl->AceCount) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  To find the Ace requested by zooming down the Ace List.
    //

    *Ace = FirstAce( Acl );

    for (i = 0; i < AceIndex; i++) {

        //
        //  Check to make sure we haven't overrun the Acl buffer
        //  with our ace pointer.  If we have then our input is bogus
        //

        if (*Ace >= (PVOID)((PUCHAR)Acl + Acl->AclSize)) {

            return STATUS_INVALID_PARAMETER;

        }

        //
        //  And move Ace to the next ace position
        //

        *Ace = NextAce( *Ace );

    }

    //
    //  Now Ace points to the Ace we're after, but make sure we aren't
    //  beyond the Acl.
    //

    if (*Ace >= (PVOID)((PUCHAR)Acl + Acl->AclSize)) {

        return STATUS_INVALID_PARAMETER;

    }

    //
    //  The Ace is still within the Acl so return success to our caller
    //

    return STATUS_SUCCESS;

}



BOOL
ADSIIsValidAcl (
    PACL pAcl
    )
/*++

Routine Description:

    This procedure validates an ACL.

    This involves validating the revision level of the ACL and ensuring
    that the number of ACEs specified in the AceCount fit in the space
    specified by the AclSize field of the ACL header.

Arguments:

    pAcl - Pointer to the ACL structure to validate.

Return Value:

    BOOLEAN - TRUE if the structure of Acl is valid.


--*/
{
    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return IsValidAcl(pAcl);
    }
    return (BOOL) ADSIRtlValidAcl (
                    pAcl
                    );
}


BOOL
ADSIInitializeAcl (
    PACL pAcl,
    DWORD nAclLength,
    DWORD dwAclRevision
    )
/*++

Routine Description:

    InitializeAcl creates a new ACL in the caller supplied memory
    buffer.  The ACL contains zero ACEs; therefore, it is an empty ACL
    as opposed to a nonexistent ACL.  That is, if the ACL is now set
    to an object it will implicitly deny access to everyone.

Arguments:

    pAcl - Supplies the buffer containing the ACL being initialized

    nAclLength - Supplies the length of the ace buffer in bytes

    dwAclRevision - Supplies the revision for this Acl

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return InitializeAcl(pAcl, nAclLength, dwAclRevision);
    }

    Status = ADSIRtlCreateAcl (
                pAcl,
                nAclLength,
                dwAclRevision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



BOOL
ADSIGetAclInformation (
    PACL pAcl,
    PVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    )
/*++

Routine Description:

    This routine returns to the caller information about an ACL.  The requested
    information can be AclRevisionInformation, or AclSizeInformation.

Arguments:

    pAcl - Supplies the Acl being examined

    pAclInformation - Supplies the buffer to receive the information
        being requested

    nAclInformationLength - Supplies the length of the AclInformation
        buffer in bytes

    dwAclInformationClass - Supplies the type of information being
        requested

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return GetAclInformation(
                   pAcl,
                   pAclInformation,
                   nAclInformationLength,
                   dwAclInformationClass
                   );
    }

    Status = ADSIRtlQueryInformationAcl (
                pAcl,
                pAclInformation,
                nAclInformationLength,
                dwAclInformationClass
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}




BOOL
ADSISetAclInformation (
    PACL pAcl,
    PVOID pAclInformation,
    DWORD nAclInformationLength,
    ACL_INFORMATION_CLASS dwAclInformationClass
    )
/*++

Routine Description:

    This routine sets the state of an ACL.  For now only the revision
    level can be set and for now only a revision level of 1 is accepted
    so this procedure is rather simple

Arguments:

    pAcl - Supplies the Acl being altered

    pAclInformation - Supplies the buffer containing the information
        being set

    nAclInformationLength - Supplies the length of the Acl information
        buffer

    dwAclInformationClass - Supplies the type of information begin set

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;
    
    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return SetAclInformation(
                   pAcl,
                   pAclInformation,
                   nAclInformationLength,
                   dwAclInformationClass
                   );
    }

    Status = ADSIRtlSetInformationAcl (
                pAcl,
                pAclInformation,
                nAclInformationLength,
                dwAclInformationClass
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
ADSIAddAce (
    PACL pAcl,
    DWORD dwAceRevision,
    DWORD dwStartingAceIndex,
    PVOID pAceList,
    DWORD nAceListLength
    )
/*++

Routine Description:

    This routine adds a string of ACEs to an ACL.

Arguments:

    pAcl - Supplies the Acl being modified

    dwAceRevision - Supplies the Acl/Ace revision of the ACE being
        added

    dwStartingAceIndex - Supplies the ACE index which will be the
        index of the first ace inserted in the acl.  0 for the
        beginning of the list and MAXULONG for the end of the list.

    pAceList - Supplies the list of Aces to be added to the Acl

    nAceListLength - Supplies the size, in bytes, of the AceList
        buffer

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.


--*/
{
    NTSTATUS Status;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return AddAce( 
                   pAcl,
                   dwAceRevision,
                   dwStartingAceIndex,
                   pAceList,
                   nAceListLength
                   );
    }

    Status = ADSIRtlAddAce (
        pAcl,
        dwAceRevision,
        dwStartingAceIndex,
        pAceList,
        nAceListLength
        );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
ADSIDeleteAce (
    PACL pAcl,
    DWORD dwAceIndex
    )
/*++

Routine Description:

    This routine deletes one ACE from an ACL.

Arguments:

    pAcl - Supplies the Acl being modified

    dwAceIndex - Supplies the index of the Ace to delete.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        return DeleteAce(pAcl, dwAceIndex);
    }

    Status = ADSIRtlDeleteAce (
                pAcl,
                dwAceIndex
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
ADSIGetAce (
    PACL pAcl,
    DWORD dwAceIndex,
    PVOID *pAce
    )
/*++

Routine Description:

    This routine returns a pointer to an ACE in an ACl referenced by
    ACE index

Arguments:

    pAcl - Supplies the ACL being queried

    dwAceIndex - Supplies the Ace index to locate

    pAce - Receives the address of the ACE within the ACL

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    Status = ADSIRtlGetAce (
                pAcl,
                dwAceIndex,
                pAce
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}



//
//  Internal support routine
//

VOID
ADSIRtlpAddData (
    IN PVOID From,
    IN ULONG FromSize,
    IN PVOID To,
    IN ULONG ToSize
    )

/*++

Routine Description:

    This routine copies data to a string of bytes.  It does this by moving
    over data in the to string so that the from string will fit.  It also
    assumes that the checks that the data will fit in memory have already
    been done.  Pictorally the results are as follows.

    Before:

        From -> ffffffffff

        To   -> tttttttttttttttt

    After:

        From -> ffffffffff

        To   -> fffffffffftttttttttttttttt

Arguments:

    From - Supplies a pointer to the source buffer

    FromSize - Supplies the size of the from buffer in bytes

    To - Supplies a pointer to the destination buffer

    ToSize - Supplies the size of the to buffer in bytes

Return Value:

    None

--*/

{
    LONG i;

    //
    //  Shift over the To buffer enough to fit in the From buffer
    //

    for (i = ToSize - 1; i >= 0; i--) {

        ((PUCHAR)To)[i+FromSize] = ((PUCHAR)To)[i];
    }

    //
    //  Now copy over the From buffer
    //

    for (i = 0; (ULONG)i < FromSize; i += 1) {

        ((PUCHAR)To)[i] = ((PUCHAR)From)[i];

    }

    //
    //  and return to our caller
    //

    return;

}


//
//  Internal support routine
//

VOID
ADSIRtlpDeleteData (
    IN PVOID Data,
    IN ULONG RemoveSize,
    IN ULONG TotalSize
    )

/*++

Routine Description:

    This routine deletes a string of bytes from the front of a data buffer
    and compresses the data.  It also zeros out the part of the string
    that is no longer in use.  Pictorially the results are as follows

    Before:

        Data       = DDDDDddddd
        RemoveSize = 5
        TotalSize  = 10

    After:

        Data      = ddddd00000

Arguments:

    Data - Supplies a pointer to the data being altered

    RemoveSize - Supplies the number of bytes to delete from the front
        of the data buffer

    TotalSize - Supplies the total number of bytes in the data buffer
        before the delete operation

Return Value:

    None

--*/

{
    ULONG i;

    //
    //  Shift over the buffer to remove the amount
    //

    for (i = RemoveSize; i < TotalSize; i++) {

        ((PUCHAR)Data)[i-RemoveSize] = ((PUCHAR)Data)[i];

    }

    //
    //  Now as a safety precaution we'll zero out the rest of the string
    //

    for (i = TotalSize - RemoveSize; i < TotalSize; i++) {

        ((PUCHAR)Data)[i] = 0;
    }

    //
    //  And return to our caller
    //

    return;

}



ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    )

/*++

Routine Description:

    This API sets the "last error value" and the "last error string"
    based on the value of Status. For status codes that don't have
    a corresponding error string, the string is set to null.

Arguments:

    Status - Supplies the status value to store as the last error value.

Return Value:

    The corresponding Win32 error code that was stored in the
    "last error value" thread variable.

--*/

{
    ULONG dwErrorCode;

    dwErrorCode = RtlNtStatusToDosError( Status );
    SetLastError( dwErrorCode );
    return( dwErrorCode );
}




NTSTATUS
ADSIRtlGetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR_CONTROL Control,
    OUT PULONG Revision
    )

/*++

Routine Description:

    This procedure retrieves the control information from a security descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    Control - Receives the control information.

    Revision - Receives the revision of the security descriptor.
               This value will always be returned, even if an error
               is returned by this routine.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{

    //
    // Always return the revision value - even if this isn't a valid
    // security descriptor
    //

    *Revision = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision;


    if ( ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Revision
         != SECURITY_DESCRIPTOR_REVISION ) {
        return STATUS_UNKNOWN_REVISION;
    }


    *Control = ((SECURITY_DESCRIPTOR *)SecurityDescriptor)->Control;

    return STATUS_SUCCESS;

}

NTSTATUS
ADSIRtlSetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    )
/*++

Routine Description:

    This procedure sets the control information in a security descriptor.


    For instance,

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      SE_DACL_PROTECTED );

    marks the DACL on the security descriptor as protected. And

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      0 );


    marks the DACL as not protected.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    ControlBitsOfInterest - A mask of the control bits being changed, set,
        or reset by this call.  The mask is the logical OR of one or more of
        the following flags:

            SE_DACL_UNTRUSTED
            SE_SERVER_SECURITY
            SE_DACL_AUTO_INHERIT_REQ
            SE_SACL_AUTO_INHERIT_REQ
            SE_DACL_AUTO_INHERITED
            SE_SACL_AUTO_INHERITED
            SE_DACL_PROTECTED
            SE_SACL_PROTECTED

    ControlBitsToSet - A mask indicating what the bits specified by ControlBitsOfInterest
        should be set to.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
#define SE_VALID_CONTROL_BITS ( SE_DACL_UNTRUSTED | \
                                SE_SERVER_SECURITY | \
                                SE_DACL_AUTO_INHERIT_REQ | \
                                SE_SACL_AUTO_INHERIT_REQ | \
                                SE_DACL_AUTO_INHERITED | \
                                SE_SACL_AUTO_INHERITED | \
                                SE_DACL_PROTECTED | \
                                SE_SACL_PROTECTED )
    //
    // Ensure the caller passed valid bits.
    //

    if ( (ControlBitsOfInterest & ~SE_VALID_CONTROL_BITS) != 0 ||
         (ControlBitsToSet & ~ControlBitsOfInterest) != 0 ) {
        return STATUS_INVALID_PARAMETER;
    }

    ((SECURITY_DESCRIPTOR *)pSecurityDescriptor)->Control &= ~ControlBitsOfInterest;
    ((SECURITY_DESCRIPTOR *)pSecurityDescriptor)->Control |= ControlBitsToSet;

    return STATUS_SUCCESS;
}



BOOL
ADSIGetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    OUT PSECURITY_DESCRIPTOR_CONTROL Control,
    OUT PULONG Revision
    )

/*++

Routine Description:

    This procedure retrieves the control information from a security descriptor.

Arguments:

    SecurityDescriptor - Supplies the security descriptor.

    Control - Receives the control information.

    Revision - Receives the revision of the security descriptor.
               This value will always be returned, even if an error
               is returned by this routine.

Return Value:

    STATUS_SUCCESS - Indicates the call completed successfully.

    STATUS_UNKNOWN_REVISION - Indicates the revision of the security
        descriptor is not known to the routine.  It may be a newer
        revision than the routine knows about.


--*/

{
    NTSTATUS Status;

    Status = ADSIRtlGetControlSecurityDescriptor (
                SecurityDescriptor,
                Control,
                Revision
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}

BOOL
ADSISetControlSecurityDescriptor (
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
    IN SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    )
/*++

Routine Description:

    This procedure sets the control information in a security descriptor.


    For instance,

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      SE_DACL_PROTECTED );

    marks the DACL on the security descriptor as protected. And

        SetSecurityDescriptorControl( &SecDesc,
                                      SE_DACL_PROTECTED,
                                      0 );


    marks the DACL as not protected.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor.

    ControlBitsOfInterest - A mask of the control bits being changed, set,
        or reset by this call.  The mask is the logical OR of one or more of
        the following flags:

            SE_DACL_UNTRUSTED
            SE_SERVER_SECURITY
            SE_DACL_AUTO_INHERIT_REQ
            SE_SACL_AUTO_INHERIT_REQ
            SE_DACL_AUTO_INHERITED
            SE_SACL_AUTO_INHERITED
            SE_DACL_PROTECTED
            SE_SACL_PROTECTED

    ControlBitsToSet - A mask indicating what the bits specified by ControlBitsOfInterest
        should be set to.

Return Value:

    Returns TRUE for success, FALSE for failure.  Extended error status
    is available using GetLastError.

--*/
{
    NTSTATUS Status;

    if (!g_fPlatformDetermined) {
        UpdatePlatformInfo();
    }

    //
    // Call WinAPI if this is Win2k.
    //
    if (g_fPlatformNotNT4) {
        //
        // In this case we should be able to load
        // the function from advapi32 and should not
        // use our private api.
        //
        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
        return FALSE;
    }

    Status = ADSIRtlSetControlSecurityDescriptor (
                pSecurityDescriptor,
                ControlBitsOfInterest,
                ControlBitsToSet
                );

    if ( !NT_SUCCESS(Status) ) {
        BaseSetLastNTError(Status);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\auto_cs.h ===
//
// auto_cs.h    CRITICAL_SECTION
//

#pragma once


class auto_leave;

class auto_cs
{
public:
    auto_cs()
    {   InitializeCriticalSection(&m_cs); }

    ~auto_cs()
    {
        DeleteCriticalSection(&m_cs);
    };

    // return value of current dumb pointer
    LPCRITICAL_SECTION  get() 
    { return &m_cs; };

    LPCRITICAL_SECTION  get() const
    { return (LPCRITICAL_SECTION)&m_cs; };

protected:
    CRITICAL_SECTION m_cs;
};


class auto_leave
{
public:
    auto_leave(auto_cs& cs)
        : m_ulCount(0), m_pcs(cs.get()) {}
    auto_leave(const auto_cs&  cs) 
    {
        m_ulCount =0;
        m_pcs = cs.get();
    }
  
    ~auto_leave()
    {
        reset();
    }
	auto_leave& operator=(auto_cs& cs)
	{
		reset();
		m_pcs = cs.get();
		return *this;
	}

    void EnterCriticalSection()
    { ::EnterCriticalSection(m_pcs); m_ulCount++; }
    void LeaveCriticalSection()
    {
    	if (m_ulCount)
    	{
    		m_ulCount--;
    		::LeaveCriticalSection(m_pcs);
    	}
	}
	//Note: Win95 doesn't support TryEnterCriticalSection.
	//Commenting out this since we don't use it. [mgorti]

	//BOOL TryEnterCriticalSection()
	//{
	//	if (::TryEnterCriticalSection(m_pcs))
	//	{
	//		m_ulCount++;
	//		return TRUE;
	//	}
	//	return FALSE;
	//}
protected:
	void reset()
	{
		while (m_ulCount)
        {
            LeaveCriticalSection();
        }
        m_pcs = 0;
	}
	ULONG				m_ulCount;
    LPCRITICAL_SECTION	m_pcs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\caccess.cxx ===
//-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  caccess.cxx
//
//  Contents:  Microsoft OleDB/OleDS Data Source Object for ADSI
//
//             CImpIAccessor object implementing the IAccessor interface.
//
//  History:   10-01-96     shanksh    Created.
//-------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//-------------------------------------------------------------------------
// CImpIAccessor::CImpIAccessor
//
// CImpIAccessor constructor.
//
//-------------------------------------------------------------------------

CImpIAccessor::CImpIAccessor (
    void      *pParentObj,        //@parm IN | Parent object pointer
    LPUNKNOWN pUnkOuter            //@parm IN | Outer Unknown pointer
    )
{
    //    Initialize simple member vars
    _pUnkOuter   = pUnkOuter;
    _pObj        = pParentObj;
    _pextbuffer  = NULL;
    _dwStatus    = 0;
    _pIDC        = NULL;
    _fCriticalSectionInitialized = FALSE;
    _pIMalloc = NULL;

    ENLIST_TRACKING(CImpIAccessor);

    return;
}


//-------------------------------------------------------------------------
// CImpIAccessor::~CImpIAccessor
//
// @mfunc CImpIAccessor destructor.
//
// @rdesc NONE
//-------------------------------------------------------------------------

CImpIAccessor::~CImpIAccessor (
    void
    )
{
    ULONG_PTR         hAccessor,   hAccessorLast;
    PADSACCESSOR pADsaccessor, pADsaccessorBadHandle;

    // Cleanup only if there's anything to clean.
    if( _pextbuffer ) {
        // Get a pointer to the special "BadHandle" accessor.
        _pextbuffer->GetItemOfExtBuffer(hAccessorBadHandle, &pADsaccessorBadHandle);

        // Get the number of available accessor handles.
        _pextbuffer->GetLastItemHandle(hAccessorLast);

        // Loop through the reminding accessor handles deleting those which
        // are referenced only by this object and refcount decrementing the
        // other ones
        for (hAccessor =1; hAccessor <=hAccessorLast; hAccessor++) {
            // Get a pointer to the next accessor.
            _pextbuffer->GetItemOfExtBuffer(hAccessor, &pADsaccessor);

            // For valid accessors just delete them.
            if( pADsaccessor != pADsaccessorBadHandle )
                DeleteADsAccessor(pADsaccessor);
        }
        // Now delete the buffer which holds accessor handles.
        delete _pextbuffer;
    }

    if( _pIMalloc )
        _pIMalloc->Release();

    if( _pIDC )
        _pIDC->Release();

    // Get rid of the critical section.
    if (_fCriticalSectionInitialized)
    {
        DeleteCriticalSection(&_criticalsectionAccessor);
    }

    return;
}


//-------------------------------------------------------------------------
// CImpIAccessor::FInit
//
// @mfunc Initialize the Accessor implementation object.
//
// @rdesc Did the Initialization Succeed
//         @flag S_OK               initialization succeeded,
//         @flag E_OUTOFMEMORY      initialization failed because of
//                                  memory allocation problem,
//-------------------------------------------------------------------------

STDMETHODIMP
CImpIAccessor::FInit (
    void
    )
{
    HRESULT hr;
    PADSACCESSOR pADsaccessorBadHandle;

    // Prepare a special, "Bad Handle" accessor.
    pADsaccessorBadHandle = (PADSACCESSOR)((BYTE *)&_dwGetDataTypeBadHandle);
    _dwGetDataTypeBadHandle = ACCESSORTYPE_INERROR;

    // Create the ExtBuffer array to hold pointers to malloc'd accessors.
    _pextbuffer = (LPEXTBUFF) new CExtBuff;
    if (_pextbuffer == NULL    ||
        !(_pextbuffer->FInit(
              sizeof(PADSACCESSOR),
              &pADsaccessorBadHandle
              ) ))
                RRETURN( E_OUTOFMEMORY );

    if( !_pIDC ) {
        hr = CoCreateInstance(
                 CLSID_OLEDB_CONVERSIONLIBRARY,
                 NULL,
                 CLSCTX_INPROC_SERVER,
                 IID_IDataConvert,
                 (void **)&_pIDC
                 );
        if ( FAILED(hr) ) {
            RRETURN (hr);
                }
    }

    hr = CoGetMalloc(MEMCTX_TASK, &_pIMalloc);

    if (SUCCEEDED(hr))
    {
        try
        {
            // This section is for serializing &CreateAccessor.
            InitializeCriticalSection(&_criticalsectionAccessor);

            _fCriticalSectionInitialized = TRUE;
        }
        catch(...)
        {
            hr = E_FAIL;
        }
    }

    RRETURN (hr);
}



//-------------------------------------------------------------------------
// CImpIAccessor::AddRefAccessor
//
// @mfunc Adds a reference count to an existing accessor.
//
// @rdesc Did release of the accessor Succeed
//         @flag S_OK                   | accessor addrefed successfully,
//         @flag DB_E_BADACCESSORHANDLE | accessor could not be addrefed
//                                        because its handle was invalid.
//-------------------------------------------------------------------------

STDMETHODIMP CImpIAccessor::AddRefAccessor(
    HACCESSOR   hAccessor,    //@parm IN  | handle of the accessor to release
    DBREFCOUNT *pcRefCounts    //@parm OUT | count of references
    )
{
    PADSACCESSOR pADsaccessor, pADsaccessorBadHandle;
    HRESULT hr;

    // Clear in case of error below.
    if( pcRefCounts )
        *pcRefCounts = 0;

    CAutoBlock     cab( &(_criticalsectionAccessor) );

    // Get a pointer to the accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessor, &pADsaccessor);

    // Get a pointer to the special "BadHandle" accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessorBadHandle, &pADsaccessorBadHandle);

    // If the handle is valid
    if (pADsaccessor != pADsaccessorBadHandle) {
        if (pADsaccessor->cRef <= 0)
            BAIL_ON_FAILURE( hr = E_FAIL );

        pADsaccessor->cRef++;

        if (pcRefCounts)
            *pcRefCounts = pADsaccessor->cRef;

        RRETURN( S_OK );
    }
    // otherwise complain about a bad handle.
    else
        RRETURN( DB_E_BADACCESSORHANDLE );

error:

    RRETURN( hr );
}



//-------------------------------------------------------------------------
// CImpIAccessor::CreateAccessor
//
// @mfunc Creates an accessor, which is a set of bindings that can be used to
// send data to or retrieve data from the data cache. The method performs
// extensive validations on the input bindings which include verification of
// the access type requested, column availability, data conversions involved,
// etc.
//
// @rdesc Returns one of the following values:
//    S_OK                    | creation of the accessor succeeded,
//    E_INVALIDARG            | creation of the accessor failed because
//                              phAccessor was a NULL pointer,
//    E_OUTOFMEMORY           | creation of the accessor failed because of
//                              memory allocation problem,
//    DB_E_CANTCREATEACCESSOR | DBROWSETFLAGS_MULTIPLEACCESSOR flag was not
//                              set and a row-fetching method has already
//                              been called.
//    OTHER                   | other result codes returned by called functions.
//-------------------------------------------------------------------------

STDMETHODIMP CImpIAccessor::CreateAccessor(
    DBACCESSORFLAGS dwAccessorFlags,
    DBCOUNTITEM     cBindings,
    const DBBINDING rgBindings[],
    DBLENGTH        cbRowSize,
    HACCESSOR       *phAccessor,
    DBBINDSTATUS    rgStatus[]
    )
{
    PADSACCESSOR pADsaccessor;
    ULONG_PTR hADsaccessor;
    HRESULT hr;
    ULONG dwGetDataType, dwSetDataType;
    DBCOUNTITEM ibind;
    BOOL fProviderOwned;
    DBBINDSTATUS bindstatus;
    ULONG wMask, wBaseType;

    if (phAccessor)
        *phAccessor = (HACCESSOR)0;

    // At the creation of the CAutoBlock object a critical section
    // is entered. Concurrent calls to CreateAccessor are entirely
    // legal but their interleaving cannot be allowed. The critical
    // section is left when this method terminate and the destructor
    // for CAutoBlock is called.
    CAutoBlock     cab( &(_criticalsectionAccessor) );

    // phAccessor must never be NULL, non-zero bindings count implies a
    // non-NULL array of bindings.
    if( phAccessor == NULL || (cBindings && rgBindings == NULL) )
        RRETURN( E_INVALIDARG );

    // cBindings is 0 and was called on the Command.
    if( cBindings == 0 )
        RRETURN( DB_E_NULLACCESSORNOTSUPPORTED );

    // dwAccessorFlags cannot take any other values than those legal.
    if( dwAccessorFlags & (~DBACCESSOR_VALID_FLAGS) )
        RRETURN( DB_E_BADACCESSORFLAGS );

    // Compute internal types for use by methods using accessors,
    DetermineTypes(
        dwAccessorFlags,
        &dwGetDataType,
        &dwSetDataType
        );

    // and detect possible inconsistencies in AccessorFlags.
    if( dwGetDataType == GD_ACCESSORTYPE_INERROR ||
        dwSetDataType == SD_ACCESSORTYPE_INERROR )
        RRETURN( DB_E_BADACCESSORFLAGS );

    // fix conformance test failure. If BYREF accessors are not supported,
    // (indicated by DBPROP_BYREFACCESSORS being FALSE), we should return 
    // the right error
    else if( (DB_E_BYREFACCESSORNOTSUPPORTED == dwGetDataType) ||
             (DB_E_BYREFACCESSORNOTSUPPORTED == dwSetDataType) )
        RRETURN( DB_E_BYREFACCESSORNOTSUPPORTED );

    // Initialize the status array to DBBINDSTATUS_OK.
    if( rgStatus )
        memset(rgStatus, 0x00, (size_t)(cBindings*sizeof(DBBINDSTATUS)));

    hr             = S_OK;
    fProviderOwned = FALSE;

    // Perform validations that apply to all types of accessors.
    for (ibind=0; ibind < cBindings; ibind++) {
        bindstatus = DBBINDSTATUS_OK;

        if( rgBindings[ibind].dwMemOwner != DBMEMOWNER_PROVIDEROWNED &&
                        rgBindings[ibind].dwMemOwner != DBMEMOWNER_CLIENTOWNED )
            bindstatus = DBBINDSTATUS_BADBINDINFO;

        // The part to be bound must specify one or more out of three values, and
        if( (rgBindings[ibind].dwPart &
            (DBPART_VALUE |DBPART_LENGTH |DBPART_STATUS)) == 0 ||
             // nothing else.
            (rgBindings[ibind].dwPart &
             ~(DBPART_VALUE |DBPART_LENGTH |DBPART_STATUS)) ||
             // Is it a good type to bind to?
            !IsGoodBindingType(rgBindings[ibind].wType) )
            bindstatus = DBBINDSTATUS_BADBINDINFO;

        // DBTYPE_BYREF, DBTYPE_VECTOR and DBTYPE_ARRAY cannot be combined.
        else if( (wMask = (rgBindings[ibind].wType & TYPE_MODIFIERS)) &&
                        wMask != DBTYPE_BYREF &&
                        wMask != DBTYPE_VECTOR &&
                        wMask != DBTYPE_ARRAY )
                        bindstatus = DBBINDSTATUS_BADBINDINFO;

        else if ((wBaseType = (rgBindings[ibind].wType & ~TYPE_MODIFIERS)) ==
                  DBTYPE_EMPTY ||
                 wBaseType == DBTYPE_NULL)
            bindstatus = DBBINDSTATUS_BADBINDINFO;

        // DBTYPE_ARRAY and DBTYPE_VECTOR are not supported types
        else if( (rgBindings[ibind].wType & DBTYPE_ARRAY) ||
                 (rgBindings[ibind].wType & DBTYPE_VECTOR) )
            bindstatus = DBBINDSTATUS_UNSUPPORTEDCONVERSION;

        // dwFlags was DBBINDFLAG_HTML and the type was not a String
        else if ( rgBindings[ibind].dwFlags &&
                  (rgBindings[ibind].dwFlags != DBBINDFLAG_HTML ||
                   (wBaseType != DBTYPE_STR  &&
                    wBaseType != DBTYPE_WSTR &&
                    wBaseType != DBTYPE_BSTR)) )
        {
            // Set Bind status to DBBINDSTATUS_BADBINDINFO
            bindstatus = DBBINDSTATUS_BADBINDINFO;
        }
        else if( rgBindings[ibind].wType == (DBTYPE_RESERVED | DBTYPE_BYREF) )
            bindstatus = DBBINDSTATUS_BADBINDINFO;

        else if( rgBindings[ibind].dwMemOwner == DBMEMOWNER_PROVIDEROWNED ) {
            if( (rgBindings[ibind].wType & TYPE_MODIFIERS) == 0
                && rgBindings[ibind].wType != DBTYPE_BSTR )
                bindstatus = DBBINDSTATUS_BADBINDINFO;
            else
                fProviderOwned = TRUE;
        }

        if( bindstatus != DBBINDSTATUS_OK )
            hr = DB_E_ERRORSOCCURRED;

        if( rgStatus )
            rgStatus[ibind] = bindstatus;
    }

    // Check for errors in the bindings
    BAIL_ON_FAILURE( hr );

    if( fProviderOwned &&
        (dwGetDataType == GD_ACCESSORTYPE_READ ||
         dwGetDataType == GD_ACCESSORTYPE_READ_OPTIMIZED) )
        dwGetDataType = GD_ACCESSORTYPE_READ_COLS_BYREF;

    // Allocate space for the accessor structure.
    pADsaccessor = (ADSACCESSOR *) new BYTE
                                     [(size_t)(sizeof(ADSACCESSOR) + (cBindings ? (cBindings-1) : 0)*
                                                                                           sizeof(DBBINDING))];

        if( pADsaccessor == NULL )
        RRETURN( E_OUTOFMEMORY );

    if( cBindings )
        memcpy(
            &(pADsaccessor->rgBindings[0]),
            &rgBindings[0],
            (size_t)(cBindings*sizeof(DBBINDING))
            );
    pADsaccessor->cBindings = cBindings;

    // For accessors valid for writing fill out a list of columns
    // so that notifications about their changes can be properly issued.
    if( dwSetDataType == SD_ACCESSORTYPE_READWRITE && cBindings ) {
        pADsaccessor->rgcol = new DBORDINAL [ (size_t)cBindings ];
        if( pADsaccessor->rgcol == NULL ) {
            dwSetDataType = SD_ACCESSORTYPE_INERROR;
        }
        else
            for (ibind =0; ibind <cBindings; ibind++)
                (pADsaccessor->rgcol)[ibind] = rgBindings[ibind].iOrdinal;
    }
    else
        pADsaccessor->rgcol = NULL;

    // Allocate DBOBJECT structures supporting IUnknown types.
    for (ibind =0; ibind <cBindings; ibind++)
        pADsaccessor->rgBindings[ibind].pObject = NULL;

    // Set accessor flags now, so that possible accessor cleanup routine would
    // know about additional structures for IUnknown types support.
    pADsaccessor->dwFlags = dwAccessorFlags;

    // Insert the new accessor pointer into the extensible buffer in which
    // accessors are stored.
    if( FAILED(hr = _pextbuffer->InsertIntoExtBuffer(
                         &pADsaccessor,
                         hADsaccessor
                         )) ) {
        DeleteADsAccessor(pADsaccessor);
        RRETURN (hr);
    }

    pADsaccessor->cRef = 1;

    // Fill out the new accessor structure with the binding info.
    //pADsaccessor->obRowData = obRowData;
    pADsaccessor->cbRowSize = cbRowSize;

    // Return the accessor index in the extensible buffer as the accessor
    // handle.
    *phAccessor = (HACCESSOR) hADsaccessor;

    // Now can safely leave.
    RRETURN( NOERROR );

error:

    RRETURN( hr );
}


//-------------------------------------------------------------------------
// CImpIAccessor::DetermineTypes
//
// @mfunc Determines internal accessor type classification for use by GetData,
// SetData and parameter handling code. Each of these has a separate type indicator
// variable and a separate set of defined types. This allows a very efficient
// handling of different accessors by methods that utilize them.
// Types are determined on the basis of AccessorFlags. Incorrect combinations of
// flags result in assignment of INERROR types.
//
// @rdesc NONE
//-------------------------------------------------------------------------

STDMETHODIMP_(void)
CImpIAccessor::DetermineTypes(
    DBACCESSORFLAGS    dwAccessorFlags,
    ULONG            *pdwGetDataType,
    ULONG            *pdwSetDataType
    )
{
    if( dwAccessorFlags & DBACCESSOR_PASSBYREF )
    {
        *pdwGetDataType = (ULONG) DB_E_BYREFACCESSORNOTSUPPORTED;
        *pdwSetDataType = (ULONG) DB_E_BYREFACCESSORNOTSUPPORTED;

        return;
    }
    else if( dwAccessorFlags & DBACCESSOR_PARAMETERDATA )
    {
         *pdwGetDataType = GD_ACCESSORTYPE_INERROR;
         *pdwSetDataType = GD_ACCESSORTYPE_INERROR;
         return;
    }

    // Determine types used in row data manipulations.
    if( dwAccessorFlags & DBACCESSOR_ROWDATA ) {
        // Determine accessor type from the point of
        // view of GetData.
        if( dwAccessorFlags & DBACCESSOR_OPTIMIZED )
            *pdwGetDataType = GD_ACCESSORTYPE_READ_OPTIMIZED;
        else
            *pdwGetDataType = GD_ACCESSORTYPE_READ;

        // Determine accessor type from the point of
        // view of SetData. PASSBYREF is disallowed.
        *pdwSetDataType = SD_ACCESSORTYPE_READWRITE;
    }
    else {
        *pdwGetDataType = GD_ACCESSORTYPE_INERROR;
        *pdwSetDataType = GD_ACCESSORTYPE_INERROR;
    }

    return;
}


//-------------------------------------------------------------------------
// CImpIAccessor::GetBindings
//
// @mfunc Returns bindings of an accessor.
//
// @rdesc Returns one of the following values:
//         S_OK           | getting bindings succeeded,
//         E_INVALIDARG   | getting bindings failed because
//                          pdwAccessorFlags or pcBindings or
//                          prgBindings was a NULL pointer,
//         E_OUTOFMEMORY  | getting bindings failed because memory
//                          allocation for the bindings array failed,
//         OTHER          | other result codes stored on the accessor
//                          object and singifying invalid accessor handle.
//-------------------------------------------------------------------------

STDMETHODIMP CImpIAccessor::GetBindings
(
HACCESSOR         hAccessor,            // IN  | accessor handle
DBACCESSORFLAGS    *pdwAccessorFlags,   // OUT | stores accessor flags
DBCOUNTITEM       *pcBindings,          // OUT | stores # of bindings
DBBINDING        **prgBindings          // OUT | stores array of bindings
)
{
    PADSACCESSOR  pADsaccessor;
    PADSACCESSOR  pADsaccessorBadHandle;
    DBCOUNTITEM   ibind;
    DBOBJECT     *pObject;

    if( pcBindings )
       *pcBindings = 0;

    if( prgBindings )
        *prgBindings = NULL;

    if( pdwAccessorFlags )
        *pdwAccessorFlags = DBACCESSOR_INVALID;

    // Are arguments valid?
    if( pdwAccessorFlags == NULL || pcBindings == NULL || prgBindings == NULL )
        RRETURN( E_INVALIDARG );

    // Obtain pointer to the accessor to be used.
    _pextbuffer->GetItemOfExtBuffer(hAccessor, &pADsaccessor);

    // Get a pointer to the special "BadHandle" accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessorBadHandle, &pADsaccessorBadHandle);

    // Recognize bad accessor handles and return appropriate HRESULT.
    if( pADsaccessor == pADsaccessorBadHandle )
        return DB_E_BADACCESSORHANDLE;

    // If necessary allocate the array of binding structures.
    if( pADsaccessor->cBindings ) {
        *prgBindings = (DBBINDING *) _pIMalloc->Alloc((ULONG)(
                           pADsaccessor->cBindings*sizeof(DBBINDING) ));

        if( *prgBindings == NULL )
            RRETURN ( E_OUTOFMEMORY );

        // Copy bindings.
        memcpy(
            *prgBindings,
            pADsaccessor->rgBindings,
            (size_t)(pADsaccessor->cBindings*sizeof(DBBINDING))
            );

        // Loop through bindings and allocate and copy DBOBJECT structs.
        for (ibind=0; ibind <pADsaccessor->cBindings; ibind++) {
            // If the accessor had failed bindings for SetData, we have
            // overloaded an unused structure member with status info, and
            // this needs to be cleaned now.
            (*prgBindings)[ibind].pTypeInfo = NULL;

            if( (*prgBindings)[ibind].pObject ) {
                pObject = (DBOBJECT *) _pIMalloc->Alloc( sizeof(DBOBJECT) );
                if( pObject ) {
                    memcpy(
                        pObject,
                        (*prgBindings)[ibind].pObject,
                        sizeof(DBOBJECT)
                        );
                    (*prgBindings)[ibind].pObject = pObject;
                }
                else {
                    while (ibind--)
                        if( (*prgBindings)[ibind].pObject )
                            _pIMalloc->Free((*prgBindings)[ibind].pObject);

                    _pIMalloc->Free( *prgBindings );
                    *prgBindings = NULL;
                    RRETURN( E_OUTOFMEMORY );
                }
            }
        }
    }

    // Return the count of bindings,
    *pcBindings = pADsaccessor->cBindings;
    // and accessor flags.
    *pdwAccessorFlags = (pADsaccessor->dwFlags & ~DBACCESSOR_REFERENCES_BLOB);

    return S_OK;
}



//-------------------------------------------------------------------------
// CImpIAccessor::ReleaseAccessor
//
// @mfunc Releases accessor. If accessor handle is valid the corresponding accessor
// is either freed (if no one else is using it) or its ref count is decremented.
//
// @rdesc Did release of the accessor Succeed
//         @flag S_OK                      | accessor released successfully,
//         @flag DB_E_BADACCESSORHANDLE | accessor could not be released because its
//                                     | handle was invalid.
//-------------------------------------------------------------------------

STDMETHODIMP CImpIAccessor::ReleaseAccessor
(
HACCESSOR    hAccessor,        //@parm IN  | handle of the accessor to release
DBREFCOUNT  *pcRefCounts    //@parm OUT | ref count of the released accessor
)
{
    PADSACCESSOR pADsaccessor, pADsaccessorBadHandle;

    if( pcRefCounts )
        *pcRefCounts = 0;

    CAutoBlock     cab( &(_criticalsectionAccessor) );

    // Get a pointer to the accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessor, &pADsaccessor);

    // Get a pointer to the special "BadHandle" accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessorBadHandle, &pADsaccessorBadHandle);

    // If the handle is valid
    if( pADsaccessor != pADsaccessorBadHandle ) {
        ADsAssert(pADsaccessor->cRef > 0);

        // Delete if no one else is    using it, otherwise
        if( pADsaccessor->cRef == 1 ) {
            // Delete the accessor structure itself, as well as allocations
            // hanging off this structure.
            DeleteADsAccessor(pADsaccessor);

            // Make sure this handle is marked as "Bad" for future.
            _pextbuffer->DeleteFromExtBuffer(hAccessor);
        }
        // decrement the refcount.
        else {
            pADsaccessor->cRef--;

            if( pcRefCounts )
                *pcRefCounts = pADsaccessor->cRef;
        }

        return NOERROR;
    }
    // otherwise complain about a bad handle.
    else
                RRETURN( DB_E_BADACCESSORHANDLE );
}

//-------------------------------------------------------------------------
// CImpIAccessor::DeleteADsAccessor
//
// @mfunc Deletes structures hanging off the ADSACCESSOR and then deletes the
// accessor structure itself.
//
// @rdesc NONE
//-------------------------------------------------------------------------

STDMETHODIMP_(void) CImpIAccessor::DeleteADsAccessor
(
PADSACCESSOR   pADsaccessor        //@parm IN  | Kagera accessor ptr
)
{
    DBCOUNTITEM ibind;

    // Delete the list of affected columns.
    if( pADsaccessor->rgcol )
        delete [] pADsaccessor->rgcol;

    // If the accessor references BLOBS then DBOBJECT structures describing
    // objects dealing with BLOBS need to be deallocated.
    for (ibind =0; ibind <pADsaccessor->cBindings; ibind++)
        if( pADsaccessor->rgBindings[ibind].pObject )
            delete pADsaccessor->rgBindings[ibind].pObject;

    delete [] pADsaccessor;
}


STDMETHODIMP
CImpIAccessor::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    // Is the pointer bad?
    if( ppv == NULL )
        RRETURN( E_INVALIDARG );

    //  Place NULL in *ppv in case of failure
    *ppv = NULL;

    if( IsEqualIID(iid, IID_IUnknown) ) {
        *ppv = (IAccessor FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IAccessor) ) {
        *ppv = (IAccessor FAR *) this;
    }
    else {
        RRETURN( E_NOINTERFACE );
    }

    AddRef();
    return S_OK;
}

//---------------------------------------------------------------------------
// CreateBadAccessor
//
// Inserts a bad accessor into the array of accessors (indexed by accessor
// handles). This is required so that inheritance of accessors from commands
// works correctly. If there are any 'holes' in the command's array of 
// accessors, then a rowset created from the command should also inherit these 
// 'holes' i,e, the array of accessor handles should not be compacted to
// eliminate these holes. This is done using this function.
//
//--------------------------------------------------------------------------- 
HRESULT
CImpIAccessor::CreateBadAccessor(void)
{
    PADSACCESSOR pADsaccessorBadHandle;
    ULONG_PTR        hADsaccessor;
    HRESULT      hr;

    // Get a pointer to the special "BadHandle" accessor.
    _pextbuffer->GetItemOfExtBuffer(hAccessorBadHandle, &pADsaccessorBadHandle);

    // ignore the returned accessor handle
    hr = _pextbuffer->InsertIntoExtBuffer(
                       &pADsaccessorBadHandle, hADsaccessor);

    RRETURN( hr );
}

//---------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\auto_prg.h ===
// auto_prg.h
//
// Same as auto_ptr but for a

#pragma once

#include <xstddef>

template<class _Ty>
class auto_prg
{
public:
	typedef _Ty element_type;

    explicit auto_prg(_Ty *_P = 0) _THROW0()
		: _Owns(_P != 0), _Ptr(_P) {}
	auto_prg(const auto_prg<_Ty>& _Y) _THROW0()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	auto_prg<_Ty>& operator=(const auto_prg<_Ty>& _Y) _THROW0()
		{if (_Ptr != _Y.get())
			{if (_Owns)
				delete [] _Ptr;
			_Owns = _Y._Owns;
			_Ptr = _Y.release(); }
		else if (_Y._Owns)
			_Owns = true;
		return (*this); }
	auto_prg<_Ty>& operator=(_Ty* _Y) _THROW0()
		{	{if (_Owns)
				delete [] _Ptr;
			_Owns = _Y != 0;
			_Ptr = _Y; }
		return (*this); }

	~auto_prg()
		{if (_Owns)
			delete [] _Ptr; }
	_Ty** operator&() _THROW0()
		{ return &_Ptr; }
    operator _Ty* () const
        { return _Ptr; }
    _Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
    _Ty& operator[] (int ndx) const _THROW0()
        {return *(get() + ndx); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() const _THROW0()
		{((auto_prg<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }
protected:
	bool _Owns;
	_Ty *_Ptr;
	};

template<class _Ty>
class pointer
{
public:
	typedef _Ty element_type;

    explicit pointer(_Ty *_P = 0) _THROW0()
		: _Owns(_P != 0), _Ptr(_P) {}
	pointer(const pointer<_Ty>& _Y) _THROW0()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	pointer<_Ty>& operator=(const pointer<_Ty>& _Y) _THROW0()
		{if (_Ptr != _Y.get())
			{if (_Owns)
				delete _Ptr;
			_Owns = _Y._Owns;
			_Ptr = _Y.release(); }
		else if (_Y._Owns)
			_Owns = true;
		return (*this); }
	pointer<_Ty>& operator=(_Ty* _Y) _THROW0()
		{	{if (_Owns)
				delete _Ptr;
			_Owns = _Y != 0;
			_Ptr = _Y; }
		return (*this); }

	~pointer()
		{if (_Owns)
			delete _Ptr; }
	_Ty** operator&() _THROW0()
		{ return &_Ptr; }
    operator _Ty* () const
        { return _Ptr; }
    _Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
    _Ty& operator[] (int ndx) const _THROW0()
        {return *(get() + ndx); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() const _THROW0()
		{((pointer<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }
protected:
	bool _Owns;
	_Ty *_Ptr;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cacecf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsAccessControlEntryCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsAccessControlEntryCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CAccessControlEntry::CreateAccessControlEntry(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\auto_tm.h ===
// auto_tm.h
//
// Same as auto_ptr but for memory freed with CoTaskFreeMem

#pragma once

#include <xstddef>

template<class _Ty>
class auto_tm
{
public:
	typedef _Ty element_type;

    explicit auto_tm(_Ty *_P = 0) _THROW0()
		: _Owns(_P != 0), _Ptr(_P) {}
	auto_tm(const auto_tm<_Ty>& _Y) _THROW0()
		: _Owns(_Y._Owns), _Ptr(_Y.release()) {}
	auto_tm<_Ty>& operator=(const auto_tm<_Ty>& _Y) _THROW0()
		{if (_Ptr != _Y.get())
			{if (_Owns)
				CoTaskMemFree(_Ptr);
			_Owns = _Y._Owns;
			_Ptr = _Y.release(); }
		else if (_Y._Owns)
			_Owns = true;
		return (*this); }
	auto_tm<_Ty>& operator=(_Ty* _Y) _THROW0()
		{	{if (_Owns)
				CoTaskMemFree(_Ptr);
			_Owns = _Y != 0;
			_Ptr = _Y; }
		return (*this); }

	~auto_tm()
		{if (_Owns)
			CoTaskMemFree(_Ptr);}
	_Ty** operator&() _THROW0()
		{ return &_Ptr; }
    operator _Ty* () const
        { return _Ptr; }
    _Ty& operator*() const _THROW0()
		{return (*get()); }
	_Ty *operator->() const _THROW0()
		{return (get()); }
    _Ty& operator[] (int ndx) const _THROW0()
        {return *(get() + ndx); }
	_Ty *get() const _THROW0()
		{return (_Ptr); }
	_Ty *release() const _THROW0()
		{((auto_tm<_Ty> *)this)->_Owns = false;
		return (_Ptr); }
	bool Ownership(bool fOwns)
		{ return _Owns = fOwns; }
protected:
	bool _Owns;
	_Ty *_Ptr;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cace.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cAccessControlEntry.cxx
//
//  Contents:  AccessControlEntry object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CAccessControlEntry

DEFINE_IDispatch_Implementation(CAccessControlEntry)

CAccessControlEntry::CAccessControlEntry():
        _pDispMgr(NULL),
        _dwAceType(0),
        _dwAccessMask(0),
        _dwAceFlags(0),
        _dwFlags(0),
        _lpObjectType(NULL),
        _lpInheritedObjectType(NULL),
        _lpTrustee(NULL),
        _pSid(NULL),
        _dwSidLen(0)
{
    ENLIST_TRACKING(CAccessControlEntry);
}


HRESULT
CAccessControlEntry::CreateAccessControlEntry(
    REFIID riid,
    void **ppvObj
    )
{
    CAccessControlEntry FAR * pAccessControlEntry = NULL;
    HRESULT hr = S_OK;

    hr = AllocateAccessControlEntryObject(&pAccessControlEntry);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pAccessControlEntry->Release();

    RRETURN(hr);

error:
    delete pAccessControlEntry;

    RRETURN_EXP_IF_ERR(hr);

}


CAccessControlEntry::~CAccessControlEntry( )
{
    delete _pDispMgr;
    if (_lpInheritedObjectType) {
        FreeADsStr(_lpInheritedObjectType);
        _lpInheritedObjectType = NULL;
    }
    if (_lpObjectType) {
        FreeADsStr(_lpObjectType);
        _lpObjectType = NULL;
    }
    if (_lpTrustee) {
        FreeADsStr(_lpTrustee);
    }
    if (_pSid) {
        FreeADsMem(_pSid);
    }

}

STDMETHODIMP
CAccessControlEntry::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsAccessControlEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsAccessControlEntry))
    {
        *ppv = (IADsAccessControlEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsAccessControlEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsAcePrivate)) {
        *ppv = (IADsAcePrivate FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CAccessControlEntry::AllocateAccessControlEntryObject(
    CAccessControlEntry ** ppAccessControlEntry
    )
{
    CAccessControlEntry FAR * pAccessControlEntry = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pAccessControlEntry = new CAccessControlEntry();
    if (pAccessControlEntry == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsAccessControlEntry,
                (IADsAccessControlEntry *)pAccessControlEntry,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pAccessControlEntry->_pDispMgr = pDispMgr;
    *ppAccessControlEntry = pAccessControlEntry;

    RRETURN(hr);

error:

    delete pAccessControlEntry;
    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}


//
// ISupportErrorInfo method
//
STDMETHODIMP
CAccessControlEntry::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsAccessControlEntry)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

//
// IADsAccessControlEntry implementation
//

STDMETHODIMP
CAccessControlEntry::get_AceType(THIS_ long FAR * retval)
{
    *retval = _dwAceType;
    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::put_AceType(THIS_ long  lnAceType)
{
    _dwAceType = lnAceType;

    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::get_AceFlags(THIS_ long FAR * retval)
{
    *retval = _dwAceFlags;

    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::put_AceFlags(THIS_ long lnAceFlags)
{
    _dwAceFlags = lnAceFlags;

    RRETURN(S_OK);
}


STDMETHODIMP
CAccessControlEntry::get_Flags(THIS_ long FAR * retval)
{
    *retval = _dwFlags;
    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::put_Flags(THIS_ long  lnFlags)
{
    _dwFlags = lnFlags;

    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::get_AccessMask(THIS_ long FAR * retval)
{

    *retval = (long)_dwAccessMask;

    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::put_AccessMask(THIS_ long lnAccessMask)
{
    _dwAccessMask = (DWORD)lnAccessMask;

    RRETURN(S_OK);
}


STDMETHODIMP
CAccessControlEntry::get_ObjectType(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpObjectType, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CAccessControlEntry::put_ObjectType(THIS_ BSTR bstrObjectType)
{

    if (_lpObjectType) {
        FreeADsStr(_lpObjectType);
        _lpObjectType = NULL;
    }

    if (bstrObjectType) {

        _lpObjectType = AllocADsStr(bstrObjectType);

        if (!_lpObjectType) {
            RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
        }

    }
    RRETURN(S_OK);
}


STDMETHODIMP
CAccessControlEntry::get_InheritedObjectType(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpInheritedObjectType, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CAccessControlEntry::put_InheritedObjectType(THIS_ BSTR bstrInheritedObjectType)
{
    if (_lpInheritedObjectType) {
        FreeADsStr(_lpInheritedObjectType);
        _lpInheritedObjectType = NULL;
    }

    if (bstrInheritedObjectType) {
        _lpInheritedObjectType = AllocADsStr(bstrInheritedObjectType);

        if (!_lpInheritedObjectType) {
            RRETURN(E_OUTOFMEMORY);
        }
    }

    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlEntry::get_Trustee(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpTrustee, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CAccessControlEntry::put_Trustee(THIS_ BSTR bstrTrustee)
{

    if (!bstrTrustee) {
        RRETURN(E_FAIL);
    }

    if (_lpTrustee) {
        FreeADsStr(_lpTrustee);
    }

    //
    // Since we are changing the trustee, we need to make
    // sure the sid value is cleared.
    //
    if (_dwSidLen) {
        _dwSidLen = 0;
    }

    if (_pSid) {
        FreeADsMem(_pSid);
        _pSid = NULL;
    }

    _lpTrustee = AllocADsStr(bstrTrustee);

    if (!_lpTrustee) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);
}


HRESULT
CopyAccessControlEntry(
    IADsAccessControlEntry * pSourceAce,
    IADsAccessControlEntry ** ppTargetAce
    )
{
    IADsAccessControlEntry * pTargetAce = NULL;
    IADsAcePrivate *pPrivAceTarget = NULL;
    IADsAcePrivate *pPrivAceSource = NULL;
    BSTR bstrInheritedObjectTypeClsid = NULL;
    BSTR bstrObjectTypeClsid = NULL;
    BSTR bstrTrustee = NULL;
    HRESULT hr = S_OK;

    DWORD dwAceType = 0;
    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwFlags = 0;
    DWORD dwSidLen = 0;
    BOOL fSidValid = FALSE;
    PSID pSid = NULL;

    hr = pSourceAce->get_AceType((LONG *)&dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_AceFlags((long *)&dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_Flags((LONG *)&dwFlags);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_ObjectType(&bstrObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = pSourceAce->get_InheritedObjectType(&bstrInheritedObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pTargetAce
                );
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_AccessMask(dwAccessMask);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_AceFlags(dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_AceType(dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_Trustee(bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_Flags((LONG)dwFlags);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_ObjectType(bstrObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->put_InheritedObjectType(bstrInheritedObjectTypeClsid);
    BAIL_ON_FAILURE(hr);

    hr = pTargetAce->QueryInterface(
             IID_IADsAcePrivate,
             (void **) &pPrivAceTarget
             );

    if (SUCCEEDED(hr)) {
        hr = pSourceAce->QueryInterface(
                 IID_IADsAcePrivate,
                 (void **) &pPrivAceSource
                 );

        if (SUCCEEDED(hr)) {
            hr = pPrivAceSource->isSidValid(&fSidValid);

            if (SUCCEEDED(hr) && fSidValid) {
                //
                // Get the sid and try putting it.
                //
                hr = pPrivAceSource->getSid(
                         &pSid,
                         &dwSidLen
                         );

                if (SUCCEEDED(hr)) {
                    pPrivAceTarget->putSid(
                        pSid,
                        dwSidLen
                        );
                }
            }
        }
    }

    *ppTargetAce =  pTargetAce;

error:

    if (bstrTrustee) {
        ADsFreeString(bstrTrustee);
    }

    if (bstrObjectTypeClsid) {
        ADsFreeString(bstrObjectTypeClsid);
    }

    if (bstrInheritedObjectTypeClsid) {
        ADsFreeString(bstrInheritedObjectTypeClsid);
    }

    if (pPrivAceTarget) {
        pPrivAceTarget->Release();
    }

    if (pPrivAceSource) {
        pPrivAceSource->Release();
    }

    if (pSid) {
        FreeADsMem(pSid);
    }

    RRETURN_EXP_IF_ERR(hr);
}

//
// IADsAcePrivate methods.
//

//+---------------------------------------------------------------------------
// Function:   CAccessControlEntry::getSid  - IADsAcePrivate method.
//
// Synopsis:   Returns the SID associated with the trustee on this ACE
//          object assuming there is one that is correct.
//          
// Arguments:  ppSid              -   Return pointer to SID.
//             pdwLength          -   Return lenght of the SID.
//
// Returns:    S_OK or appropriate failure error code.
//
// Modifies:   ppSid and pdwLength
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccessControlEntry::getSid(
    OUT PSID *ppSid,
    OUT DWORD *pdwLength
    ) 
{
    HRESULT hr = S_OK;
    PSID pSid = NULL;

    if (!ppSid || !pdwLength) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }
    if (!_pSid) {
        //
        // This means that the there is no usable value for the sid.
        //
        RRETURN(E_FAIL);
    }

    pSid = (PSID) AllocADsMem(_dwSidLen);
    
    if (!pSid) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    memcpy(pSid, _pSid, _dwSidLen);

    *pdwLength = _dwSidLen;

    *ppSid = pSid;

error:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   CAccessControlEntry::putSid  - IADsAcePrivate method.
//
// Synopsis:   Updates the SID associated with the trustee on this Ace 
//          object to the value specified.
//          
// Arguments:  PSID              -   Pointer to SID.
//             dwLength          -   Lenght of the SID.
//
// Returns:    S_OK on success or E_ADS_BAD_PARAMETER, E_OUTOFMEMORY 
//          on failure.
//
// Modifies:   _pSid and _dwSidLen.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccessControlEntry::putSid(
    IN PSID pSid,
    IN DWORD dwLength
    )
{
    HRESULT hr = S_OK;
    PSID pLocalSid = NULL;

    if (dwLength && !pSid) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    if (_pSid) {
        FreeADsMem(_pSid);
        _pSid = NULL;
        _dwSidLen = 0;
    }

    if (dwLength) {
        //
        // pSid also has to be valid at this point
        //
        _pSid = (PSID) AllocADsMem(dwLength);
        if (!_pSid) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        memcpy(_pSid, pSid, dwLength);

        _dwSidLen = dwLength;
    }

error:

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CAccessControlEntry::isSidValid  - IADsAcePrivate method.
//
// Synopsis:   Returns status of the sid associated with this ACE's trustee.
//          
// Arguments:  pfSidValid       -   Return value.
//
// Returns:    S_OK or E_ADS_BAD_PARAMETER.
//
// Modifies:   pfSidValid set to TRUE or FALSE as appropriate.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccessControlEntry::isSidValid(
    OUT BOOL *pfSidValid
    )
{
    if (!pfSidValid) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    //
    // If the Sid length is zero, then there is no sid for trustee.
    //
    *pfSidValid = (_dwSidLen != 0);
    RRETURN(S_OK);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\auto_rel.h ===
//
// auto_rel.h
//

#pragma once

// class I - Multi-Inheritance casting for ATL type classes
// ergo C2385 - T::Release() is ambiguous
//
template<class T, class I = T>
class auto_rel
{
public:
    explicit auto_rel(T* p = 0)
        : pointee(p) {};
        // Don't AddRef()

    auto_rel(auto_rel<T,I>& rhs)
        : pointee(rhs.get()) { if (pointee) ((I*)pointee)->AddRef(); }

    ~auto_rel()
        {
        	if (pointee)
        		((I*)pointee)->Release();
		};

    auto_rel<T,I>& operator= (const auto_rel<T,I>& rhs)
    {   
        if (this != rhs.getThis())
        {
            reset (rhs.get());
            if (pointee) ((I*)pointee)->AddRef();
        }
        return *this;
    };

    auto_rel<T,I>& operator= (T*rhs)
    {   
        reset (rhs);
        // Don't AddRef()
        return *this;
    };

    T& operator*() const 
        { return *pointee; };
    T*  operator-> () const
        { return pointee; };
    T** operator& ()                // for OpenEntry etc...
        { reset(); return &pointee; };
    operator T* ()
        { return pointee; };
#ifdef MAPIDEFS_H
    operator LPMAPIPROP ()
        { return (LPMAPIPROP)pointee; };
#endif
	operator bool ()
		{ return pointee != NULL; };
	operator bool () const
		{ return pointee != NULL; };
	bool operator! ()
		{ return pointee == NULL; };
	bool operator! () const
		{ return pointee == NULL; };

    // Checks for NULL
    bool operator== (LPVOID lpv)
        { return pointee == lpv; };
    bool operator!= (LPVOID lpv)
        { return pointee != lpv; };
    bool operator== (const auto_rel<T,I>& rhs)
        { return pointee == rhs.pointee; }
    bool operator< (const auto_rel<T,I>& rhs)
        { return pointee < rhs.pointee; }

    // return value of current dumb pointer
    T*  get() const
        { return pointee; };

    // relinquish ownership
    T*  release()
    {   T * oldPointee = pointee;
        pointee = 0;
        return oldPointee;
    };

    // delete owned pointer; assume ownership of p
    ULONG reset (T* p = 0)
    {   ULONG ul = 0;
        if (pointee)
			ul = ((I*)pointee)->Release();
        pointee = p;
        
        return ul;
    };

private:
#ifdef MAPIDEFS_H
    // these are here on purpose, better to find out at compile time
    // use auto_padr<T,I> or auto_prow<T,I>
    operator LPADRLIST () { return 0; };
    operator LPSRowSet () { return 0; };
#endif

    // operator& throws off operator=
    const auto_rel<T,I> * getThis() const
    {   return this; };

    T* pointee;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\bindercf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:  bindercf.cxx
//
//  Contents:  ADSI OLE DB Provider Binder Factory Code
//
//             CADsBinderCF::CreateInstance
//
//  History:   7-23-98     mgorti    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#if (!defined(BUILD_FOR_NT40))
#include "atl.h"
#endif

#include "bindercf.hxx"

#if (!defined(BUILD_FOR_NT40))
#include "binder.hxx"
#endif

#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CBinderF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    7-23-98   mgorti     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsBinderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
#if (!defined(BUILD_FOR_NT40))
    HRESULT     hr = S_OK;

    // Create Instance code here

	CComObject<CBinder>		*pBinder = NULL;
    hr = CComObject<CBinder>::CreateInstance(&pBinder);
	if (FAILED(hr))
		return hr;

	//To make sure we delete the binder object in case we encounter errors after this point.
	pBinder->AddRef();
	auto_rel<IBindResource> pBinderDelete(pBinder);

	hr = pBinder->QueryInterface(iid, (void**)ppv);
	if (FAILED(hr))
		return hr;

    return hr;
#else
    return E_FAIL;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\binder.cxx ===
// Binder.cpp : Implementation of CBinder


#include "oleds.hxx"

#if (!defined(BUILD_FOR_NT40))

#include "atl.h"
#include "binder.hxx"
#include "row.hxx"

//property description constants
const PWSTR DESC_DBPROP_INIT_LCID =                     L"Location ID";
const PWSTR DESC_DBPROP_INIT_MODE =                     L"Mode";
const PWSTR DESC_DBPROP_INIT_BINDFLAGS =        L"Bind Flags";
const PWSTR DESC_DBPROP_INIT_LOCKOWNER =        L"Lock Owner";
const PWSTR DESC_DBPROP_USERID =                L"User ID";
const PWSTR DESC_DBPROP_PASSWORD =              L"Password";
const PWSTR DESC_DBPROP_ENCRYPT_PASSWORD =      L"Encrypt Password";

#define DEFAULT_DBPROP_INIT_MODE                DB_MODE_READ

/////////////////////////////////////////////////////////////////////////////
// CBinder

//ISupportErrorInfo methods

//+---------------------------------------------------------------------------
//
//  Function:  CBinder::InterfaceSupportsErrorInfo
//
//  Synopsis: Given an interface ID, tells if that interface supports
//            the interface ISupportErrorInfo
//
//  Arguments:
//              REFIID riid
//
//  Returns:
//              S_OK             yes, the interface supports ISupportErrorInfo
//              S_FALSE                  no, the interface doesn't support it.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] =
    {
            &IID_IBindResource, &IID_IDBBinderProperties
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
            if (InlineIsEqualGUID(*arr[i],riid))
                    RRETURN(S_OK);
    }
    RRETURN(S_FALSE);
}

//IBindResource methods
//+---------------------------------------------------------------------------
//
//  Function:  CBinder::Bind
//
//  Synopsis: Binds to a row or rowset object given a URL.
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::Bind(
                           IUnknown *                   punkOuter,
                           LPCOLESTR                    pwszURL,
                           DBBINDURLFLAG                dwBindFlags,
                           REFGUID                              rguid,
                           REFIID                               riid,
                           IAuthenticate *              pAuthenticate,
                           DBIMPLICITSESSION *  pImplSession,
                           DWORD *                              pdwBindStatus,
                           IUnknown **                  ppUnk
                           )
{
    HRESULT hr = S_OK;

	TRYBLOCK
		//if caller passed a null value for dwBindFlags,
		//get them from initialization properties.
		if (dwBindFlags == 0)
			dwBindFlags = BindFlagsFromDbProps();

		//Forward the Bind call to CSessionObject for actual binding
		ADsAssert(m_pSession);
		hr = m_pSession->Bind(punkOuter, pwszURL, dwBindFlags, rguid, riid,
			pAuthenticate, pImplSession, pdwBindStatus, ppUnk);

		if (FAILED(hr))
				RRETURN(hr);
	
	CATCHBLOCKRETURN

	RRETURN(hr);
}

//IDBBinderProperties : IDBProperties
//(most of this code has been copied form exoledb and reorganized).
//IDBProperties
//+---------------------------------------------------------------------------
//
//  Function:  CBinder::GetProperties
//
//  Synopsis: Gets the requested Binder properties
//
//  For more info see OLE DB 2.1 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::GetProperties(
                                                           ULONG cPropertySets,
                                                           const DBPROPIDSET rgPropertySets[  ],
                                                           ULONG *pcPropertySets,
                                                           DBPROPSET **prgPropertySets)
{
    BOOL            fPropInError, fSpecialSets, fCopy = FALSE;
    HRESULT         hr = S_OK;
    LONG            ipropset =0, iprop =0;
    ULONG           cprop = 0, cpropError =0, ipropT;
    DBPROPSET       *rgPropertySetsOutput = NULL, *ppropset = NULL;
    DBPROP          *pprop;
    auto_leave      cs_auto_leave(m_autocs);

	TRYBLOCK
			//Let property manager object check and init the arguments
            hr = m_dbProperties.CheckAndInitPropArgs(cPropertySets,
                                                                       rgPropertySets,
                                                                       pcPropertySets,
                                                                       (void **)prgPropertySets,
                                                                       &fPropInError,
                                                                       &fSpecialSets);

            //if all the requested sets are special,
            //we just return error because this method
            //doesn't support special sets. Otherwise,
            //we attempt to return information about other
            //non-special sets.
            if(fSpecialSets && SUCCEEDED(hr))
                    RRETURN(DB_E_ERRORSOCCURRED);
            else if(!fSpecialSets && FAILED(hr))
                    RRETURN(hr);

            cs_auto_leave.EnterCriticalSection();

            //if cPropertySets is zero, return INIT property set.
            if(cPropertySets == 0)
            {
                    cPropertySets = 1;
                    fCopy = TRUE;
            }
            //or if DBPROPSET_PROPERTIESINERROR is requested,
            //check for invalid status values
            else if(fPropInError)
            {
                    ppropset = m_dbProperties.GetPropertySet(DBPROPSET_DBINIT);
                    for(iprop = 0, cpropError = 0;
                        (ULONG)iprop < ppropset->cProperties;
                            iprop++)
                            if( ppropset->rgProperties[iprop].dwStatus != DBPROPSTATUS_OK )
                                    cpropError++;
            }

            //Allocate memory for returning property sets.
            rgPropertySetsOutput =
                    (DBPROPSET *)CoTaskMemAlloc(cPropertySets *sizeof(DBPROPSET));
            if (!rgPropertySetsOutput)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            //If properties in error were requested, look for all properties
            //with invalid status values and return the info.
            if(fPropInError)
            {
                    if(cpropError)
                    {
                            rgPropertySetsOutput[0].rgProperties
                                    =(DBPROP *)CoTaskMemAlloc(cpropError *sizeof(DBPROP));
                            if(rgPropertySetsOutput[0].rgProperties == NULL)
                            {
                                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                            }
                            rgPropertySetsOutput[0].guidPropertySet = DBPROPSET_DBINIT;
                            for(ipropT =0, iprop =0;
                                ipropT <ppropset->cProperties;
                                    ipropT++)

                                    if( ppropset->rgProperties[ipropT].dwStatus
                                            != DBPROPSTATUS_OK )
                                    {
                                            memcpy(&(rgPropertySetsOutput[0].rgProperties[iprop]),
                                                    &(ppropset->rgProperties[ipropT]),
                                                    sizeof(DBPROP));
                                            VariantInit(
                                                    &(rgPropertySetsOutput[0].rgProperties[iprop].vValue));

                                            hr = VariantCopy(
                                                    &(rgPropertySetsOutput[0].rgProperties[iprop].vValue),
                                                    &(ppropset->rgProperties[ipropT].vValue));

                                            BAIL_ON_FAILURE(hr);
                                            iprop++;
                                    }
                    }
                    else
                            rgPropertySetsOutput[0].rgProperties = NULL;

                    rgPropertySetsOutput[0].cProperties = cpropError;
                    cpropError =0;
            }
            //if fCopy is set, copy the init property set to the return array
            else if(fCopy)
            {
                    for (ipropset=0; (ULONG)ipropset<cPropertySets; ++ipropset)
                    {
                            hr = m_dbProperties.CopyPropertySet(
                                    ipropset, &rgPropertySetsOutput[ipropset]);
                            BAIL_ON_FAILURE(hr);
                    }
            }
            //caller requested for some regular property sets
            //return the info.
            else
            {
                    //copy passed in information from rgPropertySets
                    //to output array.
                    memcpy(rgPropertySetsOutput,
                               rgPropertySets,
                               cPropertySets *sizeof(DBPROPSET));
                    //cycle thru each property set, get properties
                    //allocate necessary memory and assign values.
                    for(ipropset = 0, cprop = 0, cpropError =0;
                        (ULONG)ipropset<cPropertySets;
                            ipropset++)
                    {
                            ppropset = m_dbProperties.GetPropertySet(
                                    rgPropertySets[ipropset].guidPropertySet);

                            if(rgPropertySets[ipropset].cPropertyIDs)
                            {
                                    iprop =0;
                                    cprop += rgPropertySets[ipropset].cPropertyIDs;

                                    //Allocate memory for all the propertyIDs in this set.
                                    rgPropertySetsOutput[ipropset].rgProperties     =
                                            (DBPROP *) CoTaskMemAlloc(
                                            rgPropertySets[ipropset].cPropertyIDs *sizeof(DBPROP));

                                    if(rgPropertySetsOutput[ipropset].rgProperties == NULL)
                                    {
                                            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                                    }

                                    //zero memory
                                    memset( rgPropertySetsOutput[ipropset].rgProperties,
                                            0x00,
                                            rgPropertySets[ipropset].cPropertyIDs *sizeof(DBPROP));

                                    //DBPROPSET_DATASOURCEINFO is not valid on this object.
                                    if( ppropset == NULL ||
                                            (rgPropertySets[ipropset].guidPropertySet ==
                                             DBPROPSET_DATASOURCEINFO)
                                      )
                                    {
                                            cpropError += rgPropertySets[ipropset].cPropertyIDs;
                                            for(;
                                                (ULONG)iprop<rgPropertySets[ipropset].cPropertyIDs;
                                                    iprop++
                                               )
                                            {
                                                    rgPropertySetsOutput[ipropset].
                                                            rgProperties[iprop].dwPropertyID
                                                            = rgPropertySets[ipropset].rgPropertyIDs[iprop];

                                                    rgPropertySetsOutput[ipropset].
                                                            rgProperties[iprop].dwStatus =
                                                            DBPROPSTATUS_NOTSUPPORTED;
                                            }

                                            continue; //continue with next property set.
                                    }

                                    //we have a valid property set. Cycle thru each
                                    //property and assign values in output array.
                                    for(;
                                        (ULONG)iprop < rgPropertySets[ipropset].cPropertyIDs;
                                            iprop++
                                       )
                                    {
                                            pprop = (DBPROP *)m_dbProperties.GetProperty(
                                                    rgPropertySets[ipropset].guidPropertySet,
                                                    rgPropertySets[ipropset].rgPropertyIDs[iprop]);
                                            if(pprop)
                                            {
                                                    rgPropertySetsOutput[ipropset].rgProperties[iprop]
                                                            = *pprop;
                                                    VariantInit(
                                                            &(rgPropertySetsOutput[ipropset].
                                                               rgProperties[iprop].vValue));

                                                    hr = VariantCopy(
                                                            &(rgPropertySetsOutput[ipropset].
                                                                rgProperties[iprop].vValue),
                                                            &(pprop->vValue));

                                                    BAIL_ON_FAILURE(hr);
                                            }
                                            //If unable to get property, set dwStatus
                                            else
                                            {
                                                    cpropError++;
                                                    rgPropertySetsOutput[ipropset].
                                                            rgProperties[iprop].dwPropertyID =
                                                            rgPropertySets[ipropset].rgPropertyIDs[iprop];

                                                    rgPropertySetsOutput[ipropset].
                                                            rgProperties[iprop].dwStatus =
                                                            DBPROPSTATUS_NOTSUPPORTED;
                                            }
                                    }
                            }
                            else //no propertyIDs requested for this set
                            {
                                    rgPropertySetsOutput[ipropset].rgProperties = NULL;
                                    //DBPROPSET_DATASOURCEINFO is invalid for this object.
                                    //Return error if it is the one requested.
                                    if(ppropset == NULL ||
                                            (rgPropertySets[ipropset].guidPropertySet ==
                                             DBPROPSET_DATASOURCEINFO)
                                      )
                                    {
                                            cprop++;
                                            cpropError++;
                                    }
                                    else //otherwise, copy all propertyIDs
                                    {
                                            hr = m_dbProperties.CopyPropertySet(
                                                    rgPropertySets[ipropset].guidPropertySet,
                                                    &rgPropertySetsOutput[ipropset]);

                                            BAIL_ON_FAILURE(hr);
                                    }
                            }
                    } //for (ipropset = 0....
            }

	CATCHBLOCKBAIL(hr)

        ADsAssert(pcPropertySets && prgPropertySets);

        *pcPropertySets  = cPropertySets;
        *prgPropertySets = rgPropertySetsOutput;

        hr = cpropError ?
                ((cpropError < cprop) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED)
                : S_OK;

        RRETURN(hr);

error:
        while(ipropset >= 0)
        {
                while(--iprop >= 0)
                        VariantClear(
                                &(rgPropertySetsOutput[ipropset].rgProperties[iprop].vValue));
                if( rgPropertySetsOutput
                        && rgPropertySetsOutput[ipropset].cProperties
                        && rgPropertySetsOutput[ipropset].rgProperties)
                        CoTaskMemFree(rgPropertySetsOutput[ipropset].rgProperties);
                ipropset--;
                if (ipropset >= 0)
                    iprop = rgPropertySetsOutput[ipropset].cProperties;
        }
        if(rgPropertySetsOutput)
            CoTaskMemFree(rgPropertySetsOutput);
        RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:  CBinder::GetPropertyInfo
//
//  Synopsis: Gets information about requested properties
//
//  For more info see OLE DB 2.1 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::GetPropertyInfo(
                                                                          ULONG cPropertySets,
                                                                          const DBPROPIDSET rgPropertySets[  ],
                                                                          ULONG *pcPropertyInfoSets,
                                                                          DBPROPINFOSET **prgPropertyInfoSets,
                                                                          OLECHAR **ppDescBuffer)
{
    HRESULT                         hr;
    BOOL                            fPropInError, fSpecialSets, fCopy =FALSE;
    ULONG                           ipropset = 0, iprop, cProperty, cprop = 0, cpropError=0;
    ULONG_PTR                       cchDescBuffer, ichDescBuffer;
    DBPROPINFOSET           *rgPropertyInfoSetsOutput = NULL, *ppropinfoset;
    const DBPROPINFO UNALIGNED *pdbpropinfoSrc;
    PDBPROPINFO                      pdbpropinfo;
    auto_leave                      cs_auto_leave(m_autocs);

    TRYBLOCK
            if(ppDescBuffer)
            {
                    *ppDescBuffer = NULL;
                    cchDescBuffer = 0;
                    ichDescBuffer = 0;
            }
            //Let the property manager object check and init arguments
            hr = m_dbProperties.CheckAndInitPropArgs(cPropertySets,
                    rgPropertySets,
                    pcPropertyInfoSets,
                    (void **)prgPropertyInfoSets,
                    &fPropInError,
                    &fSpecialSets);

            if(FAILED(hr))
                    RRETURN(hr);
            else if(fPropInError)
                    RRETURN(E_INVALIDARG);

            cs_auto_leave.EnterCriticalSection();

            //if cPropertySets is zero, return INIT property set info
            if(cPropertySets == 0)
            {
                    cPropertySets = 1;
                    fCopy = TRUE;
            }

            rgPropertyInfoSetsOutput = (DBPROPINFOSET *)
                    CoTaskMemAlloc(cPropertySets*sizeof(DBPROPINFOSET));
            if (!rgPropertyInfoSetsOutput)
                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

            if(fCopy)
            {
                    for (ipropset=0; ipropset <cPropertySets; ++ipropset)
                    {
                            hr = m_dbProperties.CopyPropertyInfoSet(
                                    ipropset,
                                    &rgPropertyInfoSetsOutput[ipropset],
                                    ppDescBuffer,
                                    &cchDescBuffer,
                                    &ichDescBuffer);
                            if (FAILED(hr))
                                    break;
                    }
                    BAIL_ON_FAILURE(hr);
            }
            else
            {
                    //copy passed in property set info to output array.
                    memcpy( rgPropertyInfoSetsOutput,
                            rgPropertySets,
                            cPropertySets *sizeof(DBPROPSET));

                    //Cycle thru each requested property set
                    for(ipropset=0, cprop =0; ipropset<cPropertySets; ipropset++)
                    {
                            iprop =0;

                            //Handle each special set
                            if( rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_DBINITALL)
                            {
                                    cprop++;
                                    hr = m_dbProperties.CopyPropertyInfoSet(DBPROPSET_DBINIT,
                                            &rgPropertyInfoSetsOutput[ipropset],
                                            ppDescBuffer,
                                            &cchDescBuffer,
                                            &ichDescBuffer);
                                    BAIL_ON_FAILURE(hr);
                            }
                            else if(fSpecialSets)
                            {
                                    if(rgPropertySets[ipropset].guidPropertySet ==
                                            DBPROPSET_DATASOURCEALL)
                                            rgPropertyInfoSetsOutput[ipropset].guidPropertySet =
                                            DBPROPSET_DATASOURCE;

                                    else if (rgPropertyInfoSetsOutput[ipropset].guidPropertySet ==
                                            DBPROPSET_SESSIONALL)
                                            rgPropertyInfoSetsOutput[ipropset].guidPropertySet =
                                            DBPROPSET_SESSION;

                                    else if(rgPropertyInfoSetsOutput[ipropset].guidPropertySet ==
                                            DBPROPSET_ROWSETALL)
                                            rgPropertyInfoSetsOutput[ipropset].guidPropertySet =
                                            DBPROPSET_ROWSET;

                                    else
                                            rgPropertyInfoSetsOutput[ipropset].guidPropertySet =
                                            DBPROPSET_DATASOURCEINFO;

                                    rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos = NULL;
                                    rgPropertyInfoSetsOutput[ipropset].cPropertyInfos = 0;
                                    cprop++;
                                    cpropError++;
                            }
                            else //Now the regular property sets
                            {
                                    ppropinfoset =
                                            m_dbProperties.GetPropertyInfoSet(
                                            rgPropertySets[ipropset].guidPropertySet);

                                    cProperty = rgPropertySets[ipropset].cPropertyIDs;

                                    if(cProperty)
                                    {
                                            cprop += cProperty;

                                            //allocate memory for each property info
                                            rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos
                                                    = (DBPROPINFO *)
                                                    CoTaskMemAlloc(cProperty *sizeof(DBPROPINFO));

                                            if( rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos
                                                    == NULL)
                                            {
                                                    BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
                                            }

                                            //zero memory
                                            memset(rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos,
                                                    0x00,
                                                    cProperty*sizeof(DBPROPINFO));

                                            //if the requested property info set is empty,
                                            //store error information into the output array.
                                            if(ppropinfoset == 0)
                                            {
                                                    cpropError += cProperty;

                                                    for(iprop =0; iprop <cProperty; iprop++)
                                                    {
                                                            rgPropertyInfoSetsOutput[ipropset].
                                                                    rgPropertyInfos[iprop].dwPropertyID     =
                                                                    rgPropertySets[ipropset].rgPropertyIDs[iprop];

                                                            rgPropertyInfoSetsOutput[ipropset].
                                                                    rgPropertyInfos[iprop].dwFlags =
                                                                    DBPROPFLAGS_NOTSUPPORTED;
                                                    }
                                            }
                                            //otherwise, try to get property info for each property.
                                            else
                                            {
                                                    pdbpropinfo =
                                                            rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos;

                                                    for(; iprop <cProperty; iprop++, pdbpropinfo++)
                                                    {
                                                            pdbpropinfoSrc = m_dbProperties.GetPropertyInfo(
                                                                    rgPropertySets[ipropset].guidPropertySet,
                                                                    rgPropertySets[ipropset].rgPropertyIDs[iprop]);
                                                            if(pdbpropinfoSrc)
                                                                    *pdbpropinfo = *pdbpropinfoSrc;
                                                            else
                                                            {
                                                                    //unable to get property info
                                                                    //for this property. Store error info.
                                                                    pdbpropinfo->dwPropertyID =
                                                                            rgPropertySets[ipropset].
                                                                            rgPropertyIDs[iprop];

                                                                    pdbpropinfo->dwFlags =
                                                                            DBPROPFLAGS_NOTSUPPORTED;
                                                                    cpropError++;
                                                            }
                                                    }
                                                    //Now copy property descriptions
                                                    //for all properties in this set
                                                    hr = m_dbProperties.CopyPropertyDescriptions(
                                                            &rgPropertyInfoSetsOutput[ipropset],
                                                            ppDescBuffer,
                                                            &cchDescBuffer,
                                                            &ichDescBuffer);
                                                    BAIL_ON_FAILURE(hr);
                                            }
                                    }
                                    else //no properties stored in this set.
                                    {
                                            cprop++;

                                            //if the returned set itself is NULL, nothing
                                            //to copy.
                                            if(ppropinfoset == NULL)
                                            {
                                                    cpropError++;
                                                    rgPropertyInfoSetsOutput[ipropset].rgPropertyInfos =
                                                            NULL;
                                            }
                                            //otherwise, just copy whatever info we have
                                            //in the set.
                                            else
                                            {
                                                    hr = m_dbProperties.CopyPropertyInfoSet(
                                                            rgPropertySets[ipropset].guidPropertySet,
                                                            &rgPropertyInfoSetsOutput[ipropset],
                                                            ppDescBuffer,
                                                            &cchDescBuffer,
                                                            &ichDescBuffer);
                                                    BAIL_ON_FAILURE(hr);
                                            }
                                    }
                            }
                    } //for (ipropset = 0 ....
            } //if (fcopy) ... else ...

    CATCHBLOCKBAIL(hr)

        *pcPropertyInfoSets  = cPropertySets;
        *prgPropertyInfoSets = rgPropertyInfoSetsOutput;

        // So far we have put relative offsets into pointers to property
        // descriptions. They have to be rebased on the beginning of the
        // desription strings buffer.
        if(ppDescBuffer && *ppDescBuffer)
        {
                for(ipropset=0; ipropset < cPropertySets; ipropset++)
                        for(iprop =0;
                            iprop <rgPropertyInfoSetsOutput[ipropset].cPropertyInfos;
                                iprop++)
                        {

                                //      Only do this if we really support the property:
                                //

                                if ( rgPropertyInfoSetsOutput[ipropset].
                                             rgPropertyInfos[iprop].dwFlags !=
                                         DBPROPFLAGS_NOTSUPPORTED )
                                {
                                        rgPropertyInfoSetsOutput[ipropset].
                                                rgPropertyInfos[iprop].pwszDescription =
                                                (WCHAR *)(*ppDescBuffer) +
                                                (ULONG_PTR)(rgPropertyInfoSetsOutput[ipropset].
                                                    rgPropertyInfos[iprop].pwszDescription);
                                }
                                else {
                                        ADsAssert ( rgPropertyInfoSetsOutput[ipropset].
                                                        rgPropertyInfos[iprop].pwszDescription
                                                                == NULL );
                                }
                        }
        }
        else
        {
                //      Assert that we're not passing back any strings:
                //

                for(ipropset=0; ipropset < cPropertySets; ipropset++)
                {
                        for(iprop =0;
                            iprop < rgPropertyInfoSetsOutput[ipropset].cPropertyInfos;
                                iprop++)
                        {
                                ADsAssert ( rgPropertyInfoSetsOutput[ipropset].
                                        rgPropertyInfos[iprop].pwszDescription == NULL );
                        }
                }
        }

        hr = cpropError ?
                ((cpropError <cprop) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED)
                : S_OK;

        RRETURN(hr);

error:
        ULONG           i;

        for ( i = 0; i < ipropset; i++ )
        {
                if( rgPropertyInfoSetsOutput
                        && rgPropertyInfoSetsOutput[i].cPropertyInfos
                        && rgPropertyInfoSetsOutput[i].rgPropertyInfos)
                        CoTaskMemFree(rgPropertyInfoSetsOutput[i].rgPropertyInfos);
        }

        if(rgPropertyInfoSetsOutput)
            CoTaskMemFree(rgPropertyInfoSetsOutput);

        if(ppDescBuffer && *ppDescBuffer)
        {
                CoTaskMemFree(*ppDescBuffer);
                *ppDescBuffer = NULL;
        }
        RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CBinder::GetProperties
//
//  Synopsis: Sets Binder properties
//
//  For more info see OLE DB 2.1 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::SetProperties(
                                                                        ULONG cPropertySets,
                                                                        DBPROPSET rgPropertySets[  ])
{
    ULONG                   ipropset, cprop, cpropError;
    DBPROPSTATUS    dbpropstat;
    DBPROP                  *ppropNew, *ppropEnd, *ppropStored;
    BOOL                    fEqualOnly, fRestore;
    HRESULT                 hr;
    DBPROPSET               *ppropset;
    auto_leave              cs_auto_leave(m_autocs);

    TRYBLOCK
        //Let the property manager object verify the args.
        hr = m_dbProperties.VerifySetPropertiesArgs(cPropertySets,
                                                        rgPropertySets);
        if (FAILED(hr))
                RRETURN(hr);

        cs_auto_leave.EnterCriticalSection();

        //Cycle thru each property set.
        for(ipropset =0, cprop =0,
                cpropError =0; ipropset < cPropertySets;
            ipropset++)
        {
                dbpropstat = DBPROPSTATUS_OK;
                fEqualOnly = FALSE;
                cprop += rgPropertySets[ipropset].cProperties;

                //Get the property set.
                ppropset = m_dbProperties.GetPropertySet(
                        rgPropertySets[ipropset].guidPropertySet);

                //Error if this is NOT init property set,
                if(rgPropertySets[ipropset].guidPropertySet != DBPROPSET_DBINIT)
                {
                        dbpropstat = DBPROPSTATUS_NOTSUPPORTED;
                }

                //ppropnew is beginning of property struct in memory
                //and ppropEnd is the end.
                ppropNew = rgPropertySets[ipropset].rgProperties;
                ppropEnd = ppropNew +rgPropertySets[ipropset].cProperties;

                if(fEqualOnly || dbpropstat == DBPROPSTATUS_OK)
                {
                        //Cycle thru each property
                        for(; ppropNew !=ppropEnd; ppropNew++)
                        {
                                ppropStored = (DBPROP *)m_dbProperties.GetProperty(
                                        rgPropertySets[ipropset].guidPropertySet,
                                        ppropNew->dwPropertyID);

                                //if property is already there....
                                if(ppropStored)
                                {
                                        ppropNew->dwStatus = DBPROPSTATUS_OK;
                                        //Set error status if validation fails or
                                        //if type doesn't match
                                        //or if bad option or fEqualOnly is set
                                        //but new and existing values aren't the same.
                                        if (ppropNew->dwPropertyID == DBPROP_INIT_MODE && (V_VT(&(ppropNew->vValue)) == VT_I4) &&
                                                V_I4(&ppropNew->vValue) != DB_MODE_READ)
                                                ppropNew->dwStatus = DBPROPSTATUS_BADVALUE;
                                        else if(V_VT(&(ppropNew->vValue)) !=
                                                (m_dbProperties.GetPropertyInfo(
                                                rgPropertySets[ipropset].guidPropertySet,
                                                ppropNew->dwPropertyID))->vtType)
                                        {
                                                if(V_VT(&(ppropNew->vValue)) != VT_EMPTY)
                                                        ppropNew->dwStatus = DBPROPSTATUS_BADVALUE;
                                                else if(fEqualOnly)
                                                        ppropNew->dwStatus = DBPROPSTATUS_NOTSETTABLE;
                                        }
                                        else if(!GoodPropOption(ppropNew->dwOptions))
                                                ppropNew->dwStatus = DBPROPSTATUS_BADOPTION;
                                        else if(fEqualOnly && !VariantsEqual(
                                                &(ppropNew->vValue),
                                                &(ppropStored->vValue)))
                                                ppropNew->dwStatus = DBPROPSTATUS_NOTSETTABLE;

                                        //fEqualOnly was not set
                                        if(!fEqualOnly && ppropNew->dwStatus ==
                                                DBPROPSTATUS_OK)
                                        {
                                                // If VT_EMPTY we need to reset the default.
                                                if(V_VT(&(ppropNew->vValue)) == VT_EMPTY)
                                                {
                                                        //      Reset our initialization properties
                                                        //  to the default:
                                                        if(ppropNew->dwPropertyID == DBPROP_INIT_LCID)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_I4;
                                                                V_I4(&(ppropNew->vValue)) =
                                                                        GetUserDefaultLCID();
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                DBPROP_INIT_MODE)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_I4;
                                                                V_I4(&(ppropNew->vValue)) = DEFAULT_DBPROP_INIT_MODE;
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                DBPROP_INIT_BINDFLAGS)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_I4;
                                                                V_I4(&(ppropNew->vValue)) = 0;
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                DBPROP_INIT_LOCKOWNER)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_BSTR;
                                                                V_BSTR(&(ppropNew->vValue)) = NULL;
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                DBPROP_AUTH_USERID)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_BSTR;
                                                                V_BSTR(&(ppropNew->vValue)) = NULL;
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                  DBPROP_AUTH_PASSWORD)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_BSTR;
                                                                V_BSTR(&(ppropNew->vValue)) = NULL;
                                                        }
                                                        else if ( ppropNew->dwPropertyID ==
                                                                   DBPROP_AUTH_ENCRYPT_PASSWORD)
                                                        {
                                                                V_VT(&(ppropNew->vValue)) = VT_BOOL;
                                                                V_BOOL(&(ppropNew->vValue)) = VARIANT_FALSE;
                                                        }
                                                        fRestore = TRUE;
                                                }
                                                else
                                                        fRestore = FALSE;

                                                //copy new value into the property variant.
                                                if(FAILED(VariantCopy(
                                                        &(ppropStored->vValue),
                                                        &(ppropNew->vValue))))
                                                        ppropNew->dwStatus = DBPROPSTATUS_NOTSET;
                                                else if( ppropNew->dwPropertyID == DBPROP_AUTH_USERID ) {
                                                    if(S_OK != m_pSession->SetUserName(V_BSTR(&(ppropNew->vValue))))
                                                        ppropNew->dwStatus = DBPROPSTATUS_NOTSET;
                                                }
                                                else if( ppropNew->dwPropertyID == DBPROP_AUTH_PASSWORD ) {
                                                    if(S_OK != m_pSession->SetPassword(V_BSTR(&(ppropNew->vValue))))
                                                        ppropNew->dwStatus = DBPROPSTATUS_NOTSET;
                                                }
                                                else if( ppropNew->dwPropertyID == DBPROP_AUTH_ENCRYPT_PASSWORD ) {
                                                    if(V_BOOL(&(ppropNew->vValue)) == VARIANT_TRUE)
                                                        m_pSession->SetAuthFlag(ADS_SECURE_AUTHENTICATION);
                                                }
                                                

                                                if(fRestore)
                                                        VariantInit(&(ppropNew->vValue));
                                        }
                                }
                                else
                                        ppropNew->dwStatus = DBPROPSTATUS_NOTSUPPORTED;

                                if(ppropNew->dwStatus != DBPROPSTATUS_OK)
                                        cpropError++;
                        }
                }
                else
                {
                        cpropError += rgPropertySets[ipropset].cProperties;
                        for(; ppropNew !=ppropEnd; ppropNew++)
                                ppropNew->dwStatus = dbpropstat;
                }
            } //for (ipropset = 0 ...

    CATCHBLOCKRETURN

        hr = cpropError ?
                ((cpropError <cprop) ? DB_S_ERRORSOCCURRED : DB_E_ERRORSOCCURRED)
                : S_OK;
        RRETURN(hr);
}

//IDBBinderProperties
//+---------------------------------------------------------------------------
//
//  Function:  CBinder::Reset
//
//  Synopsis: Resets binder properties to default values.
//
//  For more info see OLE DB 2.5 spec.
//----------------------------------------------------------------------------
STDMETHODIMP CBinder::Reset( void)
{
    HRESULT                 hr              = NOERROR;
    DBPROP *                pprop;
    auto_leave              cs_auto_leave(m_autocs);

    TRYBLOCK
		cs_auto_leave.EnterCriticalSection();
        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_LCID );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_I4;
        V_I4(&pprop->vValue)    = GetUserDefaultLCID();

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_MODE );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_I4;
        V_I4(&pprop->vValue)    = DEFAULT_DBPROP_INIT_MODE;

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_BINDFLAGS );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_I4;
        V_I4(&pprop->vValue)    = 0;

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_LOCKOWNER );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_BSTR;
        V_BSTR(&pprop->vValue)  = NULL;

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_USERID );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_BSTR;
        V_BSTR(&pprop->vValue)  = NULL;
        m_pSession->SetUserName(NULL);

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_PASSWORD );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_BSTR;
        V_BSTR(&pprop->vValue)  = NULL;
        m_pSession->SetPassword(NULL);

        pprop = (DBPROP *) m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_ENCRYPT_PASSWORD );

        ADsAssert ( pprop );

        VariantClear ( &pprop->vValue );
        V_VT(&pprop->vValue)    = VT_BOOL;
        V_BOOL(&pprop->vValue)  = VARIANT_FALSE;
        m_pSession->SetAuthFlag(0);
	
	CATCHBLOCKRETURN

	RRETURN(hr);
}

//Helper functions

//+---------------------------------------------------------------------------
//
//  Function: CBinder::InitializeProperties
//
//  Synopsis: Initializes binder init property group to default values.
//
//----------------------------------------------------------------------------
HRESULT CBinder::InitializeProperties()
{
        HRESULT                 hr;
        DBPROP                  prop;
        DBPROPINFO *    ppropinfo;

        //      Initialize the DBPROP structure:
        //

        ZeroMemory ( &prop, sizeof (prop) );
        prop.dwOptions          = DBPROPOPTIONS_OPTIONAL;
        prop.dwStatus           = DBPROPSTATUS_OK;

        //      Add the LCID:
        //

        prop.dwPropertyID       = DBPROP_INIT_LCID;
        V_VT(&prop.vValue)      = VT_I4;
        V_I4(&prop.vValue)      = GetUserDefaultLCID ();

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_INIT_LCID
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *)m_dbProperties.GetPropertyInfo(
                DBPROPSET_DBINIT,
                DBPROP_INIT_LCID);
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the DB_MODE:
        //

        prop.dwPropertyID               = DBPROP_INIT_MODE;
        V_VT(&prop.vValue)              = VT_I4;
        V_I4(&prop.vValue)              = DEFAULT_DBPROP_INIT_MODE;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_INIT_MODE
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_INIT_MODE );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the BindFlags property:
        //

        prop.dwPropertyID               = DBPROP_INIT_BINDFLAGS;
        V_VT(&prop.vValue)              = VT_I4;
        V_I4(&prop.vValue)              = 0;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_INIT_BINDFLAGS
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_INIT_BINDFLAGS );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the LOCKOWNER property:
        //

        prop.dwPropertyID               = DBPROP_INIT_LOCKOWNER;
        V_VT(&prop.vValue)              = VT_BSTR;
        V_BSTR(&prop.vValue)    = NULL;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_INIT_LOCKOWNER
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_INIT_LOCKOWNER );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the USERID property:
        //

        prop.dwPropertyID               = DBPROP_AUTH_USERID;
        V_VT(&prop.vValue)              = VT_BSTR;
        V_BSTR(&prop.vValue)    = NULL;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_USERID
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_USERID );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the PASSWORD property:
        //

        prop.dwPropertyID               = DBPROP_AUTH_PASSWORD;
        V_VT(&prop.vValue)              = VT_BSTR;
        V_BSTR(&prop.vValue)    = NULL;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_PASSWORD
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_PASSWORD );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;

        //      Add the ENCRYPT_PASSWORD property:
        //

        prop.dwPropertyID               = DBPROP_AUTH_ENCRYPT_PASSWORD;
        V_VT(&prop.vValue)              = VT_BOOL;
        V_BOOL(&prop.vValue)    = VARIANT_FALSE;

        hr = m_dbProperties.SetProperty (
                DBPROPSET_DBINIT,
                prop,
                TRUE,
                DESC_DBPROP_ENCRYPT_PASSWORD
                );
        BAIL_ON_FAILURE(hr);

        //      Make it writable:

        ppropinfo = (DBPROPINFO *) m_dbProperties.GetPropertyInfo (
                DBPROPSET_DBINIT,
                DBPROP_AUTH_ENCRYPT_PASSWORD );
        ADsAssert ( ppropinfo );
        ppropinfo->dwFlags |= DBPROPFLAGS_WRITE;


error:
        RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: CBinder::BindFlagsFromDbProps
//
//  Synopsis: extracts bind flags from initialization properties.
//
//----------------------------------------------------------------------------
DWORD CBinder::BindFlagsFromDbProps ( )
{
        const DBPROP *          ppropMode;
        const DBPROP *          ppropBindFlags;

        ppropMode = m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_MODE );
        ADsAssert ( ppropMode );

        ppropBindFlags = m_dbProperties.GetProperty (
                DBPROPSET_DBINIT,
                DBPROP_INIT_BINDFLAGS );
        ADsAssert ( ppropBindFlags );

        const VARIANT * pvarMode = &ppropMode->vValue;
        const VARIANT * pvarBindFlags = &ppropBindFlags->vValue;

        DWORD           dwResult                = 0;

        if ( V_VT(pvarMode) == VT_I4 ) {
                DWORD           dwModeMask      =
                        DB_MODE_READ |
                        DB_MODE_WRITE |
                        DB_MODE_READWRITE |
                        DB_MODE_SHARE_DENY_READ |
                        DB_MODE_SHARE_DENY_WRITE |
                        DB_MODE_SHARE_EXCLUSIVE |
                        DB_MODE_SHARE_DENY_NONE;

                dwResult |= V_I4(pvarMode) & dwModeMask;
        }

        if ( V_VT(pvarBindFlags) == VT_I4 ) {
                DWORD           dwBindFlagProp  = V_I4(pvarBindFlags);
                DWORD           dwBindFlags             = 0;

                if ( dwBindFlagProp & DB_BINDFLAGS_DELAYFETCHCOLUMNS ) {
                        dwBindFlags |= DBBINDURLFLAG_DELAYFETCHCOLUMNS;
                }
                if ( dwBindFlagProp & DB_BINDFLAGS_DELAYFETCHSTREAM ) {
                        dwBindFlags |= DBBINDURLFLAG_DELAYFETCHSTREAM;
                }
                if ( dwBindFlagProp & DB_BINDFLAGS_RECURSIVE ) {
                        dwBindFlags |= DBBINDURLFLAG_RECURSIVE;
                }
                if ( dwBindFlagProp & DB_BINDFLAGS_OUTPUT ) {
                        dwBindFlags |= DBBINDURLFLAG_OUTPUT;
                }

                dwResult |= V_I4(pvarBindFlags) | dwBindFlags;
        }

        RRETURN (dwResult);
}

//+---------------------------------------------------------------------------
//
//  Function: CBinder::CreateDataSource
//
//  Synopsis: Creates an implicit DataSource object for this binder object.
//
//----------------------------------------------------------------------------
HRESULT CBinder::CreateDataSource()
{
        //Call this function only at creation time.
        ADsAssert(m_pDataSource == NULL && m_pDBInitialize.get() == NULL);

        HRESULT hr = S_OK;

        //Create a DataSource object. Note: starts with refcount = 1.
        m_pDataSource = new CDSOObject( NULL );
        if (m_pDataSource == NULL)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        //Initialize the object
        if (!m_pDataSource->FInit())
        {
                delete m_pDataSource;
                m_pDataSource = NULL;
                BAIL_ON_FAILURE(hr = E_FAIL);
        }

        //Get IDBInitialize interface and store it in (auto)member variable.
        //This will also make sure the DataSource object stays alive during
        //the lifetime of binder object.
        hr = m_pDataSource->QueryInterface(__uuidof(IDBInitialize),
                                           (void**)&m_pDBInitialize);
        BAIL_ON_FAILURE(hr);

        //We already stored datasource object reference in auto_rel object,
        //Now release once, since datasource object is created with refcount = 1.
        m_pDataSource->Release();

error:
        RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: CBinder::CreateSession
//
//  Synopsis: Creates an implicit Session object for this binder object.
//
//----------------------------------------------------------------------------
HRESULT CBinder::CreateSession()
{
        //Call this function only at creation time.
        ADsAssert(m_pSession == NULL && m_pOpenRowset.get() == NULL);

        HRESULT hr = S_OK;
        CCredentials creds;

        //create a session object. Note: starts with refcount = 1
        m_pSession = new CSessionObject( NULL );
        if (m_pSession == NULL)
                BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        //Initialize session object passing null credentials.
        //Note: This increments refcount on DataSource object.
        if (!m_pSession->FInit(m_pDataSource, creds))
                BAIL_ON_FAILURE(hr = E_FAIL);

        hr = m_pSession->QueryInterface(__uuidof(IOpenRowset),
                                                                        (void **)&m_pOpenRowset);
        BAIL_ON_FAILURE(hr);

        //We already stored session reference in auto_rel object.
        //Now release once, since session object is created
        //with refcount = 1
        m_pSession->Release();

        RRETURN ( S_OK );

error:
        //if we're here, the Session object is no good.
        if (m_pSession)
        {
                delete m_pSession;
                m_pSession = NULL;
        }

        RRETURN ( hr );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\ccommand.cxx ===
//
// Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  ccommand.cxx
//
//  Contents:  Microsoft OleDB/OleDS Data Source Object for ADSI
//
//
//  History:   08-01-96     shanksh    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

static WCHAR gpszADsPathAttr[] = L"ADsPath";

static BOOL
IsAutomatable(
    DBTYPE dbType
    );

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::AddRefAccessor
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns:
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::AddRefAccessor(
        HACCESSOR hAccessor,
    DBREFCOUNT *  pcRefCount
    )
{
    //
    // Asserts
    //
    ADsAssert(_pAccessor);

    RRETURN( _pAccessor->AddRefAccessor(
                    hAccessor,
                    pcRefCount) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::CreateAccessor
//
//  Synopsis:
//
//  Arguments:
//
//
//  Returns:
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::CreateAccessor(
    DBACCESSORFLAGS dwAccessorFlags,
    DBCOUNTITEM     cBindings,
    const DBBINDING rgBindings[],
    DBLENGTH        cbRowSize,
    HACCESSOR *     phAccessor,
    DBBINDSTATUS    rgStatus[]
    )
{
    //
    // Asserts
    //
    ADsAssert(_pAccessor);

    RRETURN( _pAccessor->CreateAccessor(
                    dwAccessorFlags,
                    cBindings,
                    rgBindings,
                    cbRowSize,
                    phAccessor,
                    rgStatus) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::ReleaseAccessor
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::ReleaseAccessor(
     HACCESSOR hAccessor,
     DBREFCOUNT * pcRefCount
     )
{
    //
    // Asserts
    //
    ADsAssert(_pAccessor);

    RRETURN( _pAccessor->ReleaseAccessor(
                    hAccessor,
                    pcRefCount) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::GetBindings
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::GetBindings(
    HACCESSOR         hAccessor,
    DBACCESSORFLAGS * pdwAccessorFlags,
    DBCOUNTITEM *     pcBindings,
    DBBINDING **      prgBindings
    )
{
    //
    // Asserts
    //
    ADsAssert(_pAccessor);

    RRETURN( _pAccessor->GetBindings(
                    hAccessor,
                    pdwAccessorFlags,
                                                                                                pcBindings, prgBindings) );
}


STDMETHODIMP
CCommandObject::GetColumnInfo2(
    DBORDINAL *     pcColumns,
    DBCOLUMNINFO ** prgInfo,
    OLECHAR **      ppStringBuffer,
    BOOL **         ppfMultiValued
    )
{
    HRESULT hr;
    ULONG pos, nStringBufLen;
    DBCOLUMNINFO *pInfo=NULL;
    OLECHAR* pStringBuffer=NULL ;
    DWORD i;
    DBTYPE wType;
    DWORD cAttrsReturned;
    LPWSTR *ppszTmpAttrs = NULL;
    DWORD cTmpAttrs;

    IDirectorySchemaMgmt *pDSAttrMgmt = NULL;
    PADS_ATTR_DEF pAttrDefinition = NULL;

    ADsAssert(_pIMalloc != NULL);

    //
    // IMalloc->Alloc is the way we have to allocate memory for out parameters
    //
    nStringBufLen = 0;
    for (i=0; i < _cAttrs; i++) {
        nStringBufLen += (wcslen(_ppszAttrs[i]) + 1) * sizeof (WCHAR);
    }

    nStringBufLen+= sizeof(WCHAR);        // For the bookmark column which is a null string

    //
    // No. of DBCOLUMN structures to be allocated
    //
    pInfo = (DBCOLUMNINFO *)_pIMalloc->Alloc((_cAttrs+1)*sizeof(DBCOLUMNINFO));
    if( !pInfo ) {
        hr = E_OUTOFMEMORY;
        goto error;
    }
    memset(pInfo, 0, (_cAttrs*sizeof(DBCOLUMNINFO)));

    pStringBuffer = (WCHAR *)_pIMalloc->Alloc(nStringBufLen);
    if( !pStringBuffer ) {
        hr = E_OUTOFMEMORY;
        goto error;
    };
    memset(pStringBuffer, 0, nStringBufLen);

    //
    // Get the attribute types by enquiring the DS schema
    //
    hr = _pDSSearch->QueryInterface(
                                IID_IDirectorySchemaMgmt,
                                (void**)&pDSAttrMgmt
                                );
    BAIL_ON_FAILURE( hr );

    // Fix for #285757. We should not send the ADsPath attribute to the
    // server. So, search for occurences of this attribute and remove them.

    ppszTmpAttrs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * _cAttrs);
    if(NULL == ppszTmpAttrs)
    {
         hr = E_OUTOFMEMORY;
         BAIL_ON_FAILURE(hr);
    } 
    cTmpAttrs = 0;
    for(i = 0; i < _cAttrs; i++)
    {
         if( _wcsicmp(L"ADsPath", _ppszAttrs[i]) )
         {
              ppszTmpAttrs[cTmpAttrs] = _ppszAttrs[i];
              cTmpAttrs++;
         }
    }     

    // Request attributes only if there is some attribute other than ADsPath
    if(cTmpAttrs)
         hr = pDSAttrMgmt->EnumAttributes(
                        ppszTmpAttrs,
                        cTmpAttrs,
                        &pAttrDefinition,
                        &cAttrsReturned
                        );
    else
    {
         cAttrsReturned = 0;
         pAttrDefinition = NULL;
    }

    if(ppszTmpAttrs != NULL)
         FreeADsMem(ppszTmpAttrs);

    pDSAttrMgmt->Release();
    pDSAttrMgmt = NULL;
    BAIL_ON_FAILURE( hr );

    //fill up the Bookmark column

    // bookmark name is empty string
    pInfo[0].pwszName                = NULL;

    pInfo[0].columnid.eKind          = DBKIND_GUID_PROPID;
    pInfo[0].columnid.uGuid.guid     = DBCOL_SPECIALCOL;
    pInfo[0].columnid.uName.ulPropid = 2;    // Value from note about
                                             // bookmarks in spec.
    pInfo[0].pTypeInfo               = NULL;
    pInfo[0].iOrdinal                = 0;
    pInfo[0].ulColumnSize            = sizeof(ULONG);
    pInfo[0].wType                   = DBTYPE_UI4;
    pInfo[0].bPrecision              = 10;       // Precision for I4.
    pInfo[0].bScale                  = (BYTE) ~ 0;
    pInfo[0].dwFlags                 = DBCOLUMNFLAGS_ISBOOKMARK
                                                                                | DBCOLUMNFLAGS_ISFIXEDLENGTH;

    //
    // Fill up the columnsinfo by getting the attribute types
    //
    pos = 0;
    for(i=0; i < _cAttrs; i++) {
        wcscpy(&pStringBuffer[pos], _ppszAttrs[i]);
        pInfo[i+1].pwszName= &pStringBuffer[pos];

        //
        // Get the type and size of the attribute
        //
        // Because of a Temporary bug in TmpTable, ~0 (specifying variable
        // size) is replaced by 256. This does not actually put a memory
        // restriction on the column size, but done merely to avoid the bug.
        //
        if( _wcsicmp(_ppszAttrs[i], L"ADsPath") == 0) {
            pInfo[i+1].wType = DBTYPE_WSTR|DBTYPE_BYREF;
            // pInfo[i+1].ulColumnSize = (ULONG) ~0;
            pInfo[i+1].ulColumnSize = (ULONG)256;
        }
        else {
            hr = GetDBType(
                      pAttrDefinition,
                      cAttrsReturned,
                      _ppszAttrs[i],
                      &pInfo[i+1].wType,
                      &pInfo[i+1].ulColumnSize
                      );

            if( FAILED(hr) )
                BAIL_ON_FAILURE( hr=E_FAIL );
        }

        wType = pInfo[i+1].wType & ~DBTYPE_BYREF;

        // any change made to setting dwFlags below should also be made in
        // GetRestrictedColumnInfo in row.cxx, for consistency
        if( (wType == DBTYPE_STR)  ||
            (wType == DBTYPE_WSTR) ||
            (wType == DBTYPE_BYTES) )
            pInfo[i+1].dwFlags = DBCOLUMNFLAGS_ISNULLABLE;
        else {
            // Temporary check
            // pInfo[i+1].dwFlags = (0);
            pInfo[i+1].dwFlags = DBCOLUMNFLAGS_ISNULLABLE |
                                 DBCOLUMNFLAGS_ISFIXEDLENGTH;
        }

        pInfo[i+1].pTypeInfo = NULL;
        pInfo[i+1].iOrdinal = i+1;
        pInfo[i+1].bPrecision = SetPrecision(wType);
        pInfo[i+1].bScale = (UCHAR) ~0;
        pInfo[i+1].columnid.eKind=DBKIND_NAME;
        pInfo[i+1].columnid.uGuid.guid=GUID_NULL;
        pInfo[i+1].columnid.uName.pwszName=pInfo[i+1].pwszName;

        pos += (wcslen(_ppszAttrs[i]) + 1);
    }

    if( ppfMultiValued ) {
                //
                // Filling in MultiValue array
                //
        BOOL * pfMultiValuedTemp;

                pfMultiValuedTemp= (BOOL *) AllocADsMem(sizeof(BOOL) * (_cAttrs+1));
        if( !(pfMultiValuedTemp) ) {
            hr=E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
                }

        pfMultiValuedTemp[0] = FALSE;   // First one is bookmark which is always FALSE

        for(ULONG j=0; j < _cAttrs; j++) {
            for(ULONG k=0; k < cAttrsReturned; k++) {
                if( !_wcsicmp(_ppszAttrs[j], pAttrDefinition[k].pszAttrName) )
                    break;
            }

            if( (k != cAttrsReturned) &&
                (pAttrDefinition[k].fMultiValued &&
                 IsAutomatable(g_MapADsTypeToVarType[pAttrDefinition[k].dwADsType]))) {
                pfMultiValuedTemp[j+1] = TRUE;
                        }
            else {
                pfMultiValuedTemp[j+1] = FALSE;
                        }
        }
        *ppfMultiValued = pfMultiValuedTemp;
    }

    if( pAttrDefinition ) {
        FreeADsMem(pAttrDefinition);
        }

    *pcColumns      = _cAttrs + 1;
    *prgInfo        = pInfo;
    *ppStringBuffer = pStringBuffer;

    RRETURN( S_OK );

error:

    if( pInfo != NULL )
        _pIMalloc->Free(pInfo);

    if( pStringBuffer != NULL )
        _pIMalloc->Free(pStringBuffer);

    if( pAttrDefinition ) {
        FreeADsMem(pAttrDefinition);
        }

    if (pDSAttrMgmt) {
        pDSAttrMgmt->Release();
    }

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::GetColumnInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    10-10-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::GetColumnInfo(
    DBORDINAL *     pcColumns,
    DBCOLUMNINFO ** prgInfo,
    OLECHAR **      ppStringBuffer
    )
{
    if( pcColumns )
        *pcColumns = 0;

    if( prgInfo )
        *prgInfo = NULL;

    if( ppStringBuffer )
        *ppStringBuffer = NULL;

    if( !pcColumns || !prgInfo || !ppStringBuffer )
        RRETURN( E_INVALIDARG );

    if( !IsCommandSet() )
        RRETURN( DB_E_NOCOMMAND );

    if( !IsCommandPrepared() )
        RRETURN( DB_E_NOTPREPARED );

    RRETURN( GetColumnInfo2(
                pcColumns,
                prgInfo,
                ppStringBuffer,
                NULL
                ) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::MapColumnIDs
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::MapColumnIDs(
        DBORDINAL  cColumnIDs,
        const DBID rgColumnIDs[],
        DBORDINAL  rgColumns[]
        )
{
    DBORDINAL cValidCols = 0;

    //
    // No Column IDs are set when GetColumnInfo returns ColumnsInfo structure.
    // Hence, any value of ID will not match with any column
    //
    DBORDINAL iCol;

    if( cColumnIDs == 0 )
        RRETURN( S_OK );

    // Spec-defined checks.
    // Note that this guarantees we can access rgColumnIDs[] in loop below.
    // (Because we'll just fall through.)
    if ( cColumnIDs && (!rgColumnIDs || !rgColumns) )
        RRETURN( E_INVALIDARG );

    if( !IsCommandSet() )
        RRETURN( DB_E_NOCOMMAND );

    if( !IsCommandPrepared() )
        RRETURN( DB_E_NOTPREPARED );

    //
    // Set the columns ordinals to invalid values
    //
    for(iCol=0; iCol < cColumnIDs; iCol++) {
        // Initialize
        rgColumns[iCol] = DB_INVALIDCOLUMN;

        //
        // The columnid with the Bookmark ID
        //
        if( rgColumnIDs[iCol].eKind == DBKIND_GUID_PROPID &&
            rgColumnIDs[iCol].uGuid.guid == DBCOL_SPECIALCOL &&
            rgColumnIDs[iCol].uName.ulPropid == 2 ) {

            rgColumns[iCol] = 0;
            cValidCols++;
            continue;
        }

        //
        // The columnid with the Column Name
        //
        if( rgColumnIDs[iCol].eKind == DBKIND_NAME &&
            rgColumnIDs[iCol].uName.pwszName ) {

            //
            // Find the name in the list of Attributes
            //
            for (ULONG iOrdinal=0; iOrdinal < _cAttrs; iOrdinal++) {
                if( !_wcsicmp(_ppszAttrs[iOrdinal],
                    rgColumnIDs[iCol].uName.pwszName) ) {

                    rgColumns[iCol] = iOrdinal+1;
                    cValidCols++;
                    break;
                }
            }
        }
    }

    if( cValidCols == 0 )
        RRETURN( DB_E_ERRORSOCCURRED );
    else if( cValidCols < cColumnIDs )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( S_OK );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::Cancel
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::Cancel(
        void
        )
{
    //
    // Need to protect _dwStatus for mutual exclusion when we support
    // multiple threads acting on the same Command object
    //
    _dwStatus |= CMD_EXEC_CANCELLED;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::Execute
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::Execute(
    IUnknown *  pUnkOuter,
    REFIID      riid,
    DBPARAMS *  pParams,
    DBROWCOUNT *pcRowsAffected,
    IUnknown ** ppRowset
    )
{
    HRESULT          hr;
    DWORD            dwFlags = 0;
    ULONG            cAccessors = 0;
    HACCESSOR        *prgAccessors = NULL;
    BOOL             *pbMultiValued = NULL;
    CRowProvider     *pRowProvider  = NULL;
    DBORDINAL        cColumns       = 0;
    DBCOLUMNINFO     *prgInfo       = NULL;
    WCHAR            *pStringBuffer = NULL;
    ULONG            cPropertySets = 0;
    DBPROPSET        *prgPropertySets = NULL;
    ULONG            i, j;

    ADsAssert(_pIMalloc != NULL);
    ADsAssert(_pAccessor != NULL);
    ADsAssert(_pCSession != NULL);

    if( ppRowset )
        *ppRowset = NULL;

    if( pcRowsAffected )
        *pcRowsAffected= -1;

    //
    // If the IID asked for is IID_NULL, then we can expect
    // that this is a non-row returning statement
    //
    if( riid == IID_NULL )
        dwFlags |= EXECUTE_NOROWSET;

    //
    // Check Arguments - Only check on row returning statements
    //
    if( !(dwFlags & EXECUTE_NOROWSET) &&
         (ppRowset == NULL) )
        RRETURN( E_INVALIDARG );

    //
    // Only 1 ParamSet if ppRowset is non-null
    //
    if( pParams &&
        (pParams->cParamSets > 1) &&
         ppRowset )
        RRETURN( E_INVALIDARG );

    //
    // Check that a command has been set
    //
    if( !IsCommandSet() )
        RRETURN( DB_E_NOCOMMAND );

    if( pUnkOuter )
        RRETURN( DB_E_NOAGGREGATION );

    //
    // Prepare the Command if not already done
    //
    if( !IsCommandPrepared() ) {
        hr = PrepareHelper();
        BAIL_ON_FAILURE( hr );
    }

    //
    // Check for a non row returning statement
    //
    if( dwFlags & EXECUTE_NOROWSET )
        RRETURN( S_OK );

    //
    // Get ColumnsInfo based on the list of attributes that we want to be
    // returned
    //
    hr = GetColumnInfo2(
             &cColumns,
             &prgInfo,
             &pStringBuffer,
             &pbMultiValued
             );

        BAIL_ON_FAILURE( hr );

    //
    // Commit the properties in the Command Object as the preferences to the
    // search
    //
    hr = SetSearchPrefs();
    BAIL_ON_FAILURE( hr );

    //
    // Create RowProvider object to pass to rowset code
    //
    _pDSSearch->AddRef();

    hr= CRowProvider::CreateRowProvider(
            _pDSSearch,
            _pszSearchFilter,
            _ppszAttrs,
            _cAttrs,
            cColumns,
            prgInfo,
            pStringBuffer,
            IID_IRowProvider,
            pbMultiValued,
            _fADSPathPresent,
            NULL,
            (void **) &pRowProvider);

    BAIL_ON_FAILURE( hr );

    pbMultiValued = NULL; // RowProvider responsible for deallocation

    //
    // We no longer need the ColumnsInfo; Release it
    //
    if (prgInfo)
    {
        _pIMalloc->Free(prgInfo);
        prgInfo = NULL;
    }

    if (pStringBuffer)
    {
        _pIMalloc->Free(pStringBuffer);
        pStringBuffer = NULL;
    }

    if( _pAccessor &&
        _pAccessor->_pextbuffer ) {
        cAccessors = _pAccessor->_pextbuffer->GetLastHandleCount();
        if( cAccessors > 0 ) {
            prgAccessors = (HACCESSOR *) AllocADsMem(
                               sizeof(HACCESSOR) * cAccessors
                                                           );
            if( !prgAccessors )
                cAccessors = 0;
            else
                for(ULONG i=0; i<cAccessors; i++)
                    prgAccessors[i] = i+1;
        }
    }

    hr = GetProperties(0, NULL, &cPropertySets, &prgPropertySets);
    BAIL_ON_FAILURE( hr );

    hr= CRowset::CreateRowset(
            pRowProvider,
            (LPUNKNOWN)(IAccessor FAR *)this ,
            NULL,
            this,
            cPropertySets,
            prgPropertySets,
            cAccessors,
            prgAccessors,
            _fADSPathPresent,
            _fAllAttrs,
            riid,
            ppRowset
            );

    if (prgAccessors)
    {
        FreeADsMem(prgAccessors);
        prgAccessors = NULL;
    }

    BAIL_ON_FAILURE( hr );

error:

    if (FAILED(hr))
    {
        //
        // Remove the Prepare flag,
        //
        _dwStatus &= ~(CMD_PREPARED);
    }

    //
    // Free the memory
    //
    if( pRowProvider )
        pRowProvider->Release();

    if( prgInfo )
        _pIMalloc->Free(prgInfo);

    if( pStringBuffer )
        _pIMalloc->Free(pStringBuffer);

    if( prgAccessors )
        FreeADsMem(prgAccessors);

    if( pbMultiValued )     {
        FreeADsMem(pbMultiValued);
    }

    // Free memory allocated by GetProperties
    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            ADsAssert(pProp);

            // We should free the DBID in pProp, but we know that
            // GetProperties always returns DB_NULLID and FreeDBID doesn't
            //  handle DB_NULLID. So, DBID is not freed here.

            VariantClear(&pProp->vValue);
        }

        _pIMalloc->Free(prgPropertySets[i].rgProperties);
    }

    _pIMalloc->Free(prgPropertySets);

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::GetDBSession
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::GetDBSession(
     REFIID      riid,
     IUnknown ** ppSession
     )
{
    HRESULT hr;

    //
    // Asserts
    //
    ADsAssert(_pCSession);

    //
    // Check Arguments
    //
    if( ppSession == NULL )
        RRETURN( E_INVALIDARG );

    //
    // Query for the interface on the session object.  If failure,
    // return the error from QueryInterface.
    //
    RRETURN( (_pCSession)->QueryInterface(riid, (VOID**)ppSession) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::GetProperties
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::GetProperties(
    const ULONG       cPropIDSets,
    const DBPROPIDSET rgPropIDSets[],
    ULONG *           pcPropSets,
    DBPROPSET **      pprgPropSets
    )
{
    //
        // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // Check in-params and NULL out-params in case of error
    //
    HRESULT hr = _pUtilProp->GetPropertiesArgChk(
                            cPropIDSets,
                            rgPropIDSets,
                            pcPropSets,
                            pprgPropSets,
                            PROPSET_COMMAND);

    if( FAILED(hr) )
        RRETURN( hr );

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->GetProperties(
                            cPropIDSets,
                            rgPropIDSets,
                            pcPropSets,
                            pprgPropSets,
                            PROPSET_COMMAND) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::SetProperties
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::SetProperties(
    ULONG     cPropertySets,
    DBPROPSET rgPropertySets[]
    )
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

        // Don't allow properties to be set if we've got a rowset open
    if( IsRowsetOpen() )
        RRETURN( DB_E_OBJECTOPEN );

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->SetProperties(
                            cPropertySets,
                            rgPropertySets,
                            PROPSET_COMMAND) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::GetCommandText
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::GetCommandText(
    GUID * pguidDialect,
    LPOLESTR *  ppwszCommand
    )
{
    HRESULT hr = S_OK;

    ADsAssert(_pIMalloc!= NULL);

    //
    // Check Function Arguments
    //
    if( ppwszCommand == NULL ) {
        hr = E_INVALIDARG;
        goto error;
        }

    *ppwszCommand = NULL;

    //
    // If the command has not been set, make sure the buffer
    // contains an empty stringt to return to the consumer
    //
    if( !IsCommandSet() ) {
        hr = DB_E_NOCOMMAND;
        goto error;
    }

    //
    // Allocate memory for the string we're going to return to the caller
    //
    *ppwszCommand = (LPWSTR)_pIMalloc->Alloc((wcslen(_pszCommandText)+1) * sizeof(WCHAR));

    if( !*ppwszCommand ) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    //
    // Copy our saved text into the newly allocated string
    //
    wcscpy(*ppwszCommand, _pszCommandText);

    //
    // If the text we're giving back is a different dialect than was
    // requested, let the caller know what dialect the text is in
    //
    if( pguidDialect != NULL && *pguidDialect != _guidCmdDialect)
    {
        hr = DB_S_DIALECTIGNORED;
        *pguidDialect = _guidCmdDialect;
    }

error:

    if( FAILED(hr) ) {
        if( pguidDialect )
            memset(pguidDialect, 0, sizeof(GUID));
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::SetCommandText
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::SetCommandText(
    REFGUID   rguidDialect,
    LPCOLESTR pszCommand
    )
{
    // Don't allow text to be set if we've got a rowset open
    if( IsRowsetOpen() )
        RRETURN( DB_E_OBJECTOPEN );

    // Check Dialect
    if( rguidDialect != DBGUID_LDAPDialect &&
        rguidDialect != DBGUID_DBSQL &&
        rguidDialect != DBGUID_SQL &&
        rguidDialect != DBGUID_DEFAULT )

        RRETURN( DB_E_DIALECTNOTSUPPORTED );

    //
    // If a CommandText is set  with a Null or an empty string, it effectively
    // unsets the CommandText to a null string
    //
    if( (pszCommand == NULL) ||
        (*pszCommand == L'\0') ) {

        if( _dwStatus & CMD_TEXT_SET )
            FreeADsStr(_pszCommandText);
        _pszCommandText = NULL;
        _dwStatus &= ~(CMD_TEXT_SET | CMD_PREPARED);

        RRETURN( S_OK );
    }

    //
    // Set the CommandText
    //
    LPWSTR pszSQLCmd = (LPWSTR)AllocADsMem((wcslen(pszCommand)+1) * sizeof(WCHAR));

    if( !pszSQLCmd )
        RRETURN( E_OUTOFMEMORY );

    //
    // Free the old memory, and set new text
    //
    if( _dwStatus & CMD_TEXT_SET )
        FreeADsMem(_pszCommandText);

    _pszCommandText = pszSQLCmd;
    wcscpy(_pszCommandText, pszCommand);

        //
        // Reset adspath present flag.
        //
    _fADSPathPresent = FALSE;

    //
    // Set status flag that we have set text
    //
    _dwStatus |= CMD_TEXT_SET;
    _dwStatus &= ~CMD_PREPARED;

    //
    // Remember the dialect that was passed in
    //
    _guidCmdDialect = rguidDialect;


    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::CanConvert
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::CanConvert(
    DBTYPE          wFromType,
    DBTYPE          wToType,
    DBCONVERTFLAGS  dwConvertFlags
    )
{
    RRETURN( CanConvertHelper(
                    wFromType,
                    wToType,
                    dwConvertFlags) );
}

//+---------------------------------------------------------------------------
//
//  Function:  SplitCommandText
//
//  Synopsis:
//
//
//  Arguments:
//
//
//
//
//
//
//  Returns:    HRESULT
//                  S_OK                    NO ERROR
//                  E_ADS_BAD_PARAMETER   bad parameter
//
//  Modifies:
//
//  History:    08-15-96   ShankSh     Created.
//              11-21-96   Felix Wong  modified to get only bind and attr
//----------------------------------------------------------------------------
HRESULT
CCommandObject::SplitCommandText(
        LPWSTR pszParsedCmd
        )
{
    LPWSTR pszAttrs = NULL;
    LPWSTR pszFirstAttr = NULL;
    LPWSTR pszCurrentAttr = NULL;
    LPWSTR pszSearchScope = NULL;
    LPWSTR pszTemp = NULL;
    HRESULT hr;
    LPWSTR ptr;

    // Command Text is the concatenation of three components separated by
    // semicolons
    //
    // 1. ADsPathName of the object of the root of the search  which contains
    //    the host name and the context enclosed by '<' and '>'
    // 2. The LDAP search string
    // 3. The list of names of the attributes to be returned separated by
    //    commas
    //
    // If the attributes have any specifiers like Range (for eg.,
    // objectclass;Range=0-1, we need to do some special processing to include
    // it in the list of attributes
    //
    // The fourth component is optional
    //
    // 4. The scope of the search: Either "Base", "Onelevel", "SubTree"
    //    (case insensitve)
    //
    // Search defaults to Subtree
    //
    // White spaces are insignificant

    _searchScope     = ADS_SCOPE_SUBTREE;
    _pszADsContext   = NULL;
    _pszSearchFilter = NULL;

    if( _ppszAttrs ) {
        FreeADsMem(_ppszAttrs);
        _ppszAttrs = NULL;
    }

    if( _pszCommandTextCp ) {
        FreeADsStr(_pszCommandTextCp);
        _pszCommandTextCp = NULL;
    }

    _pszCommandTextCp = AllocADsStr(pszParsedCmd);
    if( !_pszCommandTextCp)
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    _pszADsContext = RemoveWhiteSpaces(_pszCommandTextCp);

    if( _pszADsContext[0] != L'<' )     {
        BAIL_ON_FAILURE( hr=DB_E_ERRORSINCOMMAND);
    }

    _pszADsContext++;
    ptr = _pszADsContext;

    hr = SeekPastADsPath(ptr, &ptr);
    BAIL_ON_FAILURE( hr );

    if( *ptr != L'>' || *(ptr+1) != L';') {
        BAIL_ON_FAILURE( hr=DB_E_ERRORSINCOMMAND);
    }

    *ptr = L'\0';
    //
    // If the command text does not contain a filter, set it to NULL
    //
    if (*(ptr + 2) == L';') {
        _pszSearchFilter = NULL;
        ptr+=2;
    }
    else {
        _pszSearchFilter = ptr + 2;
        _pszSearchFilter = RemoveWhiteSpaces(_pszSearchFilter);
        hr = SeekPastSearchFilter(_pszSearchFilter, &ptr);
        BAIL_ON_FAILURE( hr );
    }


    if (*ptr != L';') {
        BAIL_ON_FAILURE( hr=DB_E_ERRORSINCOMMAND);
    }

    *ptr = L'\0';
    ptr++;

    //
    // The next component is the list of attributes followed by (optionally)
    // the scope of the search
    //

    // Since the attributes themselves can contain a ';' because of some
    // attribute specifiers, we need to make sure which ';' we are looking at.
    pszAttrs = ptr;

    while ((pszTemp = wcschr(ptr, ';')) != NULL)
        if ( !_wcsicmp(pszTemp+1, L"Base")     ||
             !_wcsicmp(pszTemp+1, L"Onelevel") ||
             !_wcsicmp(pszTemp+1, L"Subtree") )  {
            //
            // we have hit the end of the attribute list
            //
            *pszTemp = L'\0';
            pszSearchScope = pszTemp+1;
            break;
        }
        else {
            ptr = pszTemp + 1;
        }

    if( pszSearchScope ) {
        if(!_wcsicmp(pszSearchScope, L"Base"))
            _searchScope = ADS_SCOPE_BASE;
        else if(!_wcsicmp(pszSearchScope, L"Onelevel"))
            _searchScope = ADS_SCOPE_ONELEVEL;
        else if(!_wcsicmp(pszSearchScope, L"SubTree"))
            _searchScope = ADS_SCOPE_SUBTREE;
        else
            BAIL_ON_FAILURE( hr=DB_E_ERRORSINCOMMAND);

        //
        // set the search preference property
        //
        DBPROPSET rgCmdPropSet[1];
        DBPROP rgCmdProp[1];

        rgCmdPropSet[0].rgProperties    = rgCmdProp;
        rgCmdPropSet[0].cProperties     = 1;
        rgCmdPropSet[0].guidPropertySet = DBPROPSET_ADSISEARCH;

        rgCmdProp[0].dwPropertyID = ADS_SEARCHPREF_SEARCH_SCOPE;
        rgCmdProp[0].dwOptions = DBPROPOPTIONS_REQUIRED;
        rgCmdProp[0].vValue.vt = VT_I4;
        V_I4(&rgCmdProp[0].vValue) = _searchScope;

        hr = SetProperties(
                     1,
                     rgCmdPropSet);
        BAIL_ON_FAILURE( hr );
    }

    pszCurrentAttr = pszFirstAttr = wcstok(pszAttrs, L",");

    for (_cAttrs=0; pszCurrentAttr != NULL; _cAttrs++ )     {
        pszCurrentAttr = wcstok(NULL, L",");
    }

    if( _cAttrs == 0 ) {
        hr=DB_E_ERRORSINCOMMAND;
        goto error;
    }

    pszFirstAttr = RemoveWhiteSpaces(pszFirstAttr);

    if( _cAttrs == 1 && !wcscmp( pszFirstAttr, L"*")) {

        // _cAttrs=1; Just ADsPath and Class attribute is sent
        _ppszAttrs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * _cAttrs);

        if( !_ppszAttrs )
            BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

        _ppszAttrs[0] = gpszADsPathAttr;
        _fADSPathPresent = TRUE;
        _fAllAttrs = TRUE;
    }
    else {
        // Allocate memory for all the string pointers
        _ppszAttrs = (LPWSTR *) AllocADsMem(sizeof(LPWSTR) * (_cAttrs+1));

        if( !_ppszAttrs ) {
            BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );
        }

        pszCurrentAttr = pszFirstAttr;

        // Remember  if adspath and rdn are avaialble or not.
        for (ULONG i=0 ; i < _cAttrs; i++) {
            if( !_wcsicmp(L"ADsPath", pszCurrentAttr) )
                _fADSPathPresent = TRUE;

            _ppszAttrs[i] = pszCurrentAttr;
            pszCurrentAttr += wcslen(pszCurrentAttr) + 1;
            _ppszAttrs[i] = RemoveWhiteSpaces(_ppszAttrs[i]);
        }

        //
        // If adspath is not in the list add it
        //
        if( _fADSPathPresent == FALSE )
            _ppszAttrs[i] = L"ADsPath";

        _fAllAttrs = FALSE; // not a SELECT * query
    }

    RRETURN( S_OK );

error:

    _pszADsContext = NULL;

    if( _ppszAttrs ) {
        FreeADsMem(_ppszAttrs);
        _ppszAttrs = NULL;
    }

    if( _pszCommandTextCp ) {
        FreeADsStr(_pszCommandTextCp);
        _pszCommandTextCp = NULL;
    }

    RRETURN( hr );
}

//
// Look up for the given attribute name in the list of ADS_ATTR_DEF structures.
// Convert the ADSTYPE to the appropriate OLE DB type.
//
STDMETHODIMP
CCommandObject::GetDBType(
    PADS_ATTR_DEF pAttrDefinition,
    DWORD         dwNumAttrs,
    LPWSTR        pszAttrName,
    WORD *        pwType,
    DBLENGTH *    pulSize
    )
{
    HRESULT hr = S_OK;

    ADsAssert(pwType && pulSize);

    for (ULONG i=0; i < dwNumAttrs; i++) {
        if( !_wcsicmp(pszAttrName, pAttrDefinition[i].pszAttrName) )
            break;
    }

    if( i == dwNumAttrs )
    BAIL_ON_FAILURE( hr=E_ADS_PROPERTY_NOT_FOUND );

    if( pAttrDefinition[i].fMultiValued &&
        IsAutomatable(g_MapADsTypeToVarType[pAttrDefinition[i].dwADsType])) {
        //
        // Can be represented it as a variant
        //
        *pwType =  DBTYPE_VARIANT | DBTYPE_BYREF;
        *pulSize = sizeof(VARIANT);

    }
    else if( (ULONG)pAttrDefinition[i].dwADsType >= g_cMapADsTypeToDBType ||
             pAttrDefinition[i].dwADsType == ADSTYPE_INVALID              ||
             pAttrDefinition[i].dwADsType == ADSTYPE_PROV_SPECIFIC) {
        BAIL_ON_FAILURE( hr=E_ADS_CANT_CONVERT_DATATYPE );
    }
    else {
        *pwType =  g_MapADsTypeToDBType[pAttrDefinition[i].dwADsType].wType;
        *pulSize = g_MapADsTypeToDBType[pAttrDefinition[i].dwADsType].ulSize;
    }

error:

    RRETURN (hr);
}


STDMETHODIMP
CCommandObject::SetSearchPrefs(
        void
        )
{
    PROPSET              *pPropSet;
    PADS_SEARCHPREF_INFO  pSearchPref = NULL;
    HRESULT               hr = S_OK;
    ULONG                 i = 0;

    //
    // Asserts
    //
    ADsAssert(_pUtilProp);
    ADsAssert(_pDSSearch);

    pPropSet = _pUtilProp->GetPropSetFromGuid(DBPROPSET_ADSISEARCH);

    if( !pPropSet || !pPropSet->cProperties )
        RRETURN( S_OK );

    pSearchPref = (PADS_SEARCHPREF_INFO) AllocADsMem(
                                                 pPropSet->cProperties *
                                                 sizeof(ADS_SEARCHPREF_INFO)
                                                 );
    if( !pSearchPref )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    for (i=0; i<pPropSet->cProperties; i++) {
        hr = _pUtilProp->GetSearchPrefInfo(
                             pPropSet->pUPropInfo[i].dwPropertyID,
                             &pSearchPref[i]
                                                         );
        BAIL_ON_FAILURE( hr );
    }

    hr = _pDSSearch->SetSearchPreference(
                                pSearchPref,
                                pPropSet->cProperties
                                );

    BAIL_ON_FAILURE( hr );

error:

    if( pSearchPref )
    {
        //
        // Free the search preferences that have already been obtained.
        // If we didn't encounter an error obtaining the preferences
        // then i == pPropSet->cProperties
        //
        _pUtilProp->FreeSearchPrefInfo(pSearchPref, i);
        FreeADsMem(pSearchPref);
    }

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::CCommandObject
//
//  Synopsis:  Constructor
//
//  Arguments:
//             pUnkOuter         Outer Unkown Pointer
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CCommandObject::CCommandObject(
    LPUNKNOWN pUnkOuter       // Outer Unkown Pointer
    )
{
    //    Initialize simple member vars
    _pUnkOuter       = pUnkOuter ? pUnkOuter : (IAccessor FAR *) this;
    _dwStatus        = 0L;
    _cRowsetsOpen    = 0;
    _pAccessor       = NULL;
    _pUtilProp       = NULL;
    _pDSSearch       = NULL;
    _fADSPathPresent = FALSE;
    _fAllAttrs       = FALSE;

    ENLIST_TRACKING(CCommandObject);
    return;
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::~CCommandObject
//
//  Synopsis:  Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CCommandObject::~CCommandObject( )
{
    if( _pCSession ) {
        _pCSession->DecrementOpenCommands();
        _pCSession->Release();
    }

    delete _pUtilProp;

    if( _pszCommandText ) {
        FreeADsMem(_pszCommandText);
    }

    if( _ppszAttrs ) {
        FreeADsMem(_ppszAttrs);
    }

    if( _pszCommandTextCp ) {
        FreeADsStr(_pszCommandTextCp);
    }

    if( _pAccessor )
        delete _pAccessor;

    if( _pIMalloc )
        _pIMalloc->Release();

    if( _pDSSearch ) {
        _pDSSearch->Release();
    }
}


//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::FInit
//
//  Synopsis:  Initialize the data source Object
//
//  Arguments:
//
//  Returns:
//             Did the Initialization Succeed
//                  TRUE        Initialization succeeded
//                  FALSE       Initialization failed
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
BOOL
CCommandObject::FInit(
    CSessionObject * pSession,
    CCredentials&    Credentials
    )
{
    HRESULT hr;

    //
    // Asserts
    //
    ADsAssert(pSession);
    ADsAssert(&Credentials);

    _pCSession = pSession;
    _pCSession->AddRef();
    _pCSession->IncrementOpenCommands();

    //
    // Allocate properties management object
    //
    _pUtilProp = new CUtilProp();
    if( !_pUtilProp )
        return FALSE;

    hr = _pUtilProp->FInit(&Credentials);
    BAIL_ON_FAILURE(hr);

    // IAccessor is always instantiated.
    _pAccessor = new CImpIAccessor(this, _pUnkOuter);
    if( _pAccessor == NULL || FAILED(_pAccessor->FInit()) )
        return FALSE;

    hr = CoGetMalloc(MEMCTX_TASK, &_pIMalloc);
    if( FAILED(hr) )
        return FALSE;

    _Credentials = Credentials;

    return TRUE;

error:

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::QueryInterface
//
//  Synopsis:  Returns a pointer to a specified interface. Callers use
//             QueryInterface to determine which interfaces the called object
//             supports.
//
//  Arguments:
//            riid     Interface ID of the interface being queried for
//            ppv      Pointer to interface that was instantiated
//
//  Returns:
//             S_OK               Interface is supported and ppvObject is set.
//             E_NOINTERFACE      Interface is not supported by the object
//             E_INVALIDARG       One or more arguments are invalid.
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCommandObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    // Is the pointer bad?
    if( ppv == NULL )
        RRETURN( E_INVALIDARG );

    if( IsEqualIID(iid, IID_IUnknown) ) {
        *ppv = (IAccessor FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IAccessor) ) {
        *ppv = (IAccessor FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IColumnsInfo) ) {
        *ppv = (IColumnsInfo FAR *) this;
    }
    else if( IsEqualIID(iid, IID_ICommand) ) {
        *ppv = (ICommand FAR *) this;
    }
    else if( IsEqualIID(iid, IID_ICommandProperties) ) {
        *ppv = (ICommandProperties FAR *) this;
    }
    else if( IsEqualIID(iid, IID_ICommandText) ) {
        *ppv = (ICommandText FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IConvertType) ) {
        *ppv = (IConvertType FAR *) this;
    }
    else if( IsEqualIID(iid, IID_ICommandPrepare) ) {
        *ppv = (ICommandPrepare FAR *) this;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

BOOL
IsAutomatable(
    DBTYPE dbType
    )
{
    if (dbType != DBTYPE_NULL) {
        return TRUE;
    }
    else {
        return FALSE;
    }
}

HRESULT
CCommandObject::SeekPastADsPath(
    IN  LPWSTR   pszIn,
    OUT LPWSTR * ppszOut
    )
{
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;
    WCHAR ch = 0;

    // No. of LParans '<' over RParans '>'
    DWORD dwParanOffset = 1;

    ADsAssert(pszIn);
    ADsAssert(ppszOut);

    while (1) {

        ch = *pszIn;

        if( ch == TEXT('\0') ) {
            break;
        }

        if( fEscapeOn ) {
            fEscapeOn = FALSE;
                }
        else if( fQuotingOn ) {
            if( ch == TEXT('"') ) {
                fQuotingOn = FALSE;
            }
        }
        else if( ch == TEXT('\\') ) {
            fEscapeOn = TRUE;
        }
        else if( ch == TEXT('"') ) {
            fQuotingOn = TRUE;
        }
        else if( ch == L'<' ) {
            dwParanOffset++;
        }
        else if( ch == L'>' ) {
            if( --dwParanOffset == 0)
                break;
        }

        pszIn++;
    }

    if( fEscapeOn || fQuotingOn || dwParanOffset != 0 ) {
        RRETURN( DB_E_ERRORSINCOMMAND );
    }

    *ppszOut = pszIn;

    RRETURN( S_OK );
}


HRESULT
CCommandObject::SeekPastSearchFilter(
    IN  LPWSTR   pszIn,
    OUT LPWSTR * ppszOut
    )
{
    BOOL fEscapeOn = FALSE, fQuotingOn = FALSE;
    DWORD dwParanOffset = 0;

    ADsAssert(pszIn);

    if( *pszIn != L'(' ) {
        RRETURN( DB_E_ERRORSINCOMMAND );
        }

    //
    // No. of LParans over RParans
    //
    dwParanOffset = 1;
    pszIn++;

    while (*pszIn && (*pszIn != L')' || dwParanOffset != 1)) {

        if( *pszIn == L'(' ) {
            dwParanOffset++;
        }

        if( *pszIn == L')' ) {
            dwParanOffset--;
        }

        pszIn++;
    }

    if( *pszIn != L')' ) {
        RRETURN( DB_E_ERRORSINCOMMAND );
    }

    *ppszOut = pszIn + 1;

    RRETURN( S_OK );
}


HRESULT
CCommandObject::Prepare(
    ULONG cExpectedRuns
    )
{
    //
    // If the command has not been set, make sure the buffer
    // contains an empty stringt to return to the consumer
    //
    if( !IsCommandSet() )
        RRETURN( DB_E_NOCOMMAND );

    //
    // Don't allow prepare if we've got a rowset open
    //
    if( IsRowsetOpen() )
        RRETURN( DB_E_OBJECTOPEN );

    //
    // SQL dialect: Convert to LDAP and save
    //
    HRESULT hr = PrepareHelper();

    //
    // Fixup the HRESULT
    //
    if( hr == DB_E_NOTABLE )
        hr = DB_E_ERRORSINCOMMAND;

    BAIL_ON_FAILURE( hr );

    //
    // Set the Prepare state
    //
    _dwStatus |= CMD_PREPARED;

error:

    RRETURN( hr );
}


HRESULT
CCommandObject::Unprepare()
{
    //
    // Don't allow unprepare if we've got a rowset open
    //
    if( IsRowsetOpen() )
        RRETURN( DB_E_OBJECTOPEN );

    //
    // Reset the Prepare state
    //
    _dwStatus &= ~(CMD_PREPARED);

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:  CCommandObject::PrepareHelper
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CCommandObject::PrepareHelper(void)
{
    LPWSTR  pszOrderList = NULL;
    LPWSTR  pszSelect    = NULL;
    LPWSTR  pszLocation  = NULL;
    LPWSTR  pszLdapQuery = NULL;
    LPWSTR  pszParsedCmd = NULL;

    //
    // SQL dialect: Convert to LDAP and save
    // If SQLParse Fails the function cleans up memory
    //
    HRESULT hr = SQLParse(
                     (const LPWSTR) _pszCommandText,
                     &pszLocation,
                     &pszLdapQuery,
                     &pszSelect,
                     &pszOrderList
                     );

    if( FAILED(hr) && hr != E_ADS_INVALID_FILTER)
        RRETURN( hr=DB_E_ERRORSINCOMMAND );

    if (SUCCEEDED(hr))
    {
        //
        // the ldap query is optional, it can be NULL. When it is NULL, it 
        // implies a * search.
        //
        DWORD dwLdapQuery = 0;
        if (pszLdapQuery) {
            dwLdapQuery = wcslen(pszLdapQuery);
        }
        pszParsedCmd =(LPWSTR) AllocADsMem((wcslen(pszLocation) +
                                            dwLdapQuery+
                                            wcslen(pszSelect) +
                                            5 + // 2 semicolons and 2 <
                                            1) * sizeof(WCHAR));

        if( !pszParsedCmd ) {
            _dwStatus &= ~CMD_TEXT_SET;
            BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );
        }

        //
        // Put the statement together.
        //
        wcscpy(pszParsedCmd, L"<");
        wcscat(pszParsedCmd, pszLocation);
        wcscat(pszParsedCmd, L">;");
        if (pszLdapQuery)
            wcscat(pszParsedCmd, pszLdapQuery);
        wcscat(pszParsedCmd, L";");
        wcscat(pszParsedCmd, pszSelect);

        hr = SplitCommandText(pszParsedCmd);
    }
    else
    {
        //
        // Assume valid LDAP filter
        //

        hr = SplitCommandText(_pszCommandText);
    }

    BAIL_ON_FAILURE( hr )

    //
    // Set the sort preference property if necessary
    //
    if( pszOrderList ) {

        DBPROPSET rgCmdPropSet[1];
        DBPROP rgCmdProp[1];

        rgCmdPropSet[0].rgProperties    = rgCmdProp;
        rgCmdPropSet[0].cProperties     = 1;
        rgCmdPropSet[0].guidPropertySet = DBPROPSET_ADSISEARCH;

        rgCmdProp[0].dwPropertyID = ADSIPROP_SORT_ON;
        rgCmdProp[0].dwOptions    = DBPROPOPTIONS_REQUIRED;
        rgCmdProp[0].vValue.vt    = VT_BSTR;
        V_BSTR (&rgCmdProp[0].vValue) = pszOrderList;

        hr = SetProperties(1, rgCmdPropSet);
        BAIL_ON_FAILURE( hr );
    }

    if( _pDSSearch ) {
        _pDSSearch->Release();
        _pDSSearch = NULL;
    }

    //
    // If integrated security is being used, impersonate the caller
    //
    BOOL fImpersonating;

    fImpersonating = FALSE;
    if(_pCSession->IsIntegratedSecurity())
    {
        HANDLE ThreadToken = _pCSession->GetThreadToken();

        ASSERT(ThreadToken != NULL);
        if (ThreadToken)
        {
            if (!ImpersonateLoggedOnUser(ThreadToken))
                RRETURN(E_FAIL);
            fImpersonating = TRUE;
        }
        else
            RRETURN(E_FAIL);
    }

    hr = GetDSInterface(_pszADsContext,
                        _Credentials,
                        IID_IDirectorySearch,
                        (void **)&_pDSSearch);

   if (fImpersonating)
    {
        RevertToSelf();
        fImpersonating = FALSE;
    }

    BAIL_ON_FAILURE( hr );

error:

    if( pszLocation )
        FreeADsMem(pszLocation);

    if( pszLdapQuery )
       FreeADsMem(pszLdapQuery);

    if( pszSelect )
        FreeADsMem(pszSelect);

    if( pszOrderList )
        FreeADsStr(pszOrderList);

    if( pszParsedCmd )
        FreeADsStr(pszParsedCmd);

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cdnbincf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdnbincf.cxx
//
//  Contents:  DN With Binary Object class factory
//
//             CADsDNWithBinaryCF::CreateInstance
//
//  History:   04-26-1999     AjayR    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsDNWithBinaryCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsDNWithBinaryCF::CreateInstance(IUnknown * pUnkOuter,
                                  REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CDNWithBinary::CreateDNWithBinary(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cdnbin.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:  CDNWithBinary.cxx
//
//  Contents:  DNWithBinary object
//
//  History:   4-23-99     AjayR    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CDNWithBinary

DEFINE_IDispatch_Implementation(CDNWithBinary)

CDNWithBinary::CDNWithBinary():
        _pDispMgr(NULL),
        _pszDNStr(NULL),
        _dwLength(0),
        _lpOctetStr(NULL)
{
    ENLIST_TRACKING(CDNWithBinary);
}


HRESULT
CDNWithBinary::CreateDNWithBinary(
    REFIID riid,
    void **ppvObj
    )
{
    CDNWithBinary FAR * pDNWithBinary = NULL;
    HRESULT hr = S_OK;

    hr = AllocateDNWithBinaryObject(&pDNWithBinary);
    BAIL_ON_FAILURE(hr);

    hr = pDNWithBinary->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pDNWithBinary->Release();

    RRETURN(hr);

error:
    delete pDNWithBinary;

    RRETURN_EXP_IF_ERR(hr);

}


CDNWithBinary::~CDNWithBinary( )
{
    delete _pDispMgr;

    if (_lpOctetStr) {
        FreeADsMem(_lpOctetStr);
    }

    if (_pszDNStr) {
        FreeADsStr(_pszDNStr);
    }
}

STDMETHODIMP
CDNWithBinary::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsDNWithBinary FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsDNWithBinary))
    {
        *ppv = (IADsDNWithBinary FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsDNWithBinary FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CDNWithBinary::AllocateDNWithBinaryObject(
    CDNWithBinary ** ppDNWithBinary
    )
{
    CDNWithBinary FAR * pDNWithBinary = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pDNWithBinary = new CDNWithBinary();
    if (pDNWithBinary == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsDNWithBinary,
                (IADsDNWithBinary *)pDNWithBinary,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pDNWithBinary->_pDispMgr = pDispMgr;
    *ppDNWithBinary = pDNWithBinary;

    RRETURN(hr);

error:

    delete pDNWithBinary;
    delete pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CDNWithBinary::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsDNWithBinary)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

//
// Methods to get and put the octet string part.
//

STDMETHODIMP
CDNWithBinary::get_BinaryValue(THIS_ VARIANT FAR* pvBinaryValue)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    /*
    if (!pvBinaryValue) {
    }
        RRETURN_EXP_IF_ERR(hr = E_ADS_BAD_PARAMETER);
    }
    */

    aBound.lLbound = 0;
    aBound.cElements = _dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, _lpOctetStr, aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pvBinaryValue) = VT_ARRAY | VT_UI1;
    V_ARRAY(pvBinaryValue) = aList;

    RRETURN(hr);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}


STDMETHODIMP
CDNWithBinary::put_BinaryValue(THIS_ VARIANT vBinaryValue)
{
    HRESULT hr = S_OK;
    VARIANT *pvProp = NULL;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    //
    // Check for variant by ref.
    //
    pvProp = &vBinaryValue;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&vBinaryValue);
    }

    if (_lpOctetStr) {
        FreeADsMem(_lpOctetStr);
        _lpOctetStr = NULL;
        _dwLength = 0;
    }

    if( pvProp->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_BAD_PARAMETER);
    }

    hr = SafeArrayGetLBound(
             V_ARRAY(pvProp),
             1,
             (long FAR *) &dwSLBound
             );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
             V_ARRAY(pvProp),
             1,
             (long FAR *) &dwSUBound
             );
    BAIL_ON_FAILURE(hr);

    _dwLength = dwSUBound -dwSLBound + 1;

    _lpOctetStr = (LPBYTE) AllocADsMem(_dwLength);

    if (!_lpOctetStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = SafeArrayAccessData(
             V_ARRAY(pvProp),
             (void HUGEP * FAR *) &pArray
             );
    BAIL_ON_FAILURE(hr);

    memcpy(_lpOctetStr, pArray, _dwLength);

    SafeArrayUnaccessData( V_ARRAY(pvProp) );

error:

    if (_lpOctetStr && FAILED(hr)) {
        FreeADsMem(_lpOctetStr);
        _lpOctetStr = NULL;
        _dwLength = NULL;
    }

    RRETURN(hr);

}


//
// Methods to get and put the DN string.
//

STDMETHODIMP
CDNWithBinary::get_DNString(THIS_ BSTR FAR* pbstrDNString)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = ValidateOutParameter(pbstrDNString))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_pszDNStr, pbstrDNString);

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CDNWithBinary::put_DNString(THIS_ BSTR bstrDNString)
{

    HRESULT hr = S_OK;

    if (_pszDNStr) {
        FreeADsStr(_pszDNStr);
        _pszDNStr = NULL;
    }

    _pszDNStr = AllocADsStr(bstrDNString);

    if (bstrDNString && !_pszDNStr) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cacl.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cAccessControlList.cxx
//
//  Contents:  AccessControlList object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CAccessControlList

DEFINE_IDispatch_Implementation(CAccessControlList)

CAccessControlList::CAccessControlList():
        _pDispMgr(NULL),
        _dwAclRevision(0),
        _dwAceCount(0),
        _pAccessControlEntry(NULL),
        _pCurrentEntry(NULL),
        _pACLEnums(NULL)
{
    ENLIST_TRACKING(CAccessControlList);
}


HRESULT
CAccessControlList::CreateAccessControlList(
    REFIID riid,
    void **ppvObj
    )
{
    CAccessControlList FAR * pAccessControlList = NULL;
    HRESULT hr = S_OK;

    hr = AllocateAccessControlListObject(&pAccessControlList);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlList->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pAccessControlList->Release();

    RRETURN(hr);

error:
    delete pAccessControlList;

    RRETURN_EXP_IF_ERR(hr);

}


CAccessControlList::~CAccessControlList( )
{
    PACCESS_CONTROL_ENTRY pTemp = NULL;
    PACCESS_CONTROL_ENTRY pNext = NULL;

    PACL_ENUM_ENTRY pACL = _pACLEnums;


    delete _pDispMgr;

    pTemp = _pAccessControlEntry;

    while (pTemp) {

        pNext = pTemp->pNext;

        if (pTemp->pAccessControlEntry) {

            (pTemp->pAccessControlEntry)->Release();
        }
        FreeADsMem(pTemp);
        pTemp = pNext;
    }


    //
    // since each enumerator hold ref count on this ACL, this destructor should
    // never be called unless all of its enumerators' destructors have been
    // invoked. In the enumerator's destructor, RemoveEnumerator is called
    // first before release ref count on this. Thus, by the time, at this
    // point, pACL should be empty.
    //

    ADsAssert(!pACL);

    //
    // just in case we have bug in codes, e.g enumerators not all destroyed
    // before dll detachement. don't want to leak here anyway
    //

    while (pACL) {

        _pACLEnums = pACL->pNext;

        //
        // free the entry but do not destroy the enumerator since clients
        // should release all interface ptrs to enumerator for destruction.
        //

        FreeADsMem(pACL);
        pACL = _pACLEnums;
    }
}

STDMETHODIMP
CAccessControlList::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsAccessControlList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsAccessControlList))
    {
        *ppv = (IADsAccessControlList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsAccessControlList FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }    
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CAccessControlList::AllocateAccessControlListObject(
    CAccessControlList ** ppAccessControlList
    )
{
    CAccessControlList FAR * pAccessControlList = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pAccessControlList = new CAccessControlList();
    if (pAccessControlList == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsAccessControlList,
                (IADsAccessControlList *)pAccessControlList,
                DISPID_NEWENUM
                );
    BAIL_ON_FAILURE(hr);

    pAccessControlList->_pDispMgr = pDispMgr;
    *ppAccessControlList = pAccessControlList;

    RRETURN(hr);

error:

    delete pAccessControlList;
    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CAccessControlList::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsAccessControlList) ||
        IsEqualIID(riid, IID_IEnumVARIANT)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP
CAccessControlList::CopyAccessList(
    THIS_ IDispatch FAR * FAR * ppAccessControlList
    )
{
    HRESULT hr = S_OK;
    DWORD dwAceCount = 0;
    DWORD dwNewAceCount = 0;
    DWORD dwAclRevision = 0;
    DWORD i = 0;
    VARIANT varAce;
    IADsAccessControlEntry * pSourceAce = NULL;
    IADsAccessControlEntry * pTargetAce = NULL;
    IDispatch * pTargDisp = NULL;
    DWORD cElementFetched = 0;
    IADsAccessControlList * pAccessControlList = NULL;
    

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);

    dwAceCount = _dwAceCount;
    dwAclRevision = _dwAclRevision;

    //
    // Reset the enumerator
    //

    _pCurrentEntry = _pAccessControlEntry;

    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);
        hr = Next(1, &varAce, &cElementFetched);
        CONTINUE_ON_FAILURE(hr);

        hr = (V_DISPATCH(&varAce))->QueryInterface(
                        IID_IADsAccessControlEntry,
                        (void **)&pSourceAce
                        );
        VariantClear(&varAce);
        
        CONTINUE_ON_FAILURE(hr);

        hr = CopyAccessControlEntry(
                    pSourceAce,
                    &pTargetAce
                    );
        BAIL_ON_FAILURE(hr);

        hr = pTargetAce->QueryInterface(
                            IID_IDispatch,
                            (void **)&pTargDisp
                            );
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlList->AddAce(pTargDisp);
        BAIL_ON_FAILURE(hr);

        dwNewAceCount++;

        if (pTargDisp) {
            pTargDisp->Release();
            pTargDisp = NULL;
        }

        if (pTargetAce) {
            pTargetAce->Release();
            pTargetAce = NULL;
        }

        if (pSourceAce) {
            pSourceAce->Release();
            pSourceAce = NULL;
        }
        
    }

    hr= pAccessControlList->put_AceCount(dwNewAceCount);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlList->put_AclRevision((long)dwAclRevision);
    BAIL_ON_FAILURE(hr);

    *ppAccessControlList = pAccessControlList;

error:

    if (pTargDisp) {
        pTargDisp->Release();
        pTargDisp = NULL;
    }

    if (pTargetAce) {
        pTargetAce->Release();
        pTargetAce = NULL;
    }

    if (pSourceAce) {
        pSourceAce->Release();
        pSourceAce = NULL;
    }    

    if(FAILED(hr) && pAccessControlList)
    {
        pAccessControlList->Release();
        pAccessControlList = NULL;
    }
        
    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CAccessControlList::AddAce(
    THIS_ IDispatch FAR *  pAccessControlEntry
    )
{

    HRESULT hr = S_OK;
    PACCESS_CONTROL_ENTRY pAccessEntry = NULL;
    PACCESS_CONTROL_ENTRY pTemp = NULL;
    IADsAccessControlEntry * pAce = NULL;

    hr = pAccessControlEntry->QueryInterface(
                            IID_IADsAccessControlEntry,
                            (void **)&pAce
                            );
    BAIL_ON_FAILURE(hr);

    pAccessEntry = (PACCESS_CONTROL_ENTRY)AllocADsMem(
                                sizeof(ACCESS_CONTROL_ENTRY)
                                );
    if (!pAccessEntry) {

        pAce->Release();
        RRETURN(E_OUTOFMEMORY);
    }

    pAccessEntry->pAccessControlEntry = pAce;

    //
    // - Now append this ace to the very end.
    // - Since ACE is added to the end, no need to call
    //  AdjustCurPtrOfEnumerators().
    //

    if (!_pAccessControlEntry) {

        _pAccessControlEntry = pAccessEntry;

    }else {

        pTemp = _pAccessControlEntry;

        while (pTemp->pNext) {

            pTemp = pTemp->pNext;
        }

        pTemp->pNext = pAccessEntry;

    }

    //
    // Now up the ace count
    //

    _dwAceCount++;

error:

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CAccessControlList::RemoveAce(
    THIS_ IDispatch FAR *  pAccessControlEntry
    )
{
    HRESULT hr = S_OK;
    PACCESS_CONTROL_ENTRY pTemp = NULL;
    IADsAccessControlEntry * pAce = NULL;
    PACCESS_CONTROL_ENTRY pAccessEntry = NULL;
    DWORD dwRemovePos = 1;      // one-based indexing since enumerator was
                                // written that way

    if (!_pAccessControlEntry) {

        RRETURN(E_FAIL);
    }


    hr =  pAccessControlEntry->QueryInterface(
                                    IID_IADsAccessControlEntry,
                                    (void **)&pAce
                                    );
    BAIL_ON_FAILURE(hr);


    pAccessEntry = _pAccessControlEntry;


    //
    // It is the first entry
    //


    if (EquivalentAces(pAccessEntry->pAccessControlEntry, pAce)) {

        //
        //  Check if we have an enumerator pointed to us
        //

        if (pAccessEntry == _pCurrentEntry) {

            _pCurrentEntry = pAccessEntry->pNext;
        }

        _pAccessControlEntry = pAccessEntry->pNext;

        (pAccessEntry->pAccessControlEntry)->Release();

         FreeADsMem(pAccessEntry);


         if (pAce) {
             pAce->Release();
         }

         //
         // Decrement the Ace count
         //

         _dwAceCount--;

        //
        // Adjust "current" ptr of all enumerators if necessary
        //

        AdjustCurPtrOfEnumerators(dwRemovePos, FALSE);

         RRETURN(S_OK);

    }

    while (pAccessEntry->pNext) {

        pTemp = pAccessEntry->pNext;
        dwRemovePos++;

        if (EquivalentAces(pTemp->pAccessControlEntry, pAce)){

            //
            //  Check if we have an enumerator pointed to us
            //

            if (pAccessEntry == _pCurrentEntry) {

                _pCurrentEntry = pAccessEntry->pNext;
            }

            pAccessEntry->pNext = pTemp->pNext;

            (pTemp->pAccessControlEntry)->Release();

             FreeADsMem(pTemp);

             if (pAce) {
                 pAce->Release();
             }

             //
             // Decrement the Ace count
             //

             _dwAceCount--;

            //
            // Adjust "current" ptr of all enumerators if necessary
            //

            AdjustCurPtrOfEnumerators(dwRemovePos, FALSE);


             RRETURN(S_OK);

        }

        pAccessEntry = pAccessEntry->pNext;
    }


    if (pAce) {
        pAce->Release();

    }

error:

    RRETURN_EXP_IF_ERR(E_FAIL);
}

STDMETHODIMP
CAccessControlList::get_AclRevision(THIS_ long FAR * retval)
{

    *retval = _dwAclRevision;
    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlList::put_AclRevision(THIS_ long lnAclRevision)
{

    _dwAclRevision = lnAclRevision;
    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlList::get_AceCount(THIS_ long FAR * retval)
{

    *retval = _dwAceCount;
    RRETURN(S_OK);
}

STDMETHODIMP
CAccessControlList::put_AceCount(THIS_ long lnAceCount)
{

    _dwAceCount = lnAceCount;
    RRETURN(S_OK);
}


STDMETHODIMP
CAccessControlList::Next(ULONG cElements, VARIANT FAR* pvar, ULONG FAR* pcElementFetched)
{
   DWORD i = 0;
   DWORD j = 0;
   IDispatch * pDispatch = NULL;
   IADsAccessControlEntry * pAccessControlEntry = NULL;
   PACCESS_CONTROL_ENTRY pTemp = NULL;
   PVARIANT pThisVar;
   HRESULT hr = S_OK;


   pTemp = _pCurrentEntry;

   if (!pTemp) {
       if (pcElementFetched) {
           *pcElementFetched = 0;
       }

       RRETURN(S_FALSE);
   }


   while (pTemp && (j < cElements)){

      pThisVar = pvar + j;
      VariantInit(pThisVar);

      pAccessControlEntry = pTemp->pAccessControlEntry;

      hr = pAccessControlEntry->QueryInterface(
                                     IID_IDispatch,
                                     (void **)&pDispatch
                                     );

      if(!SUCCEEDED(hr))
      {
          pTemp = pTemp->pNext;          
          continue;
      }

      V_DISPATCH(pThisVar) = pDispatch;
      V_VT(pThisVar) = VT_DISPATCH;

      pTemp = pTemp->pNext;
      j++;
   }

   if (pcElementFetched) {
      *pcElementFetched = j;
   }

   //
   // Advance _pCurrentEntry
   //


   _pCurrentEntry = pTemp;

   if (j < cElements) {
      RRETURN (S_FALSE);
   }

   RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccessControlList::GetElement
//
//  Synopsis:   Get the dwPos'th ACE in the ACL. Note that no
//            refCount is added to the ACE, it is the responsibility
//            of the caller to handle that.
//
//  Arguments:  [dwPos] the ACE required
//              [pAce] Pointer to ACE returned in this param.
//
//  Returns:    HRESULT
//
//  Modifies:   [pAce]
//
//----------------------------------------------------------------------------
HRESULT
CAccessControlList::GetElement(
    DWORD dwPos,
    IADsAccessControlEntry ** pAce
    )
{
    HRESULT hr = S_OK;
    DWORD j = 1;
    PACCESS_CONTROL_ENTRY pTemp = NULL;

    *pAce = NULL;
    // set to the acl head
    pTemp = _pAccessControlEntry;

    if (_dwAceCount < dwPos) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    while (pTemp && (j < dwPos)) {
        pTemp = pTemp->pNext;
        j++;
    }

    if (!pTemp || pTemp == NULL) {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    // we should have the correct ACE here
    *pAce = pTemp->pAccessControlEntry;

error:
    if (FAILED(hr)) {
        hr = S_FALSE;
    }
    RRETURN(hr);
}


STDMETHODIMP
CAccessControlList::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr = S_OK;
    IEnumVARIANT * penum = NULL;

    *retval = NULL;

    hr = CAccCtrlListEnum::CreateAclEnum(
             (CAccCtrlListEnum **)&penum,
             this
             );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                   IID_IUnknown,
                   (VOID FAR* FAR*)retval
                   );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    //
    // keep a linked list of all enumerators that enumerate on this ACL
    // But don't hold on to inteface ptr of enumerators; otherwise, cycle
    // reference count. Do this only after above succeed.
    //

    hr = AddEnumerator(
            (CAccCtrlListEnum *)penum
            );
    BAIL_ON_FAILURE(hr);

error:

    if (FAILED(hr) && penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

HRESULT
CAccessControlList::
AddEnumerator(
    CAccCtrlListEnum *pACLEnum
    )
{
    PACL_ENUM_ENTRY pNewACLEnum = NULL;

    //
    // don't want add NULL enumerator as an entry to add complication everywhere
    //

    ADsAssert(pACLEnum);


    pNewACLEnum = (PACL_ENUM_ENTRY) AllocADsMem(sizeof(ACL_ENUM_ENTRY));

    if (!pNewACLEnum)
        RRETURN(E_OUTOFMEMORY);

    //
    // We are only adding a ptr to the enumerator.
    // Don't hold on to inteface ptr. Otherwise, this has ref count on
    // enumerator has ref count on this. Cycle reference count.
    //

    pNewACLEnum->pACLEnum = pACLEnum;

    pNewACLEnum->pNext = _pACLEnums;
    _pACLEnums = pNewACLEnum;

    RRETURN(S_OK);
}

HRESULT
CAccessControlList::
RemoveEnumerator(
    CAccCtrlListEnum *pACLEnum
    )
{
    PACL_ENUM_ENTRY pCurACLEnum = _pACLEnums;
    PACL_ENUM_ENTRY pPrevACLEnum = NULL;

    //
    // can't think of a case needing to remove a pACLEnum which may be
    // NULL now. Don't want to add complication. Probably coding error.
    //

    ADsAssert(pACLEnum);


    //
    // optional, but we really shouldn't call this if _pACLEnums is NULL
    //

    ADsAssert(_pACLEnums);


    //
    // check the first enumerator
    //

    if (pCurACLEnum) {

        //
        // match what we want to remove
        //

        if (pCurACLEnum->pACLEnum == pACLEnum) {

            //
            // remove the enumerator from our list but don't destroy
            // the enumerator
            //

            _pACLEnums = pCurACLEnum->pNext;
            FreeADsMem(pCurACLEnum);

            RRETURN(S_OK);
        }

    } else {

        RRETURN(E_FAIL);
    }


    //
    // start checking from the second element, if any, of the list
    //

    pPrevACLEnum = pCurACLEnum;
    pCurACLEnum = pCurACLEnum->pNext;

    while (pCurACLEnum && (pCurACLEnum->pACLEnum!=pACLEnum)) {

        pPrevACLEnum = pCurACLEnum;
        pCurACLEnum = pCurACLEnum->pNext;
    }


    if (pCurACLEnum) {

        //
        // match found
        //

        pPrevACLEnum->pNext = pCurACLEnum->pNext;
        FreeADsMem(pCurACLEnum);

        RRETURN(S_OK);

    } else {

        RRETURN(E_FAIL);
    }

}


BOOL
EquivalentStrings(
    BSTR bstrSrcString,
    BSTR bstrDestString
    )
{
    if (!bstrSrcString && !bstrDestString) {
        return(TRUE);
    }
    if (!bstrSrcString && bstrDestString) {
        return(FALSE);
    }
    if (!bstrDestString && bstrSrcString) {
        return(FALSE);
    }
#ifdef WIN95
    if (!_wcsicmp(bstrSrcString, bstrDestString)) {
#else
    if (CompareStringW(
            LOCALE_SYSTEM_DEFAULT,
            NORM_IGNORECASE,
            bstrSrcString,
            -1,
            bstrDestString,
            -1
            ) 
        == CSTR_EQUAL) {
#endif
        return(TRUE);
    }

    return(FALSE);
}


BOOL
EquivalentAces(
    IADsAccessControlEntry  * pSourceAce,
    IADsAccessControlEntry  * pDestAce
    )
{
    HRESULT hr = S_OK;

    BSTR bstrSrcTrustee = NULL;
    BSTR bstrDestTrustee = NULL;

    DWORD dwSrcMask = 0;
    DWORD dwDestMask = 0;

    DWORD dwSrcAceFlags = 0;
    DWORD dwDestAceFlags = 0;

    DWORD dwSrcAceType = 0;
    DWORD dwDestAceType = 0;

    DWORD dwSrcFlags  = 0;
    DWORD dwDestFlags = 0;

    BSTR bstrSrcObjectType = NULL;
    BSTR bstrDestObjectType = NULL;

    BSTR bstrSrcInherObjType = NULL;
    BSTR bstrDestInherObjType = NULL;

    BOOL dwRet = FALSE;

    hr = pSourceAce->get_Trustee(&bstrSrcTrustee);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_Trustee(&bstrDestTrustee);
    BAIL_ON_FAILURE(hr);

    if (!EquivalentStrings(bstrSrcTrustee, bstrDestTrustee)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = pSourceAce->get_AccessMask((long *)&dwSrcMask);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_AccessMask((long *)&dwDestMask);
    BAIL_ON_FAILURE(hr);

    if (dwSrcMask != dwDestMask) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = pSourceAce->get_AceFlags((long *)&dwSrcAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_AceFlags((long *)&dwDestAceFlags);
    BAIL_ON_FAILURE(hr);

    if (dwSrcAceFlags != dwDestAceFlags) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    hr = pSourceAce->get_AceType((long *)&dwSrcAceType);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_AceType((long *)&dwDestAceType);
    BAIL_ON_FAILURE(hr);

    if (dwSrcAceType != dwDestAceType) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    hr = pSourceAce->get_Flags((long *)&dwSrcFlags);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_Flags((long *)&dwDestFlags);
    BAIL_ON_FAILURE(hr);

    if (dwSrcFlags != dwDestFlags) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    hr = pSourceAce->get_ObjectType(&bstrSrcObjectType);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_ObjectType(&bstrDestObjectType);
    BAIL_ON_FAILURE(hr);

    if (!EquivalentStrings(bstrSrcObjectType, bstrDestObjectType)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }



    hr = pSourceAce->get_InheritedObjectType(&bstrSrcInherObjType);
    BAIL_ON_FAILURE(hr);

    hr = pDestAce->get_InheritedObjectType(&bstrDestInherObjType);
    BAIL_ON_FAILURE(hr);

    if (!EquivalentStrings(bstrSrcInherObjType, bstrDestInherObjType)) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    dwRet = TRUE;

cleanup:

    if (bstrSrcTrustee) {
        ADsFreeString(bstrSrcTrustee);
    }

    if (bstrDestTrustee) {
        ADsFreeString(bstrDestTrustee);
    }

    if (bstrSrcObjectType) {
        ADsFreeString(bstrSrcObjectType);
    }

    if (bstrDestObjectType) {
        ADsFreeString(bstrDestObjectType);
    }

    if (bstrSrcInherObjType) {
        ADsFreeString(bstrSrcInherObjType);
    }

    if (bstrDestInherObjType) {
        ADsFreeString(bstrDestInherObjType);
    }

    return(dwRet);

error:

    dwRet = FALSE;

    goto cleanup;
}


void
CAccessControlList::
AdjustCurPtrOfEnumerators(
    DWORD dwPosNewOrDeletedACE,
    BOOL  fACEAdded
    )
{
    PACL_ENUM_ENTRY pACLEnum = _pACLEnums;
    CAccCtrlListEnum * pEnum = NULL;
    BOOL fOk = FALSE;


    if (fACEAdded) {

        while (pACLEnum) {

            pEnum = pACLEnum->pACLEnum;
            ADsAssert(pEnum);

            //
            // NOTE: - Problem may occur in multithreaded model (manipulation
            //       on the enumerator & the actual ACL in two threads).
            //       - ADSI CLIENTS should use critical section protection, as
            //       with property cache.
            //

            if (dwPosNewOrDeletedACE <= pEnum->GetCurElement()) {
                //
                // the new ACE is added in front of the last ACE enumerated
                // so, increment the position of the last enumerated element
                // by one

                fOk = pEnum->IncrementCurElement();

                ADsAssert(fOk);     // should be within bound after increment;
                                    // otherwise, coding error
            }

            // else {

                //
                // the new ACE is added after the last ACE enumerated, so
                // no effect on the position of the last enumerated element
                //
            // }

            pACLEnum=pACLEnum->pNext;
        }

    } else {    // ACE deleted

        while (pACLEnum) {

            pEnum = pACLEnum->pACLEnum;
            ADsAssert(pEnum);

            //
            // NOTE: - Problem may occur in multithreaded model (manipulation
            //       on the enumerator & the actual ACL in two threads).
            //       - ADSI CLIENTS should use critical section protection,
            //       as with property cache.
            //

            if ( dwPosNewOrDeletedACE <= pEnum->GetCurElement() )  {

                //
                // the ACE deleted is in front of, or is, the last ACE
                // enumerated, so decrement the position of the last
                // enumerated element by one

                fOk = pEnum->DecrementCurElement();

                ADsAssert(fOk);     // should be within bound after decrement;
                                    // otherwise, coding error
            }

            // else {

                //
                // the new ACE deleted is after the last ACE enumerated, so
                // no effect on the position of the last enumerated element
                //
            // }

            pACLEnum=pACLEnum->pNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cdbprop.cxx ===
#include "oleds.hxx"

#if (!defined(BUILD_FOR_NT40))

// ---------------- C D B P R O P E R T I E S   C O D E  ----------------------


//-----------------------------------------------------------------------------
// CDBProperties::CDBProperties
//
// @mfunc
// CDBProperties constructor.
//
// @rdesc NONE
//-----------------------------------------------------------------------------

CDBProperties::CDBProperties():
        _cPropSets(0),
        _aPropSets(0),
        _cPropInfoSets(0),
        _aPropInfoSets(0)
{
}

//-----------------------------------------------------------------------------
// CDBProperties::~CDBProperties
//
// @mfunc
// CDBProperties destructor. Release storage used by CDBProperties.
//
// @rdesc NONE
//-----------------------------------------------------------------------------

CDBProperties::~CDBProperties()
{
        ULONG iSet, iProp, iSetInfo;

        for (iSet=0; iSet<_cPropSets; ++iSet)
        {
                for (iProp=0; iProp <_aPropSets[iSet].cProperties; ++iProp)
                        VariantClear(&(_aPropSets[iSet].rgProperties[iProp].vValue));
                delete [] _aPropSets[iSet].rgProperties;
        }
        delete [] _aPropSets;

        for (iSet=0; iSet<_cPropInfoSets; ++iSet)
        {
                delete [] _aPropInfoSets[iSet].rgPropertyInfos;
        }
        delete [] _aPropInfoSets;
}


//-----------------------------------------------------------------------------
// CDBProperties::GetPropertySet
//
// @mfunc Looks up a property set by its GUID.
//
// @rdesc Pointer to desired property set, or 0 if not found.
//-----------------------------------------------------------------------------

DBPROPSET*
CDBProperties::GetPropertySet(const GUID& guid) const
{
        DBPROPSET* pPropSet = 0;                // the answer, assume not found

        // linear search
        ULONG iPropSet;
        for (iPropSet=0; iPropSet<_cPropSets; ++iPropSet)
        {
                if (IsEqualGUID(guid, _aPropSets[iPropSet].guidPropertySet))
                {
                        pPropSet = &_aPropSets[iPropSet];
                        break;
                }
        }

        return ( pPropSet );
}


//-----------------------------------------------------------------------------
// CDBProperties::GetPropertyInfoSet
//
// @mfunc Looks up a property info set by its GUID.
//
// @rdesc Pointer to desired property info set, or 0 if not found.
//-----------------------------------------------------------------------------

DBPROPINFOSET*
CDBProperties::GetPropertyInfoSet(const GUID& guid) const
{
        DBPROPINFOSET* pPropInfoSet = 0;                // the answer, assume not found

        // linear search
        ULONG iPropSet;
        for (iPropSet=0; iPropSet<_cPropInfoSets; ++iPropSet)
        {
                if (IsEqualGUID(guid, _aPropInfoSets[iPropSet].guidPropertySet))
                {
                        pPropInfoSet = &_aPropInfoSets[iPropSet];
                        break;
                }
        }

        return ( pPropInfoSet );
}


//-----------------------------------------------------------------------------
// CDBProperties::CopyPropertySet
//
// @mfunc Makes a copy of a property set, given its GUID.
//
// @rdesc
//              @flag S_OK                      | copying succeeded,
//              @flag E_FAIL        | no property set for given GUID,
//              @flag E_OUTOFMEMORY | copying failed because of memory allocation.
//-----------------------------------------------------------------------------

HRESULT
CDBProperties::CopyPropertySet(const GUID& guid, DBPROPSET* pPropSetDst) const
{
    ADsAssert(pPropSetDst && "must supply a PropSet pointer");

    HRESULT hr = S_OK;
        const DBPROPSET* pPropSetSrc = GetPropertySet(guid);
        ULONG iProp;

    if (pPropSetSrc == 0)       // not found
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // start with shallow copy
    *pPropSetDst = *pPropSetSrc;

    // allocate property array
    pPropSetDst->rgProperties = (DBPROP*)
                    CoTaskMemAlloc(pPropSetSrc->cProperties * sizeof(DBPROP));
    if (pPropSetDst->rgProperties == 0)
    {
        pPropSetDst->cProperties = 0;       // defensive
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

        memcpy( pPropSetDst->rgProperties,
                        pPropSetSrc->rgProperties,
                        pPropSetSrc->cProperties*sizeof(DBPROP));

    // copy the property array
    for (iProp=0; iProp<pPropSetSrc->cProperties; ++iProp)
    {
                VariantInit(&(pPropSetDst->rgProperties[iProp].vValue));
                if(FAILED(hr = VariantCopy(&(pPropSetDst->rgProperties[iProp].vValue),
                                        (VARIANT *)&(pPropSetSrc->rgProperties[iProp].vValue))))
                {
                        while(iProp)
                        {
                                iProp--;
                                VariantClear(&(pPropSetDst->rgProperties[iProp].vValue));
                        }
                        CoTaskMemFree(pPropSetDst->rgProperties);
                        pPropSetDst->rgProperties = NULL;
                        pPropSetDst->cProperties = 0;       // defensive
                        goto Cleanup;
                }
    }

Cleanup:
        RRETURN ( hr );
}


//-----------------------------------------------------------------------------
// CDBProperties::CopyPropertyInfoSet
//
// @mfunc Makes a copy of a property info set, given its GUID.
//
// @rdesc
//              @flag S_OK                      | copying succeeded,
//              @flag E_FAIL        | no property set for given GUID,
//              @flag E_OUTOFMEMORY | copying failed because of memory allocation.
//-----------------------------------------------------------------------------

HRESULT
CDBProperties::CopyPropertyInfoSet
        (
        const GUID&             guid,
        DBPROPINFOSET*  pPropInfoSetDst,
        WCHAR**                 ppDescBuffer,
        ULONG_PTR*                  pcchDescBuffer,
        ULONG_PTR*                  pichCurrent
        ) const
{
    ADsAssert(pPropInfoSetDst && "must supply a PropSet pointer");

    HRESULT hr = S_OK;
        const DBPROPINFOSET* pPropInfoSetSrc = GetPropertyInfoSet(guid);

    if (pPropInfoSetSrc == 0)       // not found
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // start with shallow copy
    *pPropInfoSetDst = *pPropInfoSetSrc;

    // allocate property array
    pPropInfoSetDst->rgPropertyInfos = (DBPROPINFO *) CoTaskMemAlloc(
                                                pPropInfoSetSrc->cPropertyInfos * sizeof(DBPROPINFO));

    if (pPropInfoSetDst->rgPropertyInfos == 0)
    {
        pPropInfoSetDst->cPropertyInfos = 0;       // defensive
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

        memcpy( pPropInfoSetDst->rgPropertyInfos,
                        pPropInfoSetSrc->rgPropertyInfos,
                        pPropInfoSetSrc->cPropertyInfos*sizeof(DBPROPINFO));

        if(FAILED(hr =CopyPropertyDescriptions(
                                                pPropInfoSetDst,
                                                ppDescBuffer,
                                                pcchDescBuffer,
                                                pichCurrent)))
        {
                CoTaskMemFree(pPropInfoSetDst->rgPropertyInfos);
                pPropInfoSetDst->rgPropertyInfos = NULL;
                pPropInfoSetDst->cPropertyInfos = 0;       // defensive
                hr = E_OUTOFMEMORY;
        }

Cleanup:
        RRETURN ( hr );
}


//-----------------------------------------------------------------------------
// CDBProperties::GetProperty
//
// @mfunc Looks up a property by its property set GUID and ID.
//
// @rdesc Pointer to DBPROP for the property, or 0 if not found.
//-----------------------------------------------------------------------------

const DBPROP*
CDBProperties::GetProperty(const GUID& guid, DBPROPID dwId) const
{
        ULONG iProp;
        const DBPROPSET* pPropSet = GetPropertySet(guid);
        const DBPROP*   pProp = 0;              // the answer, assume not found

        if (pPropSet == 0)                      // no properties for desired property set
                goto Cleanup;

        // look up the desired property in the property set
        for (iProp=0; iProp<pPropSet->cProperties; ++iProp)
        {
                if (dwId == pPropSet->rgProperties[iProp].dwPropertyID)
                {
                        pProp = & pPropSet->rgProperties[iProp];
                        break;
                }
        }

Cleanup:
        return ( pProp );
}


//-----------------------------------------------------------------------------
// CDBProperties::GetPropertyInfo
//
// @mfunc Looks up a property info by its property set GUID and ID.
//
// @rdesc Pointer to DBPROPINFO for the property info, or 0 if not found.
//-----------------------------------------------------------------------------

const DBPROPINFO UNALIGNED*
CDBProperties::GetPropertyInfo(const GUID& guid, DBPROPID dwId) const
{
        ULONG iPropInfo;
        const DBPROPINFOSET* pPropInfoSet = GetPropertyInfoSet(guid);
        const DBPROPINFO UNALIGNED* pPropInfo = 0;          // the answer, assume not found

        if (pPropInfoSet == 0)                  // no properties for desired property set
                goto Cleanup;

        // look up the desired property in the property set
        for (iPropInfo=0; iPropInfo <pPropInfoSet->cPropertyInfos; ++iPropInfo)
        {
                if (dwId == pPropInfoSet->rgPropertyInfos[iPropInfo].dwPropertyID)
                {
                        pPropInfo = & pPropInfoSet->rgPropertyInfos[iPropInfo];
                        break;
                }
        }

Cleanup:
        return ( pPropInfo );
}

//-----------------------------------------------------------------------------
// CDBProperties::SetProperty
//
// @mfunc Adds a new property, or resets an existing one
//        This overloaded function is same as the other except that the
//        last parameter is of type PWSTR [mgorti]
//
// @rdesc
//              @flag S_OK                      | property added/reset,
//              @flag E_OUTOFMEMORY | no memory for new property set or new property.
//-----------------------------------------------------------------------------

HRESULT
CDBProperties::SetProperty(const GUID& guid,
                                                   const DBPROP& prop,
                                                   BOOL fAddNew,
                                                   PWSTR pwszDesc)
{
        HRESULT hr;
        DBPROP *pProp;                  // pointer to array entry for new property
        ULONG iProp;
        DBPROPSET* pPropSet = GetPropertySet(guid);

        if (pPropSet == 0)              // no properties yet in desired property set
        {
                if(!fAddNew)
                {
                        hr = E_FAIL;
                        goto Cleanup;
                }

                // get a new property set array
                DBPROPSET * aNewPropSets = new DBPROPSET[_cPropSets + 1];
                if (aNewPropSets == 0)
                {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                }
                memcpy(aNewPropSets, _aPropSets, _cPropSets *sizeof(DBPROPSET));

                // add the new property set
                pPropSet = & aNewPropSets[_cPropSets];
                pPropSet->guidPropertySet = guid;
                pPropSet->cProperties = 0;
                pPropSet->rgProperties = 0;

                // release the old array, install the new one
                delete [] _aPropSets;
                _aPropSets = aNewPropSets;
                ++ _cPropSets;
        }

        // look for the desired property.
        if(!fAddNew)
        {
                pProp = 0;
                for (iProp=0; iProp<pPropSet->cProperties; ++iProp)
                {
                        if (pPropSet->rgProperties[iProp].dwPropertyID ==
                                prop.dwPropertyID)
                        {
                                pProp = &pPropSet->rgProperties[iProp];
                                break;
                        }
                }
                if (pProp == 0)
                {
                        hr = E_FAIL;
                        goto Cleanup;
                }
        }

        // if it's a new property, add it.  OLE-DB doesn't provide for any "unused"
        // portion in the array of DBPROPS, so we must reallocate the array every
        // time we add a property.
        else
        {
                ULONG cPropLeftOver;

                // allocate new property array
                cPropLeftOver =
                        C_PROP_INCR -
                                (pPropSet->cProperties + C_PROP_INCR - 1)%C_PROP_INCR - 1;
                if(cPropLeftOver)
                {
                        pProp = &pPropSet->rgProperties[pPropSet->cProperties];
                }
                else
                {
                        DBPROP* aNewProperties =
                                new DBPROP[pPropSet->cProperties + C_PROP_INCR];
                        if (aNewProperties == 0)
                        {
                                hr = E_OUTOFMEMORY;
                                goto Cleanup;
                        }

                        // copy old array into new
                        memcpy( aNewProperties,
                                        pPropSet->rgProperties,
                                        pPropSet->cProperties *sizeof(DBPROP));

                        // prepare to use new property entry
                        pProp = & aNewProperties[pPropSet->cProperties];

                        // release old array, install new
                        delete [] pPropSet->rgProperties;
                        pPropSet->rgProperties = aNewProperties;
                }
                ++ pPropSet->cProperties;
        }

        // copy the property into my array
        if(!fAddNew)
        {
                DBPROP propSave;

                propSave = *pProp;
                *pProp = prop;
                VariantInit(&(pProp->vValue));
                if(FAILED(hr = VariantCopy(     &(pProp->vValue),
                                                                        (VARIANT *)&(prop.vValue))))
                {
                        *pProp = propSave;
                        goto Cleanup;
                }
        }
        else
        {
                DBPROPINFO propinfo;

                *pProp = prop;
                propinfo.pwszDescription = pwszDesc;
                propinfo.dwPropertyID = prop.dwPropertyID;
                propinfo.dwFlags = DBPROPFLAGS_READ;
                if(guid == DBPROPSET_DBINIT)
                        propinfo.dwFlags |= DBPROPFLAGS_DBINIT;
                else if(guid == DBPROPSET_DATASOURCEINFO)
                        propinfo.dwFlags |= DBPROPFLAGS_DATASOURCEINFO;
                else
                        propinfo.dwFlags |= DBPROPFLAGS_ROWSET;
                propinfo.vtType = V_VT(&(prop.vValue));
                VariantInit(&(propinfo.vValues));
                if(FAILED(hr = SetPropertyInfo(guid, propinfo)))
                        goto Cleanup;
        }

        hr = S_OK;

Cleanup:
        RRETURN ( hr );
}

//-----------------------------------------------------------------------------
// CDBProperties::SetPropertyInfo
//
// @mfunc Adds a new property info, or resets an existing one.
//
// @rdesc
//              @flag S_OK                      | property info added/reset,
//              @flag E_OUTOFMEMORY | no memory for new property info set
//                                                        or new property info.
//-----------------------------------------------------------------------------

HRESULT
CDBProperties::SetPropertyInfo(const GUID& guid, const DBPROPINFO& propinfo)
{
        HRESULT hr;
        PDBPROPINFO pPropInfo;          // pointer to array entry for new property
        ULONG iPropInfo;
        DBPROPINFOSET* pPropInfoSet = GetPropertyInfoSet(guid);

        if (pPropInfoSet == 0)          // no properties yet in desired property set
        {

                // get a new property set array
                DBPROPINFOSET * aNewPropInfoSets =
                        new DBPROPINFOSET[_cPropInfoSets + 1];

                if (aNewPropInfoSets == 0)
                {
                        hr = E_OUTOFMEMORY;
                        goto Cleanup;
                }

                memcpy( aNewPropInfoSets,
                                _aPropInfoSets,
                                _cPropInfoSets *sizeof(DBPROPINFOSET));

                // add the new property set
                pPropInfoSet = & aNewPropInfoSets[_cPropInfoSets];
                pPropInfoSet->guidPropertySet = guid;
                pPropInfoSet->cPropertyInfos = 0;
                pPropInfoSet->rgPropertyInfos = 0;

                // release the old array, install the new one
                delete [] _aPropInfoSets;
                _aPropInfoSets = aNewPropInfoSets;
                ++ _cPropInfoSets;
        }

        // look for the desired property.
        pPropInfo = 0;
        for (iPropInfo=0; iPropInfo<pPropInfoSet->cPropertyInfos; ++iPropInfo)
        {
                if (pPropInfoSet->rgPropertyInfos[iPropInfo].dwPropertyID ==
                        propinfo.dwPropertyID)
                {
                        pPropInfo = &pPropInfoSet->rgPropertyInfos[iPropInfo];
                        break;
                }
        }

        // if it's a new property, add it.  OLE-DB doesn't provide for any "unused"
        // portion in the array of DBPROPS, so we must reallocate the array every
        // time we add a property.
        if (pPropInfo == 0)
        {
                ULONG cPropLeftOver;

                // allocate new property array
                cPropLeftOver =
                        C_PROP_INCR -
                                (pPropInfoSet->cPropertyInfos + C_PROP_INCR - 1)%C_PROP_INCR - 1;

                if(cPropLeftOver)
                {
                        pPropInfo =
                                &pPropInfoSet->rgPropertyInfos[pPropInfoSet->cPropertyInfos];
                }
                else
                {
                        DBPROPINFO* aNewPropertyInfos =
                                new DBPROPINFO[pPropInfoSet->cPropertyInfos + C_PROP_INCR];

                        if (aNewPropertyInfos == 0)
                        {
                                hr = E_OUTOFMEMORY;
                                goto Cleanup;
                        }

                        // copy old array into new
                        memcpy( aNewPropertyInfos,
                                        pPropInfoSet->rgPropertyInfos,
                                        pPropInfoSet->cPropertyInfos *sizeof(DBPROPINFO));

                        // prepare to use new property entry
                        pPropInfo = & aNewPropertyInfos[pPropInfoSet->cPropertyInfos];

                        // release old array, install new
                        delete [] pPropInfoSet->rgPropertyInfos;
                        pPropInfoSet->rgPropertyInfos = aNewPropertyInfos;
                }
                ++ pPropInfoSet->cPropertyInfos;
        }

        // copy the property into my array
        *pPropInfo = propinfo;

        hr = S_OK;

Cleanup:
        RRETURN ( hr );
}


//-----------------------------------------------------------------------------
// CDBProperties::LoadDescription
//
// @mfunc Loads a localized string from the localization DLL.
//
// @rdesc Count of characters returned in the buffer.
//-----------------------------------------------------------------------------

int
CDBProperties::LoadDescription
        (
        ULONG   ids,            //@parm IN | String ID
        PWSTR   pwszBuff,       //@parm OUT | Temporary buffer
        ULONG   cchBuff         //@parm IN | Count of characters buffer can hold
        ) const
{
        return ( 0 );
//              return( LoadStringW(g_hinstDll, ids, pwszBuff, cchBuff) );
}


//-----------------------------------------------------------------------------
// CDBProperties::CopyPropertyDescriptions
//
// @mfunc Copies into a buffer descriptions of properties in a given set.
//
// @rdesc
//              @flag S_OK                      | copying of property descriptions succeeded,
//              @flag E_OUTOFMEMORY | buffer for property descriptions could not
//                                                        be allocated/extended.
//-----------------------------------------------------------------------------

HRESULT
CDBProperties::CopyPropertyDescriptions
        (
        DBPROPINFOSET*  pPropInfoSet,
        WCHAR**                 ppDescBuffer,
        ULONG_PTR*                  pcchDescBuffer,
        ULONG_PTR*                  pichCurrent
        ) const
{
        LONG iprop, cchLeft, cchNew;
        int cchCopied;
        WCHAR *pwszTmp;

        if(ppDescBuffer)
        {
                cchLeft = (LONG)*pcchDescBuffer - (LONG)*pichCurrent;
                for(iprop =0; (ULONG)iprop <pPropInfoSet->cPropertyInfos; iprop++)
                {
                        if(pPropInfoSet->rgPropertyInfos[iprop].dwFlags ==
                                DBPROPFLAGS_NOTSUPPORTED)
                                continue;

                        if(cchLeft < (LONG)CCHAR_MAX_PROP_STR_LENGTH)
                        {
                                cchNew = CCHAR_AVERAGE_PROP_STR_LENGTH *
                                                        (pPropInfoSet->cPropertyInfos - iprop - 1) +
                                                                CCHAR_MAX_PROP_STR_LENGTH +
                                                                        *pcchDescBuffer - cchLeft;

                                pwszTmp = (WCHAR *)CoTaskMemAlloc(cchNew *sizeof(WCHAR));
                                if(pwszTmp == NULL)
                                        RRETURN ( E_OUTOFMEMORY );

                                if(*ppDescBuffer)
                                {
                                        memcpy( pwszTmp,
                                                        *ppDescBuffer,
                                                        (*pcchDescBuffer -cchLeft)*sizeof(WCHAR));

                                        CoTaskMemFree(*ppDescBuffer);
                                }
                                cchLeft += cchNew -(LONG)*pcchDescBuffer;
                                *ppDescBuffer = pwszTmp;
                                *pcchDescBuffer = cchNew;
                        }

                        //?? Do we need to load these strings from resources ??
                        //$TODO$ Raid #86943 Copy property descriptions from source to destination buffer.
                        cchCopied = wcslen(pPropInfoSet->rgPropertyInfos[iprop].pwszDescription);
                        wcscpy((WCHAR *)(*ppDescBuffer) + *pichCurrent,
                          pPropInfoSet->rgPropertyInfos[iprop].pwszDescription);
                        pPropInfoSet->rgPropertyInfos[iprop].pwszDescription =
                                (WCHAR *)(*pichCurrent);

                        *pichCurrent += (cchCopied +1);
                        cchLeft -= (cchCopied +1);
                }
        }
        else {
                //      We need to NULL out the pwszDescription values:
                //

                for(iprop =0; (ULONG)iprop <pPropInfoSet->cPropertyInfos; iprop++)
                {
                        pPropInfoSet->rgPropertyInfos[iprop].pwszDescription = NULL;
                }
        }

        RRETURN ( NOERROR );
}

//-----------------------------------------------------------------------------
// CDBProperties::CheckAndInitPropArgs
//
// @mfunc Helper function used while getting property sets.
//        Used to check and get information about property sets.
//        Tells if the caller is requesting
//        special sets or the set of properties in error.
//
// @rdesc
//              @flag S_OK                      | check succeeded,
//              @flag E_INVALIDARG  | one of the arguments is invalid.
//-----------------------------------------------------------------------------
HRESULT
CDBProperties::CheckAndInitPropArgs
        (
        ULONG                           cPropertySets,    // IN | Number of property sets
        const DBPROPIDSET       rgPropertySets[], // IN | Property Sets
        ULONG                           *pcPropertySets,  // OUT | Count of structs returned
        void                            **prgPropertySets,// OUT | Array of Properties
        BOOL                            *pfPropInError,
        BOOL                            *pfPropSpecial
        )
{
        LONG    ipropset;
        ULONG   cpropsetSpecial;

        // Initialize
        if( pcPropertySets )
                *pcPropertySets = 0;
        if( prgPropertySets )
                *prgPropertySets = NULL;
        if(pfPropInError)
                *pfPropInError = FALSE;
        if(pfPropSpecial)
                *pfPropSpecial = FALSE;

        // Check Arguments, on failure post HRESULT to error queue
        if( ((cPropertySets > 0) && !rgPropertySets) ||
                !pcPropertySets ||
                !prgPropertySets )
                RRETURN ( E_INVALIDARG );

        // New argument check for > 1 cPropertyIDs and NULL pointer for
        // array of property ids.
        for(ipropset=0, cpropsetSpecial = 0;
            (ULONG)ipropset<cPropertySets;
                ipropset++)
        {
                if( rgPropertySets[ipropset].cPropertyIDs &&
                        !(rgPropertySets[ipropset].rgPropertyIDs) )
                        RRETURN (E_INVALIDARG);

                //when passing property set DBPROPSET_PROPERTIESINERROR,
                //this is the only set the caller can ask. Also, the
                //count of propertyIDs and the propertyID array must be
                //NULL in this case.
                if( rgPropertySets[ipropset].guidPropertySet ==
                        DBPROPSET_PROPERTIESINERROR )
                {
                        if(pfPropInError)
                        {
                                if(cPropertySets >1
                                   || rgPropertySets[ipropset].cPropertyIDs
                                   || rgPropertySets[ipropset].rgPropertyIDs)
                                        RRETURN (E_INVALIDARG);
                                else
                                        *pfPropInError = TRUE;
                        }
                }
                //Count the number of special property sets being asked.
                else if( rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_DATASOURCEALL
                          || rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_DATASOURCEINFOALL
                          || rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_DBINITALL
                          || rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_SESSIONALL
                          || rgPropertySets[ipropset].guidPropertySet ==
                                    DBPROPSET_ROWSETALL)
                        cpropsetSpecial++;
        }

        //When requesting special property sets, all of them
        //must be special or none.
        if(cpropsetSpecial)
        {
                if(pfPropSpecial)
                        *pfPropSpecial = TRUE;
                if(cpropsetSpecial < cPropertySets)
                        RRETURN (E_INVALIDARG);
        }
        else if(pfPropSpecial)
                *pfPropSpecial = FALSE;

        RRETURN ( NOERROR );
}

//-----------------------------------------------------------------------------
// CDBProperties::VerifySetPropertiesArgs
//
// @mfunc Helper function used in IDBProperties::SetProperties. Validates
//        arguments passed to IDBProperties::SetProperties.
//
// @rdesc
//              @flag S_OK                      | Validation succeeded.
//              @flag E_INVALIDARG  | Validation failed - one of the arguments
//                                                        is in error.
//-----------------------------------------------------------------------------
HRESULT
CDBProperties::VerifySetPropertiesArgs
        (
        ULONG           cPropertySets,          //@parm IN | Count of properties
        DBPROPSET       rgPropertySets[]        //@parm IN | Properties
        )
{
        ULONG ipropset;

        if(cPropertySets && rgPropertySets == NULL)
                RRETURN (E_INVALIDARG);

        for(ipropset =0; ipropset <cPropertySets; ipropset++)
                if(     rgPropertySets[ipropset].cProperties &&
                        rgPropertySets[ipropset].rgProperties == NULL)
                        RRETURN (E_INVALIDARG);

        RRETURN ( NOERROR );
}


//-----------------------------------------------------------------------------
// VariantsEqual
//
// @mfunc Tests two variants holding property values for equality.
//
// @rdesc
//              @flag TRUE      | values equal,
//              @flag FALSE | values unequal.
//-----------------------------------------------------------------------------
BOOL VariantsEqual
        (
        VARIANT *pvar1,
        VARIANT *pvar2
        )
{
        if(V_VT(pvar1) != V_VT(pvar1))
                return ( FALSE );
        else if(V_VT(pvar1) == VT_I2)
                return (V_I2(pvar1) == V_I2(pvar2));
        else if(V_VT(pvar1) == VT_BOOL)
                return (V_BOOL(pvar1) == V_BOOL(pvar2));
        else if(V_VT(pvar1) == VT_BSTR)
        {
                if(V_BSTR(pvar1) == NULL || V_BSTR(pvar2) == NULL)
                        return (V_BSTR(pvar1) == V_BSTR(pvar2));
                else
                        return (wcscmp(V_BSTR(pvar1), V_BSTR(pvar2)) == 0);
        }
        else
                return (V_I4(pvar1) == V_I4(pvar2));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cdnstr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:  CDNWithString.cxx
//
//  Contents:  DNWithString object
//
//  History:   4-23-99     AjayR    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CDNWithString

DEFINE_IDispatch_Implementation(CDNWithString)

CDNWithString::CDNWithString():
        _pszStrVal(NULL),
        _pszDNStr(NULL)
{
    ENLIST_TRACKING(CDNWithString);
}


HRESULT
CDNWithString::CreateDNWithString(
    REFIID riid,
    void **ppvObj
    )
{
    CDNWithString FAR * pDNWithString = NULL;
    HRESULT hr = S_OK;

    hr = AllocateDNWithStringObject(&pDNWithString);
    BAIL_ON_FAILURE(hr);

    hr = pDNWithString->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pDNWithString->Release();

    RRETURN(hr);

error:
    delete pDNWithString;

    RRETURN_EXP_IF_ERR(hr);

}


CDNWithString::~CDNWithString( )
{
    delete _pDispMgr;

    if (_pszStrVal) {
        FreeADsStr(_pszStrVal);
    }

    if (_pszDNStr) {
        FreeADsStr(_pszDNStr);
    }
}

STDMETHODIMP
CDNWithString::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsDNWithString FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsDNWithString))
    {
        *ppv = (IADsDNWithString FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsDNWithString FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CDNWithString::AllocateDNWithStringObject(
    CDNWithString ** ppDNWithString
    )
{
    CDNWithString FAR * pDNWithString = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pDNWithString = new CDNWithString();
    if (pDNWithString == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsDNWithString,
                (IADsDNWithString *)pDNWithString,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pDNWithString->_pDispMgr = pDispMgr;
    *ppDNWithString = pDNWithString;

    RRETURN(hr);

error:

    delete pDNWithString;
    delete pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CDNWithString::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsDNWithString)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

//
// Methods to get and put the string part.
//

STDMETHODIMP
CDNWithString::get_StringValue(THIS_ BSTR FAR* pbstrValue)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = ValidateOutParameter(pbstrValue))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_pszStrVal, pbstrValue);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CDNWithString::put_StringValue(THIS_ BSTR bstrValue)
{

    HRESULT hr = S_OK;

    if (_pszStrVal) {
        FreeADsStr(_pszStrVal);
        _pszStrVal = NULL;
    }

    _pszStrVal = AllocADsStr(bstrValue);
    if (bstrValue && !_pszStrVal) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}


//
// Methods to get and put the DN string.
//
STDMETHODIMP
CDNWithString::get_DNString(THIS_ BSTR FAR* pbstrDNString)
{
    HRESULT hr = S_OK;

    if (FAILED(hr = ValidateOutParameter(pbstrDNString))){
        RRETURN_EXP_IF_ERR(hr);
    }

    hr = ADsAllocString(_pszDNStr, pbstrDNString);

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CDNWithString::put_DNString(THIS_ BSTR bstrDNString)
{

    HRESULT hr = S_OK;

    if (_pszDNStr) {
        FreeADsStr(_pszDNStr);
        _pszDNStr = NULL;
    }

    _pszDNStr = AllocADsStr(bstrDNString);

    if (bstrDNString && !_pszDNStr) {
        hr = E_OUTOFMEMORY;
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cadssec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       cadssec.cxx
//
//  Contents: This file contains the support ADsSecurityUtility class
//          implementation and the support routines it requires. The
//          default interface for the ADsSecurityClassUtility class
//          is IADsSecurityUtility. 
//
//  History:    10-11-00    AjayR  Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"

//
// Helper functions.
//

//+---------------------------------------------------------------------------
// Function:   GetServerAndResource - Helper routine.
//
// Synopsis:   Splits the string into a serverName piece and rest piece.
//          This is used for fileshare paths like \\Computer\share to return
//          \\computer and share. In the case of registry a string like
//          \\Computer\HKLM\Microsoft will be split into \\Computer and
//          HKLM\Microsoft. if there is no computer name specified, then
//          the serverName will be NULL.
//
// Arguments:  pszName           -   Name to be split.
//             ppszServer        -   Return value for server name.
//             ppszResource      -   Return value for rest of string.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSD and pdwLength on success.
//
//----------------------------------------------------------------------------
HRESULT
GetServerAndResource(
    LPWSTR pszName,
    LPWSTR *ppszServer,
    LPWSTR *ppszResource
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = wcslen(pszName);
    LPWSTR pszTemp = pszName;
    LPWSTR pszServer = NULL;
    LPWSTR pszResource = NULL;
    DWORD dwLen = 0;
    BOOL fNoServer = FALSE;

    *ppszServer = NULL;
    *ppszResource = NULL;

    //
    // If we have just 1 \ or no \'s there is no server name.
    //
    if ((dwLength < 2)
        || (pszName[0] != L'\\') 
        || (pszName[1] != L'\\')
        ) {
        fNoServer = TRUE;
    }
    
    if (fNoServer) {
        //
        // Name is the entire string passed in.
        //
        pszResource = AllocADsStr(pszName);
        if (!pszResource) {
            BAIL_ON_FAILURE(hr = E_FAIL);
        }

        *ppszResource = pszResource;
        RRETURN(hr);
    }

    //
    // Make sure that the first 2 chars are \\
    //
    if (pszTemp[0] != L'\\'
        || pszTemp[1] != L'\\' )
         {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
   
    pszTemp += 2;

    while (pszTemp && *pszTemp != L'\\') {
        dwLen++;
        pszTemp++;
    }

    if (!pszTemp 
        || !*pszTemp
        || !dwLen
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    dwLen += 2; // the 2 \\ in the serverName
    
    //
    // Advance past the \ in \\testShare\FileShare.
    //
    pszTemp++;
    if (!pszTemp || !*pszTemp) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG)
    }

    //
    // If we get here we have valid server and share names.
    //
    pszServer = (LPWSTR) AllocADsMem((dwLen+1) * sizeof(WCHAR));
    if (!pszServer) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    wcsncpy(pszServer, pszName, dwLen);

    pszResource = AllocADsStr(pszTemp);
    if (!pszResource) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    *ppszServer = pszServer;
    *ppszResource = pszResource;

error:

    if (FAILED(hr)) {
        if (pszResource) {
            FreeADsMem(pszResource);
        }

        if (pszServer) {
            FreeADsMem(pszServer);
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetKeyRootAndSubKey - Helper routine.
//
// Synopsis:   Gets the root (such as HKLM) from the registry key path. This
//          is needed when we open a handle to the key. The rest of the path
//          constitutes the SubKey name.
//
// Arguments:  pszKeyName        -   Name of the key we need to open.
//             ppszSubKey        -   Return value for the subKey
//             phKey             -   Return value for key root to open.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   phKey, NULL on failure and one of 
//                  HKEY_USERS, HKEY_CURRENT_USER, HKEY_CURRENT_CONFIG,
//                  HKEY_LOCAL_MACHINE, HKEY_CLASSES_ROOT
//                  or HKEY_PERFORMANCE_DATA on success.
//
//----------------------------------------------------------------------------
HRESULT 
GetKeyRootAndSubKey(
    LPWSTR pszKeyName,
    LPWSTR * ppszSubKey,
    HKEY * phKey
    )
{
    HRESULT hr = S_OK;
    HKEY hKey = NULL;
    LPWSTR pszRoot = NULL;
    LPWSTR pszTemp = pszKeyName;
    LPWSTR pszSubKey = NULL;
    DWORD dwLen = 0;

    *phKey = NULL;
    *ppszSubKey = NULL;

    while (pszTemp 
           && *pszTemp 
           && *pszTemp != L'\\') {
        dwLen++;
        pszTemp++;
    }

    //
    // If the length is less than 3 something is wrong.
    //
    if ((dwLen < 3)
        || !pszTemp
        || !*pszTemp
        ) {
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
    }

    //
    // To get the subkey, we need to move past the \.
    //
    pszTemp++;
    if (pszTemp && *pszTemp) {
        pszSubKey = AllocADsStr(pszTemp);
        if (!pszSubKey) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    pszRoot = (LPWSTR) AllocADsMem((dwLen+1) * sizeof(WCHAR));
    if (!pszRoot) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Copy over the root so we can use it in the subsequent comparisions.
    //
    wcsncpy(pszRoot, pszKeyName, dwLen);

    if (_wcsicmp( pszRoot, L"HKEY_CLASSES_ROOT") == 0
         || _wcsicmp( pszRoot, L"HKCR") == 0
        ) {
        hKey = HKEY_CLASSES_ROOT;
    }
    else if (_wcsicmp( pszRoot, L"HKEY_LOCAL_MACHINE") == 0
             || _wcsicmp( pszRoot, L"HKLM") == 0
             ) {
        hKey = HKEY_LOCAL_MACHINE;
    }
    else if (_wcsicmp(pszRoot, L"HKEY_CURRENT_CONFIG") == 0
             || _wcsicmp(pszRoot, L"HKCC") == 0
             ) {
        hKey = HKEY_CURRENT_CONFIG;
    }
    else if (_wcsicmp(pszRoot, L"HKEY_CURRENT_USER" ) == 0
             || _wcsicmp( pszRoot, L"HKCU") == 0 
             ) {
        hKey = HKEY_CURRENT_USER;
    }
    else if (_wcsicmp(pszRoot, L"HKEY_USERS") == 0
             || _wcsicmp(pszRoot, L"HKU") == 0
             ) {
        hKey = HKEY_USERS;
    }
    else if ( _wcsicmp(pszRoot, L"HKEY_PERFORMANCE_DATA") == 0) {
        hKey = HKEY_PERFORMANCE_DATA;
    } 
    else {
        //
        // Has to be one of the above.
        //
        BAIL_ON_FAILURE(hr = E_FAIL);
    }
        
    *phKey = hKey;
    *ppszSubKey = pszSubKey;

error:

    if (pszRoot) {
        FreeADsStr(pszRoot);
    }

    if (FAILED(hr) && pszSubKey) {
        FreeADsStr(pszSubKey);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertRawSDToBinary - Helper routine.
//
// Synopsis:   Converts the binary SD to a VT_UI1 | VT_ARRAY.
//
// Arguments:  pSecurityDescriptor   -   Binary sd to convert.
//             dwLength              -   Length of SD.
//             pVariant              -   Return value.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pVariant to point to IID_IADsSecurityDescriptor on success.
//
//----------------------------------------------------------------------------
HRESULT
ConvertRawSDToBinary(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwLength,
    VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY * aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    
    aBound.lLbound = 0;
    aBound.cElements = dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );
    if (!aList) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, pSecurityDescriptor, aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(pVariant) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVariant) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertRawSDToHexString - Helper routine.
//
// Synopsis:   Converts the binary SD to a VT_BSTR in hex string format.
//
// Arguments:  pSecurityDescriptor   -   Binary sd to convert.
//             dwLength              -   Length of SD.
//             pVariant              -   Return value for VT_BSTR.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pVariant to point to IID_IADsSecurityDescriptor on success.
//
//----------------------------------------------------------------------------
HRESULT
ConvertRawSDToHexString(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    DWORD dwLength,
    VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszHexStr = NULL;
    BSTR bstrHexSD = NULL;
    WCHAR szSmallStr[10];
    
    pszHexStr = (LPWSTR) AllocADsMem((dwLength+1) * 2 * sizeof(WCHAR));
    if (!pszHexStr) {
        BAIL_ON_FAILURE(hr);
    }

    for (DWORD dwCtr = 0; dwCtr < dwLength; dwCtr++) {
        wsprintf(
            szSmallStr,
            L"%02x",
            ((BYTE*)pSecurityDescriptor)[dwCtr]
            );
        wcscat(pszHexStr, szSmallStr);
    }

    hr = ADsAllocString(pszHexStr, &bstrHexSD);

    if (SUCCEEDED(hr)) {
        pVariant->vt = VT_BSTR;
        pVariant->bstrVal = bstrHexSD;
    }

error:

    if (pszHexStr) {
        FreeADsMem(pszHexStr);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertHexSDToRawSD - Helper routine.
//
// Synopsis:   Converts the hex string SD to a binary SD.
//
// Arguments:  pVarHexSD             -   Variant with hex string.
//             ppSecurityDescriptor  -   Return value for binary SD
//             pdwLength             -   Return value for length of SD.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSecurityDescriptor and pdwLength updated accordingly.
//
//----------------------------------------------------------------------------
HRESULT
ConvertHexSDToRawSD(
    PVARIANT pVarHexSD,
    PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    DWORD *pdwLength
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszHexSD = V_BSTR(pVarHexSD);
    DWORD dwLen;
    LPBYTE lpByte = NULL;

    *ppSecurityDescriptor = NULL;
    *pdwLength = 0;

    if (!pszHexSD
        || ((dwLen = wcslen(pszHexSD)) == 0)
        ) {
        //
        // NULL SD.
        //
        RRETURN(S_OK);
    }

    dwLen = wcslen(pszHexSD);

    //
    // Length has to be even.
    //
    if (((dwLen/2) * 2) != dwLen) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    dwLen /= 2;

    if (dwLen) {
        
        lpByte = (LPBYTE) AllocADsMem(dwLen);
        if (!lpByte) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
        
        //
        // Go through and read one 2 hex chars at a time.
        //
        for (
             DWORD dwCtr = 0;
             (dwCtr < dwLen) && (pszHexSD && *pszHexSD);
             dwCtr++ ) {

            DWORD dwCount, dwHexVal;
            dwCount = swscanf(pszHexSD, L"%02x", &dwHexVal);
            
            //
            // The read has to be successful and the data valid.
            //
            if (dwCount != 1) {
                BAIL_ON_FAILURE(hr = E_FAIL);
            }

            //
            // Make sure that the value is in the correct range.
            //
            if (dwHexVal & (0xFFFFFF00)) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }

            lpByte[dwCtr] = (BYTE) dwHexVal;

            pszHexSD++;
            if (!pszHexSD) {
                BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            pszHexSD++;
        } // for loop

        //
        // The sd translation was succesful.
        //
        *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR)(LPVOID) lpByte;
        *pdwLength = dwLen;
    } // if the string had any data in it.
    
error:

    if (FAILED(hr) && lpByte) {
        FreeADsMem(lpByte);
    }
    
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   ConvertBinarySDToRawSD - Helper routine.
//
// Synopsis:   Converts a VT_UI1 | VT_ARRAY to a binary SD.
//
// Arguments:  pvVarBinSD            -   The input variant array to convert.
//             ppSecurityDescriptor  -   Return value for binary sd.
//             pdwLength             -   Return value for length of binary sd.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSecurityDescriptor and pdwLength modified appropriately.
//
//----------------------------------------------------------------------------
HRESULT
ConvertBinarySDToRawSD(
    PVARIANT pvVarBinSD,
    PSECURITY_DESCRIPTOR *ppSecurityDescriptor,
    DWORD *pdwLength
    )
{
    HRESULT hr = S_OK;
    LPVOID lpMem = NULL;
    long lBoundLower = -1;
    long lBoundUpper = -1;
    CHAR HUGEP *pArray = NULL;

    *ppSecurityDescriptor = NULL;
    *pdwLength = 0;
    
    //
    // Make sure we have an array and then get length.
    //
    if( pvVarBinSD->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(
             V_ARRAY(pvVarBinSD),
             1,
             &lBoundLower
             );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
             V_ARRAY(pvVarBinSD),
             1,
             &lBoundUpper
             );
    BAIL_ON_FAILURE(hr);

    if ((lBoundUpper == -1)
        && (lBoundLower == -1)
        ) {
        //
        // Nothing further to do in this case.
        //
        ;
    } 
    else {
        long lLength;

        lLength = (lBoundUpper - lBoundLower) + 1;
        lpMem = AllocADsMem(lLength);
        if (!lpMem) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }

        hr = SafeArrayAccessData(
                 V_ARRAY(pvVarBinSD),
                 (void HUGEP * FAR *) &pArray
                 );
        BAIL_ON_FAILURE(hr);

        memcpy(lpMem, pArray, lLength);

        SafeArrayUnaccessData(V_ARRAY(pvVarBinSD));

        *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR) lpMem;
        *pdwLength = (DWORD) lLength;
    }

error:

    if (FAILED(hr) && lpMem) {
        FreeADsMem(lpMem);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetRawSDFromFile - Helper routine.
//
// Synopsis:   Gets the security descriptor from the file in binary format.
//
// Arguments:  pszFileName       -   Name of file to get sd from.
//             secInfo           -   Security mask to use for the operation.
//             ppSD              -   Return value for the SD.
//             pdwLength         -   Return value for the lenght of the SD.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSD and pdwLength on success.
//
//----------------------------------------------------------------------------
HRESULT
GetRawSDFromFile(
    LPWSTR pszFileName,
    SECURITY_INFORMATION secInfo,
    PSECURITY_DESCRIPTOR *ppSD,
    PDWORD pdwLength
    )
{
    HRESULT hr = S_OK;
    DWORD dwLength = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;
                                

    *ppSD = NULL;
    *pdwLength = 0;

    //
    // Get the length of the SD.
    //
    if (!GetFileSecurity(
             pszFileName,
             secInfo,
             NULL,
             0,
             &dwLength
             )
        && (dwLength == 0)
        ) {
        //
        // There was an error.
        //
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    if (dwLength == 0) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }
    
    pSD = (PSECURITY_DESCRIPTOR) AllocADsMem(dwLength);
    
    if (!pSD) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (!GetFileSecurity(
             pszFileName,
             secInfo,
             pSD,
             dwLength,
             &dwLength
             )
        ) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    *pdwLength = dwLength;
    *ppSD = pSD;

error:

    if (FAILED(hr) && pSD) {
        FreeADsMem(pSD);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   SetRawSDToFile - Helper routine.
//
// Synopsis:   Sets the binary security descriptor on the file.
//
// Arguments:  pszFileName       -   Name of file to set sd on.
//             secInfo           -   Security mask to use for the operation.
//             pSD               -   Value of SD to set.
//             dwLength          -   Length of the sd.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
SetRawSDToFile(
    LPWSTR pszFileName,
    SECURITY_INFORMATION secInfo,
    PSECURITY_DESCRIPTOR pSD
    )
{
    HRESULT hr = S_OK;
    
    if (!SetFileSecurity(
            pszFileName,
            secInfo,
            pSD
            )
        ) {
        RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    } 
    else {
        RRETURN(S_OK);
    }
}

//+---------------------------------------------------------------------------
// Function:   GetRawSDFromFileShare - Helper routine.
//
// Synopsis:   Gets the security descriptor from the fileshare in bin format.
//
// Arguments:  pszFileShareName  -   Name of fileshare to get sd from.
//             ppSD              -   Return value for the SD.
//             pdwLength         -   Return value for the lenght of the SD.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSD and pdwLength on success.
//
//----------------------------------------------------------------------------
HRESULT
GetRawSDFromFileShare(
    LPWSTR pszFileShareName,
    PSECURITY_DESCRIPTOR *ppSD,
    PDWORD pdwLength
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszServerName = NULL;
    LPWSTR pszShareName = NULL;
    
    DWORD dwLength = 0;
    PSECURITY_DESCRIPTOR pSD = NULL;
    SHARE_INFO_502 * pShareInfo502 = NULL;
    NET_API_STATUS nasStatus = NERR_Success;

    *ppSD = NULL;
    *pdwLength = 0;

    //
    // We need to split the name into serverName and shareName
    //
    hr = GetServerAndResource(
             pszFileShareName,
             &pszServerName,
             &pszShareName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Only 502 level call returns the SD Info.
    //
    nasStatus = NetShareGetInfo(
                    pszServerName,
                    pszShareName,
                    502,
                    (LPBYTE *)&pShareInfo502
                    );    
    if (nasStatus != NERR_Success) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));
    }

    //
    // If the SD is non NULL process the SD.
    //
    if (pShareInfo502->shi502_security_descriptor) {
        //
        // Get the length of the SD, it should not be 0.
        //
        SetLastError(0);
        dwLength = GetSecurityDescriptorLength(
                       pShareInfo502->shi502_security_descriptor
                       );


        //
        // The return length should not be zero.
        //
        if (dwLength == 0) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }
        
        pSD = (PSECURITY_DESCRIPTOR) AllocADsMem(dwLength);
        
        if (!pSD) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    
        memcpy(pSD, pShareInfo502->shi502_security_descriptor, dwLength);
    
        *ppSD = pSD;
        *pdwLength = dwLength;
    }
    else {
        //
        // The SD was NULL the ret values are set correctly
        //
        ;
    }

error:

    if (pszServerName) {
        FreeADsStr(pszServerName);
    }

    if (pszShareName) {
        FreeADsStr(pszShareName);
    }

    if (pShareInfo502) {
        NetApiBufferFree(pShareInfo502);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   SetRawSDToFileShare - Helper routine.
//
// Synopsis:   Sets the binary SD on the fileshare.
//
// Arguments:  pszFileShare      -   Name of fileshare to set sd on.
//             pSD              -   The SD to set.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT 
SetRawSDToFileShare(
    LPWSTR pszFileShare,
    PSECURITY_DESCRIPTOR pSD
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszServerName = NULL;
    LPWSTR pszShareName = NULL;
    SHARE_INFO_502 * pShareInfo502 = NULL;
    NET_API_STATUS nasStatus = NERR_Success;
    PSECURITY_DESCRIPTOR pTempSD = NULL;

    //
    // We need to split the name into serverName and shareName
    //
    hr = GetServerAndResource(
             pszFileShare,
             &pszServerName,
             &pszShareName
             );
    BAIL_ON_FAILURE(hr);

    //
    // Ideally we should use 1501 level but that is only on Win2k. So
    // we need to read the info, update SD and then set it.
    //
    nasStatus = NetShareGetInfo(
                    pszServerName,
                    pszShareName,
                    502,
                    (LPBYTE *) &pShareInfo502
                    );
    if (nasStatus != NERR_Success) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));
    }

    //
    // Store away the SD so we restore before free.
    //
    pTempSD = pShareInfo502->shi502_security_descriptor;

    pShareInfo502->shi502_security_descriptor = pSD;

    nasStatus = NetShareSetInfo(
                    pszServerName,
                    pszShareName,
                    502,
                    (LPBYTE) pShareInfo502,
                    NULL
                    );

    pShareInfo502->shi502_security_descriptor = pTempSD;

    if (nasStatus != NERR_Success) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(nasStatus));
    }

error:

    if (pShareInfo502) {
        NetApiBufferFree(pShareInfo502);
    }

    if (pszServerName) {
        FreeADsStr(pszServerName);
    }
    if (pszShareName) {
        FreeADsStr(pszShareName);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   GetRawSDFromRegistry - Helper routine.
//
// Synopsis:   Gets the security descriptor from the registry in bin format.
//
// Arguments:  pszFileRegKeyName -   Name of fileshare to get sd from.
//             secInfo           -   Security mask to use for the operation.
//             ppSD              -   Return value for the SD.
//             pdwLength         -   Return value for the lenght of the SD.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   ppSD and pdwLength on success.
//
//----------------------------------------------------------------------------
HRESULT
GetRawSDFromRegistry(
    LPWSTR pszFileRegKeyName,
    SECURITY_INFORMATION secInfo,
    PSECURITY_DESCRIPTOR *ppSD,
    PDWORD pdwLength
    )
{
    HRESULT hr;
    LPWSTR pszServerName = NULL;
    LPWSTR pszKeyName = NULL;
    LPWSTR pszSubKey = NULL;
    DWORD dwLength = 0;
    DWORD dwErr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    HKEY hKey = NULL;
    HKEY hKeyRoot = NULL;
    HKEY hKeyMachine = NULL;

    *ppSD = NULL;
    *pdwLength = 0;

    //
    // We need to split the name into serverName and shareName
    //
    hr = GetServerAndResource(
             pszFileRegKeyName,
             &pszServerName,
             &pszKeyName
             );
    BAIL_ON_FAILURE(hr);


    //
    // pszKeyName has to have a valid string. We need to process it
    // to find out which key set we need to open (such as HKLM).
    //
    hr = GetKeyRootAndSubKey(pszKeyName, &pszSubKey, &hKeyRoot);
    BAIL_ON_FAILURE(hr);

    //
    // Need to open the hKeyRoot on the appropriate machine.
    // If the serverName is NULL it will be local machine.
    //
    dwErr = RegConnectRegistry(
                pszServerName,
                hKeyRoot,
                &hKeyMachine
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    //
    // Open the key and try and read the security descriptor
    //
    dwErr = RegOpenKeyEx(
                hKeyMachine,
                pszSubKey,
                0,
                KEY_READ,
                &hKey
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    dwErr = RegGetKeySecurity(
                hKey,
                secInfo,
                pSD,
                &dwLength
                );
    if (dwLength == 0) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    pSD = (PSECURITY_DESCRIPTOR) AllocADsMem(dwLength);
    if (!pSD) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    dwErr = RegGetKeySecurity(
                hKey,
                secInfo,
                pSD,
                &dwLength
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    *ppSD = pSD;
    *pdwLength = dwLength;

error:

    if (pszServerName) {
        FreeADsStr(pszServerName);
    }

    if (pszKeyName) {
        FreeADsStr(pszKeyName);
    }

    if (pszSubKey) {
        FreeADsStr(pszSubKey);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (hKeyMachine) {
        RegCloseKey(hKeyMachine);
    }

    if (FAILED(hr) && pSD) {
        FreeADsMem(pSD);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   SetRawSDToRegistry - Helper routine.
//
// Synopsis:   Sets the security descriptor to the specified key.
//
// Arguments:  pszFileRegKeyName -   Name of fileshare to set sd on.
//             secInfo           -   Security mask to use for the operation.
//             pSD               -   SD to set on the reg key.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
HRESULT
SetRawSDToRegistry(
    LPWSTR pszFileRegKeyName,
    SECURITY_INFORMATION secInfo,
    PSECURITY_DESCRIPTOR pSD
    )
{
    HRESULT hr;
    LPWSTR pszServerName = NULL;
    LPWSTR pszKeyName = NULL;
    LPWSTR pszSubKey = NULL;
    DWORD dwErr;
    HKEY hKey = NULL;
    HKEY hKeyRoot = NULL;
    HKEY hKeyMachine = NULL;

    //
    // We need to split the name into serverName and shareName
    //
    hr = GetServerAndResource(
             pszFileRegKeyName,
             &pszServerName,
             &pszKeyName
             );
    BAIL_ON_FAILURE(hr);
    
    //
    // pszKeyName has to have a valid string. We need to process it
    // to find out which key set we need to open (such as HKLM).
    //
    hr = GetKeyRootAndSubKey(pszKeyName, &pszSubKey, &hKeyRoot);
    BAIL_ON_FAILURE(hr);

    //
    // Need to open the hKeyRoot on the appropriate machine.
    // If the serverName is NULL it will be local machine.
    //
    dwErr = RegConnectRegistry(
                pszServerName,
                hKeyRoot,
                &hKeyMachine
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }
    
    //
    // Open the key and try and read the security descriptor
    //
    dwErr = RegOpenKeyEx(
                hKeyMachine,
                pszSubKey,
                0,
                KEY_WRITE,
                &hKey
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

    dwErr = RegSetKeySecurity(
                hKey,
                secInfo,
                pSD
                );
    if (dwErr) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwErr));
    }

error:

    if (pszServerName) {
        FreeADsStr(pszServerName);
    }

    if (pszKeyName) {
        FreeADsStr(pszKeyName);
    }

    if (pszSubKey) {
        FreeADsStr(pszSubKey);
    }

    if (hKey) {
        RegCloseKey(hKey);
    }

    if (hKeyMachine) {
        RegCloseKey(hKeyMachine);
    }

    RRETURN(hr);
}

/****************************************************************************/
//
// CADsSecurityUtility Class.
//
/****************************************************************************/

DEFINE_IDispatch_Implementation(CADsSecurityUtility)

//+---------------------------------------------------------------------------
// Function:   CSecurity::CSecurityDescriptor - Constructor.
//
// Synopsis:   Standard constructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CADsSecurityUtility::CADsSecurityUtility():
    _secInfo( DACL_SECURITY_INFORMATION
             | GROUP_SECURITY_INFORMATION
             | OWNER_SECURITY_INFORMATION
            ),
    _pDispMgr(NULL)
{
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::~CADsSecurityUtility - Destructor.
//
// Synopsis:   Standard destructor.
//
// Arguments:  N/A.
//
// Returns:    N/A.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
CADsSecurityUtility::~CADsSecurityUtility()
{
    //
    // Only the dispmgr needs to be cleaned up.
    //
    delete _pDispMgr;
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::AllocateADsSecurityUtilityObject -
//             Static helper method.
//
// Synopsis:   Standard static allocation routine.
//
// Arguments:  ppADsSecurityUtil    -   Return ptr.
//
// Returns:    S_OK on success or appropriate error code on failure.
//
// Modifies:   *ppADsSecurity.
//
//----------------------------------------------------------------------------
HRESULT
CADsSecurityUtility::AllocateADsSecurityUtilityObject(
    CADsSecurityUtility **ppADsSecurityUtil
    )
{
    HRESULT hr = S_OK;
    CADsSecurityUtility FAR * pADsSecurityUtil = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;

    pADsSecurityUtil = new CADsSecurityUtility();

    if (!pADsSecurityUtil) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pDispMgr = new CDispatchMgr;

    if (!pDispMgr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = LoadTypeInfoEntry(
             pDispMgr,
             LIBID_ADs,
             IID_IADsSecurityUtility,
             (IADsSecurityUtility *)pADsSecurityUtil,
             DISPID_REGULAR
             );
    BAIL_ON_FAILURE(hr);

    pADsSecurityUtil->_pDispMgr = pDispMgr;
    *ppADsSecurityUtil = pADsSecurityUtil;

    RRETURN(hr);

error:

    delete pADsSecurityUtil;
    delete pDispMgr;

    RRETURN_EXP_IF_ERR(hr);
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::CreateADsSecurityUtility - Static 
//          helper method.
//
// Synopsis:   Standard static class factor helper method.
//
// Arguments:  riid             -   IID needed on returned object.
//             ppvObj           -   Return ptr.
//
// Returns:    S_OK on success or appropriate error code on failure.
//
// Modifies:   *ppvObj is suitably modified.
//
//----------------------------------------------------------------------------
HRESULT
CADsSecurityUtility::CreateADsSecurityUtility(
    REFIID riid,
    void **ppvObj
    )
{
    CADsSecurityUtility FAR * pADsSecurityUtil = NULL;
    HRESULT hr = S_OK;

    hr = AllocateADsSecurityUtilityObject(&pADsSecurityUtil);
    BAIL_ON_FAILURE(hr);

    hr = pADsSecurityUtil->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pADsSecurityUtil->Release();

    RRETURN(hr);

error:
    delete pADsSecurityUtil;

    RRETURN_EXP_IF_ERR(hr);

}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::QueryInterface --- IUnknown support.
//
// Synopsis:   Standard query interface method.
//
// Arguments:  iid           -  Interface requested.
//             ppInterface   -  Return pointer to interface requested.
//
// Returns:    S_OK on success. Error code otherwise.
//
// Modifies:   *ppInterface to return interface pointer.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtility::QueryInterface(
    REFIID iid,
    LPVOID *ppInterface
    )
{
    HRESULT hr = S_OK;

    if (!ppInterface) {
        RRETURN(E_INVALIDARG);
    }

    if (IsEqualIID(iid, IID_IUnknown)) {
        *ppInterface = (IADsSecurityUtility *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch)) {
        *ppInterface = (IADsSecurityUtility *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSecurityUtility)) {
        *ppInterface = (IADsSecurityUtility *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo)) {
        *ppInterface = (ISupportErrorInfo *) this;
    }
    else {
        RRETURN(E_NOINTERFACE);
    }

    AddRef();
    RRETURN(S_OK);

}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::InterfaceSupportserrorInfo
//                           ISupportErrorInfo support.
//
// Synopsis:   N/A.
//
// Arguments:  riid          -  Interface being tested..
//
// Returns:    S_OK or S_FALSE on failure.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtility::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsSecurityUtility)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::GetSecurityDescriptor - 
//          IADsSecurityUtility support.
//
// Synopsis:   Gets the security descriptor from the named object.
//
// Arguments:  varPath           -   Path of object to get SD from.
//             lPathFormat       -   Specifies type of object path.
//                                  Only ADS_PATH_FILE, ADS_PATH_FILESHARE
//                                  and ADS_PATH_REGISTRY are supported.
//             lOutFormat        -   Specifies output SD format.
//             pVariant          -   Return value for SD.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pVariant is update appropriately.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtility::GetSecurityDescriptor(
    IN VARIANT varPath,
    IN long lPathFormat, 
    IN OPTIONAL long lOutFormat, 
    OUT VARIANT *pVariant
    )
{
    HRESULT hr = S_OK;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD dwLength = 0;
    VARIANT *pvPath = NULL;

    //
    // Make sure the params are correct.
    //
    if (!pVariant) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    VariantInit(pVariant);
    
    if (lPathFormat < ADS_PATH_FILE
        || lPathFormat > ADS_PATH_REGISTRY
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Make sure we handle byRef params correctly.
    //
    pvPath = &varPath;
    if (V_VT(pvPath) == (VT_BYREF|VT_VARIANT)) {
        pvPath = V_VARIANTREF(&varPath);
    }
    
    //
    // For the path to be valid for now, it has to be a string.
    //
    if (pvPath->vt != VT_BSTR) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (pvPath->bstrVal == NULL) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    if (lOutFormat < ADS_SD_FORMAT_IID 
        || lOutFormat > ADS_SD_FORMAT_HEXSTRING
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    //
    // Time to get the raw sd from the source.
    //
    switch (lPathFormat) {
    case ADS_PATH_FILE:
        hr = GetRawSDFromFile(
                 pvPath->bstrVal,
                 _secInfo,
                 &pSecurityDescriptor,
                 &dwLength
                 );
        break;

    case ADS_PATH_FILESHARE:
        hr = GetRawSDFromFileShare(
                 pvPath->bstrVal,
                 &pSecurityDescriptor,
                 &dwLength
                 );
        break;
        
    case ADS_PATH_REGISTRY:
        hr = GetRawSDFromRegistry(
                 pvPath->bstrVal,
                 _secInfo,
                 &pSecurityDescriptor,
                 &dwLength
                 );
        break;

    default:
        hr = E_INVALIDARG;
        break;
    } // end of case to read sd.

    BAIL_ON_FAILURE(hr);
    
    //
    // Now convert the sd to the required format.
    //
    switch (lOutFormat) {
    case ADS_SD_FORMAT_IID:
        hr = BinarySDToSecurityDescriptor(
                 pSecurityDescriptor,
                 pVariant,
                 NULL,
                 NULL,
                 NULL,
                 0
                 );
        break;

    case ADS_SD_FORMAT_RAW:
        hr = ConvertRawSDToBinary(
                 pSecurityDescriptor,
                 dwLength,
                 pVariant
                 );
        break;

    case ADS_SD_FORMAT_HEXSTRING:
        hr = ConvertRawSDToHexString(
                 pSecurityDescriptor,
                 dwLength,
                 pVariant
                 );
        break;

    default:
        hr = E_INVALIDARG;
    } // end of case for output format.

error:

    if (pSecurityDescriptor) {
        FreeADsMem(pSecurityDescriptor);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::SetSecurityDescriptor - 
//          IADsSecurityUtility support.
//
// Synopsis:   Sets the security descriptor from the named object.
//
// Arguments:  varPath           -   Path of object to set SD on.
//             lPathFormat       -   Format of path.
//             varData           -   Variant with SD to set.
//             lDataFormat       -   Format of the SD data.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   N/A.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtility::SetSecurityDescriptor(
    IN VARIANT varPath,
    IN long lPathFormat,
    IN VARIANT varData,
    IN long lDataFormat
    )
{
    HRESULT hr = E_INVALIDARG;
    VARIANT *pvPath = NULL;
    VARIANT *pvData = NULL;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwLength = 0;

    if ((lPathFormat < ADS_PATH_FILE)
        || (lPathFormat > ADS_PATH_REGISTRY)
        || (lDataFormat < ADS_SD_FORMAT_IID)
        || (lDataFormat > ADS_SD_FORMAT_HEXSTRING)
        ) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }
    
    //
    // Make sure we handle byRef params correctly.
    //
    pvPath = &varPath;
    if (V_VT(pvPath) == (VT_BYREF | VT_VARIANT)) {
        pvPath = V_VARIANTREF(&varPath);
    }

    pvData = &varData;
    if (V_VT(pvData) == (VT_BYREF | VT_VARIANT)) {
        pvData = V_VARIANTREF(&varData);
    }

    //
    // Find out what format the SD is in and convert to raw binary
    // format as that is what we need to set.
    //
    switch (lDataFormat) {
    case ADS_SD_FORMAT_IID:
        hr = SecurityDescriptorToBinarySD(
                 *pvData,
                 &pSD,
                 &dwLength,
                 NULL,
                 NULL,
                 NULL,
                 0
                 );
        break;

    case ADS_SD_FORMAT_HEXSTRING:
        if (V_VT(pvData) == VT_BSTR) {
            hr = ConvertHexSDToRawSD(
                     pvData,
                     &pSD,
                     &dwLength
                     );
        }
        break;

    case ADS_SD_FORMAT_RAW:
        if (V_VT(pvData) == (VT_UI1 | VT_ARRAY)) {
            hr = ConvertBinarySDToRawSD(
                     pvData,
                     &pSD,
                     &dwLength
                     );
        }

    default:
        hr = E_INVALIDARG;
        break;
    } // end switch type of input data.

    //
    // This will catch conversion failures as well as bad params.
    //
    BAIL_ON_FAILURE(hr); 
    
    //
    // For now the path has to be a string.
    //
    if (pvPath->vt != VT_BSTR) {
        BAIL_ON_FAILURE(hr = E_INVALIDARG);
    }

    switch (lPathFormat) {
    case ADS_PATH_FILE:
        hr = SetRawSDToFile(
                 pvPath->bstrVal,
                 _secInfo,
                 pSD
                 );
        break;

    case ADS_PATH_FILESHARE:
        hr = SetRawSDToFileShare(
                 pvPath->bstrVal,
                 pSD
                 );
        break;

    case ADS_PATH_REGISTRY:
        hr = SetRawSDToRegistry(
                 pvPath->bstrVal,
                 _secInfo,
                 pSD
                 );
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }

    BAIL_ON_FAILURE(hr);

error:

    if (pSD) {
        FreeADsMem(pSD);
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:   CADsSecurityUtility::ConvertSecurityDescriptor - 
//          IADsSecurityUtility method.
//
// Synopsis:   Converts the input SD to the appropriate format requested.
//
// Arguments:  varData           -   Input SD to convert.
//             lDataFormat       -   Input SD format.
//             loutFormat        -   Format of output SD.
//             pvResult          -   Return value.
//
// Returns:    S_OK or any appropriate error code.
//
// Modifies:   pvResult with appropriate value.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtility::ConvertSecurityDescriptor(
    IN VARIANT varData,
    IN long lDataFormat, 
    IN long lOutFormat, 
    OUT VARIANT *pvResult
    )
{
    HRESULT hr;
    PSECURITY_DESCRIPTOR pSD = NULL;
    DWORD dwLenSD;
    VARIANT *pVarData = &varData;

    if (!pvResult) {
        BAIL_ON_FAILURE(hr= E_INVALIDARG);
    }

    if (V_VT(pVarData) == (VT_BYREF | VT_VARIANT)) {
        pVarData = V_VARIANTREF(&varData);
    }
     
    //
    // We will convert to binary format and then to 
    // the requested format.
    //
    switch (lDataFormat) {
    case ADS_SD_FORMAT_IID:
        hr = SecurityDescriptorToBinarySD(
                 *pVarData,
                 &pSD,
                 &dwLenSD,
                 NULL,
                 NULL,
                 NULL,
                 0
                 );
        break;

    case ADS_SD_FORMAT_RAW : 
        hr = ConvertBinarySDToRawSD(
                 pVarData,
                 &pSD,
                 &dwLenSD
                 );
        break;

    case ADS_SD_FORMAT_HEXSTRING:
        hr = ConvertHexSDToRawSD(
                 pVarData,
                 &pSD,
                 &dwLenSD
                 );
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }
    BAIL_ON_FAILURE(hr);

    //
    // Convert to the requested format.
    //
    switch (lOutFormat) {
    case ADS_SD_FORMAT_IID:
        hr = BinarySDToSecurityDescriptor(
                 pSD,
                 pvResult,
                 NULL,
                 NULL,
                 NULL,
                 0
                 );
        break;

    case ADS_SD_FORMAT_RAW:
        hr = ConvertRawSDToBinary(
                 pSD,
                 dwLenSD,
                 pvResult
                 );
        break;
        
    case ADS_SD_FORMAT_HEXSTRING:
        hr = ConvertRawSDToHexString(
                 pSD,
                 dwLenSD,
                 pvResult
                 );
        break;

    default:
        hr = E_INVALIDARG;
        break;
    }

error:

    if (pSD) {
        FreeADsMem(pSD);
    }

    RRETURN(hr);
}

STDMETHODIMP
CADsSecurityUtility::put_SecurityMask(
    long lSecurityMask
    )
{
    _secInfo = (SECURITY_INFORMATION) lSecurityMask;
    RRETURN(S_OK);
}

STDMETHODIMP
CADsSecurityUtility::get_SecurityMask(
    long *plSecurityMask
    )
{
    if (!plSecurityMask) {
        RRETURN(E_INVALIDARG);
    }

    *plSecurityMask = (long) _secInfo;

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\caclcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsAccessControlListCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsAccessControlListCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CAccessControlList::CreateAccessControlList(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\clgint.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cLargeInteger.cxx
//
//  Contents:  LargeInteger object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CLargeInteger

DEFINE_IDispatch_Implementation(CLargeInteger)

CLargeInteger::CLargeInteger():
        _pDispMgr(NULL),
        _dwHighPart(0),
        _dwLowPart(0)
{
    ENLIST_TRACKING(CLargeInteger);
}


HRESULT
CLargeInteger::CreateLargeInteger(
    REFIID riid,
    void **ppvObj
    )
{
    CLargeInteger FAR * pLargeInteger = NULL;
    HRESULT hr = S_OK;

    hr = AllocateLargeIntegerObject(&pLargeInteger);
    BAIL_ON_FAILURE(hr);

    hr = pLargeInteger->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pLargeInteger->Release();

    RRETURN(hr);

error:
    delete pLargeInteger;

    RRETURN_EXP_IF_ERR(hr);

}


CLargeInteger::~CLargeInteger( )
{
    delete _pDispMgr;
}

STDMETHODIMP
CLargeInteger::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsLargeInteger FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsLargeInteger))
    {
        *ppv = (IADsLargeInteger FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsLargeInteger FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CLargeInteger::AllocateLargeIntegerObject(
    CLargeInteger ** ppLargeInteger
    )
{
    CLargeInteger FAR * pLargeInteger = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pLargeInteger = new CLargeInteger();
    if (pLargeInteger == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsLargeInteger,
                (IADsLargeInteger *)pLargeInteger,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pLargeInteger->_pDispMgr = pDispMgr;
    *ppLargeInteger = pLargeInteger;

    RRETURN(hr);

error:

    delete pLargeInteger;
    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CLargeInteger::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsLargeInteger)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP
CLargeInteger::get_HighPart(THIS_  LONG *retval)
{
   *retval = _dwHighPart;
   RRETURN(S_OK);
}

STDMETHODIMP
CLargeInteger::put_HighPart(THIS_   LONG lnHighPart)
{
   _dwHighPart = lnHighPart;
   RRETURN(S_OK);
}

STDMETHODIMP
CLargeInteger::get_LowPart(THIS_  LONG *retval)
{
   *retval = _dwLowPart;
   RRETURN(S_OK);
}

STDMETHODIMP
CLargeInteger::put_LowPart(THIS_   LONG lnLowPart)
{
   _dwLowPart = lnLowPart;
   RRETURN(S_OK);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\clgintcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsLagreIntegerCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsLargeIntegerCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsLargeIntegerCF::CreateInstance(IUnknown * pUnkOuter,
                                  REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CLargeInteger::CreateLargeInteger(
                iid,
                ppv
                );

    RRETURN(hr);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cdsocf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cnamcf.cxx
//
//  Contents:  ADSI DSO Object Class Factory Code
//
//             CDSOCF::CreateInstance
//
//  History:   06-15-96     yihsins    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CDSOCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    // Create Instance code here

    hr = CDSOObject::CreateDSOObject(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cenumacl.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cenumacl.cxx
//
//  Contents:  Access Control List Enumerator Code
//
//             CAccCtrlListEnum::Create
//             CAccCtrlListEnum::CAccCtrlListEnum
//             CAccCtrlListEnum::~CAccCtrlListEnum
//             CAccCtrlListEnum::QueryInterface
//             CAccCtrlListEnum::AddRef
//             CAccCtrlListEnum::Release
//             CAccCtrlListEnum::Next
//             CAccCtrlListEnum::Skip
//             CAccCtrlListEnum::Clone
//
//  History:    03-26-98    AjayR Created.
//           This file was cloned from ldap\cenumvar.cxx
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::CAccCtrlListEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    03-26-96   AjayR     Cloned from ldap\cenumvar.
//
//----------------------------------------------------------------------------
CAccCtrlListEnum::CAccCtrlListEnum()
{
    //
    // Set the reference count on the enumerator.
    //
    _cRef = 1;

    _pACL = NULL;
    _curElement = 0;

}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::~CAccCtrlListEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CAccCtrlListEnum::~CAccCtrlListEnum()
{
    //
    // Bump down the reference count on the Collection object
    //

    //
    // Remove its entry (in ACL) as an enumerator of the ACL
    //
    if (_pACL) {
        _pACL->RemoveEnumerator(this);
    }

    // Release the ACL if we have a ref on it
    if (_pACL) {
        _pACL->Release();
        _pACL = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCtrlListEnum::QueryInterface(
    REFIID iid,
    void FAR* FAR* ppv
    )
{

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAccCtrlListEnum::AddRef(void)
{
    return ++_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CAccCtrlListEnum::Release(void)
{

    if(--_cRef == 0){

        delete this;
        return 0;
    }

    return _cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCtrlListEnum::Skip(ULONG cElements)
{

    RRETURN(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCtrlListEnum::Reset()
{

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnum]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CAccCtrlListEnum::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CAccCtrlListEnum::Create
//
//  Synopsis: Create the enumeration object and initialise the
//           the member variables with the appropritate values.
//
//  Arguments:  [ppEnumVariant]
//              [pACL] Pointer to CAccessControlList
//
//  Returns:    HRESULT
//
//  Modifies:   [ppEnumVariant]
//
//----------------------------------------------------------------------------
HRESULT
CAccCtrlListEnum::CreateAclEnum(
    CAccCtrlListEnum FAR* FAR* ppEnumVariant,
    CAccessControlList *pACL
    )
{
    HRESULT hr = S_OK;
    CAccCtrlListEnum FAR* pEnumVariant = NULL;

    *ppEnumVariant = NULL;

    pEnumVariant = new CAccCtrlListEnum();

    if (!pEnumVariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    // Note that we need to release this when we get rid of this object
    pACL->AddRef();
    pEnumVariant->_pACL = pACL;

error:
    if (FAILED(hr))
        delete pEnumVariant;
    else
        *ppEnumVariant = pEnumVariant;

    RRETURN_EXP_IF_ERR(hr);

}


// This method only returns one element at a time even if more
// than one element is asked for, of course pcElmentFetched is
// returned as one.
STDMETHODIMP
CAccCtrlListEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_FALSE;
    DWORD dwAceCount = 0;
    IADsAccessControlEntry *pAce = NULL;
    IDispatch *pDispatch = NULL;
    PVARIANT pThisVar = pvar;

    if (pcElementFetched) {
        *pcElementFetched = 0;
    }

    if (_pACL == NULL) {
        RRETURN(hr = S_FALSE);
    }

    // Will get the ace count each time so that changes in the
    // ACL do not affect the enum object

    //
    // ** Changes in ACL does affect the enum object. We should still get 
    // AceCount and check if _curElement within bounds as defensive
    // programming - especially since current model does not add critical
    // section protection on the enumerator for multi-threaded model.
    //  

    hr = _pACL->get_AceCount((long *)&dwAceCount);   // always return S_OK;    
    ADsAssert(hr == S_OK);

    if (dwAceCount == 0) {
        hr = S_FALSE;
        RRETURN(hr);
    }

    //
    // valid dwAceCount here (See **) 
    //

    if (_curElement < dwAceCount) {

        // bump up the curElement as we start at 0
        _curElement++;

        // get the corresponding acl pointer and QI it
        hr = _pACL->GetElement(_curElement, &pAce);      // either return S_OK or S_FALSE
        ADsAssert(hr == S_OK || hr == S_FALSE);

        if (hr != S_FALSE) {


            hr = pAce->QueryInterface(
                           IID_IDispatch,
                           (void **)&pDispatch
                           );
            if(FAILED(hr))
            {
                RRETURN(hr = S_FALSE); 
            }

            V_DISPATCH(pThisVar) = pDispatch;
            V_VT(pThisVar) = VT_DISPATCH;

            if (pcElementFetched) {
                *pcElementFetched = 1;
            }
        } else {
            RRETURN_EXP_IF_ERR(hr);
        }
    } else {

        // In this case, we need to set hr to S_FALSE
        // as we have returned all the aces.
        hr = S_FALSE;
    }

    RRETURN(hr);

}


BOOL
CAccCtrlListEnum::
DecrementCurElement(
    )
{
    if (_pACL && _curElement>=1) {

        _curElement--;
        return TRUE;

    } else {    // !pACL || _curElement ==0
        
        //
        // do not decrement _curElement since lower bound limit on curElement
        // is 0.
        //

        return FALSE;
    }
}
        
BOOL
CAccCtrlListEnum::
IncrementCurElement(
    )
{
    HRESULT hr = E_FAIL;
    DWORD dwAceCount;

    if (!_pACL) 
        return FALSE;
    
    hr = _pACL->get_AceCount((long *)&dwAceCount);
    if (FAILED(hr)) {
        return FALSE;
    }

    if (_curElement>=dwAceCount-1) {

        //
        // do not increment _curElement since upper bound limit on curElement
        // already reached; upperbound limit is actually dwAceCount-1 since
        // Next() increment _curElement by 1 before calling 
        // GetElement(_curElement). See Next() for details.
        //

        return FALSE;
    }

    _curElement++;
    return TRUE;
}

DWORD
CAccCtrlListEnum::
GetCurElement(
    )
{
    return _curElement;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cdso.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdso.cxx
//
//  Contents:  Microsoft OleDB/OleDS Data Source Object for ADSI
//
//
//  History:   08-01-96     shanksh    Created.
//
//------------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

extern LONG glnOledbObjCnt; 

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::CreateDSOObject
//
//  Synopsis:  Creates a new DB Session object from the DSO, and returns the
//             requested interface on the newly created object.
//
//  Arguments: pUnkOuter         Controlling IUnknown if being aggregated
//             riid              The ID of the interface
//             ppDBSession       A pointer to memory in which to return the
//                               interface pointer
//
//  Returns:
//                 S_OK                  The method succeeded.
//                 E_INVALIDARG          ppDBSession was NULL
//                 DB_E_NOAGGREGATION    pUnkOuter was not NULL (this object
//                                       does not support being aggregated)
//                 E_FAIL                Provider-specific error. This
//                 E_OUTOFMEMORY         Out of memory
//                 E_NOINTERFACE         Could not obtain requested interface on
//                                       DBSession object
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
HRESULT
CDSOObject::CreateDSOObject(
    IUnknown * pUnkOuter,
    REFIID     riid,
    void **    ppvObj
    )
{
    CDSOObject* pDSO = NULL;
    HRESULT hr;

    //
    // check in-params and NULL out-params in case of error
    //
    if( ppvObj )
        *ppvObj = NULL;
    else
        RRETURN( E_INVALIDARG );

    if( pUnkOuter )// && !InlineIsEqualGUID(riid, IID_IUnknown) )
        RRETURN( DB_E_NOAGGREGATION );

    //
    // open a DBSession object
    //
    pDSO = new CDSOObject(pUnkOuter);
    if( !pDSO )
        RRETURN( E_OUTOFMEMORY );

    //
    // initialize the object
    //
    if( !pDSO->FInit() ) {
        delete pDSO;
        RRETURN( E_OUTOFMEMORY );
    }

    //
    // get requested interface pointer on DSO Object
    //
    hr = pDSO->QueryInterface( riid, (void **)ppvObj);
    if( FAILED( hr ) ) {
        delete pDSO;
        RRETURN( hr );
    }

    pDSO->Release();

    RRETURN( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::Initialize
//
//  Synopsis:  Initializes the DataSource object.
//
//  Arguments:
//
//
//  Returns:   HRESULT
//                  S_OK
//                  E_FAIL
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::Initialize(
    void
    )
{
    HRESULT hr = S_OK;

    if( _fDSOInitialized )
        RRETURN( DB_E_ALREADYINITIALIZED);

    if(IsIntegratedSecurity())
    {
        //
        // If using integrated security, we need to save the calling thread's
        // security context here. Reason is that when we actually connect to
        // the directory, we could be running on a different context, and we
        // need to impersonate this context to work correctly.
        //
        if (!OpenThreadToken(
                 GetCurrentThread(),
                 TOKEN_ALL_ACCESS,
                 TRUE,
                 &_ThreadToken))
        {
            //
            // If thread doesn't have a token, use process token
            //
            if (GetLastError() != ERROR_NO_TOKEN ||
                !OpenProcessToken(
                     GetCurrentProcess(),
                     TOKEN_ALL_ACCESS,
                     &_ThreadToken))
            {
                GetLastError();
                BAIL_ON_FAILURE(hr = E_FAIL);

            }
        }
    }

    _fDSOInitialized = TRUE;

error:

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::Uninitialize
//
//  Synopsis:  Returns the Data Source Object to an uninitialized state
//
//  Arguments:
//
//
//  Returns:   HRESULT
//                  S_OK            |   The method succeeded
//                  DB_E_OBJECTOPEN |   A DBSession object was already created
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::Uninitialize(
    void
    )
{
    //
    // data source object is not initialized; do nothing
    //
    if( !_fDSOInitialized ) {
        RRETURN( S_OK );
    }
    else {
        if( !IsSessionOpen() ) {
            //
            // DSO initialized, but no DBSession is open.
            // So, reset DSO to uninitialized state
            //

            if (_ThreadToken)
            {
                CloseHandle(_ThreadToken);
                _ThreadToken = NULL;
            }

            _fDSOInitialized = FALSE;
            RRETURN( S_OK );
        }
        else {
            //
            // DBSession has already been created; trying to uninit
            // the DSO now is an error
            //
            RRETURN( DB_E_OBJECTOPEN );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::GetProperties
//
//  Synopsis:  Returns current settings of all properties in the
//             DBPROPFLAGS_DATASOURCE property group
//
//  Arguments:
//             cPropertySets       count of restiction guids
//             rgPropertySets      restriction guids
//             pcProperties        count of properties returned
//             pprgProperties      property information returned
//
//  Returns:   HRESULT
//                  S_OK          | The method succeeded
//                  E_FAIL        | Provider specific error
//                  E_INVALIDARG  | pcPropertyInfo or prgPropertyInfo was NULL
//                  E_OUTOFMEMORY | Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::GetProperties(
    ULONG             cPropIDSets,
    const DBPROPIDSET rgPropIDSets[],
    ULONG *           pcPropSets,
    DBPROPSET **      pprgPropSets
    )
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // If the Data Source object is initialized.
    //
    DWORD dwBitMask = PROPSET_DSO;

    if( _fDSOInitialized )
    dwBitMask |= PROPSET_INIT;

    //
    // Validate the GetProperties Arguments
    //
    HRESULT hr = _pUtilProp->GetPropertiesArgChk(
                                cPropIDSets,
                                rgPropIDSets,
                                pcPropSets,
                                pprgPropSets,
                                dwBitMask);
    if( FAILED(hr) )
        RRETURN( hr );

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->GetProperties(
                            cPropIDSets,
                            rgPropIDSets,
                            pcPropSets,
                            pprgPropSets,
                            dwBitMask ) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::GetPropertyInfo
//
//  Synopsis:  Returns information about rowset and data source properties supported
//             by the provider
//
//  Arguments:
//             cPropertySets        Number of properties being asked about
//             rgPropertySets       Array of cPropertySets properties about
//                                  which to return information
//             pcPropertyInfoSets   Number of properties for which information
//                                  is being returned
//             prgPropertyInfoSets  Buffer containing default values returned
//             ppDescBuffer         Buffer containing property descriptions
//
//  Returns:   HRESULT
//                  S_OK          | The method succeeded
//                  E_FAIL        | Provider specific error
//                  E_INVALIDARG  | pcPropertyInfo or prgPropertyInfo was NULL
//                  E_OUTOFMEMORY | Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::GetPropertyInfo(
    ULONG             cPropertyIDSets,
    const DBPROPIDSET rgPropertyIDSets[],
    ULONG *           pcPropertyInfoSets,
    DBPROPINFOSET **  pprgPropertyInfoSets,
    WCHAR **          ppDescBuffer)
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->GetPropertyInfo(
                            cPropertyIDSets,
                            rgPropertyIDSets,
                            pcPropertyInfoSets,
                            pprgPropertyInfoSets,
                            ppDescBuffer,
                            _fDSOInitialized) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::SetProperties
//
//  Synopsis:  Set properties in the DBPROPFLAGS_DATASOURCE property group
//
//  Arguments:
//             cPropertySets
//             rgPropertySets
//
//  Returns:   HRESULT
//                  E_INVALIDARG  | cProperties was not equal to 0 and
//                                  rgProperties was NULL
//                  E_FAIL        | Provider specific error
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::SetProperties(
    ULONG     cPropertySets,
    DBPROPSET rgPropertySets[]
    )
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // If the Data Source object is initialized.
    //
    DWORD dwBitMask = PROPSET_DSO;

    if( _fDSOInitialized )
        dwBitMask |= PROPSET_INIT;

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->SetProperties(
                            cPropertySets,
                            rgPropertySets,
                            dwBitMask) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::GetClassID
//
//  Synopsis:
//
//  Arguments:
//
//
//
//  Returns:
//
//
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::GetClassID(
        CLSID * pClassID
    )
{
    if( pClassID )
    {
        memcpy(pClassID, &CLSID_ADsDSOObject, sizeof(CLSID));
        RRETURN( S_OK );
    }

    RRETURN( E_FAIL );
}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::CreateSession
//
//  Synopsis:  Creates a new DB Session object from the DSO, and returns the
//             requested interface on the newly created object.
//
//  Arguments:
//             pUnkOuter,        Controlling IUnknown if being aggregated
//             riid,             The ID of the interface
//             ppDBSession       A pointer to memory in which to return the
//                               interface pointer
//
//  Returns:   HRESULT
//                 S_OK                  The method succeeded.
//                 E_INVALIDARG          ppDBSession was NULL
//                 DB_E_NOAGGREGATION    pUnkOuter was not NULL (this object
//                                       does not support being aggregated)
//                 E_FAIL                Provider-specific error. This
//                                       provider can only create one DBSession
//                 E_OUTOFMEMORY         Out of memory
//                 E_NOINTERFACE         Could not obtain requested interface
//                                       on DBSession object
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::CreateSession(
        IUnknown *  pUnkOuter,
    REFIID      riid,
    IUnknown ** ppDBSession
    )
{
    CSessionObject* pDBSession = NULL;
    HRESULT                     hr;
    BOOL                        fSuccess;

    //
    // check in-params and NULL out-params in case of error
    //
    if( ppDBSession )
        *ppDBSession = NULL;
    else
        RRETURN( E_INVALIDARG );

    if( pUnkOuter )//&& !InlineIsEqualGUID(riid, IID_IUnknown) )
        RRETURN( DB_E_NOAGGREGATION );

    if( !_fDSOInitialized ) {
        RRETURN(E_UNEXPECTED);
    }

    //
    // open a DBSession object
    //
    pDBSession = new CSessionObject(pUnkOuter);
    if( !pDBSession )
        RRETURN( E_OUTOFMEMORY );

    //
    // initialize the object
    //
    if( _pUtilProp->IsIntegratedSecurity() )
    {
        CCredentials    tempCreds;

        tempCreds.SetUserName(NULL);
        tempCreds.SetPassword(NULL);
        tempCreds.SetAuthFlags(_Credentials.GetAuthFlags());

        fSuccess = pDBSession->FInit(this, tempCreds);
    }
    else
    {
        fSuccess = pDBSession->FInit(this, _Credentials);
    }

    if (!fSuccess) {
        delete pDBSession;
        RRETURN( E_OUTOFMEMORY );
    }

    //
    // get requested interface pointer on DBSession
    //
    hr = pDBSession->QueryInterface( riid, (void **) ppDBSession );
    if( FAILED( hr ) ) {
        delete pDBSession;
        RRETURN( hr );
    }

    pDBSession->Release();

    RRETURN( S_OK );
}

//+-----------------------------------------------------------------------------
//
//  Function:  CDSOObject::CDSOObject
//
//  Synopsis:  Constructor
//
//  Arguments:
//             pUnkOuter         Outer Unkown Pointer
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CDSOObject::CDSOObject(
        LPUNKNOWN pUnkOuter
    )
{
    //  Initialize simple member vars
    _pUnkOuter       = pUnkOuter ? pUnkOuter : (IDBInitialize FAR *) this;
    _fDSOInitialized = FALSE;
    _cSessionsOpen   = FALSE;
    _pUtilProp       = NULL;
    _ThreadToken     = NULL;

    // Set defaults
    _Credentials.SetUserName(NULL);
    _Credentials.SetPassword(NULL);
    _Credentials.SetAuthFlags(0);

    ENLIST_TRACKING(CDSOObject);

    // make sure DLL isn't unloaded until all data source objects are destroyed
    InterlockedIncrement(&glnOledbObjCnt);
}


//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::~CDSOObject
//
//  Synopsis:  Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CDSOObject::~CDSOObject( )
{
    //
    // Free properties management object
    //
    delete _pUtilProp;

    if (_ThreadToken)
        CloseHandle(_ThreadToken);

    InterlockedDecrement(&glnOledbObjCnt);
}


//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::FInit
//
//  Synopsis:  Initialize the data source Object
//
//  Arguments:
//
//  Returns:
//             Did the Initialization Succeed
//                  TRUE        Initialization succeeded
//                  FALSE       Initialization failed
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
BOOL CDSOObject::FInit(
    void
    )
{
    HRESULT hr;

    //
    // Allocate properties management object
    //
    _pUtilProp = new CUtilProp();

    if( !_pUtilProp )
        return FALSE;

    hr = _pUtilProp->FInit(&_Credentials);
    BAIL_ON_FAILURE( hr );

    return TRUE;

error:
    return FALSE;

}

//+---------------------------------------------------------------------------
//
//  Function:  CDSOObject::QueryInterface
//
//  Synopsis:  Returns a pointer to a specified interface. Callers use
//             QueryInterface to determine which interfaces the called object
//             supports.
//
//  Arguments:
//            riid     Interface ID of the interface being queried for
//            ppv      Pointer to interface that was instantiated
//
//  Returns:
//             S_OK               Interface is supported and ppvObject is set.
//             E_NOINTERFACE      Interface is not supported by the object
//             E_INVALIDARG       One or more arguments are invalid.
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CDSOObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if( ppv == NULL )
        RRETURN( E_INVALIDARG );

    if( IsEqualIID(iid, IID_IUnknown) ) {
        *ppv = (IDBInitialize FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IDBInitialize) ) {
        *ppv = (IDBInitialize FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IDBProperties) ) {
        *ppv = (IDBProperties FAR *) this;
    }
    else if( _fDSOInitialized &&
             IsEqualIID(iid, IID_IDBCreateSession) ) {
        *ppv = (IDBCreateSession FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IPersist) ) {
        *ppv = (IPersist FAR *) this;
    }
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cextbuff.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  caccess.cxx
//
//  Contents:  Microsoft OleDB/OleDS Data Source Object for ADSI
//
//             Implementation of the Extended Buffer Object used for storing
//             accessor handles.
//
//  History:   10-01-96     shanksh    Created.
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop


// ---------------------------  C E X T B U F F E R ---------------------------
//
// Implementation class for the Extended Buffer object.


//-----------------------------------------------------------------------------
// CExtBuff::CExtBuff
//
// @mfunc CExtBuff constructor.
//
// @rdesc NONE
//-----------------------------------------------------------------------------

CExtBuff::CExtBuff(
    void
    )
{
    _cItem    = 0;
    _cItemMax = 0;
    _rgItem   = NULL;
}


//-----------------------------------------------------------------------------
// CExtBuff::~CExtBuff
//
// @mfunc CExtBuff destructor.
//
// @rdesc NONE
//-----------------------------------------------------------------------------

CExtBuff::~CExtBuff(
    void
    )
{
    if (_rgItem)
        FreeADsMem(_rgItem);
}


//-----------------------------------------------------------------------------
// FInit::CExtBuff
//
//      CExtBuff initialization (memory allocation for the default item
//      happens  here).
//
// @rdesc Did the Initialization Succeed
//      @flag  TRUE  | Initialization succeeded
//        @flag  FALSE | Initializtion failed
//-----------------------------------------------------------------------------

BOOL CExtBuff::FInit(
    ULONG       cbItem,           // size of items to store
    VOID        *pvItemDefault    // points to a default value to return
                                  // when an element asked for doesn't exist
    )
{
    ULONG_PTR  hItemDefault;

    ADsAssert(cbItem);
    ADsAssert(HIWORD(cbItem) == 0);

    _cbItem = cbItem;
    _rgItem = (BYTE *)AllocADsMem((CEXTBUFFER_DITEM*_cbItem));

    if (_rgItem == NULL)
        return FALSE;

    _cItemMax = CEXTBUFFER_DITEM;

    // It's the first insertion so hItemDefault is always 0 and consequently
    // we don't need to store it.
    if (pvItemDefault)
        return (InsertIntoExtBuffer(pvItemDefault, hItemDefault) == NOERROR);
    else
        return TRUE;
}


//------------------------------------------------------------------------------
// CExtBuff::InsertIntoExtBuffer
//
// @mfunc Stores an item in the Extended Buffer.
//
// @rdesc Returns one of the following values:
//         @flag S_OK          | insertion succeeded,
//         @flag E_OUTOFMEMORY | insertion failed because of memory allocation
 //                              failure
//-----------------------------------------------------------------------------------

STDMETHODIMP CExtBuff::InsertIntoExtBuffer(
    VOID        *pvItem,    // pointer to item to be stored
    ULONG_PTR   &hItem      // points to where the item handle is returned
    )
{
    // If the buffer capacity is exhausted it needs to be reallocated. Buffer capacity
    // is increased by a fixed quantum.
    if (_cItem == _cItemMax) {
        BYTE *pbTmp;

        pbTmp = (BYTE *)ReallocADsMem(
                            _rgItem,
                            _cItemMax * _cbItem,
                            (_cItemMax +CEXTBUFFER_DITEM)*_cbItem
                            );
        if (pbTmp == NULL)
            RRETURN (E_OUTOFMEMORY);

        // Buffer capacity increased.
        _cItemMax += CEXTBUFFER_DITEM;
        _rgItem    = pbTmp;
    }

    // Copy the item.
    memcpy( (_rgItem + _cItem*_cbItem), (BYTE *)pvItem, _cbItem );
    _cItem++;

    // Index of the item constitues its handle.
    hItem = _cItem -1;

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cdnstrcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdnstrcf.cxx
//
//  Contents:  DN With String Object class factory
//
//             CADsDNWithStringCF::CreateInstance
//
//  History:   04-26-1999     AjayR    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsDNWithStringCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsDNWithStringCF::CreateInstance(IUnknown * pUnkOuter,
                                  REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CDNWithString::CreateDNWithString(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cenumvar.cxx ===
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"

extern PROUTER_ENTRY g_pRouterHead;
extern CRITICAL_SECTION g_csRouterHeadCritSect;

CEnumVariant::CEnumVariant()
{
    _cRef = 1;

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);

    _lpCurrentRouterEntry = g_pRouterHead;

}

CEnumVariant::~CEnumVariant()
{

}


HRESULT
CEnumVariant::Create(IEnumVARIANT **ppenum)
{
    HRESULT     hr;
    CEnumVariant * pEnum;

    pEnum = new CEnumVariant();

    if (!pEnum) {
        RRETURN (E_OUTOFMEMORY);
    }

    if (pEnum)
    {
        hr = pEnum->QueryInterface(IID_IEnumVARIANT,
                                    (void **)ppenum);

        pEnum->Release();
    }
    else
    {
        *ppenum = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}

STDMETHODIMP
CEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


STDMETHODIMP_(ULONG)
CEnumVariant::AddRef(void)
{

    return ++_cRef;
}


STDMETHODIMP_(ULONG)
CEnumVariant::Release(void)
{


    if(--_cRef == 0){

        delete this;
        return 0;
    }

    return _cRef;
}

STDMETHODIMP
CEnumVariant::Next(ULONG cElements, VARIANT FAR* pvar, ULONG FAR* pcElementFetched)
{
    DWORD dwFound = 0;
    PROUTER_ENTRY lpRouter = _lpCurrentRouterEntry;
    HRESULT hr;
    IDispatch * lpDispatch;

    while (lpRouter && (dwFound  < cElements)) {
        hr = CoCreateInstance(*lpRouter->pNamespaceClsid,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDispatch,
                              (void **)&lpDispatch
                              );
        if (FAILED(hr)) {
            lpRouter = lpRouter->pNext;
            continue;
        }

        VariantInit(&pvar[dwFound]);
        pvar[dwFound].vt = VT_DISPATCH;
        pvar[dwFound].punkVal = lpDispatch;
        dwFound++;

        lpRouter = lpRouter->pNext;
    }
    _lpCurrentRouterEntry = lpRouter;

    //
    // Hack for VB -- it passes NULL always
    //
    if (pcElementFetched) {
        *pcElementFetched = dwFound;
    }
    if (dwFound < cElements) {
        RRETURN(S_FALSE);
    }
    RRETURN(S_OK);
}


STDMETHODIMP
CEnumVariant::Skip(ULONG cElements)
{

    RRETURN(ResultFromScode(E_FAIL));

}

STDMETHODIMP
CEnumVariant::Reset()
{
    RRETURN(ResultFromScode(S_OK));
}

STDMETHODIMP
CEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(ResultFromScode(E_FAIL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR ClassName,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);

    hr = BuildADsPath(
            Parent,
            Name,
            &_ADsPath
            );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
        );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(Parent, &_Parent);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString(Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString(ClassName, &_ADsClass);
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0)
{
}


CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }

}




HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_Name, retval));
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsPath, retval));

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsClass, retval));
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_Parent, retval));
}



HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsGuid, retval));
}


STDMETHODIMP
CCoreADsObject::GetInfo(THIS_ DWORD dwApiLevel, BOOL fExplicit)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cnamscf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsNamespacesCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsNamespacesCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CADsNamespaces *     pDomain;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CADsNamespaces::CreateNamespaces(
             L"",
             L"ADs:",
             ADS_OBJECT_BOUND,
             iid,
             ppv
             );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cprop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cPropertyEntry.cxx
//
//  Contents:  PropertyEntry object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CPropertyEntry

DEFINE_IDispatch_Implementation(CPropertyEntry)

CPropertyEntry::CPropertyEntry():
        _pDispMgr(NULL),
        _lpName(NULL),
        _dwValueCount(0),
        _dwADsType(0),
        _dwControlCode(0)
{
    ENLIST_TRACKING(CPropertyEntry);
}


HRESULT
CPropertyEntry::CreatePropertyEntry(
    REFIID riid,
    void **ppvObj
    )
{
    CPropertyEntry FAR * pPropertyEntry = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyEntryObject(&pPropertyEntry);
    BAIL_ON_FAILURE(hr);

    hr = pPropertyEntry->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPropertyEntry->Release();

    RRETURN(hr);

error:
    delete pPropertyEntry;

    RRETURN_EXP_IF_ERR(hr);

}


CPropertyEntry::~CPropertyEntry( )
{
   VariantClear(&_propVar);

   if (_lpName) {
       FreeADsStr(_lpName);
   }

   delete _pDispMgr;
}

STDMETHODIMP
CPropertyEntry::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPropertyEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyEntry))
    {
        *ppv = (IADsPropertyEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPropertyEntry FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CPropertyEntry::AllocatePropertyEntryObject(
    CPropertyEntry ** ppPropertyEntry
    )
{
    CPropertyEntry FAR * pPropertyEntry = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPropertyEntry = new CPropertyEntry();
    if (pPropertyEntry == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyEntry,
                (IADsPropertyEntry *)pPropertyEntry,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPropertyEntry->_pDispMgr = pDispMgr;
    *ppPropertyEntry = pPropertyEntry;

    RRETURN(hr);

error:

    delete pPropertyEntry;

    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CPropertyEntry::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsPropertyEntry)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP
CPropertyEntry::get_Values(THIS_ VARIANT FAR * retval)
{
    HRESULT hr;
    VariantInit(retval);
    hr = VariantCopy(retval, &_propVar);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CPropertyEntry::put_Values(THIS_ VARIANT vValues)
{
    HRESULT hr;

    // set the values only if it is valid
    if ( (V_VT(&vValues) == (VT_ARRAY | VT_VARIANT))
         || (V_VT(&vValues) == (VT_EMPTY))) {

        hr = VariantCopy(&_propVar, &vValues);
        RRETURN_EXP_IF_ERR(hr);

    } else {

        RRETURN(hr=E_ADS_BAD_PARAMETER);

    }
}


STDMETHODIMP
CPropertyEntry::get_ValueCount(THIS_ long FAR * retval)
{
    *retval = _dwValueCount;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyEntry::put_ValueCount(THIS_ long lnValueCount)
{

    _dwValueCount = lnValueCount;
    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyEntry::get_ADsType(THIS_ long FAR * retval)
{
    *retval = _dwADsType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyEntry::put_ADsType(THIS_ long lnADsType)
{
    _dwADsType = lnADsType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyEntry::get_ControlCode(THIS_ long FAR * retval)
{
    *retval = _dwControlCode;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyEntry::put_ControlCode(THIS_ long lnControlCode)
{
    _dwControlCode = lnControlCode;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyEntry::get_Name(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpName, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CPropertyEntry::put_Name(THIS_ BSTR bstrName)
{

    if (!bstrName) {
        RRETURN_EXP_IF_ERR(E_ADS_BAD_PARAMETER);
    }

    if (_lpName) {
        FreeADsStr(_lpName);
    }

    _lpName = AllocADsStr(bstrName);

    if (!_lpName) {
        RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CPropertyEntry::Clear(THIS_ )
{
    _dwADsType = 0;

    _dwControlCode = 0;

    _dwValueCount = 0;

    VariantClear(&_propVar);

    if (_lpName) {
        FreeADsStr(_lpName);
        _lpName = NULL;
    }

    RRETURN(S_OK);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cpropcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsPropertyEntryCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsPropertyEntryCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPropertyEntry::CreatePropertyEntry(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  Windows NT 3.5 Provider Object Class Factory Code
//
//             CADsProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop


//  Class CADsProvider

CADsProvider::CADsProvider()
{

}

HRESULT
CADsProvider::Create(CADsProvider FAR * FAR * ppProvider)
{
    CADsProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CADsProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN(hr);
}

CADsProvider::~CADsProvider( )
{
    ENLIST_TRACKING(CADsProvider);
}

STDMETHODIMP
CADsProvider::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IParseDisplayName FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CADsProvider::ParseDisplayName(IBindCtx* pbc, WCHAR* szDisplayName, ULONG* pchEaten, IMoniker** ppmk)
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN(hr);
}


HRESULT
CADsProvider::ResolvePathName(IBindCtx* pbc,
                WCHAR* szDisplayName,
                ULONG* pchEaten,
                IMoniker** ppmk
                )
{
    HRESULT hr = S_OK;
    LPUNKNOWN pUnknown = NULL;

    if (!pchEaten) {
        BAIL_IF_ERROR(hr = E_INVALIDARG);
    }

    *pchEaten = 0;

    //
    // The ADs: Path would only work if it contains the exact
    // text L"ADs:" or L"ADs://" for backward compatibility.
    //
    if ((_wcsicmp(szDisplayName,L"ADs:") != 0)
        && (_wcsicmp(szDisplayName, L"ADs://") != 0 )) {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_IF_ERROR(hr);
    }

    hr = CADsNamespaces::CreateNamespaces(
             L"",
             L"ADs:",
             ADS_OBJECT_BOUND,
             IID_IUnknown,
             (void **)&pUnknown
             );
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += wcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\common.cxx ===
#include "oleds.hxx"
#pragma hdrstop

//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Router routines and properties that are common to
//              all Router objects. Router objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------


//+------------------------------------------------------------------------
//
//  Function:   BuildADsPath
//
//  Synopsis:   Returns the ADs path for Router Objects. Note that there
//              is *** ONLY ONE *** Router Object and that is the Namespaces
//              Object.
//              The ADsPath for the Namespaces Object is the same as its
//              Name -- L"ADs:"
//
//  Arguments:  [Parent]  - is NULL and ignored
//              [Name]    - is L"ADs:"
//              [pADsPath] - pointer to a BSTR
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    HRESULT hr = S_OK;

    ADsAssert(pADsPath);

    hr = ADsAllocString(Name, pADsPath);

    RRETURN(hr);
}



HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    if (!StringFromGUID2(clsid, ADsClass, MAX_PATH)) {
        //
        // MAX_PATH should be more than enough for the GUID.
        //
        ADsAssert(!"GUID too big !!!");
        RRETURN(E_FAIL);
    }
 
    RRETURN(ADsAllocString(ADsClass, pADsClass));
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cnamesps.cxx ===
#include "oleds.hxx"
#pragma hdrstop

#define DISPID_REGULAR      1
//  Class CADsNamespaces

DEFINE_IDispatch_Implementation(CADsNamespaces)
DEFINE_IADs_Implementation(CADsNamespaces)


CADsNamespaces::CADsNamespaces():
    _pDispMgr(NULL),
    _bstrDefaultContainer(NULL)
{
    VariantInit(&_vFilter);
    ENLIST_TRACKING(CADsNamespaces);
}

HRESULT
CADsNamespaces::CreateNamespaces(
    BSTR Parent,
    BSTR NamespacesName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CADsNamespaces FAR * pNamespaces = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespacesObject(&pNamespaces);
    BAIL_ON_FAILURE(hr);

    hr = pNamespaces->InitializeCoreObject(Parent,
                                           NamespacesName,
                                           L"Namespaces",
                                           CLSID_ADsNamespaces,
                                           dwObjectState);
    BAIL_ON_FAILURE(hr);

    hr = pNamespaces->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespaces->Release();

    RRETURN(hr);

error:

    delete pNamespaces;
    RRETURN_EXP_IF_ERR(hr);
}


CADsNamespaces::~CADsNamespaces( )
{
    ADsFreeString(_bstrDefaultContainer);
    delete _pDispMgr;

}

STDMETHODIMP
CADsNamespaces::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsNamespaces))
    {
        *ppv = (IADsNamespaces FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CADsNamespaces::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADs) ||
        IsEqualIID(riid, IID_IADsContainer) ||
        IsEqualIID(riid, IID_IADsNamespaces)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP
CADsNamespaces::SetInfo()
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::GetInfo()
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}


/* IADsContainer methods */

STDMETHODIMP
CADsNamespaces::get_Count(long FAR* retval)
{
    RRETURN_EXP_IF_ERR(E_ADS_PROPERTY_NOT_SUPPORTED);
}

STDMETHODIMP
CADsNamespaces::get_Filter(THIS_ VARIANT FAR* pVar)
{
    HRESULT hr;
    VariantInit(pVar);
    hr = VariantCopy(pVar, &_vFilter);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CADsNamespaces::put_Filter(THIS_ VARIANT Var)
{
    HRESULT hr;
    VariantClear(&_vFilter);
    hr = VariantCopy(&_vFilter, &Var);
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CADsNamespaces::get_Hints(THIS_ VARIANT FAR* pHints)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::put_Hints(THIS_ VARIANT Hints)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    WCHAR szBuffer[MAX_PATH];
    HRESULT hr = S_OK;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    // for namespace, we do not expect that it will have more than MAX_PATH characters
    if(wcslen(RelativeName) >= MAX_PATH)
    {
        RRETURN(E_ADS_BAD_PARAMETER);
    }

    wcscpy(szBuffer, RelativeName);

    hr = ::GetObject(
                szBuffer,
                IID_IDispatch,
                (LPVOID *)ppObject,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

error:

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CADsNamespaces::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CEnumVariant::Create(&penum);
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(IID_IUnknown,
                               (VOID FAR* FAR*)retval);

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    RRETURN_EXP_IF_ERR(hr);
}

//
// IADsNamespaces methods
//

STDMETHODIMP
CADsNamespaces::get_DefaultContainer(THIS_ BSTR FAR* retval)
{

    LPTSTR pszDefContainer = NULL;
    HRESULT hr;

    hr = QueryKeyValue(DEF_CONT_REG_LOCATION,
                       TEXT("DefaultContainer"),
                       &pszDefContainer);

    BAIL_IF_ERROR(hr);

    hr = ADsAllocString(pszDefContainer, retval);

cleanup:
    if(pszDefContainer){
        FreeADsMem(pszDefContainer);
    }
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CADsNamespaces::put_DefaultContainer(THIS_ BSTR bstrDefaultContainer)
{
    HRESULT hr =  S_OK;

    hr = SetKeyAndValue(DEF_CONT_REG_LOCATION,
                        TEXT("DefaultContainer"),
                        NULL,
                        bstrDefaultContainer);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CADsNamespaces::Create(THIS_ BSTR ClassName, BSTR RelativeName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::CopyHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

STDMETHODIMP
CADsNamespaces::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN_EXP_IF_ERR(E_NOTIMPL);
}

HRESULT
CADsNamespaces::AllocateNamespacesObject(
    CADsNamespaces ** ppNamespaces
    )
{
    CADsNamespaces FAR * pNamespaces = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespaces = new CADsNamespaces();
    if (pNamespaces == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pNamespaces,
                           DISPID_REGULAR);
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(pDispMgr,
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pNamespaces,
                           DISPID_NEWENUM);
    BAIL_ON_FAILURE(hr);

    pNamespaces->_pDispMgr = pDispMgr;
    *ppNamespaces = pNamespaces;

    RRETURN(hr);

error:

    delete pNamespaces;
    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cprovcf.cxx
//
//  Contents:  ADs Provider Object Class Factory Code
//
//             CADsProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CADsProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CADsProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CADsProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cseccf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000
//
//  File:  cseccf.cxx
//
//  Contents:  ADs Security Object class factory
//
//             CADsSecurityCF::CreateInstance
//
//  History:   11-04-2000     AjayR    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsSecurityUtilityCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityUtilityCF::CreateInstance(
    IUnknown * pUnkOuter,
    REFIID iid, LPVOID * ppv
    )
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    if (!ppv) {
        RRETURN(E_INVALIDARG);
    }

    hr = CADsSecurityUtility::CreateADsSecurityUtility(
             iid,
             ppv
             );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\crowset.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       crowset.cxx
//
//  Contents:   IRowset implementation for ADSI OLEDB provider
//
//--------------------------------------------------------------------------

#include "oleds.hxx"

//-----------------------------------------------------------------------------
// Note on nomenclature
//
// Index - index within the rowset cache.
// 0 <= (Index <= m_cNumRowsCached - 1)
//
// Row - index within the entire rowset (not just the cache).
// 0 <= Row <= #rows in rowset - 1
//
// Bookmark - a unique value associated with each row. Currently, this is the
// same as the row value.
//
// Row handle - handle to a row in the rowset cache that is returned to the
// user. This value has to be unique across all rows currently in the cache
// (rows that the user has a reference on). Although we could use the index
// as this unique value, we will use the row (+1, since 0 == DB_NULL_HROW and
// hence row 0 cannot have a handle of 0). Using the row has the advantage
// that we will be able to detect stale row handles passed in by the user in
// most cases. This would be more difficult with the index as the index can
// be reused.
//
// The rowset cache contains a fixed number of rows, specified by the
// DBPROP_MAXOPENROWS property (if this property is set to 0, the rowset may
// contain as many rows as possble). A row remains in the cache as long as the
// consumer has a reference to the row. A row is removed from the cache when
// its reference count goes to 0, as a result of a call to ReleaseRows. If the
// cache becomes full, subsequent calls to fetch more rows in to the cache will
// return DB_S_ROWLIMITEXCEEDED. The rows in the cache need not be contiguous.
// For example, the consumer might fetch rows 1,2,3 and then call ReleaseRows
// only on 2. In this case, 1 and 3 would still be in the cache. Each row in
// the cache contains its "row" value. Currently, this value is also used as
// the bookmark to the row.
//-----------------------------------------------------------------------------

//-----------------------------------------------------------------------------
// CreateRowset
//
// Creates and initializes a rowset object. Called by a command or session
// object. The rows are brought in only on demand.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::CreateRowset(
    CRowProvider   *pIRowProvider,  // The Row provider
    IUnknown       *pParentObj,     // parent object, a command or a session
    CSessionObject *pCSession,      // Session Object
    CCommandObject *pCCommand,      // Command Object
    ULONG          cPropertySets,   // # property sets in rowset property group
    DBPROPSET      rgPropertySets[],// properties in rowset property group
    ULONG          cAccessors,      // accessor count
    HACCESSOR      rgAccessors[],   // accessors on command object
    BOOL           fadsPathPresent, // Is ADsPath present in query
    BOOL           fAllAttrs,       // Return all attrs from row object?
    REFIID         riid,            // Interface desired
    IUnknown       **ppIRowset      // pointer to desired interface
    )
{
    HRESULT        hr;
    CRowset        *pCRowset = NULL;
    BOOL           fGotWarning = FALSE, fRowObjRequested;
    DBCOUNTITEM    cRowsObtained;
    HROW           *phRow = NULL;

    if( ppIRowset != NULL)
        *ppIRowset = NULL;

    pCRowset = new CRowset();
    if( NULL == pCRowset )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );

    hr = pCRowset->FInit(
            pIRowProvider,
            pParentObj,
            pCSession,
            pCCommand,
            cPropertySets,
            rgPropertySets,
            cAccessors,
            rgAccessors,
            fadsPathPresent,
            fAllAttrs
            );
    BAIL_ON_FAILURE(hr);
    if( hr != S_OK )
        fGotWarning = TRUE;

    if( ppIRowset != NULL )
    {
#if (!defined(BUILD_FOR_NT40))
        // If the client requested IRow, create a rowset and get a row object
        // off the rowset. Once we make the provider read/write, we should add
        // IRowChange and IRowSchmaChange here in addition to IRow. If the
        // client set the DBPROP_IRow property, then we always create a row
        // object by default.
        hr = pCRowset->IsRowObjRequested(&fRowObjRequested);
        BAIL_ON_FAILURE( hr );

        if( IsEqualIID(riid, IID_IRow) || (fRowObjRequested) )
        {
            hr = pCRowset->GetNextRows(NULL, 0, 1, &cRowsObtained, &phRow);
            BAIL_ON_FAILURE(hr);

            if( DB_S_ENDOFROWSET == hr )
                BAIL_ON_FAILURE( hr = DB_E_NOTFOUND );

            if( hr != S_OK )
                BAIL_ON_FAILURE( E_FAIL );

            ADsAssert( (1 == cRowsObtained ) && (phRow != NULL) &&
                       (*phRow != DB_NULL_HROW) );

            // Bump up reference count of rowset. This is to avoid the
            // destruction of the rowset if the call below fails. Artificially
            // incrementing the reference count by one will ensure that any
            // call to Release() on the rowset (say, from the destructor of
            // the row object) will not end up in the rowset object being
            // deleted.
            pCRowset->m_cRef++;

            hr = pCRowset->m_pCRowsetInfo->GetRowFromHROW(
                         NULL,
                         *phRow,
                         riid,
                         ppIRowset,
                         FALSE, // this is not a tear-off
                         pCRowset->m_fAllAttrs
                         );

            // Restore reference count
            pCRowset->m_cRef--;

            BAIL_ON_FAILURE(hr);

            // Release the row handle since the row object now has a reference
            // to it. The reference count of the rowset is at 1 now since the
            // row object stored off a pointer to the rowset. The rowset will
            // be freed when the row is released.
            hr = pCRowset->ReleaseRows(1, phRow, NULL, NULL, NULL);
            BAIL_ON_FAILURE(hr);

            // we won't bother returning DB_S_NOTSINGLETON if there are more
            // rows in the rowset since the spec doesn't require it.
        }
        else
#endif
        {
            hr = pCRowset->QueryInterface(riid, (void **)ppIRowset);
            BAIL_ON_FAILURE(hr);
        }
    }
    else // OpenRowset may pass in NULL as ppIRowset
        delete pCRowset;

    if( fGotWarning )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( S_OK );

error:

    if( pCRowset )
        delete pCRowset;

    RRETURN(hr);
}

//-----------------------------------------------------------------------------
// IsRowObjRequested
//
// From the properties specified by the client, check if DBPROP_IRow is set
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::IsRowObjRequested(BOOL *pfRowObjRequested)
{
#if (!defined(BUILD_FOR_NT40))
    DBPROPIDSET rgPropertyIDSets;
    DBPROPID    dbPropId;
    ULONG       cPropSets;
    DBPROPSET   *prgPropertySets;
    VARIANT     *pVariant;
    HRESULT     hr;
    int         i, j;

    if( NULL == pfRowObjRequested )
        BAIL_ON_FAILURE( hr = E_INVALIDARG );

    dbPropId = DBPROP_IRow;
    cPropSets = 0;
    prgPropertySets = NULL;

    rgPropertyIDSets.cPropertyIDs = 1;
    rgPropertyIDSets.rgPropertyIDs = &dbPropId;
    rgPropertyIDSets.guidPropertySet = DBPROPSET_ROWSET;

    hr = m_pCUtilProp->GetProperties(1,
                                     &rgPropertyIDSets,
                                     &cPropSets,
                                     &prgPropertySets,
                                     PROPSET_COMMAND
                                    );
    BAIL_ON_FAILURE( hr );

    ADsAssert( (1 == cPropSets) && (prgPropertySets != NULL) );
    ADsAssert( (1 == prgPropertySets->cProperties) &&
                       (prgPropertySets->rgProperties != NULL) );

    pVariant = &(prgPropertySets->rgProperties[0].vValue);
    *pfRowObjRequested =  V_BOOL( pVariant );

    // Free memory allocated by GetProperties
    for (i = 0; i < cPropSets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            ADsAssert(pProp);

            // We should free the DBID in pProp, but we know that
            // GetProperties always returns DB_NULLID and FreeDBID doesn't
            //  handle DB_NULLID. So, DBID is not freed here.

            VariantClear(&pProp->vValue);
        }

        CoTaskMemFree(prgPropertySets[i].rgProperties);
    }
    CoTaskMemFree(prgPropertySets);

    RRETURN( S_OK );

error:

    RRETURN( hr );
#else
    RRETURN(E_FAIL);
#endif
}

//-----------------------------------------------------------------------------
// CRowset
//
// Constructor initializes all fields to NULL
//
//-----------------------------------------------------------------------------
CRowset::CRowset(void)
{
    m_pCRowsetInfo = NULL;
    m_pCAccessor = NULL;
    m_pCRowProvider = NULL;
    m_pCUtilProp = NULL;

    m_pIDataConvert = NULL;
    m_pIColumnsInfo = NULL;
    m_pIRowProvider = NULL;
    m_pIMalloc = NULL;

    m_lLastFetchRow = RESET_ROW;
    m_cRowBytes = 0;
    m_cCol = 0;

    m_pColData = NULL;

    m_fCritSectionInitialized = FALSE;
    m_fEndOfRowset = FALSE;
    m_fadsPathPresent = TRUE;
    m_fAllAttrs = FALSE;

    m_cNumRowsCached = 0;
    m_LastFetchDir = FORWARD;

    m_pRowsPtr = NULL;
    m_dwRowCacheSize = 0;
    m_lCurrentRow = 0;

    m_cRef = 0;
}

//-----------------------------------------------------------------------------
// ~Crowset
//
// Destructor releases all resources
//
//-----------------------------------------------------------------------------
CRowset::~CRowset(void)
{
    if( m_pRowsPtr )
    {
        int iRow;

        for(iRow = 0; iRow < m_cNumRowsCached; iRow++)
        {
            ADsAssert(m_pRowsPtr[iRow] != NULL);
            FreeRow(m_pRowsPtr[iRow]);
        }

        FreeADsMem(m_pRowsPtr);
    }

    if( m_pCRowsetInfo )
        delete m_pCRowsetInfo;
    if( m_pCAccessor )
        delete m_pCAccessor;
    if( m_pCUtilProp )
        delete m_pCUtilProp;
    // Shouldn't delete m_pCRowProvider since we didn't allocate it

    if( m_pIDataConvert )
        m_pIDataConvert->Release();
    if( m_pIColumnsInfo )
        m_pIColumnsInfo->Release();
    if( m_pIMalloc )
        m_pIMalloc->Release();
    // Shouldn't release m_pIRowProvider since we didn't AddRef it

    if( m_pColData )
        FreeADsMem(m_pColData);

    if( m_fCritSectionInitialized )
        DeleteCriticalSection(&m_RowsetCritSection);
}

//-----------------------------------------------------------------------------
// FInit
//
// Initializes rowset object
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::FInit(
    CRowProvider   *pIRowProvider,  // The Row provider
    IUnknown       *pParentObj,     // parent object, a command or a session
    CSessionObject *pCSession,      // Session Object
    CCommandObject *pCCommand,      // Command Object
    ULONG          cPropertySets,   // # property sets in rowset property group
    DBPROPSET      rgPropertySets[],// properties in rowset property group
    ULONG          cAccessors,      // accessor count
    HACCESSOR      rgAccessors[],   // accessors on command object
    BOOL           fadsPathPresent, // Is ADsPath present in query
    BOOL           fAllAttrs        // Return all attrs from row object?
    )
{
    HRESULT        hr;
    BOOL           fGotWarning = FALSE;

    //
    // InitializeCriticalSection can throw exceptions under low memory conditions,
    // so catch the exception and handle it nicely.
    //
    try
    {
        InitializeCriticalSection(&m_RowsetCritSection);
        m_fCritSectionInitialized = TRUE;
    }
    catch(...)
    {
        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    m_pCRowsetInfo = new CRowsetInfo(NULL, pParentObj, pCSession, pCCommand,
                                           pIRowProvider);

    if( NULL == m_pCRowsetInfo )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );
    hr = m_pCRowsetInfo->FInit( (IUnknown *) ((IAccessor *)this) );
    BAIL_ON_FAILURE(hr);

    m_pCAccessor = new CImpIAccessor(this, NULL);
    if( NULL == m_pCAccessor )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );
    hr = m_pCAccessor->FInit();
    BAIL_ON_FAILURE(hr);

    m_pCRowProvider = pIRowProvider;

    m_pCUtilProp = new CUtilProp();
    if( NULL == m_pCUtilProp )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );
    hr = m_pCUtilProp->FInit(NULL);
    BAIL_ON_FAILURE(hr);

    // Set the properties. Use PROPSET_COMMAND as we only want to set
    // properties in the rowset property group. Any other properties
    // should return error.
    hr = m_pCUtilProp->SetProperties(cPropertySets,
                                     rgPropertySets,
                                     PROPSET_COMMAND
                                     );

    // On session object, we need to check DBPROPOPTIONS to really decide if
    // there was a serious error. See comment before SetSearchPrefs in
    // csession.cxx
    if( pCSession &&
              ((DB_E_ERRORSOCCURRED == hr) || (DB_S_ERRORSOCCURRED == hr)) )
    {
        ULONG i, j;

        for(i = 0; i < cPropertySets; i++)
            for(j = 0; j < rgPropertySets[i].cProperties; j++)
                if( rgPropertySets[i].rgProperties[j].dwStatus !=
                               DBPROPSTATUS_OK )
                    if( rgPropertySets[i].rgProperties[j].dwOptions !=
                               DBPROPOPTIONS_OPTIONAL )
                    {
                        BAIL_ON_FAILURE( hr = DB_E_ERRORSOCCURRED );
                    }
                    else
                        fGotWarning = TRUE;

        // if we get here, then there was all required properties were set
        // successfully. However, hr could still be DB_ERRORSOCCURRED if all
        // properties were optional and all of them could not be set. This
        // condition is not an error for OpenRowset as noted in the comment
        // in csession.cxx. Hence reset hr to S_OK.

        hr = S_OK;
    }

    BAIL_ON_FAILURE(hr);
    if( hr != S_OK ) // warning needs to be returned to user
        fGotWarning = TRUE;

    // Get the maximum number of rows the rowset cache should support
    hr = GetMaxCacheSize();
    BAIL_ON_FAILURE(hr);

    // Get IDataConvert interface for later use by IRowset->GetData
    hr = CoCreateInstance(
            CLSID_OLEDB_CONVERSIONLIBRARY,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IDataConvert,
            (void **)&m_pIDataConvert
            );
    BAIL_ON_FAILURE(hr);

    // Get IColumnsInfo interface pointer from row provider
    hr = pIRowProvider->QueryInterface(
            IID_IColumnsInfo,
            (void **)&m_pIColumnsInfo
            );
    BAIL_ON_FAILURE(hr);

    // No need to AddRef below since row provider is contained in CRowsetInfo
    // and CRowsetInfo's lifetime is within CRowset.
    m_pIRowProvider = pIRowProvider;

    // Copy inherited accessors from the command object
    hr = CopyAccessors(cAccessors, pCCommand, rgAccessors);
    BAIL_ON_FAILURE(hr);

    hr = CoGetMalloc(MEMCTX_TASK, &m_pIMalloc);
    BAIL_ON_FAILURE(hr);

    // get the column offsets from the row provider
    hr = GetColOffsets();
    BAIL_ON_FAILURE(hr);

    m_fadsPathPresent = fadsPathPresent;
    m_fAllAttrs = fAllAttrs;

    if( fGotWarning )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( S_OK );

error:

    if( m_pCRowsetInfo != NULL )
        delete m_pCRowsetInfo; // Releases pParentObj, pCCommand, pCSession and
                               // pIRowProvider

    if( m_pCAccessor != NULL )
        delete m_pCAccessor;
    if( m_pCUtilProp != NULL )
        delete m_pCUtilProp;
    if( m_pIDataConvert != NULL )
        m_pIDataConvert->Release();
    if( m_pIColumnsInfo != NULL )
        m_pIColumnsInfo->Release();
    if( m_pIMalloc )
        m_pIMalloc->Release();
    if( m_fCritSectionInitialized )
        DeleteCriticalSection(&m_RowsetCritSection);

    m_pCRowsetInfo = NULL;
    m_pCAccessor = NULL;
    m_pCRowProvider = NULL;
    m_pCUtilProp = NULL;
    m_pIDataConvert = NULL;
    m_pIColumnsInfo = NULL;
    m_pIRowProvider = NULL;
    m_pIMalloc = NULL;

    m_fCritSectionInitialized = FALSE;

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// GetMaxCacheSize
//
// From the properties specified by the client, get the maximum number of rows
// that the rowset cache should support.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::GetMaxCacheSize(void)
{
    DBPROPIDSET rgPropertyIDSets;
    DBPROPID    dbPropId;
    ULONG       cPropSets;
    DBPROPSET   *prgPropertySets;
    VARIANT     *pVariant;
    HRESULT     hr;
    ULONG       i, j;

    dbPropId = DBPROP_MAXOPENROWS;
    cPropSets = 0;
    prgPropertySets = NULL;

    rgPropertyIDSets.cPropertyIDs = 1;
    rgPropertyIDSets.rgPropertyIDs = &dbPropId;
    rgPropertyIDSets.guidPropertySet = DBPROPSET_ROWSET;

    hr = m_pCUtilProp->GetProperties(1,
                                     &rgPropertyIDSets,
                                     &cPropSets,
                                     &prgPropertySets,
                                     PROPSET_COMMAND
                                    );
    BAIL_ON_FAILURE( hr );

    ADsAssert( (1 == cPropSets) && (prgPropertySets != NULL) );
    ADsAssert( (1 == prgPropertySets->cProperties) &&
                       (prgPropertySets->rgProperties != NULL) );

    pVariant = &(prgPropertySets->rgProperties[0].vValue);
    m_dwMaxCacheSize =  V_I4( pVariant );

    // Free memory allocated by GetProperties
    for (i = 0; i < cPropSets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            ADsAssert(pProp);

            // We should free the DBID in pProp, but we know that
            // GetProperties always returns DB_NULLID and FreeDBID doesn't
            //  handle DB_NULLID. So, DBID is not freed here.

            VariantClear(&pProp->vValue);
        }

        CoTaskMemFree(prgPropertySets[i].rgProperties);
    }
    CoTaskMemFree(prgPropertySets);

    RRETURN( S_OK );

error:

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// CopyAccessors
//
// Copies inherited accessors from the command object to the rowset object. If
// the rowset is being created by a session object, nothing has to be done.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::CopyAccessors(
    ULONG          cAccessors,      // accessor count
    CCommandObject *pCCommand,      // Command Object
    HACCESSOR      rgAccessors[]    // accessors on command object
    )
{
    HRESULT        hr = S_OK;
    IAccessor      *pIAccessorCommand = NULL; // Command's IAccessor
    IAccessor      *pIAccessorRowset = NULL;  // Rowset's IAccessor

    // Bump up reference count so that call to Release at the end of this
    // function doesn't delete rowset object.
    CAutoBlock cab(&m_RowsetCritSection);
    ++m_cRef;

    if( (cAccessors > 0) && (pCCommand != NULL) )
    {
        hr = pCCommand->QueryInterface(
                    IID_IAccessor,
                    (void **)&pIAccessorCommand
                    );
        BAIL_ON_FAILURE(hr);

        hr = this->QueryInterface(
                    IID_IAccessor,
                    (void **)&pIAccessorRowset
                    );
        BAIL_ON_FAILURE(hr);

        hr = CpAccessors2Rowset(
                    pIAccessorCommand,
                    pIAccessorRowset,
                    cAccessors,
                    rgAccessors,
                    m_pCAccessor);
        BAIL_ON_FAILURE(hr);
    }

error:

    if( pIAccessorCommand )
        pIAccessorCommand->Release();
    if( pIAccessorRowset )
        pIAccessorRowset->Release();

    --m_cRef;

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// GetColOffsets
//
// Decides the offets of the columns in thr row buffer based on the column
// info from the row provider
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::GetColOffsets(void)
{
    HRESULT      hr;
    DBCOLUMNINFO *pColInfo = NULL;
    OLECHAR      *pColNames = NULL;
    DWORD        dwOffset, i;

    hr = m_pIColumnsInfo->GetColumnInfo(&m_cCol, &pColInfo, &pColNames);
    BAIL_ON_FAILURE( hr );

    // we don't need the column names
    m_pIMalloc->Free(pColNames);

    m_pColData = (COLDATA *) AllocADsMem(sizeof(COLDATA) * m_cCol);
    if( NULL == m_pColData )
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    // Account for fields such as the row reference count that occur
    // before all columns in the row buffer
    dwOffset = sizeof(ROWBUFFER);

    for(i = 0; i < m_cCol; i++)
    {
        dwOffset = ColumnAlign(dwOffset);
        m_pColData[i].dwColOffset = dwOffset;

        // Account for the length and status fields of OLEDB data
        dwOffset += FIELD_OFFSET(OLEDBDATA, OledbValue);

        // Row provider returns all variable-length data types as BYREF
        if( pColInfo[i].wType & DBTYPE_BYREF )
            dwOffset += sizeof(char *);
        else
            dwOffset += (DWORD)pColInfo[i].ulColumnSize;

        m_pColData[i].wType = pColInfo[i].wType;
    }

    m_cRowBytes = dwOffset;
    m_pIMalloc->Free(pColInfo);

    RRETURN( S_OK );

error:

    if( pColInfo != NULL )
        m_pIMalloc->Free(pColInfo);
    if( m_pColData != NULL )
    {
        FreeADsMem(m_pColData);
        m_pColData = NULL;
    }
    m_cCol = m_cRowBytes = 0;

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// GetNextRows
//
// Gets rows using the row provider into the rowset's cache. Handles for these
// rows are returned to the caller. The caller then retrieves the rows using
// GetData.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetNextRows(
    HCHAPTER    hChapter, // ignored since this is not a chaptered rowset
    DBROWOFFSET lRowsOffset,
    DBROWCOUNT  cRows,
    DBCOUNTITEM *pcRowsObtained,
    HROW        **prghRows
    )
{
    HRESULT   hr;
    RBOOKMARK StartRowBmk;                 // bookmark of first row to fetch
    ULONG     cbBookmark = ADSI_BMK_SIZE;  // size in bytes of the bookmark

    if( (NULL == pcRowsObtained) || (NULL == prghRows) )
    {
        if( pcRowsObtained != NULL )
            *pcRowsObtained = 0;
        RRETURN( E_INVALIDARG );
    }

    *pcRowsObtained = 0;

    if( 0 == cRows )
        RRETURN( S_OK );

    CAutoBlock cab(&m_RowsetCritSection);

    if( RESET_ROW == m_lLastFetchRow )
    // this is the first fetch OR RestartPosition was called prior to this
    {
        if( (lRowsOffset > 0) || ((0 == lRowsOffset) && (cRows > 0)) )
        {
            StartRowBmk = DBBMK_FIRST;
            cbBookmark = STD_BMK_SIZE;
        }
        else if( (lRowsOffset < 0) || ((0 == lRowsOffset) && (cRows < 0)) )
        {
            // can't set StartRowBmk to DBBMK_LAST as we want to set it one
            // beyond the end of the rowset

            // Seek to end of rowset
            hr = SeekToEnd();
            if( FAILED(hr) )
                RRETURN( hr );

            // m_lCurrentRow is now 2 off the last row of the rowset
            StartRowBmk = RowToBmk(m_lCurrentRow - 1);
        }

        if( cRows < 0 )
        // the first row we want to fetch is one before that specified by
        // the combination of StartRowBmk and lRowsOffset
            lRowsOffset--;
    }
    else // we have fetched rows before OR RestartPosition was not called
    {
        // except in the 3rd case below, it is possible that StartRowBmk
        // will end up pointing to a row that is outside the rowset
        if( (FORWARD == m_LastFetchDir) && (cRows > 0) )
                StartRowBmk = RowToBmk(m_lLastFetchRow + 1);
        else if( (BACKWARD == m_LastFetchDir) && (cRows < 0) )
                StartRowBmk = RowToBmk(m_lLastFetchRow - 1);
        else // first row returned will be same as last row returned previously
                StartRowBmk = RowToBmk(m_lLastFetchRow);
    }

    hr = GetRowsAt(NULL, hChapter, cbBookmark, (BYTE *) &StartRowBmk,
                         lRowsOffset, cRows, pcRowsObtained, prghRows);

    if( SUCCEEDED(hr) )
    {
        // If we return DB_S_ENDOFROWSET because lRowsOffset indicated a
        // position outside the rowset, then we do not modify m_lLastFetchRow.
        // Only if we walked off either end of the rowset AND fetched at least
        // a row is m_lLastFetchRow updated. If no rows are returned due to
        // lack of space in the rowset cache, we do not modify m_lLastFetchRow.
        if( *pcRowsObtained )
        {
            m_LastFetchDir = (cRows > 0) ? FORWARD:BACKWARD;
            m_lLastFetchRow = HROWToRow( (*prghRows)[*pcRowsObtained - 1] );
        }
    }

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// GetRowsAt
//
// Fetches rows starting from a given offset from a bookmark. Handles for
// rows fetched are returned to the caller. The caller may send in an invalid
// bookmark i.e, a bookmark that was not returned by a previous invocation of
// GetData. Although, this is an error, the spec does not require the provider
// to detect this condition. So, the user can send in a random bookmark and the
// provider will return the correct row if there is a row that corresponds to
// the bookmark and DB_S_ENDOFROWSET otherwise. We make use of this fact when
// GetNextRows calls GetRowsAt. The bookmark passed in by GetNextRows may be
// for a row that is not yet in the provider's cache.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetRowsAt(
    HWATCHREGION hReserved, // Reserved for future use. Ignored.
    HCHAPTER     hChapter,  // ignored as this is not a chaptered rowset
    DBBKMARK     cbBookmark,
    const BYTE   *pBookmark,
    DBROWOFFSET  lRowsOffset,
    DBROWCOUNT   cRows,
    DBCOUNTITEM  *pcRowsObtained,
    HROW         **prghRows
    )
{
    LONG         lStartRow, // first row returned
                 lBmkRow,   // row corresponding to bookmark
                 lNextRow,
                 lRowIndex;
    int          iStep;
    HROW         *phRow;
    ROWBUFFER    *pRowBuffer;
    HRESULT      hr;
    BOOL         fMemAllocated = FALSE;
    DBCOUNTITEM  iRow;
    ULONG_PTR    ulRowsOffset;

    if( (0 == cbBookmark) || (NULL == pBookmark) ||
        (NULL == pcRowsObtained) || (NULL == prghRows) )
    {
        if( pcRowsObtained != NULL )
            *pcRowsObtained = 0;

        RRETURN( E_INVALIDARG );
    }

    *pcRowsObtained = 0;

    if( (cbBookmark != STD_BMK_SIZE) && (cbBookmark != ADSI_BMK_SIZE) )
        RRETURN( DB_E_BADBOOKMARK );

    if( 0 == cRows )
        RRETURN( S_OK ); // don't have to check for any errors

    CAutoBlock cab(&m_RowsetCritSection);

    // rowset can't have more than 2^32 rows. So, if offset points to beyond
    // that return eof.
    ulRowsOffset = (lRowsOffset > 0) ? lRowsOffset : -lRowsOffset;
    if( ulRowsOffset & 0xffffffff00000000 )
        RRETURN( DB_S_ENDOFROWSET );

    // Get first row to fetch
    hr = BmkToRow(cbBookmark, pBookmark, &lBmkRow);
    if( FAILED(hr) )
        RRETURN( hr );
    lStartRow = lBmkRow + lRowsOffset;

    if( lStartRow < FIRST_ROW )
        RRETURN( DB_S_ENDOFROWSET );

    lNextRow = lStartRow;
    if( NULL == *prghRows ) // provider has to allocate memory for handles
    {
        ULONG_PTR cNumHandles, cRowsAbs;

        // not sure if there is an abs64
        if(cRows < 0)
            cRowsAbs = -cRows;
        else
            cRowsAbs = cRows;

        // Guard against user requesting too many rows - maximum we can
        // return is the size of the rowset cache
        if( m_dwMaxCacheSize > 0 ) // user specified some max value
            cNumHandles = Min(cRowsAbs, (ULONG_PTR) m_dwMaxCacheSize);
        else
            cNumHandles = cRowsAbs;

        if( 0 == (cNumHandles * sizeof(HROW)) ) // numeric overflow
            *prghRows = NULL;
        else
            *prghRows = (HROW *) m_pIMalloc->Alloc(cNumHandles * sizeof(HROW));

        if( NULL == *prghRows )
            RRETURN( E_OUTOFMEMORY );
        fMemAllocated = TRUE;
    }

    iStep = (cRows > 0) ? 1 : -1;
    phRow = *prghRows;

    // fetch rows
    while( cRows )
    {
        hr = SeekToRow(lNextRow);
        BAIL_ON_FAILURE(hr);

        if( DB_S_ENDOFROWSET == hr )
        // we reached the end of the rowset OR we have reached the end of
        // whatever portion of the results set that ADSI has cached (depends
        // on the ADSIPROP_CACHE_RESULTS property)
        {
            if( (0 == *pcRowsObtained) && fMemAllocated )
            {
                m_pIMalloc->Free(*prghRows);
                *prghRows = NULL;
            }

            RRETURN( DB_S_ENDOFROWSET );
        }

        // Bring in the row that we just seeked to
        hr = BringInRow();

        BAIL_ON_FAILURE(hr);

        if( (DB_S_ROWLIMITEXCEEDED == hr) || (DB_S_ENDOFROWSET == hr) )
        // no more space in rowset cache OR end of rowset. We will hit end
        // of rowset only if m_lCurrentRow was one/two beyond the end of the
        // rowset when SeekToRow was called above AND lNextRow == m_lCurrentRow
        // (in which case, SeekToRow would just return without doing anything).
        {
            if( (0 == *pcRowsObtained) && fMemAllocated )
            {
                m_pIMalloc->Free(*prghRows);
                *prghRows = NULL;
            }

            RRETURN( hr );
        }

        // Get the index of the row within the rowset cache
        *phRow = RowToHROW(lNextRow);
        lRowIndex = HROWToIndex(*phRow);

        // Increment reference count of row
        pRowBuffer = m_pRowsPtr[lRowIndex];
        ADsAssert(pRowBuffer != NULL);
        IncrRefCount(pRowBuffer);

        phRow++;
        (*pcRowsObtained)++;
        lNextRow += iStep;
        cRows += (-iStep);

    } // while (cRows)

    RRETURN( S_OK );

error:
    // release any rows that were brought into the cache
    phRow = *prghRows;
    for(iRow = 0; iRow < *pcRowsObtained; iRow++)
    {
        ULONG ulRefCount;

        ReleaseRows(1, phRow, NULL, &ulRefCount, NULL); //ignore ret value

        phRow++;
    }

    if( fMemAllocated )
    {
        m_pIMalloc->Free(*prghRows);
        *prghRows = NULL;
    }

    *pcRowsObtained = 0;

    RRETURN(hr);
}

//-----------------------------------------------------------------------------
// BmkToRow
//
// Converts a bookmark to a row within the rowset.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::BmkToRow(
    ULONG      cbBookmark, // number of bytes in the bookmark
    const BYTE *pBookmark, //  pointer to bookmark
    LONG       *plRow
    )
{
    HRESULT    hr;

    ADsAssert( plRow != NULL );

    if( STD_BMK_SIZE == cbBookmark )
    {
        // If pBookmark is a pointer passed in from GetNextRows, then it is
        // actually a LONG *. Accessing *pBookmark to get the LSByte of the
        // bookmark below assumes LITTLE ENDIAN format.

        if( DBBMK_FIRST == *pBookmark )
            *plRow = FIRST_ROW;
        else if( DBBMK_LAST == *pBookmark )
        {
            CAutoBlock cab(&m_RowsetCritSection); // protect access to m_ fields

            // Seek to end of rowset
            hr = SeekToEnd();

            if( FAILED(hr) )
                RRETURN( hr );
            
            // should have reached end of rowset
            ADsAssert( DB_S_ENDOFROWSET == hr );

            // Seeking to end of rowset sets current row to MAX + 2, if there
            // is at least one row in the result. If the result is empty, we
            // will return -1 in *plRow below, but that's OK as -1 implies
            // DB_S_ENDOFROWSET in GetRowsAt()
            *plRow = m_lCurrentRow - 2;
        }
        else
            RRETURN( DB_E_BADBOOKMARK );
    }
    else if( ADSI_BMK_SIZE == cbBookmark )
        *plRow = *((LONG *) pBookmark);

    else // should never get in here
        ADsAssert( FALSE );

    RRETURN( S_OK );
}

//-----------------------------------------------------------------------------
// SeekToRow
//
// Positions the IDirectorySearch cursor such that the next call to GetNextRow
// will fetch the row lTargetRow. If we hit the end of the rowset before
// seeking to lTargetRow, returns DB_S_ENDOFROWSET.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::SeekToRow(LONG lTargetRow)
{
    HRESULT hr;

    CAutoBlock cab(&m_RowsetCritSection);

    if( lTargetRow == m_lCurrentRow ) // already at the right row
        RRETURN( S_OK );

    if( lTargetRow < m_lCurrentRow )
    {
        while( lTargetRow != m_lCurrentRow )
        {
            hr = m_pCRowProvider->SeekToPreviousRow();
            BAIL_ON_FAILURE(hr);

            // m_fEndOfRowset is set to TRUE only if we hit the end of the
            // rowset while moving forward
            m_fEndOfRowset = FALSE;

            if( m_lCurrentRow > 0 )
                m_lCurrentRow--;

            if( S_ADS_NOMORE_ROWS == hr )
                if( m_lCurrentRow != lTargetRow )
                    RRETURN( DB_S_ENDOFROWSET );
        }
    }
    else
    {
        while( lTargetRow != m_lCurrentRow )
        {
            hr = m_pCRowProvider->SeekToNextRow();
            BAIL_ON_FAILURE(hr);

            m_lCurrentRow++;

            if( S_ADS_NOMORE_ROWS == hr )
            {
                // if we were already at the end of the rowset, then reset
                // m_lCurrentRow to its original value
                if( m_fEndOfRowset)
                    m_lCurrentRow--;
                else
                    m_fEndOfRowset = TRUE;

                RRETURN( DB_S_ENDOFROWSET );
            }
        }

        m_fEndOfRowset = FALSE;

    }

    RRETURN( S_OK );

error:

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// SeekToEnd
//
// Moves the IDirectorySearch cursor forward till it hits the end of the
// rowset.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::SeekToEnd(void)
{
    HRESULT hr = S_OK;

    CAutoBlock cab(&m_RowsetCritSection);

    while(1) // till we reach end of rowset
    {
        hr = m_pCRowProvider->SeekToNextRow();

        BAIL_ON_FAILURE(hr);

        m_lCurrentRow++;

        if( S_ADS_NOMORE_ROWS == hr )
        {
            // if we were already at the end of the rowset, then reset
            // m_lCurrentRow to its original value
            if( m_fEndOfRowset)
                m_lCurrentRow--;
            else
                m_fEndOfRowset = TRUE;

            RRETURN( DB_S_ENDOFROWSET );
        }
    }

error:

    RRETURN( hr );
}

//-----------------------------------------------------------------------------
// BringInRow
//
// Brings in the row that we seeked to last. Only one row is brought in.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::BringInRow(void)
{
    HRESULT   hr;
    ROWBUFFER *pRowBuffer = NULL;
    DWORD     cColErrors; // #columns in a row that had an error when retrieved
    int       iCol, iRow;
    HROW      hRow;
    LONG      lIndex;
    DBSTATUS  *pdbStatus;

    CAutoBlock cab(&m_RowsetCritSection);

    // check if the row is already in the cache

    hRow = RowToHROW(m_lCurrentRow);
    lIndex = HROWToIndex(hRow);

    if(lIndex != -1)
    // row is already in cache
    {
        pRowBuffer = m_pRowsPtr[lIndex];
        ADsAssert(pRowBuffer != NULL);

        if( pRowBuffer->cColErrors )
            RRETURN( DB_S_ERRORSOCCURRED );
        else
            RRETURN( S_OK );
    }

    // check if we have room in the cache
    if( (m_dwMaxCacheSize > 0) && ((DWORD)m_cNumRowsCached == m_dwMaxCacheSize) )
        RRETURN( DB_S_ROWLIMITEXCEEDED );

    // Allocate more space in the cache, if we have run out
    if( (DWORD)m_cNumRowsCached == m_dwRowCacheSize ) // no more space for rows
    {
        DWORD     dwTmpSize;
        ROWBUFFER **pTmpRowsPtr;

        dwTmpSize = (0 == m_dwRowCacheSize) ? 1 : (m_dwRowCacheSize*2);

        // make sure we don't overflow the cache
        if( (m_dwMaxCacheSize > 0) && (dwTmpSize > m_dwMaxCacheSize) )
            dwTmpSize = m_dwMaxCacheSize;

        pTmpRowsPtr = (ROWBUFFER **) ReallocADsMem(m_pRowsPtr,
                                      m_dwRowCacheSize*sizeof(ROWBUFFER *),
                                      dwTmpSize*sizeof(ROWBUFFER *));
        if( NULL == pTmpRowsPtr )
            BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );

        m_dwRowCacheSize = dwTmpSize;
        m_pRowsPtr = pTmpRowsPtr;
    }

    // Allocate memory for a new row
    pRowBuffer = (ROWBUFFER *) AllocADsMem(m_cRowBytes);
    if( NULL == pRowBuffer )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );
    // initialize row to 0 (reference count initialized to 0 here)
    memset((char *) pRowBuffer, 0, m_cRowBytes);

    pRowBuffer->lRow = m_lCurrentRow;

    // use row provider to get the next row
    hr = m_pIRowProvider->NextRow();

    BAIL_ON_FAILURE(hr);

    m_lCurrentRow++;

    if( DB_S_ENDOFROWSET == hr )
    {
        if( m_fEndOfRowset )
            m_lCurrentRow--;
        else
            m_fEndOfRowset = TRUE;
        FreeADsMem(pRowBuffer);
        RRETURN( DB_S_ENDOFROWSET );
    }
    else
        m_fEndOfRowset = FALSE;

    cColErrors = 0;

    for(iCol = 1; (DBORDINAL)iCol < m_cCol; iCol++)
    {
        hr = m_pIRowProvider->GetColumn(
            iCol,
            (DBSTATUS *) ( m_pColData[iCol].dwColOffset +
                     FIELD_OFFSET(OLEDBDATA, dbStatus) + (char *)pRowBuffer ),
            (ULONG *) ( m_pColData[iCol].dwColOffset +
                     FIELD_OFFSET(OLEDBDATA, dwLength) + (char *)pRowBuffer ),
            (BYTE *) ( m_pColData[iCol].dwColOffset +
                     FIELD_OFFSET(OLEDBDATA, OledbValue) + (char *)pRowBuffer )
        );

        if( FAILED(hr) )
            cColErrors++;

        // store the ADS_SEARCH_COLUMN if the DS returned any data. Even if
        // GetColumn fails, this has to be done to ensure that the
        // ADS_SEARCH_COLUMN structure is freed later.
        pdbStatus = (DBSTATUS *) ( m_pColData[iCol].dwColOffset +
                    FIELD_OFFSET(OLEDBDATA, dbStatus) + (char *)pRowBuffer );
        if( *pdbStatus != DBSTATUS_S_ISNULL )
            memcpy((void *) ((char *)pRowBuffer + m_pColData[iCol].dwColOffset
                              + FIELD_OFFSET(OLEDBDATA, adsSearchCol)),
                   (void *) (&(m_pCRowProvider->_pdbSearchCol[iCol].adsColumn)),
                   sizeof(ADS_SEARCH_COLUMN) );
    }

    // Copy over the ADsPath search column, if required
    if( FALSE == m_fadsPathPresent )
        memcpy( (void *) (&(pRowBuffer->adsSearchCol)),
                (void *) (&(m_pCRowProvider->_pdbSearchCol[iCol].adsColumn)),
                sizeof(ADS_SEARCH_COLUMN) );

    if( cColErrors == (m_cCol - 1) ) // all columns were in error
    {
        // any failure after this point should do this
        FreeRow(pRowBuffer);
        pRowBuffer = NULL; // so that we don't try to free again later

        BAIL_ON_FAILURE( hr = DB_E_ERRORSOCCURRED );
    }

    // fill in the bookmark column
    *( (DBSTATUS *) (m_pColData[0].dwColOffset +
       FIELD_OFFSET(OLEDBDATA, dbStatus)+(char *)pRowBuffer) ) = DBSTATUS_S_OK;
    *( (ULONG *) (m_pColData[0].dwColOffset +
       FIELD_OFFSET(OLEDBDATA, dwLength)+(char *)pRowBuffer) ) = ADSI_BMK_SIZE;
    // bookmark value is same as row
    *( (ULONG *) (m_pColData[0].dwColOffset +
       FIELD_OFFSET(OLEDBDATA, OledbValue)+(char *)pRowBuffer) ) =
                                                m_lCurrentRow - 1;

    // Store pointer to new row
    m_pRowsPtr[m_cNumRowsCached] = pRowBuffer;

    m_cNumRowsCached++;

    if( cColErrors )
    {
        pRowBuffer->cColErrors = cColErrors;
        RRETURN( DB_S_ERRORSOCCURRED );
    }

    RRETURN( S_OK );

error:
    if( pRowBuffer )
        FreeADsMem(pRowBuffer);

    RRETURN( hr );
}

//----------------------------------------------------------------------------- // GetData
//
// Returns the data from the rowset cache in the format requested by the
// client. This routine performs deferred accessor validation i.e, checks that
// could not be done when the accessor was created due to lack of info. about
// the rowset.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetData(
    HROW      hRow,
    HACCESSOR hAccessor,
    void      *pData
    )
{
    HRESULT         hr;
    LONG            lRowIndex;
    DBACCESSORFLAGS dwAccessorFlags;
    DBCOUNTITEM     cBindings = 0, cErrors = 0;
    DBBINDING       *prgBindings = NULL;
    ROWBUFFER       *pRowBuffer;
    int             iBind;
    ULONG           ulCol;
    ULONG           *pulProvLength;
    DBLENGTH        *pulConsLength;
    DBSTATUS        *pdbConsStatus, *pdbProvStatus;
    void            *pConsValue, *pProvValue;
    OLEDBDATA       *pProvOledbData;

    if( NULL == pData ) // we don't supprt NULL accessor. So, this is an error
        RRETURN( E_INVALIDARG );

    CAutoBlock cab(&m_RowsetCritSection);

    lRowIndex = HROWToIndex(hRow);
    if( (lRowIndex < FIRST_ROW) || (lRowIndex >= m_cNumRowsCached) )
        RRETURN( DB_E_BADROWHANDLE );

    // Get pointer to the specified row
    pRowBuffer = m_pRowsPtr[lRowIndex];
    ADsAssert( pRowBuffer != NULL );
    if( RefCount(pRowBuffer) <= 0 )
        RRETURN( DB_E_BADROWHANDLE );

    ADsAssert( m_pCAccessor );

    hr = m_pCAccessor->GetBindings( // this call validates hAccessor
                hAccessor,
                &dwAccessorFlags,
                &cBindings,
                &prgBindings
                );

    if( FAILED(hr) )
        RRETURN( hr );

    ADsAssert( cBindings ); // NULL accessor is disallowed

    for(iBind = 0; (DBCOUNTITEM)iBind < cBindings; iBind++)
    {
        // Free pObject in the binding, if any
        if( prgBindings[iBind].pObject )
            m_pIMalloc->Free(prgBindings[iBind].pObject);

        // these types are disallowed
        ADsAssert( !((prgBindings[iBind].wType & DBTYPE_VECTOR) ||
                   (prgBindings[iBind].wType & DBTYPE_ARRAY)) );

        // Get pointers to consumer's OLEDB data using the bindings
        if( prgBindings[iBind].dwPart & DBPART_STATUS )
            pdbConsStatus = (DBSTATUS *) ( (char *)pData +
                                          prgBindings[iBind].obStatus );
        else
            pdbConsStatus = NULL;

        if( prgBindings[iBind].dwPart & DBPART_LENGTH )
            pulConsLength = (DBLENGTH *) ( (char *)pData +
                                          prgBindings[iBind].obLength );
        else
            pulConsLength = NULL;

        if( prgBindings[iBind].dwPart & DBPART_VALUE )
            pConsValue = (void *) ( (char *)pData +
                                          prgBindings[iBind].obValue );
        else
            pConsValue = NULL;

        // Check if accessor points to a valid column
        ulCol = prgBindings[iBind].iOrdinal;
        if( ulCol >= m_cCol )
        {
            if( pdbConsStatus )
                *pdbConsStatus = DBSTATUS_E_BADACCESSOR;
            cErrors++;
            continue;
        }

        // Get pointers to providers OLEDB data from the row buffer cache
        pProvOledbData = (OLEDBDATA *) ((char *)pRowBuffer +
                                         m_pColData[ulCol].dwColOffset);
        pdbProvStatus = &(pProvOledbData->dbStatus);
        pulProvLength = &(pProvOledbData->dwLength);
        pProvValue = &(pProvOledbData->OledbValue);

        if( DBMEMOWNER_PROVIDEROWNED == prgBindings[iBind].dwMemOwner )
        {
            if( pdbConsStatus )
                *pdbConsStatus = *pdbProvStatus;
            if( pulConsLength )
                *pulConsLength = *pulProvLength;

            if( prgBindings[iBind].wType & DBTYPE_BYREF )
            {
                // If a binding specifies provider owned memory, and specifies
                // type X | BYREF, and the provider's copy is not X or
                // X | BYREF, return error
                if( (prgBindings[iBind].wType & (~DBTYPE_BYREF)) !=
                        (m_pColData[ulCol].wType & (~DBTYPE_BYREF)) )
                {
                    if( pdbConsStatus )
                        *pdbConsStatus = DBSTATUS_E_BADACCESSOR;
                    cErrors++;
                    continue;
                }

                if( m_pColData[ulCol].wType & DBTYPE_BYREF )
                // provider's type exactly matches consumer's type
                {
                    if( pConsValue )
                        *(void **) pConsValue = *(void **) pProvValue;
                }
                else
                // provider actually has the data, not a pointer to the data
                {
                    if( pConsValue )
                        *(void **) pConsValue = pProvValue;
                }
            }
            else if( DBTYPE_BSTR == prgBindings[iBind].wType )
            {
                if( DBTYPE_BSTR != m_pColData[ulCol].wType )
                {
                    if( pdbConsStatus )
                        *pdbConsStatus = DBSTATUS_E_BADACCESSOR;
                    cErrors++;
                    continue;
                }

                if( pConsValue )
                    *(void **) pConsValue = *(void **) pProvValue;
            }
            else // we should never get here
                ADsAssert( FALSE );
        }
        else // binding specified client-owned memory
        {
            // workaround for bug in IDataConvert. Variant to Variant
            // conversions may not always work (depending on the type in the
            // variant). So, handle that case separately.

            DBTYPE dbSrcType, dbDstType;

            dbSrcType = m_pColData[ulCol].wType & (~DBTYPE_BYREF);
            dbDstType = prgBindings[iBind].wType & (~DBTYPE_BYREF);

            if( (DBTYPE_VARIANT == dbSrcType) &&
                (DBTYPE_VARIANT == dbDstType) )
            {
                PVARIANT pSrcVariant, pDstVariant = NULL;

                if( (*pdbProvStatus != DBSTATUS_S_OK) &&
                    (*pdbProvStatus != DBSTATUS_S_ISNULL) )
                // provider wasn't able to get value from DS. Return bad
                // status to consumer
                {
                    if( pdbConsStatus )
                        *pdbConsStatus = *pdbProvStatus;
                    if( pulConsLength )
                        *pulConsLength = 0;
                    // value will not be set

                    cErrors++;
                    continue; // to next binding
                }

                if( m_pColData[ulCol].wType & DBTYPE_BYREF )
                    pSrcVariant = *(PVARIANT *)pProvValue;
                else
                    pSrcVariant = (PVARIANT)pProvValue;

                if( (prgBindings[iBind].wType & DBTYPE_BYREF) && pConsValue )
                {
                    pDstVariant = (PVARIANT)m_pIMalloc->Alloc(sizeof(VARIANT));
                    if( NULL == pDstVariant )
                        hr = E_OUTOFMEMORY;
                }
                else
                    pDstVariant = (PVARIANT)pConsValue;

                if( pdbConsStatus )
                   *pdbConsStatus = *pdbProvStatus;
                if( pulConsLength )
                   *pulConsLength = *pulProvLength;

                if( pDstVariant )
                {
                    VariantInit(pDstVariant);

                    if( DBSTATUS_S_ISNULL == *pdbProvStatus )
                    // provider couldn't get this column from DS (probably
                    // because there was no attribute with this name)
                    {
                        if( prgBindings[iBind].wType & DBTYPE_BYREF )
                        // don't allocate anything if returning NULL status
                            m_pIMalloc->Free(pDstVariant);
                        else
                            V_VT(pDstVariant) = VT_EMPTY;

                        hr = S_OK;
                    }
                    else
                    {
                        hr = VariantCopy(pDstVariant, pSrcVariant);
                        if( SUCCEEDED(hr) )
                        {
                            if( pConsValue &&
                                (prgBindings[iBind].wType & DBTYPE_BYREF) )
                                *(void **) pConsValue = pDstVariant;
                        }
                        else if( prgBindings[iBind].wType & DBTYPE_BYREF )
                            m_pIMalloc->Free(pDstVariant);
                    } // else
                } // if( pDstvariant)
            } // if( DBTYPE_VARIANT == ...)
            else
            {
                DBLENGTH dbTmpLen = 0;

                hr = m_pIDataConvert->DataConvert(
                    m_pColData[ulCol].wType,
                    prgBindings[iBind].wType,
                    *pulProvLength,
                    &dbTmpLen,
                    pProvValue,
                    pConsValue,
                    prgBindings[iBind].cbMaxLen,
                    *pdbProvStatus,
                    pdbConsStatus,
                    prgBindings[iBind].bPrecision,
                    prgBindings[iBind].bScale,
                    DBDATACONVERT_DEFAULT
                    );
                if( pulConsLength )
                    *pulConsLength = dbTmpLen;

                // if the binding specified DBTYPE_VARIANT | DBTYPE_BYREF, then
                // IDataConvert does not allocate a VT_NULL variant. Instead it
                // returns nothing in pConsValue. If it is not BYREF, then
                // return VT_EMPTY instead of VT_NULL.
                if( SUCCEEDED(hr) && (DBSTATUS_S_ISNULL == *pdbProvStatus) &&
                    (prgBindings[iBind].wType == DBTYPE_VARIANT) &&
                     pConsValue )
                {
                    PVARIANT pVariant;

                    pVariant = (PVARIANT)pConsValue;

                    V_VT(pVariant) = VT_EMPTY;
                }

            }

            if( FAILED(hr) )
            {
                if( pdbConsStatus )
                    *pdbConsStatus = DBSTATUS_E_CANTCONVERTVALUE;
                cErrors++;
                continue;
            }
        } // client-owned memory
    }

    m_pIMalloc->Free(prgBindings);

    if( cErrors )
        if( cErrors != cBindings ) // not all columns had error
            RRETURN( DB_S_ERRORSOCCURRED );
        else
            RRETURN( DB_E_ERRORSOCCURRED );
    else
        RRETURN( S_OK );
}

//-----------------------------------------------------------------------------
// AddRefRows
//
// Increments reference count of specified rows
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::AddRefRows(
    DBCOUNTITEM  cRows,
    const HROW   rghRows[],
    ULONG        rgRefCounts[],
    DBROWSTATUS  rgRowStatus[]
    )
{
    int       iRow;
    LONG      lRowIndex;
    ROWBUFFER *pRowBuffer;
    DBCOUNTITEM cErrors = 0;

    if( (NULL == rghRows) && (cRows != 0) )
        RRETURN( E_INVALIDARG );

    CAutoBlock cab(&m_RowsetCritSection);

    for(iRow = 0; (DBCOUNTITEM)iRow < cRows; iRow++)
    {
        lRowIndex = HROWToIndex(rghRows[iRow]);
        if( (lRowIndex < 0) || (lRowIndex >= m_cNumRowsCached) )
        {
            if( rgRowStatus )
                rgRowStatus[iRow] = DBROWSTATUS_E_INVALID;
            if( rgRefCounts )
                rgRefCounts[iRow] = 0;
            cErrors++;
            continue;
        }

        // Get pointer to the specified row
        pRowBuffer = m_pRowsPtr[lRowIndex];
        ADsAssert( pRowBuffer != NULL );
        if( RefCount(pRowBuffer) <= 0 )
        {
            if( rgRowStatus )
                rgRowStatus[iRow] = DBROWSTATUS_E_INVALID;
            if( rgRefCounts )
                rgRefCounts[iRow] = 0;
            cErrors++;
            continue;
        }

        IncrRefCount(pRowBuffer);

        if( rgRefCounts )
            rgRefCounts[iRow] = RefCount(pRowBuffer);
        if( rgRowStatus )
            rgRowStatus[iRow] = DBROWSTATUS_S_OK;
    }

    if( cErrors )
        if( cErrors == cRows )
            RRETURN( DB_E_ERRORSOCCURRED );
        else
            RRETURN( DB_S_ERRORSOCCURRED );

    RRETURN( S_OK );
}

//----------------------------------------------------------------------------
// ReleaseRows
//
// Decrements reference count of specified rows. The rows are not freed even
// if the reference count goes down to 0.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowset::ReleaseRows(
    DBCOUNTITEM  cRows,
    const HROW   rghRows[],
    DBROWOPTIONS rgRowOptions[], // ignored
    ULONG        rgRefCounts[],
    DBROWSTATUS  rgRowStatus[]
    )
{
    int       iRow;
    LONG      lRowIndex;
    ROWBUFFER *pRowBuffer;
    DBCOUNTITEM cErrors = 0;

    if( (NULL == rghRows) && (cRows != 0) )
        RRETURN( E_INVALIDARG );

    CAutoBlock cab(&m_RowsetCritSection);

    for(iRow = 0; (DBCOUNTITEM)iRow < cRows; iRow++)
    {
        lRowIndex = HROWToIndex(rghRows[iRow]);
        if( (lRowIndex < 0) || (lRowIndex >= m_cNumRowsCached) )
        {
            if( rgRowStatus )
                rgRowStatus[iRow] = DBROWSTATUS_E_INVALID;
            if( rgRefCounts )
                rgRefCounts[iRow] = 0;
            cErrors++;
            continue;
        }

        // Get pointer to the specified row
        pRowBuffer = m_pRowsPtr[lRowIndex];
        ADsAssert( pRowBuffer != NULL );
        if( RefCount(pRowBuffer) <= 0 )
        {
            if( rgRowStatus )
                rgRowStatus[iRow] = DBROWSTATUS_E_INVALID;
            if( rgRefCounts )
                rgRefCounts[iRow] = 0;
            cErrors++;
            continue;
        }

        DecrRefCount(pRowBuffer);

        if( rgRefCounts )
            rgRefCounts[iRow] = RefCount(pRowBuffer);
        if( rgRowStatus )
            rgRowStatus[iRow] = DBROWSTATUS_S_OK;

        // Free the row's memory
        if( 0 == RefCount(pRowBuffer) )
        {
            int i;

            FreeRow(pRowBuffer);
            m_cNumRowsCached--;

            // compact the cache
            for(i = lRowIndex; i < m_cNumRowsCached; i++)
                m_pRowsPtr[i] = m_pRowsPtr[i+1];
        }
    }

    if( cErrors )
        if( cErrors == cRows )
            RRETURN( DB_E_ERRORSOCCURRED );
        else
            RRETURN( DB_S_ERRORSOCCURRED );

    RRETURN( S_OK );
}

//----------------------------------------------------------------------------
// RestartPosition
//
// Repositions the next fetch poition to the initial position
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowset::RestartPosition(
    HCHAPTER hChapter // ignored
    )
{
    CAutoBlock cab(&m_RowsetCritSection);

    m_lLastFetchRow = RESET_ROW;

    RRETURN( S_OK );
}

//----------------------------------------------------------------------------
// FreeRow
//
// Frees the memory used by a row in the rowset cache. Also frees the ADsColumn
// structures contained within the row.
//
//----------------------------------------------------------------------------
void
CRowset::FreeRow(
    ROWBUFFER *pRowBuffer
    )
{
    int               iCol;
    ADS_SEARCH_COLUMN *pADsCol;
    DBSTATUS          *pdbStatus;
    PVARIANT          pVariant;

    CAutoBlock cab(&m_RowsetCritSection);

    // start with column 1. Bookmark column is ignored.
    for(iCol = 1; (DBORDINAL)iCol < m_cCol; iCol++)
    {
        pADsCol = (ADS_SEARCH_COLUMN *) ((char *)pRowBuffer +
                       m_pColData[iCol].dwColOffset +
                       FIELD_OFFSET(OLEDBDATA, adsSearchCol));
        pdbStatus = (DBSTATUS *) ( m_pColData[iCol].dwColOffset +
                       FIELD_OFFSET(OLEDBDATA, dbStatus) +
                       (char *)pRowBuffer );

        if( *pdbStatus != DBSTATUS_S_ISNULL )
        {
            if( (DBSTATUS_S_OK == *pdbStatus) &&
                ((m_pColData[iCol].wType & (~DBTYPE_BYREF)) == DBTYPE_VARIANT) )
            // variant (or variant array) needs to be freed
            {
                pVariant = *(PVARIANT *) ( (m_pColData[iCol].dwColOffset +
                               FIELD_OFFSET(OLEDBDATA, OledbValue) +
                               (char *)pRowBuffer) );

                if( V_VT(pVariant) & VT_ARRAY )
                    SafeArrayDestroy(V_ARRAY(pVariant));
                else
                    VariantClear(pVariant);

                FreeADsMem(pVariant);
            }

            // ignore error return
            m_pCRowProvider->_pDSSearch->FreeColumn(pADsCol);
        }
    }

    if( FALSE == m_fadsPathPresent )
        // ignore error return
        m_pCRowProvider->_pDSSearch->FreeColumn(&(pRowBuffer->adsSearchCol));

    FreeADsMem(pRowBuffer);

    return;
}

//-----------------------------------------------------------------------------
// GetADsPathFromHROW
//
// Gets the ADsPath corresponding to a HROW. This function is called by
// GetURLFromHROW, only if m_fadsPathPresent is FALSE.
//
//-----------------------------------------------------------------------------
HRESULT
CRowset::GetADsPathFromHROW(
    HROW hRow,
    ADS_CASE_IGNORE_STRING *padsPath
    )
{
    LONG      lRowIndex;
    ROWBUFFER *pRowBuffer;

    ADsAssert(FALSE == m_fadsPathPresent);

    CAutoBlock cab(&m_RowsetCritSection);

    lRowIndex = HROWToIndex(hRow);
    if( (lRowIndex < 0) || (lRowIndex >= m_cNumRowsCached) )
        RRETURN(E_HANDLE);

    // Get pointer to the specified row
    pRowBuffer = m_pRowsPtr[lRowIndex];
    ADsAssert( pRowBuffer != NULL );
    if( RefCount(pRowBuffer) <= 0 )
        RRETURN(E_HANDLE);

    if( NULL == padsPath )
        RRETURN(E_INVALIDARG);
    *padsPath =
        pRowBuffer->adsSearchCol.pADsValues[0].CaseIgnoreString;

    RRETURN( S_OK );
}

//-----------------------------------------------------------------------------
// IUnknown methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CRowset::QueryInterface(
    THIS_ REFIID riid,
    LPVOID FAR* ppvObj
    )
{
    if( NULL == ppvObj )
        RRETURN( E_INVALIDARG );

    *ppvObj = NULL;

    if( IsEqualIID(riid, IID_IUnknown) )
        *ppvObj = (IUnknown FAR *) ((IAccessor *) this);
    else if( IsEqualIID(riid, IID_IAccessor) )
        *ppvObj = (IAccessor FAR *) this;
    else if( IsEqualIID(riid, IID_IColumnsInfo) )
        *ppvObj = (IColumnsInfo FAR *) this;
    else if( IsEqualIID(riid, IID_IConvertType) )
        *ppvObj = (IConvertType FAR *) this;
#if (!defined(BUILD_FOR_NT40))
    else if( IsEqualIID(riid, IID_IGetRow) )
        *ppvObj = (IGetRow FAR *) this;
#endif
    else if( IsEqualIID(riid, IID_IRowset) )
        *ppvObj = (IRowset FAR *) this;
    else if( IsEqualIID(riid, IID_IRowsetIdentity) )
        *ppvObj = (IRowsetIdentity FAR *) this;
    else if( IsEqualIID(riid, IID_IRowsetInfo) )
        *ppvObj = (IRowsetInfo FAR *) this;
    else if( IsEqualIID(riid, IID_IRowsetLocate) )
        *ppvObj = (IRowsetLocate FAR *) this;
    else if( IsEqualIID(riid, IID_IRowsetScroll) )
        *ppvObj = (IRowsetScroll FAR *) this;
    else
         RRETURN( E_NOINTERFACE );

    AddRef();
    RRETURN( S_OK );
}

//-----------------------------------------------------------------------------
// AddRef
//
// Increments reference count of this object
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRowset::AddRef(
    void
    )
{
    CAutoBlock cab(&m_RowsetCritSection);

    ADsAssert(((LONG)m_cRef) >= 0);

    return ++m_cRef;
}

//-----------------------------------------------------------------------------
// Release
//
// Decrements reference count of this object
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CRowset::Release(
    void
    )
{
    CAutoBlock cab(&m_RowsetCritSection);

    ADsAssert(m_cRef > 0);

    m_cRef--;

    if( 0 == m_cRef )
    {
        cab.UnBlock();
        delete this;

        return 0;
    }

    return m_cRef;
}

//-----------------------------------------------------------------------------
// IAccessor methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::AddRefAccessor(
    HACCESSOR  hAccessor,
    DBREFCOUNT *pcRefCount
    )
{
    ADsAssert(m_pCAccessor);

    RRETURN( m_pCAccessor->AddRefAccessor(hAccessor, pcRefCount) );
}

STDMETHODIMP
CRowset::CreateAccessor(
    DBACCESSORFLAGS dwAccessorFlags,
    DBCOUNTITEM     cBindings,
    const DBBINDING rgBindings[],
    DBLENGTH        cbRowSize,
    HACCESSOR *     phAccessor,
    DBBINDSTATUS    rgStatus[]
    )
{
    ADsAssert(m_pCAccessor);

    RRETURN(m_pCAccessor->CreateAccessor(
                    dwAccessorFlags,
                    cBindings,
                    rgBindings,
                    cbRowSize,
                    phAccessor,
                    rgStatus)
                    );
}

STDMETHODIMP
CRowset::ReleaseAccessor(
     HACCESSOR  hAccessor,
     DBREFCOUNT *pcRefCount
     )
{
    ADsAssert(m_pCAccessor);

    RRETURN( m_pCAccessor->ReleaseAccessor(
                    hAccessor,
                    pcRefCount)
                    );
}

STDMETHODIMP
CRowset::GetBindings(
    HACCESSOR         hAccessor,
    DBACCESSORFLAGS * pdwAccessorFlags,
    DBCOUNTITEM *     pcBindings,
    DBBINDING **      prgBindings
    )
{
    ADsAssert(m_pCAccessor);

    RRETURN( m_pCAccessor->GetBindings(
                    hAccessor,
                    pdwAccessorFlags,
                    pcBindings,
                    prgBindings)
                    );
}

//-----------------------------------------------------------------------------
// IColumnsInfo methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetColumnInfo(
    DBORDINAL       *pcColumns,
    DBCOLUMNINFO    **pprgInfo,
    WCHAR **        ppStringBuffer
    )
{
    ADsAssert(m_pIColumnsInfo);

    RRETURN( m_pIColumnsInfo->GetColumnInfo(
                    pcColumns,
                    pprgInfo,
                    ppStringBuffer)
                    );
}

STDMETHODIMP
CRowset::MapColumnIDs(
    DBORDINAL  cColumnIDs,
    const DBID rgColumnIDs[],
    DBORDINAL  rgColumns[]
    )
{
    ADsAssert(m_pIColumnsInfo);

    RRETURN( m_pIColumnsInfo->MapColumnIDs(
                    cColumnIDs,
                    rgColumnIDs,
                    rgColumns)
                    );
}

//-----------------------------------------------------------------------------
// IConvertType methods (mandatory for IRowset)
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::CanConvert(
    DBTYPE         wFromType,
    DBTYPE         wToType,
    DBCONVERTFLAGS dwConvertFlags
    )
{
    HRESULT hr;

    if( dwConvertFlags & DBCONVERTFLAGS_PARAMETER ) // not allowed on rowset
        RRETURN( DB_E_BADCONVERTFLAG );

    if( (dwConvertFlags & (~(DBCONVERTFLAGS_ISLONG |
                            DBCONVERTFLAGS_ISFIXEDLENGTH |
                            DBCONVERTFLAGS_FROMVARIANT))) !=
                            DBCONVERTFLAGS_COLUMN )
        RRETURN( DB_E_BADCONVERTFLAG );

    if( dwConvertFlags & DBCONVERTFLAGS_ISLONG )
    {
        DBTYPE wType;

        wType = wFromType & (~(DBTYPE_BYREF | DBTYPE_ARRAY | DBTYPE_VECTOR));

        // wType has to be variable-length DBTYPE
        if( (wType != DBTYPE_STR) && (wType != DBTYPE_WSTR) &&
            (wType != DBTYPE_BYTES) && (wType != DBTYPE_VARNUMERIC) )
            RRETURN( DB_E_BADCONVERTFLAG );
    }

    // CreateAccessor returns error for ARRAY and VECTOR types. So we cannot
    // convert to these types.
    if( (wToType & DBTYPE_ARRAY) || (wToType & DBTYPE_VECTOR) )
        RRETURN( S_FALSE );

    if( dwConvertFlags & DBCONVERTFLAGS_FROMVARIANT )
    {
        DBTYPE dbTmpType, wVtType;

        wVtType = wFromType & VT_TYPEMASK;

        // Take out all of the Valid VT_TYPES (36 is VT_RECORD in VC 6)
        if( (wVtType > VT_DECIMAL && wVtType < VT_I1) ||
            ((wVtType > VT_LPWSTR && wVtType < VT_FILETIME) && wVtType !=36) ||
            (wVtType > VT_CLSID) )
            RRETURN( DB_E_BADTYPE );

        dbTmpType = wToType & (~DBTYPE_BYREF);
        if( DBTYPE_VARIANT == dbTmpType )
        // GetData will do the right thing, so return TRUE.
            RRETURN( S_OK );
    }

    // GetData handles VARIANT to VARIANT conversions, so special check here
    if( (DBTYPE_VARIANT == (wFromType & (~DBTYPE_BYREF))) &&
        (DBTYPE_VARIANT == (wToType & (~DBTYPE_BYREF))) )
        RRETURN( S_OK );

    ADsAssert( m_pIDataConvert != NULL );

    hr = m_pIDataConvert->CanConvert(wFromType, wToType);

    RRETURN( (E_INVALIDARG == hr)? S_FALSE : hr );
}

//-----------------------------------------------------------------------------
// IGetRow methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetRowFromHROW(
    IUnknown  *pUnkOuter,
    HROW      hRow,
    REFIID    riid,
    IUnknown  **ppUnk
    )
{
    ADsAssert(m_pCRowsetInfo);

    RRETURN( m_pCRowsetInfo->GetRowFromHROW(
                     pUnkOuter,
                     hRow,
                     riid,
                     ppUnk,
                     TRUE, // this ia tear-off row
                     m_fAllAttrs)
                     );
}

STDMETHODIMP
CRowset::GetURLFromHROW(
    HROW     hRow,
    LPOLESTR *ppwszURL
    )
{
    ADsAssert(m_pCRowsetInfo);

    RRETURN( m_pCRowsetInfo->GetURLFromHROW(hRow, ppwszURL) );
}

//-----------------------------------------------------------------------------
// IRowsetIdentity methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::IsSameRow(
    HROW hRow1,
    HROW hRow2
    )
{
    LONG      lIndex1, lIndex2;
    ROWBUFFER *pRowBuffer1, *pRowBuffer2;

    lIndex1 = HROWToIndex(hRow1);
    lIndex2 = HROWToIndex(hRow2);

    if( (lIndex1 < 0) || (lIndex1 >= m_cNumRowsCached) ||
        (lIndex2 < 0) || (lIndex2 >= m_cNumRowsCached) )
        RRETURN( DB_E_BADROWHANDLE );

    // Get pointer to the specified row
    pRowBuffer1 = m_pRowsPtr[lIndex1];
    pRowBuffer2 = m_pRowsPtr[lIndex2];
    ADsAssert( (pRowBuffer1 != NULL) && (pRowBuffer2 != NULL) );
    if( (RefCount(pRowBuffer1) <= 0) || (RefCount(pRowBuffer2) <= 0) )
        RRETURN( DB_E_BADROWHANDLE );

    if( lIndex1 == lIndex2 )
        RRETURN( S_OK );
    else
        RRETURN( S_FALSE );
}

//-----------------------------------------------------------------------------
// IRowsetInfo methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetProperties(
    const ULONG       cPropertyIDSets,
    const DBPROPIDSET rgPropertyIDSets[],
    ULONG             *pcPropertySets,
    DBPROPSET         **pprgPropertySets
    )
{
    ADsAssert( m_pCUtilProp );

    // Check arguments for error
    HRESULT hr = m_pCUtilProp->GetPropertiesArgChk(
                            cPropertyIDSets,
                            rgPropertyIDSets,
                            pcPropertySets,
                            pprgPropertySets,
                            PROPSET_COMMAND);

    if( FAILED(hr) )
        RRETURN( hr );

    RRETURN( m_pCUtilProp->GetProperties(
                            cPropertyIDSets,
                            rgPropertyIDSets,
                            pcPropertySets,
                            pprgPropertySets,
                            PROPSET_COMMAND) );
}

STDMETHODIMP
CRowset::GetReferencedRowset(
    DBORDINAL   iOrdinal,
    REFIID      riid,
    IUnknown    **ppReferencedRowset
    )
{
    ADsAssert(m_pCRowsetInfo);

    RRETURN( m_pCRowsetInfo->GetReferencedRowset(
                iOrdinal,
                riid,
                ppReferencedRowset)
                );
}

STDMETHODIMP
CRowset::GetSpecification(
    REFIID      riid,
    IUnknown    **ppSpecification
    )
{
    ADsAssert(m_pCRowsetInfo);

    RRETURN( m_pCRowsetInfo->GetSpecification(
                riid,
                ppSpecification)
                );
}

//----------------------------------------------------------------------------- // IRowsetLocate methods
//-----------------------------------------------------------------------------
STDMETHODIMP
CRowset::Compare(
    HCHAPTER   hChapter,
    DBBKMARK   cbBookmark1,
    const BYTE *pBookmark1,
    DBBKMARK   cbBookmark2,
    const BYTE *pBookmark2,
    DBCOMPARE  *pComparison
    )
{
    if( (0 == cbBookmark1) || (0 == cbBookmark2) || (NULL == pComparison) ||
        (NULL == pBookmark1) || (NULL == pBookmark2) )
        RRETURN( E_INVALIDARG );

    if( STD_BMK_SIZE == cbBookmark1 )
    {
        if( (*pBookmark1 != DBBMK_FIRST) && (*pBookmark1 != DBBMK_LAST) )
            RRETURN( DB_E_BADBOOKMARK );
    }
    else
        if( ADSI_BMK_SIZE != cbBookmark1 )
            RRETURN( DB_E_BADBOOKMARK );

    if( STD_BMK_SIZE == cbBookmark2 )
    {
        if( (*pBookmark2 != DBBMK_FIRST) && (*pBookmark2 != DBBMK_LAST) )
            RRETURN( DB_E_BADBOOKMARK );
    }
    else
        if( ADSI_BMK_SIZE != cbBookmark2 )
            RRETURN( DB_E_BADBOOKMARK );

    if( (STD_BMK_SIZE == cbBookmark1) || (STD_BMK_SIZE == cbBookmark2) )
    // standard bookmarks can only be compared for equality (not for <, >)
    {
        if( cbBookmark1 != cbBookmark2 )
            *pComparison = DBCOMPARE_NE;
        else if( *pBookmark1 == *pBookmark2 )
            *pComparison = DBCOMPARE_EQ;
        else
            *pComparison = DBCOMPARE_NE;
    }
    else
    {
        if( (*((RBOOKMARK *)pBookmark1)) <  (*((RBOOKMARK *)pBookmark2)) )
            *pComparison = DBCOMPARE_LT;
        else if( (*((RBOOKMARK *)pBookmark1)) >  (*((RBOOKMARK *)pBookmark2)) )
            *pComparison = DBCOMPARE_GT;
        else
            *pComparison = DBCOMPARE_EQ;
    }

    RRETURN( S_OK );
}

STDMETHODIMP
CRowset::Hash(
    HCHAPTER        hChapter,
    DBBKMARK        cBookmarks,
    const DBBKMARK  rgcbBookmarks[],
    const BYTE      *rgpBookmarks[],
    DBHASHVALUE     rgHashedValues[],
    DBROWSTATUS     rgBookmarkStatus[]
    )
{
    int  i;
    HRESULT hr;
    DBBKMARK cErrors = 0;

    if( (NULL == rgHashedValues) || ((cBookmarks != 0) &&
                  ((NULL == rgpBookmarks) || (NULL == rgcbBookmarks))) )
        RRETURN( E_INVALIDARG );

    if( 0 == cBookmarks )
        RRETURN( S_OK );

    for(i = 0; (DBBKMARK)i < cBookmarks; i++)
    {
        if( (rgcbBookmarks[i] != ADSI_BMK_SIZE) || (NULL == rgpBookmarks[i]) )
        {
            cErrors++;
            if( rgBookmarkStatus )
                rgBookmarkStatus[i] = DBROWSTATUS_E_INVALID;
        }
        else
        {
            LONG lRow;

            hr = BmkToRow(rgcbBookmarks[i], rgpBookmarks[i], &lRow);
            if( FAILED(hr) )
            {
                cErrors++;
                if( rgBookmarkStatus )
                    rgBookmarkStatus[i] = DBROWSTATUS_E_INVALID;

                continue;
            }

            rgHashedValues[i] = (DWORD) lRow;
            if( rgBookmarkStatus )
                rgBookmarkStatus[i] = DBROWSTATUS_S_OK;
        }
    }

    if( cErrors )
    {
        if( cErrors == cBookmarks )
            RRETURN( DB_E_ERRORSOCCURRED );
        else
            RRETURN( DB_S_ERRORSOCCURRED );
    }
    else
        RRETURN( S_OK );
}

STDMETHODIMP
CRowset::GetRowsByBookmark(
    HCHAPTER       hChapter,
    DBCOUNTITEM    cRows,
    const DBBKMARK rgcbBookmarks[],
    const BYTE     *rgpBookmarks[],
    HROW           rghRows[],
    DBROWSTATUS    rgRowStatus[]
    )
{
    int           i;
    HRESULT       hr;
    DBCOUNTITEM   cRowsObtained = 0, cErrors = 0;

    if( (NULL == rghRows) || (NULL == rgcbBookmarks) || (NULL== rgpBookmarks) )
        RRETURN( E_INVALIDARG );

    if( 0 == cRows )
        RRETURN( S_OK );

    for(i = 0; (DBCOUNTITEM)i < cRows; i++)
    {
        if( (rgcbBookmarks[i] != ADSI_BMK_SIZE) || (NULL == rgpBookmarks[i]) )
        {
            cErrors++;
            if( rgRowStatus )
                rgRowStatus[i] = DBROWSTATUS_E_INVALID;
            rghRows[i] = DB_NULL_HROW;
        }
        else
        {
            HROW *phRow;

            phRow = &rghRows[i];
            hr = GetRowsAt(NULL, hChapter, rgcbBookmarks[i],
                           (BYTE *) rgpBookmarks[i], 0, 1, &cRowsObtained,
                           &phRow
                          );
            if( 1 == cRowsObtained )
            {
                if( rgRowStatus )
                    rgRowStatus[i] = DBROWSTATUS_S_OK;
            }
            else
            {
                cErrors++;
                rghRows[i] = DB_NULL_HROW;
                if( rgRowStatus )
                {
                    if( DB_S_ROWLIMITEXCEEDED == hr )
                        rgRowStatus[i] = DBROWSTATUS_E_LIMITREACHED;
                    else if ( E_OUTOFMEMORY == hr )
                        rgRowStatus[i] = DBROWSTATUS_E_OUTOFMEMORY;
                    else
                       rgRowStatus[i] = DBROWSTATUS_E_INVALID;
                 }
             } // else
        } // else
    } // for

    if( cErrors )
    {
        if( cErrors == cRows )
            RRETURN( DB_E_ERRORSOCCURRED );
        else
            RRETURN( DB_S_ERRORSOCCURRED );
    }
    else
        RRETURN( S_OK );
}

//----------------------------------------------------------------------------
// IRowsetScroll methods
//----------------------------------------------------------------------------
STDMETHODIMP
CRowset::GetApproximatePosition(
    HCHAPTER      hChapter,
    DBBKMARK      cbBookmark,
    const BYTE    *pBookmark,
    DBCOUNTITEM   *pulPosition,
    DBCOUNTITEM   *pcRows
    )
{
    LONG    cRows = 0;
    HRESULT hr;

    if( (cbBookmark != 0) && ( NULL == pBookmark) )
        RRETURN( E_INVALIDARG );

    CAutoBlock cab(&m_RowsetCritSection);

    if( pcRows )
    // get the total number of rows in the rowset
    {
        hr = SeekToEnd();
        if( FAILED(hr) )
            RRETURN( E_FAIL );

        cRows = m_lCurrentRow - 1;
    }

    if( 0 == cbBookmark )
    {
        if( pcRows )
            *pcRows = cRows;
        RRETURN( S_OK );
    }
    else if( (cbBookmark != ADSI_BMK_SIZE) && (cbBookmark != STD_BMK_SIZE) )
        RRETURN( DB_E_BADBOOKMARK );
    else
    {
        LONG lRow;

        hr = BmkToRow(cbBookmark, pBookmark, &lRow);
        if( FAILED(hr) )
        {
            if( DB_E_BADBOOKMARK == hr )
                RRETURN( DB_E_BADBOOKMARK );
            else
                RRETURN( E_FAIL );
        }

        if( pulPosition )
        {
            *pulPosition = lRow + 1;   // this number is 1-based
            if( pcRows && (*pulPosition > (DBCOUNTITEM)cRows) ) // bookmark was bad
                *pulPosition = cRows;  // make sure *pulPosition <= *pcRows
        }

        if( pcRows )
            *pcRows = cRows;
    }

    RRETURN( S_OK );
}

STDMETHODIMP
CRowset::GetRowsAtRatio(
    HWATCHREGION hReserved1,
    HCHAPTER     hChapter,
    DBCOUNTITEM  ulNumerator,
    DBCOUNTITEM  ulDenominator,
    DBROWCOUNT   cRows,
    DBCOUNTITEM  *pcRowsObtained,
    HROW         **prghRows
    )
{
    HRESULT   hr;
    LONG      lStartRow, cTotalRows;
    RBOOKMARK StartRowBmk;

    if( (NULL == pcRowsObtained) || (NULL == prghRows) )
    {
        if( pcRowsObtained != NULL )
            *pcRowsObtained = 0;
        RRETURN( E_INVALIDARG );
    }

    *pcRowsObtained = 0;

    if( (ulNumerator > ulDenominator) || (0 == ulDenominator) )
        RRETURN( DB_E_BADRATIO );

    if( ((ulNumerator == ulDenominator) && (cRows > 0)) ||
        ((0 == ulNumerator) && (cRows < 0)) )
        RRETURN( DB_S_ENDOFROWSET );

    if( 0 == cRows )
        RRETURN( S_OK );

    CAutoBlock cab(&m_RowsetCritSection);

    // get total number of rows
    hr = SeekToEnd();
    if( FAILED(hr) )
        RRETURN( E_FAIL );

    cTotalRows = m_lCurrentRow - 1;

    // Make sure ratio of 1 sets lStartRow to cTotalRows -1 (last row)
    lStartRow = (long)((((double) ulNumerator)/ulDenominator) *
                                                        (cTotalRows - 1));
    StartRowBmk = RowToBmk(lStartRow);

    hr = GetRowsAt(NULL, hChapter, ADSI_BMK_SIZE, (BYTE *) &StartRowBmk,
                         0, cRows, pcRowsObtained, prghRows);

    RRETURN( hr );
}

//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\csedcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsSecurityDescriptorCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsSecurityDescriptorCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CSecurityDescriptor::CreateSecurityDescriptor(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\csed.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cSecurityDescriptor.cxx
//
//  Contents:  SecurityDescriptor object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop

//  Class CSecurityDescriptor

DEFINE_IDispatch_Implementation(CSecurityDescriptor)

CSecurityDescriptor::CSecurityDescriptor():
        _pDispMgr(NULL),
        _lpOwner(NULL),
        _fOwnerDefaulted(FALSE),
        _lpGroup(NULL),
        _fGroupDefaulted(FALSE),
        _dwRevision(0),
        _dwControl(0),
        _pDAcl(NULL),
        _fDaclDefaulted(FALSE),
        _pSAcl(NULL),
        _fSaclDefaulted(FALSE)
{
    ENLIST_TRACKING(CSecurityDescriptor);
}


HRESULT
CSecurityDescriptor::CreateSecurityDescriptor(
    REFIID riid,
    void **ppvObj
    )
{
    CSecurityDescriptor FAR * pSecurityDescriptor = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSecurityDescriptorObject(&pSecurityDescriptor);
    BAIL_ON_FAILURE(hr);

    hr = pSecurityDescriptor->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pSecurityDescriptor->Release();

    RRETURN(hr);

error:
    delete pSecurityDescriptor;

    RRETURN_EXP_IF_ERR(hr);

}


CSecurityDescriptor::~CSecurityDescriptor( )
{
    delete _pDispMgr;

    if (_pDAcl) {
        _pDAcl->Release();
    }

    if (_pSAcl) {
        _pSAcl->Release();
    }

    if (_lpOwner) {
        FreeADsStr(_lpOwner);
    }

    if (_lpGroup) {
        FreeADsStr(_lpGroup);
    }
}

STDMETHODIMP
CSecurityDescriptor::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsSecurityDescriptor FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSecurityDescriptor))
    {
        *ppv = (IADsSecurityDescriptor FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsSecurityDescriptor FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CSecurityDescriptor::AllocateSecurityDescriptorObject(
    CSecurityDescriptor ** ppSecurityDescriptor
    )
{
    CSecurityDescriptor FAR * pSecurityDescriptor = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSecurityDescriptor = new CSecurityDescriptor();
    if (pSecurityDescriptor == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsSecurityDescriptor,
                (IADsSecurityDescriptor *)pSecurityDescriptor,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pSecurityDescriptor->_pDispMgr = pDispMgr;
    *ppSecurityDescriptor = pSecurityDescriptor;

    RRETURN(hr);

error:

    delete pSecurityDescriptor;
    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CSecurityDescriptor::InterfaceSupportsErrorInfo(THIS_ REFIID riid) 
{
    if (IsEqualIID(riid, IID_IADsSecurityDescriptor)) {
        return S_OK;
    } else {
        return S_FALSE;
    }
}

STDMETHODIMP
CSecurityDescriptor::get_DiscretionaryAcl(
    IDispatch FAR * FAR * retval
    )
{

    if (_pDAcl) {

        //
        // Need to AddRef this pointer


        _pDAcl->AddRef();

        *retval = _pDAcl;



    }else {
        *retval = NULL;
    }

    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_DiscretionaryAcl(
    IDispatch FAR * pDiscretionaryAcl
    )
{
    HRESULT hr = S_OK;

    if (_pDAcl) {

        _pDAcl->Release();
    }

    if (pDiscretionaryAcl) {

        hr = pDiscretionaryAcl->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&_pDAcl
                    );

    }else {
        _pDAcl = NULL;

    }


    RRETURN_EXP_IF_ERR(hr);



}


STDMETHODIMP
CSecurityDescriptor::get_SystemAcl(
    IDispatch FAR * FAR * retval
    )
{
    if (_pSAcl) {

        //
        //  Need to AddRef this pointer
        //

        _pSAcl->AddRef();

        *retval = _pSAcl;

    }else {
        *retval = NULL;
    }

    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_SystemAcl(
    IDispatch FAR * pSystemAcl
    )
{
    HRESULT hr = S_OK;


    if (_pSAcl) {


        _pSAcl->Release();
    }

    if (pSystemAcl) {

        hr = pSystemAcl->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&_pSAcl
                    );
    }else {

        _pSAcl = NULL;
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CSecurityDescriptor::get_Revision(THIS_ long FAR * retval)
{

    *retval = _dwRevision;
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_Revision(THIS_ long lnRevision)
{

    _dwRevision = lnRevision;
    RRETURN(S_OK);
}


STDMETHODIMP
CSecurityDescriptor::get_Control(THIS_ long FAR * retval)
{
    *retval = _dwControl;
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_Control(THIS_ long lnControl)
{

    _dwControl = lnControl;
    RRETURN(S_OK);
}


STDMETHODIMP
CSecurityDescriptor::get_Owner(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpOwner, retval);
    RRETURN_EXP_IF_ERR(hr);

}

STDMETHODIMP
CSecurityDescriptor::put_Owner(THIS_ BSTR bstrOwner)
{


    if (_lpOwner) {
        FreeADsStr(_lpOwner);
    }

    if (!bstrOwner) {
        _lpOwner = NULL;
    }
    else {
        _lpOwner = AllocADsStr(bstrOwner);

        if (!_lpOwner) {
            RRETURN(E_OUTOFMEMORY);
        }
        
    }


    RRETURN(S_OK);

}

STDMETHODIMP
CSecurityDescriptor::get_Group(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpGroup, retval);
    RRETURN_EXP_IF_ERR(hr);

}


STDMETHODIMP
CSecurityDescriptor::put_Group(THIS_ BSTR bstrGroup)
{

    if (_lpGroup) {
        FreeADsStr(_lpGroup);
    }

    if (!bstrGroup) {
        _lpGroup = NULL;
    }
    else {
        _lpGroup = AllocADsStr(bstrGroup);

        if (!_lpGroup) {
            RRETURN_EXP_IF_ERR(E_OUTOFMEMORY);
        }
    }
    RRETURN(S_OK);
}


STDMETHODIMP
CSecurityDescriptor::CopySecurityDescriptor(THIS_ IDispatch FAR * FAR * ppSecurityDescriptor)
{

    HRESULT hr = S_OK;
    IADsSecurityDescriptor * pSecDes = NULL;

    IDispatch *pTargetDACL = NULL;
    IDispatch *pTargetSACL = NULL;
    IDispatch * pDisp = NULL;

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    if (_lpOwner) {
       hr = pSecDes->put_Owner(_lpOwner);
       BAIL_ON_FAILURE(hr);
    }

    if (_lpGroup) {
        hr = pSecDes->put_Group(_lpGroup);
        BAIL_ON_FAILURE(hr);
    }

    hr = pSecDes->put_Revision(_dwRevision);
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Control((DWORD)_dwControl);
    BAIL_ON_FAILURE(hr);

    if (_pDAcl) {
        hr = _pDAcl->CopyAccessList(&pTargetDACL);
        BAIL_ON_FAILURE(hr);

        hr = pSecDes->put_DiscretionaryAcl(pTargetDACL);
        BAIL_ON_FAILURE(hr);
    }


    if (_pSAcl) {

        hr = _pSAcl->CopyAccessList(&pTargetSACL);
        BAIL_ON_FAILURE(hr);

        hr = pSecDes->put_SystemAcl(pTargetSACL);
        BAIL_ON_FAILURE(hr);

    }
    hr = pSecDes->QueryInterface(
                        IID_IDispatch,
                        (void**)&pDisp
                        );
    BAIL_ON_FAILURE(hr);


    *ppSecurityDescriptor = pDisp;

cleanup:
    if (pTargetSACL) {
        pTargetSACL->Release();
    }

    if (pTargetDACL) {
        pTargetDACL->Release();
    }

    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN_EXP_IF_ERR(hr);

error:

    *ppSecurityDescriptor = NULL;    

    goto cleanup;
}


STDMETHODIMP
CSecurityDescriptor::get_OwnerDefaulted(THIS_ VARIANT_BOOL FAR* retval)
{
    if (_fOwnerDefaulted) {
        *retval = VARIANT_TRUE;
    }else{
        *retval = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_OwnerDefaulted(THIS_ VARIANT_BOOL fOwnerDefaulted)
{
    if (fOwnerDefaulted == VARIANT_TRUE) {
        _fOwnerDefaulted = TRUE;
    }else {
        _fOwnerDefaulted = FALSE;
    }

    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::get_GroupDefaulted(THIS_ VARIANT_BOOL FAR* retval)
{
    if (_fGroupDefaulted) {
        *retval = VARIANT_TRUE;
    }else{
        *retval = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_GroupDefaulted(THIS_ VARIANT_BOOL fGroupDefaulted)
{
    if (fGroupDefaulted == VARIANT_TRUE) {
        _fGroupDefaulted = TRUE;
    }else {
        _fGroupDefaulted = FALSE;
    }

    RRETURN(S_OK);
}


STDMETHODIMP
CSecurityDescriptor::get_DaclDefaulted(THIS_ VARIANT_BOOL FAR* retval)
{
    if (_fDaclDefaulted) {
        *retval = VARIANT_TRUE;
    }else{
        *retval = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_DaclDefaulted(THIS_ VARIANT_BOOL fDaclDefaulted)
{
    if (fDaclDefaulted == VARIANT_TRUE) {
        _fDaclDefaulted = TRUE;
    }else {
        _fDaclDefaulted = FALSE;
    }

    RRETURN(S_OK);
}


STDMETHODIMP
CSecurityDescriptor::get_SaclDefaulted(THIS_ VARIANT_BOOL FAR* retval)
{
    if (_fSaclDefaulted) {
        *retval = VARIANT_TRUE;
    }else{
        *retval = VARIANT_FALSE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CSecurityDescriptor::put_SaclDefaulted(THIS_ VARIANT_BOOL fSaclDefaulted)
{
    if (fSaclDefaulted == VARIANT_TRUE) {
        _fSaclDefaulted = TRUE;
    }else {
        _fSaclDefaulted = FALSE;
    }

    RRETURN(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\crowprov.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       crowprov.cxx
//
//  Contents:   IProvider implementation for ADSI rowsets
//
//  Functions:
//
//  Notes:
//
//
//  History:    07/10/96  | RenatoB   | Created, lifted most from EricJ code
//-----------------------------------------------------------------------------

// Includes
#include "oleds.hxx"

HRESULT
PackLargeInteger(
    LARGE_INTEGER *plargeint,
    PVARIANT pVarDestObject
    );

HRESULT
PackDNWithBinary(
    PADS_DN_WITH_BINARY pDNWithBinary,
    PVARIANT pVarDestObject
    );

HRESULT
PackDNWithString(
    PADS_DN_WITH_STRING pDNWithString,
    PVARIANT pVarDestObject
    );

//+---------------------------------------------------------------------------
//
//  Function:  CreateRowProvider
//
//  Synopsis:  @mfunc Creates and initializes a Row provider .
//
//----------------------------------------------------------------------------
HRESULT
CRowProvider::CreateRowProvider(
    IDirectorySearch * pDSSearch,
    LPWSTR             pszFilter,
    LPWSTR *           ppszAttrs,
    DWORD              cAttrs,
    DBORDINAL          cColumns,               // count of the rowset's columns
    DBCOLUMNINFO *     rgInfo,                 // array of cColumns DBCOLUMNINFO's
    OLECHAR*           pStringsBuffer,         // the names of the columns are here
    REFIID             riid,
    BOOL *             pMultiValued,
    BOOL               fADSPathPresent,
    CCredentials *     pCredentials,
    void **            ppvObj                  // the created Row provider
    )
{
    HRESULT        hr;
    CRowProvider * pRowProvider = NULL;

    if( ppvObj )
        *ppvObj = NULL;
    else
        BAIL_ON_FAILURE( hr = E_INVALIDARG );

    pRowProvider = new CRowProvider();
    if( pRowProvider == NULL )
        BAIL_ON_FAILURE( hr = E_OUTOFMEMORY );

    //
    //initialize rowprovider with the search filter and the columnsinfo
    //
    hr = pRowProvider->FInit(
                        pDSSearch,
                        pszFilter,
                        ppszAttrs,
                        cAttrs,
                        cColumns,
                        rgInfo,
                        pStringsBuffer,
                        pMultiValued,
                        fADSPathPresent,
                        pCredentials
                        );

    if( FAILED(hr) ) {
        delete pRowProvider;
        BAIL_ON_FAILURE( hr );
    }

    //
    // This interface pointer is embedded in the pRowProvider.
    //
    pDSSearch = NULL;

    hr = pRowProvider->QueryInterface( riid, ppvObj);
    if( FAILED(hr) ) {
        delete pRowProvider;
        BAIL_ON_FAILURE( hr );
    }

    pRowProvider->Release();

    RRETURN( S_OK );

error:

    if( pDSSearch )
        pDSSearch->Release();

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::CRowProvider
//
//----------------------------------------------------------------------------
CRowProvider::CRowProvider()
:
    _pMalloc         (NULL),
    _cColumns        (0),
    _ColInfo         (NULL),
    _pwchBuf         (NULL),
    _hSearchHandle   (NULL),
    _pdbSearchCol    (NULL),
    _pDSSearch       (NULL),
    _pMultiValued    (NULL),
    _fADSPathPresent (FALSE),
    _iAdsPathIndex   (0),
    _pCredentials    (NULL)

{
}


//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::~CRowProvider
//
//----------------------------------------------------------------------------
CRowProvider::~CRowProvider()
{
    ULONG i;

    if( _hSearchHandle != NULL )
        _pDSSearch->CloseSearchHandle(_hSearchHandle);

    if( _pDSSearch != NULL )
        _pDSSearch->Release();

    // Release the memory allocated for columns and ColumnsInfo
    if (_pMalloc != NULL) {
        if( _pdbSearchCol != NULL ) {
            _pMalloc->Free((void*)_pdbSearchCol);
        }

        if( _ColInfo != NULL )
            _pMalloc->Free(_ColInfo);

        if( _pwchBuf != NULL )
            _pMalloc->Free(_pwchBuf);

        _pMalloc->Release();
    }

    if( _pMultiValued ) {
        FreeADsMem(_pMultiValued);
    }

    if( _pCredentials )
        delete _pCredentials;
};



//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::Finit
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowProvider::FInit(
    IDirectorySearch * pDSSearch,
    LPWSTR             pszFilter,
    LPWSTR *           ppszAttrs,
    DWORD              cAttrs,
    DBORDINAL          cColumns,
    DBCOLUMNINFO *     rgInfo,
    OLECHAR *          pStringsBuffer,
    BOOL *             pMultiValued,
    BOOL                   fADSPathPresent,
    CCredentials *     pCredentials)
{
    HRESULT hr;
    ULONG i;
    ULONG cChars, cCharDispl;

    //
    // Asserts
    //
    ADsAssert(cColumns);
    ADsAssert(rgInfo);
    ADsAssert(pDSSearch);

    _cColumns= cColumns;

    hr = CoGetMalloc(MEMCTX_TASK, &_pMalloc);
    BAIL_ON_FAILURE( hr );

    _ColInfo = (DBCOLUMNINFO*)_pMalloc->Alloc((size_t)(cColumns *sizeof(DBCOLUMNINFO)));
    if( _ColInfo == NULL )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    memcpy(_ColInfo, rgInfo, (size_t)(cColumns * sizeof(DBCOLUMNINFO)));

    cChars = _pMalloc->GetSize(pStringsBuffer);
    _pwchBuf = (WCHAR*)_pMalloc->Alloc(cChars);
    if( _pwchBuf == NULL )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    memcpy(_pwchBuf, (void*)pStringsBuffer , cChars);

    for (i=0; i<_cColumns; i++) {
        if( rgInfo[i].pwszName ) {
            cCharDispl = (ULONG)(rgInfo[i].pwszName - pStringsBuffer);
            _ColInfo[i].pwszName = _pwchBuf + cCharDispl;
            _ColInfo[i].columnid.uName.pwszName = _pwchBuf + cCharDispl;
        }
    }

    // We have adspath at the end of the attribute list.
    _fADSPathPresent  = fADSPathPresent ;

    //Store credentials if non-NULL.
    if( pCredentials ) {
        //We don't expect that _pCredentials is already non-NULL
        ADsAssert(_pCredentials == NULL);
        _pCredentials = new CCredentials(*pCredentials);
        if( !_pCredentials )
            BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );
    }

    if( _fADSPathPresent == FALSE )
        cAttrs++;

    //
    // Create _pdbSearchCol, a member containing an array
    // of DB_SEARCH_COLUMN.
    // Reason for this is that trowset.cpp sometimes asks
    // for GetColumn twice: one to get the size of the column
    // and one to get the data.
    // Since OLEDP copies data, we do not want to have two copies
    // around
    //
    _pdbSearchCol = (PDB_SEARCH_COLUMN)_pMalloc->Alloc((ULONG)((cColumns + 1)*sizeof(DB_SEARCH_COLUMN)));
    if( _pdbSearchCol == NULL ) {
        hr = E_OUTOFMEMORY;
        goto error;
    }

    _pDSSearch = pDSSearch;

    hr = _pDSSearch->ExecuteSearch(
             pszFilter,
             ppszAttrs,
             cAttrs,
             &_hSearchHandle
              );
    BAIL_ON_FAILURE( hr );

    _pMultiValued = pMultiValued;

    RRETURN( hr );

error:

    if( _pMalloc != NULL ) {
        if( _pdbSearchCol != NULL ) {
            _pMalloc->Free((void*)_pdbSearchCol);
            _pdbSearchCol= NULL;
        };
        if( _ColInfo != NULL ) {
            _pMalloc->Free(_ColInfo);
            _ColInfo = NULL;
        }

        if( _pwchBuf != NULL ) {
            _pMalloc->Free(_pwchBuf);
            _pwchBuf = NULL;
        }

        _pMalloc->Release();
        _pMalloc = NULL;
    };

    if (_hSearchHandle != NULL)
        _pDSSearch->CloseSearchHandle(_hSearchHandle);

    _hSearchHandle = NULL;

    _pDSSearch = NULL;

    RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::QueryInterface
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowProvider::QueryInterface(
        REFIID   riid,
        LPVOID * ppv)
{
    if( !ppv )
        RRETURN( E_INVALIDARG );

    if( riid == IID_IUnknown
        ||  riid == IID_IRowProvider )
        *ppv = (IRowProvider FAR *) this;
    else if( riid == IID_IColumnsInfo )
        *ppv = (IColumnsInfo FAR *) this;
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    RRETURN( S_OK );
}

//-----------------------------------------------------------------------------
//
//  Function:  CRowProvider::NextRow
//
//  Synopsis:  Advance to the next row.
//
//             Called by: Client.
//             Called when: To advance to next row.
//             This sets the "current" row.
//             Initially the "current" row is prior to the first actual row.
//             (Which means This must be called prior to the first GetColumn call.)
//
//----------------------------------------------------------------------------

STDMETHODIMP
CRowProvider::NextRow()
{
    HRESULT hr;
    ULONG i;
    DWORD dwType, dwExtError = ERROR_SUCCESS;
    VARTYPE vType = VT_NULL;
    const int ERROR_BUF_SIZE = 512;
    const int NAME_BUF_SIZE = 128;
    WCHAR ErrorBuf[ERROR_BUF_SIZE];
    WCHAR NameBuf[NAME_BUF_SIZE];

    do {
        // Clear the ADSI extended error, so that after the call to GetNextRow,
        // we can safely check if an extended error was set.
        ADsSetLastError(ERROR_SUCCESS, NULL, NULL);
        dwExtError = ERROR_SUCCESS;

        //
        // read the next row
        //
        hr = _pDSSearch->GetNextRow(
                        _hSearchHandle
                        );

        // we should treat SIZE_LIMIT_EXCEEDED error message as
        // S_ADS_NOMORE_ROWS
        // in the future, we might want to return this error message
        // to the user under non-paged search situation
        if (LIMIT_EXCEEDED_ERROR(hr))
            hr = S_ADS_NOMORE_ROWS;
        
		BAIL_ON_FAILURE( hr );

        if (hr == S_ADS_NOMORE_ROWS)
        {
            // check if more results are likely (pagedTimeLimit search). If so,
            // we will keep trying till a row is obtained.
            hr = ADsGetLastError(&dwExtError, ErrorBuf, ERROR_BUF_SIZE,
                        NameBuf, NAME_BUF_SIZE);
            BAIL_ON_FAILURE(hr);

            if (dwExtError != ERROR_MORE_DATA)
            // we really have no more data
                RRETURN(DB_S_ENDOFROWSET);
        }
    } while(ERROR_MORE_DATA == dwExtError);

    //
    //read all the columnsinto _pdbSearchCol leaving the bookmark column
    //
    for (i=1; i<_cColumns; i++) {

        hr = _pDSSearch->GetColumn(
                 _hSearchHandle,
                 _ColInfo[i].pwszName,
                 &(_pdbSearchCol[i].adsColumn)
                 );
        if (FAILED(hr)  && hr != E_ADS_COLUMN_NOT_SET)
            goto error;

        if (hr == E_ADS_COLUMN_NOT_SET ||
            _pdbSearchCol[i].adsColumn.dwNumValues == 0) {

            _pdbSearchCol[i].dwStatus = DBSTATUS_S_ISNULL;
            _pdbSearchCol[i].dwType = DBTYPE_EMPTY;
            _pdbSearchCol[i].dwLength = 0;
            hr = S_OK;

        }
        else if (_ColInfo[i].wType == (DBTYPE_VARIANT | DBTYPE_BYREF)) {
            _pdbSearchCol[i].dwStatus = DBSTATUS_S_OK;
            _pdbSearchCol[i].dwType = _ColInfo[i].wType;
            _pdbSearchCol[i].dwLength = sizeof(VARIANT);
        }
        else if ((ULONG) _pdbSearchCol[i].adsColumn.dwADsType >= g_cMapADsTypeToDBType ||
            g_MapADsTypeToDBType[_pdbSearchCol[i].adsColumn.dwADsType].wType == DBTYPE_NULL) {
            _pdbSearchCol[i].dwStatus = DBSTATUS_E_CANTCONVERTVALUE;
            _pdbSearchCol[i].dwType = DBTYPE_EMPTY;
            _pdbSearchCol[i].dwLength = 0;
        }
        else {
            _pdbSearchCol[i].dwStatus = DBSTATUS_S_OK;
            _pdbSearchCol[i].dwType = g_MapADsTypeToDBType[_pdbSearchCol[i].adsColumn.dwADsType].wType;

            switch (_pdbSearchCol[i].dwType & ~DBTYPE_BYREF) {
            case DBTYPE_WSTR:
                _pdbSearchCol[i].dwLength =
                (wcslen( _pdbSearchCol[i].adsColumn.pADsValues[0].CaseIgnoreString)) *
                sizeof (WCHAR);
                break;

            case DBTYPE_BYTES:
                if(_pdbSearchCol[i].adsColumn.dwADsType == ADSTYPE_OCTET_STRING)
                    _pdbSearchCol[i].dwLength =
                    _pdbSearchCol[i].adsColumn.pADsValues[0].OctetString.dwLength;
                else if(_pdbSearchCol[i].adsColumn.dwADsType ==
                                         ADSTYPE_NT_SECURITY_DESCRIPTOR)
                    _pdbSearchCol[i].dwLength =
                    _pdbSearchCol[i].adsColumn.pADsValues[0].SecurityDescriptor.dwLength;
                else if(_pdbSearchCol[i].adsColumn.dwADsType ==
                                          ADSTYPE_PROV_SPECIFIC)
                    _pdbSearchCol[i].dwLength =
                    _pdbSearchCol[i].adsColumn.pADsValues[0].ProviderSpecific.dwLength;

                break;

            default:
                _pdbSearchCol[i].dwLength = g_MapADsTypeToDBType[_pdbSearchCol[i].adsColumn.dwADsType].ulSize;
            }
        }
    }

    if ((FALSE == _fADSPathPresent))
    {
        hr = _pDSSearch->GetColumn(
                 _hSearchHandle,
                 L"AdsPath",
                 &(_pdbSearchCol[i].adsColumn)
                 );
        if FAILED(hr)
            goto error;
    }

    RRETURN(hr);

error:
    RRETURN(hr);
}


//-----------------------------------------------------------------------------
//
//  Function:  CRowProvider::GetColumn
//
//  Synopsis:  @mfunc Get a column value.
//
//             We only provide a ptr to the value -- retained in our memory
//             space.
//
//             Called by: Client.
//             Called when: After NextRow, once for each column.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CRowProvider::GetColumn(
    ULONG        iCol,
    DBSTATUS    *pdbStatus,
    ULONG        *pdwLength,
    BYTE        *pbData
    )
{

    DBTYPE columnType = 0;
    DBSTATUS dbStatus_temp = 0;
    BOOL is_Ref = FALSE;
    HRESULT hr = S_OK;

    ADsAssert( 1 <= iCol && iCol <= _cColumns );

    //
    // Note that the caller gives us a ptr to where to put the data.
    // We can fill in dwStatus, dwLength.
    // For pbData, we assume this is a ptr to where we are to write our ptr.
    //
    columnType = _ColInfo[iCol].wType;
    if ((columnType & DBTYPE_ARRAY) || (columnType & DBTYPE_VECTOR) ) {
        if (pdbStatus != NULL)
            *pdbStatus= DBSTATUS_E_UNAVAILABLE;

        if (pdwLength != NULL)
            *pdwLength = 0;

        RRETURN(DB_S_ERRORSOCCURRED);
    }

    if (pdwLength!= NULL)
        *pdwLength = _pdbSearchCol[iCol].dwLength;

    dbStatus_temp = _pdbSearchCol[iCol].dwStatus;

    if (columnType & DBTYPE_BYREF)
        is_Ref = TRUE;

    columnType &= (~DBTYPE_BYREF);

    if (pbData != NULL && dbStatus_temp == DBSTATUS_S_OK) {
        switch (columnType) {
            case DBTYPE_BOOL:
                * (VARIANT_BOOL*) pbData =  _pdbSearchCol[iCol].adsColumn.pADsValues[0].Boolean ?
                                            VARIANT_TRUE: VARIANT_FALSE;
                break;
            case DBTYPE_I4:
                * (DWORD*) pbData = _pdbSearchCol[iCol].adsColumn.pADsValues[0].Integer;
                break;
            case DBTYPE_WSTR:
                *(WCHAR**)pbData = _pdbSearchCol[iCol].adsColumn.pADsValues[0].CaseIgnoreString;
                break;
            case DBTYPE_BYTES:
                if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                 ADSTYPE_OCTET_STRING)
                    *(BYTE**)pbData = _pdbSearchCol[iCol].adsColumn.pADsValues[0].OctetString.lpValue;
                else if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                ADSTYPE_NT_SECURITY_DESCRIPTOR)
                     *(BYTE**)pbData = _pdbSearchCol[iCol].adsColumn.pADsValues[0].SecurityDescriptor.lpValue;

                else if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                 ADSTYPE_PROV_SPECIFIC)
                     *(BYTE**)pbData = _pdbSearchCol[iCol].adsColumn.pADsValues[0].ProviderSpecific.lpValue;

                break;
            case DBTYPE_DATE:
                {
                double date = 0;
                hr = SystemTimeToVariantTime(
                                &_pdbSearchCol[iCol].adsColumn.pADsValues[0].UTCTime,
                                &date);
                if( FAILED(hr) )
                    if (pdbStatus != NULL)
                        *pdbStatus= DBSTATUS_E_CANTCONVERTVALUE;

                BAIL_ON_FAILURE(hr);
                *(double*)pbData = date;
                break;
                }
            case DBTYPE_VARIANT:
                if (_pMultiValued[iCol] == FALSE) {
                    PVARIANT pVariant = (PVARIANT) AllocADsMem(sizeof(VARIANT));
                    if (!pVariant) {
                        if (pdbStatus != NULL)
                            *pdbStatus= DBSTATUS_E_CANTCONVERTVALUE;
                        hr = E_OUTOFMEMORY;
                        BAIL_ON_FAILURE(hr);
                    }

                    if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                ADSTYPE_LARGE_INTEGER)
                        hr = PackLargeInteger(
                                  &_pdbSearchCol[iCol].adsColumn.pADsValues[0].LargeInteger, pVariant);
                    else if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                ADSTYPE_DN_WITH_BINARY)
                        hr = PackDNWithBinary(_pdbSearchCol[iCol].adsColumn.pADsValues[0].pDNWithBinary, pVariant);

                    else if(_pdbSearchCol[iCol].adsColumn.dwADsType ==
                                                ADSTYPE_DN_WITH_STRING)
                        hr = PackDNWithString(_pdbSearchCol[iCol].adsColumn.pADsValues[0].pDNWithString, pVariant);

                    if( FAILED(hr) )
                        if (pdbStatus != NULL)
                            *pdbStatus= DBSTATUS_E_CANTCONVERTVALUE;
                    BAIL_ON_FAILURE(hr);
                    *((PVARIANT*)pbData) = pVariant;
                }
                else {
                    hr = CopyADs2VariantArray(
                         &_pdbSearchCol[iCol].adsColumn,
                         (PVARIANT *) pbData
                         );
                    if (hr == E_ADS_CANT_CONVERT_DATATYPE) {
                        dbStatus_temp= DBSTATUS_E_UNAVAILABLE;
                        break;
                    }
                    if( FAILED(hr) )
                        if (pdbStatus != NULL)
                            *pdbStatus= DBSTATUS_E_CANTCONVERTVALUE;
                    BAIL_ON_FAILURE(hr);
                }
                break;

            default:
                dbStatus_temp= DBSTATUS_E_UNAVAILABLE;
                break;
        };
    };
    if (pdbStatus == 0)
        RRETURN(S_OK);

    if (pdbStatus != NULL)

        *pdbStatus = dbStatus_temp;

    if (dbStatus_temp == DBSTATUS_S_OK || dbStatus_temp == DBSTATUS_S_ISNULL)
        RRETURN(S_OK);
    else
        RRETURN(DB_S_ERRORSOCCURRED);

error:
    RRETURN(hr);
}


HRESULT CRowProvider::GetIndex(
    IColumnsInfo* pColumnsInfo,
    LPWSTR lpwszColName,
    int& iIndex
    )
{
#if (!defined(BUILD_FOR_NT40))
    HRESULT hr = S_OK;
    int iColumn;
    DBCOLUMNINFO* pColumnInfo = NULL;
    DBORDINAL cColumns = 0;
    OLECHAR* pStringsBuffer = NULL;

    iIndex = 0;
    hr = pColumnsInfo->GetColumnInfo(&cColumns, &pColumnInfo, &pStringsBuffer);
    BAIL_ON_FAILURE(hr);

    for(iColumn = 0; iColumn < cColumns; iColumn++)
    {
        if(pColumnInfo[iColumn].pwszName == NULL || lpwszColName == NULL)
            continue;

        if(!_wcsicmp(pColumnInfo[iColumn].pwszName, lpwszColName))
        {
            iIndex = iColumn;
            break;
        }
    }

    if (pColumnInfo)
        _pMalloc->Free((void*)pColumnInfo);
    if (pStringsBuffer)
        _pMalloc->Free((void*)pStringsBuffer);

    RRETURN(S_OK);

error:
    if (pColumnInfo)
        _pMalloc->Free((void*)pColumnInfo);
    if (pStringsBuffer)
        _pMalloc->Free((void*)pStringsBuffer);
    RRETURN(hr);
#else
    RRETURN(E_FAIL);
#endif
}

STDMETHODIMP CRowProvider::GetURLFromHROW(
    HROW hRow,
    LPOLESTR  *ppwszURL,
    IRowset* pRowset
    )
{
#if (!defined(BUILD_FOR_NT40))
    HRESULT hr = S_OK;
    auto_rel<IAccessor> pAccessor;
    auto_rel<IColumnsInfo> pColumnsInfo;
    HACCESSOR hAccessor = NULL;
    DBBINDING Bindings[1];
    CComVariant   varData;

    if ((NULL == hRow) || (NULL == ppwszURL) || (NULL == pRowset))
        RRETURN(E_INVALIDARG);

    *ppwszURL = NULL;

    // If adspath is in the list of columns selected
    // return that value.
    if (_fADSPathPresent)
    {
        VariantInit(&varData);

        Bindings[0].dwPart      = DBPART_VALUE;
        Bindings[0].dwMemOwner  = DBMEMOWNER_CLIENTOWNED;
        Bindings[0].eParamIO    = DBPARAMIO_NOTPARAM;
        Bindings[0].wType       = DBTYPE_VARIANT;
        Bindings[0].pTypeInfo   = NULL;
        Bindings[0].obValue     = 0;
        Bindings[0].bPrecision  = 0;
        Bindings[0].bScale      = 0;
        Bindings[0].cbMaxLen    = sizeof(VARIANT);
        Bindings[0].pObject     = NULL;
        Bindings[0].pBindExt    = NULL;
        Bindings[0].dwFlags     = 0;

        hr = pRowset->QueryInterface(IID_IAccessor, (void**)&pAccessor);
        BAIL_ON_FAILURE(hr);

        if (_iAdsPathIndex == 0)
        {
            hr = pRowset->QueryInterface(__uuidof(IColumnsInfo), (void **)&pColumnsInfo);
            BAIL_ON_FAILURE(hr);

            hr = GetIndex(pColumnsInfo, L"AdsPath", _iAdsPathIndex);
            if (0 == _iAdsPathIndex)
                hr = E_UNEXPECTED;

            BAIL_ON_FAILURE(hr);
        }

        Bindings[0].iOrdinal    = _iAdsPathIndex;
        Bindings[0].obValue     = NULL;

        hr = pAccessor->CreateAccessor(DBACCESSOR_ROWDATA,sizeof(Bindings)/sizeof(Bindings[0]) , Bindings, 0, &hAccessor, NULL);
        BAIL_ON_FAILURE(hr);
        hr = pRowset->GetData(hRow, hAccessor, &varData);
        BAIL_ON_FAILURE(hr);

        ADsAssert(varData.vt == VT_BSTR);
        ADsAssert(varData.bstrVal);

        // allocate the string and copy data
        *ppwszURL = (LPWSTR ) _pMalloc->Alloc(sizeof(WCHAR) * (wcslen(varData.bstrVal) + 1));
        if (NULL == *ppwszURL)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(*ppwszURL, varData.bstrVal);

        if (hAccessor)
            pAccessor->ReleaseAccessor(hAccessor, NULL);

    }
    else
    {
        ADS_CASE_IGNORE_STRING padsPath;

        hr = ((CRowset *)pRowset)->GetADsPathFromHROW(hRow, &padsPath);
        BAIL_ON_FAILURE(hr);

        *ppwszURL = (LPWSTR ) _pMalloc->Alloc(sizeof(WCHAR) *
                        (wcslen(padsPath)  +1));
        if (NULL == *ppwszURL)
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        wcscpy(*ppwszURL, padsPath);

    }

    RRETURN(S_OK);

error:
    if (hAccessor)
        pAccessor->ReleaseAccessor(hAccessor, NULL);
    RRETURN(hr);
#else
    RRETURN(E_FAIL);
#endif

}


//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::GetColumnInfo
//
//  Synopsis:  @mfunc Get Column Info.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowProvider::GetColumnInfo(
    DBORDINAL *     pcColumns,
    DBCOLUMNINFO ** pprgInfo,
    WCHAR **        ppStringsBuffer
    )
{
    DBORDINAL i;
    ULONG cChars, cCharDispl;
    HRESULT                hr             = S_OK;
    DBCOLUMNINFO * prgInfo    = NULL;
    WCHAR *        pStrBuffer = NULL;

    //
    // Asserts
    //
    ADsAssert(_pMalloc);
    ADsAssert(_cColumns);
    ADsAssert(_ColInfo);
    ADsAssert(_pwchBuf);

    if( pcColumns )
        *pcColumns = 0;

    if( pprgInfo )
        *pprgInfo = NULL;

    if( ppStringsBuffer )
        *ppStringsBuffer = NULL;

    if( (pcColumns == NULL) || (pprgInfo == NULL) || (ppStringsBuffer == NULL) )
        BAIL_ON_FAILURE( hr=E_INVALIDARG );

    prgInfo = (DBCOLUMNINFO*)_pMalloc->Alloc((ULONG)(_cColumns * sizeof(DBCOLUMNINFO)));
    if( prgInfo == NULL )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    memcpy(prgInfo, _ColInfo, (size_t)(_cColumns * sizeof(DBCOLUMNINFO)));

    cChars = _pMalloc->GetSize(_pwchBuf);
    pStrBuffer  = (WCHAR*)_pMalloc->Alloc(cChars);
    if( pStrBuffer == NULL )
    BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    memcpy(pStrBuffer, (void*)_pwchBuf , cChars);

    for (i=1; i<_cColumns; i++) {
        cCharDispl = (ULONG)(_ColInfo[i].pwszName - _pwchBuf);
        prgInfo[i].pwszName = pStrBuffer + cCharDispl;
        prgInfo[i].columnid.uName.pwszName = pStrBuffer + cCharDispl;
    };

    *pcColumns       = _cColumns;
    *pprgInfo        = prgInfo;
    *ppStringsBuffer = pStrBuffer;

    RRETURN( S_OK );

error:

    if( !prgInfo )
        _pMalloc->Free(prgInfo);

    if( pStrBuffer != NULL )
        _pMalloc->Free(pStrBuffer);

    RRETURN( hr );
};


//+---------------------------------------------------------------------------
//
//  Function:  CRowProvider::MapColumnIDs
//
//  Synopsis:  @mfunc Map Column IDs.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CRowProvider::MapColumnIDs(
    DBORDINAL  cColumnIDs,
    const DBID rgColumnIDs[],
    DBORDINAL  rgColumns[]
    )
{
    ULONG        found = 0;
    DBORDINAL i;

    DBORDINAL cValidCols = 0;
    //
    // No Column IDs are set when GetColumnInfo returns ColumnsInfo structure.
    // Hence, any value of ID will not match with any column
    //
    DBORDINAL iCol;

    //
    // No-Op if cColumnIDs is 0
    //
    if( cColumnIDs == 0 )
        RRETURN( S_OK );

    // Spec-defined checks.
    // Note that this guarantees we can access rgColumnIDs[] in loop below.
    // (Because we'll just fall through.)
    if( cColumnIDs && (!rgColumnIDs || !rgColumns) )
        RRETURN( E_INVALIDARG );

    //
    // Set the columns ordinals to invalid values
    //
    for (iCol=0; iCol < cColumnIDs; iCol++) {
        // Initialize
        rgColumns[iCol] = DB_INVALIDCOLUMN;

        //
        // The columnid with the Bookmark or the same name
        //
        if( rgColumnIDs[iCol].eKind == DBKIND_GUID_PROPID &&
            rgColumnIDs[iCol].uGuid.guid == DBCOL_SPECIALCOL &&
            rgColumnIDs[iCol].uName.ulPropid == 2 ) {
            rgColumns[iCol] = 0;
            cValidCols++;
            continue;
        }

        //
        // The columnid with the Column Name
        //
        if( rgColumnIDs[iCol].eKind == DBKIND_NAME &&
            rgColumnIDs[iCol].uName.pwszName ) {
            //
            // Find the name in the list of Attributes
            //
            for (ULONG iOrdinal=0; iOrdinal < _cColumns; iOrdinal++) {
                if( _ColInfo[iOrdinal].columnid.eKind == DBKIND_NAME &&
                        !_wcsicmp(_ColInfo[iOrdinal].columnid.uName.pwszName,
                        rgColumnIDs[iCol].uName.pwszName) ) {
                        rgColumns[iCol] = iOrdinal;
                        cValidCols++;
                        break;
                }
            }
        }
    }

    if( cValidCols == 0 )
        RRETURN( DB_E_ERRORSOCCURRED );
    else if( cValidCols < cColumnIDs )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( S_OK );
}


STDMETHODIMP
CRowProvider::CopyADs2VariantArray(
     PADS_SEARCH_COLUMN pADsColumn,
     PVARIANT *ppVariant
     )
{
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    VARTYPE vType = VT_NULL;
    HRESULT hr = S_OK;
    ULONG i;
    PVARIANT pVariant = NULL, pVarArray = NULL;
    BOOL fSafeArrayLocked = FALSE;


    ADsAssert(ppVariant);
    *ppVariant = NULL;

    aBound.lLbound = 0;
    aBound.cElements = pADsColumn->dwNumValues;

    pVariant = (PVARIANT) AllocADsMem(sizeof(VARIANT));
    if (!pVariant) {
        RRETURN(E_OUTOFMEMORY);
    }

    if ((ULONG) pADsColumn->dwADsType >= g_cMapADsTypeToVarType ||
        (vType = g_MapADsTypeToVarType[pADsColumn->dwADsType]) == VT_NULL) {

        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    if (aList == NULL)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    hr = SafeArrayAccessData( aList, (void **) &pVarArray );
    if (FAILED(hr)) {
        SafeArrayDestroy( aList );
        goto error;
    }

    fSafeArrayLocked = TRUE;

    for (i=0; i<aBound.cElements; i++) {

        (V_VT(pVarArray+i)) = vType;

        switch (vType) {
        case VT_I4:
            V_I4(pVarArray+i) = pADsColumn->pADsValues[i].Integer;
            break;

        case VT_DISPATCH:
            if(pADsColumn->dwADsType == ADSTYPE_LARGE_INTEGER)
                hr = PackLargeInteger(&pADsColumn->pADsValues[i].LargeInteger,
                                  pVarArray+i);
            else if(pADsColumn->dwADsType == ADSTYPE_DN_WITH_BINARY)
                hr = PackDNWithBinary(pADsColumn->pADsValues[i].pDNWithBinary,
                                  pVarArray+i);
            else if(pADsColumn->dwADsType == ADSTYPE_DN_WITH_STRING)
                hr = PackDNWithString(pADsColumn->pADsValues[i].pDNWithString,
                                  pVarArray+i);

            BAIL_ON_FAILURE(hr);
            break;

        case VT_BOOL:
            V_I4(pVarArray+i) = pADsColumn->pADsValues[i].Boolean ?
                                          VARIANT_TRUE: VARIANT_FALSE;
            break;

        case VT_BSTR:
            hr = ADsAllocString (
                     pADsColumn->pADsValues[i].CaseIgnoreString,
                     &(V_BSTR(pVarArray+i))
                     );
            BAIL_ON_FAILURE(hr);
            break;

       case VT_DATE:
            {
            double date = 0;
            hr = SystemTimeToVariantTime(
                            &pADsColumn->pADsValues[i].UTCTime,
                            &date);
            BAIL_ON_FAILURE(hr);
            V_DATE(pVarArray+i)= date;
            break;
            }

        case (VT_UI1 | VT_ARRAY):
            VariantInit(pVarArray+i);

            if(pADsColumn->dwADsType == ADSTYPE_OCTET_STRING)
                hr = BinaryToVariant(
                        pADsColumn->pADsValues[i].OctetString.dwLength,
                        pADsColumn->pADsValues[i].OctetString.lpValue,
                        pVarArray+i);
            else if(pADsColumn->dwADsType == ADSTYPE_NT_SECURITY_DESCRIPTOR)
                hr = BinaryToVariant(
                        pADsColumn->pADsValues[i].SecurityDescriptor.dwLength,
                        pADsColumn->pADsValues[i].SecurityDescriptor.lpValue,
                        pVarArray+i);
            else if(pADsColumn->dwADsType == ADSTYPE_PROV_SPECIFIC)
                hr = BinaryToVariant(
                        pADsColumn->pADsValues[i].ProviderSpecific.dwLength,
                        pADsColumn->pADsValues[i].ProviderSpecific.lpValue,
                        pVarArray+i);

            BAIL_ON_FAILURE(hr);
            break;

        default:
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
            break;
        }

    }

    fSafeArrayLocked = FALSE;
    SafeArrayUnaccessData( aList );

    V_VT((PVARIANT)pVariant) = VT_ARRAY | VT_VARIANT;
    V_ARRAY((PVARIANT)pVariant) = aList;

    *ppVariant = pVariant;

    RRETURN(S_OK);

error:

    if (fSafeArrayLocked && (NULL != aList))
    {
        SafeArrayUnaccessData( aList );
        SafeArrayDestroy( aList );
    }


    if (pVariant) {
        FreeADsMem(pVariant);
    }
    RRETURN(hr);


}


HRESULT
PackLargeInteger(
    LARGE_INTEGER *plargeint,
    PVARIANT pVarDestObject
    )
{
   HRESULT hr = S_OK;
   IADsLargeInteger * pLargeInteger = NULL;
   IDispatch * pDispatch = NULL;

   hr = CoCreateInstance(
            CLSID_LargeInteger,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsLargeInteger,
            (void **) &pLargeInteger);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->put_LowPart(plargeint->LowPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->put_HighPart(plargeint->HighPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   V_VT(pVarDestObject) = VT_DISPATCH;
   V_DISPATCH(pVarDestObject) =  pDispatch;

error:

   if (pLargeInteger) {
      pLargeInteger->Release();
   }
   RRETURN(hr);
}

HRESULT
PackDNWithBinary(
    PADS_DN_WITH_BINARY pDNWithBinary,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr;
    IADsDNWithBinary *pIADsDNWithBinary = NULL;
    BSTR bstrTemp = NULL;
    SAFEARRAYBOUND aBound;
    SAFEARRAY *aList = NULL;
    CHAR HUGEP *pArray = NULL;
    IDispatch *pIDispatch = NULL;

    if( (NULL == pDNWithBinary) || (NULL == pVarDestObject) )
        BAIL_ON_FAILURE(hr = E_INVALIDARG);

    hr = CoCreateInstance(
             CLSID_DNWithBinary,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsDNWithBinary,
             (void **) &pIADsDNWithBinary
             );
    BAIL_ON_FAILURE(hr);

    if (pDNWithBinary->pszDNString) {
        hr = ADsAllocString(pDNWithBinary->pszDNString, &bstrTemp);
        BAIL_ON_FAILURE(hr);

        //
        // Put the value in the object - we can only set BSTR's
        //
        hr = pIADsDNWithBinary->put_DNString(bstrTemp);
        BAIL_ON_FAILURE(hr);
    }

    aBound.lLbound = 0;
    aBound.cElements = pDNWithBinary->dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, pDNWithBinary->lpBinaryValue, aBound.cElements );

    SafeArrayUnaccessData( aList );

    V_VT(pVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(pVarDestObject) = aList;

    hr = pIADsDNWithBinary->put_BinaryValue(*pVarDestObject);
    VariantClear(pVarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pIADsDNWithBinary->QueryInterface(
                            IID_IDispatch,
                            (void **) &pIDispatch
                            );
    BAIL_ON_FAILURE(hr);

    V_VT(pVarDestObject) = VT_DISPATCH;
    V_DISPATCH(pVarDestObject) = pIDispatch;

error:
    if(pIADsDNWithBinary)
        pIADsDNWithBinary->Release();

    if (bstrTemp)
        ADsFreeString(bstrTemp);

    RRETURN(hr);
}

HRESULT
PackDNWithString(
    PADS_DN_WITH_STRING pDNWithString,
    PVARIANT pVarDestObject
    )
{
    HRESULT hr;
    IADsDNWithString *pIADsDNWithString = NULL;
    BSTR bstrDNVal = NULL;
    BSTR bstrStrVal = NULL;
    IDispatch *pIDispatch;

    if( (NULL == pDNWithString) || (NULL == pVarDestObject) )
        BAIL_ON_FAILURE(hr = E_INVALIDARG);

    hr = CoCreateInstance(
             CLSID_DNWithString,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsDNWithString,
             (void **) &pIADsDNWithString
             );
    BAIL_ON_FAILURE(hr);

    if (pDNWithString->pszDNString) {
        hr = ADsAllocString(pDNWithString->pszDNString, &bstrDNVal);
        BAIL_ON_FAILURE(hr);

        hr = pIADsDNWithString->put_DNString(bstrDNVal);
        BAIL_ON_FAILURE(hr);
    }

    if (pDNWithString->pszStringValue) {
        hr = ADsAllocString(
                 pDNWithString->pszStringValue,
                 &bstrStrVal
                 );
        BAIL_ON_FAILURE(hr);

        hr = pIADsDNWithString->put_StringValue(bstrStrVal);

        BAIL_ON_FAILURE(hr);
    }

    hr = pIADsDNWithString->QueryInterface(
                            IID_IDispatch,
                            (void **) &pIDispatch
                            );
    BAIL_ON_FAILURE(hr);

    V_VT(pVarDestObject) = VT_DISPATCH;
    V_DISPATCH(pVarDestObject) = pIDispatch;

error:

    if(pIADsDNWithString)
        pIADsDNWithString->Release();

    if (bstrDNVal) {
        ADsFreeString(bstrDNVal);
    }

    if (bstrStrVal) {
        ADsFreeString(bstrStrVal);
    }

    RRETURN(hr);
}

HRESULT
CRowProvider::SeekToNextRow(void)
{
    HRESULT hr;
    DWORD dwExtError = ERROR_SUCCESS;
    const int ERROR_BUF_SIZE = 512;
    const int NAME_BUF_SIZE = 128;
    WCHAR ErrorBuf[ERROR_BUF_SIZE];
    WCHAR NameBuf[NAME_BUF_SIZE];

    do {
        // Clear the ADSI extended error, so that after the call to GetNextRow,
        // we can safely check if an extended error was set.
        ADsSetLastError(ERROR_SUCCESS, NULL, NULL);
        dwExtError = ERROR_SUCCESS;

        //
        // read the next row
        //
        hr = _pDSSearch->GetNextRow(
                        _hSearchHandle
                        );

        // we should treat SIZE_LIMIT_EXCEEDED error message as
        // S_ADS_NOMORE_ROWS
        // in the future, we might want to return this error message
        // to the user under non-paged search situation
        if (LIMIT_EXCEEDED_ERROR(hr))
            hr = S_ADS_NOMORE_ROWS;
        
        BAIL_ON_FAILURE( hr );

        if (hr == S_ADS_NOMORE_ROWS)
        {
            // check if more results are likely (pagedTimeLimit search). If so,
            // we will keep trying till a row is obtained.
            hr = ADsGetLastError(&dwExtError, ErrorBuf, ERROR_BUF_SIZE,
                        NameBuf, NAME_BUF_SIZE);
            BAIL_ON_FAILURE(hr);

            if (dwExtError != ERROR_MORE_DATA)
            // we really have no more data
                RRETURN(S_ADS_NOMORE_ROWS);
        }
    } while(ERROR_MORE_DATA == dwExtError);

error:
    RRETURN(hr);
}

HRESULT
CRowProvider::SeekToPreviousRow(void)
{
    RRETURN( _pDSSearch->GetPreviousRow(_hSearchHandle) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\csession.cxx ===
//---------------------------------------------------------------------------

//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  csession.cxx
//
//  Contents:  Microsoft OleDB/OleDS Session object for ADSI
//
//
//  History:   08-01-96     shanksh    Created.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop
#include "atl.h"
#include "row.hxx"

//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::GetDataSource
//
//  Synopsis: Retrieve an interface pointer on the session object
//
//  Arguments:
//              riid,               IID desired
//              ppDSO               ptr to interface
//
//
//  Returns:
//              S_OK                    Session Object Interface returned
//              E_INVALIDARG            ppDSO was NULL
//              E_NOINTERFACE           IID not supported
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::GetDataSource (
        REFIID      riid,
    IUnknown ** ppDSO
    )
{
    //
    // Asserts
    //
    ADsAssert(_pDSO);

    if( ppDSO == NULL )
        RRETURN( E_INVALIDARG );

    RRETURN( _pDSO->QueryInterface(riid, (LPVOID*)ppDSO) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::GetDataSource
//
//  Synopsis: Retrieve an interface pointer on the session object
//
//  Arguments:
//              riid,               IID desired
//              ppDSO               ptr to interface
//
//
//  Returns:
//              S_OK                    Session Object Interface returned
//              E_INVALIDARG            ppDSO was NULL
//              E_NOINTERFACE           IID not supported
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::OpenRowset(
        IUnknown *  pUnkOuter,
        DBID *      pTableID,
        DBID *      pIndexID,
        REFIID      riid,
        ULONG       cPropertySets,
        DBPROPSET   rgPropertySets[],
        IUnknown ** ppRowset
        )
{
    // Don't pass any credentials (NULL)
    RRETURN( OpenRowsetWithCredentials(
                    pUnkOuter,
                    pTableID,
                    pIndexID,
                    riid,
                    cPropertySets,
                    rgPropertySets,
                    NULL,
                    ppRowset) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::OpenRowsetWithCredentials
//
//  Synopsis: Opens a rowset. Similar to OpenRowset but takes extra argument
//            CCredentials. This function is used when consumer calls
//            IBindResource::Bind requesting a rowset.
//
//  Returns : HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CSessionObject::OpenRowsetWithCredentials (
        IUnknown *     pUnkOuter,
        DBID *         pTableID,
        DBID *         pIndexID,
        REFIID         riid,
        ULONG          cPropertySets,
        DBPROPSET      rgPropertySets[],
        CCredentials * pCredentials,
        IUnknown **    ppRowset
        )
{
    BOOL         fWarning = FALSE;
    CRowProvider *pRowProvider = NULL;
    DWORD        cAttrs = 1;
    BOOL         *pbMultiValue = NULL; 
    LPWSTR       *pAttrs = NULL;

    //
    // Check in-params and NULL out-params in case of error
    //
    if( ppRowset )
        *ppRowset = NULL;

    if( !pTableID && !pIndexID )
        RRETURN( E_INVALIDARG );

    if( pIndexID )
        RRETURN( DB_E_NOINDEX );

    //
    // Check the PropertySets
    //
    if( cPropertySets > 0 && !rgPropertySets )
        RRETURN ( E_INVALIDARG );

    for(ULONG i=0; i<cPropertySets; i++) {
        if( rgPropertySets[i].cProperties && !rgPropertySets[i].rgProperties )
            RRETURN ( E_INVALIDARG );
    }

    //
    // pwszName field represents the ADsPath of the Directory we have to open;
    // Make sure pwszName is meaningful
    //
    if( !pTableID ||  pTableID->eKind != DBKIND_NAME ||
        !pTableID->uName.pwszName || !(*(pTableID->uName.pwszName)) )
        RRETURN( DB_E_NOTABLE );

    if( pUnkOuter )//&& !InlineIsEqualGUID(riid, IID_IUnknown) )
        RRETURN( DB_E_NOAGGREGATION );

    if( riid == IID_NULL )
        RRETURN( E_NOINTERFACE );

    //
    // By default, we use credentials stored in member variable _Credentials
    // for binding. Buf if caller passed any credentials through pCredentials,
    // these take precedence. This also means that we need to store these
    // credentials in the CRowProvider object for future use -
    // e.g. GetRowFromHRow will use these credentials.
    //
    CCredentials * pCreds = &_Credentials;
    if( pCredentials )
        pCreds = pCredentials;

    //
    // If integrated security is being used, impersonate the caller
    //
    BOOL fImpersonating;

    fImpersonating = FALSE;
    if(_pDSO->IsIntegratedSecurity())
    {
        HANDLE ThreadToken = _pDSO->GetThreadToken();

        ASSERT(ThreadToken != NULL);
        if (ThreadToken)
        {
            if (!ImpersonateLoggedOnUser(ThreadToken))
                RRETURN(E_FAIL);
            fImpersonating = TRUE;
        }
        else
            RRETURN(E_FAIL);
    }

    HRESULT hr = GetDSInterface(
                    pTableID->uName.pwszName,
                    *pCreds,
                    IID_IDirectorySearch,
                    (void **)&_pDSSearch);

    if (fImpersonating)
    {
        RevertToSelf();
        fImpersonating = FALSE;
    }

    if( FAILED(hr) )
        RRETURN( hr );

    //
    // Get ColumnsInfo based on the list of attributes that we want to be
    // returned.  GetDefaultColumnInfo cleansup memory on failure.
    //
    ULONG          cColumns      = 0;
    DBCOLUMNINFO * prgInfo       = NULL;
    WCHAR *        pStringBuffer = NULL;

    hr = GetDefaultColumnInfo(&cColumns, &prgInfo, &pStringBuffer);
    if( FAILED(hr) )
        RRETURN( hr );

    // Store the properties (which must be in the rowset property group) in
    // the property object. OpenRowset is different from methods like
    // ICOmmand::SetProperties and ISessionProperties::SetProperties in that
    // it returns DB_E_ERROSOCCURRED if any property which is REQUIRED could
    // not be set and DB_S_ERROROCCURRED if any property that is OPTIONAL
    // could not be set. ICommand::SetProperties returns DB_E_ERROSOCCURRED
    // if all properties could not be set and DB_S_ERROSOCCURRED if some
    // property could not be set i.e, DBPROPOPTIONS (REQUIRED or OPTIONAL) is
    // ignored.

    // Use PROPSET_COMMAND as the bitmask below since the properties that are
    // going to be set are in the rowset property group. These properties that
    // are stored in the property object cannot be retrieved by the client
    // since GetProperties on a session object will only return properties in
    // the session property group.

    hr = _pUtilProp->SetProperties(
            cPropertySets,
            rgPropertySets,
            PROPSET_COMMAND
            );
    if( (DB_E_ERRORSOCCURRED == hr) || (DB_S_ERRORSOCCURRED == hr) )
    // check if a required property could not be set
    {
        ULONG i, j;

        for(i = 0; i < cPropertySets; i++)
            for(j = 0; j < rgPropertySets[i].cProperties; j++)
                if( rgPropertySets[i].rgProperties[j].dwStatus != 
                               DBPROPSTATUS_OK ) 
                    if( rgPropertySets[i].rgProperties[j].dwOptions != 
                               DBPROPOPTIONS_OPTIONAL ) 
                    {
                        BAIL_ON_FAILURE( hr = DB_E_ERRORSOCCURRED );
                    }
                    else
                        fWarning = TRUE;

        // if we get here, then there was all required properties were set 
        // successfully. However, hr could still be DB_ERRORSOCCURRED if all
        // properties were optional and all of them could not be set. This
        // condition is not an error for OpenRowset as noted in the comment 
        // above. Hence reset hr to S_OK.

        hr = S_OK;
    }

    // we still need to catch other errors like E_INAVLIDARG
    BAIL_ON_FAILURE(hr);

    hr = SetSearchPrefs();
    BAIL_ON_FAILURE( hr );

    //
    // Create RowProvider object to pass to rowset code
    //
    pbMultiValue = (BOOL *)AllocADsMem(sizeof(BOOL));
    pAttrs = (LPWSTR *)AllocADsMem(cAttrs * sizeof(LPWSTR));
    if( pAttrs )
        pAttrs[0] = AllocADsStr(L"ADsPath");

    if( !pAttrs || !pAttrs[0] || !pbMultiValue )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    *pbMultiValue = FALSE;

    // Is this an NDS path? If so, set filter appropriately. Fix for #286560.
    WCHAR lpszProgId[MAX_PATH];
    BOOL fIsNds;

    hr = CopyADsProgId(pTableID->uName.pwszName, lpszProgId);
    BAIL_ON_FAILURE( hr );
    if( !wcscmp(L"NDS", lpszProgId) )
        fIsNds = TRUE;
    else
        fIsNds = FALSE;

    //
    // AddRef the DSSearch interface.  If the CreateRowProvider function fails
    // then it releases the interface, otherwise it just stores it.
    //
    _pDSSearch->AddRef();
    hr = CRowProvider::CreateRowProvider(
                            _pDSSearch,
                            NULL,
                            pAttrs,
                            cAttrs,
                            cColumns,
                            prgInfo,
                            pStringBuffer,
                            IID_IRowProvider,
                            pbMultiValue,
                            TRUE,
                            pCreds,
                            (void **) &pRowProvider
                            );

    BAIL_ON_FAILURE( hr );

    //
    // RowProvider responsible for deallocation
    //
    pbMultiValue = NULL;

    hr= CRowset::CreateRowset(
            pRowProvider,
            (LPUNKNOWN)(IAccessor FAR *)this ,
            this,
            NULL,
            cPropertySets,
            rgPropertySets,
            0,
            NULL,
            TRUE,  // ADsPath is requested
            FALSE, // not all attributes are requested 
            riid,
            ppRowset
            );

    BAIL_ON_FAILURE( hr );

error:

    if( _pDSSearch ) {
        _pDSSearch->Release();
        _pDSSearch = NULL;
    }

    if( pRowProvider )
        pRowProvider->Release();

    if( prgInfo )
        _pIMalloc->Free(prgInfo);

    if( pStringBuffer )
        _pIMalloc->Free(pStringBuffer);

    if( pbMultiValue )
        FreeADsMem(pbMultiValue);

    if (pAttrs)
    {
        for (i = 0; i < cAttrs; i++)
        {
            if (pAttrs[i])
                FreeADsStr(pAttrs[0]);
        }
        FreeADsMem(pAttrs);
    }

    if( FAILED(hr) )
        RRETURN( hr );
    else if( fWarning )
        RRETURN( DB_S_ERRORSOCCURRED );
    else
        RRETURN( hr );
}


//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::GetProperties
//
//  Synopsis: Returns current settings of all properties in the DBPROPFLAGS_SESSION property
//            group
//
//  Arguments:
//              cPropertySets         count of restiction guids
//              rgPropertySets        restriction guids
//              pcProperties          count of properties returned
//              prgProperties         property information returned
//
//  Returns:
//              S_OK                    Session Object Interface returned
//              E_INVALIDARG            pcProperties or prgPropertyInfo was NULL
//              E_OUTOFMEMORY           Out of memory
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::GetProperties(
        ULONG        cPropIDSets,
        const        DBPROPIDSET rgPropIDSets[],
        ULONG *      pcPropSets,
        DBPROPSET ** pprgPropSets
        )
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // Check in-params and NULL out-params in case of error
    //
    HRESULT hr = _pUtilProp->GetPropertiesArgChk(
                                cPropIDSets,
                                rgPropIDSets,
                                pcPropSets,
                                pprgPropSets,
                                PROPSET_SESSION);
    if( FAILED(hr) )
        RRETURN( hr );

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->GetProperties(
                            cPropIDSets,
                            rgPropIDSets,
                            pcPropSets,
                            pprgPropSets,
                            PROPSET_SESSION) );
}


//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::SetProperties
//
//  Synopsis: Set properties in the DBPROPFLAGS_SESSION property group
//
//  Arguments:
//              cProperties
//              rgProperties
//
//  Returns:
//              S_OK             Session Object Interface returned
//              E_INVALIDARG     pcProperties or prgPropertyInfo was NULL
//              E_OUTOFMEMORY    Out of memory
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::SetProperties(
        ULONG     cPropertySets,
        DBPROPSET rgPropertySets[]
    )
{
    //
    // Asserts
    //
    ADsAssert(_pUtilProp);

    //
    // Just pass this call on to the utility object that manages our properties
    //
    RRETURN( _pUtilProp->SetProperties(
                            cPropertySets,
                            rgPropertySets,
                            PROPSET_SESSION) );
}

//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::CreateCommand
//
//  Synopsis: Creates a brand new command and returns requested interface
//
//  Arguments:
//              pUnkOuter           outer Unknown
//              riid,               IID desired
//              ppCommand           ptr to interface
//
//
//  Returns:
//              S_OK                Command Object Interface returned
//              E_INVALIDARG        ppCommand was NULL
//              E_NOINTERFACE       IID not supported
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::CreateCommand(
        IUnknown *  pUnkOuter,
        REFIID      riid,
        IUnknown ** ppCommand
    )
{
    CCommandObject* pCommand = NULL;
    HRESULT                     hr;

    //
    // check in-params and NULL out-params in case of error
    //
    if( ppCommand )
        *ppCommand = NULL;
    else
        RRETURN( E_INVALIDARG );

    if( pUnkOuter )//&& !InlineIsEqualGUID(riid, IID_IUnknown) )
        RRETURN( DB_E_NOAGGREGATION );

    //
    // open a CCommand object
    //
    pCommand = new CCommandObject(pUnkOuter);
    if( !pCommand )
        RRETURN( E_OUTOFMEMORY );

    //
    // initialize the object
    //
    if( !pCommand->FInit(this, _Credentials) ) {
        delete pCommand;
        RRETURN( E_OUTOFMEMORY );
    }

    //
    // get requested interface pointer on DBSession
    //
    hr = pCommand->QueryInterface(riid, (void **)ppCommand);
    if( FAILED( hr ) ) {
        delete pCommand;
        RRETURN( hr );
    }

    pCommand->Release();

    //
    // all went well
    //
    RRETURN( S_OK );
}



//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::GetDefaultColumnInfo
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::GetDefaultColumnInfo(
        ULONG *         pcColumns,
        DBCOLUMNINFO ** prgInfo,
        OLECHAR **      ppStringBuffer
    )
{
    //
    // Asserts
    //
    ADsAssert(_pIMalloc);
    ADsAssert(pcColumns);
    ADsAssert(prgInfo);
    ADsAssert(ppStringBuffer);

    //
    // Allcoate memory for the Bookmark and ADsPath column
    //
    *prgInfo = (DBCOLUMNINFO*)_pIMalloc->Alloc(2 * sizeof(DBCOLUMNINFO));
    *ppStringBuffer = (WCHAR*)_pIMalloc->Alloc((wcslen(L"ADsPath") + 1) * sizeof(WCHAR));

    //
    // Free memory on a failure
    //
    if( !(*prgInfo) || !(*ppStringBuffer))
    {
        if (*prgInfo)
        {
            _pIMalloc->Free(*prgInfo);
            *prgInfo = NULL;
        }
        if (*ppStringBuffer)
        {
            _pIMalloc->Free(*ppStringBuffer);
            *ppStringBuffer = NULL;
        }

        RRETURN( E_OUTOFMEMORY );
    }

    //
    // Initialize the memory
    //
    ZeroMemory(*prgInfo, 2 * sizeof(DBCOLUMNINFO));
    ZeroMemory(*ppStringBuffer, (wcslen(L"ADsPath") + 1) * sizeof(WCHAR));
    wcscpy(*ppStringBuffer, OLESTR("ADsPath"));

    //
    // Fill up the Bookmark column
    //
    *pcColumns = 2;

    (*prgInfo)[0].pwszName                = NULL;
    (*prgInfo)[0].pTypeInfo               = NULL;
    (*prgInfo)[0].iOrdinal                = 0;
    (*prgInfo)[0].ulColumnSize            = sizeof(ULONG);
    (*prgInfo)[0].wType                   = DBTYPE_UI4;
    (*prgInfo)[0].bPrecision              = 10;
    (*prgInfo)[0].bScale                  = (BYTE) ~ 0;
    (*prgInfo)[0].columnid.eKind          = DBKIND_GUID_PROPID;
    (*prgInfo)[0].columnid.uGuid.guid     = DBCOL_SPECIALCOL;
    (*prgInfo)[0].columnid.uName.ulPropid = 2;
    (*prgInfo)[0].dwFlags                 = DBCOLUMNFLAGS_ISBOOKMARK |
                                            DBCOLUMNFLAGS_ISFIXEDLENGTH;
    //
    // Fill up the ADsPath column
    //
    (*prgInfo)[1].pwszName                = *ppStringBuffer;
    (*prgInfo)[1].pTypeInfo               = NULL;
    (*prgInfo)[1].iOrdinal                = 1;
    (*prgInfo)[1].ulColumnSize            = (ULONG)256;
    (*prgInfo)[1].wType                   = DBTYPE_WSTR|DBTYPE_BYREF;
    (*prgInfo)[1].bPrecision              = (BYTE) ~ 0;
    (*prgInfo)[1].bScale                  = (BYTE) ~ 0;
    (*prgInfo)[1].columnid.eKind          = DBKIND_NAME;
    (*prgInfo)[1].columnid.uName.pwszName = *ppStringBuffer;
    (*prgInfo)[1].columnid.uGuid.guid     = GUID_NULL;
    (*prgInfo)[1].dwFlags                 = DBCOLUMNFLAGS_ISNULLABLE;

    RRETURN( S_OK );
}

#if (!defined(BUILD_FOR_NT40))
//IBindResource::Bind
//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::CSessionObject
//
//  Synopsis: Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    09-17-1998   mgorti     Created.
//
//----------------------------------------------------------------------------
HRESULT CSessionObject::Bind(
    IUnknown *              punkOuter,
    LPCOLESTR               pwszURL,
    DBBINDURLFLAG           dwBindFlags,
    REFGUID                 rguid,
    REFIID                  riid,
    IAuthenticate *         pAuthenticate,
    DBIMPLICITSESSION *     pImplSession,
    DWORD *                 pdwBindStatus,
    IUnknown **             ppUnk
    )
{
    HRESULT         hr = S_OK;
    CComBSTR        bstrNewURL;

	TRYBLOCK
    
		//Initialize return arguments
        if (pdwBindStatus)
            *pdwBindStatus = 0;

        if (ppUnk)
            *ppUnk = NULL;

        if (pImplSession)
            pImplSession->pSession = NULL;

        //if caller passed a null value for dwBindFlags,
        //get them from initialization properties.
        if (dwBindFlags == 0)
            dwBindFlags = BindFlagsFromDbProps();

        //Generic argument validation
        hr = ValidateBindArgs(punkOuter,
                pwszURL,
                dwBindFlags,
                rguid,
                riid,
                pAuthenticate,
                pImplSession,
                pdwBindStatus,
                ppUnk);

        BAIL_ON_FAILURE(hr);

        //Fill in the pImplSession struct.
        if (pImplSession)
        {
            // Our session doesn't support aggregation.
            if (pImplSession->pUnkOuter != NULL)
                BAIL_ON_FAILURE(hr = DB_E_NOAGGREGATION);

            hr = QueryInterface(*pImplSession->piid,
                                (void**)&(pImplSession->pSession));
            if (FAILED(hr))
                BAIL_ON_FAILURE(hr = E_NOINTERFACE );
        }

        //Specific validation checks
        //We are currently a read-only provider
        if (dwBindFlags & DBBINDURLFLAG_WRITE)
            BAIL_ON_FAILURE(hr = DB_E_READONLY);

        //We currently don't support aggregation
        if (punkOuter != NULL)
            BAIL_ON_FAILURE (hr = DB_E_NOAGGREGATION);

        //We don't support the following flags
        if (dwBindFlags & DBBINDURLFLAG_ASYNCHRONOUS)
            BAIL_ON_FAILURE(hr = DB_E_ASYNCNOTSUPPORTED);

        if (dwBindFlags & DBBINDURLFLAG_OUTPUT              ||
            dwBindFlags & DBBINDURLFLAG_RECURSIVE           ||
            dwBindFlags & DBBINDURLFLAG_DELAYFETCHSTREAM    ||
            dwBindFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS)
            BAIL_ON_FAILURE(hr = E_INVALIDARG);

        //Now Try to Bind.
        if (InlineIsEqualGUID(rguid, DBGUID_ROW) ||
            InlineIsEqualGUID(rguid, DBGUID_ROWSET))
        {
            //If the URL is not absolute, build the absolute URL
            //using the DBPROP_INIT_PROVIDERSTRING.
            if (! bIsAbsoluteURL(pwszURL))
            {
                hr = BuildAbsoluteURL (pwszURL, bstrNewURL);
                if (FAILED(hr))
                    BAIL_ON_FAILURE(hr = E_INVALIDARG);
            }
            else
                bstrNewURL = pwszURL;

            if ( InlineIsEqualGUID(rguid, DBGUID_ROW) )
            {
                hr = BindToRow(punkOuter,
                               (PWCHAR)bstrNewURL,
                               pAuthenticate,
                               dwBindFlags,
                               riid,
                               ppUnk);
            }
            else
            {
                hr = BindToRowset(punkOuter,
                                  (PWCHAR)bstrNewURL,
                                  pAuthenticate,
                                  dwBindFlags,
                                  riid,
                                  ppUnk);
            }

            BAIL_ON_FAILURE(hr);
        }
        else if (InlineIsEqualGUID(rguid, DBGUID_DSO))
        {
            ADsAssert(_pDSO);
            hr = BindToDataSource(
                            punkOuter,
                            pwszURL,
                            pAuthenticate,
                            dwBindFlags,
                            riid,
                            ppUnk
                    );
            BAIL_ON_FAILURE (hr);
        }
        else if (InlineIsEqualGUID(rguid, DBGUID_SESSION))
        {
            hr = QueryInterface(riid, (void**)ppUnk);
            BAIL_ON_FAILURE (hr);
        }
        else
            BAIL_ON_FAILURE(hr = E_INVALIDARG);

        //Fix for bug Raid-X5#83386 - spec change
        //If caller specified any DENY semantics,
        //set warning status and return value, since
        //we don't support these.
        if (dwBindFlags & DBBINDURLFLAG_SHARE_DENY_READ ||
            dwBindFlags & DBBINDURLFLAG_SHARE_DENY_WRITE ||
            dwBindFlags & DBBINDURLFLAG_SHARE_EXCLUSIVE)
        {
            if (pdwBindStatus)
                *pdwBindStatus = DBBINDURLSTATUS_S_DENYNOTSUPPORTED;
            BAIL_ON_FAILURE (hr = DB_S_ERRORSOCCURRED);
        }
	
	CATCHBLOCKBAIL(hr)

error:

    RRETURN(hr);
}

#endif

//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::CSessionObject
//
//  Synopsis: Constructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CSessionObject::CSessionObject(
        LPUNKNOWN pUnkOuter
    )
{
    //
    // Initialize simple member vars
    //
    _pUnkOuter     = pUnkOuter ? pUnkOuter : (IGetDataSource FAR *)this;
    _cCommandsOpen = 0;
    _pUtilProp     = NULL;
    _pDSSearch     = NULL;
    _pIMalloc      = NULL;
    _pDSO          = NULL;

    ENLIST_TRACKING(CSessionObject);
}


//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::~CSessionObject
//
//  Synopsis: Destructor
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
CSessionObject::~CSessionObject( )
{
    //
    // Free properties management object
    //
    delete _pUtilProp;

    if( _pIMalloc )
        _pIMalloc->Release();

    if( _pDSO ) {
        _pDSO->DecrementOpenSessions();
        _pDSO->Release();
    }
}

//+---------------------------------------------------------------------------
//
//  Function:  CSessionObject::FInit
//
//  Synopsis:  Initialize the session Object
//
//  Arguments:
//
//  Returns:
//             TRUE              Initialization succeeded
//             FALSE             Initialization failed
//
//  Modifies:
//
//  History:    08-28-96   ShankSh     Created.
//
//----------------------------------------------------------------------------
BOOL CSessionObject::FInit(
        CDSOObject *   pDSO,
        CCredentials & Credentials
        )
{
    HRESULT hr;

    //
    // Asserts
    //
    ADsAssert(pDSO);
    ADsAssert(&Credentials);

    //
    // Allocate properties management object
    //
    _pUtilProp = new CUtilProp();
    if( !_pUtilProp )
        return FALSE;

    hr = _pUtilProp->FInit(&Credentials);
    BAIL_ON_FAILURE(hr);

    //
    // IMalloc->Alloc is the way we have to allocate memory for out parameters
    //
    hr = CoGetMalloc(MEMCTX_TASK, &_pIMalloc);
    BAIL_ON_FAILURE(hr);

    //
    // Establish parent object pointer
    //
    _pDSO = pDSO;
    _Credentials = Credentials;
    _pDSO->AddRef();
    _pDSO->IncrementOpenSessions();

    return( TRUE );

error:

    RRETURN( FALSE );
}

STDMETHODIMP
CSessionObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if( ppv == NULL )
        RRETURN( E_INVALIDARG );

    if( IsEqualIID(iid, IID_IUnknown) ) {
        *ppv = (IGetDataSource FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IGetDataSource) ) {
        *ppv = (IGetDataSource FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IOpenRowset) ) {
        *ppv = (IOpenRowset FAR *) this;
    }
    else if( IsEqualIID(iid, IID_ISessionProperties) ) {
        *ppv = (ISessionProperties FAR *) this;
    }
    else if( IsEqualIID(iid, IID_IDBCreateCommand) ) {
        *ppv = (IDBCreateCommand FAR *) this;
    }
#if (!defined(BUILD_FOR_NT40))
    else if( IsEqualIID(iid, IID_IBindResource) ) {
        *ppv = (IBindResource FAR *) this;
    }
#endif
    else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

#if (!defined(BUILD_FOR_NT40))
//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::ValidateBindArgs
//
//  Synopsis: Validates IBindResource::Bind function arguments.
//
//----------------------------------------------------------------------------
HRESULT CSessionObject::ValidateBindArgs(
    IUnknown *              punkOuter,
    LPCOLESTR               pwszURL,
    DBBINDURLFLAG           dwBindFlags,
    REFGUID                 rguid,
    REFIID                  riid,
    IAuthenticate *         pAuthenticate,
    DBIMPLICITSESSION *     pImplSession,
    DWORD *                 pdwBindStatus,
    IUnknown **             ppUnk
    )
{
    //General validation checks.
    if (pwszURL == NULL || InlineIsEqualGUID(rguid,GUID_NULL) ||
        InlineIsEqualGUID(riid, GUID_NULL) || ppUnk == NULL )
        RRETURN(E_INVALIDARG);

    if (pImplSession &&
        (pImplSession->pUnkOuter == NULL || pImplSession->piid == NULL))
        RRETURN(E_INVALIDARG);

    if (punkOuter && !InlineIsEqualGUID(riid, IID_IUnknown))
        RRETURN(DB_E_NOAGGREGATION);

    if (pImplSession && pImplSession->pUnkOuter &&
        pImplSession->piid &&
        !InlineIsEqualGUID(*pImplSession->piid, IID_IUnknown))
        RRETURN(DB_E_NOAGGREGATION);

    if (dwBindFlags & DBBINDURLFLAG_RECURSIVE)
    {
        //if DBBINDURLFLAG_RECURSIVE is set, at least one of the SHARE_DENY
        //flags must have been set.
        if (! ( (dwBindFlags & DBBINDURLFLAG_SHARE_DENY_READ) ||
                (dwBindFlags & DBBINDURLFLAG_SHARE_DENY_WRITE) ||
                (dwBindFlags & DBBINDURLFLAG_SHARE_EXCLUSIVE)
                )
                )
            RRETURN(E_INVALIDARG);
    }

    if (!(dwBindFlags & DBBINDURLFLAG_READ) &&
        !(dwBindFlags & DBBINDURLFLAG_WRITE) ) {
        // Must have either read or write access:
        RRETURN(E_INVALIDARG);
    }

    if (InlineIsEqualGUID(rguid, DBGUID_DSO) &&
        !((dwBindFlags & DBBINDURLFLAG_READ) ||
          (dwBindFlags & DBBINDURLFLAG_ASYNCHRONOUS) ||
          (dwBindFlags & DBBINDURLFLAG_WAITFORINIT)
         )
       )
       //if object type is DataSource, only the above flags are allowed
       RRETURN(E_INVALIDARG);

    if (InlineIsEqualGUID(rguid, DBGUID_SESSION) &&
        ! (dwBindFlags == DBBINDURLFLAG_READ))
        //if object type is Session, only DBBINDURLFLAG_READ is allowed
        RRETURN(E_INVALIDARG);

    if (InlineIsEqualGUID(rguid, DBGUID_ROWSET) &&
        ((dwBindFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS) ||
         (dwBindFlags & DBBINDURLFLAG_DELAYFETCHSTREAM)
        )
       )
       //if object type is Rowset, DELAYFETCHCOLUMNS and DELAYFETCHSTREAM
       //flags are disallowed.
       RRETURN ( E_INVALIDARG );

    if (InlineIsEqualGUID(rguid, DBGUID_STREAM) &&
        ((dwBindFlags & DBBINDURLFLAG_DELAYFETCHCOLUMNS) ||
         (dwBindFlags & DBBINDURLFLAG_DELAYFETCHSTREAM)
        )
       )
       //if object type is Stream, DELAYFETCHCOLUMNS and
       //DELAYFETCHSTREAM flags are disallowed.
       RRETURN(E_INVALIDARG);

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::BindToRow
//
//  Synopsis: Given a URL, binds to that row object and returns the requested
//            interface.
//
//----------------------------------------------------------------------------
HRESULT
CSessionObject::BindToRow(
    IUnknown *punkOuter,
    LPCOLESTR pwszURL,
    IAuthenticate *pAuthenticate,
    DWORD dwBindFlags,
    REFIID riid,
    IUnknown** ppUnk
    )
{
    CComObject<CRow>        *pRow = NULL;
    auto_rel<IUnknown>      pSession;
    auto_rel<IRow> pRowDelete;
    HRESULT hr = S_OK;

    hr = CComObject<CRow>::CreateInstance(&pRow);
    if (FAILED(hr))
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    //To make sure we delete the row object in
    //case we encounter errors after this point.
    //Note: this version of auto_rel doesn't addref on assignment.
    pRowDelete = pRow;
    pRowDelete->AddRef();

    hr = QueryInterface(__uuidof(IUnknown), (void **)&pSession);
    if (FAILED(hr))
        BAIL_ON_FAILURE(hr = E_FAIL);

    //Initialize row and bind it to a Directory Object.
    hr = pRow->Initialize((PWSTR)pwszURL,
                    (IUnknown *)pSession,
                    pAuthenticate,
                    dwBindFlags,
                    FALSE, // not a tearoff 
                    FALSE, // don't get column info. from rowset 
                    &_Credentials,
                    true);

    if (FAILED(hr))
    {
        if (INVALID_CREDENTIALS_ERROR(hr))
        {
            BAIL_ON_FAILURE(hr = DB_SEC_E_PERMISSIONDENIED);
        }
        else
        {
            BAIL_ON_FAILURE(hr = DB_E_NOTFOUND);
        }
    }

    hr = pRow->QueryInterface(riid, (void**)ppUnk);
    if (FAILED(hr))
        BAIL_ON_FAILURE (hr = E_NOINTERFACE);

error:

    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::BindToRowset
//
//  Synopsis: Given a URL, binds to a rowset object that has all its child
//            nodes as rows and returns the requested interface on the rowset.
//
//----------------------------------------------------------------------------
HRESULT
CSessionObject::BindToRowset(
    IUnknown *pUnkOuter,
    LPCOLESTR pwszURL,
    IAuthenticate *pAuthenticate,
    DWORD dwBindFlags,
    REFIID riid,
    IUnknown** ppUnk
    )
{
    HRESULT hr;
    DWORD fAuthFlags;

    DBID tableID;
    tableID.eKind = DBKIND_NAME;
    tableID.uName.pwszName = (LPWSTR) pwszURL;

    //Create the rowset.

    // Fix for 351040. First try explicit credentials, then session object's
    // credentials, then default credentials. 

    if(pAuthenticate)
    {
        CCredentials creds;

        hr = GetCredentialsFromIAuthenticate(pAuthenticate, creds);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = E_INVALIDARG);

        fAuthFlags = creds.GetAuthFlags();
        creds.SetAuthFlags(fAuthFlags |
                        ADS_SECURE_AUTHENTICATION);

        hr = OpenRowsetWithCredentials(pUnkOuter, &tableID, NULL, riid, 
                                       0, NULL, &creds, ppUnk); 
    }

    if( (!pAuthenticate) || (INVALID_CREDENTIALS_ERROR(hr)) )
    // try credentials in session object
        hr = OpenRowset(pUnkOuter, &tableID, NULL, riid, 0, NULL, ppUnk);

    if(INVALID_CREDENTIALS_ERROR(hr))
    // try default credentials
    {
        CCredentials creds; // default credentials

        fAuthFlags = creds.GetAuthFlags();
        creds.SetAuthFlags(fAuthFlags |
                        ADS_SECURE_AUTHENTICATION);

        hr = OpenRowsetWithCredentials(pUnkOuter, &tableID, NULL, riid,
                                       0, NULL, &creds, ppUnk); 
    }

    BAIL_ON_FAILURE(hr);

    RRETURN ( S_OK );

error:
    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::BindFlagsFromDbProps
//
//  Synopsis: Synthesizes bind flags from initialization properties
//            DBPROP_INIT_MODE and DBPROP_INIT_BINDFLAGS
//
//----------------------------------------------------------------------------
DWORD CSessionObject::BindFlagsFromDbProps()
{
    HRESULT hr = S_OK;
    auto_rel<IDBProperties> pDBProp;
    ULONG   i, j, cPropertySets = 0;
    DWORD dwMode = 0, dwBindFlags = 0, dwBindFlagProp = 0;
    DWORD dwResult = 0;

    hr = GetDataSource(__uuidof(IDBProperties), (IUnknown **)&pDBProp);
    BAIL_ON_FAILURE(hr);

    DBPROPID  propids[2];
    propids[0] = DBPROP_INIT_MODE;
    propids[1] = DBPROP_INIT_BINDFLAGS;

    DBPROPIDSET rgPropertyIDSets[1];
    rgPropertyIDSets[0].rgPropertyIDs = propids;
    rgPropertyIDSets[0].cPropertyIDs = 2;
    rgPropertyIDSets[0].guidPropertySet = DBPROPSET_DBINIT;

    DBPROPSET *prgPropertySets;
    hr = pDBProp->GetProperties(
                            1,
                            rgPropertyIDSets,
                            &cPropertySets,
                            &prgPropertySets);

    if (hr == DB_E_ERRORSOCCURRED)
        BAIL_ON_FAILURE(hr);

    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &prgPropertySets[i].rgProperties[j];
            ADsAssert(pProp);
            if (pProp->dwStatus == S_OK &&
                pProp->dwPropertyID == DBPROP_INIT_MODE)
                dwMode = V_I4(&pProp->vValue);
            else if (pProp->dwStatus == S_OK &&
                    pProp->dwPropertyID == DBPROP_INIT_BINDFLAGS)
                dwBindFlagProp = V_I4(&pProp->vValue);
            else
                continue;
        }
    }

    //Now extract bind flags from dwMode and dwBindFlagProp
    {
        DWORD dwModeMask      =
                DB_MODE_READ |
                DB_MODE_WRITE |
                DB_MODE_READWRITE |
                DB_MODE_SHARE_DENY_READ |
                DB_MODE_SHARE_DENY_WRITE |
                DB_MODE_SHARE_EXCLUSIVE |
                DB_MODE_SHARE_DENY_NONE;

        dwResult |= dwMode & dwModeMask;

        if ( dwBindFlagProp & DB_BINDFLAGS_DELAYFETCHCOLUMNS ) {
            dwBindFlags |= DBBINDURLFLAG_DELAYFETCHCOLUMNS;
        }
        if ( dwBindFlagProp & DB_BINDFLAGS_DELAYFETCHSTREAM ) {
            dwBindFlags |= DBBINDURLFLAG_DELAYFETCHSTREAM;
        }
        if ( dwBindFlagProp & DB_BINDFLAGS_RECURSIVE ) {
            dwBindFlags |= DBBINDURLFLAG_RECURSIVE;
        }
        if ( dwBindFlagProp & DB_BINDFLAGS_OUTPUT ) {
            dwBindFlags |= DBBINDURLFLAG_OUTPUT;
        }

        dwResult |= dwBindFlagProp | dwBindFlags;
    }

error:
    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            ADsAssert(pProp);
            FreeDBID(&pProp->colid);
            VariantClear(&pProp->vValue);
        }

        CoTaskMemFree(prgPropertySets[i].rgProperties);
    }
    CoTaskMemFree(prgPropertySets);

    RRETURN ( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::BindToDataSource
//
//  Synopsis: Initializes the DataSource object if necessary, Sets
//            DBPROP_INIT_PROVIDERSTRING property and returns the requested
//            interface on the datasource.
//
//----------------------------------------------------------------------------
HRESULT
CSessionObject::BindToDataSource(
    IUnknown *pUnkOuter,
    LPCOLESTR pwszURL,
    IAuthenticate *pAuthenticate,
    DWORD dwBindFlags,
    REFIID riid,
    IUnknown** ppUnk
    )
{
    HRESULT                 hr = S_OK;
    auto_rel<IDBProperties> pDBProperties;
    DBPROP                  props[1];
    DBPROPSET               rgPropertySets[1];
    CComBSTR                bstrURL(pwszURL);

    //Initialize DBPROP_INIT_PROVIDERSTRING only if the
    //URL is absolute.
    if (bIsAbsoluteURL (pwszURL))
    {
        // Check if the datasource has already been initialized.
        if (_pDSO->IsInitialized())
            BAIL_ON_FAILURE(hr = DB_E_ALREADYINITIALIZED);
            
        props[0].dwPropertyID = DBPROP_INIT_PROVIDERSTRING;
        props[0].dwOptions = DBPROPOPTIONS_OPTIONAL;
        props[0].vValue.vt = VT_BSTR;
        props[0].vValue.bstrVal = (PWCHAR)bstrURL;

        rgPropertySets[0].rgProperties = props;
        rgPropertySets[0].cProperties = 1;
        rgPropertySets[0].guidPropertySet = DBPROPSET_DBINIT;

        hr = GetDataSource(
                __uuidof(IDBProperties),
                (IUnknown **)&pDBProperties
        );
        BAIL_ON_FAILURE(hr);

        hr = pDBProperties->SetProperties(1, rgPropertySets);
        BAIL_ON_FAILURE(hr);
    }
    //  If consumer doesn't specify DBBINDURLFLAG_WAITFORINIT, it
    //  means consumer wants an initialized DSO
    //
    if (! (dwBindFlags & DBBINDURLFLAG_WAITFORINIT))
    {
        auto_rel<IDBInitialize> pDBInitialize;

        hr = GetDataSource(__uuidof(IDBInitialize), (IUnknown **)&pDBInitialize);
        BAIL_ON_FAILURE(hr);

        hr = pDBInitialize->Initialize();
        BAIL_ON_FAILURE(hr);
    }

    //Return the requested interface on the DSO.
    hr = GetDataSource(riid, ppUnk);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN ( hr );
}

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::BuildAbsoluteURL
//
//  Synopsis: Given a relative URL, builds absolute URL using the relative URL
//            and the property DBPROP_INIT_PROVIDERSTRING.
//
//----------------------------------------------------------------------------
HRESULT
CSessionObject::BuildAbsoluteURL(
    CComBSTR       bstrLeaf,
    CComBSTR&      bstrAbsoluteURL
    )
{
    HRESULT                 hr = S_OK;
    auto_rel<IDBProperties> pDBProp;
    auto_rel<IADsPathname>  pPathParent;
    auto_rel<IADsPathname>  pPathLeaf;
    ULONG                   cPropertySets = 0;
    long                    i, j, cElements = 0;
    CComBSTR                bstrParent;
    DBPROPSET*              prgPropertySets = NULL;
    DBPROPID                propids[1];
    DBPROPIDSET             rgPropertyIDSets[1];

    hr = GetDataSource(__uuidof(IDBProperties), (IUnknown **)&pDBProp);
    BAIL_ON_FAILURE(hr);

    propids[0] = DBPROP_INIT_PROVIDERSTRING;

    rgPropertyIDSets[0].rgPropertyIDs = propids;
    rgPropertyIDSets[0].cPropertyIDs = 1;
    rgPropertyIDSets[0].guidPropertySet = DBPROPSET_DBINIT;

    hr = pDBProp->GetProperties(
                            1,
                            rgPropertyIDSets,
                            &cPropertySets,
                            &prgPropertySets);

    if (SUCCEEDED(hr) && cPropertySets == 1)
    {
        ADsAssert(prgPropertySets != NULL);
        ADsAssert(prgPropertySets[0].rgProperties != NULL);

        DBPROP* pProp = & (prgPropertySets[0].rgProperties[0]);

        bstrParent = pProp->vValue.bstrVal;
    }

    // Build Absolute Path from Parent and leaf.

    hr = CPathname::CreatePathname(
            __uuidof(IADsPathname),
            (void **)&pPathParent
            );
    BAIL_ON_FAILURE(hr);

    hr = pPathParent->Set(bstrParent, ADS_SETTYPE_FULL);
    BAIL_ON_FAILURE(hr);

    if (bstrLeaf.Length() > 0)
    {
        hr = CPathname::CreatePathname(
                __uuidof(IADsPathname),
                (void **)&pPathLeaf
                );
        BAIL_ON_FAILURE(hr);

        hr = pPathLeaf->Set(bstrLeaf, ADS_SETTYPE_DN);
        BAIL_ON_FAILURE(hr);

        hr = pPathLeaf->GetNumElements(&cElements);
        BAIL_ON_FAILURE(hr);

        //Add leaf elements in reverse order.
        //Ex: if bstrLeaf = "CN=Administrator,CN=Users",
        //we add CN=Users first.
        for (i = cElements-1; i >= 0; i--)
        {
            CComBSTR bstrElement;
            hr = pPathLeaf->GetElement(i, &bstrElement);
            BAIL_ON_FAILURE(hr);

            hr = pPathParent->AddLeafElement(bstrElement);
            BAIL_ON_FAILURE(hr);
        }
    }
    //Read back the fully built path name
    hr = pPathParent->Retrieve(ADS_FORMAT_X500, &bstrAbsoluteURL);
    BAIL_ON_FAILURE(hr);

error:
    // Free memory allocated by GetProperties
    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            ADsAssert(pProp);

            // We should free the DBID in pProp, but we know that
            // GetProperties always returns DB_NULLID and FreeDBID doesn't
            //  handle DB_NULLID. So, DBID is not freed here.

            VariantClear(&pProp->vValue);
        }

        CoTaskMemFree(prgPropertySets[i].rgProperties);
    }
    CoTaskMemFree(prgPropertySets);

    RRETURN(hr);
}

extern PROUTER_ENTRY g_pRouterHead;
extern CRITICAL_SECTION g_csRouterHeadCritSect;

//+---------------------------------------------------------------------------
//
//  Function: CSessionObject::bIsAbsoluteURL
//
//  Synopsis: If the given URL starts with any of the ADS provider prefixes,
//            returns true. Returns false otherwise.
//
//----------------------------------------------------------------------------
bool
CSessionObject::bIsAbsoluteURL( LPCOLESTR pwszURL)
{
    if (pwszURL == NULL)
        return false;

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);


    for (PROUTER_ENTRY pProvider = g_pRouterHead;
         pProvider != NULL;
         pProvider = pProvider->pNext)
    {
        if (pProvider->szProviderProgId == NULL)
            continue;

        size_t strSize = wcslen(pProvider->szProviderProgId);
        
        if ( _wcsnicmp(pwszURL, pProvider->szProviderProgId, strSize) == 0 )
            return true;
    }

    // Given URL doesn't start with any of the ADSI provider prefixes.
    return false;
}

#endif

//-----------------------------------------------------------------------------
// SetSearchPrefs
//
// Sets ADSI search preferences on the property object.
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CSessionObject::SetSearchPrefs(
        void
        )
{
    PROPSET              *pPropSet;
    PADS_SEARCHPREF_INFO  pSearchPref = NULL;
    HRESULT               hr = S_OK;
    ULONG                 i;

    //
    // Asserts
    //
    ADsAssert(_pUtilProp);
    ADsAssert(_pDSSearch);

    pPropSet = _pUtilProp->GetPropSetFromGuid(DBPROPSET_ADSISEARCH);

    if( !pPropSet || !pPropSet->cProperties )
        RRETURN( S_OK );

    pSearchPref = (PADS_SEARCHPREF_INFO) AllocADsMem(
                                                 pPropSet->cProperties *
                                                 sizeof(ADS_SEARCHPREF_INFO)
                                                 );
    if( !pSearchPref )
        BAIL_ON_FAILURE( hr=E_OUTOFMEMORY );

    for (i=0; i<pPropSet->cProperties; i++) {
        hr = _pUtilProp->GetSearchPrefInfo(
                             pPropSet->pUPropInfo[i].dwPropertyID,
                             &pSearchPref[i]
                                                         );
        BAIL_ON_FAILURE( hr );
    }

    hr = _pDSSearch->SetSearchPreference(
                                pSearchPref,
                                pPropSet->cProperties
                                );

    _pUtilProp->FreeSearchPrefInfo(pSearchPref, pPropSet->cProperties);

    BAIL_ON_FAILURE( hr );

error:

    if( pSearchPref )
        FreeADsMem(pSearchPref);

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\crsinfo.cxx ===
//-----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       CRSInfo.cxx
//
//  Contents:   IRowsetInfo and IGetRow methods 
//
//  Functions:
//
//  Notes:
//
//
//  History:    08/30/96  | RenatoB   | Created
//----------------------------------------------------------------------------


//-----------------------------------------------------------------------------
// @class CRowsetInfo | embedding of Rowset,
//  to give our IrowsetInfo interface
//
//
//-----------------------------------------------------------------------------
// Includes
#include "oleds.hxx"
#include "atl.h"
#include "row.hxx"

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::QueryInterface
//
//  Synopsis:  @mfunc QueryInterface.
//
//  Update: This function should never be called as RowsetInfo is now contained
//  in CRowset.
//
//-----------------------------------------------------------------------.
HRESULT
CRowsetInfo::QueryInterface(
        REFIID   riid,
        LPVOID * ppv
        )
{
    ADsAssert(FALSE);

    RRETURN( E_INVALIDARG );
}

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::CRowsetInfo
//
//  Synopsis:  @mfunc Ctor
//
//  Arguments:
//
//
//  Returns:    @rdesc NONE
//
//  Modifies:
//
//  History:    08/30/96   RenatoB          Created
//
//----------------------------------------------------------------------------
CRowsetInfo::CRowsetInfo(
        IUnknown *       pUnkOuter,      // controlling unknown)
        IUnknown *       pParentObject,  // RowProvider
        CSessionObject * pCSession,      // Session that created rowset
        CCommandObject * pCCommand,      // Command object that created rowset
        CRowProvider *   pRowProvider    // Row provider pointer
   )
{
    //
    // Asserts
    //
    ADsAssert(pRowProvider);

    _pUnkOuter     = (pUnkOuter == NULL) ? (IRowsetInfo FAR *)this : pUnkOuter;
    _pRowset       = NULL;
    _pParentObject = pParentObject;
    _pCSession     = pCSession;
    _pCCommand     = pCCommand;

    // AddRef twice - once for command/session object, once for parent object
    if( NULL == _pCCommand )
    {
        _pCSession->AddRef();
        _pCSession->AddRef();
    }
    else if( NULL == _pCSession )
    {
        _pCCommand->AddRef();
        _pCCommand->AddRef();
    }
    else // shouldn't get here
        ADsAssert(FALSE);

    _pRowProvider  = pRowProvider;
    _pRowProvider->AddRef();

    _pMalloc       = NULL;

    if( _pCCommand != NULL )
        _pCCommand->IncrementOpenRowsets();

    _fCriticalSectionInitialized = FALSE;

}


//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::~CRowsetInfo
//
//  Synopsis:  @mfunc Dtor
//
//  Arguments:
//
//
//  Returns:    @rdesc NONE
//
//  Modifies:
//
//  History:    08/30/96   RenatoB          Created
//
//----------------------------------------------------------------------------
CRowsetInfo::~CRowsetInfo()
{
    if( _pMalloc != NULL )
        _pMalloc->Release();

    if( _pCCommand != NULL ) {
        _pCCommand->DecrementOpenRowsets();
        _pCCommand->Release();
    }

    if( _pCSession != NULL ) {
        _pCSession->Release();
        }

    if( _pParentObject != NULL ) {
        _pParentObject->Release();
        }

    if( _pRowProvider != NULL ) {
        _pRowProvider->Release();
        }

    if (_fCriticalSectionInitialized) {
        DeleteCriticalSection(&_csRowsetInfo);
        }
}

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::FInit
//
//  Synopsis:  @mfunc Initializer
//
//  Synopsis:  @mfunc Initializer
//
//  Arguments:
//
//
//  Returns:    @rdesc NONE
//    @flag S_OK              | Interface is supported
//        @flag E_OUTOFMEMORY | Not enough memory 
//        @flag E_INVALIDARG  | One or more arguments are invalid.
//
//  Modifies:
//
//  History:    08/30/96   RenatoB          Created
//
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::FInit(
        IUnknown * pRowset)          // rowset interface
{
    HRESULT hr;
    hr = S_OK;

    //
    // InitializeCriticalSection can throw exceptions under low memory conditions.
    // Catch any exceptions and handle them.
    //
    try
    {
        //this section is for IRowsetInfo and IUnknown methods.
        InitializeCriticalSection(&_csRowsetInfo);
        _fCriticalSectionInitialized = TRUE;
    }
    catch(...)
    {
        RRETURN( E_FAIL );
    }

    if( FAILED(CoGetMalloc(MEMCTX_TASK, &_pMalloc)) )
        RRETURN( E_OUTOFMEMORY );

    // Should not AddRef here because RowsetInfo is contained in CRowset
    _pRowset = pRowset;

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetReferencedRowset
//
//  Synopsis:  @mfunc Returns an interface pointer to the rowset to which a bookmark applies
//
//             Called by: Client
//             Called when: Any time
//
//  Arguments:
//     iOrdinal          [in]  Bookmark column for which to get related rowset. Must be 0 in this impl.
//     riid              [in] IID of the interface pointer to return in *ppReferencedRowset.
//     ppReferencedRowset[out] pointer to  Rowset object referenced by Bookmark
//
//
//  Returns:    @rdesc NONE
//        S_OK                    | Interface is supported
//        E_INVALIDARG            | ppReferencedRowset was a NULL pointer
//        E_FAIL                  | provider specific error
//        E_NOINTERFACE           | Rowset does not support interface
//        DB_E_NOTAREFENCEDCOLUMN | iOrdinal was not 0
//
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::GetReferencedRowset(
    DBORDINAL   iOrdinal,
    REFIID      riid,
    IUnknown ** ppReferencedRowset
    )
{
    CAutoBlock cab (&_csRowsetInfo);

    //
    // Asserts
    //
    ADsAssert(_pRowProvider);
    ADsAssert(_pRowset);

    if( ppReferencedRowset == NULL )
        RRETURN( E_INVALIDARG );

    *ppReferencedRowset = NULL;

    if( iOrdinal >= _pRowProvider->GetColumnCount() )
        RRETURN( DB_E_BADORDINAL );

    if( iOrdinal != 0 )
        RRETURN( DB_E_NOTAREFERENCECOLUMN );

    RRETURN(_pRowset->QueryInterface(
                 riid,
                 (void**)ppReferencedRowset)
           );
};

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetSpecificaton
//
//  Synopsis:  @mfunc Returns an interface pointer to the command that created the rowset
//
//             Called by: Client
//             Called when: Any time
//
//  Arguments:
//     riid              [in] IID of the interface pointer to return in *ppSpecification.
//     ppSpecification [out] pointer to  command
//
//
//  Returns:    @rdesc NONE
//        S_OK                    | Interface is supported
//        E_INVALIDARG            | ppSpecification was a NULL pointer
//        E_FAIL                  | provider specific error
//        E_NOINTERFACE           | Command does not support interface
//      S_FALSE                   | Rowset does not have command that created it
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::GetSpecification(
    REFIID      riid,
    IUnknown ** ppSpecification
    )
{
    CAutoBlock cab(&_csRowsetInfo);

    if( ppSpecification == NULL )
        RRETURN( E_INVALIDARG );

    *ppSpecification = NULL;

    if( _pParentObject == NULL )
        RRETURN( S_FALSE );

    RRETURN( _pParentObject->QueryInterface(riid, (void**)ppSpecification) );
};

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetProperties
//
//  Synopsis:  @mfunc GetProperties
//             Called by: Client.
//             Called when: Any time.
//
//  Arguments:
//    cPropertyIDSets[in]    The number of DBPROPIDSET structures in rgProperttySets
//    rgPropertyIDSets[in]   Array of cPropertyIDSets of DBPROIDSET structs.
//    pcPropertySets[out]    number of DBPROPSET returned in *prgPropertySets
//    prgPropertySets[out]   pointer to array of DBPROPSET structures, having the
//                           value and status of requested properties
//
//  Returns:   @rdesc HRESULT
//  S_OK                Success
//  DB_S_ERRORSOCCURRED Values were not supported for some properties
//  E_FAIL              A provider-specific error occurred
//  E_INVALIDARG        cPropertyIDSets > 0 and rgPropertyIdSEts = NULL
//                      pcPropertySets or prgPropertySets was NULL pointer
//                      In al element of rgPropertyIDSets, cPropertyIDs was not zero
//                      and rgPropertyIDs was a Null pointer
//  E_OUTOFMEMORY       Provider could not allocate memory
//  DB_E_ERRORSOCCURRED Values were not returned for any properties
//-----------------------------------------------------------------------.
HRESULT
CRowsetInfo::GetProperties(
    const ULONG       cPropertyIDSets,
    const DBPROPIDSET rgPropertyIDSets[],
    ULONG *           pcPropertySets,
    DBPROPSET **      prgPropertySets
    )
{
    // should never get here because this call is handled by CRowset
    ADsAssert(FALSE);

    RRETURN( E_FAIL );
};

//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetRowFromHROW
//
//  Synopsis:  @mfunc Returns an interface pointer to a row in the rowset.
//
//             Called by: Client
//             Called when: Any time
//
//  Arguments:
//     IUnknown             *pUnkOuter              Outer unknown.
//     HROW                 hRow                    Handle to row.
//     REFIID               riid,                   Interface requested.
//     [out]IUnknown        **ppUnk                 returned interface
//
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::GetRowFromHROW(
    IUnknown  *pUnkOuter,
    HROW hRow,
    REFIID riid,
    IUnknown  * *ppUnk,
    BOOL fIsTearOff,
    BOOL fAllAttrs
    )
{
#if (!defined(BUILD_FOR_NT40))
    HRESULT hr = S_OK;
    CAutoBlock cab(&_csRowsetInfo);
    auto_tm<WCHAR> lpwszURL;
    auto_rel<IGetDataSource>   pGetDataSource;
    auto_rel<ICommand> pCommand;
    auto_rel<IRowset> pRowset;
    auto_rel<IRowset> pRealRowset;
    CComObject<CRow>  *pRow = NULL;
    auto_rel<IRow>    pRowDelete;
    CCredentials      creds;
    CCredentials      *pCreds;
    PWSTR pwszUserID = NULL, pwszPassword = NULL;

    //Initialize return arguments
    if (ppUnk)
        *ppUnk = NULL;

    //We currently don't support aggregation.
    if (pUnkOuter != NULL)
        RRETURN(DB_E_NOAGGREGATION);

    if (ppUnk == NULL)
        RRETURN(E_INVALIDARG);

    if ( _pParentObject == NULL)
        RRETURN(S_FALSE);

    TRYBLOCK
        PWSTR pURL;
        ADsAssert(_pRowset != NULL);
        hr = _pRowset->QueryInterface(__uuidof(IRowset), (void **)&pRealRowset);
        BAIL_ON_FAILURE(hr);
        hr =  _pRowProvider->GetURLFromHROW( hRow,&pURL, pRealRowset);
        BAIL_ON_FAILURE(hr);

        //assign returned ptr to auto_tm class for auto deletion.
        lpwszURL = pURL;

        *ppUnk = NULL;

        //
        // Get the session and QI for any mandatory interface -
        // we query for IGetDataSource.
        //
        hr = _pParentObject->QueryInterface(
                IID_IGetDataSource,
                (void**)&pGetDataSource);

        if (FAILED(hr))
        {
            hr = _pParentObject->QueryInterface(
                    IID_ICommand,
                    (void**)&pCommand);
            BAIL_ON_FAILURE(hr);

            hr = pCommand->GetDBSession (
                    IID_IGetDataSource,
                    (LPUNKNOWN *)&pGetDataSource);
            BAIL_ON_FAILURE(hr);
        }

        //Get user id and password properties for authentication
        //If the RowProvider has cached special credentials, we use them,
        //Otherwise we use the DBPROP_AUTH_USERID and DBPROP_AUTH_PASSWORD
        //properties in the originating DataSource object.
        if ((pCreds = _pRowProvider->GetCredentials()) == NULL)
        {
            hr = GetCredentials(pGetDataSource, creds);
            BAIL_ON_FAILURE(hr);
            pCreds = &creds;
        }

        hr = pCreds->GetUserName(&pwszUserID);
        BAIL_ON_FAILURE(hr);
        hr = pCreds->GetPassword(&pwszPassword);
        BAIL_ON_FAILURE(hr);

        //Instantiate a row object.
        hr = CComObject<CRow>::CreateInstance(&pRow);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

        //To make sure we delete the row object in case
        //we encounter errors after this point.
        pRow->AddRef();
        pRowDelete = pRow;

        //Initialize the row object.
        hr = pRow->Initialize(  lpwszURL,
                (IUnknown *)pGetDataSource,
                (IUnknown *)_pRowset,
                hRow,
                pwszUserID,
                pwszPassword,
                DBBINDURLFLAG_READ, //we are currently a read-only provider.
                fIsTearOff, // see comment at beginning of row.cxx
                !fAllAttrs, // see comment at beginning of row.cxx
                _pRowProvider
                );

        if (FAILED(hr))
        {
            if (INVALID_CREDENTIALS_ERROR(hr))
            {
                BAIL_ON_FAILURE(hr = DB_SEC_E_PERMISSIONDENIED);
            }
            else if (hr == E_NOINTERFACE)
            {
                BAIL_ON_FAILURE(hr);
            }
            else
            {
                BAIL_ON_FAILURE(hr = DB_E_NOTFOUND);
            }
        }

        //Get the requested interface on the Row.
        hr = pRow->QueryInterface(riid, (void**)ppUnk);
        if (FAILED(hr))
            BAIL_ON_FAILURE(hr = E_NOINTERFACE);

    CATCHBLOCKBAIL(hr)

    if (pwszUserID)
        FreeADsStr(pwszUserID);
    if (pwszPassword)
    {
        SecureZeroMemory(pwszPassword, wcslen(pwszPassword) * sizeof(WCHAR));
        FreeADsStr(pwszPassword);
    }

    RRETURN(S_OK);

error:
    if (pwszUserID)
        FreeADsStr(pwszUserID);
    if (pwszPassword)
    {
        SecureZeroMemory(pwszPassword, wcslen(pwszPassword) * sizeof(WCHAR));
        FreeADsStr(pwszPassword);
    }

    RRETURN(hr);

#else
    RRETURN(E_FAIL);
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetURLFromHROW
//
//  Synopsis:  @mfunc Returns an interface pointer to a row in the rowset.
//
//             Called by: Client
//             Called when: Any time
//
//  Arguments:
//         HROW                 hRow                    Handle to row.
//         LPOLESTR             ppwszURL,               URL name for the row.
//
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
HRESULT
CRowsetInfo::GetURLFromHROW(
    HROW hRow,
    LPOLESTR  *ppwszURL
    )
{
#if (!defined(BUILD_FOR_NT40))
    CAutoBlock         cab(&_csRowsetInfo);
    LPWSTR             lpwszURL = NULL;
    auto_rel<IRowset>  pRealRowset;
    HRESULT            hr = S_OK;

    if (ppwszURL == NULL)
        RRETURN(E_INVALIDARG);

    ADsAssert(_pRowset != NULL);
    hr = _pRowset->QueryInterface(__uuidof(IRowset), (void **)&pRealRowset);
    BAIL_ON_FAILURE(hr);

    // Call row provider to get the URL.
    hr = _pRowProvider->GetURLFromHROW( hRow,ppwszURL, pRealRowset);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
#else
    RRETURN(E_FAIL);
#endif
};



//+---------------------------------------------------------------------------
//
//  Function:  CRowsetInfo::GetCredentials
//
//  Synopsis:  @mfunc Gets credentials stored in INIT properties.
//
//  Arguments:
//        pSession              [in] IGetDataSource interface ptr on Session.
//        refCredentials        [in] CCredentials containing user id and password.
//
//  Returns: HRESULT
//
//----------------------------------------------------------------------------
HRESULT CRowsetInfo::GetCredentials(
    IGetDataSource *pSession,
    CCredentials &refCredentials
    )
{
#if (!defined(BUILD_FOR_NT40))
    HRESULT hr = S_OK;
    auto_rel<IDBProperties> pDBProp;
    ULONG   i, j, cPropertySets = 0;

    Assert(pSession);

    hr = pSession->GetDataSource(
            __uuidof(IDBProperties),
            (IUnknown **)&pDBProp);

    BAIL_ON_FAILURE(hr);

    DBPROPID        propids[2];
    propids[0] = DBPROP_AUTH_USERID;
    propids[1] = DBPROP_AUTH_PASSWORD;

    DBPROPIDSET rgPropertyIDSets[1];
    rgPropertyIDSets[0].rgPropertyIDs = propids;
    rgPropertyIDSets[0].cPropertyIDs = 2;
    rgPropertyIDSets[0].guidPropertySet = DBPROPSET_DBINIT;

    DBPROPSET *prgPropertySets;

    hr = pDBProp->GetProperties(
            1,
            rgPropertyIDSets,
            &cPropertySets,
            &prgPropertySets);

    if (hr == DB_E_ERRORSOCCURRED)
            BAIL_ON_FAILURE(hr);

    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &prgPropertySets[i].rgProperties[j];
            Assert(pProp);
            if (pProp->dwStatus == S_OK &&
                pProp->dwPropertyID == DBPROP_AUTH_USERID)
                refCredentials.SetUserName(V_BSTR(&pProp->vValue));
            else if (pProp->dwStatus == S_OK &&
                     pProp->dwPropertyID == DBPROP_AUTH_PASSWORD)
                refCredentials.SetPassword(V_BSTR(&pProp->vValue));
            else
                continue;
        }
    }

error:
    for (i = 0; i < cPropertySets; i++)
    {
        for (j = 0; j < prgPropertySets[i].cProperties; j++)
        {
            DBPROP *pProp = &(prgPropertySets[i].rgProperties[j]);
            Assert(pProp);
            FreeDBID(&pProp->colid);
            VariantClear(&pProp->vValue);
        }

        CoTaskMemFree(prgPropertySets[i].rgProperties);
    }
    CoTaskMemFree(prgPropertySets);

    RRETURN ( hr );
#else
    RRETURN(E_FAIL);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cstream.cxx ===
#include "oleds.hxx"
#if (!defined(BUILD_FOR_NT40))
#include "atl.h"
#include "cstream.h"

/* -------------------------------------------------------------------------
CStreamMem
------------------------------------------------------------------------- */
//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::CStreamMem (constructor)
//
//  Synopsis: constructs a CStreamMem object
//  
//----------------------------------------------------------------------------
CStreamMem::CStreamMem(void)
{
	m_pvData = NULL;
	m_cbBufferSize= 0;
	m_cbSeek = 0;
	memset(&m_statstg,0,sizeof(STATSTG));

	m_statstg.type = STGTY_STREAM;

    GetSystemTimeAsFileTime(&m_statstg.ctime);

	m_hRow = DB_NULL_HROW;
	m_fExternalData = true;
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::~CStreamMem (destructor)
//
//  Synopsis: destructs a CStreamMem object
//  
//----------------------------------------------------------------------------
CStreamMem::~CStreamMem(void)
{
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Initialize
//
//  Synopsis: Initializes a CStreamMem object
//
//  Parameters: pVar	Variant of type VT_UI1 | VT_ARRAY containing the bytes
//              IRow *  pointer to IRow interface
//              HROW	handle to the row that is creating this stream
//
//  Returns:    HRESULT
//  
//----------------------------------------------------------------------------
HRESULT CStreamMem::Initialize(VARIANT *pVar, IRow* pSourceRow, HROW hRow)
{
	ADsAssert (pVar && pSourceRow);

	//ADSI uses VT_ARRAY|VT_UI1 for binary data. Make sure we have proper type.
	ADsAssert(V_VT(pVar) == (VT_ARRAY | VT_UI1)); 
	
	HRESULT hr = NOERROR;
	auto_leave al(m_cs);

    SAFEARRAY *psa;
    UINT cDim;

	TRYBLOCK
		al.EnterCriticalSection();

		hr = m_pVar.Attach(pVar);
		BAIL_ON_FAILURE(hr);
	
		psa = V_ARRAY(pVar);
		cDim = SafeArrayGetDim(psa);
		if (cDim != 1)
			RRETURN(E_INVALIDARG);

		//Get bounds of safearray and determine size
		long lLBound, lUBound;
		hr = SafeArrayGetLBound(psa, cDim, &lLBound);
		BAIL_ON_FAILURE(hr);
		hr = SafeArrayGetUBound(psa, cDim, &lUBound);
		BAIL_ON_FAILURE(hr);
		
		m_cbBufferSize = lUBound - lLBound + 1;

		//Get a pointer to the actual byte data
		hr = SafeArrayAccessData(V_ARRAY(pVar), &m_pvData);
		BAIL_ON_FAILURE(hr);

		hr = SafeArrayUnaccessData(psa);
		BAIL_ON_FAILURE(hr);

		m_pSourceRow = pSourceRow;
		m_pSourceRow->AddRef();
		m_hRow = hRow;

		//Update stat structure
		m_statstg.cbSize.LowPart = m_cbBufferSize;
		GetSystemTimeAsFileTime(&m_statstg.mtime);
    CATCHBLOCKBAIL(hr)
	
	RRETURN(S_OK);

error:
	RRETURN(hr);
}

//////////////////////////////////////////////////////////////////////////////
// IStream
//

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Read
//
//  Synopsis: Reads specified number of bytes from stream.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Read(
	void __RPC_FAR *pv,
	ULONG cb,
	ULONG __RPC_FAR *pcbRead)
{
	if (pv == NULL)
		RRETURN(STG_E_INVALIDPOINTER);

	auto_leave al(m_cs);
	ULONG cbRead = 0;

	if( pcbRead != NULL )
		*pcbRead = 0;

	al.EnterCriticalSection();

	// anything to do?
	if( cb == 0 || 
		m_statstg.cbSize.LowPart == 0 || 
		m_cbSeek == m_statstg.cbSize.LowPart )
		RRETURN(NOERROR);

	// determine amount to copy
	cbRead = min(cb,m_statstg.cbSize.LowPart - m_cbSeek);

	if( cbRead > 0 )
	{
		// copy it
		CopyMemory(pv,(PBYTE)m_pvData + m_cbSeek,cbRead);

		// adjust seek pointer
		m_cbSeek += cbRead;
	}

	// update access time
    GetSystemTimeAsFileTime(&m_statstg.atime);

	if( pcbRead != NULL )
		*pcbRead = cbRead;

	RRETURN(NOERROR);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Write
//
//  Synopsis: Writes specified number of bytes to stream.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Write( 
	const void __RPC_FAR *pv,
	ULONG cb,
	ULONG __RPC_FAR *pcbWritten)
{
	//DS OLE DB provider is currently read-only. 
	//It doesn't support writes on its streams.
	RRETURN(STG_E_ACCESSDENIED);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Seek
//
//  Synopsis: Sets the current read/write pointer to the given position.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Seek( 
	LARGE_INTEGER dlibMove,
	DWORD dwOrigin,
	ULARGE_INTEGER __RPC_FAR *plibNewPosition)
{
	auto_leave al(m_cs);
	
	// can we handle the seek?
	if( dlibMove.HighPart != 0 )
		RRETURN(STG_E_WRITEFAULT);

	al.EnterCriticalSection();
	
	// handle the seek request
	switch( dwOrigin)
	{
		case STREAM_SEEK_SET:
			if( dlibMove.LowPart > m_statstg.cbSize.LowPart )
				RRETURN(STG_E_INVALIDFUNCTION);
			m_cbSeek = dlibMove.LowPart;
			break;
		case STREAM_SEEK_CUR:
			if( dlibMove.LowPart + m_cbSeek > m_statstg.cbSize.LowPart )
				RRETURN(STG_E_INVALIDFUNCTION);
			m_cbSeek += (int)dlibMove.LowPart;
			break;
		case STREAM_SEEK_END:
			//We are read-only provider. Seeking past the end of stream
			//or prior to beginning of stream is not supported
			if ( int(dlibMove.LowPart) > 0 || 
				 (int(dlibMove.LowPart) + int(m_statstg.cbSize.LowPart)) < 0
			   )
				RRETURN(STG_E_INVALIDFUNCTION);
			m_cbSeek = m_statstg.cbSize.LowPart + (int)dlibMove.LowPart;
			break;
	}

	// return new seek position
	if( plibNewPosition )
	{
		plibNewPosition->HighPart = 0;
		plibNewPosition->LowPart = m_cbSeek;
	}

	RRETURN(NOERROR);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::SetSize
//
//  Synopsis: Sets the size of the stream.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::SetSize( 
	ULARGE_INTEGER libNewSize)
{
	//DS OLE DB provider is currently read-only. 
	//It doesn't support writes on its streams.
	RRETURN(STG_E_ACCESSDENIED);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::CopyTo
//
//  Synopsis: Copies specified number of bytes from this stream to another.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::CopyTo( 
	IStream __RPC_FAR *pstm,
	ULARGE_INTEGER cb,
	ULARGE_INTEGER __RPC_FAR *pcbRead,
	ULARGE_INTEGER __RPC_FAR *pcbWritten)
{
	auto_leave al(m_cs);
	HRESULT hr = NOERROR;
	ULONG cbBytes = 0;
	ULONG cbWritten = 0;

	if( pstm == NULL )
		RRETURN(STG_E_INVALIDPOINTER);

	al.EnterCriticalSection();
	
	cbBytes = min(m_statstg.cbSize.LowPart - m_cbSeek,cb.LowPart);

	if( pcbRead )
		pcbRead->QuadPart = cbBytes;

	if( cbBytes == 0 )
		RRETURN(NOERROR);

	hr = pstm->Write((PBYTE)m_pvData + m_cbSeek,cbBytes,&cbWritten);
	if( pcbWritten )
		pcbWritten->QuadPart = cbWritten;
	RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Commit
//
//  Synopsis: Makes changes to this stream permanent.
//            Note: This is a no-op since this stream is currently read-only.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Commit( 
	DWORD grfCommitFlags)
{
	RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Revert
//
//  Synopsis: Reverts changes to this stream.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Revert( void)
{
	RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::LockRegion
//
//  Synopsis: Locks a specified number of bytes in the stream
//            starting from a given offset.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::LockRegion( 
	ULARGE_INTEGER libOffset,
	ULARGE_INTEGER cb,
	DWORD dwLockType)
{
	RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::UnlockRegion
//
//  Synopsis: Unlocks a specified number of bytes in the stream
//            starting from a given offset.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::UnlockRegion( 
	ULARGE_INTEGER libOffset,
	ULARGE_INTEGER cb,
	DWORD dwLockType)
{
	RRETURN(E_NOTIMPL);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Stat
//
//  Synopsis: Gets information about the stream: size, modification time etc.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Stat( 
	STATSTG __RPC_FAR *pstatstg,
	DWORD grfStatFlag)
{
	auto_leave al(m_cs);

	if( !pstatstg )
		RRETURN(STG_E_INVALIDPOINTER);

	al.EnterCriticalSection();
	memcpy(pstatstg,&m_statstg,sizeof(STATSTG));
	al.LeaveCriticalSection();

	RRETURN(NOERROR);
}

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::Clone
//
//  Synopsis: Creates a new stream object which references the same bytes
//            but with its own seek pointer.
//
//  For more info see IStream documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::Clone( 
	IStream __RPC_FAR *__RPC_FAR *ppstm)
{
	RRETURN(E_NOTIMPL);
}

///////////////////////////////////////////////////////////////////////////////
//IGetSourceRow
//

//+---------------------------------------------------------------------------
//
//  Function: CStreamMem::GetSourceRow
//
//  Synopsis: Gets the requested interface on the row object that originaly
//            created this stream. 
//
//  For more info see IGetSourceRow in OLE DB 2.5 documentation.
//----------------------------------------------------------------------------
STDMETHODIMP CStreamMem::GetSourceRow(REFIID riid, IUnknown **ppRow)
{
	auto_leave al(m_cs);

	al.EnterCriticalSection();

	if (m_pSourceRow.get() == NULL)
	{
		*ppRow = NULL;
		RRETURN(DB_E_NOSOURCEOBJECT);
	}

	HRESULT hr = m_pSourceRow->QueryInterface(riid, (void **)ppRow);
	if (FAILED(hr))
		RRETURN(E_NOINTERFACE);

	RRETURN(S_OK);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cstream.h ===
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Memory stream implementations for DS OLE DB PROVIDER
//
// copied from cdopt\src\cdo\mystream.* and modified.

class ATL_NO_VTABLE CStreamMem :
	INHERIT_TRACKING,
	public CComObjectRootEx<CComMultiThreadModel>,
	public IStream,
	public IGetSourceRow
{
public: 

DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CStreamMem)
	COM_INTERFACE_ENTRY(IStream)
	COM_INTERFACE_ENTRY(ISequentialStream)
	COM_INTERFACE_ENTRY(IGetSourceRow)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		RRETURN( CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p));
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

private:
    	auto_cs m_cs;		// critical section
        ULONG   m_cbSeek;
        STATSTG m_statstg;

		CComVariant		m_pVar;
		auto_rel<IRow>	m_pSourceRow;
		HROW			m_hRow;
        PVOID			m_pvData;
        DWORD			m_cbBufferSize;
		bool			m_fExternalData;

    public:
        CStreamMem(void);
        ~CStreamMem(void);

		//internal methods
		HRESULT Initialize(VARIANT *pVar, IRow* pSourceRow, HROW hRow);

        // IStream
        STDMETHODIMP Read(
            void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbRead);
        
        STDMETHODIMP Write( 
            const void __RPC_FAR *pv,
            ULONG cb,
            ULONG __RPC_FAR *pcbWritten);
        
        STDMETHODIMP Seek( 
            LARGE_INTEGER dlibMove,
            DWORD dwOrigin,
            ULARGE_INTEGER __RPC_FAR *plibNewPosition);
        
        STDMETHODIMP SetSize( 
            ULARGE_INTEGER libNewSize);
        
        STDMETHODIMP CopyTo( 
            IStream __RPC_FAR *pstm,
            ULARGE_INTEGER cb,
            ULARGE_INTEGER __RPC_FAR *pcbRead,
            ULARGE_INTEGER __RPC_FAR *pcbWritten);
        STDMETHODIMP Commit( 
            DWORD grfCommitFlags);
        
        STDMETHODIMP Revert( void);
        
        STDMETHODIMP LockRegion( 
            ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb,
            DWORD dwLockType);
        
        STDMETHODIMP UnlockRegion( 
            ULARGE_INTEGER libOffset,
            ULARGE_INTEGER cb,
            DWORD dwLockType);
        
        STDMETHODIMP Stat( 
            STATSTG __RPC_FAR *pstatstg,
            DWORD grfStatFlag);
        
        STDMETHODIMP Clone( 
            IStream __RPC_FAR *__RPC_FAR *ppstm);

		//IGetSourceRow
		STDMETHODIMP GetSourceRow(REFIID riid, IUnknown **ppRow);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\guid.c ===
#define INITGUID

#include <ole2.h>

//--------------------------------------------------------------------------
//
//  ADS CLSIDs
//
//--------------------------------------------------------------------------


DEFINE_GUID(CLSID_ADsNamespaces,0x233664B0L,0x0367,0x11CF,0xAB,0xC4,0x02,0x60,0x8C,0x9E,0x75,0x53);

DEFINE_GUID(CLSID_ADsProvider,0x4753DA60L,0x5B71,0x11CF,0xB0,0x35,0x00,0xAA,0x00,0x6E,0x09,0x75);

// {E0FA581D-2188-11d2-A739-00C04FA377A1}
DEFINE_GUID(CLSID_ADSI_BINDER,0xe0fa581d, 0x2188, 0x11d2, 0xa7, 0x39, 0x0, 0xc0, 0x4f, 0xa3, 0x77, 0xa1);

// {04EE4CBB-21B6-11d2-A739-00C04FA377A1}
DEFINE_GUID(CLSID_Row, 0x4ee4cbb, 0x21b6, 0x11d2, 0xa7, 0x39, 0x0, 0xc0, 0x4f, 0xa3, 0x77, 0xa1);

//------------------------------------------------------------------------
//  GUIDS that come out of oleds.tlb.
//------------------------------------------------------------------------

DEFINE_GUID(IID_IProvideDBService, 0xEFF65380L,0x9C98,0x11CF,0xB9,0x63,0x00,0xAA,0x00,0x44,0x77,0x3D);

DEFINE_GUID( IID_IRowProvider, 0x36576d80, 0xe5bc, 0x11cf, 0xa4, 0x8, 0x0, 0xc0, 0x4f, 0xd6, 0x11, 0xd0);

DEFINE_GUID( DBPROPSET_TEMPTABLE, 0x4e4c0950L,0xe5a8,0x11cf,0xa4,0x08,0x00,0xc0,0x4f,0xd6,0x11,0xd0);



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  getobj.cxx
//
//  Contents:  ADs Wrapper Function to mimic Visual Basic's GetObject
//
//
//  History:   11-15-95     krishnag    Created.
//             07-12-96     t-danal     Added path validation.
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop

extern PROUTER_ENTRY g_pRouterHead;
extern CRITICAL_SECTION g_csRouterHeadCritSect;

BOOL
IsPathOfProgId(
    LPWSTR ProgId,
    LPWSTR Path
    );

BOOL
IsADsProgId(
    LPWSTR Path
    );

//+---------------------------------------------------------------------------
//  Function:  ADsGetObject
//
//  Synopsis:
//
//  Arguments:  [LPWSTR lpszPathName]
//              [REFIID riid]
//              [void FAR * FAR * ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    07-12-95   t-danal      Created.
//
//----------------------------------------------------------------------------
HRESULT
ADsGetObject(
    LPCWSTR lpszPathName,
    REFIID riid,
    void FAR * FAR * ppObject
    )
{
    HRESULT hr;

    hr = GetObject((LPWSTR)lpszPathName,
                   riid,
                   ppObject,
                   FALSE);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:
//
//  Arguments:  [LPWSTR lpszPathName]
//              [REFIID riid]
//              [void FAR * FAR * ppObject]
//              [BOOL Generic]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//  History:    11-03-95   krishnag     Created.
//              07-12-95   t-danal      Added router verification and
//                                      renamed from ADsGetObject
//
//----------------------------------------------------------------------------
HRESULT
GetObject(
    LPWSTR lpszPathName,
    REFIID riid,
    void FAR * FAR * ppObject,
    BOOL bRelative
    )
{
    HRESULT hr;
    ULONG chEaten = 0L;
    IMoniker * pMoniker = NULL;
    IBindCtx *pbc = NULL;
    WCHAR* lpszProgId = NULL;

    if (!lpszPathName)
        return E_FAIL;

    lpszProgId = new WCHAR[wcslen(lpszPathName) + 1];
    if(!lpszProgId)
    {
        hr = E_OUTOFMEMORY;
        BAIL_IF_ERROR(hr);
    }

    hr = CopyADsProgId(
               (LPWSTR)lpszPathName,
               lpszProgId
               );
    BAIL_IF_ERROR( hr );

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);
    
    
    PROUTER_ENTRY lpRouter = g_pRouterHead;
    

    //
    // Check if the Path matches with ProviderProgId or the Aliases
    //

    // ADs is a special case, and we also did not differentiate between uppercase and lowercase before, so keep this unchanged
    if(_wcsicmp(lpszProgId, L"ADs"))
    {
        while (lpRouter &&
               (!IsPathOfProgId(lpRouter->szProviderProgId, lpszProgId) &&
               !IsPathOfProgId(lpRouter->szAliases, lpszProgId)))
                   lpRouter = lpRouter->pNext;

        if (!lpRouter)
            BAIL_IF_ERROR(hr=E_FAIL);
    }
    
    hr = CreateBindCtx(0, &pbc);
    BAIL_IF_ERROR(hr);

    hr = MkParseDisplayName(pbc,
                            lpszPathName,
                            &chEaten,
                            &pMoniker);
    BAIL_IF_ERROR(hr);

    hr = pMoniker->BindToObject(pbc,  NULL, riid, ppObject);
    BAIL_IF_ERROR(hr);

cleanup:
    if (pbc) {
        pbc->Release();
    }

    if (pMoniker) {
        pMoniker->Release();
    }

    if(lpszProgId)
    {
        delete [] lpszProgId;
        lpszProgId = NULL;
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Function:   IsPathOfProgId
//
//  Synopsis:   Checks if an OLE Path corresponds to given ProgId.
//              Path must be @Foo! or Foo: style.
//
//  Arguments:  [LPWSTR ProgId]
//              [LPWSTR Path]
//
//  Returns:    BOOL
//
//  Modifies:    -
//
//  History:    07-12-95  t-danal     Created
//
//----------------------------------------------------------------------------
BOOL
IsPathOfProgId(
    LPWSTR ProgId,
    LPWSTR Path
    )
{
    if (!ProgId || !Path)  // Just in case...
        return FALSE;    

    if(wcscmp(ProgId, Path))
        return FALSE;

    return TRUE;
}

//+---------------------------------------------------------------------------
//  Function:   IsADsProgId
//
//  Synopsis:   Checks if the ProgIds of paths is ADs progid.
//              Paths must be @Foo! or Foo: style.
//
//  Arguments:  [LPWSTR Path]
//
//  Returns:    BOOL
//
//  Modifies:    -
//
//  History:    07-12-95  t-danal     Created
//
//----------------------------------------------------------------------------
BOOL
IsADsProgId(
    LPWSTR Path
    )
{
    int cch = 0;
    LPWSTR pEnd;

    if (!Path)
        return FALSE;

    if (*Path == L'@')
        Path++;

    pEnd = Path;
    while (*pEnd &&
           *pEnd != L'!' &&
           *pEnd != L':') {
        pEnd++;
    }  

    if (_wcsnicmp(L"ADS", Path, (int)(pEnd-Path)))
        return FALSE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       guid.h
//
//  Contents:   extern references for ADs guids
//
//  History:    16-Jan-95   KrishnaG
//
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// ADs CLSIDs
//
//-------------------------------------------

extern const CLSID CLSID_ADsNamespaces;

extern const CLSID CLSID_ADsProvider;

extern const CLSID CLSID_ADSI_BINDER;

extern const CLSID CLSID_Row;

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cvalue.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cPropertyValue.cxx
//
//  Contents:  PropertyValue object
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "oleds.hxx"
#pragma hdrstop


DEFINE_IDispatch_Implementation(CPropertyValue)


CPropertyValue::CPropertyValue():
        _pDispMgr(NULL),
        _dwDataType(0),
        _pDispatch(NULL)
{
    memset(&_ADsValue, 0, sizeof(ADSVALUE));

    ENLIST_TRACKING(CPropertyValue);
}

HRESULT
CPropertyValue::CreatePropertyValue(
    REFIID riid,
    void **ppvObj
    )
{
    CPropertyValue FAR * pPropertyValue = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyValueObject(&pPropertyValue);
    BAIL_ON_FAILURE(hr);

    hr = pPropertyValue->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPropertyValue->Release();

    RRETURN(hr);

error:
    delete pPropertyValue;

    RRETURN_EXP_IF_ERR(hr);

}



CPropertyValue::~CPropertyValue( )
{
    ClearData();

    delete _pDispMgr;
}

STDMETHODIMP
CPropertyValue::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsPropertyValue FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyValue))
    {
        *ppv = (IADsPropertyValue FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsPropertyValue2))
    {
        *ppv = (IADsPropertyValue2 FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADsPropertyValue FAR *) this;
    }
    else if (IsEqualIID(iid, IID_ISupportErrorInfo))
    {
        *ppv = (ISupportErrorInfo FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsValue))
    {
        *ppv = (IADsValue FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CPropertyValue::AllocatePropertyValueObject(
    CPropertyValue ** ppPropertyValue
    )
{
    CPropertyValue FAR * pPropertyValue = NULL;
    CDispatchMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPropertyValue = new CPropertyValue();
    if (pPropertyValue == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CDispatchMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyValue,
                (IADsPropertyValue *)pPropertyValue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    hr = LoadTypeInfoEntry(
                pDispMgr,
                LIBID_ADs,
                IID_IADsPropertyValue2,
                (IADsPropertyValue2 *)pPropertyValue,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPropertyValue->_pDispMgr = pDispMgr;
    *ppPropertyValue = pPropertyValue;

    RRETURN(hr);

error:

    delete pPropertyValue;
    delete  pDispMgr;

    RRETURN_EXP_IF_ERR(hr);

}

//
// ISupportErrorInfo method
//
STDMETHODIMP
CPropertyValue::InterfaceSupportsErrorInfo(THIS_ REFIID riid)
{
    if (IsEqualIID(riid, IID_IADsPropertyValue) ||
        IsEqualIID(riid, IID_IADsPropertyValue) ||
        IsEqualIID(riid, IID_IADsValue)) {
        return S_OK;
    } else {
        return S_FALSE;
    }

}


STDMETHODIMP
CPropertyValue::Clear(THIS_ )
{
    ClearData();
    RRETURN(S_OK);
}



STDMETHODIMP
CPropertyValue::get_ADsType(THIS_ long FAR * retval)
{
    *retval = _ADsValue.dwType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyValue::put_ADsType(THIS_ long lnADsType)
{
    _ADsValue.dwType  = (ADSTYPE)lnADsType;
    RRETURN(S_OK);
}



STDMETHODIMP
CPropertyValue::get_DNString(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_DN_STRING) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ADsAllocString(_ADsValue.DNString, retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_DNString(THIS_ BSTR bstrDNString)
{
    HRESULT hr = S_OK;
    ClearData();

    _ADsValue.DNString = NULL;
    _ADsValue.DNString = AllocADsStr(bstrDNString);
    if(!_ADsValue.DNString && bstrDNString)
    {
        hr = E_OUTOFMEMORY;
    }
    _ADsValue.dwType = ADSTYPE_DN_STRING;

    RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_CaseExactString(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_CASE_EXACT_STRING) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ADsAllocString(_ADsValue.CaseExactString, retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_CaseExactString(THIS_ BSTR bstrCaseExactString)
{
    HRESULT hr = S_OK;
    
    ClearData();

    _ADsValue.DNString = NULL;
    _ADsValue.DNString = AllocADsStr(bstrCaseExactString);
    if(!_ADsValue.DNString && bstrCaseExactString)
    {
        hr = E_OUTOFMEMORY;
    }
    _ADsValue.dwType = ADSTYPE_CASE_EXACT_STRING;

    RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_CaseIgnoreString(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_CASE_IGNORE_STRING) {
        RRETURN_EXP_IF_ERR(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ADsAllocString(_ADsValue.CaseIgnoreString, retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_CaseIgnoreString(THIS_ BSTR bstrCaseIgnoreString)
{
    HRESULT hr = S_OK;
    
    ClearData();

    _ADsValue.DNString = NULL;
    _ADsValue.DNString = AllocADsStr(bstrCaseIgnoreString);
    if(!_ADsValue.DNString && bstrCaseIgnoreString)
    {
        hr = E_OUTOFMEMORY;
    }
    _ADsValue.dwType = ADSTYPE_CASE_IGNORE_STRING;

    RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_PrintableString(THIS_ BSTR FAR * retval)
{

    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_PRINTABLE_STRING) {
        RRETURN_EXP_IF_ERR(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ADsAllocString(_ADsValue.PrintableString, retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_PrintableString(THIS_ BSTR bstrPrintableString)
{
    HRESULT hr = S_OK;
    
    ClearData();

    _ADsValue.PrintableString = NULL;
    _ADsValue.PrintableString = AllocADsStr(bstrPrintableString);

    if(!_ADsValue.PrintableString && bstrPrintableString)
    {
        hr = E_OUTOFMEMORY;
    }
    _ADsValue.dwType = ADSTYPE_PRINTABLE_STRING;

    RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_NumericString(THIS_ BSTR FAR * retval)
{

    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_NUMERIC_STRING) {
        RRETURN_EXP_IF_ERR(E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = ADsAllocString(_ADsValue.NumericString, retval);

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_NumericString(THIS_ BSTR bstrNumericString)
{
    HRESULT hr = S_OK;
    
    ClearData();

    _ADsValue.DNString = NULL;
    _ADsValue.DNString = AllocADsStr(bstrNumericString);
    if(!_ADsValue.DNString && bstrNumericString)
    {
        hr = E_OUTOFMEMORY;
    }
    
    _ADsValue.dwType = ADSTYPE_NUMERIC_STRING;

    RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_OctetString(THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    if (_ADsValue.dwType != ADSTYPE_OCTET_STRING) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    aBound.lLbound = 0;
    aBound.cElements = _ADsValue.OctetString.dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray,
            _ADsValue.OctetString.lpValue,
            aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(retval) = VT_ARRAY | VT_UI1;
    V_ARRAY(retval) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_OctetString(THIS_ VARIANT VarOctetString)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    VARIANT * pvVar = &VarOctetString;
    HRESULT hr = S_OK;

    ClearData();

    _ADsValue.dwType = ADSTYPE_OCTET_STRING;

    if ( VarOctetString.vt == (VT_ARRAY | VT_BYREF)) {
        pvVar = V_VARIANTREF(&VarOctetString);
    }
      
    if( pvVar->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pvVar),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pvVar),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    _ADsValue.OctetString.lpValue = (LPBYTE)AllocADsMem(dwSUBound - dwSLBound + 1);

    if ( _ADsValue.OctetString.lpValue == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _ADsValue.OctetString.dwLength = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(pvVar),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( _ADsValue.OctetString.lpValue,
            pArray,
            dwSUBound-dwSLBound+1);

    SafeArrayUnaccessData( V_ARRAY(pvVar) );

error:
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::get_Integer(THIS_ LONG FAR * retval)
{
    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_INTEGER) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *retval = _ADsValue.Boolean;

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_Integer(THIS_ LONG lnInteger)
{
    ClearData();

    _ADsValue.Integer = lnInteger;
    _ADsValue.dwType = ADSTYPE_INTEGER;



    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyValue::get_Boolean(THIS_ LONG FAR * retval)
{
    HRESULT hr = S_OK;

    if (_ADsValue.dwType != ADSTYPE_BOOLEAN) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }


    *retval = _ADsValue.Boolean;
    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_Boolean(THIS_ LONG lnBoolean)
{
    ClearData();

    _ADsValue.Boolean = lnBoolean;
    _ADsValue.dwType = ADSTYPE_BOOLEAN;

    RRETURN(S_OK);
}


STDMETHODIMP
CPropertyValue::get_SecurityDescriptor(THIS_ IDispatch FAR * FAR * ppDispatch)
{

    HRESULT hr = E_ADS_CANT_CONVERT_DATATYPE;

    //
    // Check if we have a valid IDispatch at this point
    //

    if (_pDispatch) {
        switch (_dwDataType) {

        case VAL_IDISPATCH_SECDESC_ONLY :
        case VAL_IDISPATCH_SECDESC_ALL :

            hr = _pDispatch->QueryInterface(
                                IID_IDispatch,
                                (void **) ppDispatch
                                );
            break;

        default:

            hr = E_ADS_CANT_CONVERT_DATATYPE;
        }
    }


    RRETURN(hr);

}



STDMETHODIMP
CPropertyValue::put_SecurityDescriptor(THIS_ IDispatch * pSecurityDescriptor)
{
    HRESULT hr = S_OK;
    IADsSecurityDescriptor *pIADsSecDes;
    IDispatch* pIDispatch;

    ClearData();

    _ADsValue.dwType = ADSTYPE_NT_SECURITY_DESCRIPTOR;

    //
    // This qi ensures that this is a security descriptor
    //
    hr = pSecurityDescriptor->QueryInterface(
                                IID_IADsSecurityDescriptor,
                                (void **) &pIADsSecDes
                                );

    BAIL_ON_FAILURE(hr);

    pIADsSecDes->Release();
    pIADsSecDes = NULL;

    hr = pSecurityDescriptor->QueryInterface(
                                  IID_IDispatch,
                                  (void **) &pIDispatch
                                  );

    BAIL_ON_FAILURE(hr);

    _dwDataType = VAL_IDISPATCH_SECDESC_ONLY;

    _pDispatch = pIDispatch;

    RRETURN(hr);

error:

    if (pIADsSecDes) {
        pIADsSecDes->Release();
    }

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPropertyValue::get_LargeInteger(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsLargeInteger * pLargeInteger = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_LARGE_INTEGER) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_LargeInteger,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsLargeInteger,
            (void **) &pLargeInteger);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->put_LowPart(_ADsValue.LargeInteger.LowPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->put_HighPart(_ADsValue.LargeInteger.HighPart);
   BAIL_ON_FAILURE(hr);

   hr = pLargeInteger->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pLargeInteger) {
      pLargeInteger->Release();
   }

   RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_LargeInteger(THIS_ IDispatch FAR* lnLargeInteger)
{
   IADsLargeInteger *pLargeInteger = NULL;
   HRESULT hr = S_OK;
   LONG lnDataHigh = 0;
   LONG lnDataLow = 0;

    ClearData();
   hr = lnLargeInteger->QueryInterface(
                                     IID_IADsLargeInteger,
                                     (void **)&pLargeInteger
                                     );
   BAIL_ON_FAILURE(hr);

    hr = pLargeInteger->get_HighPart(&lnDataHigh);
   BAIL_ON_FAILURE(hr);

    hr = pLargeInteger->get_LowPart(&lnDataLow);
   BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_LARGE_INTEGER;
   _ADsValue.LargeInteger.HighPart = lnDataHigh;
   _ADsValue.LargeInteger.LowPart = lnDataLow;

error:
   if (pLargeInteger) {
        pLargeInteger->Release();
    }

   RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::get_UTCTime(THIS_ DATE *retval)
{
   HRESULT hr = S_OK;
   int result = FALSE;

   if (_ADsValue.dwType != ADSTYPE_UTC_TIME) {
       RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
   }

   result = SystemTimeToVariantTime(&_ADsValue.UTCTime, retval);
   if (result != TRUE) {
        hr = E_FAIL;
   }

   RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::put_UTCTime(THIS_ DATE DateInDate)
{
   HRESULT hr = S_OK;
   int result = FALSE;

   ClearData();

   _ADsValue.dwType = ADSTYPE_UTC_TIME;
   result = VariantTimeToSystemTime(DateInDate, &_ADsValue.UTCTime);
   if (result != TRUE) {
        hr = E_FAIL;
   }

   RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPropertyValue::ConvertADsValueToPropertyValue(THIS_ PADSVALUE pADsValue)
{
    HRESULT hr = S_OK;

    hr = ConvertADsValueToPropertyValue2(
             pADsValue,
             NULL,
             NULL,
             TRUE
             );

    RRETURN_EXP_IF_ERR(hr);
}


STDMETHODIMP
CPropertyValue::ConvertADsValueToPropertyValue2(
            THIS_ PADSVALUE pADsValue,
            LPWSTR pszServerName,
            CCredentials* pCredentials,
            BOOL fNTDSType
            )
{
    HRESULT hr = S_OK;

    ClearData();

    hr = AdsCopyADsValueToPropObj(
             pADsValue,
             this,
             pszServerName,
             pCredentials,
             fNTDSType
             );

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CPropertyValue::ConvertPropertyValueToADsValue(THIS_ PADSVALUE  pADsValue)
{

    return( ConvertPropertyValueToADsValue2(
                 pADsValue,
                 NULL,      // serverName
                 NULL,      // userName
                 NULL,      // userPassword
                 0,         // default flags.
                 TRUE       // flag NTDS
                 )
             );

}


//
// Handles all the parameters
//
STDMETHODIMP
CPropertyValue::ConvertPropertyValueToADsValue2(
                    THIS_ PADSVALUE  pADsValue,
                    LPWSTR pszServerName,
                    LPWSTR pszUserName,
                    LPWSTR pszPassWord,
                    LONG dwFlags,
                    BOOL fNTDSType
                    )
{

    HRESULT hr = S_OK;
    CCredentials Credentials( pszUserName, pszPassWord, dwFlags);

    hr = AdsCopyPropObjToADsValue(
             this,
             pADsValue,
             pszServerName,
             &Credentials,
             fNTDSType
             );

    RRETURN_EXP_IF_ERR(hr);
}



STDMETHODIMP
CPropertyValue::get_CaseIgnoreList(THIS_ IDispatch FAR * FAR *retval)
{
    HRESULT hr = S_OK;
    IADsCaseIgnoreList * pCaseIgnoreList = NULL;
    IDispatch * pDispatch = NULL;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    BSTR bstrAddress = NULL;
    PADS_CASEIGNORE_LIST pCurrent = NULL;
    DWORD cElements = 0;
    VARIANT VarDestObject;

    VariantInit( &VarDestObject );

    if (_ADsValue.dwType != ADSTYPE_CASEIGNORE_LIST) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

    if (!_ADsValue.pCaseIgnoreList) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
            CLSID_CaseIgnoreList,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsCaseIgnoreList,
            (void **) &pCaseIgnoreList);
    BAIL_ON_FAILURE(hr);

    pCurrent = _ADsValue.pCaseIgnoreList;
    while (pCurrent) {
        cElements++;
        pCurrent = pCurrent->Next;
    }

    aBound.lLbound = 0;
    aBound.cElements = cElements;
    aList = SafeArrayCreate( VT_BSTR, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = _ADsValue.pCaseIgnoreList;
    for ( i = 0; i < (long)cElements; i++ ) {
        hr = ADsAllocString(
                pCurrent->String,
                &bstrAddress
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, bstrAddress );
        SysFreeString(bstrAddress);
        BAIL_ON_FAILURE(hr);
        pCurrent = pCurrent->Next;
    }

    V_VT(&VarDestObject) = VT_ARRAY | VT_BSTR;
    V_ARRAY(&VarDestObject) = aList;

    hr = pCaseIgnoreList->put_CaseIgnoreList(VarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pCaseIgnoreList->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:
    VariantClear( &VarDestObject );

    if (pCaseIgnoreList) {
        pCaseIgnoreList->Release();
    }
    if ( aList ) {
        SafeArrayDestroy( aList );
    }
   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_CaseIgnoreList(THIS_ IDispatch FAR* pdCaseIgnoreList)
{
    IADsCaseIgnoreList *pCaseIgnoreList = NULL;
    HRESULT hr = S_OK;
    LONG lnAmount= 0;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    PADS_CASEIGNORE_LIST pCurrent = NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varCaseIgnoreList;
    VARIANT varBstrElement;

    ClearData();
    VariantInit(&varCaseIgnoreList);

    hr = pdCaseIgnoreList->QueryInterface(
                             IID_IADsCaseIgnoreList,
                             (void **)&pCaseIgnoreList
                             );
    BAIL_ON_FAILURE(hr);

    _ADsValue.dwType = ADSTYPE_CASEIGNORE_LIST;

    hr = pCaseIgnoreList->get_CaseIgnoreList(&varCaseIgnoreList);
    BAIL_ON_FAILURE(hr);

    if(!((V_VT(&varCaseIgnoreList) &  VT_VARIANT) &&  V_ISARRAY(&varCaseIgnoreList))) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varCaseIgnoreList))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varCaseIgnoreList))->rgsabound[0].cElements <= 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varCaseIgnoreList),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varCaseIgnoreList),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    _ADsValue.pCaseIgnoreList = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
    if (!_ADsValue.pCaseIgnoreList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = _ADsValue.pCaseIgnoreList;

    for (i = dwSLBound; i <= (long)dwSUBound; i++) {

        VariantInit(&varBstrElement);
        hr = SafeArrayGetElement(V_ARRAY(&varCaseIgnoreList),
                                (long FAR *)&i,
                                &varBstrElement
                                );
        BAIL_ON_FAILURE(hr);

        pCurrent->String = AllocADsStr(V_BSTR(&varBstrElement));
        VariantClear(&varBstrElement);
        if (!pCurrent->String) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (i != (long)dwSUBound) {
            pCurrent->Next = (PADS_CASEIGNORE_LIST)AllocADsMem(sizeof(ADS_CASEIGNORE_LIST));
            if (!pCurrent->Next) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pCurrent = pCurrent->Next;
        }
    }
    pCurrent->Next = NULL;
    RRETURN(S_OK);

error:
    VariantClear(&varCaseIgnoreList);
    if (pCaseIgnoreList) {
        pCaseIgnoreList->Release();
    }
    RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_FaxNumber(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsFaxNumber * pFaxNumber = NULL;
   IDispatch * pDispatch = NULL;
   VARIANT Var;

   if (_ADsValue.dwType != ADSTYPE_FAXNUMBER) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

    if (!_ADsValue.pFaxNumber) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_FaxNumber,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsFaxNumber,
            (void **) &pFaxNumber);
   BAIL_ON_FAILURE(hr);

    VariantInit(&Var);
    hr = BinaryToVariant(
                _ADsValue.pFaxNumber->NumberOfBits,
                _ADsValue.pFaxNumber->Parameters,
                &Var);
    BAIL_ON_FAILURE(hr);
    hr = pFaxNumber->put_Parameters(Var);
    VariantClear(&Var);
    
    BAIL_ON_FAILURE(hr);
    

    hr = pFaxNumber->put_TelephoneNumber(_ADsValue.pFaxNumber->TelephoneNumber);
    BAIL_ON_FAILURE(hr);

   hr = pFaxNumber->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pFaxNumber) {
      pFaxNumber->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_FaxNumber(THIS_ IDispatch FAR* pdFaxNumber)
{
    IADsFaxNumber *pFaxNumber = NULL;
    HRESULT hr = S_OK;
    BSTR bstrTelephoneNumber = NULL;
    VARIANT varAddress;

    VariantInit(&varAddress);
    ClearData();
    hr = pdFaxNumber->QueryInterface(
                             IID_IADsFaxNumber,
                             (void **)&pFaxNumber
                             );
    BAIL_ON_FAILURE(hr);

    hr = pFaxNumber->get_TelephoneNumber(&bstrTelephoneNumber);
    BAIL_ON_FAILURE(hr);

    _ADsValue.dwType = ADSTYPE_FAXNUMBER;

    _ADsValue.pFaxNumber = (PADS_FAXNUMBER)AllocADsMem(sizeof(ADS_FAXNUMBER));
    if (!_ADsValue.pFaxNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _ADsValue.pFaxNumber->TelephoneNumber = AllocADsStr(bstrTelephoneNumber);
    if (!_ADsValue.pFaxNumber->TelephoneNumber && bstrTelephoneNumber) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    hr = pFaxNumber->get_Parameters(&varAddress);
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                    &varAddress,
                    &_ADsValue.pFaxNumber->NumberOfBits,
                    &_ADsValue.pFaxNumber->Parameters
                    );
    BAIL_ON_FAILURE(hr);

error:
    VariantClear(&varAddress);
   if (pFaxNumber) {
        pFaxNumber->Release();
    }

   if(bstrTelephoneNumber)
   {
       SysFreeString(bstrTelephoneNumber);
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_NetAddress(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsNetAddress * pNetAddress = NULL;
   IDispatch * pDispatch = NULL;
   VARIANT VarAddress;

   VariantInit(&VarAddress);
   if (_ADsValue.dwType != ADSTYPE_NETADDRESS) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }
    if (!_ADsValue.pNetAddress) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_NetAddress,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsNetAddress,
            (void **) &pNetAddress);
   BAIL_ON_FAILURE(hr);

    hr = pNetAddress->put_AddressType(_ADsValue.pNetAddress->AddressType);
    BAIL_ON_FAILURE(hr);

    hr = BinaryToVariant(
                _ADsValue.pNetAddress->AddressLength,
                _ADsValue.pNetAddress->Address,
                &VarAddress);
    BAIL_ON_FAILURE(hr);
    hr = pNetAddress->put_Address(VarAddress);
    BAIL_ON_FAILURE(hr);

   hr = pNetAddress->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:
    VariantClear(&VarAddress);
   if (pNetAddress) {
      pNetAddress->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_NetAddress(THIS_ IDispatch FAR* pdNetAddress)
{
   IADsNetAddress *pNetAddress = NULL;
   HRESULT hr = S_OK;
   LONG lnAddressType = 0;
   VARIANT varAddress;

    ClearData();
    VariantInit(&varAddress);

    _ADsValue.pNetAddress = (PADS_NETADDRESS)AllocADsMem(sizeof(ADS_NETADDRESS));
    if (!_ADsValue.pNetAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

   hr = pdNetAddress->QueryInterface(
                             IID_IADsNetAddress,
                             (void **)&pNetAddress
                             );
   BAIL_ON_FAILURE(hr);

    hr = pNetAddress->get_AddressType(
                    &lnAddressType
                    );
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->get_Address(
                    &varAddress
                    );
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                    &varAddress,
                    &_ADsValue.pNetAddress->AddressLength,
                    &_ADsValue.pNetAddress->Address
                    );
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_NETADDRESS;
   _ADsValue.pNetAddress->AddressType = lnAddressType;

error:
    VariantClear(&varAddress);
   if (pNetAddress) {
        pNetAddress->Release();
    }

   RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_OctetList(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsOctetList* pOctetList = NULL;
   IDispatch * pDispatch = NULL;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    PADS_OCTET_LIST pCurrent = NULL;
    DWORD cElements = 0;
    VARIANT VarDestObject;
    VARIANT varElement;

    VariantInit( &VarDestObject );
    VariantInit(&varElement);

    if (_ADsValue.dwType != ADSTYPE_OCTET_LIST) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }
    if (!_ADsValue.pOctetList) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_OctetList,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsOctetList,
            (void **) &pOctetList);
   BAIL_ON_FAILURE(hr);

    pCurrent = _ADsValue.pOctetList;
    while (pCurrent) {
        cElements++;
        pCurrent = pCurrent->Next;
    }

    aBound.lLbound = 0;
    aBound.cElements = cElements;
    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = _ADsValue.pOctetList;
    for ( i = 0; i < (long)cElements; i++ ) {
        hr = BinaryToVariant(
                        pCurrent->Length,
                        pCurrent->Data,
                        &varElement);
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &varElement);
        VariantClear(&varElement);
        BAIL_ON_FAILURE(hr);
        pCurrent = pCurrent->Next;
    }

    V_VT(&VarDestObject) = VT_ARRAY | VT_BSTR;
    V_ARRAY(&VarDestObject) = aList;

    hr = pOctetList->put_OctetList(VarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pOctetList->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

    VariantClear( &VarDestObject );

    if (pOctetList) {
        pOctetList->Release();
    }

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_OctetList(THIS_ IDispatch FAR* pdOctetList)
{
   IADsOctetList *pOctetList = NULL;
   HRESULT hr = S_OK;
   LONG lnAmount= 0;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    PADS_OCTET_LIST pCurrent = NULL;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varOctetList;
    VARIANT varElement;

    VariantInit(&varOctetList);
    ClearData();
   hr = pdOctetList->QueryInterface(
                             IID_IADsOctetList,
                             (void **)&pOctetList
                             );
   BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_OCTET_LIST;

    hr = pOctetList->get_OctetList(&varOctetList);
    BAIL_ON_FAILURE(hr);

    if(!((V_VT(&varOctetList) &  VT_VARIANT) &&  V_ISARRAY(&varOctetList))) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varOctetList))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varOctetList))->rgsabound[0].cElements <= 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varOctetList),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varOctetList),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    _ADsValue.pOctetList = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
    if (!_ADsValue.pOctetList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pCurrent = _ADsValue.pOctetList;
    for (i = dwSLBound; i <= (long)dwSUBound; i++) {
        VariantInit(&varElement);
        hr = SafeArrayGetElement(V_ARRAY(&varOctetList),
                                (long FAR *)&i,
                                &varElement
                                );
        BAIL_ON_FAILURE(hr);
        hr = VariantToBinary(
                        &varElement,
                        &pCurrent->Length,
                        &pCurrent->Data
                        );
        VariantClear(&varElement);
        
        BAIL_ON_FAILURE(hr);
        if (i != (long)dwSUBound) {
            pCurrent->Next = (PADS_OCTET_LIST)AllocADsMem(sizeof(ADS_OCTET_LIST));
            if (!pCurrent->Next) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }
            pCurrent = pCurrent->Next;
        }
        
    }
    pCurrent->Next = NULL;

error:
    VariantClear(&varOctetList);
   if (pOctetList) {
        pOctetList->Release();
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_Email(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsEmail* pEmail = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_EMAIL) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_Email,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsEmail,
            (void **) &pEmail);
   BAIL_ON_FAILURE(hr);

    hr = pEmail->put_Type(_ADsValue.Email.Type);
    BAIL_ON_FAILURE(hr);

    hr = pEmail->put_Address(_ADsValue.Email.Address);
    BAIL_ON_FAILURE(hr);

   hr = pEmail->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pEmail) {
      pEmail->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_Email(THIS_ IDispatch FAR* pdEmail)
{
   IADsEmail *pEmail = NULL;
   HRESULT hr = S_OK;
   LONG lnType= 0;
   BSTR bstrAddress = NULL;

    ClearData();
   hr = pdEmail->QueryInterface(
                             IID_IADsEmail,
                             (void **)&pEmail
                             );
   BAIL_ON_FAILURE(hr);

    hr = pEmail->get_Type(
                    &lnType
                    );
    BAIL_ON_FAILURE(hr);
    hr = pEmail->get_Address(&bstrAddress);
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_EMAIL;
   _ADsValue.Email.Type = lnType;
   _ADsValue.Email.Address = AllocADsStr(bstrAddress);
    if (!_ADsValue.Email.Address && bstrAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:
   if (pEmail) {
        pEmail->Release();
    }

   if(bstrAddress)
   {
       SysFreeString(bstrAddress);
   }

   RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_Path(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsPath* pPath = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_PATH) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }
    if (!_ADsValue.pPath) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_Path,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsPath,
            (void **) &pPath);
   BAIL_ON_FAILURE(hr);

    hr = pPath->put_Type(_ADsValue.pPath->Type);
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_VolumeName(_ADsValue.pPath->VolumeName);
    BAIL_ON_FAILURE(hr);

    hr = pPath->put_Path(_ADsValue.pPath->Path);
    BAIL_ON_FAILURE(hr);

   hr = pPath->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pPath) {
      pPath->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_Path(THIS_ IDispatch FAR* pdPath)
{
   IADsPath *pPath = NULL;
   HRESULT hr = S_OK;
   LONG lnType = 0;
   BSTR bstrVolumeName = NULL;
   BSTR bstrPath = NULL;

    ClearData();

   hr = pdPath->QueryInterface(
                             IID_IADsPath,
                             (void **)&pPath
                             );
   BAIL_ON_FAILURE(hr);

    hr = pPath->get_Type(
                    &lnType
                    );
    BAIL_ON_FAILURE(hr);
    hr = pPath->get_VolumeName(
                    &bstrVolumeName
                    );
    BAIL_ON_FAILURE(hr);
    hr = pPath->get_Path(
                    &bstrPath
                    );
    BAIL_ON_FAILURE(hr);


   _ADsValue.dwType = ADSTYPE_PATH;
    _ADsValue.pPath = (PADS_PATH)AllocADsMem(sizeof(ADS_PATH));
    if (!_ADsValue.pPath) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

   _ADsValue.pPath->Type = lnType;
   _ADsValue.pPath->VolumeName = AllocADsStr(bstrVolumeName);
   if (!_ADsValue.pPath->VolumeName && bstrVolumeName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
   }
   _ADsValue.pPath->Path = AllocADsStr(bstrPath);
   if (!_ADsValue.pPath->Path && bstrPath) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
   }

error:
   if (pPath) {
        pPath->Release();
    }

   if(bstrVolumeName)
   {
       SysFreeString(bstrVolumeName);    
   }

   if(bstrPath)
   {
       SysFreeString(bstrPath);
   }

   

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_ReplicaPointer(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsReplicaPointer* pReplicaPointer = NULL;
   IDispatch * pDispatch = NULL;
   IADsNetAddress* pNetAddress = NULL;
   VARIANT VarNetAddress;
   VARIANT VarDest;

   VariantInit(&VarNetAddress);
   VariantInit(&VarDest);

   if (_ADsValue.dwType != ADSTYPE_REPLICAPOINTER) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

    if (!_ADsValue.pReplicaPointer) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_ReplicaPointer,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsReplicaPointer,
            (void **) &pReplicaPointer);
   BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ReplicaType(_ADsValue.pReplicaPointer->ReplicaType);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ReplicaNumber(_ADsValue.pReplicaPointer->ReplicaNumber);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_Count(_ADsValue.pReplicaPointer->Count);
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->put_ServerName(_ADsValue.pReplicaPointer->ServerName);
    BAIL_ON_FAILURE(hr);

    ////

   hr = CoCreateInstance(
            CLSID_NetAddress,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsNetAddress,
            (void **) &pNetAddress);
   BAIL_ON_FAILURE(hr);


    hr = pNetAddress->put_AddressType(_ADsValue.pReplicaPointer->ReplicaAddressHints->AddressType);
    BAIL_ON_FAILURE(hr);

    hr = BinaryToVariant(
                _ADsValue.pReplicaPointer->ReplicaAddressHints->AddressLength,
                _ADsValue.pReplicaPointer->ReplicaAddressHints->Address,
                &VarNetAddress);
    BAIL_ON_FAILURE(hr);
    hr = pNetAddress->put_Address(VarNetAddress);
    BAIL_ON_FAILURE(hr);

   hr = pNetAddress->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

    V_VT(&VarDest) = VT_DISPATCH;
    V_DISPATCH(&VarDest) =  pDispatch;

    hr = pReplicaPointer->put_ReplicaAddressHints(VarDest);
    BAIL_ON_FAILURE(hr);

   hr = pReplicaPointer->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:
    VariantClear(&VarNetAddress);
    VariantClear(&VarDest);
   if (pReplicaPointer) {
      pReplicaPointer->Release();
   }

   if (pNetAddress) {
       pNetAddress->Release();
   }
   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_ReplicaPointer(THIS_ IDispatch FAR* pdReplicaPointer)
{
   IADsReplicaPointer *pReplicaPointer = NULL;
   HRESULT hr = S_OK;
   LONG lnAmount= 0;
   IADsNetAddress *pNetAddress = NULL;
   LONG lnAddressType = 0;
   VARIANT varAddress;
   IDispatch *pdNetAddress = NULL;
    long lnReplicaType;
    long lnReplicaNumber;
    long lnCount;
    BSTR bstrServerName = NULL;

    VariantInit(&varAddress);
    ClearData();

    _ADsValue.pReplicaPointer = (PADS_REPLICAPOINTER)AllocADsMem(sizeof(ADS_REPLICAPOINTER));
    if (!_ADsValue.pReplicaPointer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _ADsValue.pReplicaPointer->ReplicaAddressHints =
                        (PADS_NETADDRESS)
                        AllocADsMem(
                            sizeof(ADS_NETADDRESS)
                            );
    if (!(_ADsValue.pReplicaPointer->ReplicaAddressHints)) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
    }

   hr = pdReplicaPointer->QueryInterface(
                             IID_IADsReplicaPointer,
                             (void **)&pReplicaPointer
                             );
   BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->get_ReplicaType(
                    &lnReplicaType
                    );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->get_ReplicaNumber(
                    &lnReplicaNumber
                    );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->get_Count(
                    &lnCount
                    );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->get_ServerName(
                    &bstrServerName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pReplicaPointer->get_ReplicaAddressHints(&varAddress);
    BAIL_ON_FAILURE(hr);

    if (V_VT(&varAddress) != VT_DISPATCH){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pdNetAddress = V_DISPATCH(&varAddress);

    hr = pdNetAddress->QueryInterface(
                             IID_IADsNetAddress,
                             (void **)&pNetAddress
                             );
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->get_AddressType(
                    &lnAddressType
                    );
    BAIL_ON_FAILURE(hr);

    hr = pNetAddress->get_Address(
                    &varAddress
                    );
    BAIL_ON_FAILURE(hr);

    hr = VariantToBinary(
                    &varAddress,
                    &_ADsValue.pReplicaPointer->ReplicaAddressHints->AddressLength,
                    &_ADsValue.pReplicaPointer->ReplicaAddressHints->Address
                    );

    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_REPLICAPOINTER;
   _ADsValue.pReplicaPointer->ReplicaAddressHints->AddressType = lnAddressType;
   _ADsValue.pReplicaPointer->ReplicaType = lnReplicaType;
   _ADsValue.pReplicaPointer->ReplicaNumber = lnReplicaNumber;
   _ADsValue.pReplicaPointer->Count = lnCount;
   _ADsValue.pReplicaPointer->ServerName = AllocADsStr(bstrServerName);
   if (!_ADsValue.pReplicaPointer->ServerName && bstrServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
   }

error:
    VariantClear(&varAddress);
   if (pNetAddress) {
        pNetAddress->Release();
    }
   if (pReplicaPointer) {
        pReplicaPointer->Release();
    }

   if(bstrServerName)
   {
       SysFreeString(bstrServerName);
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_Timestamp(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsTimestamp* pTimestamp = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_TIMESTAMP) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_Timestamp,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsTimestamp,
            (void **) &pTimestamp);
   BAIL_ON_FAILURE(hr);

    hr = pTimestamp->put_WholeSeconds(_ADsValue.Timestamp.WholeSeconds);
    BAIL_ON_FAILURE(hr);

    hr = pTimestamp->put_EventID(_ADsValue.Timestamp.EventID);
    BAIL_ON_FAILURE(hr);

   hr = pTimestamp->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pTimestamp) {
      pTimestamp->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_Timestamp(THIS_ IDispatch FAR* lnTimestamp)
{
   IADsTimestamp *pTimestamp = NULL;
   HRESULT hr = S_OK;
   LONG lnWholeSeconds = 0;
   LONG lnEventID = 0;

    ClearData();
   hr = lnTimestamp->QueryInterface(
                             IID_IADsTimestamp,
                             (void **)&pTimestamp
                             );
   BAIL_ON_FAILURE(hr);

    hr = pTimestamp->get_WholeSeconds(
                    &lnWholeSeconds
                    );
    BAIL_ON_FAILURE(hr);
    hr = pTimestamp->get_EventID(
                    &lnEventID
                    );
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_TIMESTAMP;
   _ADsValue.Timestamp.WholeSeconds = lnWholeSeconds;
   _ADsValue.Timestamp.EventID = lnEventID;

error:
   if (pTimestamp) {
        pTimestamp->Release();
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_PostalAddress(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsPostalAddress * pPostalAddress = NULL;
   IDispatch * pDispatch = NULL;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i;
    BSTR bstrAddress = NULL;
    DWORD cElements = 0;
    VARIANT VarDestObject;

    VariantInit( &VarDestObject );

    if (_ADsValue.dwType != ADSTYPE_POSTALADDRESS) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

    if (!_ADsValue.pPostalAddress) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_PostalAddress,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsPostalAddress,
            (void **) &pPostalAddress);
   BAIL_ON_FAILURE(hr);

    aBound.lLbound = 0;
    aBound.cElements = 6;
    aList = SafeArrayCreate( VT_BSTR, 1, &aBound );
    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) 6; i++ )
    {
        hr = ADsAllocString(
                _ADsValue.pPostalAddress->PostalAddress[i],
                &bstrAddress
                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, bstrAddress );
        SysFreeString(bstrAddress);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(&VarDestObject) = VT_ARRAY | VT_BSTR;
    V_ARRAY(&VarDestObject) = aList;

    hr = pPostalAddress->put_PostalAddress(VarDestObject);
    BAIL_ON_FAILURE(hr);

    hr = pPostalAddress->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

    RRETURN(hr);

error:

    VariantClear( &VarDestObject );

    if (pPostalAddress) {
        pPostalAddress->Release();
    }
    if (aList) {
        SafeArrayDestroy( aList );
    }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_PostalAddress(THIS_ IDispatch FAR* pdPostalAddress)
{
   IADsPostalAddress *pPostalAddress = NULL;
   HRESULT hr = S_OK;
   LONG lnAmount= 0;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    long i;
    IDispatch FAR * pDispatch = NULL;
    BYTE*  pbParameter = NULL;
    VARIANT varAddress;
    VARIANT varBstrElement;

    VariantInit(&varAddress);
    ClearData();
   hr = pdPostalAddress->QueryInterface(
                             IID_IADsPostalAddress,
                             (void **)&pPostalAddress
                             );
   BAIL_ON_FAILURE(hr);

    _ADsValue.dwType = ADSTYPE_POSTALADDRESS;

    _ADsValue.pPostalAddress = (PADS_POSTALADDRESS)AllocADsMem(sizeof(ADS_POSTALADDRESS));
    if (!_ADsValue.pPostalAddress) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = pPostalAddress->get_PostalAddress(
                    &varAddress
                    );
    BAIL_ON_FAILURE(hr);
    if(!((V_VT(&varAddress) &  VT_VARIANT) &&  V_ISARRAY(&varAddress))) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ((V_ARRAY(&varAddress))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if ( ((V_ARRAY(&varAddress))->rgsabound[0].cElements <= 0) ||
         ((V_ARRAY(&varAddress))->rgsabound[0].cElements >6) ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&varAddress),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&varAddress),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    for (i = dwSLBound; i <= (long)dwSUBound; i++) {

        VariantInit(&varBstrElement);
        hr = SafeArrayGetElement(V_ARRAY(&varAddress),
                                (long FAR *)&i,
                                &varBstrElement
                                );
        BAIL_ON_FAILURE(hr);

        _ADsValue.pPostalAddress->PostalAddress[i-dwSLBound] = AllocADsStr(V_BSTR(&varBstrElement));
        VariantClear(&varBstrElement);
        if (!_ADsValue.pPostalAddress->PostalAddress[i-dwSLBound]) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }
    RRETURN(S_OK);

error:
    VariantClear(&varAddress);
   if (pPostalAddress) {
        pPostalAddress->Release();
    }

   RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::get_BackLink(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsBackLink* pBackLink = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_BACKLINK) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_BackLink,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsBackLink,
            (void **) &pBackLink);
   BAIL_ON_FAILURE(hr);

    hr = pBackLink->put_RemoteID(_ADsValue.BackLink.RemoteID);
    BAIL_ON_FAILURE(hr);

    hr = pBackLink->put_ObjectName(_ADsValue.BackLink.ObjectName);
    BAIL_ON_FAILURE(hr);

   hr = pBackLink->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pBackLink) {
      pBackLink->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_BackLink(THIS_ IDispatch FAR* pdBackLink)
{
   IADsBackLink *pBackLink = NULL;
   HRESULT hr = S_OK;
   LONG lnRemoteID = 0;
   BSTR bstrObjectName = NULL;

    ClearData();
   hr = pdBackLink->QueryInterface(
                             IID_IADsBackLink,
                             (void **)&pBackLink
                             );
   BAIL_ON_FAILURE(hr);

    hr = pBackLink->get_RemoteID(
                    &lnRemoteID
                    );
    BAIL_ON_FAILURE(hr);
    hr = pBackLink->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_BACKLINK;
   _ADsValue.BackLink.RemoteID = lnRemoteID;
   _ADsValue.BackLink.ObjectName = AllocADsStr(bstrObjectName);
    if (!_ADsValue.BackLink.ObjectName && bstrObjectName ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:
   if (pBackLink) {
        pBackLink->Release();
    }

   if(bstrObjectName)
   {
       SysFreeString(bstrObjectName);
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_TypedName(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsTypedName* pTypedName = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_TYPEDNAME) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

    if (!_ADsValue.pTypedName) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


   hr = CoCreateInstance(
            CLSID_TypedName,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsTypedName,
            (void **) &pTypedName);
   BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_Level(_ADsValue.pTypedName->Level);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_Interval(_ADsValue.pTypedName->Interval);
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->put_ObjectName(_ADsValue.pTypedName->ObjectName);
    BAIL_ON_FAILURE(hr);

   hr = pTypedName->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pTypedName) {
      pTypedName->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_TypedName(THIS_ IDispatch FAR* pdTypedName)
{
   IADsTypedName* pTypedName = NULL;
   HRESULT hr = S_OK;
   LONG lnLevel= 0;
   LONG lnInterval= 0;
   BSTR bstrObjectName = NULL;

    ClearData();
   hr = pdTypedName->QueryInterface(
                             IID_IADsTypedName,
                             (void **)&pTypedName
                             );
   BAIL_ON_FAILURE(hr);

    hr = pTypedName->get_Level(
                    &lnLevel
                    );
    BAIL_ON_FAILURE(hr);
    hr = pTypedName->get_Interval(
                    &lnInterval
                    );
    BAIL_ON_FAILURE(hr);

    hr = pTypedName->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_TYPEDNAME;

    _ADsValue.pTypedName = (PADS_TYPEDNAME)AllocADsMem(sizeof(ADS_TYPEDNAME));
    if (!_ADsValue.pTypedName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

   _ADsValue.pTypedName->Level= lnLevel;
   _ADsValue.pTypedName->Interval= lnInterval;
   _ADsValue.pTypedName->ObjectName = AllocADsStr(bstrObjectName);
    if (!_ADsValue.pTypedName->ObjectName && bstrObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:
   if (pTypedName) {
        pTypedName->Release();
    }

   if(bstrObjectName)
   {
       SysFreeString(bstrObjectName);
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::get_Hold(THIS_ IDispatch FAR * FAR *retval)
{
   HRESULT hr = S_OK;
   IADsHold* pHold = NULL;
   IDispatch * pDispatch = NULL;

   if (_ADsValue.dwType != ADSTYPE_HOLD) {
      hr = E_ADS_CANT_CONVERT_DATATYPE;
      BAIL_ON_FAILURE(hr);
    }

   hr = CoCreateInstance(
            CLSID_Hold,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsHold,
            (void **) &pHold);
   BAIL_ON_FAILURE(hr);

    hr = pHold->put_Amount(_ADsValue.Hold.Amount);
    BAIL_ON_FAILURE(hr);

    hr = pHold->put_ObjectName(_ADsValue.Hold.ObjectName);
    BAIL_ON_FAILURE(hr);

   hr = pHold->QueryInterface(
            IID_IDispatch,
            (void **) &pDispatch
            );
   BAIL_ON_FAILURE(hr);

   *retval = pDispatch;

error:

   if (pHold) {
      pHold->Release();
   }

   RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::put_Hold(THIS_ IDispatch FAR* pdHold)
{
   IADsHold *pHold = NULL;
   HRESULT hr = S_OK;
   LONG lnAmount= 0;
   BSTR bstrObjectName = NULL;

   ClearData();
   hr = pdHold->QueryInterface(
                             IID_IADsHold,
                             (void **)&pHold
                             );
   BAIL_ON_FAILURE(hr);

    hr = pHold->get_Amount(
                    &lnAmount
                    );
    BAIL_ON_FAILURE(hr);
    hr = pHold->get_ObjectName(
                    &bstrObjectName
                    );
    BAIL_ON_FAILURE(hr);

   _ADsValue.dwType = ADSTYPE_HOLD;
   _ADsValue.Hold.Amount= lnAmount;
   _ADsValue.Hold.ObjectName = AllocADsStr(bstrObjectName);
    if (!_ADsValue.Hold.ObjectName && bstrObjectName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:
   if (pHold) {
        pHold->Release();
    }

   if(bstrObjectName)
   {
       SysFreeString(bstrObjectName);
   }

   RRETURN(hr);
}


//
// Helper to get octetString in variant if we have a
// secDesc stored underneath.
//
STDMETHODIMP
CPropertyValue::getOctetStringFromSecDesc(VARIANT FAR *retval)
{
   HRESULT hr = S_OK;
   SAFEARRAY *aList = NULL;
   SAFEARRAYBOUND aBound;
   CHAR HUGEP *pArray = NULL;
   ADSVALUE ADsDestValue;

   memset(&ADsDestValue, 0, sizeof(ADSVALUE));

   hr = AdsCopyPropObjToADsValue(
            this,
            &ADsDestValue,
            NULL, // pszServerName,
            NULL, // pCredentials - use default credentials
            TRUE  // fNTDSType
            );

   BAIL_ON_FAILURE(hr);

   if (ADsDestValue.dwType != ADSTYPE_OCTET_STRING) {
       BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
   }

   aBound.lLbound = 0;
   aBound.cElements = ADsDestValue.OctetString.dwLength;

   aList = SafeArrayCreate( VT_UI1, 1, &aBound );

   if ( aList == NULL ) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray);
   BAIL_ON_FAILURE(hr);

   memcpy(pArray, ADsDestValue.OctetString.lpValue, aBound.cElements);

   SafeArrayUnaccessData( aList );

   V_VT(retval) = VT_ARRAY | VT_UI1;
   V_ARRAY(retval) = aList;

error:

    if (FAILED(hr) && aList) {
        SafeArrayDestroy(aList);
    }

    AdsClear(&ADsDestValue);

    RRETURN(hr);
}



//
// Helper to get SecDesc in variant if we have a
// octetString stored underneath.
//
STDMETHODIMP
CPropertyValue::getSecurityDescriptorFromOctStr(VARIANT FAR *retval)
{
   HRESULT hr = S_OK;
   CCredentials dummyCredentials(NULL, NULL, 0);


   hr = ConvertSecDescriptorToVariant(
            NULL, // pszServerName
            dummyCredentials,
            _ADsValue.OctetString.lpValue,
            retval,
            TRUE // NTDS Type
            );

    RRETURN(hr);
}


//
// There has to be a better way to do this. Ideally this code
// should live in one plae and we should be able to use that
// everywhere. Currently it lives here as well as in the ldap
// provider - slight differences though.
// This comment holds true for DNWithString also - AjayR 4-30-99
//
STDMETHODIMP
CPropertyValue::getDNWithBinary(THIS_ IDispatch FAR * FAR * ppDispatch)
{
   HRESULT hr = S_OK;
   IADsDNWithBinary *pDNWithBinary = NULL;
   SAFEARRAY *aList = NULL;
   SAFEARRAYBOUND aBound;
   CHAR HUGEP *pArray = NULL;
   BSTR bstrTemp = NULL;
   VARIANT vVar;

   VariantInit(&vVar);

   if (_ADsValue.dwType != ADSTYPE_DN_WITH_BINARY) {
       BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
   }


   hr = CoCreateInstance(
            CLSID_DNWithBinary,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IADsDNWithBinary,
            (void **) &pDNWithBinary
            );
   BAIL_ON_FAILURE(hr);

   if (_ADsValue.pDNWithBinary->pszDNString) {
       hr = ADsAllocString(_ADsValue.pDNWithBinary->pszDNString, &bstrTemp);
       BAIL_ON_FAILURE(hr);

       //
        // Put the value in the object - we can only set BSTR's
       //
       hr = pDNWithBinary->put_DNString(bstrTemp);
       BAIL_ON_FAILURE(hr);
    }

    aBound.lLbound = 0;
    aBound.cElements = _ADsValue.pDNWithBinary->dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, _ADsValue.pDNWithBinary->lpBinaryValue, aBound.cElements );

    SafeArrayUnaccessData( aList );

    V_VT(&vVar) = VT_ARRAY | VT_UI1;
    V_ARRAY(&vVar) = aList;

    hr = pDNWithBinary->put_BinaryValue(vVar);
    VariantClear(&vVar);
    BAIL_ON_FAILURE(hr);

    hr = pDNWithBinary->QueryInterface(
                            IID_IDispatch,
                            (void **) ppDispatch
                            );
    BAIL_ON_FAILURE(hr);

error:

    if (pDNWithBinary) {
        pDNWithBinary->Release();
    }

    if (bstrTemp) {
        ADsFreeString(bstrTemp);
    }

    RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::putDNWithBinary(THIS_ IDispatch * pDNWithBinary)
{
    HRESULT hr = S_OK;
    IADsDNWithBinary * pDNBinary = NULL;
    PADS_DN_WITH_BINARY pDNBin = NULL;
    VARIANT vBinary;
    DWORD dwSUBound = 0;
    DWORD dwSLBound = 0;
    DWORD dwLength  = 0;
    BSTR bstrDN = NULL;
    LPBYTE lpByte = NULL;
    CHAR HUGEP *pArray = NULL;

    VariantInit(&vBinary);

    ClearData();

    //
    // This qi ensures that this is a security descriptor
    //
    hr = pDNWithBinary->QueryInterface(
                            IID_IADsDNWithBinary,
                            (void **) &pDNBinary
                            );

    BAIL_ON_FAILURE(hr);

    //
    // Convert to ADSVALUE and then to ldap representation.
    // This way the code to and from LDAP lives in one place.
    //
    hr = pDNBinary->get_BinaryValue(&vBinary);
    BAIL_ON_FAILURE(hr);

    if ((vBinary.vt != (VT_ARRAY | VT_UI1))
        && vBinary.vt != VT_EMPTY) {

        BAIL_ON_FAILURE(hr = E_FAIL);
    }

    hr = pDNBinary->get_DNString(&bstrDN);
    BAIL_ON_FAILURE(hr);

    //
    // Get the byte array in a usable format.
    //
    hr = SafeArrayGetLBound(
             V_ARRAY(&vBinary),
             1,
             (long FAR *) &dwSLBound
             );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(
             V_ARRAY(&vBinary),
             1,
             (long FAR *) &dwSUBound
             );
    BAIL_ON_FAILURE(hr);

    dwLength = dwSUBound - dwSLBound + 1;

    lpByte = (LPBYTE) AllocADsMem(dwLength);

    if (dwLength && !lpByte) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    hr = SafeArrayAccessData(
             V_ARRAY(&vBinary),
             (void HUGEP * FAR *) &pArray
             );
    BAIL_ON_FAILURE(hr);

    memcpy(lpByte, pArray, dwLength);

    SafeArrayUnaccessData( V_ARRAY(&vBinary) );

    pDNBin = (PADS_DN_WITH_BINARY) AllocADsMem(sizeof(ADS_DN_WITH_BINARY));

    if (!pDNBin) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    if (bstrDN) {

        pDNBin->pszDNString = AllocADsStr(bstrDN);

        if (!pDNBin->pszDNString && bstrDN) {
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
        }
    }

    _ADsValue.dwType = ADSTYPE_DN_WITH_BINARY;
    _ADsValue.pDNWithBinary = pDNBin;
    _ADsValue.pDNWithBinary->lpBinaryValue = lpByte;
    _ADsValue.pDNWithBinary->dwLength = dwLength;


error:

    if (pDNBinary) {
        pDNBinary->Release();
    }

    if (FAILED(hr)) {

        if (lpByte) {
            FreeADsMem(lpByte);
        }

        if (pDNBin) {
            if (pDNBin->pszDNString) {
                FreeADsStr(pDNBin->pszDNString);
            }

            FreeADsMem(pDNBin);
        }

    }

    if (bstrDN) {
        ADsFreeString(bstrDN);
    }

    VariantClear(&vBinary);

    RRETURN(hr);


}

STDMETHODIMP
CPropertyValue::putDNWithString(THIS_ IDispatch * pDNWithString)
{
    HRESULT hr = S_OK;
    IADsDNWithString *pDNString = NULL;
    PADS_DN_WITH_STRING pDNStr = NULL;
    BSTR bstrStringValue = NULL;
    BSTR bstrDN = NULL;

    ClearData();

    hr = pDNWithString->QueryInterface(
                            IID_IADsDNWithString,
                            (void **)&pDNString
                            );
    BAIL_ON_FAILURE(hr);

    hr = pDNString->get_StringValue(&bstrStringValue);
    BAIL_ON_FAILURE(hr);

    hr = pDNString->get_DNString(&bstrDN);
    BAIL_ON_FAILURE(hr);

    _ADsValue.dwType = ADSTYPE_DN_WITH_STRING;
    pDNStr = (PADS_DN_WITH_STRING) AllocADsMem(sizeof(ADS_DN_WITH_STRING));

    if (!pDNStr) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // Put String value in the DNString struct.
    //
    pDNStr->pszStringValue = AllocADsStr(bstrStringValue);

    if (bstrStringValue && !pDNStr->pszStringValue) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pDNStr->pszDNString = AllocADsStr(bstrDN);

    if (bstrDN && !pDNStr->pszDNString) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    _ADsValue.dwType = ADSTYPE_DN_WITH_STRING;
    _ADsValue.pDNWithString = pDNStr;

error:

    if (pDNString) {
        pDNString->Release();
    }

    if (bstrStringValue) {
        ADsFreeString(bstrStringValue);
    }

    if (bstrDN) {
        ADsFreeString(bstrDN);
    }

    if (pDNStr && FAILED(hr)) {

        if (pDNStr->pszDNString) {
            FreeADsStr(pDNStr->pszDNString);
        }

        if (pDNStr->pszStringValue) {
            FreeADsMem(pDNStr->pszStringValue);
        }
        FreeADsMem(pDNStr);
    }

    RRETURN(hr);

}


STDMETHODIMP
CPropertyValue::getDNWithString(THIS_ IDispatch FAR * FAR * ppDispatch)
{
    HRESULT hr = S_OK;
    ADSVALUE AdsValue;
    IADsDNWithString *pDNWithString = NULL;
    IDispatch *pDispatch = NULL;
    BSTR bstrStrVal = NULL;
    BSTR bstrDNVal = NULL;

    if (_ADsValue.dwType != ADSTYPE_DN_WITH_STRING) {
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = CoCreateInstance(
             CLSID_DNWithString,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IADsDNWithString,
             (void **) &pDNWithString
             );
    BAIL_ON_FAILURE(hr);



    if (_ADsValue.pDNWithString->pszDNString) {
        hr = ADsAllocString(_ADsValue.pDNWithString->pszDNString, &bstrDNVal);
        BAIL_ON_FAILURE(hr);

        hr = pDNWithString->put_DNString(bstrDNVal);
        BAIL_ON_FAILURE(hr);
    }

    if (_ADsValue.pDNWithString->pszStringValue) {
        hr = ADsAllocString(
                 _ADsValue.pDNWithString->pszStringValue,
                 &bstrStrVal
                 );
        BAIL_ON_FAILURE(hr);

        hr = pDNWithString->put_StringValue(bstrStrVal);

        BAIL_ON_FAILURE(hr);
    }

    hr = pDNWithString->QueryInterface(
                            IID_IDispatch,
                            (void **) ppDispatch
                            );
    BAIL_ON_FAILURE(hr);

error:

    if (pDNWithString) {
        pDNWithString->Release();
    }

    if (bstrDNVal) {
        ADsFreeString(bstrDNVal);
    }

    if (bstrStrVal) {
        ADsFreeString(bstrStrVal);
    }

    RRETURN(hr);
}


STDMETHODIMP
CPropertyValue::getProvSpecific(THIS_ VARIANT FAR *retval )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    if (_ADsValue.dwType != ADSTYPE_PROV_SPECIFIC) {
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    aBound.lLbound = 0;
    aBound.cElements = _ADsValue.ProviderSpecific.dwLength;

    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray,
            _ADsValue.ProviderSpecific.lpValue,
            aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(retval) = VT_ARRAY | VT_UI1;
    V_ARRAY(retval) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }

    RRETURN_EXP_IF_ERR(hr);
}

STDMETHODIMP
CPropertyValue::putProvSpecific(THIS_ VARIANT VarProvSpecific)
{
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    HRESULT hr = S_OK;

    ClearData();

    _ADsValue.dwType = ADSTYPE_PROV_SPECIFIC;

    if( VarProvSpecific.vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(&VarProvSpecific),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&VarProvSpecific),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    _ADsValue.ProviderSpecific.lpValue = (LPBYTE)AllocADsMem(dwSUBound - dwSLBound + 1);

    if ( _ADsValue.ProviderSpecific.lpValue == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    _ADsValue.ProviderSpecific.dwLength = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(&VarProvSpecific),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( _ADsValue.ProviderSpecific.lpValue,
            pArray,
            dwSUBound-dwSLBound+1);

    SafeArrayUnaccessData( V_ARRAY(&VarProvSpecific) );

error:
    RRETURN_EXP_IF_ERR(hr);
}

void
CPropertyValue::ClearData()
{
    //
    // For all the types - this works even if the adsvalue is null
    // as adsvalue.dwType = 0 ---> invalid_type does nothing !!!
    //
    AdsClear(&_ADsValue);

    if (_pDispatch) {

        switch (_dwDataType) {

        case VAL_IDISPATCH_SECDESC_ONLY:
        case VAL_IDISPATCH_SECDESC_ALL:

           _pDispatch->Release();
           _pDispatch = NULL;
           _dwDataType = VAL_IDISPATCH_UNKNOWN;
           break;

        default:

            ADsAssert(!"Internal incosistency secdesc ptr but bad type.");
            _pDispatch = NULL;
            _dwDataType = VAL_IDISPATCH_UNKNOWN;
            break;

        } // end switch
    }
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyValue::GetObjectProperty
//
//  Synopsis: Gets the values stored in this PropertyValue object. The
// value returned is determined by the value requested in lnContorlCode.
// For now though we will only support ADSTYPE_UNKNOWN in which case we
// get the info from the object itself. Alternatively the type should match
// that which is in the object.
//
//
//  Arguments: lnControlCode - ADSTYPE_INVALID implies whatever we have
//                           - anything else implies we return the type.
//             pvProp        - the output value goes into this.
//
//
//-------------------------------------------------------------------------
STDMETHODIMP
CPropertyValue::GetObjectProperty(
    THIS_ long *lnControlCode,
    VARIANT *pvProp
    )
{
    HRESULT hr = S_OK;
    ADSTYPE dwTypeAsked = ADSTYPE_INVALID;

    ADsAssert(pvProp);
    ADsAssert(lnControlCode);


    if (*lnControlCode == ADSTYPE_UNKNOWN) {
        dwTypeAsked = _ADsValue.dwType;
    } else {
        dwTypeAsked = (ADSTYPE)*lnControlCode;
    }

    *lnControlCode = dwTypeAsked;

    switch (dwTypeAsked) {

    case ADSTYPE_INVALID:
        BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        break;

    case ADSTYPE_DN_STRING :
        pvProp->vt = VT_BSTR;
        hr = get_DNString(&(pvProp->bstrVal));
        break;

    case ADSTYPE_CASE_EXACT_STRING :
        pvProp->vt = VT_BSTR;
        hr = get_CaseExactString(&(pvProp->bstrVal));
        break;

    case ADSTYPE_CASE_IGNORE_STRING :
        pvProp->vt = VT_BSTR;
        hr = get_CaseIgnoreString(&(pvProp->bstrVal));
        break;

    case ADSTYPE_PRINTABLE_STRING :
        pvProp->vt = VT_BSTR;
        hr = get_PrintableString(&(pvProp->bstrVal));
        break;

    case ADSTYPE_NUMERIC_STRING :
        pvProp->vt = VT_BSTR;
        hr = get_NumericString(&(pvProp->bstrVal));
        break;

    case ADSTYPE_BOOLEAN :
        {
            LONG lnVal = 0;

            pvProp->vt = VT_BOOL;
            hr = get_Boolean(&(lnVal));
            if (SUCCEEDED(hr)) {
                pvProp->boolVal = lnVal ? VARIANT_TRUE : VARIANT_FALSE;
            }
        }
            break;


    case ADSTYPE_INTEGER :
        pvProp->vt = VT_I4;
        hr = get_Integer(&(pvProp->lVal));
        break;

    case ADSTYPE_OCTET_STRING :
        hr = get_OctetString(pvProp);

        if (hr == E_ADS_CANT_CONVERT_DATATYPE) {
            //
            // Try and see if it is a SD and convert
            //
            if (_ADsValue.dwType == ADSTYPE_NT_SECURITY_DESCRIPTOR) {
                hr = getOctetStringFromSecDesc(pvProp);
            }
        }
        break;

    case ADSTYPE_PROV_SPECIFIC :
        hr = getProvSpecific(pvProp);
        break;

    case ADSTYPE_UTC_TIME :
        pvProp->vt = VT_DATE;
        hr = get_UTCTime(&(pvProp->date));
        break;

    case ADSTYPE_LARGE_INTEGER :
        pvProp->vt = VT_DISPATCH;
        hr = get_LargeInteger(&(pvProp->pdispVal));
        break;

    case ADSTYPE_OBJECT_CLASS :
        pvProp->vt = VT_DISPATCH;
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;

    case ADSTYPE_CASEIGNORE_LIST :
        pvProp->vt = VT_DISPATCH;
        hr = get_CaseIgnoreList(&(pvProp->pdispVal));
        break;

    case ADSTYPE_OCTET_LIST :
        pvProp->vt = VT_DISPATCH;
        hr = get_OctetList(&(pvProp->pdispVal));
        break;

    case ADSTYPE_PATH :
        pvProp->vt = VT_DISPATCH;
        hr = get_Path(&(pvProp->pdispVal));
        break;

    case ADSTYPE_POSTALADDRESS :
        pvProp->vt = VT_DISPATCH;
        hr = get_PostalAddress(&(pvProp->pdispVal));
        break;

    case ADSTYPE_TIMESTAMP :
        pvProp->vt = VT_DISPATCH;
        hr = get_Timestamp(&(pvProp->pdispVal));
        break;

    case ADSTYPE_BACKLINK :
        pvProp->vt = VT_DISPATCH;
        hr = get_BackLink(&(pvProp->pdispVal));
        break;

    case ADSTYPE_TYPEDNAME :
        pvProp->vt = VT_DISPATCH;
        hr = get_TypedName(&(pvProp->pdispVal));
        break;

    case ADSTYPE_HOLD :
        pvProp->vt = VT_DISPATCH;
        hr = get_Hold(&(pvProp->pdispVal));
        break;

    case ADSTYPE_NETADDRESS :
        pvProp->vt = VT_DISPATCH;
        hr = get_NetAddress(&(pvProp->pdispVal));
        break;

    case ADSTYPE_REPLICAPOINTER :
        pvProp->vt = VT_DISPATCH;
        hr = get_ReplicaPointer(&(pvProp->pdispVal));
        break;

    case ADSTYPE_FAXNUMBER :
        pvProp->vt = VT_DISPATCH;
        hr = get_FaxNumber(&(pvProp->pdispVal));
        break;

    case ADSTYPE_EMAIL :
        pvProp->vt = VT_DISPATCH;
        hr = get_Email(&(pvProp->pdispVal));
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR :
        pvProp->vt = VT_DISPATCH;
        hr = get_SecurityDescriptor(&(pvProp->pdispVal));

        if (hr == E_ADS_CANT_CONVERT_DATATYPE) {
            //
            // Try and see if it is an OctetString needed as SecDesc
            //
            if (_ADsValue.dwType == ADSTYPE_OCTET_STRING) {
                hr = getSecurityDescriptorFromOctStr(pvProp);
            }
        }
        break;

    case ADSTYPE_DN_WITH_BINARY:
        pvProp->vt = VT_DISPATCH;
        hr = getDNWithBinary(&(pvProp->pdispVal));
        break;

    case ADSTYPE_DN_WITH_STRING:
        pvProp->vt = VT_DISPATCH;
        hr = getDNWithString(&(pvProp->pdispVal));
        break;

    case ADSTYPE_UNKNOWN :
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;

    default:
        // We should never be here
        hr = E_ADS_BAD_PARAMETER;
        break;

    }

error:

    RRETURN(hr);
}

STDMETHODIMP
CPropertyValue::PutObjectProperty(
    THIS_ long lnControlCode,
    VARIANT varObj
    )
{
    HRESULT hr = S_OK;
    VARIANT *pvVar = &varObj;

    if (lnControlCode == ADSTYPE_UNKNOWN
        || lnControlCode == ADSTYPE_INVALID) {

        BAIL_ON_FAILURE(hr=E_ADS_BAD_PARAMETER);
    }

    if (V_VT(pvVar) == (VT_BYREF|VT_VARIANT)) {
        //
        // The value is being passed in byref so we need to
        // deref it for vbs stuff to work
        //
        pvVar = V_VARIANTREF(&varObj);
    }

    switch (lnControlCode) {

    case ADSTYPE_INVALID:
        BAIL_ON_FAILURE(hr = E_ADS_BAD_PARAMETER);
        break;

    case ADSTYPE_DN_STRING :
        if (pvVar->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_DNString(pvVar->bstrVal);
        break;

    case ADSTYPE_CASE_EXACT_STRING :
        if (pvVar->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }
        hr = put_CaseExactString(pvVar->bstrVal);
        break;

    case ADSTYPE_CASE_IGNORE_STRING :
        if (pvVar->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_CaseIgnoreString(pvVar->bstrVal);
        break;

    case ADSTYPE_PRINTABLE_STRING :
        if (pvVar->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_PrintableString(pvVar->bstrVal);
        break;

    case ADSTYPE_NUMERIC_STRING :
        if (pvVar->vt != VT_BSTR) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_NumericString(pvVar->bstrVal);
        break;

    case ADSTYPE_BOOLEAN :

        if (pvVar->vt != VT_BOOL) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Boolean((pvVar->boolVal == VARIANT_TRUE) ? TRUE : FALSE);
        break;

    case ADSTYPE_INTEGER :
        if (pvVar->vt != VT_I4) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Integer(pvVar->lVal);
        break;

    case ADSTYPE_OCTET_STRING :
        hr = put_OctetString(*pvVar);
        break;

    case ADSTYPE_PROV_SPECIFIC :
        hr = putProvSpecific(varObj);
        break;

    case ADSTYPE_UTC_TIME :
        if (pvVar->vt != VT_DATE) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_UTCTime(pvVar->date);
        break;

    case ADSTYPE_LARGE_INTEGER :
        if (pvVar->vt != VT_DISPATCH) {
           BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_LargeInteger(pvVar->pdispVal);
        break;

    case ADSTYPE_OBJECT_CLASS :
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;

    case ADSTYPE_CASEIGNORE_LIST :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_CaseIgnoreList(pvVar->pdispVal);
        break;

    case ADSTYPE_OCTET_LIST :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_OctetList(pvVar->pdispVal);
        break;

    case ADSTYPE_PATH :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Path(pvVar->pdispVal);
        break;

    case ADSTYPE_POSTALADDRESS :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_PostalAddress(pvVar->pdispVal);
        break;

    case ADSTYPE_TIMESTAMP :
        if (pvVar->vt != VT_DISPATCH){
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Timestamp(pvVar->pdispVal);
        break;

    case ADSTYPE_BACKLINK :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_BackLink(pvVar->pdispVal);
        break;

    case ADSTYPE_TYPEDNAME :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_TypedName(pvVar->pdispVal);
        break;

    case ADSTYPE_HOLD :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Hold(pvVar->pdispVal);
        break;

    case ADSTYPE_NETADDRESS :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_NetAddress(pvVar->pdispVal);
        break;

    case ADSTYPE_REPLICAPOINTER :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_ReplicaPointer(pvVar->pdispVal);
        break;

    case ADSTYPE_FAXNUMBER :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_FaxNumber(pvVar->pdispVal);
        break;

    case ADSTYPE_EMAIL :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_Email(pvVar->pdispVal);
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = put_SecurityDescriptor(pvVar->pdispVal);
        break;

    case ADSTYPE_DN_WITH_BINARY :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = putDNWithBinary(pvVar->pdispVal);
        break;

    case ADSTYPE_DN_WITH_STRING :
        if (pvVar->vt != VT_DISPATCH) {
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }

        hr = putDNWithString(pvVar->pdispVal);
        break;

    case ADSTYPE_UNKNOWN :
        hr = E_ADS_CANT_CONVERT_DATATYPE;
        break;

    default:
        hr = E_ADS_BAD_PARAMETER;
        break;
    }

error:

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\cvaluecf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cdomcf.cxx
//
//  Contents:  Windows NT 3.5 Domain Object Class Factory Code
//
//             CADsNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "procs.hxx"
#pragma hdrstop
#include "oleds.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   CADsPropertyValueCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CADsPropertyValueCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPropertyValue::CreatePropertyValue(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\dbid.cxx ===
//------------------------------------------------------------------------------
//
//  Microsoft Sidewalk
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       oledbhelp.cpp
//
//  Contents:   OLE DB helper methods
//
//  Owner:      BassamT
//														 
//  History:    11/30/97   BassamT	Created.
//
//------------------------------------------------------------------------------

#include "oleds.hxx"

#if (!defined(BUILD_FOR_NT40))

#define dimensionof(x) sizeof(x)/sizeof(x[0])

HRESULT IsValidDBID
//------------------------------------------------------------------------------
// checks if we have a valid DBID
(
	const DBID * pdbid1
	// [in] the DBID to check
)
{
	Assert(pdbid1 != NULL);

	if (pdbid1 &&
		((pdbid1->eKind == DBKIND_GUID_NAME) ||
		(pdbid1->eKind == DBKIND_GUID_PROPID) ||
		(pdbid1->eKind == DBKIND_NAME) ||
		(pdbid1->eKind == DBKIND_PGUID_NAME) ||
		(pdbid1->eKind == DBKIND_PGUID_PROPID) ||
		(pdbid1->eKind == DBKIND_PROPID) ||
		(pdbid1->eKind == DBKIND_GUID)))
	{
		return S_OK;
	}
	else
	{
		return S_FALSE;
	}
}

BOOL CompareDBIDs
//------------------------------------------------------------------------------
// Compares two DBIDs. Given two DBIDS to determine if they are the same.
// Returns TRUE if they are the same DBIDs or FALSE if different
(
	const DBID * pdbid1,
	// [in] pointer to DBID 1; can be badly formed eKind
	const DBID * pdbid2
	// [in] pointer to DBID 2; assumed valid eKind
)
{
	// Array of valid eKind matches, in addition to matching exactly.
	static BYTE abKind[] =
	{
		DBKIND_PGUID_NAME,		// DBKIND_GUID_NAME
		DBKIND_PGUID_PROPID,	// DBKIND_GUID_PROPID
		DBKIND_NAME,			// DBKIND_NAME
		DBKIND_GUID_NAME,		// DBKIND_PGUID_NAME
		DBKIND_GUID_PROPID,		// DBKIND_PGUID_PROPID
		DBKIND_PROPID,			// DBKIND_PROPID
		DBKIND_GUID				// DBKIND_GUID
	};

	// Verify that offsets are correct (header file might change).
	Assert(	0 == DBKIND_GUID_NAME && 
			1 == DBKIND_GUID_PROPID && 
			2 == DBKIND_NAME && 
			3 == DBKIND_PGUID_NAME && 
			4 == DBKIND_PGUID_PROPID && 
			5 == DBKIND_PROPID && 
			6 == DBKIND_GUID);

	if (pdbid1 == NULL || pdbid2 == NULL)
	{
		return FALSE;
	}

	// Assume a match, and discard early if we can.

	// Don't assert for 1, since might be badly-formed.
	// 2 is assumed to be well-formed.
	Assert(inrange(((SHORT)pdbid2->eKind), 0, dimensionof(abKind)));

	if (pdbid1->eKind != pdbid2->eKind && 
		pdbid1->eKind != abKind[pdbid2->eKind])
	{
		return FALSE;
	}

	if (DBID_USE_GUID_OR_PGUID(pdbid1->eKind))
	{
		if (!DBID_USE_GUID_OR_PGUID(pdbid2->eKind))
		{
			return FALSE;
		}

		// Compare GUIDs.
		// Note that _GUID_ is equivalent to _PGUID_.
		if (!IsEqualGUID(
			DBID_USE_PGUID(pdbid1->eKind) ? *(pdbid1->uGuid.pguid) : pdbid1->uGuid.guid,
			DBID_USE_PGUID(pdbid2->eKind) ? *(pdbid2->uGuid.pguid) : pdbid2->uGuid.guid))
		{
			return FALSE;
		}
	}

	if (DBID_USE_NAME(pdbid1->eKind))
	{
		if (!DBID_USE_NAME(pdbid2->eKind))
		{
			return FALSE;
		}

		// Compare names.
		// Need to check if 1 is null and the other is not.
		if (((pdbid1->uName.pwszName == NULL) && (pdbid2->uName.pwszName != NULL)) || 
			((pdbid1->uName.pwszName != NULL) && (pdbid2->uName.pwszName == NULL)))
		{
			 return FALSE;
		}

		// Since the above check does not rule out both being null, which is
		// a valid comparison, and wcscmp will GPF if they were, we need
		// to check for valid pointers
		if(pdbid1->uName.pwszName != NULL && pdbid2->uName.pwszName != NULL)
		{
			// Assume null-terminated.
			if (_wcsicmp(pdbid1->uName.pwszName, pdbid2->uName.pwszName) != 0)
			{
				return FALSE;
			}
		}
	}

	if (DBID_USE_PROPID(pdbid1->eKind))
	{
		if (!DBID_USE_PROPID(pdbid2->eKind))
		{
			return FALSE;
		}
		// Compare PROPID.

		if (pdbid1->uName.ulPropid != pdbid2->uName.ulPropid)
		{
			return FALSE;
		}
	}

	// a match
	return TRUE;
}


void FreeDBID
//------------------------------------------------------------------------------
// FreeDBID
// Given a DBID free an allocated buffers
(
	DBID *pdbidSrc
	//[in] Pointer to DBID
)
{
	Assert(pdbidSrc);

	switch (pdbidSrc->eKind)
	{
	case DBKIND_GUID_NAME:
		CLIENT_FREE(pdbidSrc->uName.pwszName); 
		break;
	case DBKIND_NAME:
		CLIENT_FREE(pdbidSrc->uName.pwszName); 
		break;
	case DBKIND_PGUID_NAME:
		CLIENT_FREE(pdbidSrc->uGuid.pguid); 
		CLIENT_FREE(pdbidSrc->uName.pwszName); 
		break;
	case DBKIND_PGUID_PROPID:
		CLIENT_FREE(pdbidSrc->uGuid.pguid); 
		break;
	case DBKIND_GUID_PROPID:
	case DBKIND_PROPID:
	case DBKIND_GUID:
		break;
	default:
		Assert(NULL && L"Unhandled dbid1.ekind");
		break;
	}
}


HRESULT CopyDBIDs
//------------------------------------------------------------------------------
// Given a DBID to copy, put it in the new buffer
//
// Need to use IMalloc->Alloc and IMalloc->Free since this routine
// is used to copy the DBIDs from storage back into the memory handed to 
// the consumer.
//
// HRESULT indicating the status of the copy
//		S_OK = Copied
//		S_FALSE = Problems copying
//		E_OUTOFMEMORY = Could not allocate resources
//
(
	DBID * pdbidDest,	
	// [in,out] Pointer to Destination DBID
	const DBID *pdbidSrc
	// [in] Pointer to Source DBID
)
{
	Assert(pdbidDest);
	Assert(pdbidSrc);

	size_t	cwchBuffer;
	HRESULT hr;


	memset(pdbidDest, 0, sizeof(*pdbidDest));

	// Save eKind
	pdbidDest->eKind = pdbidSrc->eKind;

	switch (pdbidSrc->eKind)
	{
		case DBKIND_GUID_NAME:
			pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
			cwchBuffer = wcslen(pdbidSrc->uName.pwszName) + 1;

			if (pdbidDest->uName.pwszName = (PWSTR)CLIENT_MALLOC(cwchBuffer * sizeof(WCHAR))) 
			{
				wcsncpy(pdbidDest->uName.pwszName, pdbidSrc->uName.pwszName, cwchBuffer);
			}
			else
			{
				hr = E_OUTOFMEMORY;
				//ErrorTrace(hr);
				goto Error;
			}
			break;

		case DBKIND_GUID_PROPID:
			pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
			pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
			break;

		case DBKIND_NAME:
			cwchBuffer = wcslen(pdbidSrc->uName.pwszName) + 1;
			if (pdbidDest->uName.pwszName = (PWSTR)CLIENT_MALLOC(cwchBuffer * sizeof(WCHAR))) 
			{
				wcsncpy(pdbidDest->uName.pwszName, pdbidSrc->uName.pwszName, cwchBuffer);
			}
			else
			{
				hr = E_OUTOFMEMORY;
				//ErrorTrace(hr);
				goto Error;
			}
			break;

		case DBKIND_PGUID_NAME:
			// convert the pguid into a guid so that we don't have to do an extra malloc
			pdbidDest->eKind = DBKIND_GUID_NAME;
			pdbidDest->uGuid.guid = *pdbidSrc->uGuid.pguid;
			cwchBuffer = wcslen(pdbidSrc->uName.pwszName) + 1;

			if (pdbidDest->uName.pwszName = (PWSTR)CLIENT_MALLOC(cwchBuffer * sizeof(WCHAR))) 
			{
				wcsncpy(pdbidDest->uName.pwszName, pdbidSrc->uName.pwszName, cwchBuffer);
			}
			else
			{
				hr = E_OUTOFMEMORY;
				//ErrorTrace(hr);
				goto Error;
			}
			break;

		case DBKIND_PGUID_PROPID:
			// convert the pguid into a guid so that we don't have to do an extra malloc
			pdbidDest->eKind = DBKIND_GUID_PROPID;
			pdbidDest->uGuid.guid = *pdbidSrc->uGuid.pguid; 
			pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
			break;

		case DBKIND_PROPID:
			pdbidDest->uName.ulPropid = pdbidSrc->uName.ulPropid;
			break;

		case DBKIND_GUID:
			pdbidDest->uGuid.guid = pdbidSrc->uGuid.guid;
			break;

		default:
			Assert(NULL && L"Unhandled dbid ekind");
			hr = E_FAIL;
			//ErrorTrace(hr);
			goto Error;
	}

	return NOERROR;

Error:
	Assert(FAILED(hr));
	return hr;
}


INT CompareOLEDBTypes
//------------------------------------------------------------------------------
// Compares two value of the same DBTYPE.
//
// Returns :
//
//		0	if both values are equal
//		>0	if pvValue1 is greater than pvValue2
//		<0	if pvValue1 is less than pvValue2
//
(
	DBTYPE wType, 
	// [in] the OLE DB type of both values
	void * pvValue1, 
	// [in] a pointer to Value1
	void * pvValue2
	// [in] a pointer to Value2
)
{
	Assert (pvValue1 != NULL);
	Assert (pvValue2 != NULL);

	// TODO : Is this right ?
	INT comp = -1;

/*
	// TODO : how do we handle these ?
	case DBTYPE_ARRAY:
	case DBTYPE_BYREF:
	case DBTYPE_VECTOR:
*/

	// TODO : support the other DB_TYPES and check that all types work
	// TODO : What about NULL values ?
	// TODO : WE could generalize this function and let it handle values
	// of different types.

	switch (wType)
	{
	case DBTYPE_I2:
		comp = (*(SHORT*)pvValue1) - (*(SHORT*)pvValue2);
		break;
	case DBTYPE_I4:
		comp = (*(LONG*)pvValue1) - (*(LONG*)pvValue2);
		break;
	case DBTYPE_UI1:
		comp = (*(UCHAR*)pvValue1) - (*(UCHAR*)pvValue2);
		break;
	case DBTYPE_I1:
		comp = (*(CHAR*)pvValue1) - (*(CHAR*)pvValue2);
		break;
	case DBTYPE_UI2:
		comp = (*(USHORT*)pvValue1) - (*(USHORT*)pvValue2);
		break;
	case DBTYPE_UI4:
		comp = (*(ULONG*)pvValue1) - (*(ULONG*)pvValue2);
		break;
	case DBTYPE_STR:
		comp = strcmp((CHAR*)(pvValue1), (CHAR*)pvValue2);
		break;
	case DBTYPE_WSTR:
		comp = wcscmp((WCHAR*)(pvValue1), (WCHAR*)pvValue2);
		break;
	case DBTYPE_GUID:
	case DBTYPE_I8:
	case DBTYPE_UI8:
	case DBTYPE_R4:
	case DBTYPE_R8:
	case DBTYPE_CY:
	case DBTYPE_DATE:
	case DBTYPE_BSTR:
	case DBTYPE_IDISPATCH:
	case DBTYPE_ERROR:
	case DBTYPE_BOOL:
	case DBTYPE_VARIANT:
	case DBTYPE_IUNKNOWN:
	case DBTYPE_DECIMAL:
	case DBTYPE_RESERVED:
	case DBTYPE_BYTES:
	case DBTYPE_NUMERIC:
	case DBTYPE_UDT:
	case DBTYPE_DBDATE:
	case DBTYPE_DBTIME:
	case DBTYPE_DBTIMESTAMP:
	default:
		Assert(FALSE && "CIndex : Data type not supported");
		return -1;
	}

	return comp;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\dbid.h ===
//------------------------------------------------------------------------------
//
//  Microsoft Sidewalk
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       oledbhelp.h
//
//  Contents:   OLE DB helper methods
//
//  Owner:      BassamT
//														 
//  History:    11/30/97   BassamT	Created.
//
//------------------------------------------------------------------------------
#if (!defined(BUILD_FOR_NT40))
#pragma once

//
// typedefs
//


// Column Number (cn). This number starts at 1.
typedef ULONG CNUM;

// Row number (rn). These numbers start at 0.
typedef ULONG RNUM;

// Offset (in bytes) into a structure or buffer (ob)
typedef DWORD OFFSET;

// Bookmark data type (bmk)
typedef ULONG BOOKMARK;


//
// constants that can be tuned for performance
//

// The maximum number of bytes to store inline for variable size data types.
const UINT k_cbInlineMax = 100;

// the number of rows to fetch at once.
const ULONG k_RowFetchCount = 20;

// Column alignment within a row.
// TODO : Should this be sizeof(DWORD) instead ?
const DWORD k_ColumnAlign = 8;



//
// constants
//

// invalid row number
const CNUM CNUM_INVALID = 0xFFFFFFFF;

// invalid row number
const RNUM RNUM_INVALID = 0xFFFFFFFF;

//
// conversion helpers
//
const UINT k_cchUCHARAsDecimalString = sizeof("255") - 1;
const UINT k_cchUSHORTAsDecimalString = sizeof("32767") - 1;
const UINT k_cchUINTAsDecimalString = sizeof("4294967294") - 1;
const UINT k_cchUINTAsHexString = sizeof("FFFFFFFF") - 1;
const UINT k_cchINTAsDecimalString = sizeof("-2147483648") - 1;
const UINT k_cchBOOLAsDecimalString = sizeof("1") - 1;
const UINT k_cchDOUBLEAsDecimalString = sizeof("2.2250738585072014 E + 308") - 1;

//
// macros
//
#define static_wcslen(pwsz) ((sizeof(pwsz) / sizeof(WCHAR)) - 1)

#define inrange(z,zmin,zmax) ( (zmin) <= (z) && (z) <= (zmax) )


#define DBID_USE_GUID_OR_PGUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_GUID \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_GUID_PROPID \
	| 1<<DBKIND_PGUID_NAME \
	| 1<<DBKIND_PGUID_PROPID ))

#define DBID_USE_GUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_GUID \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_GUID_PROPID ))

#define DBID_USE_PGUID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_PGUID_NAME \
	| 1<<DBKIND_PGUID_PROPID ))

#define DBID_USE_NAME(e) \
	((1<<(e)) & \
	( 1<<DBKIND_NAME \
	| 1<<DBKIND_GUID_NAME \
	| 1<<DBKIND_PGUID_NAME ))

#define DBID_USE_PROPID(e) \
	((1<<(e)) & \
	( 1<<DBKIND_PROPID \
	| 1<<DBKIND_GUID_PROPID \
	| 1<<DBKIND_PGUID_PROPID ))

#define DBID_IS_BOOKMARK(dbid) \
	(  DBID_USE_GUID(dbid.eKind)  &&  dbid.uGuid.guid  == DBCOL_SPECIALCOL \
	|| DBID_USE_PGUID(dbid.eKind) && *dbid.uGuid.pguid == DBCOL_SPECIALCOL )

#define SET_DBID_FROM_NAME(dbid, pwsz) \
	dbid.eKind = DBKIND_NAME;\
	dbid.uName.pwszName = pwsz;

#define IsBadPointer(v) (IsBadReadPtr((void*)hAccessor, sizeof(void*)))

//
// functions
//

inline DWORD RoundDown(DWORD dwSize, DWORD dwAmount)
{
	return dwSize & ~(dwAmount - 1);
}

inline DWORD RoundUp(DWORD dwSize, DWORD dwAmount)
{
	return (dwSize +  (dwAmount - 1)) & ~(dwAmount - 1);
}

#define CLIENT_MALLOC(cb) (CoTaskMemAlloc(cb))
#define CLIENT_FREE(x) (CoTaskMemFree(x), x = NULL)

HRESULT CopyDBIDs(DBID * pdbidDest,	const DBID *pdbidSrc);
BOOL CompareDBIDs(const DBID *pdbid1, const DBID *pdbid2);
HRESULT IsValidDBID(const DBID *pdbid);
void FreeDBID(DBID *pdbid);

INT CompareOLEDBTypes(DBTYPE wType, void * pvValue1, void * pvValue2);


inline BOOL IsColumnVarLength
//------------------------------------------------------------------------------
// return TRUE if the column is of a variable length type
(
	DBTYPE wType
)
{
	if (wType == DBTYPE_BSTR ||
		wType == DBTYPE_STR ||
		wType == DBTYPE_WSTR ||
		wType == DBTYPE_BYTES)
	{
		return TRUE;
	}

	return FALSE;
}


inline DWORD AdjustVariableTypesLength
//------------------------------------------------------------------------------
// adjusts the length of variable length data types
(
	DBTYPE wType,
	DWORD cb
)
{

	if (wType == DBTYPE_STR)
	{
		return cb + 1;
	}
	
	if (wType == DBTYPE_WSTR)
	{
		return cb + sizeof(WCHAR);
	}
	
	return cb;
}

inline USHORT GetColumnMaxPrecision
//------------------------------------------------------------------------------
// returns the maximium possible precision of a column, given its type.
// Do not pass a byref, array, or vector column type.
(
	DBTYPE wType
	// [in] the OLE DB data type
)
{
	if ((wType & DBTYPE_BYREF) ||
		(wType & DBTYPE_ARRAY) ||
		(wType & DBTYPE_VECTOR))
	{
        Assert (FALSE);
		return 0;
	}

	switch( wType )
	{
    case DBTYPE_I1:
    case DBTYPE_UI1:
        return 3;

	case DBTYPE_I2:
	case DBTYPE_UI2:
		return 5;

	case DBTYPE_I4:
	case DBTYPE_UI4:
		return 10;

	case DBTYPE_R4:
        return 7;

	case DBTYPE_I8:
        return 19;

	case DBTYPE_UI8:
        return 20;

	case DBTYPE_R8:
        return 16;

	case DBTYPE_DATE:
		return 8;

	case DBTYPE_CY:
		return 19;

	case DBTYPE_DECIMAL:
        return 28;

	case DBTYPE_NUMERIC:
		return 38;

	case DBTYPE_EMPTY:
	case DBTYPE_NULL:
	case DBTYPE_ERROR:
	case DBTYPE_BOOL:
	case DBTYPE_BSTR:
	case DBTYPE_IDISPATCH:
	case DBTYPE_IUNKNOWN:
	case DBTYPE_VARIANT:
	case DBTYPE_GUID:
	case DBTYPE_BYTES:
	case DBTYPE_STR:
	case DBTYPE_WSTR:
	case DBTYPE_DBDATE:
	case DBTYPE_DBTIME:
	case DBTYPE_DBTIMESTAMP:
	case DBTYPE_HCHAPTER:
        return 0;

	default:
		Assert (FALSE && "Unsupported data type");
		return 0;
	}
}

inline ULONG GetColumnSize
//------------------------------------------------------------------------------
// returns the size of the column in bytes
(
	DBTYPE wType,
	// [in] the OLE DB data type
	DWORD cchMaxLength
	// [in] if this is a variable size field then this is the max length
	//		if there is one defined. Otherwise this is 0xFFFFFFFF
)
{
	// Handle BYREF destination separately
	if ((wType & DBTYPE_BYREF) ||
		(wType & DBTYPE_ARRAY) ||
		(wType & DBTYPE_VECTOR))
	{
		return sizeof(void*);
	}

	switch( wType )
	{
	case DBTYPE_EMPTY:
	case DBTYPE_NULL:
		return 0;

	case DBTYPE_I2:
	case DBTYPE_UI2:
		return 2;

	case DBTYPE_I4:
	case DBTYPE_R4:
	case DBTYPE_UI4:
		return 4;

	case DBTYPE_I8:
	case DBTYPE_R8:
	case DBTYPE_DATE:
	case DBTYPE_UI8:
		return 8;

	case DBTYPE_ERROR:
		return sizeof(SCODE);

	case DBTYPE_BOOL:
		return sizeof(VARIANT_BOOL);

	case DBTYPE_CY:
		return sizeof(CY);

	case DBTYPE_BSTR:
		return sizeof(BSTR);

	case DBTYPE_IDISPATCH:
		return sizeof(IDispatch*);

	case DBTYPE_IUNKNOWN:
		return sizeof(IUnknown*);

	case DBTYPE_VARIANT:
		return sizeof(VARIANT);

	case DBTYPE_DECIMAL:
		return sizeof(DECIMAL);

	case DBTYPE_I1:
	case DBTYPE_UI1:
		return 1;

	case DBTYPE_GUID:
		return sizeof(GUID);

	case DBTYPE_BYTES:
		return cchMaxLength;

	case DBTYPE_STR:
		return cchMaxLength * sizeof(char);

	case DBTYPE_WSTR:
		return cchMaxLength * sizeof(WCHAR);

	case DBTYPE_NUMERIC:
		return sizeof(DB_NUMERIC);

	case DBTYPE_DBDATE:
		return sizeof(DBDATE);

	case DBTYPE_DBTIME:
		return sizeof(DBTIME);

	case DBTYPE_DBTIMESTAMP:
		return sizeof(DBTIMESTAMP);

	case DBTYPE_HCHAPTER:
		return sizeof(HCHAPTER);

	default:
		Assert (FALSE && "Unsupported data type");
		return 0;
	}
}

//
// IUnknown Macros
//

// put this macros in your class definition. Make sure that 
// you inherit from IUnknown and that you use the 
// INIT_IUNKNOWN macro in your class constructor
#define DEFINE_IUNKNOWN \
private:\
	LONG _cRefs;\
public:\
    STDMETHOD(InternalQueryInterface)(REFIID riid, void ** ppv);\
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)\
	{\
		return InternalQueryInterface(riid, ppv);\
	}\
	STDMETHOD_(ULONG,AddRef)() \
	{\
		return InterlockedIncrement(&_cRefs);\
	}\
    STDMETHOD_(ULONG,Release)()\
	{\
		if (InterlockedDecrement(&_cRefs) == 0)\
		{\
			delete this;\
			return 0;\
		}\
		return _cRefs;\
	}

#define INIT_IUNKNOWN	_cRefs = 1;

#define DEFINE_IUNKNOWN_WITH_CALLBACK(x) \
private:\
	LONG _cRefs;\
public:\
    STDMETHOD(InternalQueryInterface)(REFIID riid, void ** ppv);\
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)\
	{\
		return InternalQueryInterface(riid, ppv);\
	}\
	STDMETHOD_(ULONG,AddRef)() \
	{\
		return InterlockedIncrement(&_cRefs);\
	}\
    STDMETHOD_(ULONG,Release)()\
	{\
		if (InterlockedDecrement(&_cRefs) == 0)\
		{\
			x();\
			return 0;\
		}\
		return _cRefs;\
	}


// put this macros in your class definition. Make sure that 
// you inherit from IUnknown and that you use the 
// INIT_AGGREGATE_IUNKNOWN macro in your class constructor.
// Also make sure that you use SET_OUTER_IUNKNOWN in wherever
// you get a pointer to the Outer IUnknown
interface INonDelegatingUnknown
{
    virtual HRESULT STDMETHODCALLTYPE NonDelegatingQueryInterface
	( 
        REFIID riid,
        void __RPC_FAR *__RPC_FAR *ppvObject
	) = 0;
    virtual ULONG STDMETHODCALLTYPE NonDelegatingAddRef(void) = 0;
    virtual ULONG STDMETHODCALLTYPE NonDelegatingRelease(void) = 0;
};

#define DEFINE_AGGREGATE_IUNKNOWN \
private:\
	IUnknown * _punkOuter;\
	LONG _cRefs;\
public:\
    STDMETHOD(InternalQueryInterface)(REFIID riid, void ** ppv);\
    STDMETHOD(NonDelegatingQueryInterface)(REFIID riid, void ** ppv)\
	{\
		if (ppv == NULL) return E_INVALIDARG;\
		if (riid != IID_IUnknown)\
		{\
			return InternalQueryInterface(riid, ppv);\
		}\
		else\
		{\
			*ppv = static_cast<INonDelegatingUnknown*>(this);\
			NonDelegatingAddRef();\
			return NOERROR;\
		}\
	}\
	STDMETHOD_(ULONG,NonDelegatingAddRef)() \
	{\
		return InterlockedIncrement(&_cRefs);\
	}\
    STDMETHOD_(ULONG,NonDelegatingRelease)()\
	{\
		if (InterlockedDecrement(&_cRefs) == 0)\
		{\
			delete this;\
			return 0;\
		}\
		return _cRefs;\
	}\
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)\
	{\
		return _punkOuter->QueryInterface(riid, ppv);\
	}\
	STDMETHOD_(ULONG,AddRef)() \
	{\
		return _punkOuter->AddRef();\
	}\
    STDMETHOD_(ULONG,Release)()\
	{\
		return _punkOuter->Release();\
	}

#define INIT_AGGREGATE_IUNKNOWN	\
	_punkOuter = reinterpret_cast<IUnknown*>(static_cast<INonDelegatingUnknown*>(this)); \
	_cRefs = 1;

#define SET_OUTER_IUNKNOWN(punk)	if (punk != NULL) _punkOuter = punk;


#define DEFINE_AGGREGATE_IUNKNOWN_WITH_CALLBACKS(_AddRef, _Release) \
private:\
	IUnknown * _punkOuter;\
	LONG _cRefs;\
public:\
    STDMETHOD(InternalQueryInterface)(REFIID riid, void ** ppv);\
    STDMETHOD(NonDelegatingQueryInterface)(REFIID riid, void ** ppv)\
	{\
		if (ppv == NULL) return E_INVALIDARG;\
		if (riid != IID_IUnknown)\
		{\
			return InternalQueryInterface(riid, ppv);\
		}\
		else\
		{\
			*ppv = static_cast<INonDelegatingUnknown*>(this);\
			NonDelegatingAddRef();\
			return NOERROR;\
		}\
	}\
	STDMETHOD_(ULONG,NonDelegatingAddRef)() \
	{\
		_AddRef();\
		return InterlockedIncrement(&_cRefs);\
	}\
    STDMETHOD_(ULONG,NonDelegatingRelease)()\
	{\
		_Release();\
		if (InterlockedDecrement(&_cRefs) == 0)\
		{\
			delete this;\
			return 0;\
		}\
		return _cRefs;\
	}\
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv)\
	{\
		return _punkOuter->QueryInterface(riid, ppv);\
	}\
	STDMETHOD_(ULONG,AddRef)() \
	{\
		return _punkOuter->AddRef();\
	}\
    STDMETHOD_(ULONG,Release)()\
	{\
		return _punkOuter->Release();\
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\helpers.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:  helpers.cxx
//
//  Contents:   ADs C Wrappers (Helper functions)
//
//                ADsBuildEnumerator
//                ADsFreeEnumerator
//                ADsEnumerateNext
//                ADsBuildVarArrayStr
//                ADsBuildVarArrayInt
//
//  History:
//        1-March-1995  KrishnaG  -- Created
//
//----------------------------------------------------------------------------
#include "oleds.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   ADsBuildEnumerator
//
//  Synopsis:   C wrapper code to create an Enumerator object.
//
//  Arguments:  [pNetOleCollection] -- The input Collection object.
//
//              [ppEnumVariant] -- The created Enumerator object.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
ADsBuildEnumerator(
    IADsContainer *pADsContainer,
    IEnumVARIANT * * ppEnumVariant
    )
{

    HRESULT hr;
    IUnknown *pUnk = NULL;

    //
    // Get a new enumerator object.
    //

    hr = pADsContainer->get__NewEnum( &pUnk );
    if (FAILED(hr)) {

        goto Fail;
    }

    //
    // QueryInterface the IUnknown pointer for an IEnumVARIANT interface,
    //

    hr = pUnk->QueryInterface(
                    IID_IEnumVARIANT,
                    (void FAR* FAR*)ppEnumVariant
                    );
    if (FAILED(hr)) {

        goto Fail;
    }

    //
    // Release the IUnknown pointer.
    //

    pUnk->Release();

    return(hr);


Fail:

    if (pUnk) {
        pUnk->Release();
    }

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ADsFreeEnumerator
//
//  Synopsis:   Frees an Enumerator object.
//
//  Arguments:  [pEnumerator] -- The Enumerator object to be freed.
//
//  Returns:    HRESULT
//----------------------------------------------------------------------------
HRESULT
ADsFreeEnumerator(
    IEnumVARIANT *pEnumVariant
    )
{

    HRESULT hr = E_ADS_BAD_PARAMETER;

    ULONG uRefCount = 0;

    if (pEnumVariant) {
        uRefCount = pEnumVariant->Release();

        return(S_OK);
    }

    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   ADsEnumerateNext
//
//  Synopsis:   C wrapper code for IEnumVARIANT::Next
//
//  Arguments:  [pEnumVariant] -- Input enumerator object.
//
//              [cElements] --  Number  of elements to retrieve.
//
//              [pvar] -- VARIANT array.
//
//              [pcElementFetched] -- Number of elements fetched.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
ADsEnumerateNext(
    IEnumVARIANT *pEnumVariant,
    ULONG cElements,
    VARIANT * pvar,
    ULONG * pcElementsFetched
    )
{

    return(pEnumVariant->Next(cElements, pvar, pcElementsFetched));
}

//+---------------------------------------------------------------------------
//
//  Function:   ADsBuildVarArrayStr
//
//  Synopsis:   Build a variant array of strings
//
//  Arguments:  [lppPathNames] -- List of pathnames to be put in the array.
//
//              [dwPathNames] -- Number of pathnames in the list.
//
//              [ppvar] -- Pointer to a pointer of a Variant array.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
ADsBuildVarArrayStr(
    LPWSTR * lppPathNames,
    DWORD  dwPathNames,
    VARIANT * pVar
    )
{

    VARIANT v;
    SAFEARRAYBOUND sabNewArray;
    DWORD i;
    SAFEARRAY *psa = NULL;
    HRESULT hr = E_FAIL;


    if (!pVar) {
        hr = E_ADS_BAD_PARAMETER;
        goto Fail;
    }
    VariantInit(pVar);

    sabNewArray.cElements = dwPathNames;
    sabNewArray.lLbound = 0;
    psa = SafeArrayCreate(VT_VARIANT, 1, &sabNewArray);

    if (!psa) {
        goto Fail;
    }

    for (i = 0; i < dwPathNames; i++) {

        VariantInit(&v);
        V_VT(&v) = VT_BSTR;
        V_BSTR(&v) = SysAllocString(*(lppPathNames + i));
        if(!V_BSTR(&v) && (*(lppPathNames + i)))
        {
            goto Fail;
        }
        hr = SafeArrayPutElement(psa,
                                 (long FAR *)&i,
                                 &v
                                 );
        VariantClear( &v );
        if (FAILED(hr)) {
            goto Fail;
        }
    }



    V_VT(pVar) = VT_ARRAY | VT_VARIANT;

    V_ARRAY(pVar) = psa;

    return(ResultFromScode(S_OK));


Fail:

    if (psa) {
        SafeArrayDestroy(psa);
    }



    return(E_FAIL);

}

//+---------------------------------------------------------------------------
//
//  Function:   ADsBuildVarArrayInt
//
//  Synopsis:   Build a variant array of integers
//
//  Arguments:  [lppObjectTypes] -- List of object types to be put in the array.
//
//              [dwObjectTypes] -- Number of object types in the list.
//
//              [ppvar] -- Pointer to a pointer of a Variant array.
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
ADsBuildVarArrayInt(
    LPDWORD    lpdwObjectTypes,
    DWORD      dwObjectTypes,
    VARIANT * pVar
    )
{

    VARIANT v;
    SAFEARRAYBOUND sabNewArray;
    DWORD i;
    SAFEARRAY *psa = NULL;
    HRESULT hr = E_FAIL;

    if (!pVar) {
        hr = E_ADS_BAD_PARAMETER;
        goto Fail;
    }
    VariantInit(pVar);

    sabNewArray.cElements = dwObjectTypes;
    sabNewArray.lLbound = 0;
    psa = SafeArrayCreate(VT_VARIANT, 1, &sabNewArray);

    if (!psa) {
        goto Fail;
    }

    for (i = 0; i < dwObjectTypes; i++) {

        VariantInit(&v);
        V_VT(&v) = VT_I4;
        V_I4(&v) = *(lpdwObjectTypes + i);
        hr = SafeArrayPutElement(psa,
                                 (long FAR *)&i,
                                 &v
                                 );
        VariantClear( &v );
        if (FAILED(hr))  {
            goto Fail;
        }
    }


    V_VT(pVar) = VT_VARIANT | VT_ARRAY;

    V_ARRAY(pVar) = psa;

    return(ResultFromScode(S_OK));


Fail:

    if (psa) {
        SafeArrayDestroy(psa);
    }

    return(E_FAIL);
}


//+---------------------------------------------------------------------------
// Function:  BinarySDToSecurityDescriptor. 
//
// Synopsis:  Convert the given binary blob to an equivalent object 
//          implementing the IADsSecurityDescriptor interface.
//
// Arguments:  pSecurityDescriptor  - the binary SD to convert.
//             pVarsec              - return value.
//             pszServerName        - serverName the SD was 
//                                     retrieved from (optional).
//             userName             - not used, optional.
//             passWord             - not used, optional.
//             dwFlags              - not used, optional.
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   pVarsec to contain a VT_DISPATCH if successful.
//
//----------------------------------------------------------------------------
HRESULT 
BinarySDToSecurityDescriptor(
    PSECURITY_DESCRIPTOR  pSecurityDescriptor,
    VARIANT *pVarsec,
    LPCWSTR pszServerName, // defaulted to NULL
    LPCWSTR userName,      // defaulted to NULL
    LPCWSTR passWord,      // defaulted to NULL
    DWORD dwFlags          // defaulted to 0
    )
{
    CCredentials creds((LPWSTR)userName, (LPWSTR)passWord, dwFlags);

    //
    // Call internal routine in sec2var.cxx that does all the work.
    //
    RRETURN(ConvertSecDescriptorToVariant(
                (LPWSTR)pszServerName,
                creds,
                pSecurityDescriptor,
                pVarsec,
                TRUE // we will always expect NT format.
                )
            );
                
}


//+---------------------------------------------------------------------------
// Function:  SecurityDescriptorToBinarySD.
//
// Synopsis:  Convert the given IADsSecurityDescriptor to (in the variant
//          to a binary security descriptor blob.
//
// Arguments:  vVarSecDes           - the binary SD to convert.
//             ppSecurityDescriptor - ptr to output binary blob.
//             pszServerName        - serverName the SD
//                                    is being put on, optional.
//             userName            - not used, optional.
//             passWord            - not used, optional.
//             dwFlags             - not used, optional.
//
// Returns:    HRESULT - S_OK or any failure error code
//
// Modifies:   pVarsec to contain a VT_DISPATCH if successful.
//
//----------------------------------------------------------------------------
HRESULT
SecurityDescriptorToBinarySD(
    VARIANT vVarSecDes,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    PDWORD pdwSDLength,
    LPCWSTR pszServerName, // defaulted to NULL
    LPCWSTR userName,      // defaulted to NULL
    LPCWSTR passWord,      // defaulted to NULL
    DWORD dwFlags         // defaulted to 0
    )
{
    HRESULT hr = E_FAIL;
    IADsSecurityDescriptor *pIADsSecDesc = NULL;
    CCredentials creds((LPWSTR)userName, (LPWSTR)passWord, dwFlags);

    //
    // Verify it is a VT_DISPATCH and also that ptr is valid.
    //
    if ((vVarSecDes.vt != VT_DISPATCH)
        || (!V_DISPATCH(&vVarSecDes))
        ) {
        BAIL_ON_FAILURE(hr);
    }
    
    //
    // Get the interface ptr from the variant (it has to be IDispatch)
    //
    hr = vVarSecDes.pdispVal->QueryInterface(
             IID_IADsSecurityDescriptor,
             (void **) &pIADsSecDesc
             );
    BAIL_ON_FAILURE(hr);

    //
    // Call the helper routine in sec2var.cxx
    //
    hr = ConvertSecurityDescriptorToSecDes(
             (LPWSTR)pszServerName,
             creds,
             pIADsSecDesc,
             ppSecurityDescriptor,
             pdwSDLength,
             TRUE // always NT Sec desc mode
             );

error:

    if (pIADsSecDesc) {
        pIADsSecDesc->Release();
    }

    RRETURN(hr);
}



// end of helpers.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\macro.h ===
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\


#define INVALID_CREDENTIALS_ERROR(hr) \
                (   hr == HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE)         ||    \
                    hr == HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED)         ||    \
                    hr == HRESULT_FROM_WIN32(ERROR_DS_INAPPROPRIATE_AUTH) ||    \
                    hr == HRESULT_FROM_WIN32(ERROR_DS_AUTH_UNKNOWN)       ||    \
                    hr == DB_SEC_E_PERMISSIONDENIED)

#define LIMIT_EXCEEDED_ERROR(hr) \
                (   hr == HRESULT_FROM_WIN32(ERROR_DS_SIZELIMIT_EXCEEDED) ||    \
                    hr == HRESULT_FROM_WIN32(ERROR_DS_TIMELIMIT_EXCEEDED))

#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}




#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                                   \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\adsi\router\libmain.cxx ===
#include "oleds.hxx"
#include "bindercf.hxx"
#include "atlbase.h"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for ADs.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

HINSTANCE g_hInst = NULL;
PROUTER_ENTRY g_pRouterHead = NULL;
CRITICAL_SECTION g_csRouterHeadCritSect;

//
// Dll's we load dynamically.
//
extern HANDLE g_hDllAdvapi32;

extern const GUID DBGUID_ROOTBINDER  =
{0xFF151822, 0xB0BF, 0x11D1, {0xA8, 0x0D, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}};

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     AllocArenaDump( NULL );
     DeleteCriticalSection(&g_csOT);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"ADs",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"ADs",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"ADs",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

// Globals


ULONG g_ulObjCount = 0; // Number of objects alivein ADs.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from formsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))


//+------------------------------------------------------------------------
//
//  ADs class factories
//
//-------------------------------------------------------------------------

CADsNamespacesCF             g_cfNamespaces;
CADsProviderCF               g_cfProvider;
CDSOCF                       g_cfDSO;
CADsSecurityDescriptorCF     g_cfSed;
CADsAccessControlListCF      g_cfAcl;
CADsAccessControlEntryCF     g_cfAce;
CADsPropertyEntryCF          g_cfPropEntry;
CADsPropertyValueCF          g_cfPropertyValue;
CADsLargeIntegerCF           g_cfLargeInteger;
CADsBinderCF                 g_cfBinder;
CPathnameCF                  g_cfPathname;
CADsDNWithBinaryCF           g_cfDNWithBinary;
CADsDNWithStringCF           g_cfDNWithString;
CADsSecurityUtilityCF        g_cfADsSecurityUtility;

extern CRITICAL_SECTION g_DispTypeInfoCritSect;
extern CRITICAL_SECTION g_StringsCriticalSection;

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_ADsNamespaces,                        &g_cfNamespaces,
    &CLSID_ADsProvider,                          &g_cfProvider,
    &CLSID_ADsDSOObject,                         &g_cfDSO,
    &CLSID_SecurityDescriptor,                   &g_cfSed,
    &CLSID_AccessControlList,                    &g_cfAcl,
    &CLSID_AccessControlEntry,                   &g_cfAce,
    &CLSID_PropertyEntry,                        &g_cfPropEntry,
    &CLSID_PropertyValue,                        &g_cfPropertyValue,
    &CLSID_LargeInteger,                         &g_cfLargeInteger,
    &CLSID_ADSI_BINDER,                          &g_cfBinder,
    &CLSID_Pathname,                             &g_cfPathname,
    &CLSID_DNWithBinary,                         &g_cfDNWithBinary,
    &CLSID_DNWithString,                         &g_cfDNWithString,
    &CLSID_ADsSecurityUtility,                   &g_cfADsSecurityUtility
};

//------------------------------------------------------------------------
// ATL Module definition
//------------------------------------------------------------------------
CComModule _Module;

//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    if( ppv == NULL )
        RRETURN( E_INVALIDARG );

    *ppv = NULL;

    for (i = 0; i < ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the ADs.DllGetClassObject
    // has been called with an unknown CLSID.
    //

    return CLASS_E_CLASSNOTAVAILABLE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    if (DllReadyToUnload())
        hr = S_OK;

    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    HRESULT     hr;
    static UINT uiNumCritSectsInitialized = 0;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        //
        // Need to put in try catch block as init crit sects can fail.
        //
        __try {

            DisableThreadLibraryCalls(hInst);

            g_hInst = hInst;


            InitializeCriticalSection(&g_DispTypeInfoCritSect);
            ++uiNumCritSectsInitialized;

            InitializeCriticalSection(&g_StringsCriticalSection);
            ++uiNumCritSectsInitialized;

            InitializeCriticalSection(&g_csRouterHeadCritSect); // router initialization
            ++uiNumCritSectsInitialized;

#if DBG==1
            InitializeCriticalSection(&g_csDP); // Used by ADsDebug
            ++uiNumCritSectsInitialized;
#ifndef MSVC
            InitializeCriticalSection(&g_csOT); // Used by Object Tracker
            ++uiNumCritSectsInitialized;
            InitializeCriticalSection(&g_csMem); // Used by Object Tracker
            ++uiNumCritSectsInitialized;
#endif
#endif
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Critical failure
            //


            //
            // Delete the cs we init'ed.  The fall through in each case is
            // intentional, as is the fact that we delete the critical sections
            // in the reverse order to which we initialized them.
            //
            switch(uiNumCritSectsInitialized)
            {
#if DBG==1
#ifndef MSVC
            case 6:
                DeleteCriticalSection(&g_csMem); // Used by Object Tracker

            case 5:
                DeleteCriticalSection(&g_csOT); // Used by Object Tracker
#endif
            case 4:
                DeleteCriticalSection(&g_csDP); // Used by ADsDebug
#endif
            case 3:
                DeleteCriticalSection(&g_csRouterHeadCritSect);

            case 2:
                DeleteCriticalSection(&g_StringsCriticalSection);

            case 1:
                DeleteCriticalSection(&g_DispTypeInfoCritSect);
            }
            //
            // Reset the counts of critical sections that we have initialized, just
            // in case LibMain(DLL_PROCESS_DETACH) does get called.
            //
            uiNumCritSectsInitialized = 0;
            
            return FALSE;
        }

        break;


    case DLL_PROCESS_DETACH:
        if (g_pRouterHead) {
            CleanupRouter(g_pRouterHead);
        }
        FreeTypeInfoTable();

        //
        // Delete the cs we init'ed.  The fall through in each case is
        // intentional, as is the fact that we delete the critical sections
        // in the reverse order to which we initialized them.
        //
        switch(uiNumCritSectsInitialized)
        {
#if DBG==1
#ifndef MSVC
        case 6:
            DeleteCriticalSection(&g_csMem); // Used by Object Tracker

        case 5:
            DeleteCriticalSection(&g_csOT); // Used by Object Tracker
#endif
        case 4:
            DeleteCriticalSection(&g_csDP); // Used by ADsDebug
#endif
        case 3:
            DeleteCriticalSection(&g_csRouterHeadCritSect);

        case 2:
            DeleteCriticalSection(&g_StringsCriticalSection);

        case 1:
             DeleteCriticalSection(&g_DispTypeInfoCritSect);
       }

        //
        // Free any libs we loaded using loadlibrary
        //
        if (g_hDllAdvapi32) {
            FreeLibrary((HMODULE) g_hDllAdvapi32);
            g_hDllAdvapi32 = NULL;
        }

        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}

STDAPI DllRegisterServer()
{
    PWCHAR pwszClsid = NULL;
    WCHAR  pwszSubKey[256];
    const WCHAR pwTypeLibraryName[] = L"activeds.tlb";
    // 15 includes name of the type libaray, NULL terminator, backslash and one extra space
    WCHAR pwTypeLibPath[MAX_PATH + 15] = L"";
    HRESULT hr = S_OK;
#if (!defined(BUILD_FOR_NT40))
    auto_rel<IRegisterProvider> pRegisterProvider;
    wcscpy(pwszSubKey, L"SOFTWARE\\Classes\\CLSID\\");
    hr = StringFromCLSID(CLSID_ADSI_BINDER, &pwszClsid);
    if (FAILED(hr))
        return hr;
    wcscat(pwszSubKey, pwszClsid);

    HKEY hKeyClsid = NULL, hKeyDll = NULL;
    DWORD dwDisposition;
    LONG lRetVal;
    ITypeLib	*pITypeLib = NULL;
    UINT iSize = 0;

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = InitializeRouter();
    }
    LeaveCriticalSection(&g_csRouterHeadCritSect);


    //Create CLSID entry
    lRetVal = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             pwszSubKey,
                             0,
                             L"",
                             0,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKeyClsid,
                             &dwDisposition);

    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //set the value
    lRetVal = RegSetValueEx(hKeyClsid,
                            NULL,
                            0,
                            REG_SZ,
                            (CONST BYTE *)L"Provider Binder for DS OLE DB Provider",
                            78);
    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //Create InprocServer32 entry
    lRetVal = RegCreateKeyEx(hKeyClsid,
                             L"InprocServer32",
                             0,
                             L"activeds.dll",
                             0,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKeyDll,
                             &dwDisposition);

    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //set the value
    lRetVal = RegSetValueEx(hKeyDll,
                            NULL,
                            0,
                            REG_SZ,
                            (CONST BYTE *)L"activeds.dll",
                            26);
    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //Now set the threadingModel value for the dll key
    lRetVal = RegSetValueEx(hKeyDll,
                            L"ThreadingModel",
                            0,
                            REG_SZ,
                            (CONST BYTE *)L"Both",
                            10);
    if (lRetVal != ERROR_SUCCESS)
        BAIL_ON_FAILURE(HRESULT_FROM_WIN32(lRetVal));

    //Now register the provider with the root binder.
    //Cocreate Root Binder and get IRegisterProvider interface.
    hr = CoCreateInstance ( DBGUID_ROOTBINDER,
                            NULL,
                            CLSCTX_ALL,
                            __uuidof(IRegisterProvider),
                            (void **) &pRegisterProvider
                            );

    if (SUCCEEDED(hr))
    {
        // Go through list of ADS providers and register each of them
        // with the root binder.
        for ( PROUTER_ENTRY pProvider = g_pRouterHead;
              pProvider != NULL;
              pProvider=pProvider->pNext)
        {
            // Invalid provider ProgID? If so, continue with next provider
            if (NULL == pProvider->szProviderProgId)
                continue;

            hr = pRegisterProvider->SetURLMapping(
                pProvider->szProviderProgId,
                0,
                CLSID_ADSI_BINDER);
            if (FAILED(hr))
                AtlTrace(_T("Failed to register %s mapping hr = %x\n"),
                         pProvider->szProviderProgId, hr);

            // Ignore error and continue with next provider
            hr = S_OK;
        }
    }
    else
    {
        AtlTrace(_T("Creation of Root Binder failed! hr = %x\n"), hr);
        goto error;
    }

    // register our activeds.tlb  
    
    iSize = GetSystemDirectoryW(pwTypeLibPath, MAX_PATH + 1);
    if(iSize == 0 || iSize > MAX_PATH + 1) {
        wcscpy(pwTypeLibPath, pwTypeLibraryName);
    }    
    else {
        wcscat(pwTypeLibPath, L"\\");
        wcscat(pwTypeLibPath,pwTypeLibraryName);
    }    
    
    hr = LoadTypeLib(pwTypeLibPath, &pITypeLib);

    if(FAILED(hr))
    {
        AtlTrace(_T("LoadTypeLib() failed! hr=%x\n"), hr);
        goto error;
    }   

    hr = RegisterTypeLib(pITypeLib, pwTypeLibPath, NULL);
    if(FAILED(hr))
    {
        AtlTrace(_T("RegisterTypeLib() failed! hr=%x\n"), hr);        
    }   

    

error:
    CoTaskMemFree(pwszClsid);
    if (hKeyClsid) {
        RegCloseKey(hKeyClsid);
    }

    if (hKeyDll) {
        RegCloseKey(hKeyDll);
    }

    if(pITypeLib) {
        pITypeLib->Release();
    }

#endif

    return hr;
}

STDAPI DllUnregisterServer()
{
    PWCHAR   pwszClsid = NULL;
    WCHAR    pwszClsidKey[256];
    WCHAR    pwszDllKey[256];
    HRESULT  hr = S_OK;
    LONG     lRetVal;
    ITypeLib	*pITypeLib = NULL;
    const WCHAR pwTypeLibraryName[] = L"activeds.tlb";
    // 15 includes name of the type libaray, NULL terminator, backslash and one extra space
    WCHAR pwTypeLibPath[MAX_PATH + 15] = L"";
    TLIBATTR* pTLibAttr = NULL;
    UINT iSize = 0;
	
#if (!defined(BUILD_FOR_NT40))
    auto_rel<IRegisterProvider> pRegisterProvider;
    wcscpy(pwszClsidKey, L"SOFTWARE\\Classes\\CLSID\\");
    hr = StringFromCLSID(CLSID_ADSI_BINDER, &pwszClsid);
    if (FAILED(hr))
        return hr;
    wcscat(pwszClsidKey, pwszClsid);

    wcscpy(pwszDllKey, pwszClsidKey);
    wcscat(pwszDllKey, L"\\InprocServer32");

    //
    // Make sure the router has been initialized
    //
    EnterCriticalSection(&g_csRouterHeadCritSect);
    if (!g_pRouterHead) {
        g_pRouterHead = Initi