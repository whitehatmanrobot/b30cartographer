&           \
        (id) != VER_PLATFORM_WIN32_NT)                  \

//*****************************************************************************
// Returns true if ixPtrTbl and ixParTbl are a valid parent-child combination
// in the pointer table scheme.
//*****************************************************************************
static inline bool IsTblPtr(ULONG ixPtrTbl, ULONG ixParTbl)
{
    if ((ixPtrTbl == TBL_Field && ixParTbl == TBL_TypeDef) ||
        (ixPtrTbl == TBL_Method && ixParTbl == TBL_TypeDef) ||
        (ixPtrTbl == TBL_Param && ixParTbl == TBL_Method) ||
        (ixPtrTbl == TBL_Property && ixParTbl == TBL_PropertyMap) ||
        (ixPtrTbl == TBL_Event && ixParTbl == TBL_EventMap))
    {
        return true;
    }
    else
        return false;
}   // IsTblPtr()

//*****************************************************************************
// This inline function is used to set the return hr value for the Validate
// functions to one of VLDTR_S_WRN, VLDTR_S_ERR or VLDTR_S_WRNERR based on
// the current hr value and the new success code.
// The general algorithm for error codes from the validation functions is:
//      if (no warnings or errors found)
//          return S_OK
//      else if (warnings found)
//          return VLDTR_S_WRN
//      else if (errors found)
//          return VLDTR_S_ERR
//      else if (warnings and errors found)
//          return VLDTR_S_WRNERR
//*****************************************************************************
static inline void SetVldtrCode(HRESULT *phr, HRESULT successcode)
{
    _ASSERTE(successcode == S_OK || successcode == VLDTR_S_WRN ||
             successcode == VLDTR_S_ERR || successcode == VLDTR_S_WRNERR);
    _ASSERTE(*phr == S_OK || *phr == VLDTR_S_WRN || *phr == VLDTR_S_ERR ||
             *phr == VLDTR_S_WRNERR);
    if (successcode == S_OK || *phr == VLDTR_S_WRNERR)
        return;
    else if (*phr == S_OK)
        *phr = successcode;
    else if (*phr != successcode)
        *phr = VLDTR_S_WRNERR;
}   // SetVldtrCode()

//*****************************************************************************
// Initialize the Validator related structures in RegMeta.
//*****************************************************************************
HRESULT RegMeta::ValidatorInit(         // S_OK or error.
    DWORD       dwModuleType,           // [IN] Specifies whether the module is a PE file or an obj.
    IUnknown    *pUnk)                  // [IN] Validation error handler.
{
    int         i = 0;                  // Index into the function pointer table.
    HRESULT     hr = S_OK;              // Return value.

    // Initialize the array of function pointers to the validation function on
    // each table.
#undef MiniMdTable
#define MiniMdTable(x) m_ValidateRecordFunctionTable[i++] = &RegMeta::Validate##x;
    MiniMdTables()

    // Verify that the ModuleType passed in is a valid one.
    if (dwModuleType < ValidatorModuleTypeMin ||
        dwModuleType > ValidatorModuleTypeMax)
    {
        IfFailGo(E_INVALIDARG);
    }

    // Verify that the interface passed in supports IID_IVEHandler.
    IfFailGo(pUnk->QueryInterface(IID_IVEHandler, (void **)&m_pVEHandler));

    // Set the ModuleType class member.  Do this last, this is used in
    // ValidateMetaData to see if the validator is correctly initialized.
    m_ModuleType = (CorValidatorModuleType)dwModuleType;
ErrExit:
    return hr;
}   // HRESULT RegMeta::ValidatorInit()

//*****************************************************************************
// Validate the entire MetaData.  Here is the basic algorithm.
//      for each table
//          for each record
//          {
//              Do generic validation - validate that the offsets into the blob
//              pool are good, validate that all the rids are within range,
//              validate that token encodings are consistent.
//          }
//      if (problems found in generic validation)
//          return;
//      for each table
//          for each record
//              Do semantic validation.
//******************************************************************************
HRESULT RegMeta::ValidateMetaData()
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    HRESULT     hr = S_OK;          // Return value.
    HRESULT     hrSave = S_OK;      // Saved hr from generic validation.
    ULONG       ulCount;            // Count of records in the current table.
    ULONG       i;                  // Index to iterate over the tables.
    ULONG       j;                  // Index to iterate over the records in a given table.
    ULONG       rValidatedSize=0;   // Size of g_rValidated array

    // Verify that the validator is initialized correctly
    if (m_ModuleType == ValidatorModuleTypeInvalid)
    {
        _ASSERTE(!"Validator not initialized, initialize with ValidatorInit().");
        IfFailGo(VLDTR_E_NOTINIT);
    }

    ::g_nValidated = 0;
    // First do a validation pass to do some basic structural checks based on
    // the Meta-Meta data.  This'll validate all the offsets into the pools,
    // rid value and coded token ranges.
    for (i = 0; i < TBL_COUNT; i++)
    {
        ulCount = pMiniMd->vGetCountRecs(i);
        switch(i)
        {
            case TBL_ImplMap:
                rValidatedSize += ulCount;
            default:
                ;
        }
        for (j = 1; j <= ulCount; j++)
        {
            IfFailGo(ValidateRecord(i, j));
            SetVldtrCode(&hrSave, hr);
        }
    }
    // Validate that the size of the Ptr tables matches with the corresponding
    // real tables.

    // Do not do semantic validation if structural validation failed.
    if (hrSave != S_OK)
    {
        hr = hrSave;
        goto ErrExit;
    }

    // Verify the entry point (if any)
    ::g_tkEntryPoint = 0;
    ::g_fIsDLL = false;
    if(m_pStgdb && m_pStgdb->m_pImage)
    {
        IMAGE_DOS_HEADER   *pDos;
        IMAGE_NT_HEADERS   *pNt;
        IMAGE_COR20_HEADER *pCor;

        if (SUCCEEDED(RuntimeReadHeaders((BYTE*)m_pStgdb->m_pImage, &pDos, &pNt, &pCor, TRUE, m_pStgdb->m_dwImageSize)))
        {
            g_tkEntryPoint = pCor->EntryPointToken;
            g_fIsDLL = ((pNt->FileHeader.Characteristics & IMAGE_FILE_DLL)!=0);
        }
    }
    if(g_tkEntryPoint)
    {
        RID rid = RidFromToken(g_tkEntryPoint);
        RID maxrid = 0;
        switch(TypeFromToken(g_tkEntryPoint))
        {
            case mdtMethodDef:  maxrid = pMiniMd->getCountMethods(); break;
            case mdtFile:       maxrid = pMiniMd->getCountFiles(); break;
            default:            break;
        }
        if((rid == 0)||(rid > maxrid))
        {
            VEContext   veCtxt;             // Context structure.
            veCtxt.Token = g_tkEntryPoint;
            veCtxt.uOffset = 0;
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EP_BADTOKEN, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    g_fValidatingMscorlib = false;
    if(pMiniMd->vGetCountRecs(TBL_Assembly))
    {
        AssemblyRec *pRecord = pMiniMd->getAssembly(1);
        LPCSTR      szName = pMiniMd->getNameOfAssembly(pRecord);
        g_fValidatingMscorlib = (0 == _stricmp(szName,"mscorlib"));
    }
    // Verify there are no circular class hierarchies.

    // Do per record semantic validation on the MetaData.  The function
    // pointers to the per record validation are stored in the table by the
    // ValidatorInit() function.
    g_rValidated = rValidatedSize ? new ValidationResult[rValidatedSize] : NULL;
    for (i = 0; i < TBL_COUNT; i++)
    {
        ulCount = pMiniMd->vGetCountRecs(i);
        for (j = 1; j <= ulCount; j++)
        {
            IfFailGo((this->*m_ValidateRecordFunctionTable[i])(j));
            SetVldtrCode(&hrSave, hr);
        }
    }
    hr = hrSave;
ErrExit:
    if(g_rValidated) delete [] g_rValidated;
    return hr;
}   // RegMeta::ValidateMetaData()

//*****************************************************************************
// Validate the Module record.
//*****************************************************************************
HRESULT RegMeta::ValidateModule(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    ModuleRec   *pRecord;           // Module record.
    VEContext   veCtxt;             // Context structure.
    HRESULT     hr = S_OK;          // Value returned.
    HRESULT     hrSave = S_OK;      // Save state.
    LPCSTR      szName;
    VARIANT     rVar[2];
    SAFEARRAY   *psa=0;

    // Get the Module record.
    veCtxt.Token = TokenFromRid(rid, mdtModule);
    veCtxt.uOffset = 0;
    pRecord = pMiniMd->getModule(rid);

    // There can only be one Module record.
    if (rid > 1)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MOD_MULTI, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Verify the name
    szName = pMiniMd->getNameOfModule(pRecord);
    if(szName && *szName)
    {
        ULONG L = (ULONG)strlen(szName);
        if(L >= MAX_CLASSNAME_LENGTH)
        {
            // Name too long
            IfFailGo(_ValidateErrorHelper(L, (ULONG)(MAX_CLASSNAME_LENGTH-1), rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NAMETOOLONG, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        if(strchr(szName,':') || strchr(szName,'\\'))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MOD_NAMEFULLQLFD, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    else
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MOD_NONAME, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Verify that the MVID is valid.
    if (*(pMiniMd->getMvidOfModule(pRecord)) == GUID_NULL)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MOD_NULLMVID, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateModule()

//*****************************************************************************
// Validate the given TypeRef.
//*****************************************************************************
HRESULT RegMeta::ValidateTypeRef(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    TypeRefRec  *pRecord;               // TypeRef record.
    mdToken     tkRes;                  // Resolution scope.
    LPCSTR      szNamespace;            // TypeRef Namespace.
    LPCSTR      szName;                 // TypeRef Name.
    mdTypeRef   tkTypeRef;              // Duplicate TypeRef.
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    VARIANT     rVar[2];                // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.

    // Get the TypeRef record.
    veCtxt.Token = TokenFromRid(rid, mdtTypeRef);
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getTypeRef(rid);

    // Check name is not NULL.
    szNamespace = pMiniMd->getNamespaceOfTypeRef(pRecord);
    szName = pMiniMd->getNameOfTypeRef(pRecord);
    if (!*szName)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TR_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else
    {
        RID ridScope;
        // Look for a Duplicate, this function reports only one duplicate.
        tkRes = pMiniMd->getResolutionScopeOfTypeRef(pRecord);
        hr = ImportHelper::FindTypeRefByName(pMiniMd, tkRes, szNamespace, szName, &tkTypeRef, rid);
        if (hr == S_OK)
        {
            IfFailGo(_ValidateErrorHelper(tkTypeRef, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TR_DUP, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else if (hr == CLDB_E_RECORD_NOTFOUND)
            hr = S_OK;
        else
            IfFailGo(hr);
        if(strlen(szName)+strlen(szNamespace) >= MAX_CLASSNAME_LENGTH)
        {
            IfFailGo(_ValidateErrorHelper((ULONG)(strlen(szName)+strlen(szNamespace)), (ULONG)(MAX_CLASSNAME_LENGTH-1), rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NAMETOOLONG, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        ridScope = RidFromToken(tkRes);
        if(ridScope)
        {
            bool badscope = true;
            //check if valid scope
            switch(TypeFromToken(tkRes))
            {
                case mdtAssemblyRef:
                case mdtModuleRef:
                case mdtModule:
                case mdtTypeRef:
                    badscope = !_IsValidToken(tkRes);
                    break;
                default:
                    break;
            }
            if(badscope)
            {
                IfFailGo(_ValidateErrorHelper(tkTypeRef, &var, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TR_BADSCOPE, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_WRN);
            }
        }
        else
        {
            // check if there is a ExportedType
            //hr = ImportHelper::FindExportedType(pMiniMd, szNamespace, szName, tkImpl, &tkExportedType, rid);
        }
        // Check if there is TypeDef with the same name
        if(!ridScope)
        {
            if((TypeFromToken(tkRes) != mdtTypeRef) &&
                (S_OK == ImportHelper::FindTypeDefByName(pMiniMd, szNamespace, szName, mdTokenNil,&tkTypeRef, 0)))
            {
                IfFailGo(_ValidateErrorHelper(tkTypeRef, &var, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TR_HASTYPEDEF, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_WRN);
            }
        }
    }
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateTypeRef()

//*****************************************************************************
// Validate the given TypeDef.
//*****************************************************************************
HRESULT RegMeta::ValidateTypeDef(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    TypeDefRec  *pRecord;               // TypeDef record.
    TypeDefRec  *pExtendsRec = 0;       // TypeDef record for the parent class.
    mdTypeDef   tkTypeDef;              // Duplicate TypeDef token.
    DWORD       dwFlags;                // TypeDef flags.
    DWORD       dwExtendsFlags;         // TypeDef flags of the parent class.
    LPCSTR      szName;                 // TypeDef Name.
    LPCSTR      szNameSpace;            // TypeDef NameSpace.
    LPCSTR      szExtName;              // Parent Name.
    LPCSTR      szExtNameSpace;         // Parent NameSpace.
    CQuickBytes qb;                     // QuickBytes for flexible allocation.
    mdToken     tkExtends;              // TypeDef of the parent class.
    VEContext   veCtxt;                 // Context record.
    VARIANT     rVar[2];                // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    mdToken     tkEncloser=mdTokenNil;  // Encloser, if any
    BOOL        bIsEnum,bExtendsEnum,bExtendsVType,bIsVType,bExtendsObject,bIsObject;
    BOOL        bHasMethods=FALSE, bHasFields=FALSE;

    // Skip validating m_tdModule class.
    if (rid == RidFromToken(m_tdModule))
        goto ErrExit;

    // Get the TypeDef record.
    veCtxt.Token = TokenFromRid(rid, mdtTypeDef);
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getTypeDef(rid);

    // Do checks for name validity..
    szName = pMiniMd->getNameOfTypeDef(pRecord);
    szNameSpace = pMiniMd->getNamespaceOfTypeDef(pRecord);
    if (!*szName)
    {
        // TypeDef Name is null.
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else if (!IsDeletedName(szName))
    {
        ULONG iRecord = pMiniMd->FindNestedClassHelper(TokenFromRid(rid, mdtTypeDef));

        tkEncloser = InvalidRid(iRecord) ? mdTokenNil
                     : pMiniMd->getEnclosingClassOfNestedClass(pMiniMd->getNestedClass(iRecord));

        // Check for duplicates based on Name/NameSpace.  Do not do Dup checks
        // on deleted records.
        hr = ImportHelper::FindTypeDefByName(pMiniMd, szNameSpace, szName, tkEncloser,
                                             &tkTypeDef, rid);
        if (hr == S_OK)
        {
            IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_DUPNAME, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else if (hr == CLDB_E_RECORD_NOTFOUND)
            hr = S_OK;
        else
            IfFailGo(hr);
        if(strlen(szName)+strlen(szNameSpace) >= MAX_CLASSNAME_LENGTH)
        {
            IfFailGo(_ValidateErrorHelper((ULONG)(strlen(szName)+strlen(szNameSpace)), (ULONG)(MAX_CLASSNAME_LENGTH-1), rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NAMETOOLONG, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

#if 0 // consider reimplementing based on GUID CA.
    // Check for Dups based on GUID.
    GUID        *pGuid;                 // TypeDef GUID.
    pGuid = pMiniMd->getGuidOfTypeDef(pRecord);
    if (*pGuid != GUID_NULL)
    {
        hr = ImportHelper::FindTypeDefByGuid(pMiniMd, pGuid, &tkTypeDef, rid);
        if (hr == S_OK)
        {
            IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_DUPGUID, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_WRN);
        }
        else if (hr == CLDB_E_RECORD_NOTFOUND)
            hr = S_OK;
        else
            IfFailGo(hr);
    }
#endif    

    // Get the flag value for the TypeDef.
    dwFlags = pMiniMd->getFlagsOfTypeDef(pRecord);
    // Do semantic checks on the flags.
    // RTSpecialName bit must be set on Deleted records.
    if (IsDeletedName(szName))
    {
        if(!IsTdRTSpecialName(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_DLTNORTSPCL, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        hr = hrSave;
        goto ErrExit;
    }

    // If RTSpecialName bit is set, the record must be a Deleted record.
    if (IsTdRTSpecialName(dwFlags))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_RTSPCLNOTDLT, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
        if(!IsTdSpecialName(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_RTSPCLNOTSPCL, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    // Check if flag value is valid
    {
        DWORD dwInvalidMask, dwExtraBits;
        dwInvalidMask = (DWORD)~(tdVisibilityMask | tdLayoutMask | tdClassSemanticsMask | 
                tdAbstract | tdSealed | tdSpecialName | tdImport | tdSerializable |
                tdStringFormatMask | tdBeforeFieldInit | tdReservedMask);
        // check for extra bits
        dwExtraBits = dwFlags & dwInvalidMask;
        if(!dwExtraBits)
        {
            // if no extra bits, check layout
            dwExtraBits = dwFlags & tdLayoutMask;
            if(dwExtraBits != tdLayoutMask)
            {
                // layout OK, check string format
                dwExtraBits = dwFlags & tdStringFormatMask;
                if(dwExtraBits != tdStringFormatMask) dwExtraBits = 0;
            }
        }
        if(dwExtraBits)
        {
            IfFailGo(_ValidateErrorHelper(dwExtraBits, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_EXTRAFLAGS, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    // Get the parent of the TypeDef.
    tkExtends = pMiniMd->getExtendsOfTypeDef(pRecord);

    // Check if TypeDef extends itself
    if(tkExtends == veCtxt.Token)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_EXTENDSITSELF, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Check if TypeDef extends one of its children
    if(RidFromToken(tkExtends)&&(TypeFromToken(tkExtends)==mdtTypeDef))
    {
        TypeDefRec*     pRec = pMiniMd->getTypeDef(RidFromToken(tkExtends));
        mdToken tkExtends2 = pMiniMd->getExtendsOfTypeDef(pRec);
        if(tkExtends2 == veCtxt.Token)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_EXTENDSCHILD, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }



    if(IsNilToken(tkEncloser) == IsTdNested(dwFlags))
    {
        IfBreakGo(m_pVEHandler->VEHandler(IsNilToken(tkEncloser) ? VLDTR_E_TD_NESTEDNOENCL 
                                                                 : VLDTR_E_TD_ENCLNOTNESTED,
            veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    
    bIsObject = bIsEnum = bIsVType = FALSE;
    if(0 == strcmp(szNameSpace,BASE_NAMESPACE))
    {
        bIsObject = (0 == strcmp(szName,BASE_OBJECT_CLASSNAME));
        if(!bIsObject)
        {
            bIsEnum   = (0 == strcmp(szName,BASE_ENUM_CLASSNAME));
            if(!bIsEnum)
            {
                bIsVType  = (0 == strcmp(szName,BASE_VTYPE_CLASSNAME));
            }
        }
    }

    if (IsNilToken(tkExtends))
    {
        // If the parent token is nil, the class must be marked Interface,
        // unless its the System.Object class.
        if ( !(bIsObject || IsTdInterface(dwFlags)))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NOTIFACEOBJEXTNULL, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        szExtName = "";
        szExtNameSpace = "";
    }
    else
    {
        // If tkExtends is a TypeRef try to resolve it to a corresponding
        // TypeDef.  If it resolves successfully, issue a warning.  It means
        // that the Ref to Def optimization didn't happen successfully.
        if (TypeFromToken(tkExtends) == mdtTypeRef)
        {
            TypeRefRec  *pTypeRefRec = pMiniMd->getTypeRef(RidFromToken(tkExtends));
            mdTypeDef   tkResTd;

            szExtName = pMiniMd->getNameOfTypeRef(pTypeRefRec);
            szExtNameSpace = pMiniMd->getNamespaceOfTypeRef(pTypeRefRec);

            if(ImportHelper::FindTypeDefByName(pMiniMd,
                        szExtNameSpace,
                        szExtName,
                        tkEncloser, &tkResTd) == S_OK)
            {
                // Ref to Def optimization is not expected to happen for Obj files.
                /*
                if (m_ModuleType != ValidatorModuleTypeObj)
                {
                    IfFailGo(_ValidateErrorHelper(tkExtends, tkResTd, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_EXTTRRES, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_WRN);
                }
                */

                // Set tkExtends to the new TypeDef, so we can continue
                // with the validation.
                tkExtends = tkResTd;
            }
        }

        // Continue validation, even for the case where TypeRef got resolved
        // to a corresponding TypeDef in the same Module.
        if (TypeFromToken(tkExtends) == mdtTypeDef)
        {
            // Extends must not be sealed.
            pExtendsRec = pMiniMd->getTypeDef(RidFromToken(tkExtends));
            dwExtendsFlags = pMiniMd->getFlagsOfTypeDef(pExtendsRec);
            szExtName = pMiniMd->getNameOfTypeDef(pExtendsRec);
            szExtNameSpace = pMiniMd->getNamespaceOfTypeDef(pExtendsRec);
            if (IsTdSealed(dwExtendsFlags))
            {
                IfFailGo(_ValidateErrorHelper(tkExtends, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_EXTENDSSEALED, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            if (IsTdInterface(dwExtendsFlags))
            {
                IfFailGo(_ValidateErrorHelper(tkExtends, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_EXTENDSIFACE, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
        }
        else if(TypeFromToken(tkExtends) == mdtTypeSpec)
        {
            IfFailGo(_ValidateErrorHelper(tkExtends, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_EXTTYPESPEC, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_WRN);
        }
        // If the parent token is non-null, the class must not be System.Object.
        if (bIsObject)
        {
            IfFailGo(_ValidateErrorHelper(tkExtends, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_OBJEXTENDSNONNULL, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    bExtendsObject = bExtendsEnum = bExtendsVType = FALSE;
    if(0 == strcmp(szExtNameSpace,BASE_NAMESPACE))
    {
        bExtendsObject = (0 == strcmp(szExtName,BASE_OBJECT_CLASSNAME));
        if(!bExtendsObject)
        {
            bExtendsEnum   = (0 == strcmp(szExtName,BASE_ENUM_CLASSNAME));
            if(!bExtendsEnum)
            {
                bExtendsVType  = (0 == strcmp(szExtName,BASE_VTYPE_CLASSNAME));
            }
        }
    }

    // System.ValueType must extend System.Object
    if(bIsVType && !bExtendsObject)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_SYSVTNOTEXTOBJ, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Validate rules for interface.  Some of the VOS rules are verified as
    // part of the validation for the corresponding Methods, fields etc.
    if (IsTdInterface(dwFlags))
    {
        // Interface type must be marked abstract.
        if (!IsTdAbstract(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_IFACENOTABS, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }

        // Interface must not be sealed
        if(IsTdSealed(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_IFACESEALED, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }

        // Interface must have parent Nil token.
        if (!IsNilToken(tkExtends))
        {
            IfFailGo(_ValidateErrorHelper(tkExtends, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_IFACEPARNOTNIL, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }

        //Interface must have only static fields -- checked in ValidateField
        //Interface must have only public fields -- checked in ValidateField
        //Interface must have only abstract or static methods -- checked in ValidateMethod
        //Interface must have only public methods -- checked in ValidateMethod

        // Interface must have GUID
        /*
        if (*pGuid == GUID_NULL)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_IFACEGUIDNULL, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_WRN);
        }
        */
    }


    // Class must have valid method and field lists
    {
        ULONG           ridStart,ridEnd;
        ridStart = pMiniMd->getMethodListOfTypeDef(pRecord);
        ridEnd  = pMiniMd->getCountMethods() + 1;
        if(ridStart > ridEnd)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_BADMETHODLST, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else 
        {
            ridEnd = pMiniMd->getEndMethodListOfTypeDef(pRecord);
            bHasMethods = (ridStart && (ridStart < ridEnd));
        }

        ridStart = pMiniMd->getFieldListOfTypeDef(pRecord);
        ridEnd  = pMiniMd->getCountFields() + 1;
        if(ridStart > ridEnd)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_BADFIELDLST, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else 
        {
            ridEnd = pMiniMd->getEndFieldListOfTypeDef(pRecord);
            bHasFields = (ridStart && (ridStart < ridEnd));
        }
    }

    // Validate rules for System.Enum
    if(bIsEnum)
    {
        if(!IsTdClass(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_SYSENUMNOTCLASS, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        if(!bExtendsVType)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_SYSENUMNOTEXTVTYPE, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    else
    {
        if(bExtendsVType || bExtendsEnum)
        {
            // ValueTypes and Enums must be sealed
            if(!IsTdSealed(dwFlags))
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_VTNOTSEAL, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            // Value class must have fields or size
            if(!bHasFields)
            {
                ULONG ulClassSize = 0;
                ClassLayoutRec  *pRec;
                RID ridClassLayout = pMiniMd->FindClassLayoutHelper(TokenFromRid(rid, mdtTypeDef));

                if (!InvalidRid(ridClassLayout))
                {
                    pRec = pMiniMd->getClassLayout(RidFromToken(ridClassLayout));
                    ulClassSize = pMiniMd->getClassSizeOfClassLayout(pRec);
                }
                if(ulClassSize == 0)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_VTNOSIZE, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }
        }
    }

    // Enum-related checks
    if (bExtendsEnum)
    {
        {
            PCCOR_SIGNATURE pValueSig;
            ULONG           cbValueSig;
            mdFieldDef      tkValueField=0, tkField, tkValue__Field;
            ULONG           ridStart,ridEnd,index;
            FieldRec        *pFieldRecord;               // Field record.
            DWORD           dwFlags, dwTally, dwValueFlags, dwValue__Flags;
            RID             ridField,ridValue=0,ridValue__ = 0;

            ridStart = pMiniMd->getFieldListOfTypeDef(pRecord);
            ridEnd = pMiniMd->getEndFieldListOfTypeDef(pRecord);
            // check the instance (value__) field(s)
            dwTally = 0;
            for (index = ridStart; index < ridEnd; index++ )
            {
                ridField = pMiniMd->GetFieldRid(index);
                pFieldRecord = pMiniMd->getField(ridField);
                dwFlags = pFieldRecord->m_Flags;
                if(!IsFdStatic(dwFlags))
                {
                    dwTally++;
                    if(ridValue == 0)
                    {
                        ridValue = ridField;
                        tkValueField = TokenFromRid(ridField, mdtFieldDef);
                        pValueSig = pMiniMd->getSignatureOfField(pFieldRecord, &cbValueSig);
                        dwValueFlags = dwFlags;
                    }
                }
                if(!strcmp(pMiniMd->getNameOfField(pFieldRecord),BASE_VALUE_FIELDNAME))
                {
                    ridValue__ = ridField;
                    dwValue__Flags = dwFlags;
                    tkValue__Field = TokenFromRid(ridField, mdtFieldDef);
                }
            }
            // Enum must have one (and only one) inst.field
            if(dwTally == 0)
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMNOINSTFLD, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            else if(dwTally > 1)
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMMULINSTFLD, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }

            // inst.field name must be "value__" (CLS)
            if(ridValue__ == 0)
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMNOVALUE, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_WRN);
            }
            else
            {
                // if "value__" field is present ...
                // ... it must be 1st instance field
                if(ridValue__ != ridValue)
                {
                    IfFailGo(_ValidateErrorHelper(tkValue__Field, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMVALNOT1ST, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // ... it must not be static
                if(IsFdStatic(dwValue__Flags))
                {
                    IfFailGo(_ValidateErrorHelper(tkValue__Field, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMVALSTATIC, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // ... it must be fdRTSpecialName
                if(!IsFdRTSpecialName(dwValue__Flags))
                {
                    IfFailGo(_ValidateErrorHelper(tkValueField, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMVALNOTSN, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // ... its type must be integral
                if(cbValueSig && pValueSig)
                {
                    ULONG ulCurByte = CorSigUncompressedDataSize(pValueSig);
                    ULONG ulCallConv = CorSigUncompressData(pValueSig);
                    ULONG ulElemSize,ulElementType;
                    ulCurByte += (ulElemSize = CorSigUncompressedDataSize(pValueSig));
                    ulElementType = CorSigUncompressData(pValueSig);
                    switch (ulElementType)
                    {
                        case ELEMENT_TYPE_BOOLEAN:
                        case ELEMENT_TYPE_CHAR:
                        case ELEMENT_TYPE_I1:
                        case ELEMENT_TYPE_U1:
                        case ELEMENT_TYPE_I2:
                        case ELEMENT_TYPE_U2:
                        case ELEMENT_TYPE_I4:
                        case ELEMENT_TYPE_U4:
                        case ELEMENT_TYPE_I8:
                        case ELEMENT_TYPE_U8:
                        case ELEMENT_TYPE_U:
                        case ELEMENT_TYPE_I:
                            break;
                        default:
                            IfFailGo(_ValidateErrorHelper(tkValue__Field, rVar, &psa));
                            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMFLDBADTYPE, veCtxt, psa));
                            SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    }
                }

            }
            // check all the fields
            dwTally = 0;
            for (index = ridStart; index < ridEnd; index++ )
            {
                ridField = pMiniMd->GetFieldRid(index);
                if(ridField == ridValue) continue; 
                pFieldRecord = pMiniMd->getField(ridField);
                if(IsFdRTSpecialName(pFieldRecord->m_Flags) 
                    && IsDeletedName(pMiniMd->getNameOfField(pFieldRecord))) continue;
                dwTally++;
                tkField = TokenFromRid(ridField, mdtFieldDef);
                if(!IsFdStatic(pFieldRecord->m_Flags))
                {
                    IfFailGo(_ValidateErrorHelper(tkField, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMFLDNOTST, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                if(!IsFdLiteral(pFieldRecord->m_Flags))
                {
                    IfFailGo(_ValidateErrorHelper(tkField, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMFLDNOTLIT, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                /*
                pvSigTmp = pMiniMd->getSignatureOfField(pFieldRecord, &cbSig);
                if(!(pvSigTmp && (cbSig==cbValueSig) &&(memcmp(pvSigTmp,pValueSig,cbSig)==0)))
                {
                    IfFailGo(_ValidateErrorHelper(tkField, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMFLDSIGMISMATCH, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                */
            }
            if(dwTally == 0)
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMNOLITFLDS, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_WRN);
            }
        }
        // Enum must have no methods
        if(bHasMethods)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMHASMETHODS, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Enum must implement no interfaces
        {
            ULONG ridStart = 1;
            ULONG ridEnd = pMiniMd->getCountInterfaceImpls() + 1;
            ULONG index;
            for (index = ridStart; index < ridEnd; index ++ )
            {
                if ( veCtxt.Token == pMiniMd->getClassOfInterfaceImpl(pMiniMd->getInterfaceImpl(index)))
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMIMPLIFACE, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    break;
                }
            }
        }
        // Enum must have no properties
        {
            ULONG ridStart = 1;
            ULONG ridEnd = pMiniMd->getCountPropertys() + 1;
            ULONG index;
            mdToken tkClass;
            for (index = ridStart; index < ridEnd; index ++ )
            {
                pMiniMd->FindParentOfPropertyHelper( index|mdtProperty, &tkClass);
                if ( veCtxt.Token == tkClass)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMHASPROP, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    break;
                }
            }
        }
        // Enum must have no events
        {
            ULONG ridStart = 1;
            ULONG ridEnd = pMiniMd->getCountEvents() + 1;
            ULONG index;
            mdToken tkClass;
            for (index = ridStart; index < ridEnd; index ++ )
            {
                pMiniMd->FindParentOfEventHelper( index|mdtEvent, &tkClass);
                if ( veCtxt.Token == tkClass)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_ENUMHASEVENT, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    break;
                }
            }
        }
    } // end if(bExtendsEnum)
    // Class having security must be marked tdHasSecurity and vice versa
    {
        ULONG ridStart = 1;
        ULONG ridEnd = pMiniMd->getCountDeclSecuritys() + 1;
        ULONG index;
        BOOL  bHasSecurity = FALSE;
        for (index = ridStart; index < ridEnd; index ++ )
        {
            if ( veCtxt.Token == pMiniMd->getParentOfDeclSecurity(pMiniMd->getDeclSecurity(index)))
            {
                bHasSecurity = TRUE;
                break;
            }
        }
        if(!bHasSecurity) // No records, check for CA "SuppressUnmanagedCodeSecurityAttribute"
        {
            bHasSecurity = (S_OK == ImportHelper::GetCustomAttributeByName(pMiniMd, veCtxt.Token, 
                "System.Security.SuppressUnmanagedCodeSecurityAttribute", NULL, NULL));
        }
        if(bHasSecurity != (IsTdHasSecurity(pRecord->m_Flags)!=0))
        {
            IfBreakGo(m_pVEHandler->VEHandler(bHasSecurity? VLDTR_E_TD_SECURNOTMARKED 
                : VLDTR_E_TD_MARKEDNOSECUR, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateTypeDef()

//*****************************************************************************
// Validate the given FieldPtr.
//*****************************************************************************
HRESULT RegMeta::ValidateFieldPtr(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateFieldPtr()

//*****************************************************************************
// Validate the given Field.
//*****************************************************************************
HRESULT RegMeta::ValidateField(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    FieldRec    *pRecord;               // Field record.
    mdTypeDef   tkTypeDef;              // Parent TypeDef token.
    mdFieldDef  tkFieldDef;             // Duplicate FieldDef token.
    LPCSTR      szName;                 // FieldDef name.
    PCCOR_SIGNATURE pbSig;              // FieldDef signature.
    ULONG       cbSig;                  // Signature size in bytes.
    VEContext   veCtxt;                 // Context record.
    VARIANT     rVar[2];                // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    BOOL        bIsValueField;
    BOOL        bIsGlobalField = FALSE;
    BOOL        bIsParentInterface = FALSE;
    BOOL        bHasValidRVA = FALSE;
    DWORD       dwInvalidFlags;
    DWORD       dwFlags;

    // Get the FieldDef record.
    veCtxt.Token = TokenFromRid(rid, mdtFieldDef);
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getField(rid);

    // Do checks for name validity.
    szName = pMiniMd->getNameOfField(pRecord);
    if (!*szName)
    {
        // Field name is NULL.
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else
    {
        if(!strcmp(szName,COR_DELETED_NAME_A)) goto ErrExit; 
        if(strlen(szName) >= MAX_CLASSNAME_LENGTH)
        {
            IfFailGo(_ValidateErrorHelper((ULONG)strlen(szName), (ULONG)(MAX_CLASSNAME_LENGTH-1), rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NAMETOOLONG, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    bIsValueField = (strcmp(szName,BASE_VALUE_FIELDNAME)==0);
    // If field is RTSpecialName, its name must be 'value__' and vice versa
    if((IsFdRTSpecialName(pRecord->m_Flags)!=0) != bIsValueField)
    {
        IfFailGo(_ValidateErrorHelper(veCtxt.Token, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(bIsValueField ? VLDTR_E_TD_ENUMVALNOTSN
                                                        : VLDTR_E_FD_NOTVALUERTSN, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Validate flags
    dwFlags = pRecord->m_Flags;
    dwInvalidFlags = ~(fdFieldAccessMask | fdStatic | fdInitOnly | fdLiteral | fdNotSerialized | fdSpecialName
        | fdPinvokeImpl | fdReservedMask);
    if(dwFlags & dwInvalidFlags)
    {
        IfFailGo(_ValidateErrorHelper(dwFlags & dwInvalidFlags, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_EXTRAFLAGS, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Validate access
    if((dwFlags & fdFieldAccessMask) == fdFieldAccessMask)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_BADACCESSFLAG, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Literal : Static, !InitOnly
    if(IsFdLiteral(dwFlags))
    {
        if(IsFdInitOnly(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_INITONLYANDLITERAL, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        if(!IsFdStatic(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_LITERALNOTSTATIC, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        if(!IsFdHasDefault(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_LITERALNODEFAULT, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    // RTSpecialName => SpecialName
    if(IsFdRTSpecialName(dwFlags) && !IsFdSpecialName(dwFlags))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_RTSNNOTSN, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Validate Field signature.
    pbSig = pMiniMd->getSignatureOfField(pRecord, &cbSig);
    IfFailGo(ValidateFieldSig(TokenFromRid(rid, mdtFieldDef), pbSig, cbSig));
    if (hr != S_OK)
        SetVldtrCode(&hrSave, hr);

    // Validate Field RVA
    if(IsFdHasFieldRVA(dwFlags))
    {
        ULONG iFieldRVARid;
        iFieldRVARid = pMiniMd->FindFieldRVAHelper(TokenFromRid(rid, mdtFieldDef));
        if((iFieldRVARid==0) || (iFieldRVARid > pMiniMd->getCountFieldRVAs()))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_RVAHASNORVA, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else
        {
            FieldRVARec* pRVARec = pMiniMd->getFieldRVA(iFieldRVARid);
            if(pRVARec->m_RVA == 0)
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_RVAHASZERORVA, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            else bHasValidRVA = TRUE;
        }
    }

    // Get the parent of the Field.
    IfFailGo(pMiniMd->FindParentOfFieldHelper(TokenFromRid(rid, mdtFieldDef), &tkTypeDef));
    // Validate that the parent is not nil.
    if (IsNilToken(tkTypeDef))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_PARNIL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else if (RidFromToken(tkTypeDef) != RidFromToken(m_tdModule))
    {
        if(_IsValidToken(tkTypeDef) && (TypeFromToken(tkTypeDef) == mdtTypeDef))
        {
            TypeDefRec* pParentRec = pMiniMd->getTypeDef(RidFromToken(tkTypeDef));
            // If the name is "value__" ...
            if(bIsValueField)
            {
                // parent must be Enum
                mdToken tkExtends = pMiniMd->getExtendsOfTypeDef(pParentRec);
                RID     ridExtends = RidFromToken(tkExtends);
                LPCSTR  szExtName="",szExtNameSpace="";
                if(ridExtends)
                {
                    if(TypeFromToken(tkExtends) == mdtTypeRef)
                    {
                        TypeRefRec* pExtRec = pMiniMd->getTypeRef(ridExtends);
                        szExtName = pMiniMd->getNameOfTypeRef(pExtRec);
                        szExtNameSpace = pMiniMd->getNamespaceOfTypeRef(pExtRec);
                    }
                    else if(TypeFromToken(tkExtends) == mdtTypeDef)
                    {
                        TypeDefRec* pExtRec = pMiniMd->getTypeDef(ridExtends);
                        szExtName = pMiniMd->getNameOfTypeDef(pExtRec);
                        szExtNameSpace = pMiniMd->getNamespaceOfTypeDef(pExtRec);
                    }
                }
                if(strcmp(szExtName,BASE_ENUM_CLASSNAME) || strcmp(szExtNameSpace,BASE_NAMESPACE))
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_VALUEPARNOTENUM, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }

                // field must be instance - checked in ValidateTypeDef
                // must be no other instance fields - checked in ValidateTypeDef
                // must be first field - checked in ValidateTypeDef
                // must be RTSpecialName -- checked in ValidateTypeDef
            }
            if(IsTdInterface(pMiniMd->getFlagsOfTypeDef(pParentRec)))
            {
                bIsParentInterface = TRUE;
                // Fields in interface are not CLS compliant
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_FLDINIFACE, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_WRN);

                // If field is not static, verify parent is not interface.
                if(!IsFdStatic(dwFlags))
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_INSTINIFACE, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // If field is not public, verify parent is not interface.
                if(!IsFdPublic(dwFlags))
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_NOTPUBINIFACE, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }
        } // end if Valid and TypeDef
        else
        {
            IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_BADPARENT, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    else // i.e. if (RidFromToken(tkTypeDef) == RidFromToken(m_tdModule))
    {
        bIsGlobalField = TRUE;
        // Globals are not CLS-compliant
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_GLOBALITEM, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_WRN);
        // Validate global field:
        // Must be Public or PrivateScope
        if(!IsFdPublic(dwFlags) && !IsFdPrivateScope(dwFlags)&& !IsFdPrivate(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_GLOBALNOTPUBPRIVSC, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Must be static
        if(!IsFdStatic(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_GLOBALNOTSTATIC, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Must have a non-zero RVA
        /*
        if(!bHasValidRVA)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_GLOBALNORVA, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        */
    }

    // Check for duplicates, except global fields with PrivateScope.
    if (*szName && cbSig && !IsFdPrivateScope(dwFlags))
    {
        hr = ImportHelper::FindField(pMiniMd, tkTypeDef, szName, pbSig, cbSig, &tkFieldDef, rid);
        if (hr == S_OK)
        {
            FieldRec    *pRec = pMiniMd->getField(RidFromToken(tkFieldDef));
            if(!IsFdPrivateScope(dwFlags))
            {
                IfFailGo(_ValidateErrorHelper(tkFieldDef, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_DUP, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            else hr = S_OK;
        }
        else if (hr == CLDB_E_RECORD_NOTFOUND)
            hr = S_OK;
        else
            IfFailGo(hr);
    }
    // Field having security must be marked fdHasSecurity and vice versa
    {
        ULONG ridStart = 1;
        ULONG ridEnd = pMiniMd->getCountDeclSecuritys() + 1;
        ULONG index;
        BOOL  bHasSecurity = FALSE;
        for (index = ridStart; index < ridEnd; index ++ )
        {
            if ( veCtxt.Token == pMiniMd->getParentOfDeclSecurity(pMiniMd->getDeclSecurity(index)))
            {
                bHasSecurity = TRUE;
                break;
            }
        }
        if(!bHasSecurity) // No records, check for CA "SuppressUnmanagedCodeSecurityAttribute"
        {
            bHasSecurity = (S_OK == ImportHelper::GetCustomAttributeByName(pMiniMd, veCtxt.Token, 
                "System.Security.SuppressUnmanagedCodeSecurityAttribute", NULL, NULL));
        }
        if(bHasSecurity)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_SECURNOTMARKED, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    // Field having marshaling must be marked fdHasFieldMarshal and vice versa
    if(InvalidRid(pMiniMd->FindFieldMarshalHelper(veCtxt.Token)) == 
        (IsFdHasFieldMarshal(dwFlags) !=0))
    {
        IfBreakGo(m_pVEHandler->VEHandler(IsFdHasFieldMarshal(dwFlags)? VLDTR_E_FD_MARKEDNOMARSHAL
            : VLDTR_E_FD_MARSHALNOTMARKED, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Field having const value must be marked fdHasDefault and vice versa
    if(InvalidRid(pMiniMd->FindConstantHelper(veCtxt.Token)) == 
        (IsFdHasDefault(dwFlags) !=0))
    {
        IfBreakGo(m_pVEHandler->VEHandler(IsFdHasDefault(dwFlags)? VLDTR_E_FD_MARKEDNODEFLT
            : VLDTR_E_FD_DEFLTNOTMARKED, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Check the field's impl.map
    {
        ULONG iRecord;
        iRecord = pMiniMd->FindImplMapHelper(veCtxt.Token);
        if(IsFdPinvokeImpl(dwFlags))
        {
            // must be static
            if(!IsFdStatic(dwFlags))
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_PINVOKENOTSTATIC, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            // must have ImplMap
            if (InvalidRid(iRecord))
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_MARKEDNOPINVOKE, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
        }
        else
        {
            // must have no ImplMap
            if (!InvalidRid(iRecord))
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_PINVOKENOTMARKED, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
        }
        if (!InvalidRid(iRecord))
        {
            hr = ValidateImplMap(iRecord);
            if(hr != S_OK)
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_BADIMPLMAP, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_WRN);
            }
        }

    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateField()

//*****************************************************************************
// Validate the given MethodPtr.
//*****************************************************************************
HRESULT RegMeta::ValidateMethodPtr(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateMethodPtr()

//*****************************************************************************
// Validate the given Method.
//*****************************************************************************
HRESULT RegMeta::ValidateMethod(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    MethodRec   *pRecord;               // Method record.
    mdTypeDef   tkTypeDef;              // Parent TypeDef token.
    mdMethodDef tkMethodDef;            // Duplicate MethodDef token.
    LPCSTR      szName;                 // MethodDef name.
    DWORD       dwFlags;                // Method flags.
    DWORD       dwImplFlags;            // Method impl.flags.
    PCCOR_SIGNATURE pbSig;              // MethodDef signature.
    ULONG       cbSig;                  // Signature size in bytes.
    VEContext   veCtxt;                 // Context record.
    VARIANT     rVar[3];                // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    BOOL        bIsCtor=FALSE;
    BOOL        bIsCctor=FALSE;
    BOOL        bIsGlobal=FALSE;
    BOOL        bIsParentInterface = FALSE;
    BOOL        bIsParentImport = FALSE;
    unsigned    retType;

    // Get the MethodDef record.
    veCtxt.Token = TokenFromRid(rid, mdtMethodDef);
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getMethod(rid);

    // Do checks for name validity.
    szName = pMiniMd->getNameOfMethod(pRecord);
    if (!*szName)
    {
        // Method name is NULL.
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else
    {
        if(!strcmp(szName,COR_DELETED_NAME_A)) goto ErrExit; 
        bIsCtor = (0 == strcmp(szName,BASE_CTOR_NAME));
        bIsCctor = (0 == strcmp(szName,BASE_CCTOR_NAME));
        if(strlen(szName) >= MAX_CLASSNAME_LENGTH)
        {
            IfFailGo(_ValidateErrorHelper((ULONG)strlen(szName), (ULONG)(MAX_CLASSNAME_LENGTH-1), rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NAMETOOLONG, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    // Get the parent, flags and signature of the Method.
    IfFailGo(pMiniMd->FindParentOfMethodHelper(TokenFromRid(rid, mdtMethodDef), &tkTypeDef));
    dwFlags = pMiniMd->getFlagsOfMethod(pRecord);
    dwImplFlags = pMiniMd->getImplFlagsOfMethod(pRecord);
    pbSig = pMiniMd->getSignatureOfMethod(pRecord, &cbSig);

    // Check for duplicates.
    if (*szName && cbSig && !IsNilToken(tkTypeDef) && !IsMdPrivateScope(dwFlags))
    {
        hr = ImportHelper::FindMethod(pMiniMd, tkTypeDef, szName, pbSig, cbSig, &tkMethodDef, rid);
        if (hr == S_OK)
        {
            IfFailGo(_ValidateErrorHelper(tkMethodDef, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_DUP, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else if (hr == CLDB_E_RECORD_NOTFOUND)
            hr = S_OK;
        else
            IfFailGo(hr);
    }

    // No further error checking for VtblGap methods.
    if (IsVtblGapName(szName))
    {
        hr = hrSave;
        goto ErrExit;
    }

    // Validate Method signature.
    IfFailGo(ValidateMethodSig(TokenFromRid(rid, mdtMethodDef), pbSig, cbSig,
                               dwFlags));
    if (hr != S_OK)
        SetVldtrCode(&hrSave, hr);

    // Validate that the parent is not nil.
    if (IsNilToken(tkTypeDef))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_PARNIL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else if (RidFromToken(tkTypeDef) != RidFromToken(m_tdModule))
    {
        if(TypeFromToken(tkTypeDef) == mdtTypeDef)
        {
            TypeDefRec* pTDRec = pMiniMd->getTypeDef(RidFromToken(tkTypeDef));
            DWORD       dwTDFlags = pTDRec->m_Flags;
            LPCSTR      szTDName = pMiniMd->getNameOfTypeDef(pTDRec);
            LPCSTR      szTDNameSpace = pMiniMd->getNamespaceOfTypeDef(pTDRec);
            BOOL        fIsTdValue=FALSE, fIsTdEnum=FALSE;
            mdToken     tkExtends = pMiniMd->getExtendsOfTypeDef(pTDRec);

            if(0 == strcmp(szTDNameSpace,BASE_NAMESPACE))
            {
                fIsTdEnum   = (0 == strcmp(szTDName,BASE_ENUM_CLASSNAME));
                if(!fIsTdEnum)
                {
                    fIsTdValue  = (0 == strcmp(szTDName,BASE_VTYPE_CLASSNAME));
                }
            }
            if(fIsTdEnum || fIsTdValue)
            {
                fIsTdEnum = fIsTdValue = FALSE; // System.Enum and System.ValueType themselves are classes
            }
            else if(RidFromToken(tkExtends))
            {
                if(TypeFromToken(tkExtends) == mdtTypeDef)
                {
                    pTDRec = pMiniMd->getTypeDef(RidFromToken(tkExtends));
                    szTDName = pMiniMd->getNameOfTypeDef(pTDRec);
                    szTDNameSpace = pMiniMd->getNamespaceOfTypeDef(pTDRec);
                }
                else
                {
                    TypeRefRec* pTRRec = pMiniMd->getTypeRef(RidFromToken(tkExtends));
                    szTDName = pMiniMd->getNameOfTypeRef(pTRRec);
                    szTDNameSpace = pMiniMd->getNamespaceOfTypeRef(pTRRec);
                }

                if(0 == strcmp(szTDNameSpace,BASE_NAMESPACE))
                {
                    fIsTdEnum   = (0 == strcmp(szTDName,BASE_ENUM_CLASSNAME));
                    if(!fIsTdEnum)
                    {
                        fIsTdValue  = (0 == strcmp(szTDName,BASE_VTYPE_CLASSNAME));
                    }
                    else fIsTdValue = FALSE;
                }
            }

            // If Method is abstract, verify parent is abstract.
            if(IsMdAbstract(dwFlags) && !IsTdAbstract(dwTDFlags))
            {
                IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_ABSTPARNOTABST, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            // If parent is import, method must have zero RVA, otherwise it depends...
            if(IsTdImport(dwTDFlags)) bIsParentImport = TRUE;
            if(IsTdInterface(dwTDFlags))
            {
                bIsParentInterface = TRUE;
                // If Method is non-static and not-abstract, verify parent is not interface.
                if(!IsMdStatic(dwFlags) && !IsMdAbstract(dwFlags))
                {
                    IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_NOTSTATABSTININTF, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // If Method is not public, verify parent is not interface.
                if(!IsMdPublic(dwFlags))
                {
                    IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_NOTPUBININTF, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // If Method is constructor, verify parent is not interface.
                if(bIsCtor)
                {
                    IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CTORININTF, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }//end if(interface)
            if((fIsTdValue || fIsTdEnum) && IsMiSynchronized(dwImplFlags))
            {
                IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_SYNCMETHODINVTYPE, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            if(bIsCtor)
            {
                // .ctor must be instance
                if(IsMdStatic(dwFlags))
                {
                    IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CTORSTATIC, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }//end if .ctor
            else if(bIsCctor)
            {
                // .cctor must be static
                if(!IsMdStatic(dwFlags))
                {
                    IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CCTORNOTSTATIC, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // ..cctor must have default callconv
                pbSig = pMiniMd->getSignatureOfMethod(pRecord, &cbSig);
                if(IMAGE_CEE_CS_CALLCONV_DEFAULT != CorSigUncompressData(pbSig))
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CCTORCALLCONV, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // .cctor must have no arguments
                if(0 != CorSigUncompressData(pbSig))
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CCTORHASARGS, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }


            }//end if .cctor
            if(bIsCtor || bIsCctor)
            {
                // .ctor, .cctor must be SpecialName and RTSpecialName
                if(!(IsMdSpecialName(dwFlags) && IsMdRTSpecialName(dwFlags)))
                {
                    IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CTORNOTSNRTSN, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
#ifdef NO_SUCH_CHECKS_NEEDED_SPEC_TO_BE_UODATED
                // .ctor, .cctor must not be virtual
                if(IsMdVirtual(dwFlags))
                {
                    IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CTORVIRT, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // .ctor, .cctor must not be abstract
                if(IsMdAbstract(dwFlags))
                {
                    IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CTORABST, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // .ctor, .cctor must not be PInvoke
                if(IsMdPinvokeImpl(dwFlags))
                {
                    IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CTORPINVOKE, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                // .ctor,.cctor must have RVA!=0
                if(pRecord->m_RVA==0)
                { 
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CTORZERORVA, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
#endif
            }//end if .ctor or .cctor
        }// end if(parent == TypeDef)
    }// end if not Module
    else // i.e. if (RidFromToken(tkTypeDef) == RidFromToken(m_tdModule))
    {
        bIsGlobal = TRUE;
        // Globals are not CLS-compliant
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_GLOBALITEM, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_WRN);
        // Validate global method:
        // Must be Public or PrivateScope
        if(!IsMdPublic(dwFlags) && !IsMdPrivateScope(dwFlags) && !IsMdPrivate(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_GLOBALNOTPUBPRIVSC, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Must be static
        if(!IsMdStatic(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_GLOBALNOTSTATIC, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Must not be abstract or virtual
        if(IsMdAbstract(dwFlags) || IsMdVirtual(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_GLOBALABSTORVIRT, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Must be not .ctor or .cctor
        if(bIsCtor)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_GLOBALCTORCCTOR, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    } //end if Module

    // Signature specifics: .ctor, .cctor, entrypoint
    if(bIsCtor || bIsCctor)
    {
        // .ctor, .cctor must return void
        pbSig = pMiniMd->getSignatureOfMethod(pRecord, &cbSig);
        CorSigUncompressData(pbSig); // get call conv out of the way
        CorSigUncompressData(pbSig); // get num args out of the way
        while (((retType=CorSigUncompressData(pbSig)) == ELEMENT_TYPE_CMOD_OPT) 
            || (retType == ELEMENT_TYPE_CMOD_REQD)) CorSigUncompressToken(pbSig);
        if(retType != ELEMENT_TYPE_VOID)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_CTORNOTVOID, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    if(g_tkEntryPoint == veCtxt.Token)
    {
        // EP must be static
        if(!IsMdStatic(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EP_INSTANCE, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        pbSig = pMiniMd->getSignatureOfMethod(pRecord, &cbSig);
        CorSigUncompressData(pbSig); // get call conv out of the way
        // EP must have 0 or 1 argument
        unsigned nArgs = CorSigUncompressData(pbSig);
        if(g_fIsDLL)
        {
            if(nArgs != 3)
            {
                IfFailGo(_ValidateErrorHelper(3, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EP_TOOMANYARGS, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            //EP must return I4
            while (((retType=CorSigUncompressData(pbSig)) == ELEMENT_TYPE_CMOD_OPT) 
                || (retType == ELEMENT_TYPE_CMOD_REQD)) CorSigUncompressToken(pbSig);
    
            if(retType != ELEMENT_TYPE_I4)
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EP_BADRET, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            // Arguments must be VOID*, U4, VOID*
            if(nArgs)
            {
                unsigned jj;
                bool    badarg;
                for(jj=0; jj<nArgs;jj++)
                {
                    while (((retType=CorSigUncompressData(pbSig)) == ELEMENT_TYPE_CMOD_OPT) 
                        || (retType == ELEMENT_TYPE_CMOD_REQD)) CorSigUncompressToken(pbSig);
        
                    switch(jj)
                    {
                        case 0:
                        case 2:
                            badarg = (retType != ELEMENT_TYPE_PTR)
                                    ||(CorSigUncompressData(pbSig) != ELEMENT_TYPE_VOID);
                            break;
    
                        case 1:
                            badarg = (retType != ELEMENT_TYPE_U4);
                            break;
    
                        default:
                            badarg = true;
                    }
                    if(badarg)
                    {
                        IfFailGo(_ValidateErrorHelper(jj+1, rVar, &psa));
                        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EP_BADARG, veCtxt, psa));
                        SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    }
                }
            }
        }
        else
        {
            if(nArgs > 1)
            {
                IfFailGo(_ValidateErrorHelper(1, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EP_TOOMANYARGS, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            //EP must return VOID, I4 or U4
            while (((retType=CorSigUncompressData(pbSig)) == ELEMENT_TYPE_CMOD_OPT) 
                || (retType == ELEMENT_TYPE_CMOD_REQD)) CorSigUncompressToken(pbSig);
    
            if((retType != ELEMENT_TYPE_VOID)&&(retType != ELEMENT_TYPE_I4)&&(retType != ELEMENT_TYPE_U4))
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EP_BADRET, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            // Argument (if any) must be vector of strings
            if(nArgs)
            {
                while (((retType=CorSigUncompressData(pbSig)) == ELEMENT_TYPE_CMOD_OPT) 
                    || (retType == ELEMENT_TYPE_CMOD_REQD)) CorSigUncompressToken(pbSig);
    
                if((retType != ELEMENT_TYPE_SZARRAY)||(CorSigUncompressData(pbSig) != ELEMENT_TYPE_STRING))
                {
                    IfFailGo(_ValidateErrorHelper(1, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EP_BADARG, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }
        }
    }


    // Check method RVA
    if(pRecord->m_RVA==0)
    { 
        if(!(IsMdPinvokeImpl(dwFlags) || IsMdAbstract(dwFlags) 
            || IsMiRuntime(dwImplFlags) || IsMiInternalCall(dwImplFlags)
            || bIsParentImport))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_ZERORVA, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    else
    {
        if(m_pStgdb && m_pStgdb->m_pImage)
        {
            IMAGE_DOS_HEADER   *pDos;
            IMAGE_NT_HEADERS   *pNt;
            IMAGE_COR20_HEADER *pCor;
            PBYTE               pbVa;

            if (FAILED(RuntimeReadHeaders((BYTE*)m_pStgdb->m_pImage, &pDos, &pNt, &pCor, TRUE, m_pStgdb->m_dwImageSize)) ||
                (pbVa = Cor_RtlImageRvaToVa(pNt, (BYTE*)m_pStgdb->m_pImage, pRecord->m_RVA, m_pStgdb->m_dwImageSize)) == 0)
            {
                IfFailGo(_ValidateErrorHelper(pRecord->m_RVA, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_BADRVA, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            else
            {
                if(IsMiManaged(dwImplFlags) && (IsMiIL(dwImplFlags) || IsMiOPTIL(dwImplFlags)))
                {
                    // validate locals signature token
                    try
                    {
                        COR_ILMETHOD_DECODER method((COR_ILMETHOD*) pbVa);
                        if (method.LocalVarSigTok)
                        {
                            if((TypeFromToken(method.LocalVarSigTok) != mdtSignature) ||
                                (!_IsValidToken(method.LocalVarSigTok)) || (RidFromToken(method.LocalVarSigTok)==0))
                            {
                                IfFailGo(_ValidateErrorHelper(method.LocalVarSigTok, rVar, &psa));
                                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_BADLOCALSIGTOK, veCtxt, psa));
                                SetVldtrCode(&hrSave, VLDTR_S_ERR);
                            }
                        }
                    } 
                    catch (...)
                    {
                        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_BADHEADER, veCtxt, 0));
                        SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    }
                }
            }
        }

        if(IsMdAbstract(dwFlags) || bIsParentImport
            || IsMiRuntime(dwImplFlags) || IsMiInternalCall(dwImplFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_ZERORVA, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    // Check the method flags
    // Validate access
    if((dwFlags & mdMemberAccessMask) == mdMemberAccessMask)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_BADACCESSFLAG, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Final/NewSlot must be virtual
    if((IsMdFinal(dwFlags)||IsMdNewSlot(dwFlags)) && !IsMdVirtual(dwFlags))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_FINNOTVIRT, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Static can't be final or virtual
    if(IsMdStatic(dwFlags))
    {
        if(IsMdFinal(dwFlags) || IsMdVirtual(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_STATANDFINORVIRT, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    else // non-static can't be an entry point
    {
        if(g_tkEntryPoint == veCtxt.Token)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EP_INSTANCE, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    if(IsMdAbstract(dwFlags))
    {
        // Can't be both abstract and final
        if(IsMdFinal(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_ABSTANDFINAL, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // If abstract, must be not miForwardRef, not Pinvoke, and must be virtual
        if(IsMiForwardRef(dwImplFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_ABSTANDIMPL, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        if(IsMdPinvokeImpl(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_ABSTANDPINVOKE, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        if(!IsMdVirtual(dwFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_ABSTNOTVIRT, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    else
    {
        // If not abstract, must be miForwardRef, and RVA!=0 or Pinvoke or miRuntime
        /*
        if(!IsMiForwardRef(dwImplFlags))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_NOTABSTNOTIMPL, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        */
        /* ---- disabled: duplicate check (see RVA check above) 
        if(!((pRecord->m_RVA !=0) || IsMdPinvokeImpl(dwFlags) 
            || IsMiRuntime(dwImplFlags) || IsMiInternalCall(dwImplFlags)))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_NOTABSTBADFLAGSRVA, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        */
    }
    // If PrivateScope, must have RVA!=0
    if(IsMdPrivateScope(dwFlags) && (pRecord->m_RVA ==0))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_PRIVSCOPENORVA, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // RTSpecialName => SpecialName
    if(IsMdRTSpecialName(dwFlags) && !IsMdSpecialName(dwFlags))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_RTSNNOTSN, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Method having security must be marked mdHasSecurity and vice versa
    {
        ULONG ridStart = 1;
        ULONG ridEnd = pMiniMd->getCountDeclSecuritys() + 1;
        ULONG index;
        BOOL  bHasSecurity = FALSE;
        for (index = ridStart; index < ridEnd; index ++ )
        {
            if ( veCtxt.Token == pMiniMd->getParentOfDeclSecurity(pMiniMd->getDeclSecurity(index)))
            {
                bHasSecurity = TRUE;
                break;
            }
        }
        if(!bHasSecurity) // No records, check for CA "SuppressUnmanagedCodeSecurityAttribute"
        {
            bHasSecurity = (S_OK == ImportHelper::GetCustomAttributeByName(pMiniMd, veCtxt.Token, 
                "System.Security.SuppressUnmanagedCodeSecurityAttribute", NULL, NULL));
        }
        if(bHasSecurity != (IsMdHasSecurity(dwFlags)!=0))
        {
            IfBreakGo(m_pVEHandler->VEHandler(bHasSecurity? VLDTR_E_FMD_SECURNOTMARKED 
                : VLDTR_E_FMD_MARKEDNOSECUR, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    // Validate method semantics
    {
        MethodSemanticsRec  *pRec;
        ULONG               ridEnd;
        ULONG               index;
        unsigned            uTally = 0;
        mdToken             tkEventProp;
        ULONG               iCount;
        DWORD               dwSemantic;
        // get the range of method rids given a typedef
        ridEnd = pMiniMd->getCountMethodSemantics();

        for (index = 1; index <= ridEnd; index++ )
        {
            pRec = pMiniMd->getMethodSemantics(index);
            if ( pMiniMd->getMethodOfMethodSemantics(pRec) ==  veCtxt.Token )
            {
                uTally++;
                if(uTally > 1)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_MULTIPLESEMANTICS, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_WRN);
                }
                tkEventProp = pMiniMd->getAssociationOfMethodSemantics(pRec);
                if((TypeFromToken(tkEventProp) == mdtEvent)||(TypeFromToken(tkEventProp) == mdtProperty))
                {
                    iCount = (TypeFromToken(tkEventProp) == mdtEvent) ? pMiniMd->getCountEvents() :
                                                                        pMiniMd->getCountPropertys();
                    if(RidFromToken(tkEventProp) > iCount)
                    {
                        IfFailGo(_ValidateErrorHelper(tkEventProp, rVar, &psa));
                        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_SEMANTICSNOTEXIST, veCtxt, psa));
                        SetVldtrCode(&hrSave, VLDTR_S_WRN);
                    }
                }
                else
                {
                    IfFailGo(_ValidateErrorHelper(tkEventProp, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_INVALIDSEMANTICS, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_WRN);
                }
                // One and only one semantics flag must be set
                iCount = 0;
                dwSemantic = pRec->m_Semantic;
                if(IsMsSetter(dwSemantic)) iCount++;
                if(IsMsGetter(dwSemantic)) iCount++;
                if(IsMsOther(dwSemantic))  iCount++;
                if(IsMsAddOn(dwSemantic))  iCount++;
                if(IsMsRemoveOn(dwSemantic)) iCount++;
                if(IsMsFire(dwSemantic)) iCount++;
                if(iCount != 1)
                {
                    IfFailGo(_ValidateErrorHelper(tkEventProp, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(iCount ? VLDTR_E_MD_MULTSEMANTICFLAGS :
                                                                VLDTR_E_MD_NOSEMANTICFLAGS, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_WRN);
                }
            }
        }// end for(index)
    }
    // Check the method's impl.map
    {
        ULONG iRecord;
        iRecord = pMiniMd->FindImplMapHelper(veCtxt.Token);
        if(IsMdPinvokeImpl(dwFlags))
        {
            // must be static
            if(!IsMdStatic(dwFlags))
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_PINVOKENOTSTATIC, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            // must have either ImplMap or RVA == 0
            if (InvalidRid(iRecord))
            {
                if(pRecord->m_RVA==0)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_MARKEDNOPINVOKE, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }
            else
            {
                if(pRecord->m_RVA!=0)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_RVAANDIMPLMAP, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }

        }
        else
        {
            // must have no ImplMap
            if (!InvalidRid(iRecord))
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_PINVOKENOTMARKED, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
        }
        if (!InvalidRid(iRecord))
        {
            hr = ValidateImplMap(iRecord);
            if(hr != S_OK)
            {
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FMD_BADIMPLMAP, veCtxt, 0));
                SetVldtrCode(&hrSave, VLDTR_S_WRN);
            }
        }

    }
    // Validate params
    {
        ULONG  ridStart = pMiniMd->getParamListOfMethod(pRecord);
        ULONG  ridEnd   = pMiniMd->getEndParamListOfMethod(pRecord);
        ParamRec* pRec;
        ULONG cbSig;
        PCCOR_SIGNATURE typePtr = pMiniMd->getSignatureOfMethod(pRecord,&cbSig);
        unsigned  callConv = CorSigUncompressData(typePtr);  // get the calling convention out of the way  
        unsigned  numArgs = CorSigUncompressData(typePtr);
        USHORT    usPrevSeq;

        for(ULONG ridP = ridStart; ridP < ridEnd; ridP++)
        {
            pRec = pMiniMd->getParam(ridP);
            // Sequence order must be ascending
            if(ridP > ridStart)
            {
                if(pRec->m_Sequence <= usPrevSeq)
                {
                    IfFailGo(_ValidateErrorHelper(ridP-ridStart,pRec->m_Sequence, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_PARAMOUTOFSEQ, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_WRN);
                }
            }
            usPrevSeq = pRec->m_Sequence;
            // Sequence value must not exceed num of arguments
            if(usPrevSeq > numArgs)
            {
                IfFailGo(_ValidateErrorHelper(ridP-ridStart,usPrevSeq, numArgs, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_PARASEQTOOBIG, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }

            // Param having marshaling must be marked pdHasFieldMarshal and vice versa
            if(InvalidRid(pMiniMd->FindFieldMarshalHelper(TokenFromRid(ridP,mdtParamDef))) == 
                (IsPdHasFieldMarshal(pRec->m_Flags) !=0))
            {
                IfFailGo(_ValidateErrorHelper(ridP-ridStart, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(IsPdHasFieldMarshal(pRec->m_Flags)? VLDTR_E_MD_PARMMARKEDNOMARSHAL
                    : VLDTR_E_MD_PARMMARSHALNOTMARKED, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            // Param having const value must be marked pdHasDefault and vice versa
            if(InvalidRid(pMiniMd->FindConstantHelper(TokenFromRid(ridP,mdtParamDef))) == 
                (IsPdHasDefault(pRec->m_Flags) !=0))
            {
                IfFailGo(_ValidateErrorHelper(ridP-ridStart, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(IsPdHasDefault(pRec->m_Flags)? VLDTR_E_MD_PARMMARKEDNODEFLT
                    : VLDTR_E_MD_PARMDEFLTNOTMARKED, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
        }
    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateMethod()
//*****************************************************************************
// Validate the given ParamPtr.
//*****************************************************************************
HRESULT RegMeta::ValidateParamPtr(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateParamPtr()

//*****************************************************************************
// Validate the given Param.
//*****************************************************************************
HRESULT RegMeta::ValidateParam(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    ParamRec    *pRecord;               // Param record
    VEContext   veCtxt;                 // Context record.
    VARIANT     rVar[3];                // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    LPCSTR      szName;                 // Param name.

    // Get the InterfaceImpl record.
    veCtxt.Token = TokenFromRid(rid, mdtParamDef);
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getParam(rid);
    // Name, if any, must not exceed MAX_CLASSNAME_LENGTH
    if(szName = pMiniMd->getNameOfParam(pRecord))
    {
        if(strlen(szName) >= MAX_CLASSNAME_LENGTH)
        {
            IfFailGo(_ValidateErrorHelper((ULONG)strlen(szName), (ULONG)(MAX_CLASSNAME_LENGTH-1), rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NAMETOOLONG, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    // Flags must be as defined in CorHdr.h
    DWORD   dwBadFlags = ~(pdIn | pdOut | pdOptional | pdHasDefault | pdHasFieldMarshal),dwFlags = pRecord->m_Flags;
    if(dwFlags & dwBadFlags)
    {
        IfFailGo(_ValidateErrorHelper(dwFlags, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_PD_BADFLAGS, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateParam()
//*****************************************************************************
// Helper function for ValidateInterfaceImpl
//*****************************************************************************
BOOL IsMethodImplementedByClass(CMiniMdRW *pMiniMd, 
                                mdToken tkMethod, 
                                LPCUTF8 szName,
                                PCCOR_SIGNATURE pSig,
                                ULONG cbSig,
                                mdToken tkClass)
{
    if((TypeFromToken(tkClass) == mdtTypeDef)&&(TypeFromToken(tkMethod) == mdtMethodDef))
    {
        HRESULT hr;
        TypeDefRec* pClass = pMiniMd->getTypeDef(RidFromToken(tkClass));
        RID ridClsStart = pMiniMd->getMethodListOfTypeDef(pClass);
        RID ridClsEnd = pMiniMd->getEndMethodListOfTypeDef(pClass);
        mdMethodDef tkFoundMethod;
        // Check among methods
        hr = ImportHelper::FindMethod(pMiniMd,tkClass,szName,pSig,cbSig,&tkFoundMethod,0);
        if(SUCCEEDED(hr)) return TRUE;
        if(hr == CLDB_E_RECORD_NOTFOUND)
        { // Check among MethodImpls
            RID ridImpl;
            for(RID idxCls = ridClsStart; idxCls < ridClsEnd; idxCls++)
            {
                RID ridCls = pMiniMd->GetMethodRid(idxCls);

                hr = ImportHelper::FindMethodImpl(pMiniMd,tkClass,TokenFromRid(ridCls,mdtMethodDef),
                    tkMethod,&ridImpl);
                if(SUCCEEDED(hr)) return TRUE;
                if(hr != CLDB_E_RECORD_NOTFOUND) return FALSE; // error returned by FindMethodImpl
            }
            // Check if parent class implements this method
            mdToken tkParent = pMiniMd->getExtendsOfTypeDef(pClass);
            if(RidFromToken(tkParent))
                return IsMethodImplementedByClass(pMiniMd,tkMethod,szName,pSig,cbSig,tkParent);
        }
    }
    return FALSE;
}
//*****************************************************************************
// Validate the given InterfaceImpl.
//*****************************************************************************
HRESULT RegMeta::ValidateInterfaceImpl(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    InterfaceImplRec *pRecord;          // InterfaceImpl record.
    mdTypeDef   tkClass;                // Class implementing the interface.
    mdToken     tkInterface;            // TypeDef for the interface.
    mdInterfaceImpl tkInterfaceImpl;    // Duplicate InterfaceImpl.
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    VARIANT     rVar[3];                // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    BOOL        fCheckTheMethods=TRUE;

    // Get the InterfaceImpl record.
    veCtxt.Token = TokenFromRid(rid, mdtInterfaceImpl);
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getInterfaceImpl(rid);

    // Get implementing Class and the TypeDef for the interface.
    tkClass = pMiniMd->getClassOfInterfaceImpl(pRecord);

    // No validation needs to be done on deleted records.
    if (IsNilToken(tkClass))
        goto ErrExit;

    tkInterface = pMiniMd->getInterfaceOfInterfaceImpl(pRecord);

    // Validate that the Class is TypeDef.
    if((!IsValidToken(tkClass))||(TypeFromToken(tkClass) != mdtTypeDef)/*&&(TypeFromToken(tkClass) != mdtTypeRef)*/)
    {
        IfFailGo(_ValidateErrorHelper(tkClass, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_IFACE_BADIMPL, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
        fCheckTheMethods = FALSE;
    }
    // Validate that the Interface is TypeDef or TypeRef.
    if((!IsValidToken(tkInterface))||(TypeFromToken(tkInterface) != mdtTypeDef)&&(TypeFromToken(tkInterface) != mdtTypeRef))
    {
        IfFailGo(_ValidateErrorHelper(tkInterface, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_IFACE_BADIFACE, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
        fCheckTheMethods = FALSE;
    }
    // Validate that Interface is marked tdInterface.
    else if(TypeFromToken(tkInterface) == mdtTypeDef)
    {
        TypeDefRec* pTDRec = pMiniMd->getTypeDef(RidFromToken(tkInterface));
        if(!IsTdInterface(pTDRec->m_Flags))
        {
            IfFailGo(_ValidateErrorHelper(tkInterface, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_IFACE_NOTIFACE, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        
    }

    // Look for duplicates.
    hr = ImportHelper::FindInterfaceImpl(pMiniMd, tkClass, tkInterface,
                                         &tkInterfaceImpl, rid);
    if (hr == S_OK)
    {
        IfFailGo(_ValidateErrorHelper(tkInterfaceImpl, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_IFACE_DUP, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else if (hr == CLDB_E_RECORD_NOTFOUND)
        hr = S_OK;
    else
        IfFailGo(hr);

    // Validate that the Class (if not interface or abstract) implements all the methods of Interface
    if((TypeFromToken(tkInterface) == mdtTypeDef) && fCheckTheMethods && (tkInterface != tkClass))
    {
        TypeDefRec* pClass = pMiniMd->getTypeDef(RidFromToken(tkClass));
        if(!(IsTdAbstract(pClass->m_Flags)||IsTdInterface(pClass->m_Flags)))
        {
            TypeDefRec* pInterface = pMiniMd->getTypeDef(RidFromToken(tkInterface));
            RID ridIntStart = pMiniMd->getMethodListOfTypeDef(pInterface);
            RID ridIntEnd = pMiniMd->getEndMethodListOfTypeDef(pInterface);
            RID ridClsStart = pMiniMd->getMethodListOfTypeDef(pClass);
            RID ridClsEnd = pMiniMd->getEndMethodListOfTypeDef(pClass);
            MethodRec*  pIntMethod;
            for(RID idxInt = ridIntStart; idxInt < ridIntEnd; idxInt++)
            {
                RID ridInt = pMiniMd->GetMethodRid(idxInt);
                pIntMethod = pMiniMd->getMethod(ridInt);
                const char* szName = pMiniMd->getNameOfMethod(pIntMethod);
                if(!IsMdStatic(pIntMethod->m_Flags) 
                    && !IsDeletedName(szName) 
                    && !IsVtblGapName(szName))
                {
                    LPCUTF8 szName = pMiniMd->getNameOfMethod(pIntMethod);
                    ULONG       cbSig;
                    PCCOR_SIGNATURE pSig = pMiniMd->getSignatureOfMethod(pIntMethod, &cbSig);
                    if(cbSig)
                    {
                        if(!IsMethodImplementedByClass(pMiniMd,TokenFromRid(ridInt,mdtMethodDef),szName,pSig,cbSig,tkClass)) 
                        { // Error: method not implemented
                            IfFailGo(_ValidateErrorHelper(tkClass,tkInterface,TokenFromRid(ridInt,mdtMethodDef), rVar, &psa));
                            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_IFACE_METHNOTIMPL, veCtxt, psa));
                            SetVldtrCode(&hrSave, VLDTR_S_ERR);
                        }
                    }
                }
            }
        }
    }
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateInterfaceImpl()

//*****************************************************************************
// Validate the given MemberRef.
//*****************************************************************************
HRESULT RegMeta::ValidateMemberRef(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    MemberRefRec *pRecord;              // MemberRef record.
    mdMemberRef tkMemberRef;            // Duplicate MemberRef.
    mdToken     tkClass;                // MemberRef parent.
    LPCSTR      szName;                 // MemberRef name.
    PCCOR_SIGNATURE pbSig;              // MemberRef signature.
    PCCOR_SIGNATURE pbSigTmp;           // Temp copy of pbSig, so that can be changed.
    ULONG       cbSig;                  // Size of sig in bytes.
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    VARIANT     rVar[2];                // VARIANT array.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.

    // Get the MemberRef record.
    veCtxt.Token = TokenFromRid(rid, mdtMemberRef);
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getMemberRef(rid);

    // Do checks for name validity.
    szName = pMiniMd->getNameOfMemberRef(pRecord);
    if (!*szName)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MR_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else 
    {
        if (IsVtblGapName(szName))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MR_VTBLNAME, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else if (IsDeletedName(szName))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MR_DELNAME, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        ULONG L = (ULONG)strlen(szName);
        if(L >= MAX_CLASSNAME_LENGTH)
        {
            // Name too long
            IfFailGo(_ValidateErrorHelper(L, (ULONG)(MAX_CLASSNAME_LENGTH-1), rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NAMETOOLONG, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    // MemberRef parent should never be nil in a PE file.
    tkClass = pMiniMd->getClassOfMemberRef(pRecord);
    if (m_ModuleType == ValidatorModuleTypePE && IsNilToken(tkClass))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MR_PARNIL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Verify that the signature is a valid signature as per signature spec.
    pbSig = pMiniMd->getSignatureOfMemberRef(pRecord, &cbSig);

    // Do some semantic checks based on the signature.
    if (hr == S_OK)
    {
        ULONG   ulCallingConv;
        ULONG   ulArgCount;
        ULONG   ulCurByte = 0;

        // Extract calling convention.
        pbSigTmp = pbSig;
        ulCurByte += CorSigUncompressedDataSize(pbSigTmp);
        ulCallingConv = CorSigUncompressData(pbSigTmp);
        // Get the argument count.
        ulCurByte += CorSigUncompressedDataSize(pbSigTmp);
        ulArgCount = CorSigUncompressData(pbSigTmp);

        // Calling convention must be one of IMAGE_CEE_CS_CALLCONV_DEFAULT,
        // IMAGE_CEE_CS_CALLCONV_VARARG or IMAGE_CEE_CS_CALLCONV_FIELD.
        if (!isCallConv(ulCallingConv, IMAGE_CEE_CS_CALLCONV_DEFAULT) &&
            !isCallConv(ulCallingConv, IMAGE_CEE_CS_CALLCONV_VARARG) &&
            !isCallConv(ulCallingConv, IMAGE_CEE_CS_CALLCONV_FIELD))
        {
            IfFailGo(_ValidateErrorHelper(ulCallingConv, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MR_BADCALLINGCONV, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // [CLS] Calling convention must not be VARARG
        if(isCallConv(ulCallingConv, IMAGE_CEE_CS_CALLCONV_VARARG))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MR_VARARGCALLINGCONV, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_WRN);
        }

        // If the parent is a MethodDef...
        if (TypeFromToken(tkClass) == mdtMethodDef)
        {
            if (!isCallConv(ulCallingConv, IMAGE_CEE_CS_CALLCONV_VARARG))
            {
                IfFailGo(_ValidateErrorHelper(tkClass, ulCallingConv, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MR_NOTVARARG, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            else if (RidFromToken(tkClass))
            {
                // The MethodDef must be the same name and the fixed part of the
                // vararg signature must be the same.
                MethodRec   *pRecord;           // Method Record.
                LPCSTR      szMethodName;       // Method name.
                PCCOR_SIGNATURE pbMethodSig;    // Method signature.
                ULONG       cbMethodSig;        // Size in bytes of signature.
                CQuickBytes qbFixedSig;         // Quick bytes to hold the fixed part of the variable signature.
                ULONG       cbFixedSig;         // Size in bytes of the fixed part.

                // Get Method record, name and signature.
                pRecord = pMiniMd->getMethod(RidFromToken(tkClass));
                szMethodName = pMiniMd->getNameOfMethod(pRecord);
                pbMethodSig = pMiniMd->getSignatureOfMethod(pRecord, &cbMethodSig);

                // Verify that the name of the Method is the same as the MemberRef.
                if (strcmp(szName, szMethodName))
                {
                    IfFailGo(_ValidateErrorHelper(tkClass, &var, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MR_NAMEDIFF, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }

                // Get the fixed part of the vararg signature of the MemberRef.
                hr = _GetFixedSigOfVarArg(pbSig, cbSig, &qbFixedSig, &cbFixedSig);
                if (FAILED(hr) || cbFixedSig != cbMethodSig ||
                    memcmp(pbMethodSig, qbFixedSig.Ptr(), cbFixedSig))
                {
                    hr = S_OK;
                    IfFailGo(_ValidateErrorHelper(tkClass, &var, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MR_SIGDIFF, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }
        }

        // There should be no duplicate MemberRefs.
        if (*szName && pbSig && cbSig)
        {
            hr = ImportHelper::FindMemberRef(pMiniMd, tkClass, szName, pbSig,
                                             cbSig, &tkMemberRef, rid);
            if (hr == S_OK)
            {
                IfFailGo(_ValidateErrorHelper(tkMemberRef, &var, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MR_DUP, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_WRN);
            }
            else if (hr == CLDB_E_RECORD_NOTFOUND)
                hr = S_OK;
            else
                IfFailGo(hr);
        }

        if(!isCallConv(ulCallingConv, IMAGE_CEE_CS_CALLCONV_FIELD))
        {
            hr = ValidateMethodSig(veCtxt.Token,pbSig, cbSig,0);
            SetVldtrCode(&hrSave,hr);
        }
    }
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateMemberRef()

//*****************************************************************************
// Validate the given Constant.
//*****************************************************************************
HRESULT RegMeta::ValidateConstant(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    ConstantRec *pRecord;              // Constant record.
    mdToken     tkParent;              // Constant parent.
    const BYTE* pbBlob;                 // Constant value blob ptr
    DWORD       cbBlob;                 // Constant value blob size
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.

    // Get the MemberRef record.
    veCtxt.Token = rid;
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getConstant(rid);
    pbBlob = pMiniMd->getValueOfConstant(pRecord,&cbBlob);
    switch(pRecord->m_Type)
    {
        case ELEMENT_TYPE_BOOLEAN:
        case ELEMENT_TYPE_CHAR:
        case ELEMENT_TYPE_I1:
        case ELEMENT_TYPE_U1:
        case ELEMENT_TYPE_I2:
        case ELEMENT_TYPE_U2:
        case ELEMENT_TYPE_I4:
        case ELEMENT_TYPE_U4:
        case ELEMENT_TYPE_R4:
        case ELEMENT_TYPE_I8:
        case ELEMENT_TYPE_U8:
        case ELEMENT_TYPE_R8:
            if(pbBlob == NULL)
            {
                IfFailGo(_ValidateErrorHelper(pRecord->m_Type, &var, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CN_BLOBNULL, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
        case ELEMENT_TYPE_STRING:
            break;

        case ELEMENT_TYPE_CLASS:
            if(*((IUnknown**)pbBlob))
            {
                IfFailGo(_ValidateErrorHelper(pRecord->m_Type, &var, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CN_BLOBNOTNULL, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            break;

        default:
            IfFailGo(_ValidateErrorHelper(pRecord->m_Type, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CN_BADTYPE, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
            break;
    }
    tkParent = pMiniMd->getParentOfConstant(pRecord);
    ULONG maxrid;
    ULONG typ = TypeFromToken(tkParent);
    switch(typ)
    {
        case mdtFieldDef:
            maxrid = pMiniMd->getCountFields();
            break;
        case mdtParamDef:
            maxrid = pMiniMd->getCountParams();
            break;
        case mdtProperty:
            maxrid = pMiniMd->getCountPropertys();
            break;
    }
    switch(typ)
    {
        case mdtFieldDef:
        case mdtParamDef:
        case mdtProperty:
            {
                ULONG rid_p = RidFromToken(tkParent);
                if((0==rid_p)||(rid_p > maxrid))
                {
                    IfFailGo(_ValidateErrorHelper(tkParent, &var, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CN_PARENTRANGE, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_WRN);
                }
                break;
            }

        default:
            IfFailGo(_ValidateErrorHelper(tkParent, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CN_PARENTTYPE, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_WRN);
            break;
    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateConstant()

//*****************************************************************************
// Validate the given CustomAttribute.
//*****************************************************************************
HRESULT RegMeta::ValidateCustomAttribute(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    CustomAttributeRec* pRecord = pMiniMd->getCustomAttribute(rid);
    veCtxt.Token = TokenFromRid(rid,mdtCustomAttribute);
    veCtxt.uOffset = 0;
    if(pRecord)
    {
        mdToken     tkOwner = pMiniMd->getParentOfCustomAttribute(pRecord);
        if(RidFromToken(tkOwner))
        { // if 0, it's deleted CA, don't pay attention
            mdToken     tkCAType = pMiniMd->getTypeOfCustomAttribute(pRecord);
            DWORD       cbValue=0;
            BYTE*       pValue = (BYTE*)(pMiniMd->getValueOfCustomAttribute(pRecord,&cbValue));
            if((TypeFromToken(tkOwner)==mdtCustomAttribute)||(!IsValidToken(tkOwner)))
            {
                IfFailGo(_ValidateErrorHelper(tkOwner, &var, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CA_BADPARENT, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            if(((TypeFromToken(tkCAType)!=mdtMethodDef)&&(TypeFromToken(tkCAType)!=mdtMemberRef))
                ||(!IsValidToken(tkCAType))||(RidFromToken(tkCAType)==0))
            {
                IfFailGo(_ValidateErrorHelper(tkCAType, &var, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CA_BADTYPE, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            else
            { //i.e. Type is valid MethodDef or MemberRef
                LPCUTF8 szName;
                PCOR_SIGNATURE  pSig=NULL;
                DWORD           cbSig=0;
                DWORD           dwFlags=0;
                if(TypeFromToken(tkCAType)==mdtMethodDef)
                {
                    MethodRec*  pTypeRec = pMiniMd->getMethod(RidFromToken(tkCAType));
                    szName = pMiniMd->getNameOfMethod(pTypeRec);
                    pSig = (PCOR_SIGNATURE)(pMiniMd->getSignatureOfMethod(pTypeRec,&cbSig));
                    dwFlags = pTypeRec->m_Flags;
                }
                else // it can be only MemberRef, otherwise we wouldn't be here
                {
                    MemberRefRec*   pTypeRec = pMiniMd->getMemberRef(RidFromToken(tkCAType));
                    szName = pMiniMd->getNameOfMemberRef(pTypeRec);
                    pSig = (PCOR_SIGNATURE)(pMiniMd->getSignatureOfMemberRef(pTypeRec,&cbSig));
                }
                if(strcmp(szName, ".ctor"))
                {
                    IfFailGo(_ValidateErrorHelper(tkCAType, &var, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CA_NOTCTOR, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                if(cbSig && pSig)
                {
                    if(FAILED(ValidateMethodSig(tkCAType, pSig,cbSig,dwFlags))
                        || (!((*pSig) & IMAGE_CEE_CS_CALLCONV_HASTHIS)))
                    {
                        IfFailGo(_ValidateErrorHelper(tkCAType, &var, &psa));
                        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CA_BADSIG, veCtxt, psa));
                        SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    }
                    else
                    { // sig seems to be OK
                        if(pValue && cbValue)
                        {
                            // Check if prolog is OK
                            WORD* pW = (WORD*)pValue;
                            if(*pW != 0x0001)
                            {
                                IfFailGo(_ValidateErrorHelper(*pW, &var, &psa));
                                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CA_BADPROLOG, veCtxt, psa));
                                SetVldtrCode(&hrSave, VLDTR_S_ERR);
                            }
                            // Check if blob corresponds to the signature
                        }
                    }

                }
                else
                {
                    IfFailGo(_ValidateErrorHelper(tkCAType, &var, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CA_NOSIG, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            } // end if bad Type - else
        } // end if RidFromToken(tkOwner)
    } // end if pRecord

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateCustomAttribute()

//*****************************************************************************
// Validate the given FieldMarshal.
//*****************************************************************************
HRESULT RegMeta::ValidateFieldMarshal(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateFieldMarshal()

//*****************************************************************************
// Validate the given DeclSecurity.
//*****************************************************************************
HRESULT RegMeta::ValidateDeclSecurity(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    DeclSecurityRec* pRecord = pMiniMd->getDeclSecurity(rid);
    mdToken     tkOwner;                // Owner of the decl security
    DWORD       dwAction;               // action flags
    BOOL        bIsValidOwner = FALSE;

    veCtxt.Token = TokenFromRid(rid,mdtPermission);
    veCtxt.uOffset = 0;

    // Must have a valid owner
    tkOwner = pMiniMd->getParentOfDeclSecurity(pRecord);
    if(RidFromToken(tkOwner)==0) goto ErrExit; // deleted record, no need to validate
    switch(TypeFromToken(tkOwner))
    {
        case mdtModule:
        case mdtAssembly:
        case mdtTypeDef:
        case mdtMethodDef:
        case mdtFieldDef:
        case mdtInterfaceImpl:
            bIsValidOwner = _IsValidToken(tkOwner);
            break;
        default:
            break;
    }
    if(!bIsValidOwner)
    {
        IfFailGo(_ValidateErrorHelper(tkOwner, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_DS_BADOWNER, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Must have one and only one flag set
    dwAction = pRecord->m_Action & dclActionMask;
    if(dwAction > dclMaximumValue) // the flags are 0,1,2,3,...,dclMaximumValue
    {
        IfFailGo(_ValidateErrorHelper(dwAction, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_DS_BADFLAGS, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Must have valid permission blob
    /* -- no, not really
    
    void const  *pvPermission;        // permission blob.
    ULONG       cbPermission;         // count of bytes of pvPermission.

    pvPermission = pMiniMd->getPermissionSetOfDeclSecurity(pRecord, &cbPermission);
    if((pvPermission==NULL)||(cbPermission==0))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_DS_NOBLOB, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    */
    // If field has DeclSecurity, verify its parent is not an interface.-- checked in ValidateField
    // If method has DeclSecurity, verify its parent is not an interface.-- checked in ValidateMethod
    
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateDeclSecurity()

//*****************************************************************************
// Validate the given ClassLayout.
//*****************************************************************************
HRESULT RegMeta::ValidateClassLayout(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    ClassLayoutRec *pRecord;            // ClassLayout record.
    TypeDefRec  *pTypeDefRec;           // Parent TypeDef record.
    DWORD       dwPackingSize;          // Packing size.
    mdTypeDef   tkParent;               // Parent TypeDef token.
    DWORD       dwTypeDefFlags;         // Parent TypeDef flags.
    RID         clRid;                  // Duplicate ClassLayout rid.
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    VARIANT     rVar[2];                // VARIANT array.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.

    // Extract the record.
    veCtxt.Token = rid;
    veCtxt.uOffset = 0;
    pRecord = pMiniMd->getClassLayout(rid);

    // Get the parent, if parent is nil its a deleted record.  Skip validation.
    tkParent = pMiniMd->getParentOfClassLayout(pRecord);
    if (IsNilToken(tkParent))
        goto ErrExit;

    // Parent should not have AutoLayout set on it.
    pTypeDefRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
    dwTypeDefFlags = pMiniMd->getFlagsOfTypeDef(pTypeDefRec);
    if (IsTdAutoLayout(dwTypeDefFlags))
    {
        IfFailGo(_ValidateErrorHelper(tkParent, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CL_TDAUTO, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Parent must not be an Interface
    if(IsTdInterface(dwTypeDefFlags))
    {
        IfFailGo(_ValidateErrorHelper(tkParent, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CL_TDINTF, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Validate the PackingSize.
    dwPackingSize = pMiniMd->getPackingSizeOfClassLayout(pRecord);
    if((dwPackingSize > 128)||((dwPackingSize & (dwPackingSize-1)) !=0 ))
    {
        IfFailGo(_ValidateErrorHelper(tkParent, dwPackingSize, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CL_BADPCKSZ, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Validate that there are no duplicates.
    hr = _FindClassLayout(pMiniMd, tkParent, &clRid, rid);
    if (hr == S_OK)
    {
        IfFailGo(_ValidateErrorHelper(tkParent, clRid, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CL_DUP, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else if (hr == CLDB_E_RECORD_NOTFOUND)
        hr = S_OK;
    else
        IfFailGo(hr);
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateClassLayout()

//*****************************************************************************
// Validate the given FieldLayout.
//*****************************************************************************
HRESULT RegMeta::ValidateFieldLayout(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    FieldLayoutRec *pRecord;            // FieldLayout record.
    mdFieldDef  tkField;                // Field token.
    ULONG       ulOffset;               // Field offset.
    FieldRec    *pFieldRec;             // Field record.
    TypeDefRec  *pTypeDefRec;           // Parent TypeDef record.
    mdTypeDef   tkTypeDef;              // Parent TypeDef token.
    RID         clRid;                  // Corresponding ClassLayout token.
    RID         flRid;                  // Duplicate FieldLayout rid.
    DWORD       dwTypeDefFlags;         // Parent TypeDef flags.
    DWORD       dwFieldFlags;           // Field flags.
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    VARIANT     rVar[2];                // VARIANT array.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.

    // Extract the record.
    veCtxt.Token = rid;
    veCtxt.uOffset = 0;
    pRecord = pMiniMd->getFieldLayout(rid);

    // Get the field, if its nil its a deleted record, so just skip it.
    tkField = pMiniMd->getFieldOfFieldLayout(pRecord);
    if (IsNilToken(tkField))
        goto ErrExit;

    // Validate the Offset value.
    ulOffset = pMiniMd->getOffSetOfFieldLayout(pRecord);
    if (ulOffset == ULONG_MAX)
    {
        IfFailGo(_ValidateErrorHelper(tkField, ulOffset, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FL_BADOFFSET, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Get the parent of the Field.
    IfFailGo(pMiniMd->FindParentOfFieldHelper(tkField, &tkTypeDef));
    // Validate that the parent is not nil.
    if (IsNilToken(tkTypeDef))
    {
        IfFailGo(_ValidateErrorHelper(tkField, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FL_TDNIL, veCtxt, psa));
        SetVldtrCode(&hr, hrSave);
        goto ErrExit;
    }

    // Validate that there exists a ClassLayout record associated with
    // this TypeDef.
    clRid = pMiniMd->FindClassLayoutHelper(tkTypeDef);
    if (InvalidRid(rid))
    {
        IfFailGo(_ValidateErrorHelper(tkField, tkTypeDef, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FL_NOCL, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Validate that ExplicitLayout is set on the TypeDef flags.
    pTypeDefRec = pMiniMd->getTypeDef(RidFromToken(tkTypeDef));
    dwTypeDefFlags = pMiniMd->getFlagsOfTypeDef(pTypeDefRec);
    if (IsTdAutoLayout(dwTypeDefFlags))
    {
        IfFailGo(_ValidateErrorHelper(tkField, tkTypeDef, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FL_TDNOTEXPLCT, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Extract Field record.
    pFieldRec = pMiniMd->getField(RidFromToken(tkField));
    // Validate that the field is non-static.
    dwFieldFlags = pMiniMd->getFlagsOfField(pFieldRec);
    if (IsFdStatic(dwFieldFlags))
    {
        IfFailGo(_ValidateErrorHelper(tkField, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FL_FLDSTATIC, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    
    // Look for duplicates.
    hr = _FindFieldLayout(pMiniMd, tkField, &flRid, rid);
    if (hr == S_OK)
    {
        IfFailGo(_ValidateErrorHelper(flRid, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FL_DUP, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else if (hr == CLDB_E_RECORD_NOTFOUND)
        hr = S_OK;
    else
        IfFailGo(hr);
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateFieldLayout()

//*****************************************************************************
// Validate the given StandAloneSig.
//*****************************************************************************
HRESULT RegMeta::ValidateStandAloneSig(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    StandAloneSigRec *pRecord;          // FieldLayout record.
    PCCOR_SIGNATURE pbSig;              // Signature.
    ULONG       cbSig;                  // Size in bytes of the signature.
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    ULONG       ulCurByte = 0;          // Current index into the signature.
    ULONG       ulCallConv;             // Calling convention.
    ULONG       ulArgCount;             // Count of arguments.
    ULONG       i;                      // Looping index.
    ULONG       ulNSentinels = 0;       // Number of sentinels in the signature
    BOOL        bNoVoidAllowed=TRUE;

    // Extract the record.
    veCtxt.Token = TokenFromRid(rid,mdtSignature);
    veCtxt.uOffset = 0;
    pRecord = pMiniMd->getStandAloneSig(rid);
    pbSig = pMiniMd->getSignatureOfStandAloneSig( pRecord, &cbSig );

    // Validate the signature is well-formed with respect to the compression
    // scheme.  If this fails, no further validation needs to be done.
    if ( (hr = ValidateSigCompression(veCtxt.Token, pbSig, cbSig)) != S_OK)
        goto ErrExit;

    //_ASSERTE((rid != 0x2c2)&&(rid!=0x2c8)&&(rid!=0x2c9)&&(rid!=0x2d6)&&(rid!=0x38b));
    // Validate the calling convention.
    ulCurByte += CorSigUncompressedDataSize(pbSig);
    ulCallConv = CorSigUncompressData(pbSig);
    i = ulCallConv & IMAGE_CEE_CS_CALLCONV_MASK;
    if(i == IMAGE_CEE_CS_CALLCONV_FIELD) // it's a temporary bypass (VB bug)
        ulArgCount = 1;
    else 
    {
        if(i != IMAGE_CEE_CS_CALLCONV_LOCAL_SIG) // then it is function sig for calli
        {
            if((i >= IMAGE_CEE_CS_CALLCONV_FIELD) 
                ||((ulCallConv & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS)
                &&(!(ulCallConv & IMAGE_CEE_CS_CALLCONV_HASTHIS))))
            {
                IfFailGo(_ValidateErrorHelper(ulCallConv, &var, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_BADCALLINGCONV, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            bNoVoidAllowed = FALSE;
        }
        // Is there any sig left for arguments?
        _ASSERTE(ulCurByte <= cbSig);
        if (cbSig == ulCurByte)
        {
            IfFailGo(_ValidateErrorHelper(ulCurByte+1, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_NOARGCNT, veCtxt, psa));
            SetVldtrCode(&hr, hrSave);
            goto ErrExit;
        }

        // Get the argument count.
        ulCurByte += CorSigUncompressedDataSize(pbSig);
        ulArgCount = CorSigUncompressData(pbSig);
    }
    // Validate the the arguments.
    if(ulArgCount)
    {
        for(i=1; ulCurByte < cbSig; i++)
        {
            hr = ValidateOneArg(veCtxt.Token, pbSig, cbSig, &ulCurByte,&ulNSentinels,bNoVoidAllowed);
            if (hr != S_OK)
            {
                if(hr == VLDTR_E_SIG_MISSARG)
                {
                    IfFailGo(_ValidateErrorHelper(i, &var, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSARG, veCtxt, psa));
                }
                SetVldtrCode(&hr, hrSave);
                hrSave = hr;
                break;
            }
            bNoVoidAllowed = TRUE; // whatever it was for the 1st arg, it must be TRUE for the rest
        }
        if((ulNSentinels != 0) && (!isCallConv(ulCallConv, IMAGE_CEE_CS_CALLCONV_VARARG )))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_SENTMUSTVARARG, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        if(ulNSentinels > 1)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MULTSENTINELS, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateStandAloneSig()

//*****************************************************************************
// Validate the given EventMap.
//*****************************************************************************
HRESULT RegMeta::ValidateEventMap(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateEventMap()

//*****************************************************************************
// Validate the given EventPtr.
//*****************************************************************************
HRESULT RegMeta::ValidateEventPtr(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateEventPtr()

//*****************************************************************************
// Validate the given Event.
//*****************************************************************************
HRESULT RegMeta::ValidateEvent(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd of the scope.
    VEContext   veCtxt;                 // Context record.
    VARIANT     rVar[2];                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    mdToken     tkClass;                // Declaring TypeDef
    mdToken     tkEventType;            // Event Type (TypeDef/TypeRef)
    EventRec*   pRecord = pMiniMd->getEvent(rid);
    HENUMInternal hEnum;

    memset(&hEnum, 0, sizeof(HENUMInternal));
    veCtxt.Token = TokenFromRid(rid,mdtEvent);
    veCtxt.uOffset = 0;

    // The scope must be a valid TypeDef
    pMiniMd->FindParentOfEventHelper( veCtxt.Token, &tkClass);
    if((TypeFromToken(tkClass) != mdtTypeDef) || !_IsValidToken(tkClass))
    {
        IfFailGo(_ValidateErrorHelper(tkClass, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_BADSCOPE, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
        tkClass = 0;
    }
    // Must have name
    {
        LPCUTF8             szName = pMiniMd->getNameOfEvent(pRecord);

        if(*szName == 0)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_NONAME, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else
        {
            if(!strcmp(szName,COR_DELETED_NAME_A)) goto ErrExit; 
            if(tkClass)    // Must be no duplicates
            {
                RID             ridEventMap;
                EventMapRec*    pEventMapRec;
                EventRec*       pRec;
                ULONG           ridStart;
                ULONG           ridEnd;
                ULONG           i;

                ridEventMap = pMiniMd->FindEventMapFor( RidFromToken(tkClass) );
                if ( !InvalidRid(ridEventMap) )
                {
                    pEventMapRec = pMiniMd->getEventMap( ridEventMap );
                    ridStart = pMiniMd->getEventListOfEventMap( pEventMapRec );
                    ridEnd = pMiniMd->getEndEventListOfEventMap( pEventMapRec );

                    for (i = ridStart; i < ridEnd; i++)
                    {
                        if(i == rid) continue;
                        pRec = pMiniMd->getEvent(i);
                        if(szName != pMiniMd->getNameOfEvent(pRec)) continue; // strings in the heap are never duplicate
                        IfFailGo(_ValidateErrorHelper(TokenFromRid(i,mdtEvent), rVar, &psa));
                        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_DUP, veCtxt, psa));
                        SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    }
                }
            }
        }
    }// end of name block
    // EventType must be Nil or valid TypeDef or TypeRef
    tkEventType = pMiniMd->getEventTypeOfEvent(pRecord);
    if(!IsNilToken(tkEventType))
    {
        if(_IsValidToken(tkEventType) && 
            ((TypeFromToken(tkEventType)==mdtTypeDef)||(TypeFromToken(tkEventType)==mdtTypeRef)))
        {
            // EventType must not be Interface or ValueType
            if(TypeFromToken(tkEventType)==mdtTypeDef) // can't say anything about TypeRef: no flags available!
            {
                DWORD dwFlags = pMiniMd->getTypeDef(RidFromToken(tkEventType))->m_Flags;
                if(!IsTdClass(dwFlags))
                {
                    IfFailGo(_ValidateErrorHelper(tkEventType, dwFlags, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_EVTYPENOTCLASS, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }
        }
        else
        {
            IfFailGo(_ValidateErrorHelper(tkEventType, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_BADEVTYPE, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    // Validate related methods
    {
        MethodSemanticsRec *pSemantics;
        RID         ridCur;
        ULONG       ulSemantics;
        mdMethodDef tkMethod;
        bool        bHasAddOn = false;
        bool        bHasRemoveOn = false;

        IfFailGo( pMiniMd->FindMethodSemanticsHelper(veCtxt.Token, &hEnum) );
        while (HENUMInternal::EnumNext(&hEnum, (mdToken *)&ridCur))
        {
            pSemantics = pMiniMd->getMethodSemantics(ridCur);
            ulSemantics = pMiniMd->getSemanticOfMethodSemantics(pSemantics);
            tkMethod = TokenFromRid( pMiniMd->getMethodOfMethodSemantics(pSemantics), mdtMethodDef );
            // Semantics must be Setter, Getter or Other
            switch (ulSemantics)
            {
                case msAddOn:
                    bHasAddOn = true;
                    break;
                case msRemoveOn:
                    bHasRemoveOn = true;
                    break;
                case msFire:
                    // must return void
                    if(_IsValidToken(tkMethod))
                    {
                        MethodRec* pRec = pMiniMd->getMethod(RidFromToken(tkMethod));
                        ULONG cbSig;
                        PCCOR_SIGNATURE pbSig = pMiniMd->getSignatureOfMethod(pRec, &cbSig);
                        CorSigUncompressData(pbSig); // get call conv out of the way
                        CorSigUncompressData(pbSig); // get num args out of the way
                        if(*pbSig != ELEMENT_TYPE_VOID)
                        {
                            IfFailGo(_ValidateErrorHelper(tkMethod, rVar, &psa));
                            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_FIRENOTVOID, veCtxt, psa));
                            SetVldtrCode(&hrSave, VLDTR_S_ERR);
                        }
                    }
                case msOther:
                    break;
                default:
                    IfFailGo(_ValidateErrorHelper(tkMethod,ulSemantics, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_BADSEMANTICS, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            // Method must be valid
            if(!_IsValidToken(tkMethod))
            {
                IfFailGo(_ValidateErrorHelper(tkMethod,rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_BADMETHOD, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            else
            {
                // Method's parent must be the same
                mdToken tkTypeDef;
                IfFailGo(pMiniMd->FindParentOfMethodHelper(tkMethod, &tkTypeDef));
                if(tkTypeDef != tkClass)
                {
                    IfFailGo(_ValidateErrorHelper(tkMethod,tkTypeDef,rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_ALIENMETHOD, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }
        } // end loop over methods
        // AddOn and RemoveOn are a must
        if(!bHasAddOn)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_NOADDON, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        if(!bHasRemoveOn)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_EV_NOREMOVEON, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }// end of related method validation block
    
    hr = hrSave;
ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateEvent()

//*****************************************************************************
// Validate the given PropertyMap.
//*****************************************************************************
HRESULT RegMeta::ValidatePropertyMap(RID rid)
{
    return S_OK;
}   // RegMeta::ValidatePropertyMap(0

//*****************************************************************************
// Validate the given PropertyPtr.
//*****************************************************************************
HRESULT RegMeta::ValidatePropertyPtr(RID rid)
{
    return S_OK;
}   // RegMeta::ValidatePropertyPtr()

//*****************************************************************************
// Validate the given Property.
//*****************************************************************************
HRESULT RegMeta::ValidateProperty(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    VEContext   veCtxt;                 // Context record.
    VARIANT     rVar[2];                // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    mdToken     tkClass = mdTokenNil;   // Declaring TypeDef
    PropertyRec* pRecord = pMiniMd->getProperty(rid);
    HENUMInternal hEnum;

    memset(&hEnum, 0, sizeof(HENUMInternal));
    veCtxt.Token = TokenFromRid(rid,mdtProperty);
    veCtxt.uOffset = 0;
    // The scope must be a valid TypeDef
    pMiniMd->FindParentOfPropertyHelper( veCtxt.Token, &tkClass);
    if((TypeFromToken(tkClass) != mdtTypeDef) || !_IsValidToken(tkClass) || IsNilToken(tkClass))
    {
        IfFailGo(_ValidateErrorHelper(tkClass, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_PR_BADSCOPE, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Must have name and signature
    {
        ULONG               cbSig;
        PCCOR_SIGNATURE     pvSig = pMiniMd->getTypeOfProperty(pRecord, &cbSig);
        LPCUTF8             szName = pMiniMd->getNameOfProperty(pRecord);
        ULONG               ulNameLen = szName ? strlen(szName) : 0;

        if(ulNameLen == 0)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_PR_NONAME, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else    if(!strcmp(szName,COR_DELETED_NAME_A)) goto ErrExit; 
        if(cbSig == 0)
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_PR_NOSIG, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Must be no duplicates
        if(ulNameLen && cbSig)
        {
            RID         ridPropertyMap;
            PropertyMapRec *pPropertyMapRec;
            PropertyRec*    pRec;
            ULONG           ridStart;
            ULONG           ridEnd;
            ULONG           i;
            ULONG               cbSig1;
            PCCOR_SIGNATURE     pvSig1;

            ridPropertyMap = pMiniMd->FindPropertyMapFor( RidFromToken(tkClass) );
            if ( !InvalidRid(ridPropertyMap) )
            {
                pPropertyMapRec = pMiniMd->getPropertyMap( ridPropertyMap );
                ridStart = pMiniMd->getPropertyListOfPropertyMap( pPropertyMapRec );
                ridEnd = pMiniMd->getEndPropertyListOfPropertyMap( pPropertyMapRec );

                for (i = ridStart; i < ridEnd; i++)
                {
                    if(i == rid) continue;
                    pRec = pMiniMd->getProperty(i);
                    pvSig1 = pMiniMd->getTypeOfProperty(pRec, &cbSig1);
                    if(cbSig != cbSig1) continue;
                    if(memcmp(pvSig,pvSig1,cbSig)) continue;
                    if(szName != pMiniMd->getNameOfProperty(pRec)) continue; // strings in the heap are never duplicate
                    IfFailGo(_ValidateErrorHelper(TokenFromRid(i,mdtProperty), rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_PR_DUP, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }
        }
        // Validate the signature
        if(pvSig && cbSig)
        {
            ULONG       ulCurByte = 0;          // Current index into the signature.
            ULONG       ulCallConv;             // Calling convention.
            ULONG       ulArgCount;
            ULONG       i;
            ULONG       ulNSentinels = 0;

            // Validate the calling convention.
            ulCurByte += CorSigUncompressedDataSize(pvSig);
            ulCallConv = CorSigUncompressData(pvSig);
            if (!isCallConv(ulCallConv, IMAGE_CEE_CS_CALLCONV_PROPERTY ))
            {
                IfFailGo(_ValidateErrorHelper(ulCallConv, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_PR_BADCALLINGCONV, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            // Get the argument count.
            ulCurByte += CorSigUncompressedDataSize(pvSig);
            ulArgCount = CorSigUncompressData(pvSig);

            // Validate the arguments.
            for (i = 0; i < ulArgCount; i++)
            {
                hr = ValidateOneArg(veCtxt.Token, pvSig, cbSig, &ulCurByte,&ulNSentinels,(i>0));
                if (hr != S_OK)
                {
                    if(hr == VLDTR_E_SIG_MISSARG)
                    {
                        IfFailGo(_ValidateErrorHelper(i+1, rVar, &psa));
                        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSARG, veCtxt, psa));
                    }
                    SetVldtrCode(&hr, hrSave);
                    break;
                }
            }
        }//end if(pvSig && cbSig)
    }// end of name/signature block

    // Marked HasDefault <=> has default value
    if (InvalidRid(pMiniMd->FindConstantHelper(veCtxt.Token)) == IsPrHasDefault(pRecord->m_PropFlags))
    {
        IfBreakGo(m_pVEHandler->VEHandler(IsPrHasDefault(pRecord->m_PropFlags)? VLDTR_E_PR_MARKEDNODEFLT
            : VLDTR_E_PR_DEFLTNOTMARKED, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Validate related methods
    {
        MethodSemanticsRec *pSemantics;
        RID         ridCur;
        ULONG       ulSemantics;
        mdMethodDef tkMethod;

        IfFailGo( pMiniMd->FindMethodSemanticsHelper(veCtxt.Token, &hEnum) );
        while (HENUMInternal::EnumNext(&hEnum, (mdToken *) &ridCur))
        {
            pSemantics = pMiniMd->getMethodSemantics(ridCur);
            ulSemantics = pMiniMd->getSemanticOfMethodSemantics(pSemantics);
            tkMethod = TokenFromRid( pMiniMd->getMethodOfMethodSemantics(pSemantics), mdtMethodDef );
            // Semantics must be Setter, Getter or Other
            switch (ulSemantics)
            {
                case msSetter:
                case msGetter:
                case msOther:
                    break;
                default:
                    IfFailGo(_ValidateErrorHelper(tkMethod,ulSemantics, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_PR_BADSEMANTICS, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            // Method must be valid
            if(!_IsValidToken(tkMethod))
            {
                IfFailGo(_ValidateErrorHelper(tkMethod,rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_PR_BADMETHOD, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            else
            {
                // Method's parent must be the same
                mdToken tkTypeDef;
                IfFailGo(pMiniMd->FindParentOfMethodHelper(tkMethod, &tkTypeDef));
                if(tkTypeDef != tkClass)
                {
                    IfFailGo(_ValidateErrorHelper(tkMethod,tkTypeDef,rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_PR_ALIENMETHOD, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }
        } // end loop over methods
    }// end of related method validation block
    
    hr = hrSave;
ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateProperty()

//*****************************************************************************
// Validate the given MethodSemantics.
//*****************************************************************************
HRESULT RegMeta::ValidateMethodSemantics(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateMethodSemantics()

//*****************************************************************************
// Validate the given MethodImpl.
//*****************************************************************************
HRESULT RegMeta::ValidateMethodImpl(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    MethodImplRec* pRecord;
    MethodImplRec* pRec;
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    mdToken     tkClass;                // Declaring TypeDef
    mdToken     tkBody;                 // Implementing method (MethodDef or MemberRef)
    mdToken     tkDecl;                 // Implemented method (MethodDef or MemberRef)
    unsigned    iCount;
    unsigned    index;

    veCtxt.Token = rid;
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getMethodImpl(rid);
    tkClass = pMiniMd->getClassOfMethodImpl(pRecord);
    // Class must be valid
    if(!_IsValidToken(tkClass) || (TypeFromToken(tkClass) != mdtTypeDef))
    {
        IfFailGo(_ValidateErrorHelper(tkClass, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_BADCLASS, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else
    { // ... and not an Interface
        if(IsTdInterface((pMiniMd->getTypeDef(RidFromToken(tkClass)))->m_Flags))
        {
            IfFailGo(_ValidateErrorHelper(tkClass, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_CLASSISINTF, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    // Decl must be valid MethodDef or MemberRef
    tkDecl = pMiniMd->getMethodDeclarationOfMethodImpl(pRecord);
    if(!(_IsValidToken(tkDecl) &&
        ((TypeFromToken(tkDecl) == mdtMethodDef) || (TypeFromToken(tkDecl) == mdtMemberRef))))
    {
        IfFailGo(_ValidateErrorHelper(tkDecl, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_BADDECL, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Body must be valid MethodDef or MemberRef
    tkBody = pMiniMd->getMethodBodyOfMethodImpl(pRecord);
    if(!(_IsValidToken(tkBody) &&
        ((TypeFromToken(tkBody) == mdtMethodDef) || (TypeFromToken(tkBody) == mdtMemberRef))))
    {
        IfFailGo(_ValidateErrorHelper(tkBody, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_BADBODY, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // No duplicates based on (tkClass,tkDecl)
    iCount = pMiniMd->getCountMethodImpls();
    for(index = rid+1; index <= iCount; index++)
    {
        pRec = pMiniMd->getMethodImpl(index);
        if((tkClass == pMiniMd->getClassOfMethodImpl(pRec)) &&
            (tkDecl == pMiniMd->getMethodDeclarationOfMethodImpl(pRec)))
        {
            IfFailGo(_ValidateErrorHelper(index, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_DUP, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    mdToken tkBodyParent;
    ULONG               cbBodySig;
    PCCOR_SIGNATURE     pbBodySig;

    if(TypeFromToken(tkBody) == mdtMethodDef)
    {
        MethodRec* pBodyRec = pMiniMd->getMethod(RidFromToken(tkBody));
        pbBodySig = pMiniMd->getSignatureOfMethod(pBodyRec,&cbBodySig);
        IfFailGo(pMiniMd->FindParentOfMethodHelper(tkBody, &tkBodyParent));
        // Body must not be static
        if(IsMdStatic(pBodyRec->m_Flags))
        {
            IfFailGo(_ValidateErrorHelper(tkBody, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_BODYSTATIC, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    else if(TypeFromToken(tkBody) == mdtMemberRef)
    {
        MemberRefRec* pBodyRec = pMiniMd->getMemberRef(RidFromToken(tkBody));
        tkBodyParent = pMiniMd->getClassOfMemberRef(pBodyRec);
        pbBodySig = pMiniMd->getSignatureOfMemberRef(pBodyRec, &cbBodySig);
    }
    // Body must belong to the same class
    if(tkBodyParent != tkClass)
    {
        IfFailGo(_ValidateErrorHelper(tkBodyParent, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_ALIENBODY, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    ULONG               cbDeclSig;
    PCCOR_SIGNATURE     pbDeclSig;

    if(TypeFromToken(tkDecl) == mdtMethodDef)
    {
        MethodRec* pDeclRec = pMiniMd->getMethod(RidFromToken(tkDecl));
        pbDeclSig = pMiniMd->getSignatureOfMethod(pDeclRec,&cbDeclSig);
        // Decl must be virtual
        if(!IsMdVirtual(pDeclRec->m_Flags))
        {
            IfFailGo(_ValidateErrorHelper(tkDecl, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_DECLNOTVIRT, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Decl must not be final
        if(IsMdFinal(pDeclRec->m_Flags))
        {
            IfFailGo(_ValidateErrorHelper(tkDecl, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_DECLFINAL, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Decl must not be private
        if(IsMdPrivate(pDeclRec->m_Flags) && IsMdCheckAccessOnOverride(pDeclRec->m_Flags))
        {
            IfFailGo(_ValidateErrorHelper(tkDecl, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_DECLPRIV, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    else if(TypeFromToken(tkDecl) == mdtMemberRef)
    {
        MemberRefRec* pDeclRec = pMiniMd->getMemberRef(RidFromToken(tkDecl));
        pbDeclSig = pMiniMd->getSignatureOfMemberRef(pDeclRec, &cbDeclSig);
    }
    // Signatures must match (except call conv)
    if((cbDeclSig != cbBodySig)||(memcmp(pbDeclSig+1,pbBodySig+1,cbDeclSig-1)))
    {
        /*
          //@TODO: fix for Whidbey to have peverify resolve assemblies 
          // through the runtime. At that point, use this method instead
          // of the current compare
        // Can't use memcmp because there may be two AssemblyRefs
        // in this scope, pointing to the same assembly, etc.).
        if (!MetaSig::CompareMethodSigs(pbDeclSig,
                                        cbDeclSig,
                                        Module*     pModule1,
                                        pbBodySig,
                                        cbDeclSig,
                                        Module*     pModule2))
        */
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MI_SIGMISMATCH, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateMethodImpl()

//*****************************************************************************
// Validate the given ModuleRef.
//*****************************************************************************
HRESULT RegMeta::ValidateModuleRef(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    ModuleRefRec *pRecord;              // ModuleRef record.
    LPCUTF8     szName;                 // ModuleRef name.
    mdModuleRef tkModuleRef;            // Duplicate ModuleRef.
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.

    // Get the ModuleRef record.
    veCtxt.Token = TokenFromRid(rid, mdtModuleRef);
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getModuleRef(rid);

    // Check name is not NULL.
    szName = pMiniMd->getNameOfModuleRef(pRecord);
    if (!*szName)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MODREF_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else
    {
        // Look for a Duplicate, this function reports only one duplicate.
        hr = ImportHelper::FindModuleRef(pMiniMd, szName, &tkModuleRef, rid);
        if (hr == S_OK)
        {
            IfFailGo(_ValidateErrorHelper(tkModuleRef, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MODREF_DUP, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else if (hr == CLDB_E_RECORD_NOTFOUND)
            hr = S_OK;
        else
            IfFailGo(hr);
    }
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateModuleRef()

//*****************************************************************************
// Validate the given TypeSpec.
//*****************************************************************************
HRESULT RegMeta::ValidateTypeSpec(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateTypeSpec()

//*****************************************************************************
// Validate the given ImplMap.
//*****************************************************************************
HRESULT RegMeta::ValidateImplMap(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    ImplMapRec  *pRecord;
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    mdToken     tkModuleRef;
    mdToken     tkMember;
    LPCUTF8     szName;                 // Import name.
    USHORT      usFlags;


    for(unsigned jjj=0; jjj<g_nValidated; jjj++) 
    { 
        if(g_rValidated[jjj].tok == (rid | 0x51000000)) return g_rValidated[jjj].hr; 
    }
    veCtxt.Token = rid;
    veCtxt.uOffset = 0;
    pRecord = pMiniMd->getImplMap(rid);
    // ImplMap must have ModuleRef
    tkModuleRef = pMiniMd->getImportScopeOfImplMap(pRecord);
    if((TypeFromToken(tkModuleRef) != mdtModuleRef) || IsNilToken(tkModuleRef)
        || (S_OK != ValidateModuleRef(RidFromToken(tkModuleRef))))
    {
        IfFailGo(_ValidateErrorHelper(tkModuleRef, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_IMAP_BADMODREF, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // ImplMap must belong to FieldDef or MethodDef
    tkMember = pMiniMd->getMemberForwardedOfImplMap(pRecord);
    if((TypeFromToken(tkMember) != mdtFieldDef) && (TypeFromToken(tkMember) != mdtMethodDef))
    {
        IfFailGo(_ValidateErrorHelper(tkMember, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_IMAP_BADMEMBER, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // ImplMap must have import name
    szName = pMiniMd->getImportNameOfImplMap(pRecord);
    if((szName==NULL)||(*szName == 0))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_IMAP_BADIMPORTNAME, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // ImplMap must have valid flags:
        // one value of pmCharSetMask - always so, no check needed (values: 0,2,4,6, mask=6)
        // one value of pmCallConvMask...
        // ...and it's not pmCallConvThiscall
    usFlags = pRecord->m_MappingFlags & pmCallConvMask;
    if((usFlags < pmCallConvWinapi)||(usFlags > pmCallConvFastcall)||(usFlags == pmCallConvThiscall))
    {
        IfFailGo(_ValidateErrorHelper(usFlags, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_IMAP_BADCALLCONV, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
ErrExit:
    g_rValidated[g_nValidated].tok = rid | 0x51000000;
    g_rValidated[g_nValidated].hr = hrSave;
    g_nValidated++;
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateImplMap()

//*****************************************************************************
// Validate the given FieldRVA.
//*****************************************************************************
HRESULT RegMeta::ValidateFieldRVA(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    FieldRVARec  *pRecord;
    VEContext   veCtxt;                 // Context record.
    VARIANT     rVar[2];                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    mdToken     tkField;
    ULONG       ulRVA;

    veCtxt.Token = rid;
    veCtxt.uOffset = 0;
    pRecord = pMiniMd->getFieldRVA(rid);
    ulRVA = pRecord->m_RVA;
    tkField = pMiniMd->getFieldOfFieldRVA(pRecord);
    if(ulRVA == 0)
    {
        IfFailGo(_ValidateErrorHelper(tkField, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FRVA_ZERORVA, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    if((0==RidFromToken(tkField))||(TypeFromToken(tkField) != mdtFieldDef)||(!_IsValidToken(tkField)))
    {
        IfFailGo(_ValidateErrorHelper(tkField,ulRVA, rVar, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FRVA_BADFIELD, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    {
        RID N = pMiniMd->getCountFieldRVAs();
        RID tmp;
        FieldRVARec* pRecTmp;
        for(tmp = rid+1; tmp <= N; tmp++)
        { 
            pRecTmp = pMiniMd->getFieldRVA(tmp);
            /*
            if(pRecTmp->m_RVA == ulRVA)
            {
                IfFailGo(_ValidateErrorHelper(ulRVA,tmp, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FRVA_DUPRVA, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            */
            if(tkField == pMiniMd->getFieldOfFieldRVA(pRecTmp))
            {
                IfFailGo(_ValidateErrorHelper(tkField,tmp, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FRVA_DUPFIELD, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
        }
    }
    
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateFieldRVA()

//*****************************************************************************
// Validate the given ENCLog.
//*****************************************************************************
HRESULT RegMeta::ValidateENCLog(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateENCLog()

//*****************************************************************************
// Validate the given ENCMap.
//*****************************************************************************
HRESULT RegMeta::ValidateENCMap(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateENCMap()

//*****************************************************************************
// Validate the given Assembly.
//*****************************************************************************
HRESULT RegMeta::ValidateAssembly(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    AssemblyRec *pRecord;           // Assembly record.
    DWORD       dwFlags;            // Assembly flags.
    LPCSTR      szName;             // Assembly Name.
    VEContext   veCtxt;             // Context structure.
    HRESULT     hr = S_OK;          // Value returned.
    HRESULT     hrSave = S_OK;      // Save state.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.

    // Get the Assembly record.
    veCtxt.Token = TokenFromRid(rid, mdtAssembly);
    veCtxt.uOffset = 0;

    pRecord = pMiniMd->getAssembly(rid);

    // There can only be one Assembly record.
    if (rid > 1)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_AS_MULTI, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Do checks for name validity..
    szName = pMiniMd->getNameOfAssembly(pRecord);
    if (!*szName)
    {
        // Assembly Name is null.
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_AS_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else
    {
        unsigned L = (unsigned)strlen(szName);
        if((*szName==' ')||strchr(szName,':') || strchr(szName,'\\')
            || ((L > 4)&&((!_stricmp(&szName[L-4],".exe"))||(!_stricmp(&szName[L-4],".dll")))))
        {
            //Assembly name has path and/or extension
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_AS_BADNAME, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    // Get the flags value for the Assembly.
    dwFlags = pMiniMd->getFlagsOfAssembly(pRecord);

    // Validate the flags 
    if(dwFlags & (~(afPublicKey|afCompatibilityMask)) ||
           (((dwFlags & afCompatibilityMask) != afSideBySideCompatible) &&
            ((dwFlags & afCompatibilityMask) != afNonSideBySideAppDomain) &&
            ((dwFlags & afCompatibilityMask) != afNonSideBySideProcess) &&
            ((dwFlags & afCompatibilityMask) != afNonSideBySideMachine)))
    {
        IfFailGo(_ValidateErrorHelper(dwFlags, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_AS_BADFLAGS, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }


    // Validate hash algorithm ID
    switch(pRecord->m_HashAlgId)
    {
        case CALG_MD2:
        case CALG_MD4:
        case CALG_MD5:
        case CALG_SHA:
        //case CALG_SHA1: // same as CALG_SHA
        case CALG_MAC:
        case CALG_SSL3_SHAMD5:
        case CALG_HMAC:
        case 0:
            break;
        default:
            IfFailGo(_ValidateErrorHelper(pRecord->m_HashAlgId, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_AS_HASHALGID, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_WRN);
    }
    // Validate locale
    {
        LPCUTF8      szLocale = pMiniMd->getLocaleOfAssembly(pRecord);
        if(!_IsValidLocale(szLocale))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_AS_BADLOCALE, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_WRN);
        }
    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateAssembly()

//*****************************************************************************
// Validate the given AssemblyProcessor.
//*****************************************************************************
HRESULT RegMeta::ValidateAssemblyProcessor(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateAssemblyProcessor()

//*****************************************************************************
// Validate the given AssemblyOS.
//*****************************************************************************
HRESULT RegMeta::ValidateAssemblyOS(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateAssemblyOS()

//*****************************************************************************
// Validate the given AssemblyRef.
//*****************************************************************************
HRESULT RegMeta::ValidateAssemblyRef(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    AssemblyRefRec *pRecord;        // Assembly record.
    LPCSTR      szName;             // AssemblyRef Name.
    VEContext   veCtxt;             // Context structure.
    HRESULT     hr = S_OK;          // Value returned.
    HRESULT     hrSave = S_OK;      // Save state.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.

    veCtxt.Token = TokenFromRid(rid, mdtAssemblyRef);
    veCtxt.uOffset = 0;

    // Get the AssemblyRef record.
    pRecord = pMiniMd->getAssemblyRef(rid);

    // Do checks for name and alias validity.
    szName = pMiniMd->getNameOfAssemblyRef(pRecord);
    if (!*szName)
    {
        // AssemblyRef Name is null.
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_AR_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else
    {
        unsigned L = (unsigned)strlen(szName);
        if((*szName==' ')||strchr(szName,':') || strchr(szName,'\\')
            || ((L > 4)&&((!_stricmp(&szName[L-4],".exe"))||(!_stricmp(&szName[L-4],".dll")))))
        {
            //Assembly name has path and/or extension
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_AS_BADNAME, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    // Validate locale
    {
        LPCUTF8      szLocale = pMiniMd->getLocaleOfAssemblyRef(pRecord);
        if(!_IsValidLocale(szLocale))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_AS_BADLOCALE, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_WRN);
        }
    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateAssemblyRef()

//*****************************************************************************
// Validate the given AssemblyRefProcessor.
//*****************************************************************************
HRESULT RegMeta::ValidateAssemblyRefProcessor(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateAssemblyRefProcessor()

//*****************************************************************************
// Validate the given AssemblyRefOS.
//*****************************************************************************
HRESULT RegMeta::ValidateAssemblyRefOS(RID rid)
{
    return S_OK;
}   // RegMeta::ValidateAssemblyRefOS()

//*****************************************************************************
// Validate the given File.
//*****************************************************************************
HRESULT RegMeta::ValidateFile(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    FileRec     *pRecord;           // File record.
    mdFile      tkFile;             // Duplicate File token.
    LPCSTR      szName;             // File Name.
#if 0
    char        szDrive[_MAX_DRIVE];// Drive component of the file name.
    char        szDir[_MAX_DIR];    // Directory component of the file name.
    char        szFname[_MAX_FNAME];// Name component of the file name.
    char        szExt[_MAX_EXT];    // Extension of the file name.
#endif
    VEContext   veCtxt;             // Context structure.
    VARIANT     var;                // The VARIANT.
    VARIANT     rVar[2];            // The VARIANT.
    SAFEARRAY   *psa = 0;           // The SAFEARRAY.
    HRESULT     hr = S_OK;          // Value returned.
    HRESULT     hrSave = S_OK;      // Save state.

    veCtxt.Token = TokenFromRid(rid, mdtFile);
    veCtxt.uOffset = 0;

    // Get the File record.
    pRecord = pMiniMd->getFile(rid);

    // Do checks for name validity.
    szName = pMiniMd->getNameOfFile(pRecord);
    if (!*szName)
    {
        // File Name is null.
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FILE_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else
    {
        ULONG L = (ULONG)strlen(szName);
        if(L >= MAX_PATH)
        {
            // Name too long
            IfFailGo(_ValidateErrorHelper(L, (ULONG)(MAX_PATH-1), rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NAMETOOLONG, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Check for duplicates based on Name.
        hr = ImportHelper::FindFile(pMiniMd, szName, &tkFile, rid);
        if (hr == S_OK)
        {
            IfFailGo(_ValidateErrorHelper(tkFile, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FILE_DUP, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else if (hr == CLDB_E_RECORD_NOTFOUND)
            hr = S_OK;
        else
            IfFailGo(hr);

        // File name must not be fully qualified.
        if(strchr(szName,':') || strchr(szName,'\\'))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FILE_NAMEFULLQLFD, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // File name must not be one of system names.
        char *sysname[6]={"con","aux","lpt","prn","null","com"};
        char *syssymbol = "0123456789$:";
        for(unsigned i=0; i<6; i++)
        {
            L = (ULONG)strlen(sysname[i]);
            if(!_strnicmp(szName,sysname[i],L))
            {
                if((szName[L]==0)|| strchr(syssymbol,szName[L]))
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FILE_SYSNAME, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    break;
                }
            }
        }
    }

    if(pRecord->m_Flags & (~0x00000003))
    {
        IfFailGo(_ValidateErrorHelper(pRecord->m_Flags, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FILE_BADFLAGS, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Validate hash value
    {
        const void * pbHashValue = NULL;
        ULONG       cbHashValue;
        pbHashValue = m_pStgdb->m_MiniMd.getHashValueOfFile(pRecord, &cbHashValue);
        if((pbHashValue == NULL)||(cbHashValue == 0))
        {
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FILE_NULLHASH, veCtxt, 0));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    // Validate that the name is not the same as the file containing
    // the manifest.

    // File name must be a valid file name.

    // Each ModuleRef in the assembly must have a corresponding File table entry.

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateFile()

//*****************************************************************************
// Validate the given ExportedType.
//*****************************************************************************
HRESULT RegMeta::ValidateExportedType(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    ExportedTypeRec  *pRecord;           // ExportedType record.
    mdExportedType   tkExportedType;          // Duplicate ExportedType.
    mdToken     tkImpl;             // Implementation token
    mdToken     tkTypeDef;          // TypeDef token

    LPCSTR      szName;             // ExportedType Name.
    LPCSTR      szNamespace;        // ExportedType Namespace.
    VEContext   veCtxt;             // Context structure.
    VARIANT     var;                // The VARIANT.
    VARIANT     rVar[2];            // The VARIANT.
    SAFEARRAY   *psa = 0;           // The SAFEARRAY.
    HRESULT     hr = S_OK;          // Value returned.
    HRESULT     hrSave = S_OK;      // Save state.

    veCtxt.Token = TokenFromRid(rid, mdtExportedType);
    veCtxt.uOffset = 0;

    // Get the ExportedType record.
    pRecord = pMiniMd->getExportedType(rid);

    tkTypeDef = pRecord->m_TypeDefId;
    if(IsNilToken(tkTypeDef))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CT_NOTYPEDEFID, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_WRN);
    }

    tkImpl = pMiniMd->getImplementationOfExportedType(pRecord);
    
    // Do checks for name validity.
    szName = pMiniMd->getTypeNameOfExportedType(pRecord);
    szNamespace = pMiniMd->getTypeNamespaceOfExportedType(pRecord);
    if (!*szName)
    {
        // ExportedType Name is null.
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CT_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else
    {
        if(!strcmp(szName,COR_DELETED_NAME_A)) goto ErrExit; 
        ULONG L = (ULONG)(strlen(szName)+strlen(szNamespace));
        if(L >= MAX_CLASSNAME_LENGTH)
        {
            // Name too long
            IfFailGo(_ValidateErrorHelper(L, (ULONG)(MAX_CLASSNAME_LENGTH-1), rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_NAMETOOLONG, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        // Check for duplicates based on Name and Enclosing ExportedType.
        hr = ImportHelper::FindExportedType(pMiniMd, szNamespace, szName, tkImpl, &tkExportedType, rid);
        if (hr == S_OK)
        {
            IfFailGo(_ValidateErrorHelper(tkExportedType, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CT_DUP, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else if (hr == CLDB_E_RECORD_NOTFOUND)
            hr = S_OK;
        else
            IfFailGo(hr);
        // Check for duplicate TypeDef based on Name/NameSpace - only for top-level ExportedTypes.
        if(TypeFromToken(tkImpl)==mdtFile)
        {
            mdToken tkTypeDef;
            hr = ImportHelper::FindTypeDefByName(pMiniMd, szNamespace, szName, mdTypeDefNil,
                                             &tkTypeDef, 0);
            if (hr == S_OK)
            {
                IfFailGo(_ValidateErrorHelper(tkTypeDef, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CT_DUPTDNAME, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            else if (hr == CLDB_E_RECORD_NOTFOUND)
                hr = S_OK;
            else
                IfFailGo(hr);
        }
    }
    // Check if flag value is valid
    {
        DWORD dwFlags = pRecord->m_Flags;
        DWORD dwInvalidMask, dwExtraBits;
        dwInvalidMask = (DWORD)~(tdVisibilityMask | tdLayoutMask | tdClassSemanticsMask | 
                tdAbstract | tdSealed | tdSpecialName | tdImport | tdSerializable |
                tdStringFormatMask | tdBeforeFieldInit | tdReservedMask);
        // check for extra bits
        dwExtraBits = dwFlags & dwInvalidMask;
        if(!dwExtraBits)
        {
            // if no extra bits, check layout
            dwExtraBits = dwFlags & tdLayoutMask;
            if(dwExtraBits != tdLayoutMask)
            {
                // layout OK, check string format
                dwExtraBits = dwFlags & tdStringFormatMask;
                if(dwExtraBits != tdStringFormatMask) dwExtraBits = 0;
            }
        }
        if(dwExtraBits)
        {
            IfFailGo(_ValidateErrorHelper(dwExtraBits, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_TD_EXTRAFLAGS, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }

    if(IsNilToken(tkImpl)
        || ((TypeFromToken(tkImpl) != mdtFile)&&(TypeFromToken(tkImpl) != mdtExportedType))
        || (!_IsValidToken(tkImpl)))
    {
        IfFailGo(_ValidateErrorHelper(tkImpl, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CT_BADIMPL, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateExportedType()

//*****************************************************************************
// Validate the given ManifestResource.
//*****************************************************************************
HRESULT RegMeta::ValidateManifestResource(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    ManifestResourceRec  *pRecord;  // ManifestResource record.
    LPCSTR      szName;             // ManifestResource Name.
    DWORD       dwFlags;            // ManifestResource flags.
    mdManifestResource tkmar;       // Duplicate ManifestResource.
    VEContext   veCtxt;             // Context structure.
    VARIANT     var;                // The VARIANT.
    SAFEARRAY   *psa = 0;           // The SAFEARRAY.
    HRESULT     hr = S_OK;          // Value returned.
    HRESULT     hrSave = S_OK;      // Save state.
    mdToken     tkImplementation;
    BOOL        bIsValidImplementation = TRUE;

    veCtxt.Token = TokenFromRid(rid, mdtManifestResource);
    veCtxt.uOffset = 0;

    // Get the ManifestResource record.
    pRecord = pMiniMd->getManifestResource(rid);

    // Do checks for name validity.
    szName = pMiniMd->getNameOfManifestResource(pRecord);
    if (!*szName)
    {
        // ManifestResource Name is null.
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MAR_NAMENULL, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    else
    {
        // Check for duplicates based on Name.
        hr = ImportHelper::FindManifestResource(pMiniMd, szName, &tkmar, rid);
        if (hr == S_OK)
        {
            IfFailGo(_ValidateErrorHelper(tkmar, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MAR_DUP, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
        else if (hr == CLDB_E_RECORD_NOTFOUND)
            hr = S_OK;
        else
            IfFailGo(hr);
    }

    // Get the flags of the ManifestResource.
    dwFlags = pMiniMd->getFlagsOfManifestResource(pRecord);
    if(dwFlags &(~0x00000003))
    {
            IfFailGo(_ValidateErrorHelper(dwFlags, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MAR_BADFLAGS, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Visibility of ManifestResource flags must either be public or private.
    if (!IsMrPublic(dwFlags) && !IsMrPrivate(dwFlags))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MAR_NOTPUBPRIV, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Implementation must be Nil or valid AssemblyRef or File
    tkImplementation = pMiniMd->getImplementationOfManifestResource(pRecord);
    if(!IsNilToken(tkImplementation))
    {
        switch(TypeFromToken(tkImplementation))
        {
            case mdtAssemblyRef:
                bIsValidImplementation = _IsValidToken(tkImplementation);
                break;
            case mdtFile:
                if(bIsValidImplementation = _IsValidToken(tkImplementation))
                {   // if file not PE, offset must be 0
                    FileRec*    pFR = pMiniMd->getFile(RidFromToken(tkImplementation));
                    if(IsFfContainsNoMetaData(pFR->m_Flags) 
                        && pRecord->m_Offset)
                    {
                        IfFailGo(_ValidateErrorHelper(tkImplementation, &var, &psa));
                        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MAR_BADOFFSET, veCtxt, psa));
                        SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    }
                }
                break;
            default:
                bIsValidImplementation = FALSE;
        }
    }
    if(!bIsValidImplementation)
    {
        IfFailGo(_ValidateErrorHelper(tkImplementation, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MAR_BADIMPL, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Validate the Offset into the PE file.

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateManifestResource()

//*****************************************************************************
// Validate the given NestedClass.
//*****************************************************************************
HRESULT RegMeta::ValidateNestedClass(RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);   // MiniMd for the scope.
    NestedClassRec  *pRecord;  // NestedClass record.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save the current state.
    VEContext   veCtxt;             // Context structure.
    VARIANT     var;                // The VARIANT.
    VARIANT     rVar[3];            // The VARIANT.
    SAFEARRAY   *psa = 0;           // The SAFEARRAY.
    mdToken     tkNested;
    mdToken     tkEncloser;

    veCtxt.Token = rid;
    veCtxt.uOffset = 0;

    // Get the NestedClass record.
    pRecord = pMiniMd->getNestedClass(rid);
    tkNested = pMiniMd->getNestedClassOfNestedClass(pRecord);
    tkEncloser = pMiniMd->getEnclosingClassOfNestedClass(pRecord);

    // Nested must be valid TypeDef
    if((TypeFromToken(tkNested) != mdtTypeDef) || !_IsValidToken(tkNested))
    {
        IfFailGo(_ValidateErrorHelper(tkNested, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_NC_BADNESTED, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Encloser must be valid TypeDef
    if((TypeFromToken(tkEncloser) != mdtTypeDef) || !_IsValidToken(tkEncloser))
    {
        IfFailGo(_ValidateErrorHelper(tkEncloser, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_NC_BADENCLOSER, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    // Check for duplicates (who knows what for)
    {
        RID N = pMiniMd->getCountNestedClasss();
        RID tmp;
        NestedClassRec* pRecTmp;
        mdToken tkEncloserTmp;
        for(tmp = rid+1; tmp <= N; tmp++)
        { 
            pRecTmp = pMiniMd->getNestedClass(tmp);
            if(tkNested == pMiniMd->getNestedClassOfNestedClass(pRecTmp))
            {
                if(tkEncloser == (tkEncloserTmp = pMiniMd->getEnclosingClassOfNestedClass(pRecTmp)))
                {
                    IfFailGo(_ValidateErrorHelper(tmp, &var, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_NC_DUP, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                else
                {
                    IfFailGo(_ValidateErrorHelper(tkNested,tkEncloser,tkEncloserTmp, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_NC_DUPENCLOSER, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            }
        }
    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateLocalVariable()

//*****************************************************************************
// Given a Table ID and a Row ID, validate all the columns contain meaningful
// values given the column definitions.  Validate that the offsets into the
// different pools are valid, the rids are within range and the coded tokens
// are valid.  Every failure here is considered an error.
//*****************************************************************************
HRESULT RegMeta::ValidateRecord(ULONG ixTbl, RID rid)
{
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save the current state.
    ULONG       ulCount;                // Count of records in the table.
    ULONG       ulRawColVal;            // Raw value of the column.
    void        *pRow;                  // Row with the data.
    CMiniTableDef *pTbl;                // Table definition.
    CMiniColDef *pCol;                  // Column definition.
    const CCodedTokenDef *pCdTkn;       // Coded token definition.
    ULONG       ix;                     // Index into the array of coded tokens.
    SAFEARRAY   *psa = 0;               // Safe array to pass to VEHandler.
    VARIANT     rVar[3];                // Variant array.

    // Get the table definition.
    pTbl = &pMiniMd->m_TableDefs[ixTbl];

    // Get the row.  We may assume that the Row pointer we get back from
    // this call is correct since we do the verification on the Record
    // pools for each table during the open sequence.  The only place
    // this is not valid is for Dynamic IL and we don't do this
    // verification in that case since we go through IMetaData* APIs
    // in that case and it should all be consistent.
    pRow = m_pStgdb->m_MiniMd.getRow(ixTbl, rid);

    for (ULONG ixCol = 0; ixCol < pTbl->m_cCols; ixCol++)
    {
        // Get the column definition.
        pCol = &pTbl->m_pColDefs[ixCol];

        // Get the raw value stored in the column.  getIX currently doesn't
        // handle byte sized fields, but there are some BYTE fields in the
        // MetaData.  So using the conditional to access BYTE fields.
        if (pCol->m_cbColumn == 1)
            ulRawColVal = pMiniMd->getI1(pRow, *pCol);
        else
            ulRawColVal = pMiniMd->getIX(pRow, *pCol);

        // Do some basic checks on the non-absurdity of the value stored in the
        // column.
        if (IsRidType(pCol->m_Type))
        {
            // Verify that the RID is within range.
            _ASSERTE(pCol->m_Type < TBL_COUNT);
            ulCount = pMiniMd->vGetCountRecs(pCol->m_Type);
            // For records storing rids to pointer tables, the stored value may
            // be one beyond the last record.
            if (IsTblPtr(pCol->m_Type, ixTbl))
                ulCount++;
            if (ulRawColVal > ulCount)
            {
                IfFailGo(_ValidateErrorHelper(ixTbl, ixCol, rid, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_RID_OUTOFRANGE, g_VECtxtNil, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
        }
        else if (IsCodedTokenType(pCol->m_Type))
        {
            // Verify that the Coded token and rid are valid.j
            pCdTkn = &g_CodedTokens[pCol->m_Type - iCodedToken];
            ix = ulRawColVal & ~(-1 << CMiniMdRW::m_cb[pCdTkn->m_cTokens]);
            if (ix >= pCdTkn->m_cTokens)
            {
                IfFailGo(_ValidateErrorHelper(ixTbl, ixCol, rid, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CDTKN_OUTOFRANGE, g_VECtxtNil, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
            ulCount = pMiniMd->vGetCountRecs(TypeFromToken(pCdTkn->m_pTokens[ix]) >> 24);
            if ( (ulRawColVal >> CMiniMdRW::m_cb[pCdTkn->m_cTokens]) > ulCount)
            {
                IfFailGo(_ValidateErrorHelper(ixTbl, ixCol, rid, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_CDRID_OUTOFRANGE, g_VECtxtNil, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
            }
        }
        else if (IsHeapType(pCol->m_Type))
        {
            // Verify that the offsets for the Heap type fields are valid offsets
            // into the heaps.
            switch (pCol->m_Type)
            {
            case iSTRING:
                if (! pMiniMd->m_Strings.IsValidCookie(ulRawColVal))
                {
                    IfFailGo(_ValidateErrorHelper(ixTbl, ixCol, rid, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_STRING_INVALID, g_VECtxtNil, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                break;
            case iGUID:
                if (! pMiniMd->m_Guids.IsValidCookie(ulRawColVal))
                {
                    IfFailGo(_ValidateErrorHelper(ixTbl, ixCol, rid, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_GUID_INVALID, g_VECtxtNil, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                break;
            case iBLOB:
                if (! pMiniMd->m_Blobs.IsValidCookie(ulRawColVal))
                {
                    IfFailGo(_ValidateErrorHelper(ixTbl, ixCol, rid, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_BLOB_INVALID, g_VECtxtNil, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                break;
            default:
                _ASSERTE(!"Invalid heap type encountered!");
            }
        }
        else
        {
            // Not much checking that can be done on the fixed type in a generic sense.
            _ASSERTE (IsFixedType(pCol->m_Type));
        }
        hr = hrSave;
    }
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateRecord()

//*****************************************************************************
// This function validates that the given Method signature is consistent as per
// the compression scheme.
//*****************************************************************************
HRESULT RegMeta::ValidateSigCompression(
    mdToken     tk,                     // [IN] Token whose signature needs to be validated.
    PCCOR_SIGNATURE pbSig,              // [IN] Signature.
    ULONG       cbSig)                  // [IN] Size in bytes of the signature.
{
    VEContext   veCtxt;                 // Context record.
    ULONG       ulCurByte = 0;          // Current index into the signature.
    ULONG       ulSize;                 // Size of uncompressed data at each point.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Saved value.

    veCtxt.Token = tk;
    veCtxt.uOffset = 0;

    // Check for NULL signature.
    if (!cbSig)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIGNULL, veCtxt, 0));
        SetVldtrCode(&hr, VLDTR_S_ERR);
        goto ErrExit;
    }

    // Walk through the signature.  At each point make sure there is enough
    // room left in the signature based on the encoding in the current byte.
    while (cbSig - ulCurByte)
    {
        _ASSERTE(ulCurByte <= cbSig);
        // Get next chunk of uncompressed data size.
        if ((ulSize = CorSigUncompressedDataSize(pbSig)) > (cbSig - ulCurByte))
        {
            IfFailGo(_ValidateErrorHelper(ulCurByte+1, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIGNODATA, veCtxt, psa));
            SetVldtrCode(&hr, VLDTR_S_ERR);
            goto ErrExit;
        }
        // Go past this chunk.
        ulCurByte += ulSize;
        CorSigUncompressData(pbSig);
    }
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateSigCompression()

//*****************************************************************************
// This function validates one argument given an offset into the signature
// where the argument begins.  This function assumes that the signature is well
// formed as far as the compression scheme is concerned.
//*****************************************************************************
HRESULT RegMeta::ValidateOneArg(
    mdToken     tk,                     // [IN] Token whose signature is being processed.
    PCCOR_SIGNATURE &pbSig,             // [IN] Pointer to the beginning of argument.
    ULONG       cbSig,                  // [IN] Size in bytes of the full signature.
    ULONG       *pulCurByte,            // [IN/OUT] Current offset into the signature..
    ULONG       *pulNSentinels,         // [IN/OUT] Number of sentinels
    BOOL        bNoVoidAllowed)         // [IN] Flag indicating whether "void" is disallowed for this arg
{
    ULONG       ulElementType;          // Current element type being processed.
    ULONG       ulElemSize;             // Size of the element type.
    mdToken     token;                  // Embedded token.
    ULONG       ulArgCnt;               // Argument count for function pointer.
    ULONG       ulRank;                 // Rank of the array.
    ULONG       ulSizes;                // Count of sized dimensions of the array.
    ULONG       ulLbnds;                // Count of lower bounds of the array.
    ULONG       ulTkSize;               // Token size.
    VEContext   veCtxt;                 // Context record.
    VARIANT     rVar[2];                // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    BOOL        bRepeat = TRUE;         // MODOPT and MODREQ belong to the arg after them

    _ASSERTE (pulCurByte);
    veCtxt.Token = tk;
    veCtxt.uOffset = 0;

    while(bRepeat)
    {
        bRepeat = FALSE;
        // Validate that the argument is not missing.
        _ASSERTE(*pulCurByte <= cbSig);
        if (cbSig == *pulCurByte)
        {
            hr = VLDTR_E_SIG_MISSARG;
            goto ErrExit;
        }

        // Get the element type.
        *pulCurByte += (ulElemSize = CorSigUncompressedDataSize(pbSig));
        ulElementType = CorSigUncompressData(pbSig);

        // Walk past all the modifier types.
        while (ulElementType & ELEMENT_TYPE_MODIFIER)
        {
            _ASSERTE(*pulCurByte <= cbSig);
            if(ulElementType == ELEMENT_TYPE_SENTINEL)
            {
                if(pulNSentinels) *pulNSentinels+=1;
                if(TypeFromToken(tk) == mdtMethodDef)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_SENTINMETHODDEF, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                if (cbSig == *pulCurByte)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_LASTSENTINEL, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    goto ErrExit;
                }
            }
            if (cbSig == *pulCurByte)
            {
                IfFailGo(_ValidateErrorHelper(ulElementType, *pulCurByte + 1, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSELTYPE, veCtxt, psa));
                SetVldtrCode(&hr, hrSave);
                goto ErrExit;
            }
            *pulCurByte += (ulElemSize = CorSigUncompressedDataSize(pbSig));
            ulElementType = CorSigUncompressData(pbSig);
        }

        switch (ulElementType)
        {
            case ELEMENT_TYPE_VOID:
                if(bNoVoidAllowed)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_BADVOID, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
            case ELEMENT_TYPE_BOOLEAN:
            case ELEMENT_TYPE_CHAR:
            case ELEMENT_TYPE_I1:
            case ELEMENT_TYPE_U1:
            case ELEMENT_TYPE_I2:
            case ELEMENT_TYPE_U2:
            case ELEMENT_TYPE_I4:
            case ELEMENT_TYPE_U4:
            case ELEMENT_TYPE_I8:
            case ELEMENT_TYPE_U8:
            case ELEMENT_TYPE_R4:
            case ELEMENT_TYPE_R8:
            case ELEMENT_TYPE_STRING:
            case ELEMENT_TYPE_OBJECT:
            case ELEMENT_TYPE_TYPEDBYREF:
            case ELEMENT_TYPE_U:
            case ELEMENT_TYPE_I:
            case ELEMENT_TYPE_R:
                break;
            case ELEMENT_TYPE_BYREF:  //fallthru
                if(TypeFromToken(tk)==mdtFieldDef)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_BYREFINFIELD, veCtxt, 0));
                    SetVldtrCode(&hr, hrSave);
                }
            case ELEMENT_TYPE_PTR:
                // Validate the referenced type.
                IfFailGo(ValidateOneArg(tk, pbSig, cbSig, pulCurByte,pulNSentinels,FALSE));
                if (hr != S_OK)
                    SetVldtrCode(&hrSave, hr);
                break;
            case ELEMENT_TYPE_PINNED:
            case ELEMENT_TYPE_SZARRAY:
                // Validate the referenced type.
                IfFailGo(ValidateOneArg(tk, pbSig, cbSig, pulCurByte,pulNSentinels,TRUE));
                if (hr != S_OK)
                    SetVldtrCode(&hrSave, hr);
                break;
            case ELEMENT_TYPE_VALUETYPE: //fallthru
            case ELEMENT_TYPE_CLASS:
            case ELEMENT_TYPE_CMOD_OPT:
            case ELEMENT_TYPE_CMOD_REQD:
                // See if the token is missing.
                _ASSERTE(*pulCurByte <= cbSig);
                if (cbSig == *pulCurByte)
                {
                    IfFailGo(_ValidateErrorHelper(ulElementType, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSTKN, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    break;
                }
                // See if the token is a valid token.
                ulTkSize = CorSigUncompressedDataSize(pbSig);
                token = CorSigUncompressToken(pbSig);
                if (!_IsValidToken(token))
                {
                    IfFailGo(_ValidateErrorHelper(token, *pulCurByte, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_TKNBAD, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    *pulCurByte += ulTkSize;
                    break;
                }
                *pulCurByte += ulTkSize;
                if((ulElementType == ELEMENT_TYPE_CLASS)||(ulElementType == ELEMENT_TYPE_VALUETYPE))
                {
                    // Check for long-form encoding
                    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
                    LPCSTR      szName = "";                 // token's Name.
                    LPCSTR      szNameSpace = "";            // token's NameSpace.

                    if(TypeFromToken(token)==mdtTypeRef)
                    {
                        TypeRefRec* pTokenRec = pMiniMd->getTypeRef(RidFromToken(token));
                        mdToken tkResScope = pMiniMd->getResolutionScopeOfTypeRef(pTokenRec);
                        if(RidFromToken(tkResScope) && (TypeFromToken(tkResScope)==mdtAssemblyRef))
                        {
                            AssemblyRefRec *pARRec = pMiniMd->getAssemblyRef(RidFromToken(tkResScope));
                            if(0 == _stricmp("mscorlib",pMiniMd->getNameOfAssemblyRef(pARRec)))
                            {
                                szNameSpace = pMiniMd->getNamespaceOfTypeRef(pTokenRec);
                                szName = pMiniMd->getNameOfTypeRef(pTokenRec);
                            }
                        }
                    }
                    else if(TypeFromToken(token)==mdtTypeDef)
                    {
                        TypeDefRec* pTokenRec = pMiniMd->getTypeDef(RidFromToken(token));
                        if(g_fValidatingMscorlib) // otherwise don't even bother checking the name
                        {
                            szName = pMiniMd->getNameOfTypeDef(pTokenRec);
                            szNameSpace = pMiniMd->getNamespaceOfTypeDef(pTokenRec);
                        }
                        // while at it, check if token is indeed a class (valuetype)
                        BOOL bValueType = FALSE;
                        if(!IsTdInterface(pTokenRec->m_Flags))
                        {
                            mdToken tkExtends = pMiniMd->getExtendsOfTypeDef(pTokenRec);
                            if(RidFromToken(tkExtends))
                            {
                                LPCSTR      szExtName = "";                 // parent's Name.
                                LPCSTR      szExtNameSpace = "";            // parent's NameSpace.
                                if(TypeFromToken(tkExtends)==mdtTypeRef)
                                {
                                    TypeRefRec* pExtRec = pMiniMd->getTypeRef(RidFromToken(tkExtends));
                                    mdToken tkResScope = pMiniMd->getResolutionScopeOfTypeRef(pExtRec);
                                    if(RidFromToken(tkResScope) && (TypeFromToken(tkResScope)==mdtAssemblyRef))
                                    {
                                        AssemblyRefRec *pARRec = pMiniMd->getAssemblyRef(RidFromToken(tkResScope));
                                        if(0 == _stricmp("mscorlib",pMiniMd->getNameOfAssemblyRef(pARRec)))
                                        {
                                            szExtNameSpace = pMiniMd->getNamespaceOfTypeRef(pExtRec);
                                            szExtName = pMiniMd->getNameOfTypeRef(pExtRec);
                                        }
                                    }
                                }
                                else if(TypeFromToken(tkExtends)==mdtTypeDef)
                                {
                                    if(g_fValidatingMscorlib) // otherwise don't even bother checking the name
                                    {
                                        TypeDefRec* pExtRec = pMiniMd->getTypeDef(RidFromToken(tkExtends));
                                        szExtName = pMiniMd->getNameOfTypeDef(pExtRec);
                                        szExtNameSpace = pMiniMd->getNamespaceOfTypeDef(pExtRec);
                                    }
                                }
                                if(0 == strcmp(szExtNameSpace,BASE_NAMESPACE))
                                {
                                    if(0==strcmp(szExtName,BASE_ENUM_CLASSNAME)) bValueType = TRUE;
                                    else if(0==strcmp(szExtName,BASE_VTYPE_CLASSNAME))
                                    {
                                        bValueType = (strcmp(szNameSpace,BASE_NAMESPACE) ||
                                                    strcmp(szName,BASE_ENUM_CLASSNAME));
                                    }
                                }
                            }
                        }
                        if(bValueType != (ulElementType == ELEMENT_TYPE_VALUETYPE))
                        {
                            IfFailGo(_ValidateErrorHelper(token, *pulCurByte, rVar, &psa));
                            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_TOKTYPEMISMATCH, veCtxt, psa));
                            SetVldtrCode(&hrSave, VLDTR_S_ERR);
                        }

                    }
                    if(0 == strcmp(szNameSpace,BASE_NAMESPACE))
                    {
                        for(unsigned jjj = 0; jjj < g_NumSigLongForms; jjj++)
                        {
                            if(0 == strcmp(szName,g_SigLongFormName[jjj]))
                            {
                                IfFailGo(_ValidateErrorHelper(token, *pulCurByte, rVar, &psa));
                                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_LONGFORM, veCtxt, psa));
                                SetVldtrCode(&hrSave, VLDTR_S_ERR);
                                break;
                            }
                        }
                    }
                }
                else // i.e. if(ELEMENT_TYPE_CMOD_OPT || ELEMENT_TYPE_CMOD_REQD)
                    bRepeat = TRUE; // go on validating, we're not done with this arg
                break;

            case ELEMENT_TYPE_VALUEARRAY:
                // Validate base type.
                IfFailGo(ValidateOneArg(tk, pbSig, cbSig, pulCurByte,pulNSentinels,TRUE));
                // Quit validation if errors found.
                if (hr != S_OK)
                    SetVldtrCode(&hrSave, hr);
                else 
                {
                    // See if the array size is missing.
                    _ASSERTE(*pulCurByte <= cbSig);
                    if (cbSig == *pulCurByte)
                    {
                        IfFailGo(_ValidateErrorHelper(*pulCurByte + 1, rVar, &psa));
                        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSVASIZE, veCtxt, psa));
                        SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    }
                    else
                    {
                        // Skip array size.
                        *pulCurByte += CorSigUncompressedDataSize(pbSig);
                        CorSigUncompressData(pbSig);
                    }
                }
                break;

            case ELEMENT_TYPE_FNPTR: 
                // Validate that calling convention is present.
                _ASSERTE(*pulCurByte <= cbSig);
                if (cbSig == *pulCurByte)
                {
                    IfFailGo(_ValidateErrorHelper(*pulCurByte + 1, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSFPTR, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    break;
                }
                // Consume calling convention.
                *pulCurByte += CorSigUncompressedDataSize(pbSig);
                CorSigUncompressData(pbSig);

                // Validate that argument count is present.
                _ASSERTE(*pulCurByte <= cbSig);
                if (cbSig == *pulCurByte)
                {
                    IfFailGo(_ValidateErrorHelper(*pulCurByte + 1, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSFPTRARGCNT, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    break;
                }
                // Consume argument count.
                *pulCurByte += CorSigUncompressedDataSize(pbSig);
                ulArgCnt = CorSigUncompressData(pbSig);

                // Validate and consume return type.
                IfFailGo(ValidateOneArg(tk, pbSig, cbSig, pulCurByte,NULL,FALSE));
                if (hr != S_OK)
                {
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    break;
                }

                // Validate and consume the arguments.
                while(ulArgCnt--)
                {
                    IfFailGo(ValidateOneArg(tk, pbSig, cbSig, pulCurByte,NULL,TRUE));
                    if (hr != S_OK)
                    {
                        SetVldtrCode(&hrSave, VLDTR_S_ERR);
                        break;
                    }
                }
                break;

            case ELEMENT_TYPE_ARRAY:
                // Validate and consume the base type.
                IfFailGo(ValidateOneArg(tk, pbSig, cbSig, pulCurByte,pulNSentinels,TRUE));

                // Validate that the rank is present.
                _ASSERTE(*pulCurByte <= cbSig);
                if (cbSig == *pulCurByte)
                {
                    IfFailGo(_ValidateErrorHelper(*pulCurByte + 1, rVar, &psa));
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSRANK, veCtxt, psa));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                    break;
                }
                // Consume the rank.
                *pulCurByte += CorSigUncompressedDataSize(pbSig);
                ulRank = CorSigUncompressData(pbSig);

                // Process the sizes.
                if (ulRank)
                {
                    // Validate that the count of sized-dimensions is specified.
                    _ASSERTE(*pulCurByte <= cbSig);
                    if (cbSig == *pulCurByte)
                    {
                        IfFailGo(_ValidateErrorHelper(*pulCurByte + 1, rVar, &psa));
                        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSNSIZE, veCtxt, psa));
                        SetVldtrCode(&hrSave, VLDTR_S_ERR);
                        break;
                    }
                    // Consume the count of sized dimensions.
                    *pulCurByte += CorSigUncompressedDataSize(pbSig);
                    ulSizes = CorSigUncompressData(pbSig);

                    // Loop over the sizes.
                    while (ulSizes--)
                    {
                        // Validate the current size.
                        _ASSERTE(*pulCurByte <= cbSig);
                        if (cbSig == *pulCurByte)
                        {
                            IfFailGo(_ValidateErrorHelper(*pulCurByte + 1, rVar, &psa));
                            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSSIZE, veCtxt, psa));
                            SetVldtrCode(&hrSave, VLDTR_S_ERR);
                            break;
                        }
                        // Consume the current size.
                        *pulCurByte += CorSigUncompressedDataSize(pbSig);
                        CorSigUncompressData(pbSig);
                    }

                    // Validate that the count of lower bounds is specified.
                    _ASSERTE(*pulCurByte <= cbSig);
                    if (cbSig == *pulCurByte)
                    {
                        IfFailGo(_ValidateErrorHelper(*pulCurByte + 1, rVar, &psa));
                        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSNLBND, veCtxt, psa));
                        SetVldtrCode(&hrSave, VLDTR_S_ERR);
                        break;
                    }
                    // Consume the count of lower bound.
                    *pulCurByte += CorSigUncompressedDataSize(pbSig);
                    ulLbnds = CorSigUncompressData(pbSig);

                    // Loop over the lower bounds.
                    while (ulLbnds--)
                    {
                        // Validate the current lower bound.
                        _ASSERTE(*pulCurByte <= cbSig);
                        if (cbSig == *pulCurByte)
                        {
                            IfFailGo(_ValidateErrorHelper(*pulCurByte + 1, rVar, &psa));
                            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSLBND, veCtxt, psa));
                            SetVldtrCode(&hrSave, VLDTR_S_ERR);
                            break;
                        }
                        // Consume the current size.
                        *pulCurByte += CorSigUncompressedDataSize(pbSig);
                        CorSigUncompressData(pbSig);
                    }
                }
                break;
            case ELEMENT_TYPE_SENTINEL: // this case never works because all modifiers are skipped before switch
                if(TypeFromToken(tk) == mdtMethodDef)
                {
                    IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_SENTINMETHODDEF, veCtxt, 0));
                    SetVldtrCode(&hrSave, VLDTR_S_ERR);
                }
                break;
            default:
                IfFailGo(_ValidateErrorHelper(ulElementType, *pulCurByte - ulElemSize, rVar, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_BADELTYPE, veCtxt, psa));
                SetVldtrCode(&hrSave, VLDTR_S_ERR);
                break;
        }   // switch (ulElementType)
    } // end while(bRepeat)
    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateOneArg()

//*****************************************************************************
// This function validates the given Method signature.  This function works
// with Method signature for both the MemberRef and MethodDef.
//*****************************************************************************
HRESULT RegMeta::ValidateMethodSig(
    mdToken     tk,                     // [IN] Token whose signature needs to be validated.
    PCCOR_SIGNATURE pbSig,              // [IN] Signature.
    ULONG       cbSig,                  // [IN] Size in bytes of the signature.
    DWORD       dwFlags)                // [IN] Method flags.
{
    ULONG       ulCurByte = 0;          // Current index into the signature.
    ULONG       ulCallConv;             // Calling convention.
    ULONG       ulArgCount;             // Count of arguments.
    ULONG       i;                      // Looping index.
    VEContext   veCtxt;                 // Context record.
    VARIANT     rVar[2];                // The VARIANT array.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.
    ULONG       ulNSentinels = 0;

    _ASSERTE(TypeFromToken(tk) == mdtMethodDef ||
             TypeFromToken(tk) == mdtMemberRef);

    veCtxt.Token = tk;
    veCtxt.uOffset = 0;

    // Validate the signature is well-formed with respect to the compression
    // scheme.  If this fails, no further validation needs to be done.
    if ( (hr = ValidateSigCompression(tk, pbSig, cbSig)) != S_OK)
        goto ErrExit;

    // Validate the calling convention.
    ulCurByte += CorSigUncompressedDataSize(pbSig);
    ulCallConv = CorSigUncompressData(pbSig);

    i = ulCallConv & IMAGE_CEE_CS_CALLCONV_MASK;
    if((i != IMAGE_CEE_CS_CALLCONV_DEFAULT)&&( i != IMAGE_CEE_CS_CALLCONV_VARARG)
        || (ulCallConv & IMAGE_CEE_CS_CALLCONV_EXPLICITTHIS))
    {
        IfFailGo(_ValidateErrorHelper(ulCallConv, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_BADCALLINGCONV, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    if(TypeFromToken(tk) == mdtMethodDef) // MemberRefs have no flags available
    {
        // If HASTHIS is set on the calling convention, the method should not be static.
        if ((ulCallConv & IMAGE_CEE_CS_CALLCONV_HASTHIS) &&
            IsMdStatic(dwFlags))
        {
            IfFailGo(_ValidateErrorHelper(ulCallConv, &var, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_THISSTATIC, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }

        // If HASTHIS is not set on the calling convention, the method should be static.
        if (!(ulCallConv & IMAGE_CEE_CS_CALLCONV_HASTHIS) &&
            !IsMdStatic(dwFlags))
        {
            IfFailGo(_ValidateErrorHelper(ulCallConv, rVar, &psa));
            IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_NOTTHISNOTSTATIC, veCtxt, psa));
            SetVldtrCode(&hrSave, VLDTR_S_ERR);
        }
    }
    // Is there any sig left for arguments?
    _ASSERTE(ulCurByte <= cbSig);
    if (cbSig == ulCurByte)
    {
        IfFailGo(_ValidateErrorHelper(ulCurByte+1, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_MD_NOARGCNT, veCtxt, psa));
        SetVldtrCode(&hr, hrSave);
        goto ErrExit;
    }

    // Get the argument count.
    ulCurByte += CorSigUncompressedDataSize(pbSig);
    ulArgCount = CorSigUncompressData(pbSig);

    // Validate the return type and the arguments.
//    for (i = 0; i < (ulArgCount + 1); i++)
    for(i=1; ulCurByte < cbSig; i++)
    {
        hr = ValidateOneArg(tk, pbSig, cbSig, &ulCurByte,&ulNSentinels,(i > 1));
        if (hr != S_OK)
        {
            if(hr == VLDTR_E_SIG_MISSARG)
            {
                IfFailGo(_ValidateErrorHelper(i, &var, &psa));
                IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MISSARG, veCtxt, psa));
            }
            SetVldtrCode(&hr, hrSave);
            hrSave = hr;
            break;
        }
    }
    if((ulNSentinels != 0) && (!isCallConv(ulCallConv, IMAGE_CEE_CS_CALLCONV_VARARG )))
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_SENTMUSTVARARG, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }
    if(ulNSentinels > 1)
    {
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_SIG_MULTSENTINELS, veCtxt, 0));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateMethodSig()

//*****************************************************************************
// This function validates the given Field signature.  This function works
// with Field signature for both the MemberRef and FieldDef.
//*****************************************************************************
HRESULT RegMeta::ValidateFieldSig(
    mdToken     tk,                     // [IN] Token whose signature needs to be validated.
    PCCOR_SIGNATURE pbSig,              // [IN] Signature.
    ULONG       cbSig)                  // [IN] Size in bytes of the signature.
{
    ULONG       ulCurByte = 0;          // Current index into the signature.
    ULONG       ulCallConv;             // Calling convention.
    VEContext   veCtxt;                 // Context record.
    VARIANT     var;                    // The VARIANT.
    SAFEARRAY   *psa = 0;               // The SAFEARRAY.
    HRESULT     hr = S_OK;              // Value returned.
    HRESULT     hrSave = S_OK;          // Save state.

    _ASSERTE(TypeFromToken(tk) == mdtFieldDef ||
             TypeFromToken(tk) == mdtMemberRef);

    veCtxt.Token = tk;
    veCtxt.uOffset = 0;

    // Validate the calling convention.
    ulCurByte += CorSigUncompressedDataSize(pbSig);
    ulCallConv = CorSigUncompressData(pbSig);
    if (!isCallConv(ulCallConv, IMAGE_CEE_CS_CALLCONV_FIELD ))
    {
        IfFailGo(_ValidateErrorHelper(ulCallConv, &var, &psa));
        IfBreakGo(m_pVEHandler->VEHandler(VLDTR_E_FD_BADCALLINGCONV, veCtxt, psa));
        SetVldtrCode(&hrSave, VLDTR_S_ERR);
    }

    // Validate the field.
    IfFailGo(ValidateOneArg(tk, pbSig, cbSig, &ulCurByte,NULL,TRUE));
    SetVldtrCode(&hrSave, hr);

    hr = hrSave;
ErrExit:
    DESTROY_SAFEARRAY_AND_RETURN()
}   // RegMeta::ValidateFieldSig()

//*****************************************************************************
// This is a utility function to allocate a one dimensional zero-based safe
// array of variants.
//*****************************************************************************
static HRESULT _AllocSafeVariantArrayVector( // Return status.
    VARIANT     *rVar,                  // [IN] Variant array.
    long        cElem,                  // [IN] Size of the array.
    SAFEARRAY   **ppArray)              // [OUT] Double pointer to SAFEARRAY.
{
    HRESULT     hr = S_OK;
    long        i;

    _ASSERTE(rVar && cElem && ppArray);

    IfNullGo(*ppArray = SafeArrayCreateVector(VT_VARIANT, 0, cElem));
    for (i = 0; i < cElem; i++)
        IfFailGo(SafeArrayPutElement(*ppArray, &i, &rVar[i]));
ErrExit:
    return hr;
}   // _AllocSafeVariantArrayVector()

//*****************************************************************************
// Helper function for creating a SAFEARRAY of size one with a VARIANT of type
// UI4.
//*****************************************************************************
static HRESULT _ValidateErrorHelper(
    ULONG       ulVal,                  // [IN] UI4 value.
    VARIANT     *rVar,                  // [IN] VARIANT pointer.
    SAFEARRAY   **ppsa)                 // [OUT] Double pointer to SAFEARRAY.
{
    HRESULT     hr = S_OK;              // Return value.

    // Initialize the VARIANT.
    V_VT(rVar) = VT_UI4;
    V_UI4(rVar) = ulVal;

    // Allocate the SAFEARRAY.
    if (*ppsa)
        IfFailGo(SafeArrayDestroy(*ppsa));
    IfFailGo(_AllocSafeVariantArrayVector(rVar, 1, ppsa));
ErrExit:
    return hr;
}   // _ValidateErrorHelper()

//*****************************************************************************
// Helper function for creating a SAFEARRAY of size two with a VARIANT of type
// UI4.  Creating multiple functions is simpler than initializing the arrays
// at every call site!
//*****************************************************************************
static HRESULT _ValidateErrorHelper(
    ULONG       ulVal1,                 // [IN] UI4 value1.
    ULONG       ulVal2,                 // [IN] UI4 value2.
    VARIANT     *rVar,                  // [IN] VARIANT pointer.
    SAFEARRAY   **ppsa)                 // [OUT] Double pointer to SAFEARRAY.
{
    HRESULT     hr = S_OK;              // Return value.

    // Initialize the VARIANTs.
    V_VT(&rVar[0]) = VT_UI4;
    V_UI4(&rVar[0]) = ulVal1;
    V_VT(&rVar[1]) = VT_UI4;
    V_UI4(&rVar[1]) = ulVal2;

    // Allocate the SAFEARRAY.
    if (*ppsa)
        IfFailGo(SafeArrayDestroy(*ppsa));
    IfFailGo(_AllocSafeVariantArrayVector(rVar, 2, ppsa));
ErrExit:
    return hr;
}   // _ValidateErrorHelper()

//*****************************************************************************
// Helper function for creating a SAFEARRAY of size three with a VARIANT of
// type UI4.  Creating multiple functions is simpler than initializing the
// arrays at every call site!
//*****************************************************************************
static HRESULT _ValidateErrorHelper(
    ULONG       ulVal1,                 // [IN] UI4 value1.
    ULONG       ulVal2,                 // [IN] UI4 value2.
    ULONG       ulVal3,                 // [IN] UI4 value3.
    VARIANT     *rVar,                  // [IN] VARIANT pointer.
    SAFEARRAY   **ppsa)                 // [OUT] Double pointer to SAFEARRAY.
{
    HRESULT     hr = S_OK;              // Return value.

    // Initialize the VARIANTs.
    V_VT(&rVar[0]) = VT_UI4;
    V_UI4(&rVar[0]) = ulVal1;
    V_VT(&rVar[1]) = VT_UI4;
    V_UI4(&rVar[1]) = ulVal2;
    V_VT(&rVar[2]) = VT_UI4;
    V_UI4(&rVar[2]) = ulVal3;

    // Allocate the SAFEARRAY.
    if (*ppsa)
        IfFailGo(SafeArrayDestroy(*ppsa));
    IfFailGo(_AllocSafeVariantArrayVector(rVar, 3, ppsa));
ErrExit:
    return hr;
}   // _ValidateErrorHelper()

//*****************************************************************************
// Helper function to see if there is a duplicate record for ClassLayout.
//*****************************************************************************
static HRESULT _FindClassLayout(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
    mdTypeDef   tkParent,               // [IN] the parent that ClassLayout is associated with
    RID         *pclRid,                // [OUT] rid for the ClassLayout.
    RID         rid)                    // [IN] rid to be ignored.
{
    ULONG       cClassLayoutRecs;
    ClassLayoutRec *pRecord;
    mdTypeDef   tkParTmp;
    ULONG       i;

    _ASSERTE(pMiniMd && pclRid && rid);
    _ASSERTE(TypeFromToken(tkParent) == mdtTypeDef && RidFromToken(tkParent));

    cClassLayoutRecs = pMiniMd->getCountClassLayouts();

    for (i = 1; i <= cClassLayoutRecs; i++)
    {
        // Ignore the rid to be ignored!
        if (rid == i)
            continue;

        pRecord = pMiniMd->getClassLayout(i);
        tkParTmp = pMiniMd->getParentOfClassLayout(pRecord);
        if (tkParTmp == tkParent)
        {
            *pclRid = i;
            return S_OK;
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
}   // _FindClassLayout()

//*****************************************************************************
// Helper function to see if there is a duplicate for FieldLayout.
//*****************************************************************************
static HRESULT _FindFieldLayout(
    CMiniMdRW   *pMiniMd,               // [IN] the minimd to lookup
    mdFieldDef  tkParent,               // [IN] the parent that FieldLayout is associated with
    RID         *pflRid,                // [OUT] rid for the FieldLayout record.
    RID         rid)                    // [IN] rid to be ignored.
{
    ULONG       cFieldLayoutRecs;
    FieldLayoutRec *pRecord;
    mdFieldDef  tkField;
    ULONG       i;

    _ASSERTE(pMiniMd && pflRid && rid);
    _ASSERTE(TypeFromToken(tkParent) == mdtFieldDef && RidFromToken(tkParent));

    cFieldLayoutRecs = pMiniMd->getCountFieldLayouts();

    for (i = 1; i <= cFieldLayoutRecs; i++)
    {
        // Ignore the rid to be ignored!
        if (rid == i)
            continue;

        pRecord = pMiniMd->getFieldLayout(i);
        tkField = pMiniMd->getFieldOfFieldLayout(pRecord);
        if (tkField == tkParent)
        {
            *pflRid = i;
            return S_OK;
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
}   // _FindFieldLayout()

//*****************************************************************************
// Helper function to validate a locale.
//*****************************************************************************
char* g_szValidLocale[] = {
"ar","ar-SA","ar-IQ","ar-EG","ar-LY","ar-DZ","ar-MA","ar-TN","ar-OM","ar-YE","ar-SY","ar-JO","ar-LB","ar-KW","ar-AE","ar-BH","ar-QA",
"bg","bg-BG",
"ca","ca-ES",
"zh-CHS","zh-TW","zh-CN","zh-HK","zh-SG","zh-MO","zh-CHT",
"cs","cs-CZ",
"da","da-DK",
"de","de-DE","de-CH","de-AT","de-LU","de-LI",
"el","el-GR",
"en","en-US","en-GB","en-AU","en-CA","en-NZ","en-IE","en-ZA","en-JM","en-CB","en-BZ","en-TT","en-ZW","en-PH",
"es","es-ES-Ts","es-MX","es-ES","es-GT","es-CR","es-PA","es-DO","es-VE","es-CO","es-PE","es-AR","es-EC","es-CL",
"es-UY","es-PY","es-BO","es-SV","es-HN","es-NI","es-PR",
"fi","fi-FI",
"fr","fr-FR","fr-BE","fr-CA","fr-CH","fr-LU","fr-MC",
"he","he-IL",
"hu","hu-HU",
"is","is-IS",
"it","it-IT","it-CH",
"ja","ja-JP",
"ko","ko-KR",
"nl","nl-NL","nl-BE",
"no",
"nb-NO",
"nn-NO",
"pl","pl-PL",
"pt","pt-BR","pt-PT",
"ro","ro-RO",
"ru","ru-RU",
"hr","hr-HR",
"sr-SP-Latn",
"sr-SP-Cyrl",
"sk","sk-SK",
"sq","sq-AL",
"sv","sv-SE","sv-FI",
"th","th-TH",
"tr","tr-TR",
"ur","ur-PK",
"id","id-ID",
"uk","uk-UA",
"be","be-BY",
"sl","sl-SI",
"et","et-EE",
"lv","lv-LV",
"lt","lt-LT",
"fa","fa-IR",
"vi","vi-VN",
"hy","hy-AM",
"az","az-AZ-Latn","az-AZ-Cyrl",
"eu","eu-ES",
"mk","mk-MK",
"af","af-ZA",
"ka","ka-GE",
"fo","fo-FO",
"hi","hi-IN",
"ms","ms-MY","ms-BN",
"kk","kk-KZ",
"ky","ky-KZ",
"sw","sw-KE",
"uz","uz-UZ-Latn","uz-UZ-Cyrl",
"tt","tt-RU",
"pa","pa-IN",
"gu","gu-IN",
"ta","ta-IN",
"te","te-IN",
"kn","kn-IN",
"mr","mr-IN",
"sa","sa-IN",
"mn","mn-MN",
"gl","gl-ES",
"kok","kok-IN",
"syr","syr-SY",
"div","div-MV",
};

static BOOL _IsValidLocale(LPCUTF8 szLocale)
{
    int i, N= sizeof(g_szValidLocale)/sizeof(char*);
    if(szLocale && *szLocale)
    {
        for(i = 0; i < N; i++)
        {
            if(!_stricmp(szLocale,g_szValidLocale[i])) return TRUE;
        }
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\newmerger.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// NewMerger.h
//
// Contains utility code for MD directory
//
//*****************************************************************************
#ifndef __NEWMERGER__h__
#define __NEWMERGER__h__

class RegMeta;

class MDTOKENMAP;


typedef enum MergeFlags
{
    MergeFlagsNone      =   0,
    MergeManifest       =   0x00000001,     
    DropMemberRefCAs    =   0x00000002,
    NoDupCheck          =   0x00000004,
} MergeFlags;

//*********************************************************************
// MergeImportData
//*********************************************************************
class MergeImportData
{
public:
    RegMeta         *m_pRegMetaImport;
    IUnknown        *m_pHandler;
    IMapToken       *m_pHostMapToken;
    IMetaDataError  *m_pError;
    MDTOKENMAP      *m_pMDTokenMap;
    MergeImportData *m_pNextImportData;
#if _DEBUG
    int             m_iImport;          // debug only. This is the ith import for merge.
#endif // _DEBUG
};


//*********************************************************************
// Class to handle merge
//*********************************************************************
class NEWMERGER
{
    friend class RegMeta;
public:
    NEWMERGER();
    ~NEWMERGER();

    HRESULT Init(RegMeta *pRegMetaDest);
    
    HRESULT AddImport(
        IMetaDataImport *pImport,               // [IN] The scope to be merged.
        IMapToken   *pHostMapToken,         // [IN] Host IMapToken interface to receive token remap notification
        IUnknown    *pHandler);             // [IN] An object to receive to receive error notification.
    
    HRESULT Merge(MergeFlags flags, CorRefToDefCheck optimizeRefToDef);

protected:
    CMiniMdRW *GetMiniMdEmit();

    HRESULT MergeTypeDefNamesOnly();
    HRESULT MergeModuleRefs();
    HRESULT MergeAssemblyRefs();
    HRESULT MergeTypeRefs();
    HRESULT CompleteMergeTypeDefs();

    HRESULT CopyTypeDefPartially( 
        TypeDefRec  *pRecEmit,                  // [IN] the emit record to fill
        CMiniMdRW   *pMiniMdImport,             // [IN] the importing scope
        TypeDefRec  *pRecImp);                  // [IN] the record to import

    // helpers for merging tables
    HRESULT MergeModule( );
    HRESULT MergeTypeDefChildren();
    HRESULT MergeInterfaceImpls( );
    HRESULT MergeMemberRefs( );
    HRESULT MergePinvoke();

    HRESULT MergeConstants( );
    HRESULT MergeCustomAttributes( );
    HRESULT MergeFieldMarshals( );
    HRESULT MergeDeclSecuritys( );
    HRESULT MergeClassLayouts( );
    HRESULT MergeFieldLayouts( );
    HRESULT MergeFieldRVAs();
    HRESULT MergeMethodImpls( );
    HRESULT MergeStandAloneSigs();
    HRESULT MergeTypeSpecs();
    HRESULT MergeSourceFiles( );
    HRESULT MergeBlocks( );
    HRESULT MergeScopes( );
    HRESULT MergeLocalVariables( );
    HRESULT MergeStrings( );

    HRESULT MergeAssembly();
    HRESULT MergeFiles();
    HRESULT MergeExportedTypes();
    HRESULT MergeManifestResources();

        // copy over a interfaceimpl record
    HRESULT CopyInterfaceImpl(
        InterfaceImplRec    *pRecEmit,          // [IN] the emit record to fill
        MergeImportData     *pImportData,       // [IN] the importing context
        InterfaceImplRec    *pRecImp);          // [IN] the record to import

    // verification helpers
    HRESULT VerifyMethods(MergeImportData *pImportData, mdTypeDef tdImp, mdTypeDef tdEmit);
    HRESULT VerifyFields(MergeImportData *pImportData, mdTypeDef tdImp, mdTypeDef tdEmit);
    HRESULT VerifyEvents(MergeImportData *pImportData, mdTypeDef tdImp, mdTypeDef tdEmit);
    HRESULT VerifyProperties(MergeImportData *pImportData, mdTypeDef tdImp, mdTypeDef tdEmit);
    HRESULT VerifyParams(MergeImportData *pImportData, mdMethodDef mdImp,   mdMethodDef mdEmit);

    // Copy helpers
    HRESULT CopyMethods(MergeImportData *pImportData, mdTypeDef tdImp, mdTypeDef tdEmit);
    HRESULT CopyFields(MergeImportData *pImportData, mdTypeDef tdImp, mdTypeDef tdEmit);
    HRESULT CopyEvents(MergeImportData *pImportData, mdTypeDef tdImp, mdTypeDef tdEmit);
    HRESULT CopyProperties(MergeImportData *pImportData, mdTypeDef tdImp, mdTypeDef tdEmit);
    HRESULT CopyParams(MergeImportData *pImportData, mdMethodDef mdImp, mdMethodDef mdEmit);

    HRESULT CopyMethod(
        MergeImportData *pImportData,           // [IN] import scope
        MethodRec   *pRecImp,                   // [IN] the record to import
        MethodRec   *pRecEmit);                 // [IN] the emit record to fill

    HRESULT CopyField(
        MergeImportData *pImportData,           // [IN] import scope
        FieldRec    *pRecImp,                   // [IN] the record to import
        FieldRec    *pRecEmit);                 // [IN] the emit record to fill

    HRESULT CopyParam(
        MergeImportData *pImportData,           // [IN] import scope
        ParamRec    *pRecImp,                   // [IN] the record to import
        ParamRec    *pRecEmit);                 // [IN] the emit record to fill

    HRESULT CopyEvent(
        MergeImportData *pImportData,           // [IN] import scope
        EventRec    *pRecImp,                   // [IN] the record to import
        EventRec    *pRecEmit);                 // [IN] the emit record to fill

    HRESULT CopyProperty(
        MergeImportData *pImportData,           // [IN] import scope
        PropertyRec *pRecImp,                   // [IN] the record to import
        PropertyRec *pRecEmit);                 // [IN] the emit record to fill


    HRESULT CopyMethodSemantics(
        MergeImportData *pImportData, 
        mdToken     tkImport,               // Event or property in the import scope
        mdToken     tkEmit);                 // corresponding event or property in the emitting scope

    HRESULT VerifyMethod(
        MergeImportData *pImportData, 
        mdMethodDef mdImp,                      // [IN] the emit record to fill
        mdMethodDef mdEmit);                    // [IN] the record to import

    HRESULT OnError(HRESULT hr, MergeImportData *pImportData, mdToken token);

private:
    RegMeta         *m_pRegMetaEmit;
    MergeImportData *m_pImportDataList;
    MergeImportData **m_pImportDataTail;
    MergeFlags      m_dwMergeFlags;
    BOOL            m_fDupCheck;
    CorRefToDefCheck m_optimizeRefToDef;
#if _DEBUG
    int             m_iImport;          // debug only. To count how many import scopes to be merged.
#endif // _DEBUG
};


#define CheckContinuableErrorEx(EXPR, HANDLER, TOKEN) \
{ \
    HRESULT hrOnErr, hrExpr; \
    hrExpr  = EXPR; \
    \
    hrOnErr = OnError(hrExpr, HANDLER, TOKEN); \
    if (hrOnErr != S_OK) \
    { \
        if (hrOnErr == S_FALSE) \
        { \
            hr = hrExpr; \
        } \
        else if (SUCCEEDED(hrOnErr)) \
        { \
            hr = E_UNEXPECTED; \
        } \
        else if (FAILED(hrOnErr)) \
        { \
            hr = hrOnErr; \
        } \
        IfFailGo(hr); \
    } \
}


#endif // __NEWMERGER__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\regmeta.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// RegMeta.h
//
// This is the code for the MetaData coclass including both the emit and 
// import API's for version 1.
//
//*****************************************************************************
#ifndef __RegMeta__h__
#define __RegMeta__h__

#include <MetaModelRW.h>
#include <CorPerm.h>
#include "..\inc\mdlog.h"
#include "utsem.h"

#include "NewMerger.h"

#include "RWUtil.h"
#include "MDPerf.h"
#include <ivehandler.h>

#include <mscoree.h>

#ifdef _IA64_
#pragma pack(push, 8)
#endif // _IA64_

class FilterManager;

// Support for symbol binding meta data.  This is a custom value hung off of 
// the Module entry.  The CORDBG_SYMBOL_URL needs to be allocated on top of
// a buffer large enough to hold it.
//
#define SZ_CORDBG_SYMBOL_URL        L"DebugSymbolUrlData"

struct CORDBG_SYMBOL_URL
{
    GUID        FormatID;               // ID of the format type.
    WCHAR       rcName[2];              // Variable sized name of the item.

    ULONG Size() const
    {
        return (ULONG)(sizeof(GUID) + ((wcslen(rcName) + 1) * 2));
    }
};


//
// Open types.
//

enum SCOPETYPE  
{
    OpenForRead         = 0x1,
    OpenForWrite        = 0x2,
    DefineForWrite      = 0x4
};

// Set API caller type
enum SetAPICallerType
{
    DEFINE_API          = 0x1,
    EXTERNAL_CALLER     = 0x2
};

// Define the record entry for the table over which ValidateMetaData iterates over.
// Add a forward declaration for RegMeta.
class RegMeta;
typedef HRESULT (__stdcall RegMeta::*ValidateRecordFunction)(RID);

// Support for security attributes. Bundles of attributes (they look much like
// custom attributes) are passed into a single API (DefineSecurityAttributeSet)
// where they're processed and written into the metadata as one or more opaque
// blobs of data.
struct CORSEC_ATTR
{
    CORSEC_ATTR     *pNext;                 // Next structure in list or NULL.
    mdToken         tkObj;                  // The object to put the value on.
    mdMemberRef     tkCtor;                 // The security attribute constructor.
    mdTypeRef       tkTypeRef;              // Ref to the security attribute type.
    mdAssemblyRef   tkAssemblyRef;          // Ref to the assembly containing the security attribute class.
    void const      *pCustomAttribute;      // The custom value data.
    ULONG           cbCustomAttribute;      // The custom value data length.
};

// Support for "Pseudo Custom Attributes".     
struct CCustAttrHashKey
{
    mdToken     tkType;                 // Token of the custom attribute type.
    int         ca;                     // flag indicating what the ca is.
};

class CCustAttrHash : public CClosedHashEx<CCustAttrHashKey, CCustAttrHash>
{
    typedef CCustAttrHashKey T;
public:
    CCustAttrHash(int iBuckets=37) : CClosedHashEx<CCustAttrHashKey,CCustAttrHash>(iBuckets) {}
    unsigned long Hash(const T *pData);
    unsigned long Compare(const T *p1, T *p2);
    ELEMENTSTATUS Status(T *pEntry);
    void SetStatus(T *pEntry, ELEMENTSTATUS s);
    void* GetKey(T *pEntry);
};

class MDInternalRW;
struct CaArg;
struct CaNamedArg;

class RegMeta :
    public IMetaDataEmit,
    public IMetaDataImport,
    public IMetaDataAssemblyEmit,
    public IMetaDataAssemblyImport,
    public IMetaDataValidate,
    public IMetaDataFilter,
    public IMetaDataHelper,
    public IMetaDataTables,
    public IMetaDataEmitHelper
{
    friend class NEWMERGER;
    friend class CImportTlb;
    friend class MDInternalRW;
    friend class MDInternalRO;

public:
    RegMeta(OptionValue *pOptionValue, BOOL fAllocStgdb=TRUE);
    ~RegMeta();

//*****************************************************************************
// Init the object with pointers to what it needs to implement the methods.
//*****************************************************************************
    HRESULT Init();
    
    void Cleanup();

//*****************************************************************************
// Initialize with an existing stgdb.
//*****************************************************************************
    HRESULT RegMeta::InitWithStgdb(
        IUnknown            *pUnk,          // The IUnknown that owns the life time for the existing stgdb
        CLiteWeightStgdbRW *pStgdb);        // existing light weight stgdb

    ULONG   GetRefCount() { return m_cRef; }
    HRESULT AddToCache();
    
//*****************************************************************************
// IUnknown methods
//*****************************************************************************
    STDMETHODIMP    QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef(void); 
    STDMETHODIMP_(ULONG) Release(void);

//*****************************************************************************
// IMetaDataRegEmit methods
//*****************************************************************************
    STDMETHODIMP SetModuleProps(            // S_OK or error.
        LPCWSTR     szName);                // [IN] If not NULL, the name to set.

    STDMETHODIMP Save(                      // S_OK or error.
        LPCWSTR     szFile,                 // [IN] The filename to save to.
        DWORD       dwSaveFlags);           // [IN] Flags for the save.

    STDMETHODIMP SaveToStream(              // S_OK or error.
        IStream     *pIStream,              // [IN] A writable stream to save to.
        DWORD       dwSaveFlags);           // [IN] Flags for the save.

    STDMETHODIMP GetSaveSize(               // S_OK or error.
        CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
        DWORD       *pdwSaveSize);          // [OUT] Put the size here.

    STDMETHODIMP Merge(                     // S_OK or error.
        IMetaDataImport *pImport,           // [IN] The scope to be merged.
        IMapToken   *pHostMapToken,         // [IN] Host IMapToken interface to receive token remap notification
        IUnknown    *pHandler);             // [IN] An object to receive to receive error notification.

    STDMETHODIMP MergeEnd();                // S_OK or error.

    STDMETHODIMP DefineTypeDef(             // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   *ptd);                  // [OUT] Put TypeDef token here

    STDMETHODIMP SetHandler(                // S_OK.
        IUnknown    *pUnk);                 // [IN] The new error handler.


//*****************************************************************************
// IMetaDataRegImport methods
//*****************************************************************************
    void STDMETHODCALLTYPE CloseEnum(HCORENUM hEnum);
    STDMETHODIMP CountEnum(HCORENUM hEnum, ULONG *pulCount);
    STDMETHODIMP ResetEnum(HCORENUM hEnum, ULONG ulPos);
    STDMETHODIMP EnumTypeDefs(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
                            ULONG cMax, ULONG *pcTypeDefs);
    STDMETHODIMP EnumInterfaceImpls(HCORENUM *phEnum, mdTypeDef td,
                            mdInterfaceImpl rImpls[], ULONG cMax,
                            ULONG* pcImpls);
    STDMETHODIMP EnumTypeRefs(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
                            ULONG cMax, ULONG* pcTypeRefs);
    STDMETHODIMP FindTypeDefByName(         // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of the Type.
        mdToken     tdEncloser,             // [IN] TypeDef/TypeRef of Enclosing class.
        mdTypeDef   *ptd);                  // [OUT] Put the TypeDef token here.

    STDMETHODIMP GetScopeProps(             // S_OK or error.
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [IN] Size of name buffer in wide chars.
        ULONG       *pchName,               // [OUT] Put size of name (wide chars) here.
        GUID        *pmvid);                // [OUT] Put MVID here.

    STDMETHODIMP GetModuleFromScope(        // S_OK.
        mdModule    *pmd);                  // [OUT] Put mdModule token here.

    STDMETHODIMP GetTypeDefProps(           // S_OK or error.
        mdTypeDef   td,                     // [IN] TypeDef token for inquiry.
        LPWSTR      szTypeDef,              // [OUT] Put name here.
        ULONG       cchTypeDef,             // [IN] size of name buffer in wide chars.
        ULONG       *pchTypeDef,            // [OUT] put size of name (wide chars) here.
        DWORD       *pdwTypeDefFlags,       // [OUT] Put flags here.
        mdToken     *ptkExtends);           // [OUT] Put base class TypeDef/TypeRef here.

    STDMETHODIMP GetInterfaceImplProps(     // S_OK or error.
        mdInterfaceImpl iiImpl,             // [IN] InterfaceImpl token.
        mdTypeDef   *pClass,                // [OUT] Put implementing class token here.
        mdToken     *ptkIface);             // [OUT] Put implemented interface token here.

    STDMETHODIMP GetTypeRefProps(
        mdTypeRef   tr,                     // S_OK or error.
        mdToken     *ptkResolutionScope,    // [OUT] Resolution scope, mdModuleRef or mdAssemblyRef.
        LPWSTR      szName,                 // [OUT] Name buffer.
        ULONG       cchName,                // [IN] Size of Name buffer.
        ULONG       *pchName);              // [OUT] Actual size of Name.

    STDMETHODIMP ResolveTypeRef(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd);


//*****************************************************************************
// IMetaDataEmit
//*****************************************************************************
    STDMETHODIMP DefineMethod(              // S_OK or error.
        mdTypeDef   td,                     // Parent TypeDef
        LPCWSTR     szName,                 // Name of member
        DWORD       dwMethodFlags,          // Member attributes
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        ULONG       ulCodeRVA,
        DWORD       dwImplFlags,
        mdMethodDef *pmd);                  // Put member token here

    STDMETHODIMP DefineMethodImpl(          // S_OK or error.
        mdTypeDef   td,                     // [IN] The class implementing the method   
        mdToken     tkBody,                 // [IN] Method body, MethodDef or MethodRef
        mdToken     tkDecl);                // [IN] Method declaration, MethodDef or MethodRef

    STDMETHODIMP SetMethodImplFlags(        // [IN] S_OK or error.  
        mdMethodDef md,                     // [IN] Method for which to set impl flags  
        DWORD       dwImplFlags);  
    
    STDMETHODIMP SetFieldRVA(               // [IN] S_OK or error.  
        mdFieldDef  fd,                     // [IN] Field for which to set offset  
        ULONG       ulRVA);             // [IN] The offset  

    STDMETHODIMP DefineTypeRefByName(       // S_OK or error.
        mdToken     tkResolutionScope,      // [IN] ModuleRef or AssemblyRef.
        LPCWSTR     szName,                 // [IN] Name of the TypeRef.
        mdTypeRef   *ptr);                  // [OUT] Put TypeRef token here.

    STDMETHODIMP DefineImportType(          // S_OK or error.
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the TypeDef.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *pImport,           // [IN] Scope containing the TypeDef.
        mdTypeDef   tdImport,               // [IN] The imported TypeDef.
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the TypeDef is imported.
        mdTypeRef   *ptr);                  // [OUT] Put TypeRef token here.

    STDMETHODIMP DefineMemberRef(           // S_OK or error
        mdToken     tkImport,               // [IN] ClassRef or ClassDef importing a member.
        LPCWSTR     szName,                 // [IN] member's name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        mdMemberRef *pmr);                  // [OUT] memberref token

    STDMETHODIMP DefineImportMember(        // S_OK or error.
        IMetaDataAssemblyImport *pAssemImport,  // [IN] Assemby containing the Member.
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *pImport,           // [IN] Import scope, with member.
        mdToken     mbMember,               // [IN] Member in import scope.
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] Assembly into which the Member is imported.
        mdToken     tkImport,               // [IN] Classref or classdef in emit scope.
        mdMemberRef *pmr);                  // [OUT] Put member ref here.

    STDMETHODIMP DefineEvent(
        mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined
        LPCWSTR     szEvent,                // [IN] Name of the event
        DWORD       dwEventFlags,           // [IN] CorEventAttr
        mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef(to the Event class
        mdMethodDef mdAddOn,                // [IN] required add method
        mdMethodDef mdRemoveOn,             // [IN] required remove method
        mdMethodDef mdFire,                 // [IN] optional fire method
        mdMethodDef rmdOtherMethods[],      // [IN] optional array of other methods associate with the event
        mdEvent     *pmdEvent);             // [OUT] output event token

    STDMETHODIMP SetClassLayout(
        mdTypeDef   td,                     // [IN] typedef
        DWORD       dwPackSize,             // [IN] packing size specified as 1, 2, 4, 8, or 16
        COR_FIELD_OFFSET rFieldOffsets[],   // [IN] array of layout specification
        ULONG       ulClassSize);           // [IN] size of the class

    STDMETHODIMP DeleteClassLayout(
        mdTypeDef   td);                    // [IN] typdef token

    STDMETHODIMP SetFieldMarshal(
        mdToken     tk,                     // [IN] given a fieldDef or paramDef token
        PCCOR_SIGNATURE pvNativeType,       // [IN] native type specification
        ULONG       cbNativeType);          // [IN] count of bytes of pvNativeType

    STDMETHODIMP DeleteFieldMarshal(
        mdToken     tk);                    // [IN] fieldDef or paramDef token to be deleted.

    STDMETHODIMP DefinePermissionSet(
        mdToken     tk,                     // [IN] the object to be decorated.
        DWORD       dwAction,               // [IN] CorDeclSecurity.
        void const  *pvPermission,          // [IN] permission blob.
        ULONG       cbPermission,           // [IN] count of bytes of pvPermission.
        mdPermission *ppm);                 // [OUT] returned permission token.

    STDMETHODIMP SetRVA(                    // [IN] S_OK or error.
        mdToken     md,                     // [IN] MethodDef for which to set offset
        ULONG       ulRVA);                 // [IN] The offset#endif

    STDMETHODIMP GetTokenFromSig(           // [IN] S_OK or error.
        PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.
        ULONG       cbSig,                  // [IN] Size of signature data.
        mdSignature *pmsig);                // [OUT] returned signature token.

    STDMETHODIMP DefineModuleRef(           // S_OK or error.
        LPCWSTR     szName,                 // [IN] DLL name
        mdModuleRef *pmur);                 // [OUT] returned module ref token

    STDMETHODIMP SetParent(                 // S_OK or error.
        mdMemberRef mr,                     // [IN] Token for the ref to be fixed up.
        mdToken     tk);                    // [IN] The ref parent.

    STDMETHODIMP GetTokenFromTypeSpec(      // S_OK or error.
        PCCOR_SIGNATURE pvSig,              // [IN] ArraySpec Signature to define.
        ULONG       cbSig,                  // [IN] Size of signature data.
        mdTypeSpec *ptypespec);             // [OUT] returned TypeSpec token.
        
    STDMETHODIMP SaveToMemory(              // S_OK or error.
        void        *pbData,                // [OUT] Location to write data.
        ULONG       cbData);                // [IN] Max size of data buffer.

    STDMETHODIMP SetSymbolBindingPath(      // S_OK or error.
        REFGUID     FormatID,               // [IN] Symbol data format ID.
        LPCWSTR     szSymbolDataPath);      // [IN] URL for the symbols of this module.

    STDMETHODIMP DefineUserString(          // S_OK or error.
        LPCWSTR     szString,               // [IN] User literal string.
        ULONG       cchString,              // [IN] Length of string.
        mdString    *pstk);                 // [OUT] String token.

    STDMETHODIMP DeleteToken(               // Return code.
        mdToken     tkObj);                 // [IN] The token to be deleted

    STDMETHODIMP SetTypeDefProps(           // S_OK or error.
        mdTypeDef   td,                     // [IN] The TypeDef.
        DWORD       dwTypeDefFlags,         // [IN] TypeDef flags.
        mdToken     tkExtends,              // [IN] Base TypeDef or TypeRef.
        mdToken     rtkImplements[]);       // [IN] Implemented interfaces.

    STDMETHODIMP DefineNestedType(          // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   tdEncloser,             // [IN] TypeDef token of the enclosing type.
        mdTypeDef   *ptd);                  // [OUT] Put TypeDef token here

    STDMETHODIMP SetMethodProps(            // S_OK or error.
        mdMethodDef md,                     // [IN] The MethodDef.
        DWORD       dwMethodFlags,          // [IN] Method attributes.
        ULONG       ulCodeRVA,              // [IN] Code RVA.
        DWORD       dwImplFlags);           // [IN] MethodImpl flags.

    STDMETHODIMP SetEventProps(             // S_OK or error.
        mdEvent     ev,                     // [IN] The event token.
        DWORD       dwEventFlags,           // [IN] CorEventAttr.
        mdToken     tkEventType,            // [IN] A reference (mdTypeRef or mdTypeRef) to the Event class.
        mdMethodDef mdAddOn,                // [IN] Add method.
        mdMethodDef mdRemoveOn,             // [IN] Remove method.
        mdMethodDef mdFire,                 // [IN] Fire method.
        mdMethodDef rmdOtherMethods[]);     // [IN] Array of other methods associate with the event.

    STDMETHODIMP SetPermissionSetProps(     // S_OK or error.
        mdToken     tk,                     // [IN] The object to be decorated.
        DWORD       dwAction,               // [IN] CorDeclSecurity.
        void const  *pvPermission,          // [IN] Permission blob.
        ULONG       cbPermission,           // [IN] Count of bytes of pvPermission.
        mdPermission *ppm);                 // [OUT] Permission token.

    STDMETHODIMP DefinePinvokeMap(          // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL);           // [IN] ModuleRef token for the target DLL.

    STDMETHODIMP SetPinvokeMap(             // Return code.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL);           // [IN] ModuleRef token for the target DLL.

    STDMETHODIMP DeletePinvokeMap(          // Return code.
        mdToken     tk);                    // [IN]FieldDef or MethodDef.

    STDMETHODIMP DefineCustomAttribute(     // Return code.
        mdToken     tkObj,                  // [IN] The object to put the value on.
        mdToken     tkType,                 // [IN] Type of the CustomAttribute (TypeRef/TypeDef).
        void const  *pCustomAttribute,          // [IN] The custom value data.
        ULONG       cbCustomAttribute,          // [IN] The custom value data length.
        mdCustomAttribute *pcv);                // [OUT] The custom value token value on return.

    STDMETHODIMP SetCustomAttributeValue(   // Return code.
        mdCustomAttribute pcv,                  // [IN] The custom value token whose value to replace.
        void const  *pCustomAttribute,          // [IN] The custom value data.
        ULONG       cbCustomAttribute);         // [IN] The custom value data length.

    STDMETHODIMP DefineField(               // S_OK or error. 
        mdTypeDef   td,                     // Parent TypeDef   
        LPCWSTR     szName,                 // Name of member   
        DWORD       dwFieldFlags,           // Member attributes    
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdFieldDef  *pmd);                  // [OUT] Put member token here    

    STDMETHODIMP DefineProperty( 
        mdTypeDef   td,                     // [IN] the class/interface on which the property is being defined  
        LPCWSTR     szProperty,             // [IN] Name of the property    
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr 
        PCCOR_SIGNATURE pvSig,              // [IN] the required type signature 
        ULONG       cbSig,                  // [IN] the size of the type signature blob 
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] optional setter of the property 
        mdMethodDef mdGetter,               // [IN] optional getter of the property 
        mdMethodDef rmdOtherMethods[],      // [IN] an optional array of other methods  
        mdProperty  *pmdProp);              // [OUT] output property token  

    STDMETHODIMP DefineParam(
        mdMethodDef md,                     // [IN] Owning method   
        ULONG       ulParamSeq,             // [IN] Which param 
        LPCWSTR     szName,                 // [IN] Optional param name 
        DWORD       dwParamFlags,           // [IN] Optional param flags    
        DWORD       dwCPlusTypeFlag,        // [IN] flag for value type. selected ELEMENT_TYPE_*    
        void const  *pValue,                // [IN] constant value  
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdParamDef  *ppd);                  // [OUT] Put param token here   

    STDMETHODIMP SetFieldProps(             // S_OK or error.
        mdFieldDef  fd,                     // [IN] The FieldDef.
        DWORD       dwFieldFlags,           // [IN] Field attributes.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue);              // [IN] size of constant value (string, in wide chars).

    STDMETHODIMP SetPropertyProps(          // S_OK or error.
        mdProperty  pr,                     // [IN] Property token.
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] Setter of the property.
        mdMethodDef mdGetter,               // [IN] Getter of the property.
        mdMethodDef rmdOtherMethods[]);     // [IN] Array of other methods.

    STDMETHODIMP SetParamProps(             // Return code.
        mdParamDef  pd,                     // [IN] Param token.   
        LPCWSTR     szName,                 // [IN] Param name.
        DWORD       dwParamFlags,           // [IN] Param flags.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
        void const  *pValue,                // [OUT] Constant value.
        ULONG       cchValue);              // [IN] size of constant value (string, in wide chars).

    STDMETHODIMP ApplyEditAndContinue(      // S_OK or error.
        IUnknown    *pImport);          // [IN] Metadata from the delta PE.

    // Specialized Custom Attributes for security.
    STDMETHODIMP DefineSecurityAttributeSet(// Return code.
        mdToken     tkObj,                  // [IN] Class or method requiring security attributes.
        COR_SECATTR rSecAttrs[],            // [IN] Array of security attribute descriptions.
        ULONG       cSecAttrs,              // [IN] Count of elements in above array.
        ULONG       *pulErrorAttr);         // [OUT] On error, index of attribute causing problem.

//*****************************************************************************
// IMetaDataImport
//*****************************************************************************
    STDMETHODIMP EnumMembers(               // S_OK, S_FALSE, or error.
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.
        ULONG       cMax,                   // [IN] Max MemberDefs to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumMembersWithName(       // S_OK, S_FALSE, or error.         
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.               
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.             
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.                
        ULONG       cMax,                   // [IN] Max MemberDefs to put.             
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHODIMP EnumMethods(               // S_OK, S_FALSE, or error.
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.
        mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.
        ULONG       cMax,                   // [IN] Max MethodDefs to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumMethodsWithName(       // S_OK, S_FALSE, or error.         
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.               
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.             
        mdMethodDef rMethods[],             // [OU] Put MethodDefs here.                
        ULONG       cMax,                   // [IN] Max MethodDefs to put.             
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHODIMP EnumFields(                // S_OK, S_FALSE, or error.
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.
        mdFieldDef  rFields[],              // [OUT] Put FieldDefs here.
        ULONG       cMax,                   // [IN] Max FieldDefs to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumFieldsWithName(        // S_OK, S_FALSE, or error.        
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.               
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.             
        mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                
        ULONG       cMax,                   // [IN] Max MemberDefs to put.             
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    
    STDMETHODIMP EnumParams(                // S_OK, S_FALSE, or error.
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration.
        mdParamDef  rParams[],              // [OUT] Put ParamDefs here.
        ULONG       cMax,                   // [IN] Max ParamDefs to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumMemberRefs(            // S_OK, S_FALSE, or error.
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdToken     tkParent,               // [IN] Parent token to scope the enumeration.
        mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.
        ULONG       cMax,                   // [IN] Max MemberRefs to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumMethodImpls(           // S_OK, S_FALSE, or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.
        mdToken     rMethodBody[],          // [OUT] Put Method Body tokens here.   
        mdToken     rMethodDecl[],          // [OUT] Put Method Declaration tokens here.
        ULONG       cMax,                   // [IN] Max tokens to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumPermissionSets(        // S_OK, S_FALSE, or error.
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.
        DWORD       dwActions,              // [IN] if !0, return only these actions.
        mdPermission rPermission[],         // [OUT] Put Permissions here.
        ULONG       cMax,                   // [IN] Max Permissions to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP FindMember(
        mdTypeDef   td,                     // [IN] given typedef
        LPCWSTR     szName,                 // [IN] member name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        mdToken     *pmb);                  // [OUT] matching memberdef

    STDMETHODIMP FindMethod(
        mdTypeDef   td,                     // [IN] given typedef
        LPCWSTR     szName,                 // [IN] member name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        mdMethodDef *pmb);                  // [OUT] matching memberdef

    STDMETHODIMP FindField(
        mdTypeDef   td,                     // [IN] given typedef
        LPCWSTR     szName,                 // [IN] member name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        mdFieldDef  *pmb);                  // [OUT] matching memberdef

    STDMETHODIMP FindMemberRef(
        mdTypeRef   td,                     // [IN] given typeRef
        LPCWSTR     szName,                 // [IN] member name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        mdMemberRef *pmr);                  // [OUT] matching memberref

    STDMETHODIMP GetMethodProps(
        mdMethodDef mb,                     // The method for which to get props.
        mdTypeDef   *pClass,                // Put method's class here.
        LPWSTR      szMethod,               // Put method's name here.
        ULONG       cchMethod,              // Size of szMethod buffer in wide chars.
        ULONG       *pchMethod,             // Put actual size here
        DWORD       *pdwAttr,               // Put flags here.
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob
        ULONG       *pulCodeRVA,            // [OUT] codeRVA
        DWORD       *pdwImplFlags);         // [OUT] Impl. Flags

    STDMETHODIMP GetMemberRefProps(         // S_OK or error.
        mdMemberRef mr,                     // [IN] given memberref
        mdToken     *ptk,                   // [OUT] Put classref or classdef here.
        LPWSTR      szMember,               // [OUT] buffer to fill for member's name
        ULONG       cchMember,              // [IN] the count of char of szMember
        ULONG       *pchMember,             // [OUT] actual count of char in member name
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value
        ULONG       *pbSig);                // [OUT] actual size of signature blob

    STDMETHODIMP EnumProperties(            // S_OK, S_FALSE, or error.
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.
        mdProperty  rProperties[],          // [OUT] Put Properties here.
        ULONG       cMax,                   // [IN] Max properties to put.
        ULONG       *pcProperties);         // [OUT] Put # put here.

    STDMETHODIMP EnumEvents(                // S_OK, S_FALSE, or error.
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.
        mdEvent     rEvents[],              // [OUT] Put events here.
        ULONG       cMax,                   // [IN] Max events to put.
        ULONG       *pcEvents);             // [OUT] Put # put here.

    STDMETHODIMP GetEventProps(             // S_OK, S_FALSE, or error.
        mdEvent     ev,                     // [IN] event token
        mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.
        LPCWSTR     szEvent,                // [OUT] Event name
        ULONG       cchEvent,               // [IN] the count of wchar of szEvent
        ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name
        DWORD       *pdwEventFlags,         // [OUT] Event flags.
        mdToken     *ptkEventType,          // [OUT] EventType class
        mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event
        mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event
        mdMethodDef *pmdFire,               // [OUT] Fire method of the event
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event
        ULONG       cMax,                   // [IN] size of rmdOtherMethod
        ULONG       *pcOtherMethod);        // [OUT] total number of other method of this event

    STDMETHODIMP EnumMethodSemantics(       // S_OK, S_FALSE, or error.
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration.
        mdToken     rEventProp[],           // [OUT] Put Event/Property here.
        ULONG       cMax,                   // [IN] Max properties to put.
        ULONG       *pcEventProp);          // [OUT] Put # put here.

    STDMETHODIMP GetMethodSemantics(        // S_OK, S_FALSE, or error.
        mdMethodDef mb,                     // [IN] method token
        mdToken     tkEventProp,            // [IN] event/property token.
        DWORD       *pdwSemanticsFlags);    // [OUT] the role flags for the method/propevent pair

    STDMETHODIMP GetClassLayout(
        mdTypeDef   td,                     // [IN] give typedef
        DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16
        COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array
        ULONG       cMax,                   // [IN] size of the array
        ULONG       *pcFieldOffset,         // [OUT] needed array size
        ULONG       *pulClassSize);         // [OUT] the size of the class

    STDMETHODIMP GetFieldMarshal(
        mdToken     tk,                     // [IN] given a field's memberdef
        PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field
        ULONG       *pcbNativeType);        // [OUT] the count of bytes of *ppvNativeType

    STDMETHODIMP GetRVA(                    // S_OK or error.
        mdToken     tk,                     // Member for which to set offset
        ULONG       *pulCodeRVA,            // The offset
        DWORD       *pdwImplFlags);         // the implementation flags

    STDMETHODIMP GetPermissionSetProps(
        mdPermission pm,                    // [IN] the permission token.
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.
        void const  **ppvPermission,        // [OUT] permission blob.
        ULONG       *pcbPermission);        // [OUT] count of bytes of pvPermission.

    STDMETHODIMP GetSigFromToken(           // S_OK or error.
        mdSignature mdSig,                  // [IN] Signature token.
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.
        ULONG       *pcbSig);               // [OUT] return size of signature.

    STDMETHODIMP GetModuleRefProps(         // S_OK or error.
        mdModuleRef mur,                    // [IN] moduleref token.
        LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.
        ULONG       cchName,                // [IN] size of szName in wide characters.
        ULONG       *pchName);              // [OUT] actual count of characters in the name.

    STDMETHODIMP EnumModuleRefs(            // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.
        mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.
        ULONG       cmax,                   // [IN] max memberrefs to put.
        ULONG       *pcModuleRefs);         // [OUT] put # put here.

    STDMETHODIMP GetTypeSpecFromToken(      // S_OK or error.
        mdTypeSpec typespec,                // [IN] TypeSpec token.
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to TypeSpec signature
        ULONG       *pcbSig);               // [OUT] return size of signature.
    
    STDMETHODIMP GetNameFromToken(          // S_OK or error.
        mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
        MDUTF8CSTR  *pszUtf8NamePtr);       // [OUT] Return pointer to UTF8 name in heap.

    STDMETHODIMP GetSymbolBindingPath(      // S_OK or error.
        GUID        *pFormatID,             // [OUT] Symbol data format ID.
        LPWSTR      szSymbolDataPath,       // [OUT] Path of symbols.
        ULONG       cchSymbolDataPath,      // [IN] Max characters for output buffer.
        ULONG       *pcbSymbolDataPath);    // [OUT] Number of chars in actual name.

    STDMETHODIMP EnumUnresolvedMethods(     // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHODIMP GetUserString(             // S_OK or error.
        mdString    stk,                    // [IN] String token.
        LPWSTR      szString,               // [OUT] Copy of string.
        ULONG       cchString,              // [IN] Max chars of room in szString.
        ULONG       *pchString);            // [OUT] How many chars in actual string.

    STDMETHODIMP GetPinvokeMap(             // S_OK or error.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
        LPWSTR      szImportName,           // [OUT] Import name.
        ULONG       cchImportName,          // [IN] Size of the name buffer.
        ULONG       *pchImportName,         // [OUT] Actual number of characters stored.
        mdModuleRef *pmrImportDLL);         // [OUT] ModuleRef token for the target DLL.

    STDMETHODIMP EnumSignatures(            // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdSignature rSignatures[],          // [OUT] put signatures here.   
        ULONG       cmax,                   // [IN] max signatures to put.  
        ULONG       *pcSignatures);         // [OUT] put # put here.

    STDMETHODIMP EnumTypeSpecs(             // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdTypeSpec  rTypeSpecs[],           // [OUT] put TypeSpecs here.   
        ULONG       cmax,                   // [IN] max TypeSpecs to put.  
        ULONG       *pcTypeSpecs);          // [OUT] put # put here.

    STDMETHODIMP EnumUserStrings(           // S_OK or error.
        HCORENUM    *phEnum,                // [IN/OUT] pointer to the enum.
        mdString    rStrings[],             // [OUT] put Strings here.
        ULONG       cmax,                   // [IN] max Strings to put.
        ULONG       *pcStrings);            // [OUT] put # put here.

    STDMETHODIMP GetParamForMethodIndex(    // S_OK or error.
        mdMethodDef md,                     // [IN] Method token.
        ULONG       ulParamSeq,             // [IN] Parameter sequence.
        mdParamDef  *ppd);                  // [IN] Put Param token here.

    STDMETHODIMP GetCustomAttributeByName(  // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCWSTR     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData);              // [OUT] Put size of data here.

    STDMETHODIMP EnumCustomAttributes(      // S_OK or error.
        HCORENUM    *phEnum,                // [IN, OUT] COR enumerator.
        mdToken     tk,                     // [IN] Token to scope the enumeration, 0 for all.
        mdToken     tkType,                 // [IN] Type of interest, 0 for all.
        mdCustomAttribute rCustomAttributes[],      // [OUT] Put custom attribute tokens here.
        ULONG       cMax,                   // [IN] Size of rCustomAttributes.
        ULONG       *pcCustomAttributes);       // [OUT, OPTIONAL] Put count of token values here.

    STDMETHODIMP GetCustomAttributeProps(   // S_OK or error.
        mdCustomAttribute cv,                   // [IN] CustomAttribute token.
        mdToken     *ptkObj,                // [OUT, OPTIONAL] Put object token here.
        mdToken     *ptkType,               // [OUT, OPTIONAL] Put AttrType token here.
        void const  **ppBlob,               // [OUT, OPTIONAL] Put pointer to data here.
        ULONG       *pcbSize);              // [OUT, OPTIONAL] Put size of date here.

    STDMETHODIMP FindTypeRef(               // S_OK or error.
        mdToken     tkResolutionScope,      // ResolutionScope.
        LPCWSTR     szName,                 // [IN] TypeRef name.
        mdTypeRef   *ptr);                  // [OUT] matching TypeRef.

    STDMETHODIMP GetMemberProps(
        mdToken     mb,                     // The member for which to get props.   
        mdTypeDef   *pClass,                // Put member's class here. 
        LPWSTR      szMember,               // Put member's name here.  
        ULONG       cchMember,              // Size of szMember buffer in wide chars.   
        ULONG       *pchMember,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcbValue);             // [OUT] size of constant value

    STDMETHODIMP GetFieldProps(  
        mdFieldDef  mb,                     // The field for which to get props.    
        mdTypeDef   *pClass,                // Put field's class here.  
        LPWSTR      szField,                // Put field's name here.   
        ULONG       cchField,               // Size of szField buffer in wide chars.    
        ULONG       *pchField,              // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcbValue);             // [OUT] size of constant value

    STDMETHODIMP GetPropertyProps(          // S_OK, S_FALSE, or error. 
        mdProperty  prop,                   // [IN] property token  
        mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
        LPCWSTR     szProperty,             // [OUT] Property name  
        ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
        ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
        DWORD       *pdwPropFlags,          // [OUT] property flags.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
        ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppDefaultValue,       // [OUT] constant value 
        ULONG       *pcbValue,              // [OUT] size of constant value
        mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
        mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod);        // [OUT] total number of other method of this property  

    STDMETHODIMP GetParamProps(             // S_OK or error.
        mdParamDef  tk,                     // [IN]The Parameter.
        mdMethodDef *pmd,                   // [OUT] Parent Method token.
        ULONG       *pulSequence,           // [OUT] Parameter sequence.
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [OUT] Size of name buffer.
        ULONG       *pchName,               // [OUT] Put actual size of name here.
        DWORD       *pdwAttr,               // [OUT] Put flags here.
        DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
        void const  **ppValue,              // [OUT] Constant value.
        ULONG       *pcbValue);             // [OUT] size of constant value

    STDMETHODIMP_(BOOL) IsValidToken(       // True or False.
        mdToken     tk);                    // [IN] Given token.

    STDMETHODIMP GetNestedClassProps(       // S_OK or error.
        mdTypeDef   tdNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptdEnclosingClass);    // [OUT] EnclosingClass token.

    STDMETHODIMP GetNativeCallConvFromSig(  // S_OK or error.
        void const  *pvSig,                 // [IN] Pointer to signature.
        ULONG       cbSig,                  // [IN] Count of signature bytes.
        ULONG       *pCallConv);            // [OUT] Put calling conv here (see CorPinvokemap).                                                                                        
    
    STDMETHODIMP IsGlobal(                  // S_OK or error.
        mdToken     pd,                     // [IN] Type, Field, or Method token.
        int         *pbGlobal);             // [OUT] Put 1 if global, 0 otherwise.

//*****************************************************************************
// IMetaDataAssemblyEmit
//*****************************************************************************
    STDMETHODIMP DefineAssembly(            // S_OK or error.
        const void  *pbPublicKey,           // [IN] Public key of the assembly.
        ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
        ULONG       ulHashAlgId,            // [IN] Hash Algorithm.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags,        // [IN] Flags.
        mdAssembly  *pma);                  // [OUT] Returned Assembly token.

    STDMETHODIMP DefineAssemblyRef(         // S_OK or error.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags,     // [IN] Token for Execution Location.
        mdAssemblyRef *pmar);               // [OUT] Returned AssemblyRef token.

    STDMETHODIMP DefineFile(                // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the file.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags,            // [IN] Flags.
        mdFile      *pmf);                  // [OUT] Returned File token.

    STDMETHODIMP DefineExportedType(        // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the Com Type.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the ExportedType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags,    // [IN] Flags.
        mdExportedType   *pmct);            // [OUT] Returned ExportedType token.

    STDMETHODIMP DefineManifestResource(    // S_OK or error.
        LPCWSTR     szName,                 // [IN] Name of the resource.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags,        // [IN] Flags.
        mdManifestResource  *pmmr);         // [OUT] Returned ManifestResource token.

    STDMETHODIMP SetAssemblyProps(          // S_OK or error.
        mdAssembly  pma,                    // [IN] Assembly token.
        const void  *pbPublicKey,           // [IN] Public key of the assembly.
        ULONG       cbPublicKey,            // [IN] Count of bytes in the public key.
        ULONG       ulHashAlgId,            // [IN] Hash Algorithm.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags);       // [IN] Flags.
    
    STDMETHODIMP SetAssemblyRefProps(       // S_OK or error.
        mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags);    // [IN] Token for Execution Location.

    STDMETHODIMP SetFileProps(              // S_OK or error.
        mdFile      file,                   // [IN] File token.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags);           // [IN] Flags.

    STDMETHODIMP SetExportedTypeProps(      // S_OK or error.
        mdExportedType   ct,                // [IN] ExportedType token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the ExportedType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags);   // [IN] Flags.

    STDMETHODIMP SetManifestResourceProps(  // S_OK or error.
        mdManifestResource  mr,             // [IN] ManifestResource token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags);       // [IN] Flags.

//*****************************************************************************
// IMetaDataAssemblyImport
//*****************************************************************************
    STDMETHODIMP GetAssemblyProps(          // S_OK or error.
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
        ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        DWORD       *pdwAssemblyFlags);     // [OUT] Flags.

    STDMETHODIMP GetAssemblyRefProps(       // S_OK or error.
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
        ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        DWORD       *pdwAssemblyRefFlags);  // [OUT] Flags.

    STDMETHODIMP GetFileProps(              // S_OK or error.
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags);         // [OUT] Flags.

    STDMETHODIMP GetExportedTypeProps(      // S_OK or error.
        mdExportedType   mdct,              // [IN] The ExportedType for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        DWORD       *pdwExportedTypeFlags); // [OUT] Flags.

    STDMETHODIMP GetManifestResourceProps(  // S_OK or error.
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        DWORD       *pdwResourceFlags);     // [OUT] Flags.

    STDMETHODIMP EnumAssemblyRefs(          // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
        ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumFiles(                 // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdFile      rFiles[],               // [OUT] Put Files here.
        ULONG       cMax,                   // [IN] Max Files to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumExportedTypes(              // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdExportedType   rExportedTypes[],            // [OUT] Put ExportedTypes here.
        ULONG       cMax,                   // [IN] Max ExportedTypes to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumManifestResources(     // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
        ULONG       cMax,                   // [IN] Max Resources to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP FindExportedTypeByName(         // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ExportedType.
        mdExportedType   tkEnclosingType,        // [IN] Enclosing ExportedType.
        mdExportedType   *ptkExportedType);           // [OUT] Put the ExportedType token here.

    STDMETHODIMP FindManifestResourceByName(// S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
        mdManifestResource *ptkManifestResource);   // [OUT] Put the ManifestResource token here.

    STDMETHODIMP GetAssemblyFromScope(      // S_OK or error
        mdAssembly  *ptkAssembly);          // [OUT] Put token here.

    STDMETHODIMP FindAssembliesByName(      // S_OK or error
         LPCWSTR  szAppBase,                // [IN] optional - can be NULL
         LPCWSTR  szPrivateBin,             // [IN] optional - can be NULL
         LPCWSTR  szAssemblyName,           // [IN] required - this is the assembly you are requesting
         IUnknown *ppIUnk[],                // [OUT] put IMetaDataAssemblyImport pointers here
         ULONG    cMax,                     // [IN] The max number to put
         ULONG    *pcAssemblies);           // [OUT] The number of assemblies returned.

//*****************************************************************************
// IMetaDataFilter
//*****************************************************************************
    STDMETHODIMP UnmarkAll();               // unmark everything in a module

    STDMETHODIMP MarkToken(
        mdToken     tk);                    // [IN] Token to be marked

    STDMETHODIMP IsTokenMarked(
        mdToken     tk,                     // [IN] Token to be checked
        BOOL        *pIsMarked);            // [OUT] TRUE if token is marked

//*****************************************************************************
// IMetaDataValidator
//*****************************************************************************
    STDMETHODIMP ValidatorInit(             // S_OK or error.
        DWORD       dwModuleType,           // [IN] Specifies whether the module is a PE file or an obj.
        IUnknown    *pUnk);                 // [IN] Validation error handler.

    STDMETHODIMP ValidateMetaData();  
//*****************************************************************************
// IMetaDataEmitHelper
//***************************************************************************** 
    STDMETHODIMP DefineMethodSemanticsHelper(
        mdToken     tkAssociation,          // [IN] property or event token
        DWORD       dwFlags,                // [IN] semantics
        mdMethodDef md);                    // [IN] method to associated with

    STDMETHODIMP SetFieldLayoutHelper(      // Return hresult.
        mdFieldDef  fd,                     // [IN] field to associate the layout info
        ULONG       ulOffset);              // [IN] the offset for the field

    STDMETHODIMP DefineEventHelper(    
        mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
        LPCWSTR     szEvent,                // [IN] Name of the event   
        DWORD       dwEventFlags,           // [IN] CorEventAttr    
        mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
        mdEvent     *pmdEvent);             // [OUT] output event token 

    STDMETHODIMP AddDeclarativeSecurityHelper(
        mdToken     tk,                     // [IN] Parent token (typedef/methoddef)
        DWORD       dwAction,               // [IN] Security action (CorDeclSecurity)
        void const  *pValue,                // [IN] Permission set blob
        DWORD       cbValue,                // [IN] Byte count of permission set blob
        mdPermission*pmdPermission);        // [OUT] Output permission token

    STDMETHODIMP SetResolutionScopeHelper(  // Return hresult.
        mdTypeRef   tr,                     // [IN] TypeRef record to update
        mdToken     rs);                    // [IN] new ResolutionScope 

    STDMETHODIMP SetManifestResourceOffsetHelper(  // Return hresult.
        mdManifestResource mr,              // [IN] The manifest token
        ULONG       ulOffset);              // [IN] new offset 

    STDMETHODIMP SetTypeParent(             // Return hresult.
        mdTypeDef   td,                     // [IN] Type definition
        mdToken     tkExtends);             // [IN] parent type

    STDMETHODIMP AddInterfaceImpl(          // Return hresult.
        mdTypeDef   td,                     // [IN] Type definition
        mdToken     tkInterface);           // [IN] interface type

//*****************************************************************************
// IMetaDataHelper
//*****************************************************************************
    STDMETHODIMP TranslateSigWithScope(
        IMetaDataAssemblyImport *pAssemImport, // [IN] assembly importing interface
        const void  *pbHashValue,           // [IN] Hash Blob for Assembly.
        ULONG       cbHashValue,            // [IN] Count of bytes.
        IMetaDataImport *import,            // [IN] importing interface
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmti,  // [IN] emit assembly interface
        IMetaDataEmit *emit,                // [IN] emit interface
        PCOR_SIGNATURE pvTranslatedSig,     // [OUT] buffer to hold translated signature
        ULONG       cbTranslatedSigMax,
        ULONG       *pcbTranslatedSig);     // [OUT] count of bytes in the translated signature

    STDMETHODIMP ConvertTextSigToComSig(    // Return hresult.
        IMetaDataEmit *emit,                // [IN] emit interface
        BOOL        fCreateTrIfNotFound,    // [IN] create typeref if not found
        LPCSTR      pSignature,             // [IN] class file format signature
        CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
        ULONG       *pcbCount);             // [OUT] the result size of signature

    STDMETHODIMP ExportTypeLibFromModule(   // Result.
        LPCWSTR     szModule,               // [IN] Module name.
        LPCWSTR     szTlb,                  // [IN] TypeLib name.
        BOOL        bRegister);             // [IN] Set to TRUE to have the typelib be registered.

    STDMETHODIMP GetMetadata(               // Result.
        ULONG       ulSelect,               // [IN] Selector.
        void        **ppData);              // [OUT] Put pointer to data here.

    STDMETHODIMP_(IUnknown *) GetCachedInternalInterface(BOOL fWithLock);   // S_OK or error
    STDMETHODIMP SetCachedInternalInterface(IUnknown *pUnk);    // S_OK or error
    STDMETHODIMP SetReaderWriterLock(UTSemReadWrite * pSem) { _ASSERTE(m_pSemReadWrite == NULL); m_pSemReadWrite = pSem; return NOERROR;}
    STDMETHODIMP_(UTSemReadWrite *) GetReaderWriterLock() { return m_pSemReadWrite; }

    //--- IMetaDataTables
    STDMETHODIMP GetStringHeapSize(    
        ULONG   *pcbStrings);               // [OUT] Size of the string heap.

    STDMETHODIMP GetBlobHeapSize(    
        ULONG   *pcbBlobs);                 // [OUT] Size of the Blob heap.

    STDMETHODIMP GetGuidHeapSize(    
        ULONG   *pcbGuids);                 // [OUT] Size of the Guid heap.

    STDMETHODIMP GetUserStringHeapSize(    
        ULONG   *pcbStrings);               // [OUT] Size of the user string heap.

    STDMETHODIMP GetNumTables(    
        ULONG   *pcTables);                 // [OUT] Count of tables.

    STDMETHODIMP GetTableIndex(   
        ULONG   token,                      // [IN] Token for which to get table index.
        ULONG   *pixTbl);                   // [OUT] Put table index here.

    STDMETHODIMP GetTableInfo(    
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   *pcbRow,                    // [OUT] Size of a row, bytes.
        ULONG   *pcRows,                    // [OUT] Number of rows.
        ULONG   *pcCols,                    // [OUT] Number of columns in each row.
        ULONG   *piKey,                     // [OUT] Key column, or -1 if none.
        const char **ppName);               // [OUT] Name of the table.

    STDMETHODIMP GetColumnInfo(   
        ULONG   ixTbl,                      // [IN] Which Table
        ULONG   ixCol,                      // [IN] Which Column in the table
        ULONG   *poCol,                     // [OUT] Offset of the column in the row.
        ULONG   *pcbCol,                    // [OUT] Size of a column, bytes.
        ULONG   *pType,                     // [OUT] Type of the column.
        const char **ppName);               // [OUT] Name of the Column.

    STDMETHODIMP GetCodedTokenInfo(   
        ULONG   ixCdTkn,                    // [IN] Which kind of coded token.
        ULONG   *pcTokens,                  // [OUT] Count of tokens.
        ULONG   **ppTokens,                 // [OUT] List of tokens.
        const char **ppName);               // [OUT] Name of the CodedToken.

    STDMETHODIMP GetRow(      
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   rid,                        // [IN] Which row.
        void    **ppRow);                   // [OUT] Put pointer to row here.

    STDMETHODIMP GetColumn(   
        ULONG   ixTbl,                      // [IN] Which table.
        ULONG   ixCol,                      // [IN] Which column.
        ULONG   rid,                        // [IN] Which row.
        ULONG   *pVal);                     // [OUT] Put the column contents here.

    STDMETHODIMP GetString(   
        ULONG   ixString,                   // [IN] Value from a string column.
        const char **ppString);             // [OUT] Put a pointer to the string here.

    STDMETHODIMP GetBlob(     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pcbData,                   // [OUT] Put size of the blob here.
        const void **ppData);               // [OUT] Put a pointer to the blob here.

    STDMETHODIMP GetGuid(     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        const GUID **ppGUID);               // [OUT] Put a pointer to the GUID here.

    STDMETHODIMP GetUserString(   
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pcbData,                   // [OUT] Put size of the UserString here.
        const void **ppData);               // [OUT] Put a pointer to the UserString here.

    STDMETHODIMP GetNextString(   
        ULONG   ixString,                   // [IN] Value from a string column.
        ULONG   *pNext);                    // [OUT] Put the index of the next string here.

    STDMETHODIMP GetNextBlob(     
        ULONG   ixBlob,                     // [IN] Value from a blob column.
        ULONG   *pNext);                    // [OUT] Put the index of the netxt blob here.

    STDMETHODIMP GetNextGuid(     
        ULONG   ixGuid,                     // [IN] Value from a guid column.
        ULONG   *pNext);                    // [OUT] Put the index of the next guid here.

    STDMETHODIMP GetNextUserString(    
        ULONG   ixUserString,               // [IN] Value from a UserString column.
        ULONG   *pNext);                    // [OUT] Put the index of the next user string here.

//*****************************************************************************
// Class factory hook-up.
//*****************************************************************************
    static HRESULT CreateObject(REFIID riid, void **ppUnk);

//*****************************************************************************
// Helpers.
//*****************************************************************************

    HRESULT MarkAll();               // mark everything in a module
    HRESULT UnmarkAllTransientCAs();

    FORCEINLINE void SetScopeType(SCOPETYPE scType) { m_scType = scType; };

    FORCEINLINE SCOPETYPE GetScopeType() { return m_scType; };

    // helper function to setup <Module> post OpenScope
    HRESULT PostOpen();    

    // helper function to reopen RegMeta with a new chuck of memory
    HRESULT ReOpenWithMemory(     
        LPCVOID     pData,                  // [in] Location of scope data.
        ULONG       cbData);                 // [in] Size of the data pointed to by pData.

    HRESULT PostInitForWrite();
    HRESULT PostInitForRead(
        LPCWSTR     szDatabase,             // Name of database.
        void        *pbData,                // Data to open on top of, 0 default.
        ULONG       cbData,                 // How big is the data.
        IStream     *pIStream,              // Optional stream to use.
        bool        fFreeMemory);           // set to true if we need to free pbData

    FORCEINLINE CLiteWeightStgdbRW* GetMiniStgdb() { return m_pStgdb; }
    FORCEINLINE CMiniMdRW* GetMiniMd() { return &m_pStgdb->m_MiniMd; }

    bool IsTypeDefDirty() { return m_fIsTypeDefDirty;}
    void SetTypeDefDirty(bool fDirty) { m_fIsTypeDefDirty = fDirty;}

    bool IsMemberDefDirty() { return m_fIsMemberDefDirty;}
    void SetMemberDefDirty(bool fDirty) { m_fIsMemberDefDirty = fDirty;}

protected:

    CLiteWeightStgdbRW  *m_pStgdb;          // This scope's Stgdb.
    CLiteWeightStgdbRW  *m_pStgdbFreeList;  // This scope's Stgdb.
    mdTypeDef   m_tdModule;                 // The global module.
    BOOL        m_bOwnStgdb;                // Specifies whether to delete m_pStgdb or not.
    IUnknown    *m_pUnk;                    // The IUnknown that owns the Stgdb.
    FilterManager *m_pFilterManager;        // Contains helper functions for marking 

    // Pointer to internal interface. 
    IMDInternalImport   *m_pInternalImport;
    UTSemReadWrite      *m_pSemReadWrite;
    bool                m_fOwnSem;

    unsigned    m_bRemap : 1;               // If true, there is a token mapper.
    unsigned    m_bSaveOptimized : 1;       // If true, save optimization has been done.
    unsigned    m_hasOptimizedRefToDef : 1; // true if we have performed ref to def optimization
    IUnknown    *m_pHandler;
    bool        m_fIsTypeDefDirty;          // This flag is set when the TypeRef to TypeDef map is not valid
    bool        m_fIsMemberDefDirty;        // This flag is set when the MemberRef to MemberDef map is not valid
    bool        m_fBuildingMscorlib;        // Set only when mscorlib itself is being built.
    bool        m_fStartedEE;               // Set when EE runtime has been started up.
    ICorRuntimeHost *m_pCorHost;            // Hosting environment for EE runtime.
    IUnknown    *m_pAppDomain;              // AppDomain in which managed security code will be run. 

    // Helper functions used for implementation of MetaData APIs.
    HRESULT PreSave();
    HRESULT RefToDefOptimization();
    HRESULT ProcessFilter();

    // Define a TypeRef given the name.
    enum eCheckDups {eCheckDefault=0, eCheckNo=1, eCheckYes=2};

    HRESULT _DefinePermissionSet(
        mdToken     tk,                     // [IN] the object to be decorated.
        DWORD       dwAction,               // [IN] CorDeclSecurity.
        void const  *pvPermission,          // [IN] permission blob.
        ULONG       cbPermission,           // [IN] count of bytes of pvPermission.
        mdPermission *ppm);                 // [OUT] returned permission token.

    HRESULT _DefineTypeRef(
        mdToken     tkResolutionScope,      // [IN] ModuleRef or AssemblyRef.
        const void  *szName,                // [IN] Name of the TypeRef.
        BOOL        isUnicode,              // [IN] Specifies whether the URL is unicode.
        mdTypeRef   *ptk,                   // [OUT] Put mdTypeRef here.
        eCheckDups  eCheck=eCheckDefault);  // [IN] Specifies whether to check for duplicates.

    // Find a given param of a Method.
    HRESULT _FindParamOfMethod(             // S_OK or error.
        mdMethodDef md,                     // [IN] The owning method of the param.
        ULONG       iSeq,                   // [IN] The sequence # of the param.
        mdParamDef  *pParamDef);            // [OUT] Put ParamDef token here.

    // Define MethodSemantics
    HRESULT _DefineMethodSemantics(         // S_OK or error.
        USHORT      usAttr,                 // [IN] CorMethodSemanticsAttr
        mdMethodDef md,                     // [IN] Method
        mdToken     tkAssoc,                // [IN] Association
        BOOL        bClear);                // [IN] Specifies whether to delete the existing records.

    // Given the signature, return the token for signature.
    HRESULT _GetTokenFromSig(               // S_OK or error.
        PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.
        ULONG       cbSig,                  // [IN] Size of signature data.
        mdSignature *pmsig);                // [OUT] returned signature token.

    // Turn the specified internal flags on.
    HRESULT _TurnInternalFlagsOn(           // S_OK or error.
        mdToken     tkObj,                  // [IN] Target object whose internal flags are targetted.
        DWORD      flags);                  // [IN] Specifies flags to be turned on.

    BOOL _IsValidToken(                     // True or False.
        mdToken     tk);                    // [IN] Given token.

    HRESULT _SaveToStream(                  // S_OK or error.
        IStream     *pIStream,              // [IN] A writable stream to save to.
        DWORD       dwSaveFlags);           // [IN] Flags for the save.

    HRESULT _SetRVA(                        // [IN] S_OK or error.
        mdToken     md,                     // [IN] Member for which to set offset
        ULONG       ulCodeRVA,              // [IN] The offset
        DWORD       dwImplFlags);

    HRESULT RegMeta::_DefineEvent(          // Return hresult.
        mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
        LPCWSTR     szEvent,                // [IN] Name of the event   
        DWORD       dwEventFlags,           // [IN] CorEventAttr    
        mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
        mdEvent     *pmdEvent);             // [OUT] output event token 

    // Creates and sets a row in the InterfaceImpl table.  Optionally clear
    // pre-existing records for the owning class.
    HRESULT _SetImplements(                 // S_OK or error.
        mdToken     rTk[],                  // Array of TypeRef or TypeDef tokens for implemented interfaces.
        mdTypeDef   td,                     // Implementing TypeDef.
        BOOL        bClear);                // Specifies whether to clear the existing records.

    // This routine eliminates duplicates from the given list of InterfaceImpl tokens
    // to be defined.  It checks for duplicates against the database only if the
    // TypeDef for which these tokens are being defined is not a new one.
    HRESULT _InterfaceImplDupProc(          // S_OK or error.
        mdToken     rTk[],                  // Array of TypeRef or TypeDef tokens for implemented interfaces.
        mdTypeDef   td,                     // Implementing TypeDef.
        CQuickBytes *pcqbTk);               // Quick Byte object for placing the array of unique tokens.

    // Helper : convert a text field signature to a com format
    HRESULT _ConvertTextElementTypeToComSig(// Return hresult.
        IMetaDataEmit *emit,                // [IN] emit interface.
        BOOL        fCreateTrIfNotFound,    // [IN] create typeref if not found or fail out?
        LPCSTR      *ppOneArgSig,           // [IN|OUT] class file format signature. On exit, it will be next arg starting point
        CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
        ULONG       cbStart,                // [IN] bytes that are already in pqbNewSig
        ULONG       *pcbCount);             // [OUT] count of bytes put into the QuickBytes buffer

    HRESULT _SetTypeDefProps(               // S_OK or error.
        mdTypeDef   td,                     // [IN] The TypeDef.
        DWORD       dwTypeDefFlags,         // [IN] TypeDef flags.
        mdToken     tkExtends,              // [IN] Base TypeDef or TypeRef.
        mdToken     rtkImplements[]);       // [IN] Implemented interfaces.

    HRESULT _SetEventProps1(                // Return hresult.
        mdEvent     ev,                     // [IN] Event token.
        DWORD       dwEventFlags,           // [IN] Event flags.
        mdToken     tkEventType);           // [IN] Event type class.

    HRESULT _SetEventProps2(                // Return hresult.
        mdEvent     ev,                     // [IN] Event token.
        mdMethodDef mdAddOn,                // [IN] Add method.
        mdMethodDef mdRemoveOn,             // [IN] Remove method.
        mdMethodDef mdFire,                 // [IN] Fire method.
        mdMethodDef rmdOtherMethods[],      // [IN] An array of other methods.
        BOOL        bClear);                // [IN] Specifies whether to clear the existing MethodSemantics records.

    HRESULT _SetPermissionSetProps(         // Return hresult.
        mdPermission tkPerm,                // [IN] Permission token.
        DWORD       dwAction,               // [IN] CorDeclSecurity.
        void const  *pvPermission,          // [IN] Permission blob.
        ULONG       cbPermission);          // [IN] Count of bytes of pvPermission.

    HRESULT _DefinePinvokeMap(              // Return hresult.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       dwMappingFlags,         // [IN] Flags used for mapping.
        LPCWSTR     szImportName,           // [IN] Import name.
        mdModuleRef mrImportDLL);           // [IN] ModuleRef token for the target DLL.
    
    HRESULT _DefineSetConstant(             // Return hresult.
        mdToken     tk,                     // [IN] Parent token.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchString,              // [IN] Size of string in wide chars, or -1 for default.
        BOOL        bSearch);               // [IN] Specifies whether to search for an existing record.

    HRESULT _SetMethodProps(                // S_OK or error.
        mdMethodDef md,                     // [IN] The MethodDef.
        DWORD       dwMethodFlags,          // [IN] Method attributes.
        ULONG       ulCodeRVA,              // [IN] Code RVA.
        DWORD       dwImplFlags);           // [IN] MethodImpl flags.

    HRESULT _SetFieldProps(                 // S_OK or error.
        mdFieldDef  fd,                     // [IN] The FieldDef.
        DWORD       dwFieldFlags,           // [IN] Field attributes.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue);              // [IN] size of constant value (string, in wide chars).

    HRESULT _SetClassLayout(                // S_OK or error.
        mdTypeDef   td,                     // [IN] The class.
        ULONG       dwPackSize,             // [IN] The packing size.
        ULONG       ulClassSize);           // [IN, OPTIONAL] The class size.
    
    HRESULT _SetFieldOffset(                // S_OK or error.
        mdFieldDef  fd,                     // [IN] The field.
        ULONG       ulOffset);              // [IN] The offset of the field.
    
    HRESULT _SetPropertyProps(              // S_OK or error.
        mdProperty  pr,                     // [IN] Property token.
        DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
        void const  *pValue,                // [IN] Constant value.
        ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
        mdMethodDef mdSetter,               // [IN] Setter of the property.
        mdMethodDef mdGetter,               // [IN] Getter of the property.
        mdMethodDef rmdOtherMethods[]);     // [IN] Array of other methods.

    HRESULT _SetParamProps(                 // Return code.
        mdParamDef  pd,                     // [IN] Param token.   
        LPCWSTR     szName,                 // [IN] Param name.
        DWORD       dwParamFlags,           // [IN] Param flags.
        DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
        void const  *pValue,                // [OUT] Constant value.
        ULONG       cchValue);              // [IN] size of constant value (string, in wide chars).

    HRESULT _SetAssemblyProps(              // S_OK or error.
        mdAssembly  pma,                    // [IN] Assembly token.
        const void  *pbOriginator,          // [IN] Originator of the assembly.
        ULONG       cbOriginator,           // [IN] Count of bytes in the Originator blob.
        ULONG       ulHashAlgId,            // [IN] Hash Algorithm.
        LPCWSTR     szName,                 // [IN] Name of the assembly.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        DWORD       dwAssemblyFlags);       // [IN] Flags.
    
    HRESULT _SetAssemblyRefProps(           // S_OK or error.
        mdAssemblyRef ar,                   // [IN] AssemblyRefToken.
        const void  *pbPublicKeyOrToken,    // [IN] Public key or token of the assembly.
        ULONG       cbPublicKeyOrToken,     // [IN] Count of bytes in the public key or token.
        LPCWSTR     szName,                 // [IN] Name of the assembly being referenced.
        const ASSEMBLYMETADATA *pMetaData,  // [IN] Assembly MetaData.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwAssemblyRefFlags);     // [IN] Token for Execution Location.

    HRESULT _SetFileProps(                  // S_OK or error.
        mdFile      file,                   // [IN] File token.
        const void  *pbHashValue,           // [IN] Hash Blob.
        ULONG       cbHashValue,            // [IN] Count of bytes in the Hash Blob.
        DWORD       dwFileFlags) ;          // [IN] Flags.

    HRESULT _SetExportedTypeProps(               // S_OK or error.
        mdExportedType   ct,                     // [IN] ExportedType token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the ExportedType.
        mdTypeDef   tkTypeDef,              // [IN] TypeDef token within the file.
        DWORD       dwExportedTypeFlags);        // [IN] Flags.

    HRESULT _SetManifestResourceProps(      // S_OK or error.
        mdManifestResource  mr,             // [IN] ManifestResource token.
        mdToken     tkImplementation,       // [IN] mdFile or mdAssemblyRef that provides the resource.
        DWORD       dwOffset,               // [IN] Offset to the beginning of the resource within the file.
        DWORD       dwResourceFlags);       // [IN] Flags.
    
    HRESULT _DefineTypeDef(                 // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
        DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
        mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
        mdToken     rtkImplements[],        // [IN] Implements interfaces
        mdTypeDef   tdEncloser,             // [IN] TypeDef token of the Enclosing Type.
        mdTypeDef   *ptd);                  // [OUT] Put TypeDef token here

    HRESULT _IsKnownCustomAttribute(        // S_OK, S_FALSE, or error.
        mdToken     tkType,                 // [IN] Token of custom attribute's type.
        int         *pca);                  // [OUT] Put value from KnownCustAttr enum here.
    
    HRESULT _DefineModuleRef(               // S_OK or error.
        LPCWSTR     szName,                 // [IN] DLL name
        mdModuleRef *pmur);                 // [OUT] returned module ref token

    HRESULT _HandleKnownCustomAttribute(    // S_OK or error.
        mdToken     tkObj,                  // [IN] Object being attributed.
        mdToken     tkType,                 // [IN] Type of the custom attribute.
        const void  *pData,                 // [IN] Custom Attribute data blob.
        ULONG       cbData,                 // [IN] Count of bytes in the data.
        int         ca,                     // [IN] Value from KnownCustAttr enum.
        int         *bKeep);                // [OUT} Keep the known CA?
    
    HRESULT _HandleNativeTypeCustomAttribute(// S_OK or error.
        mdToken     tkObj,                  // Object being attributed.
        CaArg       *pArgs,                 // Pointer to args.
        CaNamedArg  *pNamedArgs,            // Pointer to named args.
        CQuickArray<BYTE> &qNativeType);    // Native type is built here.
        
    
    HRESULT _CheckCmodForCallConv(          // S_OK, -1 if found, or error.
        PCCOR_SIGNATURE pbSig,              // [IN] Signature to check.
        ULONG       *pcbTotal,              // [OUT] Put bytes consumed here.
        ULONG       *pCallConv);            // [OUT] If found, put calling convention here.
    
    HRESULT RegMeta::_SearchOneArgForCallConv(// S_OK, -1 if found, or error.                  
        PCCOR_SIGNATURE pbSig,              // [IN] Signature to check.                      
        ULONG       *pcbTotal,              // [OUT] Put bytes consumed here.                
        ULONG       *pCallConv);            // [OUT] If found, put calling convention here.  
    

    
    int inline IsGlobalMethodParent(mdTypeDef *ptd)
    {
        if (IsGlobalMethodParentTk(*ptd)) 
        {
            *ptd = m_tdModule;
            return (true);
        }
        return (false);
    }

    int inline IsGlobalMethodParentToken(mdTypeDef td)
    {
        return (!IsNilToken(m_tdModule) && td == m_tdModule);
    }

    FORCEINLINE BOOL IsENCOn()
    {
        _ASSERTE( ((m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateENC) ==
                  m_pStgdb->m_MiniMd.IsENCOn() );
        return (m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateENC;
    }

    FORCEINLINE BOOL IsIncrementalOn()
    {
        return (m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateIncremental;
    }

    FORCEINLINE BOOL CheckDups(CorCheckDuplicatesFor checkdup)
    {
        return ((m_OptionValue.m_DupCheck & checkdup) || 
            (m_OptionValue.m_UpdateMode == MDUpdateIncremental ||
             m_OptionValue.m_UpdateMode == MDUpdateENC) );
    }

    FORCEINLINE HRESULT UpdateENCLog(mdToken tk, CMiniMdRW::eDeltaFuncs funccode = CMiniMdRW::eDeltaFuncDefault)
    {
        _ASSERTE( ((m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateENC) ==
                  m_pStgdb->m_MiniMd.IsENCOn() );
        return m_pStgdb->m_MiniMd.UpdateENCLog(tk, funccode);
    }

    FORCEINLINE HRESULT UpdateENCLog2(ULONG ixTbl, ULONG iRid, CMiniMdRW::eDeltaFuncs funccode = CMiniMdRW::eDeltaFuncDefault)
    {
        _ASSERTE( ((m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateENC) ==
                  m_pStgdb->m_MiniMd.IsENCOn() );
        return m_pStgdb->m_MiniMd.UpdateENCLog2(ixTbl, iRid, funccode);
    }

    FORCEINLINE bool IsCallerDefine()   { return m_SetAPICaller == DEFINE_API; }
    FORCEINLINE void SetCallerDefine()  { m_SetAPICaller = DEFINE_API; }
    FORCEINLINE bool IsCallerExternal()    { return m_SetAPICaller == EXTERNAL_CALLER; }
    FORCEINLINE void SetCallerExternal()    { m_SetAPICaller = EXTERNAL_CALLER; }

    // Define Validate methods for all tables.
#undef MiniMdTable
#define MiniMdTable(x) STDMETHODIMP Validate##x(RID rid);
    MiniMdTables()

    // Validate a record in a generic sense using Meta-Meta data.
    STDMETHODIMP ValidateRecord(ULONG ixTbl, ULONG ulRow);

    // Validate if the signature is properly formed with regards to the
    // compression scheme.
    STDMETHODIMP ValidateSigCompression(
        mdToken     tk,                     // [IN] Token whose signature needs to be validated.
        PCCOR_SIGNATURE pbSig,              // [IN] Signature.
        ULONG       cbSig);                 // [IN] Size in bytes of the signature.

    // Validate one argument given the offset to the beginning of the
    // argument, size of the full signature and the currentl offset value.
    STDMETHODIMP ValidateOneArg(
        mdToken     tk,                     // [IN] Token whose signature is being processed.
        PCCOR_SIGNATURE &pbSig,             // [IN] Pointer to the beginning of argument.
        ULONG       cbSig,                  // [IN] Size in bytes of the full signature.
        ULONG       *pulCurByte,            // [IN/OUT] Current offset into the signature..
        ULONG       *pulNSentinels,         // [IN/OUT] Number of sentinels
		BOOL		bNoVoidAllowed);		// [IN] Flag indicating whether "void" is disallowed for this arg

    // Validate the given Method signature.
    STDMETHODIMP ValidateMethodSig(
        mdToken     tk,                     // [IN] Token whose signature needs to be validated.
        PCCOR_SIGNATURE pbSig,              // [IN] Signature.
        ULONG       cbSig,                  // [IN] Size in bytes of the signature.
        DWORD       dwFlags);               // [IN] Method flags.

    // Validate the given Field signature.
    STDMETHODIMP ValidateFieldSig(
        mdToken     tk,                     // [IN] Token whose signature needs to be validated.
        PCCOR_SIGNATURE pbSig,              // [IN] Signature.
        ULONG       cbSig);                 // [IN] Size in bytes of the signature.

private:
    ULONG       m_cRef;                     // Ref count.
    SCOPETYPE   m_scType;
    NEWMERGER   m_newMerger;                // class for handling merge 
    
#ifdef MD_PERF_STATS_ENABLED
    MDCompilerPerf m_MDCompilerPerf;        // PCompiler erf object to store all stats.
#endif // #ifdef MD_PERF_STATS_ENABLED

    bool        m_bCached;                  // If true, cached in list of scopes.
    bool        m_fFreeMemory;              // keep our own copy of memory
    void        *m_pbData;

    OptionValue m_OptionValue;

    mdTypeRef   m_trLanguageType;

    // Specifies whether the caller of the Set API is one of the Define functions
    // or an external API.  This allows for performance optimization in the Set APIs
    // by not checking for Duplicates in certain cases.
    SetAPICallerType m_SetAPICaller;

    CorValidatorModuleType      m_ModuleType;
    IVEHandler                  *m_pVEHandler;
    ValidateRecordFunction      m_ValidateRecordFunctionTable[TBL_COUNT];
    
    CCustAttrHash               m_caHash;   // Hashed list of custom attribute types seen.
    
    bool        m_bKeepKnownCa;             // Should all known CA's be kept?

private:
    static BOOL HighCharTable[];
};

#ifdef _IA64_
#pragma pack(pop)
#endif // _IA64_

#define GET_SCOPE_FROM_IFACE(iface) (((RegMeta *) iface)->GetScope())

#endif // __RegMeta__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\regmeta.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// RegMeta.cpp
//
// Implementation for meta data public interface methods.
//
//*****************************************************************************
#include "stdafx.h"
#include "RegMeta.h"
#include "MetaData.h"
#include "CorError.h"
#include "MDUtil.h"
#include "RWUtil.h"
#include "MDLog.h"
#include "ImportHelper.h"
#include "FilterManager.h"
#include "MDPerf.h"
#include "CorPermE.h"
#include "FusionBind.h"
#include "__file__.ver"
#include "switches.h"
#include "PostError.h"
#include "IAppDomainSetup.h"

#include <MetaModelRW.h>

#define DEFINE_CUSTOM_NODUPCHECK    1
#define DEFINE_CUSTOM_DUPCHECK      2
#define SET_CUSTOM                  3

#if defined(_DEBUG) && defined(_TRACE_REMAPS)
#define LOGGING
#endif
#include <log.h>

#pragma warning(disable: 4102)

RegMeta::RegMeta(OptionValue *pOptionValue,
                 BOOL fAllocStgdb) :
    m_cRef(0),
    m_pStgdb(0),
    m_pUnk(0),
    m_bRemap(false),
    m_bSaveOptimized(false),
    m_pHandler(0),
    m_pFilterManager(0),
    m_hasOptimizedRefToDef(false),
    m_fIsTypeDefDirty(false),
    m_fIsMemberDefDirty(false),
    m_SetAPICaller(EXTERNAL_CALLER),
    m_trLanguageType(0),
    m_fBuildingMscorlib(false),
    m_fStartedEE(false),
    m_pCorHost(NULL),
    m_pAppDomain(NULL),
    m_ModuleType(ValidatorModuleTypeInvalid),
    m_pVEHandler(0),
    m_pInternalImport(NULL),
    m_pSemReadWrite(NULL),
    m_fOwnSem(false),
    m_pStgdbFreeList(NULL),
    m_fFreeMemory(false),
    m_pbData(NULL),
    m_bKeepKnownCa(false),
    m_bCached(false)
{
    memcpy(&m_OptionValue, pOptionValue, sizeof(OptionValue));
    m_bOwnStgdb = (fAllocStgdb != 0);

#ifdef _DEBUG        
	if (REGUTIL::GetConfigDWORD(L"MD_RegMetaBreak", 0))
	{
        _ASSERTE(!"RegMeta()");
	}
    if (REGUTIL::GetConfigDWORD(L"MD_KeepKnownCA", 0))
        m_bKeepKnownCa = true;
#endif // _DEBUG

} // RegMeta::RegMeta()

RegMeta::~RegMeta()
{

    LOCKWRITE();
    if (m_pInternalImport)
    {
        // RegMeta is going away. Make sure we clear up the pointer from MDInternalRW to this RegMeta.
        m_pInternalImport->SetCachedPublicInterface(NULL);
        m_pInternalImport = NULL;
        m_fOwnSem = false;
    }

    UNLOCKWRITE();

    if (m_pSemReadWrite && m_fOwnSem)
        delete m_pSemReadWrite;

    if (m_fFreeMemory && m_pbData)
        free(m_pbData);

    Cleanup();

    if (m_pFilterManager)
        delete m_pFilterManager;
} // RegMeta::~RegMeta()

//*****************************************************************************
// Call this after initialization is complete.
//*****************************************************************************
HRESULT RegMeta::AddToCache()
{
    HRESULT hr=S_OK;
    // add this RegMeta to the loaded module list.
    IfFailGo(LOADEDMODULES::AddModuleToLoadedList(this));
    m_bCached = true;
ErrExit:
    return hr;    
} // void RegMeta::AddToCache()

//*****************************************************************************
// Init the object with pointers to what it needs to implement the methods.
//*****************************************************************************
HRESULT RegMeta::Init()
{
    HRESULT     hr = NOERROR;

    // Allocate our m_pStgdb, if we should.
    if (!m_pStgdb && m_bOwnStgdb)
        IfNullGo( m_pStgdb = new CLiteWeightStgdbRW );
    
    // initialize the embedded merger
    m_newMerger.Init(this);

ErrExit:
    return (hr);
} // HRESULT RegMeta::Init()

//*****************************************************************************
// Initialize with an existing stgdb.
//*****************************************************************************
HRESULT RegMeta::InitWithStgdb(
    IUnknown        *pUnk,              // The IUnknown that owns the life time for the existing stgdb
    CLiteWeightStgdbRW *pStgdb)         // existing light weight stgdb
{
    // RegMeta created this way will not create a read/write lock semaphore. 

    HRESULT     hr = S_OK;

    _ASSERTE(! m_pStgdb);
    m_tdModule = COR_GLOBAL_PARENT_TOKEN;
    m_bOwnStgdb = false;
    m_pStgdb = pStgdb;

    // remember the owner of the light weight stgdb
    // AddRef it to ensure the lifetime
    //
    m_pUnk = pUnk;
    m_pUnk->AddRef();
    IfFailGo( m_pStgdb->m_MiniMd.GetOption(&m_OptionValue) );
ErrExit:
    return hr;
} // HRESULT RegMeta::InitWithStgdb()

//*****************************************************************************
// call stgdb InitNew
//*****************************************************************************
HRESULT RegMeta::PostInitForWrite()
{
    HRESULT     hr = NOERROR;

    // Allocate our m_pStgdb, if we should.
    if (!m_pStgdb && m_bOwnStgdb)
        IfNullGo( m_pStgdb = new CLiteWeightStgdbRW );
    
    // Initialize the new, empty database.
    _ASSERTE(m_pStgdb && m_bOwnStgdb);
    m_pStgdb->InitNew();

#if 0
    // Add version string as the first string in the string heap.
    ULONG       ulOffset;
    char        tmpStr[256];
    sprintf (tmpStr, "Version of runtime against which the binary is built : %s",
             VER_FILEVERSION_STR);
    IfFailGo(m_pStgdb->m_MiniMd.AddString(tmpStr, &ulOffset));
    _ASSERTE(ulOffset == 1 && "Addition of version string didn't return offset 1");
#endif
    // Set up the Module record.
    ULONG       iRecord;
    ModuleRec   *pModule;
    GUID        mvid;
    IfNullGo(pModule=m_pStgdb->m_MiniMd.AddModuleRecord(&iRecord));
    IfFailGo(CoCreateGuid(&mvid));
    IfFailGo(m_pStgdb->m_MiniMd.PutGuid(TBL_Module, ModuleRec::COL_Mvid, pModule, mvid));

    // Add the dummy module typedef which we are using to parent global items.
    TypeDefRec  *pRecord;
    IfNullGo(pRecord=m_pStgdb->m_MiniMd.AddTypeDefRecord(&iRecord));
    m_tdModule = TokenFromRid(iRecord, mdtTypeDef);
    IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_TypeDef, TypeDefRec::COL_Name, pRecord, COR_WMODULE_CLASS));

    IfFailGo( m_pStgdb->m_MiniMd.SetOption(&m_OptionValue) );

    if (m_OptionValue.m_ThreadSafetyOptions == MDThreadSafetyOn)
    {
        m_pSemReadWrite = new UTSemReadWrite;
        IfNullGo( m_pSemReadWrite);
        m_fOwnSem = true;
    }    
ErrExit:
    return hr;
} // HRESULT RegMeta::PostInitForWrite()

//*****************************************************************************
// call stgdb OpenForRead
//*****************************************************************************
HRESULT RegMeta::PostInitForRead(
    LPCWSTR     szDatabase,             // Name of database.
    void        *pbData,                // Data to open on top of, 0 default.
    ULONG       cbData,                 // How big is the data.
    IStream     *pIStream,              // Optional stream to use.
    bool        fFreeMemory)
{
    
    HRESULT     hr = NOERROR;
    
    m_fFreeMemory = fFreeMemory;
    m_pbData = pbData;

    // Allocate our m_pStgdb, if we should.
    if (!m_pStgdb && m_bOwnStgdb)
        IfNullGo( m_pStgdb = new CLiteWeightStgdbRW );
    
    _ASSERTE(m_pStgdb && m_bOwnStgdb);
    IfFailGo( m_pStgdb->OpenForRead(
        szDatabase,
        pbData,
        cbData,
        pIStream,
        NULL,
        (m_scType == OpenForRead)) );

    IfFailGo( m_pStgdb->m_MiniMd.SetOption(&m_OptionValue) );

    if (m_OptionValue.m_ThreadSafetyOptions == MDThreadSafetyOn)
    {
        m_pSemReadWrite = new UTSemReadWrite;
        IfNullGo( m_pSemReadWrite);
        m_fOwnSem = true;
    }
ErrExit:
    return hr;
} // HRESULT    RegMeta::PostInitForRead()

//*****************************************************************************
// Cleanup code used by dtor.
//*****************************************************************************
void RegMeta::Cleanup()
{
    CLiteWeightStgdbRW  *pCur; 

    if (m_bOwnStgdb)
    {
        _ASSERTE(m_pStgdb && !m_pUnk);
        delete m_pStgdb;
        m_pStgdb = 0;
    }
    else
    {
        _ASSERTE(m_pUnk);
        if (m_pUnk)
            m_pUnk->Release();
        m_pUnk = 0;
    }

    // delete the old copies of Stgdb list. This is the list track all of the old snapshuts with ReOpenWithMemory
    // call.
    //
    while (m_pStgdbFreeList)
    {
        pCur = m_pStgdbFreeList;
        m_pStgdbFreeList = m_pStgdbFreeList->m_pNextStgdb;
        delete pCur;
    }

    if (m_pVEHandler)
        m_pVEHandler->Release();

    if (m_fStartedEE) {
        m_pAppDomain->Release();
        m_pCorHost->Stop();
        m_pCorHost->Release();
    }
} // void RegMeta::Cleanup()


//*****************************************************************************
// Note that the returned IUnknown is not AddRef'ed. This function also does not
// trigger the creation of Internal interface.
//*****************************************************************************
IUnknown* RegMeta::GetCachedInternalInterface(BOOL fWithLock) 
{
    IUnknown        *pRet;
    if (fWithLock)
    {
        LOCKREAD();
        pRet = m_pInternalImport;
    }
    else
    {
        pRet = m_pInternalImport;
    }
    if (pRet) pRet->AddRef();
    
    return pRet;
} // IUnknown* RegMeta::GetCachedInternalInterface() 


//*****************************************************************************
// Set the cached Internal interface. This function will return an Error is the
// current cached internal interface is not empty and trying set a non-empty internal
// interface. One RegMeta will only associated
// with one Internal Object. Unless we have bugs somewhere else. It will QI on the 
// IUnknown for the IMDInternalImport. If this failed, error will be returned.
// Note: Caller should take a write lock
//*****************************************************************************
HRESULT RegMeta::SetCachedInternalInterface(IUnknown *pUnk)
{
    HRESULT     hr = NOERROR;
    IMDInternalImport *pInternal = NULL;

    if (pUnk)
    {
        if (m_pInternalImport)
        {
            _ASSERTE(!"Bad state!");
        }
        IfFailRet( pUnk->QueryInterface(IID_IMDInternalImport, (void **) &pInternal) );

        // Should be non-null
        _ASSERTE(pInternal);
        m_pInternalImport = pInternal;
    
        // We don't add ref the internal interface
        pInternal->Release();
    }
    else
    {
        // Internal interface is going away before the public interface. Take ownership on the 
        // reader writer lock.
        m_fOwnSem = true;
        m_pInternalImport = NULL;
    }
    return hr;
} // HRESULT RegMeta::SetCachedInternalInterface(IUnknown *pUnk)


//*****************************************************************************
// IMetaDataRegEmit methods
//*****************************************************************************

//*****************************************************************************
// Set module properties on a scope.
//*****************************************************************************
STDMETHODIMP RegMeta::SetModuleProps(   // S_OK or error.
    LPCWSTR     szName)                 // [IN] If not NULL, the name to set.
{
    HRESULT     hr = S_OK;
    ModuleRec   *pModule;               // The module record to modify.

    LOG((LOGMD, "RegMeta::SetModuleProps(%S)\n", MDSTR(szName)));
    START_MD_PERF()
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    pModule = m_pStgdb->m_MiniMd.getModule(1);
    if (szName)
    {
        WCHAR       rcFile[_MAX_PATH];
        WCHAR       rcExt[_MAX_PATH];       
        WCHAR       rcNewFileName[_MAX_PATH];       

        // If the total name is less than _MAX_PATH, the components are, too.
        if (wcslen(szName) >= _MAX_PATH)
            IfFailGo(E_INVALIDARG);

        SplitPath(szName, NULL, NULL, rcFile, rcExt);
        MakePath(rcNewFileName, NULL, NULL, rcFile, rcExt);
        IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_Module, ModuleRec::COL_Name, pModule, rcNewFileName));
    }

    IfFailGo(UpdateENCLog(TokenFromRid(1, mdtModule)));

ErrExit:
    
    STOP_MD_PERF(SetModuleProps);
    return hr;
} // STDMETHODIMP RegMeta::SetModuleProps()

//*****************************************************************************
// Saves a scope to a file of a given name.
//*****************************************************************************
STDMETHODIMP RegMeta::Save(                     // S_OK or error.
    LPCWSTR     szFile,                 // [IN] The filename to save to.
    DWORD       dwSaveFlags)            // [IN] Flags for the save.
{
    HRESULT     hr=S_OK;

    LOG((LOGMD, "RegMeta::Save(%S, 0x%08x)\n", MDSTR(szFile), dwSaveFlags));
    START_MD_PERF()
    LOCKWRITE();

    // Check reserved param..
    if (dwSaveFlags != 0)
        IfFailGo (E_INVALIDARG);
    IfFailGo(PreSave());
    IfFailGo(m_pStgdb->Save(szFile, dwSaveFlags));

    // Reset m_bSaveOptimized, this is to handle the incremental and ENC
    // scenerios where one may do multiple saves.
    _ASSERTE(m_bSaveOptimized && !m_pStgdb->m_MiniMd.IsPreSaveDone());
    m_bSaveOptimized = false;

ErrExit:
    
    STOP_MD_PERF(Save);
    return hr;
} // STDMETHODIMP RegMeta::Save()

//*****************************************************************************
// Saves a scope to a stream.
//*****************************************************************************
STDMETHODIMP RegMeta::SaveToStream(     // S_OK or error.
    IStream     *pIStream,              // [IN] A writable stream to save to.
    DWORD       dwSaveFlags)            // [IN] Flags for the save.
{
    HRESULT     hr=S_OK;
    LOCKWRITE();

    LOG((LOGMD, "RegMeta::SaveToStream(0x%08x, 0x%08x)\n", pIStream, dwSaveFlags));
    START_MD_PERF()

    //Save(L"Foo.clb", 0);

    m_pStgdb->m_MiniMd.PreUpdate();

    hr = _SaveToStream(pIStream, dwSaveFlags);

ErrExit:
    // 
    STOP_MD_PERF(SaveToStream);
    return hr;
} // STDMETHODIMP RegMeta::SaveToStream()


//*****************************************************************************
// Saves a scope to a stream.
//*****************************************************************************
HRESULT RegMeta::_SaveToStream(         // S_OK or error.
    IStream     *pIStream,              // [IN] A writable stream to save to.
    DWORD       dwSaveFlags)            // [IN] Flags for the save.
{
    HRESULT     hr=S_OK;

    IfFailGo(PreSave());
    IfFailGo( m_pStgdb->SaveToStream(pIStream) );

    // Reset m_bSaveOptimized, this is to handle the incremental and ENC
    // scenerios where one may do multiple saves.
    _ASSERTE(m_bSaveOptimized && !m_pStgdb->m_MiniMd.IsPreSaveDone());
    m_bSaveOptimized = false;

ErrExit:
    return hr;
} // STDMETHODIMP RegMeta::_SaveToStream()

//*****************************************************************************
// As the Stgdb object to get the save size for the scope.
//*****************************************************************************
STDMETHODIMP RegMeta::GetSaveSize(      // S_OK or error.
    CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
    DWORD       *pdwSaveSize)           // [OUT] Put the size here.
{
    HRESULT     hr=S_OK;

    LOG((LOGMD, "RegMeta::GetSaveSize(0x%08x, 0x%08x)\n", fSave, pdwSaveSize));
    START_MD_PERF();
    LOCKWRITE();

    if ( m_pStgdb->m_MiniMd.GetFilterTable()->Count() )
    {
        int     iCount;

        // There is filter table. Linker is using /opt:ref.
        // Make sure that we are marking the AssemblyDef token!
        iCount = m_pStgdb->m_MiniMd.getCountAssemblys();
        _ASSERTE(iCount <= 1);

        if (iCount)
        {
            IfFailGo( m_pFilterManager->Mark(TokenFromRid(iCount, mdtAssembly) ));
        }
    }
    else if (m_newMerger.m_pImportDataList)
    {
        // always pipe through another pass of merge to drop unnecessary ref for linker.
        MarkAll();
    }

#if 0
    // enable this when we have a compiler to test
    if (fSave & cssDiscardTransientCAs)
    {
        UnmarkAllTransientCAs();
    }
#endif //0
    IfFailGo(PreSave());
    hr = m_pStgdb->GetSaveSize(fSave, pdwSaveSize);
    

ErrExit:

    STOP_MD_PERF(GetSaveSize);
    return hr;
} // STDMETHODIMP RegMeta::GetSaveSize()

//*****************************************************************************
// Merge the pImport scope to this scope
//*****************************************************************************
STDMETHODIMP RegMeta::Merge(            // S_OK or error.
    IMetaDataImport *pImport,           // [IN] The scope to be merged.
    IMapToken   *pHostMapToken,         // [IN] Host IMapToken interface to receive token remap notification
    IUnknown    *pHandler)              // [IN] An object to receive to receive error notification.
{
    HRESULT     hr = NOERROR;

    LOG((LOGMD, "RegMeta::Merge(0x%08x, 0x%08x)\n", pImport, pHandler));
    START_MD_PERF();
    LOCKWRITE();

    m_hasOptimizedRefToDef = false;

    // track this import
    IfFailGo(  m_newMerger.AddImport(pImport, pHostMapToken, pHandler) );

ErrExit:    
    STOP_MD_PERF(Merge);
    return (hr);
}


//*****************************************************************************
// real merge takes place here
//*****************************************************************************
STDMETHODIMP RegMeta::MergeEnd()        // S_OK or error.
{
    HRESULT     hr = NOERROR;

    LOG((LOGMD, "RegMeta::MergeEnd()\n"));
    START_MD_PERF();
    LOCKWRITE();
    // Merge happens here!!

    // bug 16719.  Merge itself is doing a lots of small changes in literally
    // dozens of places.  It would be to hard to maintain and would cause code
    // bloat to auto-grow the tables.  So instead, we've opted to just expand
    // the world right away and avoid the trouble.
    IfFailGo(m_pStgdb->m_MiniMd.ExpandTables());

    IfFailGo( m_newMerger.Merge(MergeFlagsNone, m_OptionValue.m_RefToDefCheck) );

ErrExit:    
    STOP_MD_PERF(MergeEnd);
    return (hr);

}

//*****************************************************************************
// Persist a set of security custom attributes into a set of permission set
// blobs on the same class or method.
//*****************************************************************************
HRESULT RegMeta::DefineSecurityAttributeSet(// Return code.
    mdToken     tkObj,                  // [IN] Class or method requiring security attributes.
    COR_SECATTR rSecAttrs[],            // [IN] Array of security attribute descriptions.
    ULONG       cSecAttrs,              // [IN] Count of elements in above array.
    ULONG       *pulErrorAttr)          // [OUT] On error, index of attribute causing problem.
{
    HRESULT         hr = S_OK;
    CORSEC_PSET     rPermSets[dclMaximumValue + 1];
    DWORD           i, j, k;
    BYTE           *pData;
    CORSEC_PERM    *pPerm;
    CMiniMdRW      *pMiniMd = &(m_pStgdb->m_MiniMd);
    MemberRefRec   *pMemberRefRec;
    TypeRefRec     *pTypeRefRec;
    TypeDefRec     *pTypeDefRec;
    BYTE           *pbBlob;
    DWORD           cbBlob;
    BYTE           *pbNonCasBlob;
    DWORD           cbNonCasBlob;
    mdPermission    ps;
    DWORD           dwAction;
    LPCSTR          szNamespace;
    LPCSTR          szClass;
    mdTypeDef       tkParent;
    HRESULT         hree = S_OK;

    LOG((LOGMD, "RegMeta::DefineSecurityAttributeSet(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
         tkObj, rSecAttrs, cSecAttrs, pulErrorAttr));
    START_MD_PERF();
    LOCKWRITE();

    memset(rPermSets, 0, sizeof(rPermSets));
    
    // Initialize error index to indicate a general error.
    if (pulErrorAttr)
        *pulErrorAttr = cSecAttrs;

    // Determine whether we're building mscorlib via an environment variable
    // (set via the build process). This allows us to determine whether
    // attribute to binary pset translations should be via the bootstrap
    // database or through the full managed code path.
    if (!m_fStartedEE && !m_fBuildingMscorlib)
        m_fBuildingMscorlib = WszGetEnvironmentVariable(SECURITY_BOOTSTRAP_DB, NULL, 0) != 0;

    // Startup the EE just once, no matter how many times we're called (this is
    // better on performance and the EE falls over if we try a start-stop-start
    // cycle anyway).
    if (!m_fBuildingMscorlib && !m_fStartedEE) 
    {
        IUnknown        *pSetup = NULL;
        IAppDomainSetup *pDomainSetup = NULL;
        bool             fDoneStart = false;

        try 
        {
            // Create a hosting environment.
            if (SUCCEEDED(hree = CoCreateInstance(CLSID_CorRuntimeHost,
                                                  NULL,
                                                  CLSCTX_INPROC_SERVER,
                                                  IID_ICorRuntimeHost,
                                                  (void**)&m_pCorHost))) 
            {

                // Startup the runtime.
                if (SUCCEEDED(hree = m_pCorHost->Start())) 
                {
                    fDoneStart = true;

                    // Create an AppDomain Setup so we can set the AppBase.
                    if (SUCCEEDED(hree = m_pCorHost->CreateDomainSetup(&pSetup))) 
                    {
                        // QI for the IAppDomainSetup interface.
                        if (SUCCEEDED(hree = pSetup->QueryInterface(__uuidof(IAppDomainSetup),
                                                                    (void**)&pDomainSetup))) 
                        {
                            // Get the current directory (place it in a BSTR).
                            DWORD  *pdwBuffer = (DWORD*)_alloca(sizeof(DWORD) + ((MAX_PATH + 1) * sizeof(WCHAR)));
                            BSTR    bstrDir = (BSTR)(pdwBuffer + 1);
                            if (*pdwBuffer = (WszGetCurrentDirectory(MAX_PATH + 1, bstrDir) * sizeof(WCHAR))) 
                            {
                                // Set the AppBase.
                                pDomainSetup->put_ApplicationBase(bstrDir);

                                // Create a new AppDomain.
                                if (SUCCEEDED(hree = m_pCorHost->CreateDomainEx(L"Compilation Domain",
                                                                                pSetup,
                                                                                NULL,
                                                                                &m_pAppDomain))) 
                                {
                                    // That's it, we're all set up.
                                    _ASSERTE(m_pAppDomain != NULL);
                                    m_fStartedEE = true;
                                    hree = S_OK;
                                }
                            }
                        }
                    }
                }
            }
        } 
        catch (...) 
        {
            _ASSERTE(!"Unexpected exception setting up hosting environment for security attributes");
            hree = E_FAIL;
        }

        // Cleanup temporary resources.
        if (m_pAppDomain && FAILED(hree))
            m_pAppDomain->Release();
        if (pDomainSetup)
            pDomainSetup->Release();
        if (pSetup)
            pSetup->Release();
        if (fDoneStart && FAILED(hree))
            m_pCorHost->Stop();
        if (m_pCorHost && FAILED(hree))
            m_pCorHost->Release();

        IfFailGo(hree);
    }

    // Calculate number and sizes of permission sets to produce. This depends on
    // the security action code encoded as the single parameter to the
    // constructor for each security custom attribute.
    for (i = 0; i < cSecAttrs; i++) 
    {

        if (pulErrorAttr)
            *pulErrorAttr = i;

        // Perform basic validation of the header of each security custom
        // attribute constructor call.
        pData = (BYTE*)rSecAttrs[i].pCustomAttribute;

        // Check minimum length.
        if (rSecAttrs[i].cbCustomAttribute < (sizeof(WORD) + sizeof(DWORD) + sizeof(WORD))) 
        {
            PostError(CORSECATTR_E_TRUNCATED);
            IfFailGo(CORSECATTR_E_TRUNCATED);
        }

        // Check version.
        if (*(WORD*)pData != 1) 
        {
            PostError(CORSECATTR_E_BAD_VERSION);
            IfFailGo(CORSECATTR_E_BAD_VERSION);
        }
        pData += sizeof(WORD);

        // Extract and check security action.
        dwAction = *(DWORD*)pData;
        if (dwAction == dclActionNil || dwAction > dclMaximumValue) 
        {
            PostError(CORSECATTR_E_BAD_ACTION);
            IfFailGo(CORSECATTR_E_BAD_ACTION);
        }

        // All other declarative security only valid on types and methods.
        if (TypeFromToken(tkObj) == mdtAssembly) 
        {
            // Assemblies can only take permission requests.
            if (dwAction != dclRequestMinimum &&
                dwAction != dclRequestOptional &&
                dwAction != dclRequestRefuse) 
            {
                PostError(CORSECATTR_E_BAD_ACTION_ASM);
                IfFailGo(CORSECATTR_E_BAD_ACTION_ASM);
            }
        } 
        else if (TypeFromToken(tkObj) == mdtTypeDef || TypeFromToken(tkObj) == mdtMethodDef) 
        {
            // Types and methods can only take declarative security.
            if (dwAction != dclRequest &&
                dwAction != dclDemand &&
                dwAction != dclAssert &&
                dwAction != dclDeny &&
                dwAction != dclPermitOnly &&
                dwAction != dclLinktimeCheck &&
                dwAction != dclInheritanceCheck) 
            {
                PostError(CORSECATTR_E_BAD_ACTION_OTHER);
                IfFailGo(CORSECATTR_E_BAD_ACTION_OTHER);
            }
        } 
        else 
        {
            // Permission sets can't be attached to anything else.
            PostError(CORSECATTR_E_BAD_PARENT);
            IfFailGo(CORSECATTR_E_BAD_PARENT);
        }

        rPermSets[dwAction].dwPermissions++;
    }

    // Initialise the descriptor for each type of permission set we are going to
    // produce.
    for (i = 0; i <= dclMaximumValue; i++) 
    {
        if (rPermSets[i].dwPermissions == 0)
            continue;

        rPermSets[i].tkObj = tkObj;
        rPermSets[i].dwAction = i;
        rPermSets[i].pImport = (IMetaDataAssemblyImport*)this;
        rPermSets[i].pAppDomain = m_pAppDomain;
        rPermSets[i].pPermissions = new CORSEC_PERM[rPermSets[i].dwPermissions];
        IfNullGo(rPermSets[i].pPermissions);

        // Initialize a descriptor for each permission within the permission set.
        for (j = 0, k = 0; j < rPermSets[i].dwPermissions; j++, k++) 
        {
            // Locate the next security attribute that contributes to this
            // permission set.
            for (; k < cSecAttrs; k++) 
            {
                pData = (BYTE*)rSecAttrs[k].pCustomAttribute;
                dwAction = *(DWORD*)(pData + sizeof(WORD));
                if (dwAction == i)
                    break;
            }
            _ASSERTE(k < cSecAttrs);

            if (pulErrorAttr)
                *pulErrorAttr = k;

            // Initialize the permission.
            pPerm = &rPermSets[i].pPermissions[j];
            pPerm->tkCtor = rSecAttrs[k].tkCtor;
            pPerm->dwIndex = k;
            pPerm->pbValues = pData + (sizeof (WORD) + sizeof(DWORD) + sizeof(WORD));
            pPerm->cbValues = rSecAttrs[k].cbCustomAttribute - (sizeof (WORD) + sizeof(DWORD) + sizeof(WORD));
            pPerm->wValues = *(WORD*)(pData + sizeof (WORD) + sizeof(DWORD));

            // Follow the security custom attribute constructor back up to its
            // defining assembly (so we know how to load its definition). If the
            // token resolution scope is not defined, it's assumed to be
            // mscorlib. If a methoddef rather than a memberref is supplied for
            // the parent of the constructor, we potentially have an error
            // condition (since we don't allow security custom attributes to be
            // used in the same assembly as which they're defined). However,
            // this is legal in one specific case, building mscorlib.
            if (TypeFromToken(rSecAttrs[k].tkCtor) == mdtMethodDef) 
            {
                if (!m_fBuildingMscorlib) 
                {
                    PostError(CORSECATTR_E_NO_SELF_REF);
                    IfFailGo(CORSECATTR_E_NO_SELF_REF);
                }
                pPerm->tkTypeRef = mdTokenNil;
                pPerm->tkAssemblyRef = mdTokenNil;

                IfFailGo(pMiniMd->FindParentOfMethodHelper(rSecAttrs[k].tkCtor, &tkParent));
                pTypeDefRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
                szNamespace = pMiniMd->getNamespaceOfTypeDef(pTypeDefRec);
                szClass = pMiniMd->getNameOfTypeDef(pTypeDefRec);
                ns::MakePath(pPerm->szName, sizeof(pPerm->szName) - 1, szNamespace, szClass);
            } 
            else 
            {
                _ASSERTE(m_fStartedEE && !m_fBuildingMscorlib);

                _ASSERTE(TypeFromToken(rSecAttrs[k].tkCtor) == mdtMemberRef);
                pMemberRefRec = pMiniMd->getMemberRef(RidFromToken(rSecAttrs[k].tkCtor));
                pPerm->tkTypeRef = pMiniMd->getClassOfMemberRef(pMemberRefRec);

                _ASSERTE(TypeFromToken(pPerm->tkTypeRef) == mdtTypeRef);
                pTypeRefRec = pMiniMd->getTypeRef(RidFromToken(pPerm->tkTypeRef));
                pPerm->tkAssemblyRef = pMiniMd->getResolutionScopeOfTypeRef(pTypeRefRec);

                // We only support the use of security custom attributes defined
                // in a separate, distinct assembly. So the type resolution
                // scope must be an assembly ref or the special case of nil
                // (which implies the attribute is defined in mscorlib). Nested
                // types (resolution scope of another typeref/def) are also not
                // supported.
                if ((TypeFromToken(pPerm->tkAssemblyRef) != mdtAssemblyRef) &&
                    !IsNilToken(pPerm->tkAssemblyRef)) 
                {
                    PostError(CORSECATTR_E_NO_SELF_REF);
                    IfFailGo(CORSECATTR_E_NO_SELF_REF);
                }

                ns::MakePath(pPerm->szName, sizeof(pPerm->szName) - 1, 
                             pMiniMd->getNamespaceOfTypeRef(pTypeRefRec),
                             pMiniMd->getNameOfTypeRef(pTypeRefRec));
            }
        }

        if (pulErrorAttr)
            *pulErrorAttr = cSecAttrs;

        // Now translate the sets of security attributes into a real permission
        // set and convert this to a serialized blob. We may possibly end up
        // with two sets as the result of splitting CAS and non-CAS permissions
        // into separate sets.
        pbBlob = NULL;
        cbBlob = 0;
        pbNonCasBlob = NULL;
        cbNonCasBlob = 0;
        IfFailGo(TranslateSecurityAttributes(&rPermSets[i], &pbBlob, &cbBlob,
                                             &pbNonCasBlob, &cbNonCasBlob, pulErrorAttr));

        // Persist the permission set blob into the metadata. For empty CAS
        // blobs this is only done if the corresponding non-CAS blob is empty.
        if (cbBlob || !cbNonCasBlob)
            IfFailGo(_DefinePermissionSet(rPermSets[i].tkObj,
                                          rPermSets[i].dwAction,
                                          pbBlob,
                                          cbBlob,
                                          &ps));
        if (pbNonCasBlob) 
        {
            DWORD dwAction;
            switch (rPermSets[i].dwAction) 
            {
            case dclDemand:
                dwAction = dclNonCasDemand;
                break;
            case dclLinktimeCheck:
                dwAction = dclNonCasLinkDemand;
                break;
            case dclInheritanceCheck:
                dwAction = dclNonCasInheritance;
                break;
            default:
                PostError(CORSECATTR_E_BAD_NONCAS);
                IfFailGo(CORSECATTR_E_BAD_NONCAS);
            }
            IfFailGo(_DefinePermissionSet(rPermSets[i].tkObj,
                                          dwAction,
                                          pbNonCasBlob,
                                          cbNonCasBlob,
                                          &ps));
        }

        if (pbBlob)
            delete [] pbBlob;
        if (pbNonCasBlob)
            delete [] pbNonCasBlob;
    }

ErrExit:
    for (i = 0; i <= dclMaximumValue; i++)
        delete [] rPermSets[i].pPermissions;
    STOP_MD_PERF(DefineSecurityAttributeSet);
    return (hr);
}   // HRESULT RegMeta::DefineSecurityAttributeSet()

//*****************************************************************************
// Unmark everything in this module
//*****************************************************************************
HRESULT RegMeta::UnmarkAll()
{
    HRESULT         hr;
    int             i;
    int             iCount;
    TypeDefRec      *pRec;
    ULONG           ulEncloser;
    NestedClassRec  *pNestedClass;
    CustomAttributeRec  *pCARec;
    mdToken         tkParent;
    int             iStart, iEnd;

    LOG((LOGMD, "RegMeta::UnmarkAll\n"));
    START_MD_PERF();
    LOCKWRITE();

#if 0
    // We cannot enable this check. Because our tests are depending on this.. Sigh..
    if (m_pFilterManager)
    {
        // UnmarkAll has been called before
        IfFailGo( META_E_HAS_UNMARKALL );
    }
#endif // 0

    // calculate the TypeRef and TypeDef mapping here
    //
    IfFailGo( RefToDefOptimization() );

    // unmark everything in the MiniMd.
    IfFailGo( m_pStgdb->m_MiniMd.UnmarkAll() );

    // instantiate the filter manager
    m_pFilterManager = new FilterManager( &(m_pStgdb->m_MiniMd) );
    IfNullGo( m_pFilterManager );

    // Mark all public typedefs.
    iCount = m_pStgdb->m_MiniMd.getCountTypeDefs();

    // Mark all of the public TypeDef. We need to skip over the <Module> typedef
    for (i = 2; i <= iCount; i++)
    {
        pRec = m_pStgdb->m_MiniMd.getTypeDef(i);
        if (m_OptionValue.m_LinkerOption == MDNetModule)
        {
            // Client is asking us to keep private type as well. 
            IfFailGo( m_pFilterManager->Mark(TokenFromRid(i, mdtTypeDef)) );
        }
        else if (i != 1)
        {
            // when client is not set to MDNetModule, global functions/fields won't be keep by default
            //
            if (IsTdPublic(pRec->m_Flags))
            {
                IfFailGo( m_pFilterManager->Mark(TokenFromRid(i, mdtTypeDef)) );
            }
            else if ( IsTdNestedPublic(pRec->m_Flags) ||
                      IsTdNestedFamily(pRec->m_Flags) ||
                      IsTdNestedFamORAssem(pRec->m_Flags) )
            {
                // This nested class would potentially be visible outside, either
                // directly or through inheritence.  If the enclosing class is
                // marked, this nested class must be marked.
                //
                ulEncloser = m_pStgdb->m_MiniMd.FindNestedClassHelper(TokenFromRid(i, mdtTypeDef));
                _ASSERTE( !InvalidRid(ulEncloser) && 
                          "Bad metadata for nested type!" );
                pNestedClass = m_pStgdb->m_MiniMd.getNestedClass(ulEncloser);
                tkParent = m_pStgdb->m_MiniMd.getEnclosingClassOfNestedClass(pNestedClass);
                if ( m_pStgdb->m_MiniMd.GetFilterTable()->IsTypeDefMarked(tkParent))
                    IfFailGo( m_pFilterManager->Mark(TokenFromRid(i, mdtTypeDef)) );
            }
        }
    }

    if (m_OptionValue.m_LinkerOption == MDNetModule)
    {
        // Mark global function if NetModule. We will not keep _Delete method.
	    pRec = m_pStgdb->m_MiniMd.getTypeDef(1);
	    iStart = m_pStgdb->m_MiniMd.getMethodListOfTypeDef( pRec );
	    iEnd = m_pStgdb->m_MiniMd.getEndMethodListOfTypeDef( pRec );
	    for ( i = iStart; i < iEnd; i ++ )
	    {
            RID         rid = m_pStgdb->m_MiniMd.GetMethodRid(i);
            MethodRec   *pMethodRec = m_pStgdb->m_MiniMd.getMethod(rid);

            // check the name
            if (IsMdRTSpecialName(pMethodRec->m_Flags))
            {
                LPCUTF8     szName = m_pStgdb->m_MiniMd.getNameOfMethod(pMethodRec);

                // Only mark method if not a _Deleted method
                if (strcmp(szName, COR_DELETED_NAME_A) != 0)
    		        IfFailGo( m_pFilterManager->Mark( TokenFromRid( rid, mdtMethodDef) ) );
            }
            else
            {
	    		// VC generates some native ForwardRef global methods that should not be kept for netModule
			if (!IsMiForwardRef(pMethodRec->m_ImplFlags) || 
		     		IsMiRuntime(pMethodRec->m_ImplFlags)    || 
		     		IsMdPinvokeImpl(pMethodRec->m_Flags) )

				IfFailGo( m_pFilterManager->Mark( TokenFromRid( rid, mdtMethodDef) ) );
            }
	    }
    }

    // mark the module property
    IfFailGo( m_pFilterManager->Mark(TokenFromRid(1, mdtModule)) );

    // We will also keep all of the TypeRef that has any CustomAttribute hang off it.
    iCount = m_pStgdb->m_MiniMd.getCountCustomAttributes();

    // Mark all of the TypeRef used by CA's 
    for (i = 1; i <= iCount; i++)
    {
        pCARec = m_pStgdb->m_MiniMd.getCustomAttribute(i);
        tkParent = m_pStgdb->m_MiniMd.getParentOfCustomAttribute(pCARec);
        if (TypeFromToken(tkParent) == mdtTypeRef)
        {
            m_pFilterManager->Mark(tkParent);
        }
    }
ErrExit:
    
    STOP_MD_PERF(UnmarkAll);
    return hr;
} // HRESULT RegMeta::UnmarkAll()



//*****************************************************************************
// Mark everything in this module
//*****************************************************************************
HRESULT RegMeta::MarkAll()
{
    HRESULT         hr = NOERROR;

    // mark everything in the MiniMd.
    IfFailGo( m_pStgdb->m_MiniMd.MarkAll() );

    // instantiate the filter manager if not instantiated
    if (m_pFilterManager == NULL)
    {        
        m_pFilterManager = new FilterManager( &(m_pStgdb->m_MiniMd) );
        IfNullGo( m_pFilterManager );
    }
ErrExit:
    return hr;
}   // HRESULT RegMeta::MarkAll

//*****************************************************************************
// Unmark all of the transient CAs
//*****************************************************************************
HRESULT RegMeta::UnmarkAllTransientCAs()
{
    HRESULT         hr = NOERROR;
    int             i;
    int             iCount;
    int             cTypeRefRecs;
    TypeDefRec      *pRec;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
    TypeRefRec      *pTypeRefRec;           // A TypeRef record.
    LPCUTF8         szNameTmp;              // A TypeRef's Name.
    LPCUTF8         szNamespaceTmp;         // A TypeRef's Name.
    LPCUTF8         szAsmRefName;           // assembly ref name
    mdToken         tkResTmp;               // TypeRef's resolution scope.
    mdTypeRef       trKnownDiscardable;
    mdMemberRef     mrType;                 // MemberRef token to the discardable TypeRef
    mdCustomAttribute   cv;
    mdTypeDef       td;
    bool            fFoundCompilerDefinedDiscardabeCA = false;
    TypeDefRec      *pTypeDefRec;
    AssemblyRefRec  *pAsmRefRec;
    RID             ridStart, ridEnd;
    CQuickBytes     qbNamespace;            // Namespace buffer.
    CQuickBytes     qbName;                 // Name buffer.
    ULONG           ulStringLen;            // Length of the TypeDef string.
    int             bSuccess;               // Return value for SplitPath().    

    if (m_pFilterManager == NULL)
        IfFailGo( MarkAll() );

    trKnownDiscardable = mdTypeRefNil;

    // Now find out all of the TypeDefs that are types for transient CAs
    // Mark all public typedefs.
    iCount = pMiniMd->getCountTypeDefs();

    // Find out the TypeRef referring to our library's System.CompilerServices.DiscardableAttribute
    cTypeRefRecs = pMiniMd->getCountTypeRefs();

    ulStringLen = (ULONG)strlen(COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE_ASNI) + 1;
    IfFailGo(qbNamespace.ReSize(ulStringLen));
    IfFailGo(qbName.ReSize(ulStringLen));
    bSuccess = ns::SplitPath(COR_COMPILERSERVICE_DISCARDABLEATTRIBUTE_ASNI,
                             (LPUTF8)qbNamespace.Ptr(),
                             ulStringLen,
                             (LPUTF8)qbName.Ptr(),
                             ulStringLen);
    _ASSERTE(bSuccess);

    // Search for the TypeRef.
    for (i = 1; i <= cTypeRefRecs; i++)
    {
        pTypeRefRec = pMiniMd->getTypeRef(i);
        szNameTmp = pMiniMd->getNameOfTypeRef(pTypeRefRec);
        szNamespaceTmp = pMiniMd->getNamespaceOfTypeRef(pTypeRefRec);

        if (strcmp(szNameTmp, (LPUTF8)qbName.Ptr()) == 0 && strcmp(szNamespaceTmp, (LPUTF8)qbNamespace.Ptr()) == 0)
        {
            // found a match. Now check the resolution scope. Make sure it is a AssemblyRef to mscorlib.dll
            tkResTmp = pMiniMd->getResolutionScopeOfTypeRef(pTypeRefRec);
            if (TypeFromToken(tkResTmp) == mdtAssemblyRef)
            {
                pAsmRefRec = pMiniMd->getAssemblyRef(RidFromToken(tkResTmp));
                szAsmRefName = pMiniMd->getNameOfAssemblyRef(pAsmRefRec);
                if (_stricmp(szAsmRefName, "mscorlib.dll") == 0)
                {
                    trKnownDiscardable = TokenFromRid(i, mdtTypeRef);
                    break;
                }
            }
        }
    }

    if (trKnownDiscardable != mdTypeRefNil)
    {
        hr = ImportHelper::FindMemberRef(pMiniMd, trKnownDiscardable, COR_CTOR_METHOD_NAME, NULL, 0, &mrType);

        // If we cannot find a MemberRef to the .ctor of the System.CompilerServices.DiscardableAttribute,
        // we won't have any TypeDef with the DiscardableAttribute CAs hang off it.
        //
        if (SUCCEEDED(hr))
        {
            // walk all of the user defined typedef
            for (i = 2; i <= iCount; i++)
            {
                pRec = pMiniMd->getTypeDef(i);
                if (IsTdNotPublic(pRec->m_Flags))
                {
                    // check to see if there a CA associated with this TypeDef
                    IfFailGo( ImportHelper::FindCustomAttributeByToken(pMiniMd, TokenFromRid(i, mdtTypeDef), mrType, 0, 0, &cv) );
                    if (hr == S_OK)
                    {
                        // yes, this is a compiler defined discardable CA. Unmark the TypeDef

                        // check the shape of the TypeDef
                        // It should have no field, no event, and no property.
                        
                        // no field
                        pTypeDefRec = pMiniMd->getTypeDef( i );
                        td = TokenFromRid(i, mdtTypeDef);
                        ridStart = pMiniMd->getFieldListOfTypeDef( pTypeDefRec );
                        ridEnd = pMiniMd->getEndFieldListOfTypeDef( pTypeDefRec );
                        if ((ridEnd - ridStart) > 0)
                            continue;

                        // no property
                        ridStart = pMiniMd->FindPropertyMapFor( td );
                        if ( !InvalidRid(ridStart) )
                            continue;

                        // no event
                        ridStart = pMiniMd->FindEventMapFor( td );
                        if ( !InvalidRid(ridStart) )
                            continue;

                        IfFailGo( m_pFilterManager->UnmarkTypeDef( td ) );
                        fFoundCompilerDefinedDiscardabeCA = true;                        
                    }
                }
            }
        }
        if (hr == CLDB_E_RECORD_NOTFOUND)
            hr = NOERROR;
    }

ErrExit:
    return hr;
}   // HRESULT RegMeta::UnmarkAllTransientCAs


//*****************************************************************************
// determine if a token is valid or not
//*****************************************************************************
BOOL RegMeta::IsValidToken(             // true if tk is valid token
    mdToken     tk)                     // [IN] token to be checked
{
    BOOL        bRet = FALSE;           // default to invalid token
    LOCKREAD();
    bRet = _IsValidToken(tk);
    
    return bRet;
} // RegMeta::IsValidToken

//*****************************************************************************
// Helper: determine if a token is valid or not
//*****************************************************************************
BOOL RegMeta::_IsValidToken( // true if tk is valid token
    mdToken     tk)                     // [IN] token to be checked
{
    bool        bRet = false;           // default to invalid token
    RID         rid = RidFromToken(tk);

    if(rid)
    {
        switch (TypeFromToken(tk))
        {
        case mdtModule:
            // can have only one module record
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountModules());
            break;
        case mdtTypeRef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountTypeRefs());
            break;
        case mdtTypeDef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountTypeDefs());
            break;
        case mdtFieldDef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountFields());
            break;
        case mdtMethodDef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountMethods());
            break;
        case mdtParamDef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountParams());
            break;
        case mdtInterfaceImpl:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountInterfaceImpls());
            break;
        case mdtMemberRef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountMemberRefs());
            break;
        case mdtCustomAttribute:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountCustomAttributes());
            break;
        case mdtPermission:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountDeclSecuritys());
            break;
        case mdtSignature:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountStandAloneSigs());
            break;
        case mdtEvent:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountEvents());
            break;
        case mdtProperty:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountPropertys());
            break;
        case mdtModuleRef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountModuleRefs());
            break;
        case mdtTypeSpec:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountTypeSpecs());
            break;
        case mdtAssembly:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountAssemblys());
            break;
        case mdtAssemblyRef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountAssemblyRefs());
            break;
        case mdtFile:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountFiles());
            break;
        case mdtExportedType:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountExportedTypes());
            break;
        case mdtManifestResource:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountManifestResources());
            break;
        case mdtString:
            // need to check the user string heap
            if (m_pStgdb->m_MiniMd.m_USBlobs.IsValidCookie(rid))
                bRet = true;
            break;
        default:
            _ASSERTE(!"Unknown token kind!");
        }
    }// end if(rid)
    return bRet;
}


//*****************************************************************************
// Mark the transitive closure of a token
//*****************************************************************************
STDMETHODIMP RegMeta::MarkToken(        // Return code.
    mdToken     tk)                     // [IN] token to be Marked
{
    HRESULT     hr = NOERROR;
    
    // LOG((LOGMD, "RegMeta::MarkToken(0x%08x)\n", tk));
    START_MD_PERF();
    LOCKWRITE();

    if (m_pStgdb->m_MiniMd.GetFilterTable() == NULL || m_pFilterManager == NULL)
    {
        // UnmarkAll has not been call. Everything is considered marked.
        // No need to do anything extra!
        IfFailGo( META_E_MUST_CALL_UNMARKALL );
    }

    switch ( TypeFromToken(tk) )
    {
    case mdtTypeDef: 
    case mdtMethodDef:
    case mdtFieldDef:
    case mdtMemberRef:
    case mdtTypeRef:
    case mdtTypeSpec:
    case mdtSignature:
    case mdtString:
#if _DEBUG
        if (TypeFromToken(tk) == mdtTypeDef)
        {
            TypeDefRec   *pType;
            pType = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(tk));
            LOG((LOGMD, "MarkToken: Host is marking typetoken 0x%08x with name <%s>\n", tk, m_pStgdb->m_MiniMd.getNameOfTypeDef(pType)));
        }
        else
        if (TypeFromToken(tk) == mdtMethodDef)
        {
            MethodRec   *pMeth;
            pMeth = m_pStgdb->m_MiniMd.getMethod(RidFromToken(tk));
            LOG((LOGMD, "MarkToken: Host is marking methodtoken 0x%08x with name <%s>\n", tk, m_pStgdb->m_MiniMd.getNameOfMethod(pMeth)));
        }
        else
        if (TypeFromToken(tk) == mdtFieldDef)
        {
            FieldRec   *pField;
            pField = m_pStgdb->m_MiniMd.getField(RidFromToken(tk));
            LOG((LOGMD, "MarkToken: Host is marking field token 0x%08x with name <%s>\n", tk, m_pStgdb->m_MiniMd.getNameOfField(pField)));
        }
        else
        {
            LOG((LOGMD, "MarkToken: Host is marking token 0x%08x\n", tk));
        }
#endif // _DEBUG
        if (!_IsValidToken(tk))
            IfFailGo( E_INVALIDARG );

        IfFailGo( m_pFilterManager->Mark(tk) );
        break;

    case mdtBaseType:
        // no need to mark base type
        goto ErrExit;

    default:
        _ASSERTE(!"Bad token type!");
        hr = E_INVALIDARG;
        break;
    }
ErrExit:
    
    STOP_MD_PERF(MarkToken);
    return hr;
} // STDMETHODIMP RegMeta::MarkToken()

//*****************************************************************************
// Unmark everything in this module
//*****************************************************************************
HRESULT RegMeta::IsTokenMarked(
    mdToken     tk,                 // [IN] Token to check if marked or not
    BOOL        *pIsMarked)         // [OUT] true if token is marked
{
    HRESULT     hr = S_OK;
    LOG((LOGMD, "RegMeta::IsTokenMarked(0x%08x)\n", tk));
    START_MD_PERF();
    LOCKREAD();

    FilterTable *pFilter = m_pStgdb->m_MiniMd.GetFilterTable();
    IfNullGo( pFilter );

    if (!_IsValidToken(tk))
        IfFailGo( E_INVALIDARG );

    switch ( TypeFromToken(tk) )
    {
    case mdtTypeRef:
        *pIsMarked = pFilter->IsTypeRefMarked(tk);
        break;
    case mdtTypeDef: 
        *pIsMarked = pFilter->IsTypeDefMarked(tk);
        break;
    case mdtFieldDef:
        *pIsMarked = pFilter->IsFieldMarked(tk);
        break;
    case mdtMethodDef:
        *pIsMarked = pFilter->IsMethodMarked(tk);
        break;
    case mdtParamDef:
        *pIsMarked = pFilter->IsParamMarked(tk);
        break;
    case mdtMemberRef:
        *pIsMarked = pFilter->IsMemberRefMarked(tk);
        break;
    case mdtCustomAttribute:
        *pIsMarked = pFilter->IsCustomAttributeMarked(tk);
        break;
    case mdtPermission:
        *pIsMarked = pFilter->IsDeclSecurityMarked(tk);
        break;
    case mdtSignature:
        *pIsMarked = pFilter->IsSignatureMarked(tk);
        break;
    case mdtEvent:
        *pIsMarked = pFilter->IsEventMarked(tk);
        break;
    case mdtProperty:
        *pIsMarked = pFilter->IsPropertyMarked(tk);
        break;
    case mdtModuleRef:
        *pIsMarked = pFilter->IsModuleRefMarked(tk);
        break;
    case mdtTypeSpec:
        *pIsMarked = pFilter->IsTypeSpecMarked(tk);
        break;
    case mdtInterfaceImpl:
        *pIsMarked = pFilter->IsInterfaceImplMarked(tk);
        break;
    case mdtString:
    default:
        _ASSERTE(!"Bad token type!");
        hr = E_INVALIDARG;
        break;
    }
ErrExit:
    
    STOP_MD_PERF(IsTokenMarked);
    return hr;
}   // IsTokenMarked

//*****************************************************************************
// Create and populate a new TypeDef record.
//*****************************************************************************
STDMETHODIMP RegMeta::DefineTypeDef(                // S_OK or error.
    LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
    DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
    mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
    mdToken     rtkImplements[],        // [IN] Implements interfaces
    mdTypeDef   *ptd)                   // [OUT] Put TypeDef token here
{
    HRESULT     hr = S_OK;              // A result.

    LOG((LOGMD, "RegMeta::DefineTypeDef(%S, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
            MDSTR(szTypeDef), dwTypeDefFlags, tkExtends,
            rtkImplements, ptd));
    START_MD_PERF();
    LOCKWRITE();

    m_pStgdb->m_MiniMd.PreUpdate();

    _ASSERTE(!IsTdNested(dwTypeDefFlags));

    IfFailGo(_DefineTypeDef(szTypeDef, dwTypeDefFlags,
                tkExtends, rtkImplements, mdTokenNil, ptd));
ErrExit:    
    STOP_MD_PERF(DefineTypeDef);
    return hr;
} // STDMETHODIMP RegMeta::DefineTypeDef()


//*****************************************************************************
//*****************************************************************************
STDMETHODIMP RegMeta::SetHandler(       // S_OK.
    IUnknown    *pUnk)                  // [IN] The new error handler.
{
    HRESULT     hr = S_OK;              // A result.

    LOG((LOGMD, "RegMeta::SetHandler(0x%08x)\n", pUnk));
    START_MD_PERF();
    LOCKWRITE();

    m_pHandler = pUnk;

    // Ignore the error return by SetHandler
    m_pStgdb->m_MiniMd.SetHandler(pUnk);

    // Figure out up front if remap is supported.
    IMapToken *pIMap = NULL;
    if (pUnk)
        pUnk->QueryInterface(IID_IMapToken, (PVOID *) &pIMap);
    m_bRemap = (pIMap != 0); 
    if (pIMap)
        pIMap->Release();

    
    STOP_MD_PERF(SetHandler);
    return hr;
} // STDMETHODIMP RegMeta::SetHandler()

//*****************************************************************************
// Close an enumerator.
//*****************************************************************************
void __stdcall RegMeta::CloseEnum(
    HCORENUM        hEnum)          // The enumerator.
{
    LOG((LOGMD, "RegMeta::CloseEnum(0x%08x)\n", hEnum));

    // No need to lock this function.

    HENUMInternal   *pmdEnum = reinterpret_cast<HENUMInternal *> (hEnum);

    if (pmdEnum == NULL)
        return;

    HENUMInternal::DestroyEnum(pmdEnum);
} // void __stdcall RegMeta::CloseEnum()

//*****************************************************************************
// Query the count of items represented by an enumerator.
//*****************************************************************************
STDMETHODIMP RegMeta::CountEnum(
    HCORENUM        hEnum,              // The enumerator.
    ULONG           *pulCount)          // Put the count here.
{
    HENUMInternal   *pmdEnum = reinterpret_cast<HENUMInternal *> (hEnum);
    HRESULT         hr = S_OK;

    // No need to lock this function.

    LOG((LOGMD, "RegMeta::CountEnum(0x%08x, 0x%08x)\n", hEnum, pulCount));
    START_MD_PERF();

    _ASSERTE( pulCount );

    if (pmdEnum == NULL)
    {
        *pulCount = 0;
        goto ErrExit;
    }

    if (pmdEnum->m_tkKind == (TBL_MethodImpl << 24))
    {
        // Number of tokens must always be a multiple of 2.
        _ASSERTE(! (pmdEnum->m_ulCount % 2) );
        // There are two entries in the Enumerator for each MethodImpl.
        *pulCount = pmdEnum->m_ulCount / 2;
    }
    else
        *pulCount = pmdEnum->m_ulCount;
ErrExit:
    STOP_MD_PERF(CountEnum);
    return hr;
} // STDMETHODIMP RegMeta::CountEnum()

//*****************************************************************************
// Reset an enumerator to any position within the enumerator.
//*****************************************************************************
STDMETHODIMP RegMeta::ResetEnum(
    HCORENUM        hEnum,              // The enumerator.
    ULONG           ulPos)              // Seek position.
{
    HENUMInternal   *pmdEnum = reinterpret_cast<HENUMInternal *> (hEnum);
    HRESULT         hr = S_OK;

    // No need to lock this function.

    LOG((LOGMD, "RegMeta::ResetEnum(0x%08x, 0x%08x)\n", hEnum, ulPos));
    START_MD_PERF();

    if (pmdEnum == NULL)
        goto ErrExit;

    pmdEnum->m_ulCur = pmdEnum->m_ulStart + ulPos;

ErrExit:
    STOP_MD_PERF(ResetEnum);
    return hr;
} // STDMETHODIMP RegMeta::ResetEnum()

//*****************************************************************************
// Enumerate Sym.TypeDef.
//*****************************************************************************
STDMETHODIMP RegMeta::EnumTypeDefs(
    HCORENUM    *phEnum,                // Pointer to the enumerator.
    mdTypeDef   rTypeDefs[],            // Put TypeDefs here.
    ULONG       cMax,                   // Max TypeDefs to put.
    ULONG       *pcTypeDefs)            // Put # put here.
{
    HENUMInternal   **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT         hr = S_OK;
    ULONG           cTokens = 0;
    HENUMInternal   *pEnum;

    LOG((LOGMD, "RegMeta::EnumTypeDefs(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
            phEnum, rTypeDefs, cMax, pcTypeDefs));
    START_MD_PERF();
    LOCKREAD();
    

    if ( *ppmdEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);

        if (pMiniMd->HasDelete() && 
            ((m_OptionValue.m_ImportOption & MDImportOptionAllTypeDefs) == 0))
        {
            IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtTypeDef, &pEnum) );

            // add all Types to the dynamic array if name is not _Delete
            for (ULONG index = 2; index <= pMiniMd->getCountTypeDefs(); index ++ )
            {
                TypeDefRec       *pRec = pMiniMd->getTypeDef(index);
                if (IsDeletedName(pMiniMd->getNameOfTypeDef(pRec)) )
                {   
                    continue;
                }
                IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(index, mdtTypeDef) ) );
            }
        }
        else
        {
            // create the enumerator
            IfFailGo( HENUMInternal::CreateSimpleEnum(
                mdtTypeDef, 
                2, 
                pMiniMd->getCountTypeDefs() + 1, 
                &pEnum) );
        }
        
        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    else
    {
        pEnum = *ppmdEnum;
    }

    // we can only fill the minimun of what caller asked for or what we have left
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rTypeDefs, pcTypeDefs);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumTypeDefs);
    return hr;
}   // RegMeta::EnumTypeDefs


//*****************************************************************************
// Enumerate Sym.InterfaceImpl where Coclass == td
//*****************************************************************************
STDMETHODIMP RegMeta::EnumInterfaceImpls(
    HCORENUM        *phEnum,            // Pointer to the enum.
    mdTypeDef       td,                 // TypeDef to scope the enumeration.
    mdInterfaceImpl rImpls[],           // Put InterfaceImpls here.
    ULONG           cMax,               // Max InterfaceImpls to put.
    ULONG           *pcImpls)           // Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = S_OK;
    ULONG               cTokens = 0;
    ULONG               ridStart;
    ULONG               ridEnd;
    HENUMInternal       *pEnum;
    InterfaceImplRec    *pRec;
    ULONG               index;

    LOG((LOGMD, "RegMeta::EnumInterfaceImpls(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
            phEnum, td, rImpls, cMax, pcImpls));
    START_MD_PERF();
    LOCKREAD();
    
    _ASSERTE(TypeFromToken(td) == mdtTypeDef);


    if ( *ppmdEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
        if ( pMiniMd->IsSorted( TBL_InterfaceImpl ) )
        {
            ridStart = pMiniMd->getInterfaceImplsForTypeDef(RidFromToken(td), &ridEnd);
            IfFailGo( HENUMInternal::CreateSimpleEnum( mdtInterfaceImpl, ridStart, ridEnd, &pEnum) );
        }
        else
        {
            // table is not sorted so we have to create dynmaic array 
            // create the dynamic enumerator
            //
            ridStart = 1;
            ridEnd = pMiniMd->getCountInterfaceImpls() + 1;

            IfFailGo( HENUMInternal::CreateDynamicArrayEnum( mdtInterfaceImpl, &pEnum) );             
            
            for (index = ridStart; index < ridEnd; index ++ )
            {
                pRec = pMiniMd->getInterfaceImpl(index);
                if ( td == pMiniMd->getClassOfInterfaceImpl(pRec) )
                {
                    IfFailGo( HENUMInternal::AddElementToEnum(pEnum, TokenFromRid(index, mdtInterfaceImpl) ) );
                }
            }
        }

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    else
    {
        pEnum = *ppmdEnum;
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rImpls, pcImpls);

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    STOP_MD_PERF(EnumInterfaceImpls);
    return hr;
} // STDMETHODIMP RegMeta::EnumInterfaceImpls()

//*****************************************************************************
// Enumerate Sym.TypeRef
//*****************************************************************************
STDMETHODIMP RegMeta::EnumTypeRefs(
    HCORENUM        *phEnum,            // Pointer to the enumerator.
    mdTypeRef       rTypeRefs[],        // Put TypeRefs here.
    ULONG           cMax,               // Max TypeRefs to put.
    ULONG           *pcTypeRefs)        // Put # put here.
{
    HENUMInternal   **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT         hr = S_OK;
    ULONG           cTokens = 0;
    ULONG           cTotal;
    HENUMInternal   *pEnum = *ppmdEnum;

    LOG((LOGMD, "RegMeta::EnumTypeRefs(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
            phEnum, rTypeRefs, cMax, pcTypeRefs));
    START_MD_PERF();
    LOCKREAD();
    

    if ( pEnum == 0 )
    {
        // instantiating a new ENUM
        CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
        cTotal = pMiniMd->getCountTypeRefs();

        IfFailGo( HENUMInternal::CreateSimpleEnum( mdtTypeRef, 1, cTotal + 1, &pEnum) );

        // set the output parameter
        *ppmdEnum = pEnum;          
    }
    
    // fill the output token buffer
    hr = HENUMInternal::EnumWithCount(pEnum, cMax, rTypeRefs, pcTypeRefs);
        
ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);

    
    STOP_MD_PERF(EnumTypeRefs);
    return hr;
} // STDMETHODIMP RegMeta::EnumTypeRefs()

//*****************************************************************************
// Given a namespace and a class name, return the typedef
//*****************************************************************************
STDMETHODIMP RegMeta::FindTypeDefByName(// S_OK or error.
    LPCWSTR     wzTypeDef,              // [IN] Name of the Type.
    mdToken     tkEnclosingClass,       // [IN] Enclosing class.
    mdTypeDef   *ptd)                   // [OUT] Put the TypeDef token here.
{
    HRESULT     hr = S_OK;
    LPSTR       szTypeDef = UTF8STR(wzTypeDef);
    LPCSTR      szNamespace;
    LPCSTR      szName;

    LOG((LOGMD, "{%08x} RegMeta::FindTypeDefByName(%S, 0x%08x, 0x%08x)\n", 
            this, MDSTR(wzTypeDef), tkEnclosingClass, ptd));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(ptd && wzTypeDef);
    _ASSERTE(TypeFromToken(tkEnclosingClass) == mdtTypeDef ||
             TypeFromToken(tkEnclosingClass) == mdtTypeRef ||
             IsNilToken(tkEnclosingClass));

    // initialize output parameter
    *ptd = mdTypeDefNil;

    ns::SplitInline(szTypeDef, szNamespace, szName);
    hr = ImportHelper::FindTypeDefByName(&(m_pStgdb->m_MiniMd),
                                        szNamespace,
                                        szName,
                                        tkEnclosingClass,
                                        ptd);
ErrExit:

    STOP_MD_PERF(FindTypeDefByName);
    return hr;
} // STDMETHODIMP RegMeta::FindTypeDefByName()

//*****************************************************************************
// Get values from Sym.Module
//*****************************************************************************
STDMETHODIMP RegMeta::GetScopeProps(
    LPWSTR      szName,                 // Put name here
    ULONG       cchName,                // Size in chars of name buffer
    ULONG       *pchName,               // Put actual length of name here
    GUID        *pmvid)                 // Put MVID here
{
    HRESULT     hr = S_OK;
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    ModuleRec   *pModuleRec;

    LOG((LOGMD, "RegMeta::GetScopeProps(%S, 0x%08x, 0x%08x, 0x%08x)\n", 
            MDSTR(szName), cchName, pchName, pmvid));
    START_MD_PERF();
    LOCKREAD();

    // there is only one module record
    pModuleRec = pMiniMd->getModule(1);

    if (pmvid)
        *pmvid = *(pMiniMd->getMvidOfModule(pModuleRec));
    if (szName || pchName)
        IfFailGo( pMiniMd->getNameOfModule(pModuleRec, szName, cchName, pchName) );
ErrExit:
    
    STOP_MD_PERF(GetScopeProps);
    return hr;
} // STDMETHODIMP RegMeta::GetScopeProps()

//*****************************************************************************
// Get the token for a Scope's (primary) module record.
//*****************************************************************************
STDMETHODIMP RegMeta::GetModuleFromScope(// S_OK.
    mdModule    *pmd)                   // [OUT] Put mdModule token here.
{
    LOG((LOGMD, "RegMeta::GetModuleFromScope(0x%08x)\n", pmd));
    START_MD_PERF();

    _ASSERTE(pmd);

    // No need to lock this function.

    *pmd = TokenFromRid(1, mdtModule);

    STOP_MD_PERF(GetModuleFromScope);
    return (S_OK);
} // STDMETHODIMP RegMeta::GetModuleFromScope()

//*****************************************************************************
// Given a token, is it (or its parent) global?
//*****************************************************************************
HRESULT RegMeta::IsGlobal(              // S_OK ir error.
    mdToken     tk,                     // [IN] Type, Field, or Method token.
    int         *pbGlobal)              // [OUT] Put 1 if global, 0 otherwise.
{
    HRESULT     hr=S_OK;                // A result.
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    mdToken     tkParent;               // Parent of field or method.
    
    LOG((LOGMD, "RegMeta::GetTokenForGlobalType(0x%08x, %08x)\n", tk, pbGlobal));
    //START_MD_PERF();

    // No need to lock this function.
    
    if (!IsValidToken(tk))
        return E_INVALIDARG;
    
    switch (TypeFromToken(tk))
    {
    case mdtTypeDef:
        *pbGlobal = IsGlobalMethodParentToken(tk);
        break;
        
    case mdtFieldDef:
        IfFailGo( pMiniMd->FindParentOfFieldHelper(tk, &tkParent) );
        *pbGlobal = IsGlobalMethodParentToken(tkParent);
        break;
        
    case mdtMethodDef:
        IfFailGo( pMiniMd->FindParentOfMethodHelper(tk, &tkParent) );
        *pbGlobal = IsGlobalMethodParentToken(tkParent);
        break;
        
    case mdtProperty:
        IfFailGo( pMiniMd->FindParentOfPropertyHelper(tk, &tkParent) );
        *pbGlobal = IsGlobalMethodParentToken(tkParent);
        break;
        
    case mdtEvent:
        IfFailGo( pMiniMd->FindParentOfEventHelper(tk, &tkParent) );
        *pbGlobal = IsGlobalMethodParentToken(tkParent);
        break;
        
    // Anything else is NOT global.
    default:
        *pbGlobal = FALSE;
    }

ErrExit:
    //STOP_MD_PERF(GetModuleFromScope);
    return (S_OK);
} // HRESULT RegMeta::IsGlobal()

//*****************************************************************************
// return flags for a given class
//*****************************************************************************
HRESULT RegMeta::GetTypeDefProps(  // S_OK or error.
    mdTypeDef   td,                     // [IN] TypeDef token for inquiry.
    LPWSTR      szTypeDef,              // [OUT] Put name here.
    ULONG       cchTypeDef,             // [IN] size of name buffer in wide chars.
    ULONG       *pchTypeDef,            // [OUT] put size of name (wide chars) here.
    DWORD       *pdwTypeDefFlags,       // [OUT] Put flags here.
    mdToken     *ptkExtends)            // [OUT] Put base class TypeDef/TypeRef here.
{
    HRESULT     hr = S_OK;
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    TypeDefRec  *pTypeDefRec;
    int         bTruncation=0;          // Was there name truncation?

    LOG((LOGMD, "{%08x} RegMeta::GetTypeDefProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n", 
            this, td, szTypeDef, cchTypeDef, pchTypeDef,
            pdwTypeDefFlags, ptkExtends));
    START_MD_PERF();
    LOCKREAD();

    if (TypeFromToken(td) != mdtTypeDef)
    {
        hr = S_FALSE;
        goto ErrExit;
    }
    _ASSERTE(TypeFromToken(td) == mdtTypeDef);

    pTypeDefRec = pMiniMd->getTypeDef(RidFromToken(td));

    if (szTypeDef || pchTypeDef)
    {
        LPCSTR  szNamespace;
        LPCSTR  szName;

        szNamespace = pMiniMd->getNamespaceOfTypeDef(pTypeDefRec);
        MAKE_WIDEPTR_FROMUTF8(wzNamespace, szNamespace);

        szName = pMiniMd->getNameOfTypeDef(pTypeDefRec);
        MAKE_WIDEPTR_FROMUTF8(wzName, szName);

        if (szTypeDef)
            bTruncation = ! (ns::MakePath(szTypeDef, cchTypeDef, wzNamespace, wzName));
        if (pchTypeDef)
        {
            if (bTruncation || !szTypeDef)
                *pchTypeDef = ns::GetFullLength(wzNamespace, wzName);
            else
                *pchTypeDef = (ULONG)(wcslen(szTypeDef) + 1);
        }
    }
    if (pdwTypeDefFlags)
    {
        // caller wants type flags
        *pdwTypeDefFlags = pMiniMd->getFlagsOfTypeDef(pTypeDefRec);
    }
    if (ptkExtends)
    {
        *ptkExtends = pMiniMd->getExtendsOfTypeDef(pTypeDefRec);

        // take care of the 0 case
        if (RidFromToken(*ptkExtends) == 0)
            *ptkExtends = mdTypeRefNil;
    }

    if (bTruncation && hr == S_OK)
        hr = CLDB_S_TRUNCATION;

ErrExit:

    STOP_MD_PERF(GetTypeDefProps);
    return hr;
} // STDMETHODIMP RegMeta::GetTypeDefProps()


//*****************************************************************************
// Retrieve information about an implemented interface.
//*****************************************************************************
STDMETHODIMP RegMeta::GetInterfaceImplProps(        // S_OK or error.
    mdInterfaceImpl iiImpl,             // [IN] InterfaceImpl token.
    mdTypeDef   *pClass,                // [OUT] Put implementing class token here.
    mdToken     *ptkIface)              // [OUT] Put implemented interface token here.
{
    LOG((LOGMD, "RegMeta::GetInterfaceImplProps(0x%08x, 0x%08x, 0x%08x)\n", 
            iiImpl, pClass, ptkIface));
    START_MD_PERF();
    LOCKREAD();

    _ASSERTE(TypeFromToken(iiImpl) == mdtInterfaceImpl);

    HRESULT         hr = S_OK;
    CMiniMdRW       *pMiniMd = &(m_pStgdb->m_MiniMd);
    InterfaceImplRec *pIIRec = pMiniMd->getInterfaceImpl(RidFromToken(iiImpl));

    if (pClass)
    {
        *pClass = pMiniMd->getClassOfInterfaceImpl(pIIRec);     
    }
    if (ptkIface)
    {
        *ptkIface = pMiniMd->getInterfaceOfInterfaceImpl(pIIRec);       
    }

ErrExit:
    
    STOP_MD_PERF(GetInterfaceImplProps);
    return hr;
} // STDMETHODIMP RegMeta::GetInterfaceImplProps()

//*****************************************************************************
// Retrieve information about a TypeRef.
//*****************************************************************************
STDMETHODIMP RegMeta::GetTypeRefProps(
    mdTypeRef   tr,                     // The class ref token.
    mdToken     *ptkResolutionScope,    // Resolution scope, ModuleRef or AssemblyRef.
    LPWSTR      szTypeRef,              // Put the name here.
    ULONG       cchTypeRef,             // Size of the name buffer, wide chars.
    ULONG       *pchTypeRef)            // Put actual size of name here.
{
    LOG((LOGMD, "RegMeta::GetTypeRefProps(0x%08x, 0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
        tr, ptkResolutionScope, szTypeRef, cchTypeRef, pchTypeRef));

    START_MD_PERF();
    LOCKREAD();
    _ASSERTE(TypeFromToken(tr) == mdtTypeRef);

    HRESULT     hr = S_OK;
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    TypeRefRec  *pTypeRefRec = pMiniMd->getTypeRef(RidFromToken(tr));
    int         bTruncation=0;          // Was there name truncation?

    if (ptkResolutionScope)
        *ptkResolutionScope = pMiniMd->getResolutionScopeOfTypeRef(pTypeRefRec);

    if (szTypeRef || pchTypeRef)
    {
        LPCSTR  szNamespace;
        LPCSTR  szName;

        szNamespace = pMiniMd->getNamespaceOfTypeRef(pTypeRefRec);
        MAKE_WIDEPTR_FROMUTF8(wzNamespace, szNamespace);

        szName = pMiniMd->getNameOfTypeRef(pTypeRefRec);
        MAKE_WIDEPTR_FROMUTF8(wzName, szName);

        if (szTypeRef)
            bTruncation = ! (ns::MakePath(szTypeRef, cchTypeRef, wzNamespace, wzName));
        if (pchTypeRef)
        {
            if (bTruncation || !szTypeRef)
                *pchTypeRef = ns::GetFullLength(wzNamespace, wzName);
            else
                *pchTypeRef = (ULONG)(wcslen(szTypeRef) + 1);
        }
    }
    if (bTruncation && hr == S_OK)
        hr = CLDB_S_TRUNCATION;
ErrExit:
    STOP_MD_PERF(GetTypeRefProps);
    return hr;
} // STDMETHODIMP RegMeta::GetTypeRefProps()

//*****************************************************************************
// Resolving a typeref
//*****************************************************************************
//#define NEW_RESOLVE_TYPEREF 1

STDMETHODIMP RegMeta::ResolveTypeRef(
    mdTypeRef   tr, 
    REFIID      riid, 
    IUnknown    **ppIScope, 
    mdTypeDef   *ptd)
{
    LOG((LOGMD, "{%08x} RegMeta::ResolveTypeRef(0x%08x, 0x%08x, 0x%08x, 0x%08x)\n",
            this, tr, riid, ppIScope, ptd));
    START_MD_PERF();
    LOCKREAD();


    WCHAR       rcModule[_MAX_PATH];
    HRESULT     hr;
    RegMeta     *pMeta = 0;
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);
    TypeRefRec  *pTypeRefRec;
    WCHAR       wzNameSpace[_MAX_PATH];

#ifdef NEW_RESOLVE_TYPEREF
    DWORD size = _MAX_PATH;
    IApplicationContext *pFusionContext = NULL;
    IAssembly *pFusionAssembly = NULL;
    mdToken resolutionToken;
#endif
    _ASSERTE(ppIScope && ptd);

    // Init the output values.
    *ppIScope = 0;
    *ptd = 0;

    if (TypeFromToken(tr) == mdtTypeDef)
    {
        // Shortcut when we receive a TypeDef token
		*ptd = tr;
        STOP_MD_PERF(ResolveTypeRef);
        hr = this->QueryInterface(riid, (void **)ppIScope);
        goto ErrExit;
    }

    // Get the class ref row.
    _ASSERTE(TypeFromToken(tr) == mdtTypeRef);

#ifdef NEW_RESOLVE_TYPEREF
    resolutionToken = tr;
    do {
        pTypeRefRec = pMiniMd->getTypeRef(RidFromToken(resolutionToken));
        resolutionToken = pMiniMd->getResolutionScopeOfTypeRef(pTypeRefRec);
    } while(TypeFromToken(resolutionToken) == mdtTypeRef);

    // look up using the resolution scope. We have two alternatives
    // AssemblyRef and a ModuleRef.
    if(TypeFromToken(resolutionToken) == mdtAssemblyRef) {
        AssemblyRefRec *pRecord;
        pRecord = pMiniMd->getAssemblyRef(RidFromToken(resolutionToken));
        
        AssemblyMetaDataInternal sContext;
        const unsigned char* pbHashValue;
        DWORD cbHashValue;
        const unsigned char* pbPublicKeyOrToken;
        DWORD cbPublicKeyOrToken;
        LPCUTF8 szName = pMiniMd->getNameOfAssemblyRef(pRecord);
        sContext.usMajorVersion = pMiniMd->getMajorVersionOfAssemblyRef(pRecord);
        sContext.usMinorVersion = pMiniMd->getMinorVersionOfAssemblyRef(pRecord);
        sContext.usBuildNumber = pMiniMd->getBuildNumberOfAssemblyRef(pRecord);
        sContext.usRevisionNumber = pMiniMd->getRevisionNumberOfAssemblyRef(pRecord);
        sContext.szLocale = pMiniMd->getLocaleOfAssemblyRef(pRecord);
                 
        sContext.ulProcessor = 0;
        sContext.ulOS = 0;

        pbHashValue = pMiniMd->getHashValueOfAssemblyRef(pRecord, &cbHashValue);
        pbPublicKeyOrToken = pMiniMd->getPublicKeyOrTokenOfAssemblyRef(pRecord, &cbPublicKeyOrToken);

        FusionBind spec;
        IfFailGo(spec.Init(szName,
                           &sContext,
                           (PBYTE) pbHashValue, cbHashValue,
                           (PBYTE) pbPublicKeyOrToken, cbPublicKeyOrToken,
                           pMiniMd->getFlagsOfAssemblyRef(pRecord)));

        IfFailGo(FusionBind::SetupFusionContext(NULL, NULL, NULL, &pFusionContext));
        IfFailGo(spec.LoadAssembly(pFusionContext,
                                   &pFusionAssembly));

        IfFailGo(pFusionAssembly->GetManifestModulePath(wzNameSpace,
                                                        &size));
        if(SUCCEEDED(CORPATHService::FindTypeDef(wzNameSpace,
                                                 tr,
                                                 pMiniMd,
                                                 riid,
                                                 ppIScope,
                                                 ptd))) 
        {
            goto ErrExit;
        }             

    }
    else if(TypeFromToken(resolutionToken) == mdtModuleRef &&
            m_pStgdb &&
            *(m_pStgdb->m_rcDatabase) != 0) {
        // For now we assume that a module ref must reside in the same directory.
        // This is a fairly safe assumption due to the nature of assemblies. All
        // modules must live in the same directory as the manifest.

        // All I need to figure out now is how to get the file name for this
        // Scope?????
        ModuleRefRec *pRecord;
        pRecord = pMiniMd->getModuleRef(RidFromToken(resolutionToken));
        
        LPCUTF8     szNameImp;
        szNameImp = pMiniMd->getNameOfModuleRef(pRecord);

        WCHAR* pFile = &(wzNameSpace[0]);
        WCHAR* directory = wcsrchr(m_pStgdb->m_rcDatabase, L'\\');
        if(directory) {
            DWORD dwChars = directory - m_pStgdb->m_rcDatabase + 1;
            wcsncpy(pFile, m_pStgdb->m_rcDatabase, dwChars);
            pFile += dwChars;
        }

        MAKE_WIDEPTR_FROMUTF8(pwName, szNameImp);
        wcscpy(pFile, pwName);

        if(SUCCEEDED(CORPATHService::FindTypeDef(wzNameSpace,
                                                 tr,
                                                 pMiniMd,
                                                 riid,
                                                 ppIScope,
                                                 ptd))) 
        {
            goto ErrExit;
        }             

    }

#endif                            

    pTypeRefRec = pMiniMd->getTypeRef(RidFromToken(tr));
    IfFailGo( pMiniMd->getNamespaceOfTypeRef(pTypeRefRec, wzNameSpace, lengthof(wzNameSpace), 0) );

    //***********************
    // before we go off to CORPATH, check the loaded modules!
    //***********************
    if ( LOADEDMODULES::ResolveTypeRefWithLoadedModules(
                tr,
                pMiniMd,
                riid,
                ppIScope,
                ptd)  == NOERROR )
    {
        // Done!! We found one match among the loaded modules.
        goto ErrExit;
    }

    wcscpy(rcModule, wzNameSpace);

    //******************
    // Try to find the module on CORPATH
    //******************

    if (wcsncmp(rcModule, L"System.", 16) &&
        wcsncmp(rcModule, L"System/", 16))
    {
        // only go through regular CORPATH lookup by fully qualified class name when
        // it is not System.*
        //
        hr = CORPATHService::GetClassFromCORPath(
            rcModule,
            tr,
            pMiniMd,
            riid,
            ppIScope,
            ptd);
    }
    else 
    {
        // force it to look for System.* in mscorlib.dll
        hr = S_FALSE;
    }

    if (hr == S_FALSE)
    {
        LPWSTR szTmp;
        WszSearchPath(NULL, L"mscorlib.dll", NULL, sizeof(rcModule)/sizeof(rcModule[0]), 
                    rcModule, &szTmp);

        //*******************
        // Last desperate try!!
        //*******************

        // Use the file name "mscorlib:
        IfFailGo( CORPATHService::FindTypeDef(
            rcModule,
            tr,
            pMiniMd,
            riid,
            ppIScope,
            ptd) );
        if (hr == S_FALSE)
        {
            IfFailGo( META_E_CANNOTRESOLVETYPEREF );
        }
    }

ErrExit:
#ifdef NEW_RESOLVE_TYPEREF
    if(pFusionContext)
        pFusionContext->Release();
    if(pFusionAssembly)
        pFusionAssembly->Release();
#endif

    if (FAILED(hr))
    {
        if (pMeta) delete pMeta;
    }

    
    STOP_MD_PERF(ResolveTypeRef);
    return (hr);

} // STDMETHODIMP RegMeta::ResolveTypeRef()} // STDMETHODIMP RegMeta::ResolveTypeRef()


//*****************************************************************************
// Given a TypeRef name, return the typeref
//*****************************************************************************
STDMETHODIMP RegMeta::FindTypeRef(      // S_OK or error.
    mdToken     tkResolutionScope,      // [IN] Resolution Scope.
    LPCWSTR     wzTypeName,             // [IN] Name of the TypeRef.
    mdTypeRef   *ptk)                   // [OUT] Put the TypeRef token here.
{
    HRESULT     hr = S_OK;              // A result.
    LPUTF8      szFullName;
    LPCUTF8     szNamespace;
    LPCUTF8     szName;
    CMiniMdRW   *pMiniMd = &(m_pStgdb->m_MiniMd);

    _ASSERTE(wzTypeName && ptk);

    LOG((LOGMD, "RegMeta::FindTypeRef(0x%8x, %ls, 0x%08x)\n", 
            tkResolutionScope, MDSTR(wzTypeName), ptk));
    START_MD_PERF();
    LOCKREAD();

    // Convert the  name to UTF8.
    szFullName = UTF8STR(wzTypeName);
    ns::SplitInline(szFullName, szNamespace, szName);

    // Look up the name.
    hr = ImportHelper::FindTypeRefByName(pMiniMd, tkResolutionScope,
                                         szNamespace,
                                         szName,
                                         ptk);
ErrExit:
    
    STOP_MD_PERF(FindTypeRef);
    return hr;
} // STDMETHODIMP RegMeta::FindTypeRef()


//*****************************************************************************
// IUnknown
//*****************************************************************************

ULONG RegMeta::AddRef()
{
    return (InterlockedIncrement((long *) &m_cRef));
} // ULONG RegMeta::AddRef()

ULONG RegMeta::Release()
{
    ULONG   cRef = InterlockedDecrement((long *) &m_cRef);
    if (!cRef)
    {   // Try to remove this RegMeta to the loaded module list.  If successful,
        //  delete this Regmeta.
        if (!m_bCached || LOADEDMODULES::RemoveModuleFromLoadedList(this))
            delete this;
    }
    return (cRef);
} // ULONG RegMeta::Release()

// {601C95B9-7398-11d2-9771-00A0C9B4D50C}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegEmit = 
{ 0x601c95b9, 0x7398, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

// {4398B4FD-7399-11d2-9771-00A0C9B4D50C}
extern const GUID DECLSPEC_SELECT_ANY IID_IMetaDataRegImport = 
{ 0x4398b4fd, 0x7399, 0x11d2, { 0x97, 0x71, 0x0, 0xa0, 0xc9, 0xb4, 0xd5, 0xc } };

HRESULT RegMeta::QueryInterface(REFIID riid, void **ppUnk)
{
    int         bRW = false;            // Is requested interface R/W?
    *ppUnk = 0;

    if (riid == IID_IUnknown)
        *ppUnk = (IUnknown *) (IMetaDataEmit *) this;
    else if (riid == IID_IMetaDataEmit)
        *ppUnk = (IMetaDataEmit *) this,                        bRW = true;
    else if (riid == IID_IMetaDataEmitHelper)
        *ppUnk = (IMetaDataEmitHelper *) this,                  bRW = true;
    else if (riid == IID_IMetaDataImport)
        *ppUnk = (IMetaDataImport *) this;
    else if (riid == IID_IMetaDataAssemblyEmit)
        *ppUnk = (IMetaDataAssemblyEmit *) this,                bRW = true;
    else if (riid == IID_IMetaDataAssemblyImport)
        *ppUnk = (IMetaDataAssemblyImport *) this;
    else if (riid == IID_IMetaDataValidate)
        *ppUnk = (IMetaDataValidate *) this;
    else if (riid == IID_IMetaDataFilter)
        *ppUnk = (IMetaDataFilter *) this;
    else if (riid == IID_IMetaDataHelper)
        *ppUnk = (IMetaDataHelper *) this;
    else if (riid == IID_IMetaDataTables)
        *ppUnk = static_cast<IMetaDataTables *>(this);
    else
        return (E_NOINTERFACE);

    if (bRW)
    {
        HRESULT hr;
        LOCKWRITE();
        
        hr = m_pStgdb->m_MiniMd.ConvertToRW();
        if (FAILED(hr))
        {
            *ppUnk = 0;
            return hr;
        }
    }

    AddRef();
    return (S_OK);
}


//*****************************************************************************
// Called by the class factory template to create a new instance of this object.
//*****************************************************************************
HRESULT RegMeta::CreateObject(REFIID riid, void **ppUnk)
{ 
    HRESULT     hr;
    OptionValue options;

    options.m_DupCheck = MDDupAll;
    options.m_RefToDefCheck = MDRefToDefDefault;
    options.m_NotifyRemap = MDNotifyDefault;
    options.m_UpdateMode = MDUpdateFull;
    options.m_ErrorIfEmitOutOfOrder = MDErrorOutOfOrderDefault;

    RegMeta *pMeta = new RegMeta(&options);

    if (pMeta == 0)
        return (E_OUTOFMEMORY);

    hr = pMeta->QueryInterface(riid, ppUnk);
    if (FAILED(hr))
        delete pMeta;
    return (hr);
} // HRESULT RegMeta::CreateObject()

//*****************************************************************************
// Called after a scope is opened to set up any add'l state.  Set the value
// for m_tdModule.
//*****************************************************************************
HRESULT RegMeta::PostOpen()    
{
    // There must always be a Global Module class and its the first entry in
    // the TypeDef table.
    m_tdModule = TokenFromRid(1, mdtTypeDef);
    
    // We don't care about failures yet.
    return (S_OK);
} // HRESULT RegMeta::PostOpen()

//*******************************************************************************
// Internal helper functions.
//*******************************************************************************

//*******************************************************************************
// Perform optimizations of the metadata prior to saving.
//*******************************************************************************
HRESULT RegMeta::PreSave()              // Return code.
{
    HRESULT     hr = S_OK;              // A result.
    CMiniMdRW   *pMiniMd;               // The MiniMd with the data.
    unsigned    bRemapOld = m_bRemap;
    MergeTokenManager *ptkMgr = NULL;

    // For convenience.
    pMiniMd = &(m_pStgdb->m_MiniMd);

    m_pStgdb->m_MiniMd.PreUpdate();

    // If the code has already been optimized there is nothing to do.
    if (m_bSaveOptimized)
        goto ErrExit;


    if (m_newMerger.m_pImportDataList)
    {
        // This is the linker scenario. We we have IMap for each scope. We will create an instance of our own mapper
        // who knows how to send notification back to host!

        // cache the host provided handler to the end our MergeTokenManager

        ptkMgr = new MergeTokenManager (m_newMerger.m_pImportDataList->m_pMDTokenMap, m_pHandler);
        IfNullGo( ptkMgr );
        hr = m_pStgdb->m_MiniMd.SetHandler( ptkMgr );
        _ASSERTE( SUCCEEDED(hr) );
    }



    IfFailGo( RefToDefOptimization() );

    IfFailGo( ProcessFilter() );

    if (m_newMerger.m_pImportDataList)
    {

        // Allocate a token mapper object that will be used for phase 1 if there is not Handler but 
        // linker has provided the IMapToken
        //
        m_bRemap = true;
    }

    // reget the minimd because it can be swapped in the call of ProcessFilter
    pMiniMd = &(m_pStgdb->m_MiniMd);


    // Don't repeat this process again.
    m_bSaveOptimized = true;

    // call get save size to trigger the PreSaveXXX on MetaModelRW class.
    IfFailGo( m_pStgdb->m_MiniMd.PreSave() );
    
ErrExit:
    if ( ptkMgr )
    {

        // recovery the initial state
        hr = m_pStgdb->m_MiniMd.SetHandler(NULL);
        ptkMgr->Release();
    }
    

    m_bRemap =  bRemapOld;
    return (hr);
} // HRESULT RegMeta::PreSave()



//*******************************************************************************
// Perform optimizations of ref to def
//*******************************************************************************
HRESULT RegMeta::RefToDefOptimization()
{
    mdToken     mfdef;                  // Method or Field Def.
    LPCSTR      szName;                 // MemberRef or TypeRef name.
    const COR_SIGNATURE *pvSig;         // Signature of the MemberRef.
    ULONG       cbSig;                  // Size of the signature blob.
    HRESULT     hr = S_OK;              // A result.
    ULONG       iMR;                    // For iterating MemberRefs.
    CMiniMdRW   *pMiniMd;               // The MiniMd with the data.
    ULONG       cMemberRefRecs;         // Count of MemberRefs.
    MemberRefRec *pMemberRefRec;        // A MemberRefRec.

    START_MD_PERF();

    // the Ref to Def map is still up-to-date
    if (IsMemberDefDirty() == false && IsTypeDefDirty() == false && m_hasOptimizedRefToDef == true)
        goto ErrExit;

    pMiniMd = &(m_pStgdb->m_MiniMd);

    // The basic algorithm here is:
    //
    //      calculate all of the TypeRef to TypeDef map and store it at TypeRefToTypeDefMap
    //      for each MemberRef mr
    //      {
    //          get the parent of mr
    //          if (parent of mr is a TypeRef and has been mapped to a TypeDef)
    //          {
    //              Remap MemberRef to MemberDef
    //          }
    //      }
    //
    // There are several places where errors are eaten, since this whole thing is
    // an optimization step and not doing it would still be valid.
    //

    // Ensure the size
    // initialize the token remap manager. This class will track all of the Refs to Defs map and also
    // token movements due to removing pointer tables or sorting.
    //
    if ( pMiniMd->GetTokenRemapManager() == NULL) 
    {

        IfFailGo( pMiniMd->InitTokenRemapManager() );
    }
    else
    {
        IfFailGo( pMiniMd->GetTokenRemapManager()->ClearAndEnsureCapacity(pMiniMd->getCountTypeRefs(), pMiniMd->getCountMemberRefs()));
    }

    // If this is the first time or more TypeDef has been introduced, recalculate the TypeRef to TypeDef map
    if (IsTypeDefDirty() || m_hasOptimizedRefToDef == false)
    {
        IfFailGo( pMiniMd->CalculateTypeRefToTypeDefMap() );
    }

    // If this is the first time or more memberdefs has been introduced, recalculate the TypeRef to TypeDef map
    if (IsMemberDefDirty() || m_hasOptimizedRefToDef == false)
    {
        mdToken     tkParent;
        cMemberRefRecs = pMiniMd->getCountMemberRefs();

        // Enum through all member ref's looking for ref's to internal things.
        for (iMR = 1; iMR<=cMemberRefRecs; iMR++)
        {   // Get a MemberRef.
            pMemberRefRec = pMiniMd->getMemberRef(iMR);

            // If not member of the TypeRef, skip it.
            tkParent = pMiniMd->getClassOfMemberRef(pMemberRefRec);

            if ( TypeFromToken(tkParent) == mdtMethodDef )
            {
                // always track the map even though it is already in the original scope
                *(pMiniMd->GetMemberRefToMemberDefMap()->Get(iMR)) =  tkParent;
                continue;
            }

            if ( TypeFromToken(tkParent) != mdtTypeRef && TypeFromToken(tkParent) != mdtTypeDef )
            {
                // this has been either optimized to mdtMethodDef, mdtFieldDef or referring to
                // ModuleRef
                continue;
            }

            // In the case of global function, we have tkParent as m_tdModule. 
            // We will always do the optmization.
            if (TypeFromToken(tkParent) == mdtTypeRef)
            {
                // The parent is a TypeRef. We need to check to see if this TypeRef is optimized to a TypeDef
                tkParent = *(pMiniMd->GetTypeRefToTypeDefMap()->Get(RidFromToken(tkParent)) );
                // tkParent = pMapTypeRefToTypeDef[RidFromToken(tkParent)];
                if ( RidFromToken(tkParent) == 0)
                {
                    continue;
                }
            }


            // Get the name and signature of this mr.
            szName = pMiniMd->getNameOfMemberRef(pMemberRefRec);
            pvSig = pMiniMd->getSignatureOfMemberRef(pMemberRefRec, &cbSig);
            
            // Look for a member with the same def.  Might not be found if it is
            // inherited from a base class.
            //@future: this should support inheritence checking.
            // Look for a member with the same name and signature.
            hr = ImportHelper::FindMember(pMiniMd, tkParent, szName, pvSig, cbSig, &mfdef);
            if (hr != S_OK)
            {
    #if _TRACE_REMAPS
            // Log the failure.
            LOG((LF_METADATA, LL_INFO10, "Member %S//%S.%S not found\n", szNamespace, szTDName, rcMRName));
    #endif
                continue;
            }

            // We will only record this if mfdef is a methoddef. We don't support
            // parent of MemberRef as fielddef. As if we can optimize MemberRef to FieldDef,
            // we can remove this row.
            //
            if ( (TypeFromToken(mfdef) == mdtMethodDef) &&
                  (m_bRemap || tkParent == m_tdModule ) )
            {
                // Always change the parent if it is the global function.
                // Or change the parent if we have a remap that we can send notification.
                //
                pMiniMd->PutToken(TBL_MemberRef, MemberRefRec::COL_Class, pMemberRefRec, mfdef);
            }
            
            // We will always track the changes. In MiniMd::PreSaveFull, we will use this map to send
            // notification to our host if there is any IMapToken provided.
            //
            *(pMiniMd->GetMemberRefToMemberDefMap()->Get(iMR)) =  mfdef;

        } // EnumMemberRefs
    }

    // Reset return code from likely search failures.
    hr = S_OK;

    SetMemberDefDirty(false);
    SetTypeDefDirty(false);
    m_hasOptimizedRefToDef = true;
ErrExit:
    STOP_MD_PERF(RefToDefOptimization);
    return hr;
}

//*****************************************************************************
// Process filter
//*****************************************************************************
HRESULT RegMeta::ProcessFilter()
{
    HRESULT         hr = NULL;
    CMiniMdRW       *pMiniMd;               // The MiniMd with the data.
    RegMeta         *pMetaNew = NULL;
    CMapToken       *pMergeMap = NULL;
    IMapToken       *pMapNew = NULL;
    MergeTokenManager *pCompositHandler = NULL;
    CLiteWeightStgdbRW  *pStgdbTmp;
    IMapToken       *pHostMapToken = NULL;

    START_MD_PERF();

    // For convenience.
    pMiniMd = &(m_pStgdb->m_MiniMd);
    IfNullGo( pMiniMd->GetFilterTable() );
    if ( pMiniMd->GetFilterTable()->Count() == 0 )
    {
        // there is no filter
        goto ErrExit;
    }

    // Yes, client has used filter to specify what are the metadata needed.
    // We will create another instance of RegMeta and make this module an imported module
    // to be merged into the new RegMeta. We will provide the handler to track all of the token
    // movements. We will replace the merged light weight stgdb to this RegMeta..
    // Then we will need to fix up the MergeTokenManager with this new movement.
    // The reason that we decide to choose this approach is because it will be more complicated
    // and very likely less efficient to fix up the signature blob pool and then compact all of the pools!
    //

    // Create a new RegMeta.
    pMetaNew = new RegMeta(&m_OptionValue);
    IfNullGo( pMetaNew );
    pMetaNew->AddRef();

    // Remember the open type.
    pMetaNew->SetScopeType(DefineForWrite);
    IfFailGo(pMetaNew->Init());
    IfFailGo(pMetaNew->PostInitForWrite());
    IfFailGo(pMetaNew->AddToCache());

    // Ignore the error return by setting handler
    hr = pMetaNew->SetHandler(m_pHandler);

    // create the IMapToken to receive token remap information from merge
    pMergeMap = new CMapToken;
    IfNullGo( pMergeMap );

    // use merge to filter out the unneeded data. But we need to keep COMType and also need to drop off the 
    // CustomAttributes that associated with MemberRef with parent MethodDef
    //
    pMetaNew->m_hasOptimizedRefToDef = false;
    IfFailGo( pMetaNew->m_newMerger.AddImport(this, pMergeMap, NULL) );
    IfFailGo( pMetaNew->m_pStgdb->m_MiniMd.ExpandTables());
    IfFailGo( pMetaNew->m_newMerger.Merge((MergeFlags)(MergeManifest | DropMemberRefCAs | NoDupCheck), MDRefToDefDefault) );

    // Now we need to recalculate the token movement
    // 
    if (m_newMerger.m_pImportDataList)
    {

        // This is the case the filter is applied to merged emit scope. We need calculate how this implicit merge
        // affects the original merge remap. Basically we need to walk all the m_pTkMapList in the merger and replace
        // the to token to the most recent to token.
        // 
        MDTOKENMAP          *pMDTokenMapList;

        pMDTokenMapList = m_newMerger.m_pImportDataList->m_pMDTokenMap;

        MDTOKENMAP          *pMap;
        TOKENREC            *pTKRec;
        ULONG               i;
        mdToken             tkFinalTo;
        ModuleRec           *pMod;
        ModuleRec           *pModNew;
        LPCUTF8             pName;

        // update each import map from merge to have the m_tkTo points to the final mapped to token
        for (pMap = pMDTokenMapList; pMap; pMap = pMap->m_pNextMap)
        {
            // update each record
            for (i = 0; i < (ULONG) (pMap->Count()); i++)
            {
                TOKENREC    *pRecTo;
                pTKRec = pMap->Get(i);
                if ( pMergeMap->Find( pTKRec->m_tkTo, &pRecTo ) )
                {
                    // This record is kept by the filter and the tkTo is changed
                    pRecTo->m_isFoundInImport = true;
                    tkFinalTo = pRecTo->m_tkTo;
                    pTKRec->m_tkTo = tkFinalTo;
                    pTKRec->m_isDeleted = false;

                    // send the notification now. Because after merge, we may have everything in order and 
                    // won't send another set of notification.
                    //
                    LOG((LOGMD, "TokenRemap in RegMeta::ProcessFilter (IMapToken 0x%08x): from 0x%08x to 0x%08x\n", pMap->m_pMap, pTKRec->m_tkFrom, pTKRec->m_tkTo));

                    pMap->m_pMap->Map(pTKRec->m_tkFrom, pTKRec->m_tkTo);
                }
                else
                {
                    // This record is prunned by the filter upon save
                    pTKRec->m_isDeleted = true;
                }
            }
        }

        // now walk the pMergeMap and check to see if there is any entry that is not set to true for m_isFoundInImport.
        // These are the records that from calling DefineXXX methods directly on the Emitting scope!
        if (m_pHandler)
            m_pHandler->QueryInterface(IID_IMapToken, (void **)&pHostMapToken);
        if (pHostMapToken)
        {
            for (i = 0; i < (ULONG) (pMergeMap->m_pTKMap->Count()); i++)
            {
                pTKRec = pMergeMap->m_pTKMap->Get(i);
                if (pTKRec->m_isFoundInImport == false)
                {
                    LOG((LOGMD, "TokenRemap in RegMeta::ProcessFilter (default IMapToken 0x%08x): from 0x%08x to 0x%08x\n", pHostMapToken, pTKRec->m_tkFrom, pTKRec->m_tkTo));

                    // send the notification on the IMapToken from SetHandler of this RegMeta
                    pHostMapToken->Map(pTKRec->m_tkFrom, pTKRec->m_tkTo);
                }
            }
        }

        // Preserve module name across merge.
        pMod = m_pStgdb->m_MiniMd.getModule(1);
        pModNew = pMetaNew->m_pStgdb->m_MiniMd.getModule(1);
        pName = m_pStgdb->m_MiniMd.getNameOfModule(pMod);
        IfFailGo(pMetaNew->m_pStgdb->m_MiniMd.PutString(TBL_Module, ModuleRec::COL_Name, pModNew, pName));

        // now swap the stgdb but keep the merger...
        _ASSERTE( m_bOwnStgdb );
        
        pStgdbTmp = m_pStgdb;
        m_pStgdb = pMetaNew->m_pStgdb;
        pMetaNew->m_pStgdb = pStgdbTmp;
        
    }
    else
    {

        // swap the Stgdb
        pStgdbTmp = m_pStgdb;
        m_pStgdb = pMetaNew->m_pStgdb;
        pMetaNew->m_pStgdb = pStgdbTmp;

        // Client either open an existing scope and apply the filter mechanism, or client define the scope and then
        // apply the filter mechanism.

        // In this case, host better has supplied the handler!!
        _ASSERTE( m_bRemap && m_pHandler);
        IfFailGo( m_pHandler->QueryInterface(IID_IMapToken, (void **) &pMapNew) );

        
        {
            // Send the notification of token movement now because after merge we may not move tokens again
            // and thus no token notification will be send.
            MDTOKENMAP      *pMap = pMergeMap->m_pTKMap;
            TOKENREC        *pTKRec;
            ULONG           i;

            for (i=0; i < (ULONG) (pMap->Count()); i++)
            {
                pTKRec = pMap->Get(i);
                pMap->m_pMap->Map(pTKRec->m_tkFrom, pTKRec->m_tkTo);
            }

        }


        // What we need to do here is create a IMapToken that will replace the original handler. This new IMapToken 
        // upon called will first map the from token to the most original from token.
        //
        pCompositHandler = new MergeTokenManager(pMergeMap->m_pTKMap, NULL);
        IfNullGo( pCompositHandler );

        // now update the following field to hold on to the real IMapToken supplied by our client by SetHandler
        if (pMergeMap->m_pTKMap->m_pMap)
            pMergeMap->m_pTKMap->m_pMap->Release();
        _ASSERTE(pMapNew);
        pMergeMap->m_pTKMap->m_pMap = pMapNew;

        // ownership transferred
        pMergeMap = NULL;
        pMapNew = NULL;
    
        // now you want to replace all of the IMapToken set by calling SetHandler to this new MergeTokenManager
        IfFailGo( m_pStgdb->m_MiniMd.SetHandler(pCompositHandler) );

        m_pHandler = pCompositHandler;

        // ownership transferred
        pCompositHandler = NULL;
    }

    // Force a ref to def optimization because the remap information was stored in the thrown away CMiniMdRW
    m_hasOptimizedRefToDef = false;
    IfFailGo( RefToDefOptimization() );

ErrExit:
    if (pHostMapToken)
        pHostMapToken->Release();
    if (pMetaNew) 
        pMetaNew->Release();
    if (pMergeMap)
        pMergeMap->Release();
    if (pCompositHandler)
        pCompositHandler->Release();
    if (pMapNew)
        pMapNew->Release();
    STOP_MD_PERF(ProcessFilter);
    return hr;
} // HRESULT RegMeta::ProcessFilter()

//*****************************************************************************
// Define a TypeRef given the full qualified name.
//*****************************************************************************
HRESULT RegMeta::_DefineTypeRef(
    mdToken     tkResolutionScope,          // [IN] ModuleRef or AssemblyRef.
    const void  *szName,                    // [IN] Name of the TypeRef.
    BOOL        isUnicode,                  // [IN] Specifies whether the URL is unicode.
    mdTypeRef   *ptk,                       // [OUT] Put mdTypeRef here.
    eCheckDups  eCheck)                     // [IN] Specifies whether to check for duplicates.
{
    HRESULT     hr = S_OK;
    LPCUTF8      szUTF8FullQualName;
    CQuickBytes qbNamespace;
    CQuickBytes qbName;
    int         bSuccess;
    ULONG       ulStringLen;


    _ASSERTE(ptk && szName);
    _ASSERTE (TypeFromToken(tkResolutionScope) == mdtModule ||
              TypeFromToken(tkResolutionScope) == mdtModuleRef ||
              TypeFromToken(tkResolutionScope) == mdtAssemblyRef ||
              TypeFromToken(tkResolutionScope) == mdtTypeRef ||
              tkResolutionScope == mdTokenNil);

    if (isUnicode)
        szUTF8FullQualName = UTF8STR((LPCWSTR)szName);
    else
        szUTF8FullQualName = (LPCUTF8)szName;

    ulStringLen = (ULONG)(strlen(szUTF8FullQualName) + 1);
    IfFailGo(qbNamespace.ReSize(ulStringLen));
    IfFailGo(qbName.ReSize(ulStringLen));
    bSuccess = ns::SplitPath(szUTF8FullQualName,
                             (LPUTF8)qbNamespace.Ptr(),
                             ulStringLen,
                             (LPUTF8)qbName.Ptr(),
                             ulStringLen);
    _ASSERTE(bSuccess);

    // Search for existing TypeRef record.
    if (eCheck==eCheckYes || (eCheck==eCheckDefault && CheckDups(MDDupTypeRef)))
    {
        hr = ImportHelper::FindTypeRefByName(&(m_pStgdb->m_MiniMd), tkResolutionScope,
                                             (LPCUTF8)qbNamespace.Ptr(),
                                             (LPCUTF8)qbName.Ptr(), ptk);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                return S_OK;
            else
                return META_S_DUPLICATE;
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create TypeRef record.
    TypeRefRec      *pRecord;
    RID             iRecord;

    IfNullGo(pRecord = m_pStgdb->m_MiniMd.AddTypeRefRecord(&iRecord));

    // record the more defs are introduced.
    SetTypeDefDirty(true);

    // Give token back to caller.
    *ptk = TokenFromRid(iRecord, mdtTypeRef);

    // Set the fields of the TypeRef record.
    IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_TypeRef, TypeRefRec::COL_Namespace,
                        pRecord, (LPUTF8)qbNamespace.Ptr()));

    IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_TypeRef, TypeRefRec::COL_Name,
                        pRecord, (LPUTF8)qbName.Ptr()));

    if (!IsNilToken(tkResolutionScope))
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_TypeRef, TypeRefRec::COL_ResolutionScope,
                        pRecord, tkResolutionScope));
    IfFailGo(UpdateENCLog(*ptk));

    // Hash the name.
    IfFailGo(m_pStgdb->m_MiniMd.AddNamedItemToHash(TBL_TypeRef, *ptk, (LPUTF8)qbName.Ptr(), 0));

ErrExit:
    return hr;
} // HRESULT RegMeta::_DefineTypeRef()

//*******************************************************************************
// Find a given param of a Method.
//*******************************************************************************
HRESULT RegMeta::_FindParamOfMethod(    // S_OK or error.
    mdMethodDef md,                     // [IN] The owning method of the param.
    ULONG       iSeq,                   // [IN] The sequence # of the param.
    mdParamDef  *pParamDef)             // [OUT] Put ParamDef token here.
{
    ParamRec    *pParamRec;
    RID         ridStart, ridEnd;
    RID         pmRid;

    _ASSERTE(TypeFromToken(md) == mdtMethodDef && pParamDef);

    // get the methoddef record
    MethodRec *pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(md));

    // figure out the start rid and end rid of the parameter list of this methoddef
    ridStart = m_pStgdb->m_MiniMd.getParamListOfMethod(pMethodRec);
    ridEnd = m_pStgdb->m_MiniMd.getEndParamListOfMethod(pMethodRec);

    // loop through each param
    // @consider: parameters are sorted by sequence. Maybe a binary search?
    //
    for (; ridStart < ridEnd; ridStart++)
    {
        pmRid = m_pStgdb->m_MiniMd.GetParamRid(ridStart);
        pParamRec = m_pStgdb->m_MiniMd.getParam(pmRid);
        if (iSeq == m_pStgdb->m_MiniMd.getSequenceOfParam(pParamRec))
        {
            // parameter has the sequence number matches what we are looking for
            *pParamDef = TokenFromRid(pmRid, mdtParamDef);
            return S_OK;
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT RegMeta::_FindParamOfMethod()

//*******************************************************************************
// Define MethodSemantics
//*******************************************************************************
HRESULT RegMeta::_DefineMethodSemantics(    // S_OK or error.
    USHORT      usAttr,                     // [IN] CorMethodSemanticsAttr.
    mdMethodDef md,                         // [IN] Method.
    mdToken     tkAssoc,                    // [IN] Association.
    BOOL        bClear)                     // [IN] Specifies whether to delete the exisiting entries.
{
    HRESULT      hr = S_OK;
    MethodSemanticsRec *pRecord = 0;
    MethodSemanticsRec *pRecord1;           // Use this to recycle a MethodSemantics record.
    RID         iRecord;
    HENUMInternal hEnum;

    _ASSERTE(TypeFromToken(md) == mdtMethodDef || IsNilToken(md));
    _ASSERTE(RidFromToken(tkAssoc));
    memset(&hEnum, 0, sizeof(HENUMInternal));

    // Clear all matching records by setting association to a Nil token.
    if (bClear)
    {
        RID         i;

        IfFailGo( m_pStgdb->m_MiniMd.FindMethodSemanticsHelper(tkAssoc, &hEnum) );
        while (HENUMInternal::EnumNext(&hEnum, (mdToken *)&i))
        {
            pRecord1 = m_pStgdb->m_MiniMd.getMethodSemantics(i);
            if (usAttr == pRecord1->m_Semantic)
            {
                pRecord = pRecord1;
                iRecord = i;
                IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_MethodSemantics,
                    MethodSemanticsRec::COL_Association, pRecord, mdPropertyNil));
                // In Whidbey, we should create ENC log record here.
            }
        }
    }
    // If setting (not just clearing) the association, do that now.
    if (!IsNilToken(md))
    {
        // Create a new record required
        if (! pRecord)
            IfNullGo(pRecord=m_pStgdb->m_MiniMd.AddMethodSemanticsRecord(&iRecord));
    
        // Save the data.
        pRecord->m_Semantic = usAttr;
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_MethodSemantics,
                                             MethodSemanticsRec::COL_Method, pRecord, md));
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_MethodSemantics,
                                             MethodSemanticsRec::COL_Association, pRecord, tkAssoc));
    
        // regardless if we reuse the record or create the record, add the MethodSemantics to the hash
        IfFailGo( m_pStgdb->m_MiniMd.AddMethodSemanticsToHash(iRecord) );
    
        // Create log record for non-token table.
        IfFailGo(UpdateENCLog2(TBL_MethodSemantics, iRecord));
    }

ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
    return hr;
} // HRESULT RegMeta::_DefineMethodSemantics()

//*******************************************************************************
// Given the signature, return the token for signature.
//*******************************************************************************
HRESULT RegMeta::_GetTokenFromSig(              // S_OK or error.
    PCCOR_SIGNATURE pvSig,              // [IN] Signature to define.
    ULONG       cbSig,                  // [IN] Size of signature data.
    mdSignature *pmsig)                 // [OUT] returned signature token.
{
    HRESULT     hr = S_OK;

    _ASSERTE(pmsig);

    if (CheckDups(MDDupSignature))
    {
        hr = ImportHelper::FindStandAloneSig(&(m_pStgdb->m_MiniMd), pvSig, cbSig, pmsig);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                return S_OK;
            else
                return META_S_DUPLICATE;
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    // Create a new record.
    StandAloneSigRec *pSigRec;
    RID     iSigRec;

    IfNullGo(pSigRec = m_pStgdb->m_MiniMd.AddStandAloneSigRecord(&iSigRec));

    // Set output parameter.
    *pmsig = TokenFromRid(iSigRec, mdtSignature);

    // Save signature.
    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_StandAloneSig, StandAloneSigRec::COL_Signature,
                                pSigRec, pvSig, cbSig));
    IfFailGo(UpdateENCLog(*pmsig));
ErrExit:
    return hr;
} // HRESULT RegMeta::_GetTokenFromSig()

//*******************************************************************************
// Turn the specified internal flags on.
//*******************************************************************************
HRESULT RegMeta::_TurnInternalFlagsOn(  // S_OK or error.
    mdToken     tkObj,                  // [IN] Target object whose internal flags are targetted.
    DWORD       flags)                  // [IN] Specifies flags to be turned on.
{
    MethodRec   *pMethodRec;
    FieldRec    *pFieldRec;
    TypeDefRec  *pTypeDefRec;

    switch (TypeFromToken(tkObj))
    {
    case mdtMethodDef:
        pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(tkObj));
        pMethodRec->m_Flags |= flags;
        break;
    case mdtFieldDef:
        pFieldRec = m_pStgdb->m_MiniMd.getField(RidFromToken(tkObj));
        pFieldRec->m_Flags |= flags;
        break;
    case mdtTypeDef:
        pTypeDefRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(tkObj));
        pTypeDefRec->m_Flags |= flags;
        break;
    default:
        _ASSERTE(!"Not supported token type!");
        return E_INVALIDARG;
    }
    return S_OK;
} // HRESULT    RegMeta::_TurnInternalFlagsOn()


//*****************************************************************************
// Helper: Set the properties on the given TypeDef token.
//*****************************************************************************
HRESULT RegMeta::_SetTypeDefProps(      // S_OK or error.
    mdTypeDef   td,                     // [IN] The TypeDef.
    DWORD       dwTypeDefFlags,         // [IN] TypeDef flags.
    mdToken     tkExtends,              // [IN] Base TypeDef or TypeRef.
    mdToken     rtkImplements[])        // [IN] Implemented interfaces.
{
    HRESULT     hr = S_OK;              // A result.
    BOOL        bClear = IsENCOn() || IsCallerExternal();   // Specifies whether to clear the InterfaceImpl records.
    TypeDefRec  *pRecord;               // New TypeDef record.

    _ASSERTE(TypeFromToken(td) == mdtTypeDef);
    _ASSERTE(TypeFromToken(tkExtends) == mdtTypeDef || TypeFromToken(tkExtends) == mdtTypeRef ||
                IsNilToken(tkExtends) || tkExtends == ULONG_MAX);

    // Get the record.
    pRecord=m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(td));

    if (dwTypeDefFlags != ULONG_MAX)
    {
        // No one should try to set the reserved flags explicitly.
        _ASSERTE((dwTypeDefFlags & (tdReservedMask&~tdRTSpecialName)) == 0);
        // Clear the reserved flags from the flags passed in.
        dwTypeDefFlags &= (~tdReservedMask);
        // Preserve the reserved flags stored.
        dwTypeDefFlags |= (pRecord->m_Flags & tdReservedMask);
        // Set the flags.
        pRecord->m_Flags = dwTypeDefFlags;
    }
    if (tkExtends != ULONG_MAX)
    {
        if (IsNilToken(tkExtends))
            tkExtends = mdTypeDefNil;
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_TypeDef, TypeDefRec::COL_Extends,
                                             pRecord, tkExtends));
    }

    // Implemented interfaces.
    if (rtkImplements)
        IfFailGo(_SetImplements(rtkImplements, td, bClear));

    IfFailGo(UpdateENCLog(td));
ErrExit:
    return hr;
} // HRESULT RegMeta::_SetTypeDefProps()


//******************************************************************************
// Creates and sets a row in the InterfaceImpl table.  Optionally clear
// pre-existing records for the owning class.
//******************************************************************************
HRESULT RegMeta::_SetImplements(        // S_OK or error.
    mdToken     rTk[],                  // Array of TypeRef or TypeDef tokens for implemented interfaces.
    mdTypeDef   td,                     // Implementing TypeDef.
    BOOL        bClear)                 // Specifies whether to clear the existing records.
{
    HRESULT     hr = S_OK;
    ULONG       i = 0;
    ULONG       j;
    InterfaceImplRec *pInterfaceImpl;
    RID         iInterfaceImpl;
    RID         ridStart;
    RID         ridEnd;
    CQuickBytes cqbTk;
    const mdToken *pTk;

    _ASSERTE(TypeFromToken(td) == mdtTypeDef && rTk);
    _ASSERTE(!m_bSaveOptimized && "Cannot change records after PreSave() and before Save().");

    // Clear all exising InterfaceImpl records by setting the parent to Nil.
    if (bClear)
    {
        IfFailGo(m_pStgdb->m_MiniMd.GetInterfaceImplsForTypeDef(
                                        RidFromToken(td), &ridStart, &ridEnd));
        for (j = ridStart; j < ridEnd; j++)
        {
            pInterfaceImpl = m_pStgdb->m_MiniMd.getInterfaceImpl(
                                        m_pStgdb->m_MiniMd.GetInterfaceImplRid(j));
            _ASSERTE (td == m_pStgdb->m_MiniMd.getClassOfInterfaceImpl(pInterfaceImpl));
            IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_InterfaceImpl, InterfaceImplRec::COL_Class,
                                                 pInterfaceImpl, mdTypeDefNil));
        }
    }

    // Eliminate duplicates from the array passed in.
    if (CheckDups(MDDupInterfaceImpl))
    {
        IfFailGo(_InterfaceImplDupProc(rTk, td, &cqbTk));
        pTk = (mdToken *)cqbTk.Ptr();
    }
    else
        pTk = rTk;

    // Loop for each implemented interface.
    while (!IsNilToken(pTk[i]))
    {
        _ASSERTE(TypeFromToken(pTk[i]) == mdtTypeRef || TypeFromToken(pTk[i]) == mdtTypeDef);

        // Create the interface implementation record.
        IfNullGo(pInterfaceImpl = m_pStgdb->m_MiniMd.AddInterfaceImplRecord(&iInterfaceImpl));

        // Set data.
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_InterfaceImpl, InterfaceImplRec::COL_Class,
                                            pInterfaceImpl, td));
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_InterfaceImpl, InterfaceImplRec::COL_Interface,
                                            pInterfaceImpl, pTk[i]));

        i++;

        IfFailGo(UpdateENCLog(TokenFromRid(mdtInterfaceImpl, iInterfaceImpl)));
    }
ErrExit:
    return hr;
} // HRESULT RegMeta::_SetImplements()

//******************************************************************************
// This routine eliminates duplicates from the given list of InterfaceImpl tokens
// to be defined.  It checks for duplicates against the database only if the
// TypeDef for which these tokens are being defined is not a new one.
//******************************************************************************
HRESULT RegMeta::_InterfaceImplDupProc( // S_OK or error.
    mdToken     rTk[],                  // Array of TypeRef or TypeDef tokens for implemented interfaces.
    mdTypeDef   td,                     // Implementing TypeDef.
    CQuickBytes *pcqbTk)                // Quick Byte object for placing the array of unique tokens.
{
    HRESULT     hr = S_OK;
    ULONG       i = 0;
    ULONG       iUniqCount = 0;
    BOOL        bDupFound;

    while (!IsNilToken(rTk[i]))
    {
        _ASSERTE(TypeFromToken(rTk[i]) == mdtTypeRef || TypeFromToken(rTk[i]) == mdtTypeDef);
        bDupFound = false;

        // Eliminate duplicates from the input list of tokens by looking within the list.
        for (ULONG j = 0; j < iUniqCount; j++)
        {
            if (rTk[i] == ((mdToken *)pcqbTk->Ptr())[j])
            {
                bDupFound = true;
                break;
            }
        }

        // If no duplicate is found record it in the list.
        if (!bDupFound)
        {
            IfFailGo(pcqbTk->ReSize((iUniqCount+1) * sizeof(mdToken)));
            ((mdToken *)pcqbTk->Ptr())[iUniqCount] = rTk[i];
            iUniqCount++;
        }
        i++;
    }

    // Create a Nil token to signify the end of list.
    IfFailGo(pcqbTk->ReSize((iUniqCount+1) * sizeof(mdToken)));
    ((mdToken *)pcqbTk->Ptr())[iUniqCount] = mdTokenNil;
ErrExit:
    return hr;
} // HRESULT RegMeta::_InterfaceImplDupProc()

//*******************************************************************************
// helper to define event
//*******************************************************************************
HRESULT RegMeta::_DefineEvent(          // Return hresult.
    mdTypeDef   td,                     // [IN] the class/interface on which the event is being defined 
    LPCWSTR     szEvent,                // [IN] Name of the event   
    DWORD       dwEventFlags,           // [IN] CorEventAttr    
    mdToken     tkEventType,            // [IN] a reference (mdTypeRef or mdTypeRef) to the Event class 
    mdEvent     *pmdEvent)              // [OUT] output event token 
{
    HRESULT     hr = S_OK;
    EventRec    *pEventRec = NULL;
    RID         iEventRec;
    EventMapRec *pEventMap;
    RID         iEventMap;
    mdEvent     mdEv;
    LPCUTF8     szUTF8Event = UTF8STR(szEvent);

    _ASSERTE(TypeFromToken(td) == mdtTypeDef && td != mdTypeDefNil);
    _ASSERTE(IsNilToken(tkEventType) || TypeFromToken(tkEventType) == mdtTypeDef ||
                TypeFromToken(tkEventType) == mdtTypeRef);
    _ASSERTE(szEvent && pmdEvent);

    if (CheckDups(MDDupEvent))
    {
        hr = ImportHelper::FindEvent(&(m_pStgdb->m_MiniMd), td, szUTF8Event, pmdEvent);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
                pEventRec = m_pStgdb->m_MiniMd.getEvent(RidFromToken(*pmdEvent));
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    if (! pEventRec)
    {
        // Create a new map if one doesn't exist already, else retrieve the existing one.
        // The event map must be created before the EventRecord, the new event map will
        // be pointing past the first event record.
        iEventMap = m_pStgdb->m_MiniMd.FindEventMapFor(RidFromToken(td));
        if (InvalidRid(iEventMap))
        {
            // Create new record.
            IfNullGo(pEventMap=m_pStgdb->m_MiniMd.AddEventMapRecord(&iEventMap));
            // Set parent.
            IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_EventMap, 
                                            EventMapRec::COL_Parent, pEventMap, td));
            IfFailGo(UpdateENCLog2(TBL_EventMap, iEventMap));
        }
        else
        {
            pEventMap = m_pStgdb->m_MiniMd.getEventMap(iEventMap);
        }

        // Create a new event record.
        IfNullGo(pEventRec = m_pStgdb->m_MiniMd.AddEventRecord(&iEventRec));

        // Set output parameter.
        *pmdEvent = TokenFromRid(iEventRec, mdtEvent);

        // Add Event to EventMap.
        IfFailGo(m_pStgdb->m_MiniMd.AddEventToEventMap(RidFromToken(iEventMap), iEventRec));
    
        IfFailGo(UpdateENCLog2(TBL_EventMap, iEventMap, CMiniMdRW::eDeltaEventCreate));     
    }

    mdEv = *pmdEvent;

    // Set data
    IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_Event, EventRec::COL_Name, pEventRec, szUTF8Event));
    IfFailGo(_SetEventProps1(*pmdEvent, dwEventFlags, tkEventType));

    // Add the <Event token, typedef token> to the lookup table
    if (m_pStgdb->m_MiniMd.HasIndirectTable(TBL_Event))
        IfFailGo( m_pStgdb->m_MiniMd.AddEventToLookUpTable(*pmdEvent, td) );

    IfFailGo(UpdateENCLog(*pmdEvent));

ErrExit:
    return hr;
} // HRESULT RegMeta::_DefineEvent()


//******************************************************************************
// Set the specified properties on the Event Token.
//******************************************************************************
HRESULT RegMeta::_SetEventProps1(                // Return hresult.
    mdEvent     ev,                     // [IN] Event token.
    DWORD       dwEventFlags,           // [IN] Event flags.
    mdToken     tkEventType)            // [IN] Event type class.
{
    EventRec    *pRecord;
    HRESULT     hr = S_OK;

    _ASSERTE(TypeFromToken(ev) == mdtEvent && RidFromToken(ev));

    pRecord = m_pStgdb->m_MiniMd.getEvent(RidFromToken(ev));
    if (dwEventFlags != ULONG_MAX)
    {
        // Don't let caller set reserved bits
        dwEventFlags &= ~evReservedMask;
        // Preserve reserved bits.
        dwEventFlags |= (pRecord->m_EventFlags & evReservedMask);
        
        pRecord->m_EventFlags = static_cast<USHORT>(dwEventFlags);
    }
    if (!IsNilToken(tkEventType))
        IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_Event, EventRec::COL_EventType,
                                             pRecord, tkEventType));
ErrExit:
    return hr;
} // HRESULT RegMeta::_SetEventProps1()

//******************************************************************************
// Set the specified properties on the given Event token.
//******************************************************************************
HRESULT RegMeta::_SetEventProps2(                // Return hresult.
    mdEvent     ev,                     // [IN] Event token.
    mdMethodDef mdAddOn,                // [IN] Add method.
    mdMethodDef mdRemoveOn,             // [IN] Remove method.
    mdMethodDef mdFire,                 // [IN] Fire method.
    mdMethodDef rmdOtherMethods[],      // [IN] An array of other methods.
    BOOL        bClear)                 // [IN] Specifies whether to clear the existing MethodSemantics records.
{
    EventRec    *pRecord;
    HRESULT     hr = S_OK;

    _ASSERTE(TypeFromToken(ev) == mdtEvent && RidFromToken(ev));

    pRecord = m_pStgdb->m_MiniMd.getEvent(RidFromToken(ev));

    // Remember the AddOn method.
    if (!IsNilToken(mdAddOn))
    {
        _ASSERTE(TypeFromToken(mdAddOn) == mdtMethodDef);
        IfFailGo(_DefineMethodSemantics(msAddOn, mdAddOn, ev, bClear));
    }

    // Remember the RemoveOn method.
    if (!IsNilToken(mdRemoveOn))
    {
        _ASSERTE(TypeFromToken(mdRemoveOn) == mdtMethodDef);
        IfFailGo(_DefineMethodSemantics(msRemoveOn, mdRemoveOn, ev, bClear));
    }

    // Remember the fire method.
    if (!IsNilToken(mdFire))
    {
        _ASSERTE(TypeFromToken(mdFire) == mdtMethodDef);
        IfFailGo(_DefineMethodSemantics(msFire, mdFire, ev, bClear));
    }

    // Store all of the other methods.
    if (rmdOtherMethods)
    {
        int         i = 0;
        mdMethodDef mb;

        while (1)
        {
            mb = rmdOtherMethods[i++];
            if (IsNilToken(mb))
                break;
            _ASSERTE(TypeFromToken(mb) == mdtMethodDef);
            IfFailGo(_DefineMethodSemantics(msOther, mb, ev, bClear));

            // The first call would've clear all the existing ones.
            bClear = false;
        }
    }
ErrExit:
    return hr;
} // HRESULT RegMeta::_SetEventProps2()

//******************************************************************************
// Set Permission on the given permission token.
//******************************************************************************
HRESULT RegMeta::_SetPermissionSetProps(         // Return hresult.
    mdPermission tkPerm,                // [IN] Permission token.
    DWORD       dwAction,               // [IN] CorDeclSecurity.
    void const  *pvPermission,          // [IN] Permission blob.
    ULONG       cbPermission)           // [IN] Count of bytes of pvPermission.
{
    DeclSecurityRec *pRecord;
    HRESULT     hr = S_OK;

    _ASSERTE(TypeFromToken(tkPerm) == mdtPermission && cbPermission != ULONG_MAX);
    _ASSERTE(dwAction && dwAction <= dclMaximumValue);

    pRecord = m_pStgdb->m_MiniMd.getDeclSecurity(RidFromToken(tkPerm));

    IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_DeclSecurity, DeclSecurityRec::COL_PermissionSet,
                                        pRecord, pvPermission, cbPermission));
ErrExit:
    return hr;
} // HRESULT RegMeta::_SetPermissionSetProps()

//******************************************************************************
// Define or set value on a constant record.
//******************************************************************************
HRESULT RegMeta::_DefineSetConstant(    // Return hresult.
    mdToken     tk,                     // [IN] Parent token.
    DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
    void const  *pValue,                // [IN] Constant value.
    ULONG       cchString,              // [IN] Size of string in wide chars, or -1 for default.
    BOOL        bSearch)                // [IN] Specifies whether to search for an existing record.
{
    HRESULT     hr = S_OK;

    if ((dwCPlusTypeFlag != ELEMENT_TYPE_VOID && dwCPlusTypeFlag != ELEMENT_TYPE_END &&
         dwCPlusTypeFlag != ULONG_MAX) &&
        (pValue || (pValue == 0 && (dwCPlusTypeFlag == ELEMENT_TYPE_STRING ||
                                    dwCPlusTypeFlag == ELEMENT_TYPE_CLASS))))
    {
        ConstantRec *pConstRec = 0;
        RID         iConstRec;
        ULONG       cbBlob;
        ULONG       ulValue = 0;

        if (bSearch)
        {
            iConstRec = m_pStgdb->m_MiniMd.FindConstantHelper(tk);
            if (!InvalidRid(iConstRec))
                pConstRec = m_pStgdb->m_MiniMd.getConstant(iConstRec);
        }
        if (! pConstRec)
        {
            IfNullGo(pConstRec=m_pStgdb->m_MiniMd.AddConstantRecord(&iConstRec));
            IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_Constant, ConstantRec::COL_Parent,
                                                 pConstRec, tk));
            IfFailGo( m_pStgdb->m_MiniMd.AddConstantToHash(iConstRec) );
        }

        // Add values to the various columns of the constant value row.
        pConstRec->m_Type = static_cast<BYTE>(dwCPlusTypeFlag);
        if (!pValue)
            pValue = &ulValue;
        cbBlob = _GetSizeOfConstantBlob(dwCPlusTypeFlag, (void *)pValue, cchString);
        if (cbBlob > 0)
            IfFailGo(m_pStgdb->m_MiniMd.PutBlob(TBL_Constant, ConstantRec::COL_Value,
                                                pConstRec, pValue, cbBlob));


        // Create log record for non-token record.
        IfFailGo(UpdateENCLog2(TBL_Constant, iConstRec));
    }
ErrExit:
    return hr;
} // HRESULT RegMeta::_DefineSetConstant()


//*****************************************************************************
// Helper: Set the properties on the given Method token.
//*****************************************************************************
HRESULT RegMeta::_SetMethodProps(       // S_OK or error.
    mdMethodDef md,                     // [IN] The MethodDef.
    DWORD       dwMethodFlags,          // [IN] Method attributes.
    ULONG       ulCodeRVA,              // [IN] Code RVA.
    DWORD       dwImplFlags)            // [IN] MethodImpl flags.
{
    MethodRec   *pRecord;
    HRESULT     hr = S_OK;

    _ASSERTE(TypeFromToken(md) == mdtMethodDef && RidFromToken(md));

    // Get the Method record.
    pRecord = m_pStgdb->m_MiniMd.getMethod(RidFromToken(md));

    // Set the data.
    if (dwMethodFlags != ULONG_MAX)
    {
        // Preserve the reserved flags stored already and always keep the mdRTSpecialName
        dwMethodFlags |= (pRecord->m_Flags & mdReservedMask);
    
        // Set the flags.
        pRecord->m_Flags = static_cast<USHORT>(dwMethodFlags);
    }
    if (ulCodeRVA != ULONG_MAX)
        pRecord->m_RVA = ulCodeRVA;
    if (dwImplFlags != ULONG_MAX)
        pRecord->m_ImplFlags = static_cast<USHORT>(dwImplFlags);

    IfFailGo(UpdateENCLog(md));
ErrExit:
    return hr;
} // HRESULT RegMeta::_SetMethodProps()


//*****************************************************************************
// Helper: Set the properties on the given Field token.
//*****************************************************************************
HRESULT RegMeta::_SetFieldProps(        // S_OK or error.
    mdFieldDef  fd,                     // [IN] The FieldDef.
    DWORD       dwFieldFlags,           // [IN] Field attributes.
    DWORD       dwCPlusTypeFlag,        // [IN] Flag for the value type, selected ELEMENT_TYPE_*
    void const  *pValue,                // [IN] Constant value.
    ULONG       cchValue)               // [IN] size of constant value (string, in wide chars).
{
    FieldRec    *pRecord;
    HRESULT     hr = S_OK;
    int         bHasDefault = false;    // If defining a constant, in this call.

    _ASSERTE (TypeFromToken(fd) == mdtFieldDef && RidFromToken(fd));

    // Get the Field record.
    pRecord = m_pStgdb->m_MiniMd.getField(RidFromToken(fd));

    // See if there is a Constant.
    if ((dwCPlusTypeFlag != ELEMENT_TYPE_VOID && dwCPlusTypeFlag != ELEMENT_TYPE_END &&
         dwCPlusTypeFlag != ULONG_MAX) &&
        (pValue || (pValue == 0 && (dwCPlusTypeFlag == ELEMENT_TYPE_STRING ||
                                    dwCPlusTypeFlag == ELEMENT_TYPE_CLASS))))
    {
        if (dwFieldFlags == ULONG_MAX)
            dwFieldFlags = pRecord->m_Flags;
        dwFieldFlags |= fdHasDefault;

        bHasDefault = true;
    }

    // Set the flags.
    if (dwFieldFlags != ULONG_MAX)
    {
        if ( IsFdHasFieldRVA(dwFieldFlags) && !IsFdHasFieldRVA(pRecord->m_Flags) ) 
        {
            // This will trigger field RVA to be created if it is not yet created!
            _SetRVA(fd, 0, 0);
        }

        // Preserve the reserved flags stored.
        dwFieldFlags |= (pRecord->m_Flags & fdReservedMask);
        // Set the flags.
        pRecord->m_Flags = static_cast<USHORT>(dwFieldFlags);
    }

    IfFailGo(UpdateENCLog(fd));
    
    // Set the Constant.
    if (bHasDefault)
    {
        BOOL bSearch = IsCallerExternal() || IsENCOn();
        IfFailGo(_DefineSetConstant(fd, dwCPlusTypeFlag, pValue, cchValue, bSearch));
    }

ErrExit:
    return hr;
} // HRESULT RegMeta::_SetFieldProps()

//*****************************************************************************
// Helper: Set the properties on the given Property token.
//*****************************************************************************
HRESULT RegMeta::_SetPropertyProps(      // S_OK or error.
    mdProperty  pr,                     // [IN] Property token.
    DWORD       dwPropFlags,            // [IN] CorPropertyAttr.
    DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type, selected ELEMENT_TYPE_*
    void const  *pValue,                // [IN] Constant value.
    ULONG       cchValue,               // [IN] size of constant value (string, in wide chars).
    mdMethodDef mdSetter,               // [IN] Setter of the property.
    mdMethodDef mdGetter,               // [IN] Getter of the property.
    mdMethodDef rmdOtherMethods[])      // [IN] Array of other methods.
{
    PropertyRec *pRecord;
    BOOL        bClear = IsCallerExternal() || IsENCOn() || IsIncrementalOn();
    HRESULT     hr = S_OK;
    int         bHasDefault = false;    // If true, constant value this call.

    _ASSERTE(TypeFromToken(pr) == mdtProperty && RidFromToken(pr));

    pRecord = m_pStgdb->m_MiniMd.getProperty(RidFromToken(pr));

    if (dwPropFlags != ULONG_MAX)
    {
        // Clear the reserved flags from the flags passed in.
        dwPropFlags &= (~prReservedMask);
    }
    // See if there is a constant.
    if ((dwCPlusTypeFlag != ELEMENT_TYPE_VOID && dwCPlusTypeFlag != ELEMENT_TYPE_END &&
         dwCPlusTypeFlag != ULONG_MAX) &&
        (pValue || (pValue == 0 && (dwCPlusTypeFlag == ELEMENT_TYPE_STRING ||
                                    dwCPlusTypeFlag == ELEMENT_TYPE_CLASS))))
    {
        if (dwPropFlags == ULONG_MAX)
            dwPropFlags = pRecord->m_PropFlags;
        dwPropFlags |= prHasDefault;
        
        bHasDefault = true;
    }
    if (dwPropFlags != ULONG_MAX)
    {
        // Preserve the reserved flags.
        dwPropFlags |= (pRecord->m_PropFlags & prReservedMask);
        // Set the flags.
        pRecord->m_PropFlags = static_cast<USHORT>(dwPropFlags);
    }

    // store the getter (or clear out old one).
    if (mdGetter != ULONG_MAX)
    {
        _ASSERTE(TypeFromToken(mdGetter) == mdtMethodDef || IsNilToken(mdGetter));
        IfFailGo(_DefineMethodSemantics(msGetter, mdGetter, pr, bClear));
    }

    // Store the setter (or clear out old one).
    if (mdSetter != ULONG_MAX)
    {
        _ASSERTE(TypeFromToken(mdSetter) == mdtMethodDef || IsNilToken(mdSetter));
        IfFailGo(_DefineMethodSemantics(msSetter, mdSetter, pr, bClear));
    }

    // Store all of the other methods.
    if (rmdOtherMethods)
    {
        int         i = 0;
        mdMethodDef mb;

        while (1)
        {
            mb = rmdOtherMethods[i++];
            if (IsNilToken(mb))
                break;
            _ASSERTE(TypeFromToken(mb) == mdtMethodDef);
            IfFailGo(_DefineMethodSemantics(msOther, mb, pr, bClear));

            // The first call to _DefineMethodSemantics would've cleared all the records
            // that match with msOther and pr.
            bClear = false;
        }
    }

    IfFailGo(UpdateENCLog(pr));
    
    // Set the constant.
    if (bHasDefault)
    {
        BOOL bSearch = IsCallerExternal() || IsENCOn() || IsIncrementalOn();
        IfFailGo(_DefineSetConstant(pr, dwCPlusTypeFlag, pValue, cchValue, bSearch));
    }

ErrExit:
    return hr;
} // HRESULT RegMeta::_SetPropertyProps()


//*****************************************************************************
// Helper: This routine sets properties on the given Param token.
//*****************************************************************************
HRESULT RegMeta::_SetParamProps(        // Return code.
    mdParamDef  pd,                     // [IN] Param token.   
    LPCWSTR     szName,                 // [IN] Param name.
    DWORD       dwParamFlags,           // [IN] Param flags.
    DWORD       dwCPlusTypeFlag,        // [IN] Flag for value type. selected ELEMENT_TYPE_*.
    void const  *pValue,                // [OUT] Constant value.
    ULONG       cchValue)               // [IN] size of constant value (string, in wide chars).
{
    HRESULT     hr = S_OK;
    ParamRec    *pRecord;
    int         bHasDefault = false;    // Is there a default this call.

    _ASSERTE(TypeFromToken(pd) == mdtParamDef && RidFromToken(pd));

    pRecord = m_pStgdb->m_MiniMd.getParam(RidFromToken(pd));

    // Set the properties.
    if (szName)
        IfFailGo(m_pStgdb->m_MiniMd.PutStringW(TBL_Param, ParamRec::COL_Name, pRecord, szName));

    if (dwParamFlags != ULONG_MAX)
    {
        // No one should try to set the reserved flags explicitly.
        _ASSERTE((dwParamFlags & pdReservedMask) == 0);
        // Clear the reserved flags from the flags passed in.
        dwParamFlags &= (~pdReservedMask);
    }
    // See if there is a constant.
    if ((dwCPlusTypeFlag != ELEMENT_TYPE_VOID && dwCPlusTypeFlag != ELEMENT_TYPE_END &&
         dwCPlusTypeFlag != ULONG_MAX) &&
        (pValue || (pValue == 0 && (dwCPlusTypeFlag == ELEMENT_TYPE_STRING ||
                                    dwCPlusTypeFlag == ELEMENT_TYPE_CLASS))))
    {
        if (dwParamFlags == ULONG_MAX)
            dwParamFlags = pRecord->m_Flags;
        dwParamFlags |= pdHasDefault;

        bHasDefault = true;
    }
    // Set the flags.
    if (dwParamFlags != ULONG_MAX)
    {
        // Preserve the reserved flags stored.
        dwParamFlags |= (pRecord->m_Flags & pdReservedMask);
        // Set the flags.
        pRecord->m_Flags = static_cast<USHORT>(dwParamFlags);
    }

    // ENC log for the param record.
    IfFailGo(UpdateENCLog(pd));
    
    // Defer setting the constant until after the ENC log for the param.  Due to the way that
    //  parameter records are re-ordered, ENC needs the param record log entry to be IMMEDIATELY
    //  after the param added function.

    // Set the constant.
    if (bHasDefault)
    {
        BOOL bSearch = IsCallerExternal() || IsENCOn();
        IfFailGo(_DefineSetConstant(pd, dwCPlusTypeFlag, pValue, cchValue, bSearch));
    }

ErrExit:
    return hr;
} // HRESULT RegMeta::_SetParamProps()

//*****************************************************************************
// Create and populate a new TypeDef record.
//*****************************************************************************
HRESULT RegMeta::_DefineTypeDef(        // S_OK or error.
    LPCWSTR     szTypeDef,              // [IN] Name of TypeDef
    DWORD       dwTypeDefFlags,         // [IN] CustomAttribute flags
    mdToken     tkExtends,              // [IN] extends this TypeDef or typeref 
    mdToken     rtkImplements[],        // [IN] Implements interfaces
    mdTypeDef   tdEncloser,             // [IN] TypeDef token of the Enclosing Type.
    mdTypeDef   *ptd)                   // [OUT] Put TypeDef token here
{
    HRESULT     hr = S_OK;              // A result.
    TypeDefRec  *pRecord = NULL;        // New TypeDef record.
    RID         iRecord;                // New TypeDef RID.
    const BOOL  bNoClear = false;       // constant for "don't clear impls".
    CQuickBytes qbNamespace;            // Namespace buffer.
    CQuickBytes qbName;                 // Name buffer.
    LPCUTF8     szTypeDefUTF8;          // Full name in UTF8.
    ULONG       ulStringLen;            // Length of the TypeDef string.
    int         bSuccess;               // Return value for SplitPath().

    _ASSERTE(IsTdAutoLayout(dwTypeDefFlags) || IsTdSequentialLayout(dwTypeDefFlags) || IsTdExplicitLayout(dwTypeDefFlags));

    _ASSERTE(ptd);
    _ASSERTE(TypeFromToken(tkExtends) == mdtTypeRef || TypeFromToken(tkExtends) == mdtTypeDef ||
                IsNilToken(tkExtends));
    _ASSERTE(szTypeDef && *szTypeDef);
    _ASSERTE(IsNilToken(tdEncloser) || IsTdNested(dwTypeDefFlags));

    szTypeDefUTF8 = UTF8STR(szTypeDef);
    ulStringLen = (ULONG)(strlen(szTypeDefUTF8) + 1);
    IfFailGo(qbNamespace.ReSize(ulStringLen));
    IfFailGo(qbName.ReSize(ulStringLen));
    bSuccess = ns::SplitPath(szTypeDefUTF8,
                             (LPUTF8)qbNamespace.Ptr(),
                             ulStringLen,
                             (LPUTF8)qbName.Ptr(),
                             ulStringLen);
    _ASSERTE(bSuccess);

    if (CheckDups(MDDupTypeDef))
    {
        // Check for existence.  Do a query by namespace and name.
        hr = ImportHelper::FindTypeDefByName(&(m_pStgdb->m_MiniMd),
                                             (LPCUTF8)qbNamespace.Ptr(),
                                             (LPCUTF8)qbName.Ptr(),
                                             tdEncloser,
                                             ptd);
        if (SUCCEEDED(hr))
        {
            if (IsENCOn())
            {
                pRecord = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(*ptd));
                // @FUTURE: Should we check to see if the GUID passed is correct?
            }
            else
            {
                hr = META_S_DUPLICATE;
                goto ErrExit;
            }
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
    }

    if (!pRecord)
    {
        // Create the new record.
        IfNullGo(pRecord=m_pStgdb->m_MiniMd.AddTypeDefRecord(&iRecord));

        // Invalidate the ref to def optimization since more def is introduced
        SetTypeDefDirty(true);

        if (!IsNilToken(tdEncloser))
        {
            NestedClassRec  *pNestedClassRec;
            RID         iNestedClassRec;

            // Create a new NestedClass record.
            IfNullGo(pNestedClassRec = m_pStgdb->m_MiniMd.AddNestedClassRecord(&iNestedClassRec));
            // Set the NestedClass value.
            IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_NestedClass, NestedClassRec::COL_NestedClass,
                                                 pNestedClassRec, TokenFromRid(iRecord, mdtTypeDef)));
            // Set the NestedClass value.
            IfFailGo(m_pStgdb->m_MiniMd.PutToken(TBL_NestedClass, NestedClassRec::COL_EnclosingClass,
                                                 pNestedClassRec, tdEncloser));

            IfFailGo( m_pStgdb->m_MiniMd.AddNestedClassToHash(iNestedClassRec) );

            // Create the log record for the non-token record.
            IfFailGo(UpdateENCLog2(TBL_NestedClass, iNestedClassRec));
        }

        // Give token back to caller.
        *ptd = TokenFromRid(iRecord, mdtTypeDef);
    }

    // Set the namespace and name.
    IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_TypeDef, TypeDefRec::COL_Name,
                                          pRecord, (LPCUTF8)qbName.Ptr()));
    IfFailGo(m_pStgdb->m_MiniMd.PutString(TBL_TypeDef, TypeDefRec::COL_Namespace,
                                          pRecord, (LPCUTF8)qbNamespace.Ptr()));

    SetCallerDefine();
    IfFailGo(_SetTypeDefProps(*ptd, dwTypeDefFlags, tkExtends, rtkImplements));
ErrExit:
    SetCallerExternal();

    return hr;
} // HRESULT RegMeta::_DefineTypeDef()


//******************************************************************************
//--- IMetaDataTables
//******************************************************************************
HRESULT RegMeta::GetStringHeapSize(    
    ULONG   *pcbStrings)                // [OUT] Size of the string heap.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    return m_pStgdb->m_MiniMd.m_Strings.GetRawSize(pcbStrings);
} // HRESULT RegMeta::GetStringHeapSize()

HRESULT RegMeta::GetBlobHeapSize(
    ULONG   *pcbBlobs)                  // [OUT] Size of the Blob heap.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    return m_pStgdb->m_MiniMd.m_Blobs.GetRawSize(pcbBlobs);
} // HRESULT RegMeta::GetBlobHeapSize()

HRESULT RegMeta::GetGuidHeapSize(
    ULONG   *pcbGuids)                  // [OUT] Size of the Guid heap.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    return m_pStgdb->m_MiniMd.m_Guids.GetRawSize(pcbGuids);
} // HRESULT RegMeta::GetGuidHeapSize()

HRESULT RegMeta::GetUserStringHeapSize(
    ULONG   *pcbStrings)                // [OUT] Size of the User String heap.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    return m_pStgdb->m_MiniMd.m_USBlobs.GetRawSize(pcbStrings);
} // HRESULT RegMeta::GetUserStringHeapSize()

HRESULT RegMeta::GetNumTables(
    ULONG   *pcTables)                  // [OUT] Count of tables.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    *pcTables = TBL_COUNT;
    return S_OK;
} // HRESULT RegMeta::GetNumTables()

HRESULT RegMeta::GetTableIndex(   
    ULONG   token,                      // [IN] Token for which to get table index.
    ULONG   *pixTbl)                    // [OUT] Put table index here.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    *pixTbl = CMiniMdRW::GetTableForToken(token);
    return S_OK;
} // HRESULT RegMeta::GetTableIndex()

HRESULT RegMeta::GetTableInfo(
    ULONG   ixTbl,                      // [IN] Which table.
    ULONG   *pcbRow,                    // [OUT] Size of a row, bytes.
    ULONG   *pcRows,                    // [OUT] Number of rows.
    ULONG   *pcCols,                    // [OUT] Number of columns in each row.
    ULONG   *piKey,                     // [OUT] Key column, or -1 if none.
    const char **ppName)                // [OUT] Name of the table.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    if (ixTbl >= TBL_COUNT)
        return E_INVALIDARG;
    CMiniTableDef *pTbl = &m_pStgdb->m_MiniMd.m_TableDefs[ixTbl];
    if (pcbRow)
        *pcbRow = pTbl->m_cbRec;
    if (pcRows)
        *pcRows = m_pStgdb->m_MiniMd.vGetCountRecs(ixTbl);
    if (pcCols)
        *pcCols = pTbl->m_cCols;
    if (piKey)
        *piKey = (pTbl->m_iKey == -1) ? -1 : pTbl->m_iKey;
    if (ppName)
        *ppName = g_Tables[ixTbl].m_pName;
    
    return S_OK;
} // HRESULT RegMeta::GetTableInfo()

HRESULT RegMeta::GetColumnInfo(   
    ULONG   ixTbl,                      // [IN] Which Table
    ULONG   ixCol,                      // [IN] Which Column in the table
    ULONG   *poCol,                     // [OUT] Offset of the column in the row.
    ULONG   *pcbCol,                    // [OUT] Size of a column, bytes.
    ULONG   *pType,                     // [OUT] Type of the column.
    const char **ppName)                // [OUT] Name of the Column.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    if (ixTbl >= TBL_COUNT)
        return E_INVALIDARG;
    CMiniTableDef *pTbl = &m_pStgdb->m_MiniMd.m_TableDefs[ixTbl];
    if (ixCol >= pTbl->m_cCols)
        return E_INVALIDARG;
    CMiniColDef *pCol = &pTbl->m_pColDefs[ixCol];
    if (poCol)
        *poCol = pCol->m_oColumn;
    if (pcbCol)
        *pcbCol = pCol->m_cbColumn;
    if (pType)
        *pType = pCol->m_Type;
    if (ppName)
        *ppName = g_Tables[ixTbl].m_pColNames[ixCol];

    return S_OK;
} //  HRESULT RegMeta::GetColumnInfo()

HRESULT RegMeta::GetCodedTokenInfo(   
    ULONG   ixCdTkn,                    // [IN] Which kind of coded token.
    ULONG   *pcTokens,                  // [OUT] Count of tokens.
    ULONG   **ppTokens,                 // [OUT] List of tokens.
    const char **ppName)                // [OUT] Name of the CodedToken.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    // Validate arguments.
    if (ixCdTkn >= CDTKN_COUNT)
        return E_INVALIDARG;

    if (pcTokens)
        *pcTokens = g_CodedTokens[ixCdTkn].m_cTokens;
    if (ppTokens)
        *ppTokens = (ULONG*)g_CodedTokens[ixCdTkn].m_pTokens;
    if (ppName)
        *ppName = g_CodedTokens[ixCdTkn].m_pName;

    return S_OK;
} // HRESULT RegMeta::GetCodedTokenInfo()

HRESULT RegMeta::GetRow(      
    ULONG   ixTbl,                      // [IN] Which table.
    ULONG   rid,                        // [IN] Which row.
    void    **ppRow)                    // [OUT] Put pointer to row here.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    // Validate arguments.
    if (ixTbl >= TBL_COUNT)
        return E_INVALIDARG;
    CMiniTableDef *pTbl = &m_pStgdb->m_MiniMd.m_TableDefs[ixTbl];
    if (rid == 0 || rid > m_pStgdb->m_MiniMd.m_Schema.m_cRecs[ixTbl])
        return E_INVALIDARG;

    // Get the row.
    *ppRow = m_pStgdb->m_MiniMd.getRow(ixTbl, rid);

    return S_OK;
} // HRESULT RegMeta::GetRow()

HRESULT RegMeta::GetColumn(
    ULONG   ixTbl,                      // [IN] Which table.
    ULONG   ixCol,                      // [IN] Which column.
    ULONG   rid,                        // [IN] Which row.
    ULONG   *pVal)                      // [OUT] Put the column contents here.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    void    *pRow;                      // Row with data.

    // Validate arguments.
    if (ixTbl >= TBL_COUNT)
        return E_INVALIDARG;
    CMiniTableDef *pTbl = &m_pStgdb->m_MiniMd.m_TableDefs[ixTbl];
    if (ixCol >= pTbl->m_cCols)
        return E_INVALIDARG;
    if (rid == 0 || rid > m_pStgdb->m_MiniMd.m_Schema.m_cRecs[ixTbl])
        return E_INVALIDARG;

    // Get the row.
    pRow = m_pStgdb->m_MiniMd.getRow(ixTbl, rid);

    // Is column a token column?
    CMiniColDef *pCol = &pTbl->m_pColDefs[ixCol];
    if (pCol->m_Type <= iCodedTokenMax)
        *pVal = m_pStgdb->m_MiniMd.GetToken(ixTbl, ixCol, pRow);
    else
        *pVal = m_pStgdb->m_MiniMd.GetCol(ixTbl, ixCol, pRow);

    return S_OK;
} // HRESULT RegMeta::GetColumn()

HRESULT RegMeta::GetString(   
    ULONG   ixString,                   // [IN] Value from a string column.
    const char **ppString)              // [OUT] Put a pointer to the string here.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    *ppString = m_pStgdb->m_MiniMd.getString(ixString);
    return S_OK;
} // HRESULT RegMeta::GetString()

HRESULT RegMeta::GetBlob(     
    ULONG   ixBlob,                     // [IN] Value from a blob column.
    ULONG   *pcbData,                   // [OUT] Put size of the blob here.
    const void **ppData)                // [OUT] Put a pointer to the blob here.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    *ppData = m_pStgdb->m_MiniMd.getBlob(ixBlob, pcbData);
    return S_OK;
} // HRESULT RegMeta::GetBlob()

HRESULT RegMeta::GetGuid(     
    ULONG   ixGuid,                     // [IN] Value from a guid column.
    const GUID **ppGuid)                // [OUT] Put a pointer to the GUID here.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    *ppGuid = m_pStgdb->m_MiniMd.getGuid(ixGuid);
    return S_OK;
} // HRESULT RegMeta::GetGuid()

HRESULT RegMeta::GetUserString(   
    ULONG   ixUserString,               // [IN] Value from a UserString column.
    ULONG   *pcbData,                   // [OUT] Put size of the UserString here.
    const void **ppData)                // [OUT] Put a pointer to the UserString here.
{
    // These are for dumping metadata information. 
    // We probably don't need to do any lock here.

    *ppData = m_pStgdb->m_MiniMd.GetUserString(ixUserString, pcbData);
    return S_OK;
} // HRESULT RegMeta::GetUserString()

HRESULT RegMeta::GetNextString(   
    ULONG   ixString,                   // [IN] Value from a string column.
    ULONG   *pNext)                     // [OUT] Put the index of the next string here.
{
    return m_pStgdb->m_MiniMd.m_Strings.GetNextItem(ixString, pNext);
} // STDMETHODIMP GetNextString()

HRESULT RegMeta::GetNextBlob(     
    ULONG   ixBlob,                     // [IN] Value from a blob column.
    ULONG   *pNext)                     // [OUT] Put the index of the netxt blob here.
{
    return m_pStgdb->m_MiniMd.m_Blobs.GetNextItem(ixBlob, pNext);
} // STDMETHODIMP GetNextBlob()

HRESULT RegMeta::GetNextGuid(     
    ULONG   ixGuid,                     // [IN] Value from a guid column.
    ULONG   *pNext)                     // [OUT] Put the index of the next guid here.
{
    return m_pStgdb->m_MiniMd.m_Guids.GetNextItem(ixGuid, pNext);
} // STDMETHODIMP GetNextGuid()

HRESULT RegMeta::GetNextUserString(    
    ULONG   ixUserString,               // [IN] Value from a UserString column.
    ULONG   *pNext)                     // [OUT] Put the index of the next user string here.
{
    return m_pStgdb->m_MiniMd.m_USBlobs.GetNextItem(ixUserString, pNext);
} // STDMETHODIMP GetNextUserString()



//*****************************************************************************
// Using the existing RegMeta and reopen with another chuck of memory. Make sure that all stgdb
// is still kept alive.
//*****************************************************************************
HRESULT RegMeta::ReOpenWithMemory(     
    LPCVOID     pData,                  // [in] Location of scope data.
    ULONG       cbData)                 // [in] Size of the data pointed to by pData.
{
    HRESULT         hr = NOERROR;
    LOCKWRITE();

    // put the current m_pStgdb to the free list
    m_pStgdb->m_pNextStgdb = m_pStgdbFreeList;
    m_pStgdbFreeList = m_pStgdb;
    m_pStgdb = new CLiteWeightStgdbRW;
    IfNullGo( m_pStgdb );
    IfFailGo( PostInitForRead(0, const_cast<void*>(pData), cbData, 0, false) );

    // we are done!

ErrExit:
    if (FAILED(hr))
    {
        // recover to the old state
        if (m_pStgdb)
            delete m_pStgdb;
        m_pStgdb = m_pStgdbFreeList;
        m_pStgdbFreeList = m_pStgdbFreeList->m_pNextStgdb;
    }
    
    return hr;
} // HRESULT RegMeta::ReOpenWithMemory()


//*****************************************************************************
// This function returns the requested public interface based on the given
// internal import interface.
//*****************************************************************************
STDAPI MDReOpenMetaDataWithMemory(
    void        *pImport,               // [IN] Given scope. public interfaces
    LPCVOID     pData,                  // [in] Location of scope data.
    ULONG       cbData)                 // [in] Size of the data pointed to by pData.
{
    HRESULT             hr = S_OK;
    IUnknown            *pUnk = (IUnknown *) pImport;
    IMetaDataImport     *pMDImport = NULL;
    RegMeta             *pRegMeta = NULL;

    _ASSERTE(pImport);
    IfFailGo( pUnk->QueryInterface(IID_IMetaDataImport, (void **) &pMDImport) );
    pRegMeta = (RegMeta*) pMDImport;

    IfFailGo( pRegMeta->ReOpenWithMemory(pData, cbData) );

ErrExit:
    if (pMDImport)
        pMDImport->Release();
    return hr;
} // STDAPI MDReOpenMetaDataWithMemory()

//******************************************************************************
// --- IMetaDataTables
//******************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\mdutil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDUtil.h
//
// Contains utility code for MD directory
//
//*****************************************************************************
#ifndef __MDUtil__h__
#define __MDUtil__h__

#include "MetaData.h"


HRESULT _GetFixedSigOfVarArg(           // S_OK or error.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob of COM+ method signature
    ULONG   cbSigBlob,                  // [IN] size of signature
    CQuickBytes *pqbSig,                // [OUT] output buffer for fixed part of VarArg Signature
    ULONG   *pcbSigBlob);               // [OUT] number of bytes written to the above output buffer

ULONG _GetSizeOfConstantBlob(
    DWORD       dwCPlusTypeFlag,            // ELEMENT_TYPE_*
    void        *pValue,                    // BLOB value
    ULONG       cchString);                 // Size of string in wide chars, or -1 for auto.


//*********************************************************************
// APIs to help look up TypeRef using CORPATH environment variable
//*********************************************************************
class CORPATHService
{
public:

    static HRESULT GetClassFromCORPath(
        LPWSTR      wzClassname,            // fully qualified class name
        mdTypeRef   tr,                     // TypeRef to be resolved
        IMetaModelCommon *pCommon,          // Scope in which the TypeRef is defined.
        REFIID      riid, 
        IUnknown    **ppIScope,
        mdTypeDef   *ptd);                  // [OUT] typedef corresponding the typeref

    static HRESULT GetClassFromDir(
        LPWSTR      wzClassname,            // Fully qualified class name.
        LPWSTR      dir,                    // Directory to try.
        int         iLen,                   // Length of the directory.
        mdTypeRef   tr,                     // TypeRef to resolve.
        IMetaModelCommon *pCommon,          // Scope in which the TypeRef is defined.
        REFIID      riid, 
        IUnknown    **ppIScope,
        mdTypeDef   *ptd);                  // [OUT] typedef

    static HRESULT FindTypeDef(
        LPWSTR      wzModule,               // name of the module that we are going to open
        mdTypeRef   tr,                     // TypeRef to resolve.
        IMetaModelCommon *pCommon,          // Scope in which the TypeRef is defined.
        REFIID      riid, 
        IUnknown    **ppIScope,
        mdTypeDef   *ptd );                 // [OUT] the type that we resolve to
};


class RegMeta;

//*********************************************************************
//
// Structure to record the all loaded modules and helpers.
// RegMeta instance is added to the global variable that is tracking 
// the opened scoped. This happens in the RegMeta's constructor. 
// In RegMeta's destructor, the RegMeta pointer will be removed from
// this list.
//
//*********************************************************************
class UTSemReadWrite;
class LOADEDMODULES : public CDynArray<RegMeta *> 
{
public:
    static UTSemReadWrite *m_pSemReadWrite; // Lock for mulit-threading
    
    static HRESULT AddModuleToLoadedList(RegMeta *pRegMeta);
    static BOOL RemoveModuleFromLoadedList(RegMeta *pRegMeta);  // true if found and removed.
    static HRESULT ResolveTypeRefWithLoadedModules(
        mdTypeRef   tr,                     // [IN] TypeRef to be resolved.
        IMetaModelCommon *pCommon,          // [IN] scope in which the typeref is defined.
        REFIID      riid,                   // [IN] iid for the return interface
        IUnknown    **ppIScope,             // [OUT] return interface
        mdTypeDef   *ptd);                  // [OUT] typedef corresponding the typeref

};



#endif // __MDUtil__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\newmerger.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Merger.cpp
//
// contains utility code to MD directory
//
//*****************************************************************************
#include "stdafx.h"
#include "NewMerger.h"
#include "RegMeta.h"
#include "ImportHelper.h"
#include "RWUtil.h"
#include "MDLog.h"
#include <PostError.h>

#define MODULEDEFTOKEN         TokenFromRid(1, mdtModule)

CMiniMdRW *NEWMERGER::GetMiniMdEmit() 
{
    return &(m_pRegMetaEmit->m_pStgdb->m_MiniMd); 
}


//*****************************************************************************
// constructor
//*****************************************************************************
NEWMERGER::NEWMERGER()
 :  m_pRegMetaEmit(0),
    m_pImportDataList(NULL),
    m_optimizeRefToDef(MDRefToDefDefault)
{
    m_pImportDataTail = &(m_pImportDataList);
#if _DEBUG
    m_iImport = 0;
#endif // _DEBUG
}   // MERGER


//*****************************************************************************
// initializer
//*****************************************************************************
HRESULT NEWMERGER::Init(RegMeta *pRegMeta) 
{
    m_pRegMetaEmit = pRegMeta;
    return NOERROR;
}   // Init


//*****************************************************************************
// destructor
//*****************************************************************************
NEWMERGER::~NEWMERGER()
{
    if (m_pImportDataList)
    {
        // delete this list and release all AddRef'ed interfaces!
        MergeImportData *pNext;
        for (pNext = m_pImportDataList; pNext != NULL; )
        {
            pNext = m_pImportDataList->m_pNextImportData;
            if (m_pImportDataList->m_pHandler)
                m_pImportDataList->m_pHandler->Release();
            if (m_pImportDataList->m_pHostMapToken)
                m_pImportDataList->m_pHostMapToken->Release();
            if (m_pImportDataList->m_pError)
                m_pImportDataList->m_pError->Release();
            if (m_pImportDataList->m_pMDTokenMap)
                delete m_pImportDataList->m_pMDTokenMap;
            m_pImportDataList->m_pRegMetaImport->Release();
            delete m_pImportDataList;
            m_pImportDataList = pNext;
        }
    }
}   // ~MERGER


//*****************************************************************************
// Adding a new import
//*****************************************************************************
HRESULT NEWMERGER::AddImport(
    IMetaDataImport *pImport,               // [IN] The scope to be merged.
    IMapToken   *pHostMapToken,             // [IN] Host IMapToken interface to receive token remap notification
    IUnknown    *pHandler)                  // [IN] An object to receive to receive error notification.
{
    HRESULT             hr = NOERROR;
    MergeImportData     *pData;

    // Add a MergeImportData to track the information for this import scope
    pData = new MergeImportData;
    IfNullGo( pData );
    pData->m_pRegMetaImport = (RegMeta *)pImport;
    pData->m_pRegMetaImport->AddRef();
    pData->m_pHostMapToken = pHostMapToken;
    if (pData->m_pHostMapToken)
        pData->m_pHostMapToken->AddRef();
    if (pHandler)
    {
        pData->m_pHandler = pHandler;
        pData->m_pHandler->AddRef();
    }
    else
    {
        pData->m_pHandler = NULL;
    }

    // don't query for IMetaDataError until we need one.
    pData->m_pError = NULL;
    pData->m_pMDTokenMap = NULL;
    pData->m_pNextImportData = NULL;
#if _DEBUG
    pData->m_iImport = ++m_iImport;
#endif // _DEBUG

    // add the newly create node to the tail of the list
    *m_pImportDataTail = pData;
    m_pImportDataTail = &(pData->m_pNextImportData);
ErrExit:
    return hr;
}   // AddImport


//*****************************************************************************
// Merge now
//*****************************************************************************
HRESULT NEWMERGER::Merge(MergeFlags dwMergeFlags, CorRefToDefCheck optimizeRefToDef)
{
    MergeImportData     *pImportData = m_pImportDataList;
    MDTOKENMAP          **pPrevMap = NULL;
    MDTOKENMAP          *pMDTokenMap;
    HRESULT             hr = NOERROR;
    MDTOKENMAP          *pCurTKMap;
    int                 i;

#if _DEBUG
    {
    LOG((LOGMD, "++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"));
    LOG((LOGMD, "Merge scope list\n"));
    i = 0;
    for (MergeImportData *pID = m_pImportDataList; pID != NULL; pID = pID->m_pNextImportData)
    {
        WCHAR szScope[1024], szGuid[40];
        GUID mvid;
        ULONG cchScope;
        pID->m_pRegMetaImport->GetScopeProps(szScope, 1024, &cchScope, &mvid);
        szScope[1023] = 0;
        GuidToLPWSTR(mvid, szGuid, 40);
        ++i; // Counter is 1-based.
        LOG((LOGMD, "%3d: %ls : %ls\n", i, szGuid, szScope));
    }
    LOG((LOGMD, "++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"));
    }
#endif // _DEBUG
    
    m_dwMergeFlags = dwMergeFlags;
    m_optimizeRefToDef = optimizeRefToDef;

    // check to see if we need to do dup check
    m_fDupCheck = ((m_dwMergeFlags & NoDupCheck) != NoDupCheck);

    while (pImportData)
    {
        // Verify that we have a filter for each import scope.
        IfNullGo( pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd.GetFilterTable() );

        // create the tokenmap class to track metadata token remap for each import scope
        pMDTokenMap = new MDTOKENMAP;
        IfNullGo(pMDTokenMap);
        IfFailGo(pMDTokenMap->Init((IMetaDataImport*)pImportData->m_pRegMetaImport));
        pImportData->m_pMDTokenMap = pMDTokenMap;
        pImportData->m_pMDTokenMap->m_pMap = pImportData->m_pHostMapToken;
        if (pImportData->m_pHostMapToken)
            pImportData->m_pHostMapToken->AddRef();
        pImportData->m_pMDTokenMap->m_pNextMap = NULL;
        if (pPrevMap)
            *pPrevMap = pImportData->m_pMDTokenMap;
        pPrevMap = &(pImportData->m_pMDTokenMap->m_pNextMap);
        pImportData = pImportData->m_pNextImportData;
    }

    // 1. Merge Module
    IfFailGo( MergeModule( ) );

    // 2. Merge TypeDef partially (i.e. only name)
    IfFailGo( MergeTypeDefNamesOnly() );

    // 3. Merge ModuleRef property and do ModuleRef to ModuleDef optimization
    IfFailGo( MergeModuleRefs() );

    // 4. Merge AssemblyRef. 
    IfFailGo( MergeAssemblyRefs() );

    // 5. Merge TypeRef with TypeRef to TypeDef optimization
    IfFailGo( MergeTypeRefs() );

    // 6. Now Merge the remaining of TypeDef records
    IfFailGo( CompleteMergeTypeDefs() );

    // 7. Merge TypeSpec
    IfFailGo( MergeTypeSpecs() );

    // 8. Merge Methods and Fields. Such that Signature translation is respecting the TypeRef to TypeDef optimization.
    IfFailGo( MergeTypeDefChildren() );


    // 9. Merge MemberRef with MemberRef to MethodDef/FieldDef optimization
    IfFailGo( MergeMemberRefs( ) );

    // 10. Merge InterfaceImpl
    IfFailGo( MergeInterfaceImpls( ) );

    // merge all of the remaining in metadata ....

    // 11. constant has dependency on property, field, param
    IfFailGo( MergeConstants() );

    // 12. field marshal has dependency on param and field
    IfFailGo( MergeFieldMarshals() );

    // 13. in ClassLayout, move over the FieldLayout and deal with FieldLayout as well
    IfFailGo( MergeClassLayouts() );

    // 14. FieldLayout has dependency on FieldDef.
    IfFailGo( MergeFieldLayouts() );

    // 15. FieldRVA has dependency on FieldDef.
    IfFailGo( MergeFieldRVAs() );
        
    // 16. MethodImpl has dependency on MemberRef, MethodDef, TypeRef and TypeDef.
    IfFailGo( MergeMethodImpls() );

    // 17. pinvoke depends on MethodDef and ModuleRef
    IfFailGo( MergePinvoke() );

    IfFailGo( MergeStandAloneSigs() );

    IfFailGo( MergeStrings() );

    if (m_dwMergeFlags & MergeManifest)
    {
        // keep the manifest!!
        IfFailGo( MergeAssembly() );
        IfFailGo( MergeFiles() );
        IfFailGo( MergeExportedTypes() );
        IfFailGo( MergeManifestResources() );
    }

    IfFailGo( MergeCustomAttributes() );
    IfFailGo( MergeDeclSecuritys() );


    // Please don't add any MergeXxx() below here.  CustomAttributess must be
    // very late, because custom values are various other types.

    // Fixup list cannot be merged. Linker will need to re-emit them.

    // Now call back to host for the result of token remap
    // 
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // Send token remap information for each import scope
        pCurTKMap = pImportData->m_pMDTokenMap;
        TOKENREC    *pRec;
        if (pImportData->m_pHostMapToken)
        {
            for (i = 0; i < pCurTKMap->Count(); i++)
            {
                pRec = pCurTKMap->Get(i);
                if (!pRec->IsEmpty())
                    pImportData->m_pHostMapToken->Map(pRec->m_tkFrom, pRec->m_tkTo);
            }
        }
    }

#if _DEBUG
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // dump the mapping
        LOG((LOGMD, "++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"));
        LOG((LOGMD, "Dumping token remap for one import scope!\n"));
        LOG((LOGMD, "This is the %d import scope for merge!\n", pImportData->m_iImport));        

        pCurTKMap = pImportData->m_pMDTokenMap;
        TOKENREC    *pRec;
        for (i = 0; i < pCurTKMap->Count(); i++)
        {
            pRec = pCurTKMap->Get(i);
            if (!pRec->IsEmpty())
                LOG((LOGMD, "   Token 0x%08x  ====>>>> Token 0x%08x\n", pRec->m_tkFrom, pRec->m_tkTo));
        }
        LOG((LOGMD, "End dumping token remap!\n"));
        LOG((LOGMD, "++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n"));
    }
#endif // _DEBUG

ErrExit:
    return hr;
}   // Merge


//*****************************************************************************
// Merge ModuleDef
//*****************************************************************************
HRESULT NEWMERGER::MergeModule()
{
    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;
    HRESULT         hr = NOERROR;
    TOKENREC        *pTokenRec;

    // we don't really merge Module information but we create a one to one mapping for each module token into the TokenMap
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        // set the current MDTokenMap

        pCurTkMap = pImportData->m_pMDTokenMap;
        IfFailGo( pCurTkMap->InsertNotFound(TokenFromRid(1, mdtModule), true, TokenFromRid(1, mdtModule), &pTokenRec) );
    }
ErrExit:
    return hr;
}   // MergeModule


//*****************************************************************************
// Merge TypeDef but only Names. This is a partial merge to support TypeRef to TypeDef optimization
//*****************************************************************************
HRESULT NEWMERGER::MergeTypeDefNamesOnly()
{
    HRESULT         hr = NOERROR;
    TypeDefRec      *pRecImport = NULL;
    TypeDefRec      *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    mdTypeDef       tdEmit;
    mdTypeDef       tdImp;
    bool            bDuplicate;
    DWORD           dwFlags;
    NestedClassRec *pNestedRec;
    RID             iNestedRec;
    mdTypeDef       tdNester;
    TOKENREC        *pTokenRec;

    LPCUTF8         szNameImp;
    LPCUTF8         szNamespaceImp;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;

        iCount = pMiniMdImport->getCountTypeDefs();

        // Merge the typedefs
        for (i = 1; i <= iCount; i++)
        {
            // only merge those TypeDefs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsTypeDefMarked(TokenFromRid(i, mdtTypeDef)) == false)
                continue;

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getTypeDef(i);
            szNameImp = pMiniMdImport->getNameOfTypeDef(pRecImport);
            szNamespaceImp = pMiniMdImport->getNamespaceOfTypeDef(pRecImport);

            // If the class is a Nested class, get the parent token.
            dwFlags = pMiniMdImport->getFlagsOfTypeDef(pRecImport);
            if (IsTdNested(dwFlags))
            {
                iNestedRec = pMiniMdImport->FindNestedClassHelper(TokenFromRid(i, mdtTypeDef));
                if (InvalidRid(iNestedRec))
                {
                    _ASSERTE(!"Bad state!");
                    IfFailGo(META_E_BADMETADATA);
                }
                else
                {
                    pNestedRec = pMiniMdImport->getNestedClass(iNestedRec);
                    tdNester = pMiniMdImport->getEnclosingClassOfNestedClass(pNestedRec);
                    _ASSERTE(!IsNilToken(tdNester));
                    IfFailGo(pCurTkMap->Remap(tdNester, &tdNester));
                }
            }
            else
                tdNester = mdTokenNil;

            // does this TypeDef already exist in the emit scope?
            if ( ImportHelper::FindTypeDefByName(
                pMiniMdEmit,
                szNamespaceImp,
                szNameImp,
                tdNester,
                &tdEmit) == S_OK )
            {
                // Yes, it does
                bDuplicate = true;

            }
            else
            {
                // No, it doesn't. Copy it over.
                bDuplicate = false;
                IfNullGo( pRecEmit = pMiniMdEmit->AddTypeDefRecord((RID *)&tdEmit) );
                tdEmit = TokenFromRid( tdEmit, mdtTypeDef );

                // Set Full Qualified Name.
                IfFailGo( CopyTypeDefPartially( pRecEmit, pMiniMdImport, pRecImport) );

                // Create a NestedClass record if the class is a Nested class.
                if (! IsNilToken(tdNester))
                {
                    IfNullGo( pNestedRec = pMiniMdEmit->AddNestedClassRecord(&iNestedRec) );

                    // copy over the information
                    IfFailGo( pMiniMdEmit->PutToken(TBL_NestedClass, NestedClassRec::COL_NestedClass,
                                                    pNestedRec, tdEmit));

                    // tdNester has already been remapped above to the Emit scope.
                    IfFailGo( pMiniMdEmit->PutToken(TBL_NestedClass, NestedClassRec::COL_EnclosingClass,
                                                    pNestedRec, tdNester));
                    IfFailGo( pMiniMdEmit->AddNestedClassToHash(iNestedRec) );

                }
            }

            // record the token movement
            tdImp = TokenFromRid(i, mdtTypeDef);
            IfFailGo( pCurTkMap->InsertNotFound(tdImp, bDuplicate, tdEmit, &pTokenRec) );
        }
    }

ErrExit:
    return hr;
}   // MergeTypeDefNamesOnly


//*****************************************************************************
// Merge EnclosingType tables
//*****************************************************************************
HRESULT NEWMERGER::CopyTypeDefPartially( 
    TypeDefRec  *pRecEmit,                  // [IN] the emit record to fill
    CMiniMdRW   *pMiniMdImport,             // [IN] the importing scope
    TypeDefRec  *pRecImp)                   // [IN] the record to import

{
    HRESULT     hr;
    LPCUTF8     szNameImp;
    LPCUTF8     szNamespaceImp;
    CMiniMdRW   *pMiniMdEmit = GetMiniMdEmit();

    szNameImp = pMiniMdImport->getNameOfTypeDef(pRecImp);
    szNamespaceImp = pMiniMdImport->getNamespaceOfTypeDef(pRecImp);

    IfFailGo( pMiniMdEmit->PutString( TBL_TypeDef, TypeDefRec::COL_Name, pRecEmit, szNameImp) );
    IfFailGo( pMiniMdEmit->PutString( TBL_TypeDef, TypeDefRec::COL_Namespace, pRecEmit, szNamespaceImp) );

    pRecEmit->m_Flags = pRecImp->m_Flags;

    // Don't copy over the extends until TypeRef's remap is calculated

ErrExit:
    return hr;

}   // CopyTypeDefPartially


//*****************************************************************************
// Merge ModuleRef tables including ModuleRef to ModuleDef optimization
//*****************************************************************************
HRESULT NEWMERGER::MergeModuleRefs()
{
    HRESULT         hr = NOERROR;
    ModuleRefRec    *pRecImport = NULL;
    ModuleRefRec    *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    mdModuleRef     mrEmit;
    bool            bDuplicate;
    TOKENREC        *pTokenRec;
    LPCUTF8         szNameImp;
    bool            isModuleDef;

    MergeImportData *pImportData;
    MergeImportData *pData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountModuleRefs();

        // loop through all ModuleRef
        for (i = 1; i <= iCount; i++)
        {
            // only merge those ModuleRefs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsModuleRefMarked(TokenFromRid(i, mdtModuleRef)) == false)
                continue;

            isModuleDef = false;

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getModuleRef(i);
            szNameImp = pMiniMdImport->getNameOfModuleRef(pRecImport);

            // Only do the ModuleRef to ModuleDef optimization if ModuleRef's name is meaningful!
            if ( szNameImp && szNameImp[0] != '\0')
            {

                // Check to see if this ModuleRef has become the ModuleDef token
                for (pData = m_pImportDataList; pData != NULL; pData = pData->m_pNextImportData)
                {
                    CMiniMdRW       *pMiniMd = &(pData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
                    ModuleRec       *pRec;
                    LPCUTF8         szName;

                    pRec = pMiniMd->getModule(MODULEDEFTOKEN);
                    szName = pMiniMd->getNameOfModule(pRec);
                    if (szName && szName[0] != '\0' && strcmp(szNameImp, szName) == 0)
                    {
                        // We found an import Module for merging that has the same name as the ModuleRef
                        isModuleDef = true;
                        bDuplicate = true;
                        mrEmit = MODULEDEFTOKEN;       // set the resulting token to ModuleDef Token
                        break;
                    }
                }
            }

            if (isModuleDef == false)
            {
                // does this ModuleRef already exist in the emit scope?
                hr = ImportHelper::FindModuleRef(pMiniMdEmit,
                                                szNameImp,
                                                &mrEmit);
                if (hr == S_OK)
                {
                    // Yes, it does
                    bDuplicate = true;
                }
                else if (hr == CLDB_E_RECORD_NOTFOUND)
                {
                    // No, it doesn't. Copy it over.
                    bDuplicate = false;
                    IfNullGo( pRecEmit = pMiniMdEmit->AddModuleRefRecord((RID*)&mrEmit) );
                    mrEmit = TokenFromRid(mrEmit, mdtModuleRef);

                    // Set ModuleRef Name.
                    IfFailGo( pMiniMdEmit->PutString(TBL_ModuleRef, ModuleRefRec::COL_Name, pRecEmit, szNameImp) );
                }
                else
                    IfFailGo(hr);
            }

            // record the token movement
            IfFailGo( pCurTkMap->InsertNotFound(
                TokenFromRid(i, mdtModuleRef), 
                bDuplicate,
                mrEmit,
                &pTokenRec) );
        }
    }

ErrExit:
    return hr;
}   // MergeModuleRefs


//*****************************************************************************
// Merge AssemblyRef tables
//*****************************************************************************
HRESULT NEWMERGER::MergeAssemblyRefs()
{
    HRESULT         hr = NOERROR;
    AssemblyRefRec  *pRecImport = NULL;
    AssemblyRefRec  *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    mdAssemblyRef   arEmit;
    bool            bDuplicate;
    LPCUTF8         szTmp;
    const void      *pbTmp;
    ULONG           cbTmp;
    ULONG           iCount;
    ULONG           i;
    ULONG           iRecord;
    TOKENREC        *pTokenRec;
    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountAssemblyRefs();

        // loope through all the AssemblyRefs.
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            // Compare with the emit scope.
            pRecImport = pMiniMdImport->getAssemblyRef(i);
            pbTmp = pMiniMdImport->getPublicKeyOrTokenOfAssemblyRef(pRecImport, &cbTmp);
            hr = CLDB_E_RECORD_NOTFOUND;
            if (m_fDupCheck)
                hr = ImportHelper::FindAssemblyRef(pMiniMdEmit,
                                               pMiniMdImport->getNameOfAssemblyRef(pRecImport),
                                               pMiniMdImport->getLocaleOfAssemblyRef(pRecImport),
                                               pbTmp, 
                                               cbTmp,
                                               pRecImport->m_MajorVersion,
                                               pRecImport->m_MinorVersion,
                                               pRecImport->m_BuildNumber,
                                               pRecImport->m_RevisionNumber,
                                               pRecImport->m_Flags,
                                               &arEmit);
            if (hr == S_OK)
            {
                // Yes, it does
                bDuplicate = true;

                // @FUTURE: more verification?
            }
            else if (hr == CLDB_E_RECORD_NOTFOUND)
            {
                // No, it doesn't.  Copy it over.
                bDuplicate = false;
                IfNullGo( pRecEmit = pMiniMdEmit->AddAssemblyRefRecord(&iRecord));
                arEmit = TokenFromRid(iRecord, mdtAssemblyRef);

                pRecEmit->m_MajorVersion = pRecImport->m_MajorVersion;
                pRecEmit->m_MinorVersion = pRecImport->m_MinorVersion;
                pRecEmit->m_BuildNumber = pRecImport->m_BuildNumber;
                pRecEmit->m_RevisionNumber = pRecImport->m_RevisionNumber;
                pRecEmit->m_Flags = pRecImport->m_Flags;

                pbTmp = pMiniMdImport->getPublicKeyOrTokenOfAssemblyRef(pRecImport, &cbTmp);
                IfFailGo(pMiniMdEmit->PutBlob(TBL_AssemblyRef, AssemblyRefRec::COL_PublicKeyOrToken,
                                            pRecEmit, pbTmp, cbTmp));

                szTmp = pMiniMdImport->getNameOfAssemblyRef(pRecImport);
                IfFailGo(pMiniMdEmit->PutString(TBL_AssemblyRef, AssemblyRefRec::COL_Name,
                                            pRecEmit, szTmp));

                szTmp = pMiniMdImport->getLocaleOfAssemblyRef(pRecImport);
                IfFailGo(pMiniMdEmit->PutString(TBL_AssemblyRef, AssemblyRefRec::COL_Locale,
                                            pRecEmit, szTmp));

                pbTmp = pMiniMdImport->getHashValueOfAssemblyRef(pRecImport, &cbTmp);
                IfFailGo(pMiniMdEmit->PutBlob(TBL_AssemblyRef, AssemblyRefRec::COL_HashValue,
                                            pRecEmit, pbTmp, cbTmp));

            }
            else
                IfFailGo(hr);

            // record the token movement.
            IfFailGo(pCurTkMap->InsertNotFound(
                TokenFromRid(i, mdtAssemblyRef),
                bDuplicate,
                arEmit,
                &pTokenRec));
        }
    }

ErrExit:
    return hr;
}   // MergeAssemblyRefs


//*****************************************************************************
// Merge TypeRef tables also performing TypeRef to TypeDef opitimization. ie.
// we will not introduce a TypeRef record if we can optimize it to a TypeDef.
//*****************************************************************************
HRESULT NEWMERGER::MergeTypeRefs()
{
    HRESULT     hr = NOERROR;
    TypeRefRec  *pRecImport = NULL;
    TypeRefRec  *pRecEmit = NULL;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    ULONG       iCount;
    ULONG       i;
    mdTypeRef   trEmit;
    bool        bDuplicate;
    TOKENREC    *pTokenRec;
    bool        isTypeDef;

    mdToken     tkResImp;
    mdToken     tkResEmit;
    LPCUTF8     szNameImp;
    LPCUTF8     szNamespaceImp;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountTypeRefs();

        // loop through all TypeRef
        for (i = 1; i <= iCount; i++)
        {
            // only merge those TypeRefs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsTypeRefMarked(TokenFromRid(i, mdtTypeRef)) == false)
                continue;

            isTypeDef = false;

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getTypeRef(i);
            tkResImp = pMiniMdImport->getResolutionScopeOfTypeRef(pRecImport);
            szNamespaceImp = pMiniMdImport->getNamespaceOfTypeRef(pRecImport);
            szNameImp = pMiniMdImport->getNameOfTypeRef(pRecImport);
            if (!IsNilToken(tkResImp))
            {
                IfFailGo(pCurTkMap->Remap(tkResImp, &tkResEmit));
            }
            else
            {
                tkResEmit = tkResImp;
            }

            // NEW! NEW!
            // If a TypeRef is parent to a NULL token or parent to the current ModuleDef, we are going to
            // try to resolve the TypeRef to a TypeDef. We will also do the optimization if tkResEmit is resolved
            // to a TypeDef. This will happen when the TypeRef is referring to a nested type while parent type
            // resolved to a TypeDef already.
            if (IsNilToken(tkResEmit) || tkResEmit == MODULEDEFTOKEN || TypeFromToken(tkResEmit) == mdtTypeDef)
            {
                hr = ImportHelper::FindTypeDefByName(
                    pMiniMdEmit,
                    szNamespaceImp,
                    szNameImp,
                    (TypeFromToken(tkResEmit) == mdtTypeDef) ? tkResEmit : mdTokenNil,
                    &trEmit);
                if (hr == S_OK)
                {
                    isTypeDef = true;

                    // it really does not matter if we set the duplicate to true or false. 
                    bDuplicate = true;
                }
            }

            // If this TypeRef cannot be optmized to a TypeDef or the Ref to Def optimization is turned off, do the following.
            if (isTypeDef == false || !((m_optimizeRefToDef & MDTypeRefToDef) == MDTypeRefToDef))
            {
                // does this TypeRef already exist in the emit scope?
                if ( m_fDupCheck && ImportHelper::FindTypeRefByName(
                    pMiniMdEmit,
                    tkResEmit,
                    szNamespaceImp,
                    szNameImp,
                    &trEmit) == S_OK )
                {
                    // Yes, it does
                    bDuplicate = true;
                }
                else
                {
                    // No, it doesn't. Copy it over.
                    bDuplicate = false;
                    IfNullGo( pRecEmit = pMiniMdEmit->AddTypeRefRecord((RID*)&trEmit) );
                    trEmit = TokenFromRid(trEmit, mdtTypeRef);

                    // Set ResolutionScope.  tkResEmit has already been re-mapped.
                    IfFailGo(pMiniMdEmit->PutToken(TBL_TypeRef, TypeRefRec::COL_ResolutionScope,
                                                    pRecEmit, tkResEmit));

                    // Set Name.
                    IfFailGo(pMiniMdEmit->PutString(TBL_TypeRef, TypeRefRec::COL_Name,
                                                    pRecEmit, szNameImp));
                    IfFailGo(pMiniMdEmit->AddNamedItemToHash(TBL_TypeRef, trEmit, szNameImp, 0));
            
                    // Set Namespace.
                    IfFailGo(pMiniMdEmit->PutString(TBL_TypeRef, TypeRefRec::COL_Namespace,
                                                    pRecEmit, szNamespaceImp));
                }
            }

            // record the token movement
            IfFailGo( pCurTkMap->InsertNotFound(
                TokenFromRid(i, mdtTypeRef), 
                bDuplicate,
                trEmit,
                &pTokenRec) );
        }
    }

ErrExit:
    return hr;
}   // MergeTypeRefs
 

//*****************************************************************************
// copy over the remaining information of partially merged TypeDef records. Right now only
// extends field is delayed to here. The reason that we delay extends field is because we want
// to optimize TypeRef to TypeDef if possible.
//*****************************************************************************
HRESULT NEWMERGER::CompleteMergeTypeDefs()
{
    HRESULT         hr = NOERROR;
    TypeDefRec      *pRecImport = NULL;
    TypeDefRec      *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    TOKENREC        *pTokenRec;
    mdToken         tkExtendsImp;
    mdToken         tkExtendsEmit;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;

        iCount = pMiniMdImport->getCountTypeDefs();

        // Merge the typedefs
        for (i = 1; i <= iCount; i++)
        {
            // only merge those TypeDefs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsTypeDefMarked(TokenFromRid(i, mdtTypeDef)) == false)
                continue;

            if ( !pCurTkMap->Find(TokenFromRid(i, mdtTypeDef), &pTokenRec) )
            {
                _ASSERTE( !"bad state!");
                IfFailGo( META_E_BADMETADATA );
            }

            if (pTokenRec->m_isDuplicate == false)
            {
                // get the extends token from the import
                pRecImport = pMiniMdImport->getTypeDef(i);
                tkExtendsImp = pMiniMdImport->getExtendsOfTypeDef(pRecImport);

                // map the extends token to an merged token
                IfFailGo( pCurTkMap->Remap(tkExtendsImp, &tkExtendsEmit) );

                // set the extends to the merged TypeDef records.
                pRecEmit = pMiniMdEmit->getTypeDef( RidFromToken(pTokenRec->m_tkTo) );
                IfFailGo(pMiniMdEmit->PutToken(TBL_TypeDef, TypeDefRec::COL_Extends, pRecEmit, tkExtendsEmit));                
            }
            else
            {
                // @FUTURE: we can check to make sure the import extends maps to the one that is set to the emit scope.
                // Otherwise, it is a error to report to linker.
            }
        }
    }
ErrExit:
    return hr;
}   // CompleteMergeTypeDefs


//*****************************************************************************
// merging TypeSpecs
//*****************************************************************************
HRESULT NEWMERGER::MergeTypeSpecs()
{
    HRESULT         hr = NOERROR;
    TypeSpecRec     *pRecImport = NULL;
    TypeSpecRec     *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    TOKENREC        *pTokenRec;
    mdTypeSpec      tsImp;
    mdTypeSpec      tsEmit;
    bool            fDuplicate;
    PCCOR_SIGNATURE pbSig;
    ULONG           cbSig;
    ULONG           cbEmit;
    CQuickBytes     qbSig;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;

        iCount = pMiniMdImport->getCountTypeSpecs();

        // loop through all TypeSpec
        for (i = 1; i <= iCount; i++)
        {
            // only merge those TypeSpecs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsTypeSpecMarked(TokenFromRid(i, mdtTypeSpec)) == false)
                continue;

            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getTypeSpec(i);
            pbSig = pMiniMdImport->getSignatureOfTypeSpec(pRecImport, &cbSig);

            // convert tokens contained in signature to new scope
            IfFailGo(ImportHelper::MergeUpdateTokenInFieldSig(
                NULL,                       // Assembly emit scope.
                pMiniMdEmit,                // The emit scope.
                NULL, NULL, 0,              // Import assembly information.
                pMiniMdImport,              // The scope to merge into the emit scope.
                pbSig,                      // signature from the imported scope
                pCurTkMap,                  // Internal token mapping structure.
                &qbSig,                     // [OUT] translated signature
                0,                          // start from first byte of the signature
                0,                          // don't care how many bytes consumed
                &cbEmit));                  // number of bytes write to cbEmit

            hr = CLDB_E_RECORD_NOTFOUND;
            if (m_fDupCheck)
                hr = ImportHelper::FindTypeSpec(
                    pMiniMdEmit,
                    (PCOR_SIGNATURE) qbSig.Ptr(),
                    cbEmit,
                    &tsEmit );

            if ( hr == S_OK )
            {
                // find a duplicate
                fDuplicate = true;
            }
            else
            {
                // copy over
                fDuplicate = false;
                IfNullGo( pRecEmit = pMiniMdEmit->AddTypeSpecRecord((ULONG *)&tsEmit) );
                tsEmit = TokenFromRid(tsEmit, mdtTypeSpec);
                IfFailGo( pMiniMdEmit->PutBlob(
                    TBL_TypeSpec, 
                    TypeSpecRec::COL_Signature, 
                    pRecEmit, 
                    (PCOR_SIGNATURE)qbSig.Ptr(), 
                    cbEmit));
            }
            tsImp = TokenFromRid(i, mdtTypeSpec);

            // Record the token movement
            IfFailGo( pCurTkMap->InsertNotFound(tsImp, fDuplicate, tsEmit, &pTokenRec) );
        }
    }
ErrExit:
    return hr;
}   // MergeTypeSpecs


//*****************************************************************************
// merging Children of TypeDefs. This includes field, method, parameter, property, event
//*****************************************************************************
HRESULT NEWMERGER::MergeTypeDefChildren() 
{
    HRESULT         hr = NOERROR;
    TypeDefRec      *pRecImport = NULL;
    TypeDefRec      *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    mdTypeDef       tdEmit;
    mdTypeDef       tdImp;
    TOKENREC        *pTokenRec;

#if _DEBUG
    LPCUTF8         szNameImp;
    LPCUTF8         szNamespaceImp;
#endif // _DEBUG

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountTypeDefs();

        // loop through all TypeDef again to merge/copy Methods, fields, events, and properties
        // 
        for (i = 1; i <= iCount; i++)
        {
            // only merge those TypeDefs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsTypeDefMarked(TokenFromRid(i, mdtTypeDef)) == false)
                continue;

#if _DEBUG
            pRecImport = pMiniMdImport->getTypeDef(i);
            szNameImp = pMiniMdImport->getNameOfTypeDef(pRecImport);
            szNamespaceImp = pMiniMdImport->getNamespaceOfTypeDef(pRecImport);
#endif // _DEBUG

            // check to see if the typedef is duplicate or not
            tdImp = TokenFromRid(i, mdtTypeDef);
            if ( pCurTkMap->Find( tdImp, &pTokenRec) == false)
            {
                _ASSERTE( !"bad state!");
                IfFailGo( META_E_BADMETADATA );
            }
            tdEmit = pTokenRec->m_tkTo;
            if (pTokenRec->m_isDuplicate == false)
            {
                // now move all of the children records over
                IfFailGo( CopyMethods(pImportData, tdImp, tdEmit) );
                IfFailGo( CopyFields(pImportData, tdImp, tdEmit) );

                IfFailGo( CopyEvents(pImportData, tdImp, tdEmit) );

                //  Property has dependency on events
                IfFailGo( CopyProperties(pImportData, tdImp, tdEmit) );
            }
            else
            {
                // verify the children records
                IfFailGo( VerifyMethods(pImportData, tdImp, tdEmit) );
                IfFailGo( VerifyFields(pImportData, tdImp, tdEmit) );
                IfFailGo( VerifyEvents(pImportData, tdImp, tdEmit) );

                // property has dependency on events
                IfFailGo( VerifyProperties(pImportData, tdImp, tdEmit) );
            }
        }
    }
ErrExit:
    return hr;
}   // MergeTypeDefChildren


//*****************************************************************************
// Verify Methods
//*****************************************************************************
HRESULT NEWMERGER::VerifyMethods(
    MergeImportData *pImportData, 
    mdTypeDef       tdImport, 
    mdTypeDef       tdEmit)
{
    HRESULT     hr = NOERROR;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    MethodRec   *pRecImp;
    MethodRec   *pRecEmit;
    ULONG       ridStart;
    ULONG       ridEnd;
    ULONG       i;
    
    TypeDefRec  *pTypeDefRec;
    LPCUTF8     szName;
    PCCOR_SIGNATURE pbSig;
    ULONG       cbSig;
    ULONG       cbEmit;
    CQuickBytes qbSig;
    TOKENREC    *pTokenRec;
    mdMethodDef mdImp;
    mdMethodDef mdEmit;
    MDTOKENMAP  *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    pCurTkMap = pImportData->m_pMDTokenMap;

    pTypeDefRec = pMiniMdImport->getTypeDef(RidFromToken(tdImport));
    ridStart = pMiniMdImport->getMethodListOfTypeDef(pTypeDefRec);
    ridEnd = pMiniMdImport->getEndMethodListOfTypeDef(pTypeDefRec);

    // loop through all Methods of the TypeDef
    for (i = ridStart; i < ridEnd; i++)
    {
        mdImp = pMiniMdImport->GetMethodRid(i);

        // only verify those Methods that are marked
        if ( pMiniMdImport->GetFilterTable()->IsMethodMarked(TokenFromRid(mdImp, mdtMethodDef)) == false)
            continue;
            
        pRecImp = pMiniMdImport->getMethod(mdImp);

        if (m_fDupCheck == FALSE && tdImport == TokenFromRid(1, mdtTypeDef))
        {
            // No dup check. This is the scenario that we only have one import scope. Just copy over the
            // globals.
            goto CopyMethodLabel;
        }
          
        szName = pMiniMdImport->getNameOfMethod(pRecImp);
        pbSig = pMiniMdImport->getSignatureOfMethod(pRecImp, &cbSig);

        mdImp = TokenFromRid(mdImp, mdtMethodDef);

        if ( IsMdPrivateScope( pRecImp->m_Flags ) )
        {
            // Trigger additive merge
            goto CopyMethodLabel;
        }

        // convert rid contained in signature to new scope
        IfFailGo(ImportHelper::MergeUpdateTokenInSig(    
            NULL,                       // Assembly emit scope.
            pMiniMdEmit,                // The emit scope.
            NULL, NULL, 0,              // Import assembly scope information.
            pMiniMdImport,              // The scope to merge into the emit scope.
            pbSig,                      // signature from the imported scope
            pCurTkMap,                // Internal token mapping structure.
            &qbSig,                     // [OUT] translated signature
            0,                          // start from first byte of the signature
            0,                          // don't care how many bytes consumed
            &cbEmit));                  // number of bytes write to cbEmit

        hr = ImportHelper::FindMethod(
            pMiniMdEmit,
            tdEmit,
            szName,
            (const COR_SIGNATURE *)qbSig.Ptr(),
            cbEmit,
            &mdEmit );

        if (tdImport == TokenFromRid(1, mdtTypeDef))
        {
            // global functions! Make sure that we move over the non-duplicate global function
            // declaration
            //
            if (hr == S_OK)
            {
                // found the duplicate
                IfFailGo( VerifyMethod(pImportData, mdImp, mdEmit) );
            }
            else
            {
CopyMethodLabel:
                // not a duplicate! Copy over the 
                IfNullGo( pRecEmit = pMiniMdEmit->AddMethodRecord((RID *)&mdEmit) );

                // copy the method content over
                IfFailGo( CopyMethod(pImportData, pRecImp, pRecEmit) );

                IfFailGo( pMiniMdEmit->AddMethodToTypeDef(RidFromToken(tdEmit), mdEmit));

                // record the token movement
                mdEmit = TokenFromRid(mdEmit, mdtMethodDef);
                IfFailGo( pMiniMdEmit->AddMemberDefToHash(
                    mdEmit, 
                    tdEmit) ); 

                mdImp = TokenFromRid(mdImp, mdtMethodDef);
                IfFailGo( pCurTkMap->InsertNotFound(mdImp, false, mdEmit, &pTokenRec) );

                // copy over the children
                IfFailGo( CopyParams(pImportData, mdImp, mdEmit) );

            }
        }
        else
        {
            if (hr == S_OK)
            {
                // Good! We are supposed to find a duplicate
                IfFailGo( VerifyMethod(pImportData, mdImp, mdEmit) );
            }
            else
            {
                // Oops! The typedef is duplicated but the method is not!!
                CheckContinuableErrorEx(META_E_METHD_NOT_FOUND, pImportData, mdImp);
            }
                
        }
    }
ErrExit:
    return hr;
}   // VerifyMethods


//*****************************************************************************
// verify a duplicated method
//*****************************************************************************
HRESULT NEWMERGER::VerifyMethod(
    MergeImportData *pImportData, 
    mdMethodDef mdImp,                      // [IN] the emit record to fill
    mdMethodDef mdEmit)                     // [IN] the record to import
{
    HRESULT     hr;
    MethodRec   *pRecImp;
    MethodRec   *pRecEmit;
    TOKENREC    *pTokenRec;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    MDTOKENMAP  *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    pCurTkMap = pImportData->m_pMDTokenMap;

    IfFailGo( pCurTkMap->InsertNotFound(mdImp, true, mdEmit, &pTokenRec) );
    
    pRecImp = pMiniMdImport->getMethod(RidFromToken(mdImp));

    // We need to make sure that the impl flags are propagated .
    // Rules are: if the first method has miForwardRef flag set but the new method does not,
    // we want to disable the miForwardRef flag. If the one found in the emit scope does not have
    // miForwardRef set and the second one doesn't either, we want to make sure that the rest of
    // impl flags are the same.
    //
    if ( !IsMiForwardRef( pRecImp->m_ImplFlags ) )
    {
        pRecEmit = pMiniMdEmit->getMethod(RidFromToken(mdEmit));
        if (!IsMiForwardRef(pRecEmit->m_ImplFlags))
        {
            // make sure the rest of ImplFlags are the same
            if (pRecEmit->m_ImplFlags != pRecImp->m_ImplFlags)
            {
                // inconsistent in implflags
                CheckContinuableErrorEx(META_E_METHDIMPL_INCONSISTENT, pImportData, mdImp);
            }
        }
        else
        {
            // propagate the importing ImplFlags
            pRecEmit->m_ImplFlags = pRecImp->m_ImplFlags;
        }
    }

    // verify the children
    IfFailGo( VerifyParams(pImportData, mdImp, mdEmit) );
ErrExit:
    return hr;
}   // NEWMERGER::VerifyMethod


//*****************************************************************************
// Verify Fields
//*****************************************************************************
HRESULT NEWMERGER::VerifyFields(
    MergeImportData *pImportData, 
    mdTypeDef       tdImport, 
    mdTypeDef       tdEmit)
{
    HRESULT     hr = NOERROR;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    FieldRec    *pRecImp;
    FieldRec    *pRecEmit;
    mdFieldDef  fdImp;
    mdFieldDef  fdEmit;
    ULONG       ridStart;
    ULONG       ridEnd;
    ULONG       i;

    TypeDefRec  *pTypeDefRec;
    LPCUTF8     szName;
    PCCOR_SIGNATURE pbSig;
    ULONG       cbSig;
    ULONG       cbEmit;
    CQuickBytes qbSig;
    TOKENREC    *pTokenRec;
    MDTOKENMAP  *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    pCurTkMap = pImportData->m_pMDTokenMap;

    pTypeDefRec = pMiniMdImport->getTypeDef(RidFromToken(tdImport));
    ridStart = pMiniMdImport->getFieldListOfTypeDef(pTypeDefRec);
    ridEnd = pMiniMdImport->getEndFieldListOfTypeDef(pTypeDefRec);

    // loop through all fields of the TypeDef
    for (i = ridStart; i < ridEnd; i++)
    {
        fdImp = pMiniMdImport->GetFieldRid(i);

        // only verify those fields that are marked
        if ( pMiniMdImport->GetFilterTable()->IsFieldMarked(TokenFromRid(fdImp, mdtFieldDef)) == false)
            continue;

        pRecImp = pMiniMdImport->getField(fdImp);

        if (m_fDupCheck == FALSE && tdImport == TokenFromRid(1, mdtTypeDef))
        {
            // No dup check. This is the scenario that we only have one import scope. Just copy over the
            // globals.
            goto CopyFieldLabel;
        }

        szName = pMiniMdImport->getNameOfField(pRecImp);
        pbSig = pMiniMdImport->getSignatureOfField(pRecImp, &cbSig);

        if ( IsFdPrivateScope(pRecImp->m_Flags))
        {
            // Trigger additive merge
            fdImp = TokenFromRid(fdImp, mdtFieldDef);
            goto CopyFieldLabel;
        }

        // convert rid contained in signature to new scope
        IfFailGo(ImportHelper::MergeUpdateTokenInSig(    
            NULL,                       // Assembly emit scope.
            pMiniMdEmit,                // The emit scope.
            NULL, NULL, 0,              // Import assembly scope information.
            pMiniMdImport,              // The scope to merge into the emit scope.
            pbSig,                      // signature from the imported scope
            pCurTkMap,                // Internal token mapping structure.
            &qbSig,                     // [OUT] translated signature
            0,                          // start from first byte of the signature
            0,                          // don't care how many bytes consumed
            &cbEmit));                  // number of bytes write to cbEmit

        hr = ImportHelper::FindField(
            pMiniMdEmit,
            tdEmit,
            szName,
            (const COR_SIGNATURE *)qbSig.Ptr(),
            cbEmit,
            &fdEmit );

        fdImp = TokenFromRid(fdImp, mdtFieldDef);

        if (tdImport == TokenFromRid(1, mdtTypeDef))
        {
            // global datas! Make sure that we move over the non-duplicate global function
            // declaration
            //
            if (hr == S_OK)
            {
                // found the duplicate
                IfFailGo( pCurTkMap->InsertNotFound(fdImp, true, fdEmit, &pTokenRec) );
            }
            else
            {
CopyFieldLabel:
                // not a duplicate! Copy over the 
                IfNullGo( pRecEmit = pMiniMdEmit->AddFieldRecord((RID *)&fdEmit) );

                // copy the field record over 
                IfFailGo( CopyField(pImportData, pRecImp, pRecEmit) );

                IfFailGo( pMiniMdEmit->AddFieldToTypeDef(RidFromToken(tdEmit), fdEmit));

                // record the token movement
                fdEmit = TokenFromRid(fdEmit, mdtFieldDef);
                IfFailGo( pMiniMdEmit->AddMemberDefToHash(
                    fdEmit, 
                    tdEmit) ); 

                fdImp = TokenFromRid(fdImp, mdtFieldDef);
                IfFailGo( pCurTkMap->InsertNotFound(fdImp, false, fdEmit, &pTokenRec) );
            }
        }
        else
        {
            if (hr == S_OK)
            {
                // Good! We are supposed to find a duplicate
                IfFailGo( pCurTkMap->InsertNotFound(fdImp, true, fdEmit, &pTokenRec) );
            }
            else
            {
                // Oops! The typedef is duplicated but the field is not!!
                CheckContinuableErrorEx(META_E_FIELD_NOT_FOUND, pImportData, fdImp);
            }
                
        }
    }
ErrExit:
    return hr;
}   // VerifyFields


//*******************************************************************************
// Helper to copy an Method record
//*******************************************************************************
HRESULT NEWMERGER::CopyMethod(
    MergeImportData *pImportData,           // [IN] import scope
    MethodRec   *pRecImp,                   // [IN] the record to import
    MethodRec   *pRecEmit)                  // [IN] the emit record to fill
{
    HRESULT     hr;
    CMiniMdRW   *pMiniMdImp = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    CMiniMdRW   *pMiniMdEmit = GetMiniMdEmit();
    LPCUTF8     szName;
    PCCOR_SIGNATURE pbSig;
    ULONG       cbSig;
    ULONG       cbEmit;
    CQuickBytes qbSig;
    MDTOKENMAP  *pCurTkMap;

    pCurTkMap = pImportData->m_pMDTokenMap;

    // copy over the fix part of the record
    pRecEmit->m_RVA = pRecImp->m_RVA;
    pRecEmit->m_ImplFlags = pRecImp->m_ImplFlags;
    pRecEmit->m_Flags = pRecImp->m_Flags;

    // copy over the name
    szName = pMiniMdImp->getNameOfMethod(pRecImp);
    IfFailGo(pMiniMdEmit->PutString(TBL_Method, MethodRec::COL_Name, pRecEmit, szName));

    // copy over the signature
    pbSig = pMiniMdImp->getSignatureOfMethod(pRecImp, &cbSig);

    // convert rid contained in signature to new scope
    IfFailGo(ImportHelper::MergeUpdateTokenInSig(    
        NULL,                       // Assembly emit scope.
        pMiniMdEmit,                // The emit scope.
        NULL, NULL, 0,              // Import assembly scope information.
        pMiniMdImp,                 // The scope to merge into the emit scope.
        pbSig,                      // signature from the imported scope
        pCurTkMap,                // Internal token mapping structure.
        &qbSig,                     // [OUT] translated signature
        0,                          // start from first byte of the signature
        0,                          // don't care how many bytes consumed
        &cbEmit));                  // number of bytes write to cbEmit

    IfFailGo(pMiniMdEmit->PutBlob(TBL_Method, MethodRec::COL_Signature, pRecEmit, qbSig.Ptr(), cbEmit));

ErrExit:
    return hr;
}   // CopyMethod


//*******************************************************************************
// Helper to copy an field record
//*******************************************************************************
HRESULT NEWMERGER::CopyField(
    MergeImportData *pImportData,           // [IN] import scope
    FieldRec    *pRecImp,                   // [IN] the record to import
    FieldRec    *pRecEmit)                  // [IN] the emit record to fill
{
    HRESULT     hr;
    CMiniMdRW   *pMiniMdImp = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    CMiniMdRW   *pMiniMdEmit = GetMiniMdEmit();
    LPCUTF8     szName;
    PCCOR_SIGNATURE pbSig;
    ULONG       cbSig;
    ULONG       cbEmit;
    CQuickBytes qbSig;
    MDTOKENMAP  *pCurTkMap;

    pCurTkMap = pImportData->m_pMDTokenMap;

    // copy over the fix part of the record
    pRecEmit->m_Flags = pRecImp->m_Flags;

    // copy over the name
    szName = pMiniMdImp->getNameOfField(pRecImp);
    IfFailGo(pMiniMdEmit->PutString(TBL_Field, FieldRec::COL_Name, pRecEmit, szName));

    // copy over the signature
    pbSig = pMiniMdImp->getSignatureOfField(pRecImp, &cbSig);

    // convert rid contained in signature to new scope
    IfFailGo(ImportHelper::MergeUpdateTokenInSig(    
        NULL,                       // Emit assembly scope.
        pMiniMdEmit,                // The emit scope.
        NULL, NULL, 0,              // Import assembly scope information.
        pMiniMdImp,                 // The scope to merge into the emit scope.
        pbSig,                      // signature from the imported scope
        pCurTkMap,                  // Internal token mapping structure.
        &qbSig,                     // [OUT] translated signature
        0,                          // start from first byte of the signature
        0,                          // don't care how many bytes consumed
        &cbEmit));                  // number of bytes write to cbEmit

    IfFailGo(pMiniMdEmit->PutBlob(TBL_Field, FieldRec::COL_Signature, pRecEmit, qbSig.Ptr(), cbEmit));

ErrExit:
    return hr;
}   // CopyField

//*******************************************************************************
// Helper to copy an field record
//*******************************************************************************
HRESULT NEWMERGER::CopyParam(
    MergeImportData *pImportData,           // [IN] import scope
    ParamRec    *pRecImp,                   // [IN] the record to import
    ParamRec    *pRecEmit)                  // [IN] the emit record to fill
{
    HRESULT     hr;
    CMiniMdRW   *pMiniMdImp = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    CMiniMdRW   *pMiniMdEmit = GetMiniMdEmit();
    LPCUTF8     szName;
    MDTOKENMAP  *pCurTkMap;

    pCurTkMap = pImportData->m_pMDTokenMap;

    // copy over the fix part of the record
    pRecEmit->m_Flags = pRecImp->m_Flags;
    pRecEmit->m_Sequence = pRecImp->m_Sequence;

    // copy over the name
    szName = pMiniMdImp->getNameOfParam(pRecImp);
    IfFailGo(pMiniMdEmit->PutString(TBL_Param, ParamRec::COL_Name, pRecEmit, szName));

ErrExit:
    return hr;
}

//*******************************************************************************
// Helper to copy an Event record
//*******************************************************************************
HRESULT NEWMERGER::CopyEvent(
    MergeImportData *pImportData,           // [IN] import scope
    EventRec    *pRecImp,                   // [IN] the record to import
    EventRec    *pRecEmit)                  // [IN] the emit record to fill
{
    HRESULT     hr = NOERROR;
    CMiniMdRW   *pMiniMdImp = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    CMiniMdRW   *pMiniMdEmit = GetMiniMdEmit();
    mdToken     tkEventTypeImp;
    mdToken     tkEventTypeEmit;            // could be TypeDef or TypeRef
    LPCUTF8     szName;
    MDTOKENMAP  *pCurTkMap;

    pCurTkMap = pImportData->m_pMDTokenMap;

    pRecEmit->m_EventFlags = pRecImp->m_EventFlags;

    //move over the event name
    szName = pMiniMdImp->getNameOfEvent( pRecImp );
    IfFailGo( pMiniMdEmit->PutString(TBL_Event, EventRec::COL_Name, pRecEmit, szName) );

    // move over the EventType
    tkEventTypeImp = pMiniMdImp->getEventTypeOfEvent(pRecImp);
    if ( !IsNilToken(tkEventTypeImp) )
    {
        IfFailGo( pCurTkMap->Remap(tkEventTypeImp, &tkEventTypeEmit) );
        IfFailGo(pMiniMdEmit->PutToken(TBL_Event, EventRec::COL_EventType, pRecEmit, tkEventTypeEmit));
    }

ErrExit:
    return hr;
}   // CopyEvent


//*******************************************************************************
// Helper to copy a property record
//*******************************************************************************
HRESULT NEWMERGER::CopyProperty(
    MergeImportData *pImportData,           // [IN] import scope
    PropertyRec *pRecImp,                   // [IN] the record to import
    PropertyRec *pRecEmit)                  // [IN] the emit record to fill
{
    HRESULT     hr = NOERROR;
    CMiniMdRW   *pMiniMdImp = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    CMiniMdRW   *pMiniMdEmit = GetMiniMdEmit();
    LPCUTF8     szName;
    PCCOR_SIGNATURE pbSig;
    ULONG       cbSig;
    ULONG       cbEmit;
    CQuickBytes qbSig;
    MDTOKENMAP  *pCurTkMap;

    pCurTkMap = pImportData->m_pMDTokenMap;

    // move over the flag value
    pRecEmit->m_PropFlags = pRecImp->m_PropFlags;

    //move over the property name
    szName = pMiniMdImp->getNameOfProperty( pRecImp );
    IfFailGo( pMiniMdEmit->PutString(TBL_Property, PropertyRec::COL_Name, pRecEmit, szName) );

    // move over the type of the property
    pbSig = pMiniMdImp->getTypeOfProperty( pRecImp, &cbSig );

    // convert rid contained in signature to new scope
    IfFailGo( ImportHelper::MergeUpdateTokenInSig(    
        NULL,                       // Assembly emit scope.
        pMiniMdEmit,                // The emit scope.
        NULL, NULL, 0,              // Import assembly scope information.
        pMiniMdImp,                 // The scope to merge into the emit scope.
        pbSig,                      // signature from the imported scope
        pCurTkMap,                // Internal token mapping structure.
        &qbSig,                     // [OUT] translated signature
        0,                          // start from first byte of the signature
        0,                          // don't care how many bytes consumed
        &cbEmit) );                 // number of bytes write to cbEmit

    IfFailGo(pMiniMdEmit->PutBlob(TBL_Property, PropertyRec::COL_Type, pRecEmit, qbSig.Ptr(), cbEmit));

ErrExit:
    return hr;
}   // CopyProperty


//*****************************************************************************
// Copy MethodSemantics for an event or a property
//*****************************************************************************
HRESULT NEWMERGER::CopyMethodSemantics(
    MergeImportData *pImportData, 
    mdToken     tkImport,               // Event or property in the import scope
    mdToken     tkEmit)                 // corresponding event or property in the emitting scope
{
    HRESULT     hr = NOERROR;
    MethodSemanticsRec  *pRecImport = NULL;
    MethodSemanticsRec  *pRecEmit = NULL;
    CMiniMdRW   *pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    CMiniMdRW   *pMiniMdEmit = GetMiniMdEmit();
    ULONG       i;
    ULONG       msEmit;                 // MethodSemantics are just index not tokens
    mdToken     tkMethodImp;
    mdToken     tkMethodEmit;
    MDTOKENMAP  *pCurTkMap;
    HENUMInternal hEnum;

    pCurTkMap = pImportData->m_pMDTokenMap;

    // copy over the associates
    IfFailGo( pMiniMdImport->FindMethodSemanticsHelper(tkImport, &hEnum) );
    while (HENUMInternal::EnumNext(&hEnum, (mdToken *) &i))
    {
        pRecImport = pMiniMdImport->getMethodSemantics(i);
        IfNullGo( pRecEmit = pMiniMdEmit->AddMethodSemanticsRecord(&msEmit) );
        pRecEmit->m_Semantic = pRecImport->m_Semantic;

        // set the MethodSemantics
        tkMethodImp = pMiniMdImport->getMethodOfMethodSemantics(pRecImport);
        IfFailGo(  pCurTkMap->Remap(tkMethodImp, &tkMethodEmit) );
        IfFailGo( pMiniMdEmit->PutToken(TBL_MethodSemantics, MethodSemanticsRec::COL_Method, pRecEmit, tkMethodEmit));

        // set the associate
        _ASSERTE( pMiniMdImport->getAssociationOfMethodSemantics(pRecImport) == tkImport );
        IfFailGo( pMiniMdEmit->PutToken(TBL_MethodSemantics, MethodSemanticsRec::COL_Association, pRecEmit, tkEmit));

        // no need to record the movement since it is not a token
        IfFailGo( pMiniMdEmit->AddMethodSemanticsToHash(msEmit) );
    }
ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
    return hr;
}   //  CopyMethodSemantics


//*****************************************************************************
// Verify Events
//*****************************************************************************
HRESULT NEWMERGER::VerifyEvents(
    MergeImportData *pImportData, 
    mdTypeDef       tdImp, 
    mdTypeDef       tdEmit)
{
    HRESULT     hr = NOERROR;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    RID         ridEventMap;
    EventMapRec *pEventMapRec;  
    EventRec    *pRecImport;
    ULONG       ridStart;
    ULONG       ridEnd;
    ULONG       i;
    mdEvent     evImp;
    mdEvent     evEmit;
    TOKENREC    *pTokenRec;
    LPCUTF8     szName;
    mdToken     tkType;
    MDTOKENMAP  *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    pCurTkMap = pImportData->m_pMDTokenMap;

    ridEventMap = pMiniMdImport->FindEventMapFor(RidFromToken(tdImp));
    if (!InvalidRid(ridEventMap))
    {
        pEventMapRec = pMiniMdImport->getEventMap(ridEventMap);
        ridStart = pMiniMdImport->getEventListOfEventMap(pEventMapRec);
        ridEnd = pMiniMdImport->getEndEventListOfEventMap(pEventMapRec);

        for (i = ridStart; i < ridEnd; i++)
        {
            // get the property rid
            evImp = pMiniMdImport->GetEventRid(i);

            // only verify those Events that are marked
            if ( pMiniMdImport->GetFilterTable()->IsEventMarked(TokenFromRid(evImp, mdtEvent)) == false)
                continue;
            
            pRecImport = pMiniMdImport->getEvent(evImp);
            szName = pMiniMdImport->getNameOfEvent(pRecImport);
            tkType = pMiniMdImport->getEventTypeOfEvent( pRecImport );
            IfFailGo( pCurTkMap->Remap(tkType, &tkType) );
            evImp = TokenFromRid( evImp, mdtEvent);         

            if ( ImportHelper::FindEvent(
                pMiniMdEmit,
                tdEmit,
                szName,
                &evEmit) == S_OK )
            {
                // Good. We found the matching property when we have a duplicate typedef
                IfFailGo( pCurTkMap->InsertNotFound(evImp, true, evEmit, &pTokenRec) );
            }
            else
            {                            
                CheckContinuableErrorEx(META_E_EVENT_NOT_FOUND, pImportData, evImp);
            }
        }
    }
ErrExit:
    return hr;
}   // VerifyEvents


//*****************************************************************************
// Verify Properties
//*****************************************************************************
HRESULT NEWMERGER::VerifyProperties(
    MergeImportData *pImportData, 
    mdTypeDef       tdImp, 
    mdTypeDef       tdEmit)
{
    HRESULT     hr = NOERROR;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    RID         ridPropertyMap;
    PropertyMapRec *pPropertyMapRec;    
    PropertyRec *pRecImport;
    ULONG       ridStart;
    ULONG       ridEnd;
    ULONG       i;
    mdProperty  prImp;
    mdProperty  prEmit;
    TOKENREC    *pTokenRec;
    LPCUTF8     szName;
    PCCOR_SIGNATURE pbSig;
    ULONG       cbSig;
    ULONG       cbEmit;
    CQuickBytes qbSig;
    MDTOKENMAP  *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    pCurTkMap = pImportData->m_pMDTokenMap;

    ridPropertyMap = pMiniMdImport->FindPropertyMapFor(RidFromToken(tdImp));
    if (!InvalidRid(ridPropertyMap))
    {
        pPropertyMapRec = pMiniMdImport->getPropertyMap(ridPropertyMap);
        ridStart = pMiniMdImport->getPropertyListOfPropertyMap(pPropertyMapRec);
        ridEnd = pMiniMdImport->getEndPropertyListOfPropertyMap(pPropertyMapRec);

        for (i = ridStart; i < ridEnd; i++)
        {
            // get the property rid
            prImp = pMiniMdImport->GetPropertyRid(i);

            // only verify those Properties that are marked
            if ( pMiniMdImport->GetFilterTable()->IsPropertyMarked(TokenFromRid(prImp, mdtProperty)) == false)
                continue;
                        
            pRecImport = pMiniMdImport->getProperty(prImp);
            szName = pMiniMdImport->getNameOfProperty(pRecImport);
            pbSig = pMiniMdImport->getTypeOfProperty( pRecImport, &cbSig );
            prImp = TokenFromRid( prImp, mdtProperty);

            // convert rid contained in signature to new scope
            IfFailGo( ImportHelper::MergeUpdateTokenInSig(    
                NULL,                       // Emit assembly.
                pMiniMdEmit,                // The emit scope.
                NULL, NULL, 0,              // Import assembly scope information.
                pMiniMdImport,              // The scope to merge into the emit scope.
                pbSig,                      // signature from the imported scope
                pCurTkMap,                // Internal token mapping structure.
                &qbSig,                     // [OUT] translated signature
                0,                          // start from first byte of the signature
                0,                          // don't care how many bytes consumed
                &cbEmit) );                 // number of bytes write to cbEmit

            if ( ImportHelper::FindProperty(
                pMiniMdEmit,
                tdEmit,
                szName,
                (PCCOR_SIGNATURE) qbSig.Ptr(),
                cbEmit,
                &prEmit) == S_OK )
            {
                // Good. We found the matching property when we have a duplicate typedef
                IfFailGo( pCurTkMap->InsertNotFound(prImp, true, prEmit, &pTokenRec) );
            }
            else
            {
                CheckContinuableErrorEx(META_E_PROP_NOT_FOUND, pImportData, prImp);                
            }
        }
    }
ErrExit:
    return hr;
}   // VerifyProperties


//*****************************************************************************
// Verify Parameters given a Method
//*****************************************************************************
HRESULT NEWMERGER::VerifyParams(
    MergeImportData *pImportData,   
    mdMethodDef     mdImport,   
    mdMethodDef     mdEmit)
{
    HRESULT     hr = NOERROR;
    ParamRec    *pRecImport = NULL;
    ParamRec    *pRecEmit = NULL;
    MethodRec   *pMethodRec;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    ULONG       ridStart, ridEnd;
    ULONG       ridStartEmit, ridEndEmit;
    ULONG       i, j;
    mdParamDef  pdEmit;
    mdParamDef  pdImp;
    TOKENREC    *pTokenRec;
    LPCUTF8     szNameImp;
    LPCUTF8     szNameEmit;
    MDTOKENMAP  *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    pCurTkMap = pImportData->m_pMDTokenMap;

    pMethodRec = pMiniMdImport->getMethod(RidFromToken(mdImport));
    ridStart = pMiniMdImport->getParamListOfMethod(pMethodRec);
    ridEnd = pMiniMdImport->getEndParamListOfMethod(pMethodRec);

    pMethodRec = pMiniMdEmit->getMethod(RidFromToken(mdEmit));
    ridStartEmit = pMiniMdEmit->getParamListOfMethod(pMethodRec);
    ridEndEmit = pMiniMdEmit->getEndParamListOfMethod(pMethodRec);

    // loop through all Parameters
    for (i = ridStart; i < ridEnd; i++)
    {
        // Get the importing param row
        pdImp = pMiniMdImport->GetParamRid(i);

        // only verify those Params that are marked
        if ( pMiniMdImport->GetFilterTable()->IsParamMarked(TokenFromRid(pdImp, mdtParamDef)) == false)
            continue;
            

        pRecImport = pMiniMdImport->getParam(pdImp);
        pdImp = TokenFromRid(pdImp, mdtParamDef);

        // It turns out when we merge a typelib with itself, the emit and import scope
        // has different sequence of parameter!!!  arghh!!!
        //
        // find the corresponding emit param row
        for (j = ridStartEmit; j < ridEndEmit; j++)
        {
            pdEmit = pMiniMdEmit->GetParamRid(j);
            pRecEmit = pMiniMdEmit->getParam(pdEmit);
            if (pRecEmit->m_Sequence == pRecImport->m_Sequence)
                break;
        }

        if (j == ridEndEmit)
        {
            // did not find the corresponding parameter in the emiting scope
            CheckContinuableErrorEx(META_S_PARAM_MISMATCH, pImportData, pdImp);
        }

        else
        {
            _ASSERTE( pRecEmit->m_Sequence == pRecImport->m_Sequence );

            pdEmit = TokenFromRid(pdEmit, mdtParamDef);
    
            // record the token movement
            szNameImp = pMiniMdImport->getNameOfParam(pRecImport);
            szNameEmit = pMiniMdEmit->getNameOfParam(pRecEmit);
            if (szNameImp && szNameEmit && strcmp(szNameImp, szNameEmit) != 0)
            {
                // parameter name doesn't match
                CheckContinuableErrorEx(META_S_PARAM_MISMATCH, pImportData, pdImp);
            }
            if (pRecEmit->m_Flags != pRecImport->m_Flags)
            {
                // flags doesn't match
                CheckContinuableErrorEx(META_S_PARAM_MISMATCH, pImportData, pdImp);
            }

            // record token movement. This is a duplicate.
            IfFailGo( pCurTkMap->InsertNotFound(pdImp, true, pdEmit, &pTokenRec) );
        }
    }

ErrExit:
    return hr;
}   // VerifyParams


//*****************************************************************************
// Copy Methods given a TypeDef
//*****************************************************************************
HRESULT NEWMERGER::CopyMethods(
    MergeImportData *pImportData, 
    mdTypeDef       tdImport, 
    mdTypeDef       tdEmit)
{
    HRESULT         hr = NOERROR;
    MethodRec       *pRecImport = NULL;
    MethodRec       *pRecEmit = NULL;
    TypeDefRec      *pTypeDefRec;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           ridStart, ridEnd;
    ULONG           i;
    mdMethodDef     mdEmit;
    mdMethodDef     mdImp;
    TOKENREC        *pTokenRec;
    PCCOR_SIGNATURE pvSigBlob;
    ULONG           cbSigBlob;
    LPCSTR          szMethodName;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    pCurTkMap = pImportData->m_pMDTokenMap;

    pTypeDefRec = pMiniMdImport->getTypeDef(RidFromToken(tdImport));
    ridStart = pMiniMdImport->getMethodListOfTypeDef(pTypeDefRec);
    ridEnd = pMiniMdImport->getEndMethodListOfTypeDef(pTypeDefRec);

    // loop through all Methods
    for (i = ridStart; i < ridEnd; i++)
    {
        pMiniMdEmit->PreUpdate();

        // compare it with the emit scope
        mdImp = pMiniMdImport->GetMethodRid(i);

        // only merge those MethodDefs that are marked
        if ( pMiniMdImport->GetFilterTable()->IsMethodMarked(TokenFromRid(mdImp, mdtMethodDef)) == false)
            continue;

        pRecImport = pMiniMdImport->getMethod(mdImp);
        szMethodName = pMiniMdImport->getNameOfMethod(pRecImport);
        IfNullGo( pRecEmit = pMiniMdEmit->AddMethodRecord((RID *)&mdEmit) );

        // copy the method content over 
        IfFailGo( CopyMethod(pImportData, pRecImport, pRecEmit) );

        IfFailGo( pMiniMdEmit->AddMethodToTypeDef(RidFromToken(tdEmit), mdEmit));

        // record the token movement
        mdImp = TokenFromRid(mdImp, mdtMethodDef);
        mdEmit = TokenFromRid(mdEmit, mdtMethodDef);
        pvSigBlob = pMiniMdEmit->getSignatureOfMethod(pRecEmit, &cbSigBlob);
        IfFailGo( pMiniMdEmit->AddMemberDefToHash(
            mdEmit, 
            tdEmit) ); 

        IfFailGo( pCurTkMap->InsertNotFound(mdImp, false, mdEmit, &pTokenRec) );

        // copy over the children
        IfFailGo( CopyParams(pImportData, mdImp, mdEmit) );
    }

ErrExit:
    return hr;
}   // CopyMethods


//*****************************************************************************
// Copy Fields given a TypeDef
//*****************************************************************************
HRESULT NEWMERGER::CopyFields(
    MergeImportData *pImportData, 
    mdTypeDef       tdImport, 
    mdTypeDef       tdEmit)
{
    HRESULT         hr = NOERROR;
    FieldRec        *pRecImport = NULL;
    FieldRec        *pRecEmit = NULL;
    TypeDefRec      *pTypeDefRec;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           ridStart, ridEnd;
    ULONG           i;
    mdFieldDef      fdEmit;
    mdFieldDef      fdImp;
    bool            bDuplicate;
    TOKENREC        *pTokenRec;
    PCCOR_SIGNATURE pvSigBlob;
    ULONG           cbSigBlob;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    pCurTkMap = pImportData->m_pMDTokenMap;

    pTypeDefRec = pMiniMdImport->getTypeDef(RidFromToken(tdImport));
    ridStart = pMiniMdImport->getFieldListOfTypeDef(pTypeDefRec);
    ridEnd = pMiniMdImport->getEndFieldListOfTypeDef(pTypeDefRec);

    // loop through all FieldDef of a TypeDef
    for (i = ridStart; i < ridEnd; i++)
    {
        pMiniMdEmit->PreUpdate();

        // compare it with the emit scope
        fdImp = pMiniMdImport->GetFieldRid(i);

        // only merge those FieldDefs that are marked
        if ( pMiniMdImport->GetFilterTable()->IsFieldMarked(TokenFromRid(fdImp, mdtFieldDef)) == false)
            continue;

        
        pRecImport = pMiniMdImport->getField(fdImp);
        bDuplicate = false;
        IfNullGo( pRecEmit = pMiniMdEmit->AddFieldRecord((RID *)&fdEmit) );

        // copy the field content over 
        IfFailGo( CopyField(pImportData, pRecImport, pRecEmit) );
        
        IfFailGo( pMiniMdEmit->AddFieldToTypeDef(RidFromToken(tdEmit), fdEmit));

        // record the token movement
        fdImp = TokenFromRid(fdImp, mdtFieldDef);
        fdEmit = TokenFromRid(fdEmit, mdtFieldDef);
        pvSigBlob = pMiniMdEmit->getSignatureOfField(pRecEmit, &cbSigBlob);
        IfFailGo( pMiniMdEmit->AddMemberDefToHash(
            fdEmit, 
            tdEmit) ); 

        IfFailGo( pCurTkMap->InsertNotFound(fdImp, false, fdEmit, &pTokenRec) );

    }

ErrExit:
    return hr;
}   // CopyFields


//*****************************************************************************
// Copy Events given a TypeDef
//*****************************************************************************
HRESULT NEWMERGER::CopyEvents(
    MergeImportData *pImportData, 
    mdTypeDef       tdImp, 
    mdTypeDef       tdEmit)
{
    HRESULT     hr = NOERROR;
    CMiniMdRW   *pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    CMiniMdRW   *pMiniMdEmit = GetMiniMdEmit();
    RID         ridEventMap;
    EventMapRec *pEventMapRec;  
    EventRec    *pRecImport;
    EventRec    *pRecEmit;
    ULONG       ridStart;
    ULONG       ridEnd;
    ULONG       i;
    mdEvent     evImp;
    mdEvent     evEmit;
    TOKENREC    *pTokenRec;
    ULONG       iEventMap;
    EventMapRec *pEventMap;
    MDTOKENMAP  *pCurTkMap;

    pCurTkMap = pImportData->m_pMDTokenMap;

    ridEventMap = pMiniMdImport->FindEventMapFor(RidFromToken(tdImp));
    if (!InvalidRid(ridEventMap))
    {
        pEventMapRec = pMiniMdImport->getEventMap(ridEventMap);
        ridStart = pMiniMdImport->getEventListOfEventMap(pEventMapRec);
        ridEnd = pMiniMdImport->getEndEventListOfEventMap(pEventMapRec);

        if (ridEnd > ridStart)      
        {
            pMiniMdEmit->PreUpdate();
    
            // If there is any event, create the eventmap record in the emit scope
            // Create new record.
            IfNullGo(pEventMap = pMiniMdEmit->AddEventMapRecord(&iEventMap));

            // Set parent.
            IfFailGo(pMiniMdEmit->PutToken(TBL_EventMap, EventMapRec::COL_Parent, pEventMap, tdEmit));
        }
        
        for (i = ridStart; i < ridEnd; i++)
        {

            pMiniMdEmit->PreUpdate();

            // get the real event rid
            evImp = pMiniMdImport->GetEventRid(i);

            // only merge those Events that are marked
            if ( pMiniMdImport->GetFilterTable()->IsEventMarked(TokenFromRid(evImp, mdtEvent)) == false)
                continue;
            
            pRecImport = pMiniMdImport->getEvent(evImp);
            IfNullGo( pRecEmit = pMiniMdEmit->AddEventRecord((RID *)&evEmit) );

            // copy the event record over 
            IfFailGo( CopyEvent(pImportData, pRecImport, pRecEmit) );
            
            // Add Event to the EventMap.
            IfFailGo( pMiniMdEmit->AddEventToEventMap(iEventMap, evEmit) );

            // record the token movement
            evImp = TokenFromRid(evImp, mdtEvent);
            evEmit = TokenFromRid(evEmit, mdtEvent);

            IfFailGo( pCurTkMap->InsertNotFound(evImp, false, evEmit, &pTokenRec) );

            // copy over the method semantics
            IfFailGo( CopyMethodSemantics(pImportData, evImp, evEmit) );
        }
    }
ErrExit:
    return hr;
}   // CopyEvents


//*****************************************************************************
// Copy Properties given a TypeDef
//*****************************************************************************
HRESULT NEWMERGER::CopyProperties(
    MergeImportData *pImportData, 
    mdTypeDef       tdImp, 
    mdTypeDef       tdEmit)
{
    HRESULT     hr = NOERROR;
    CMiniMdRW   *pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    CMiniMdRW   *pMiniMdEmit = GetMiniMdEmit();
    RID         ridPropertyMap;
    PropertyMapRec *pPropertyMapRec;    
    PropertyRec *pRecImport;
    PropertyRec *pRecEmit;
    ULONG       ridStart;
    ULONG       ridEnd;
    ULONG       i;
    mdProperty  prImp;
    mdProperty  prEmit;
    TOKENREC    *pTokenRec;
    ULONG       iPropertyMap;
    PropertyMapRec  *pPropertyMap;
    MDTOKENMAP  *pCurTkMap;

    pCurTkMap = pImportData->m_pMDTokenMap;

    ridPropertyMap = pMiniMdImport->FindPropertyMapFor(RidFromToken(tdImp));
    if (!InvalidRid(ridPropertyMap))
    {
        pPropertyMapRec = pMiniMdImport->getPropertyMap(ridPropertyMap);
        ridStart = pMiniMdImport->getPropertyListOfPropertyMap(pPropertyMapRec);
        ridEnd = pMiniMdImport->getEndPropertyListOfPropertyMap(pPropertyMapRec);

        if (ridEnd > ridStart)      
        {
            pMiniMdEmit->PreUpdate();

            // If there is any event, create the PropertyMap record in the emit scope
            // Create new record.
            IfNullGo(pPropertyMap = pMiniMdEmit->AddPropertyMapRecord(&iPropertyMap));

            // Set parent.
            IfFailGo(pMiniMdEmit->PutToken(TBL_PropertyMap, PropertyMapRec::COL_Parent, pPropertyMap, tdEmit));
        }

        for (i = ridStart; i < ridEnd; i++)
        {
            pMiniMdEmit->PreUpdate();

            // get the property rid
            prImp = pMiniMdImport->GetPropertyRid(i);

            // only merge those Properties that are marked
            if ( pMiniMdImport->GetFilterTable()->IsPropertyMarked(TokenFromRid(prImp, mdtProperty)) == false)
                continue;
            
            
            pRecImport = pMiniMdImport->getProperty(prImp);
            IfNullGo( pRecEmit = pMiniMdEmit->AddPropertyRecord((RID *)&prEmit) );

            // copy the property record over 
            IfFailGo( CopyProperty(pImportData, pRecImport, pRecEmit) );

            // Add Property to the PropertyMap.
            IfFailGo( pMiniMdEmit->AddPropertyToPropertyMap(iPropertyMap, prEmit) );

            // record the token movement
            prImp = TokenFromRid(prImp, mdtProperty);
            prEmit = TokenFromRid(prEmit, mdtProperty);

            IfFailGo( pCurTkMap->InsertNotFound(prImp, false, prEmit, &pTokenRec) );

            // copy over the method semantics
            IfFailGo( CopyMethodSemantics(pImportData, prImp, prEmit) );
        }
    }
ErrExit:
    return hr;
}   // CopyProperties


//*****************************************************************************
// Copy Parameters given a TypeDef
//*****************************************************************************
HRESULT NEWMERGER::CopyParams(
    MergeImportData *pImportData, 
    mdMethodDef     mdImport,   
    mdMethodDef     mdEmit)
{
    HRESULT     hr = NOERROR;
    ParamRec    *pRecImport = NULL;
    ParamRec    *pRecEmit = NULL;
    MethodRec   *pMethodRec;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    ULONG       ridStart, ridEnd;
    ULONG       i;
    mdParamDef  pdEmit;
    mdParamDef  pdImp;
    TOKENREC    *pTokenRec;
    MDTOKENMAP  *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    pCurTkMap = pImportData->m_pMDTokenMap;


    pMethodRec = pMiniMdImport->getMethod(RidFromToken(mdImport));
    ridStart = pMiniMdImport->getParamListOfMethod(pMethodRec);
    ridEnd = pMiniMdImport->getEndParamListOfMethod(pMethodRec);

    // loop through all InterfaceImpl
    for (i = ridStart; i < ridEnd; i++)
    {
        pMiniMdEmit->PreUpdate();

        // Get the param rid
        pdImp = pMiniMdImport->GetParamRid(i);

        // only merge those Params that are marked
        if ( pMiniMdImport->GetFilterTable()->IsParamMarked(TokenFromRid(pdImp, mdtParamDef)) == false)
            continue;
            
        
        pRecImport = pMiniMdImport->getParam(pdImp);
        IfNullGo( pRecEmit = pMiniMdEmit->AddParamRecord((RID *)&pdEmit) );

        // copy the Parameter record over 
        IfFailGo( CopyParam(pImportData, pRecImport, pRecEmit) );

        // warning!! warning!!
        // We cannot add paramRec to method list until it is fully set.
        // AddParamToMethod will use the ulSequence in the record
        IfFailGo( pMiniMdEmit->AddParamToMethod(RidFromToken(mdEmit), pdEmit));

        // record the token movement
        pdImp = TokenFromRid(pdImp, mdtParamDef);
        pdEmit = TokenFromRid(pdEmit, mdtParamDef);

        IfFailGo( pCurTkMap->InsertNotFound(pdImp, false, pdEmit, &pTokenRec) );
    }

ErrExit:
    return hr;
}   // CopyParams


//*****************************************************************************
// merging MemberRef
//*****************************************************************************
HRESULT NEWMERGER::MergeMemberRefs( ) 
{
    HRESULT         hr = NOERROR;
    MemberRefRec    *pRecImport = NULL;
    MemberRefRec    *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    mdMemberRef     mrEmit;
    mdMemberRef     mrImp;
    bool            bDuplicate;
    TOKENREC        *pTokenRec;
    mdToken         tkParentImp;
    mdToken         tkParentEmit;

    LPCUTF8         szNameImp;
    PCCOR_SIGNATURE pbSig;
    ULONG           cbSig;
    ULONG           cbEmit;
    CQuickBytes     qbSig;

    bool            isRefOptimizedToDef;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;

        iCount = pMiniMdImport->getCountMemberRefs();

        // loop through all MemberRef
        for (i = 1; i <= iCount; i++)
        {

            // only merge those MemberRefs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsMemberRefMarked(TokenFromRid(i, mdtMemberRef)) == false)
                continue;

            isRefOptimizedToDef = false;

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getMemberRef(i);
            szNameImp = pMiniMdImport->getNameOfMemberRef(pRecImport);
            pbSig = pMiniMdImport->getSignatureOfMemberRef(pRecImport, &cbSig);
            tkParentImp = pMiniMdImport->getClassOfMemberRef(pRecImport);

            IfFailGo( pCurTkMap->Remap(tkParentImp, &tkParentEmit) );

            // convert rid contained in signature to new scope
            IfFailGo(ImportHelper::MergeUpdateTokenInSig(    
                NULL,                       // Assembly emit scope.
                pMiniMdEmit,                // The emit scope.
                NULL, NULL, 0,              // Import assembly information.
                pMiniMdImport,              // The scope to merge into the emit scope.
                pbSig,                      // signature from the imported scope
                pCurTkMap,                // Internal token mapping structure.
                &qbSig,                     // [OUT] translated signature
                0,                          // start from first byte of the signature
                0,                          // don't care how many bytes consumed
                &cbEmit));                  // number of bytes write to cbEmit

            // NEW!! NEW!! We want to know if we can optimize this MemberRef to a FieldDef or MethodDef
            if (TypeFromToken(tkParentEmit) == mdtTypeDef && RidFromToken(tkParentEmit) != 0)
            {
                // The parent of this MemberRef has been successfully optimized to a TypeDef. Then this MemberRef should be 
                // be able to optimized to a MethodDef or FieldDef unless one of the parent in the inheritance hierachy
                // is through TypeRef. Then this MemberRef stay as MemberRef. If This is a VarArg calling convention, then 
                // we will remap the MemberRef's parent to a MethodDef or stay as TypeRef.
                //
                mdToken     tkParent = tkParentEmit;
                mdToken     tkMethDefOrFieldDef;
                PCCOR_SIGNATURE pbSigTmp = (const COR_SIGNATURE *) qbSig.Ptr();

                while (TypeFromToken(tkParent) == mdtTypeDef && RidFromToken(tkParent) != 0)
                {
                    TypeDefRec      *pRec;
                    hr = ImportHelper::FindMember(pMiniMdEmit, tkParent, szNameImp, pbSigTmp, cbEmit, &tkMethDefOrFieldDef);
                    if (hr == S_OK)
                    {
                        // We have found a match!!
                        if (isCallConv(CorSigUncompressCallingConv(pbSigTmp), IMAGE_CEE_CS_CALLCONV_VARARG))
                        {
                            // The found MethodDef token will replace this MemberRef's parent token
                            _ASSERTE(TypeFromToken(tkMethDefOrFieldDef) == mdtMethodDef);
                            tkParentEmit = tkMethDefOrFieldDef;
                            break;
                        }
                        else
                        {
                            // The found MethodDef/FieldDef token will replace this MemberRef token and we won't introduce a MemberRef 
                            // record.
                            //
                            mrEmit = tkMethDefOrFieldDef;
                            isRefOptimizedToDef = true;
                            bDuplicate = true;
                            break;
                        }
                    }

                    // now walk up to the parent class of tkParent and try to resolve this MemberRef
                    pRec = pMiniMdEmit->getTypeDef(RidFromToken(tkParent));
                    tkParent = pMiniMdEmit->getExtendsOfTypeDef(pRec);
                }

                // When we exit the loop, there are several possibilities:
                // 1. We found a MethodDef/FieldDef to replace the MemberRef
                // 2. We found a MethodDef matches the MemberRef but the MemberRef is VarArg, thus we want to use the MethodDef in the 
                // parent column but not replacing it.
                // 3. We exit because we run out the TypeDef on the parent chain. If it is because we encounter a TypeRef, this TypeRef will
                // replace the parent column of the MemberRef. Or we encounter nil token! (This can be unresolved global MemberRef or
                // compiler error to put an undefined MemberRef. In this case, we should just use the old tkParentEmit
                // on the parent column for the MemberRef.

                if (TypeFromToken(tkParent) == mdtTypeRef && RidFromToken(tkParent) != 0)
                {
                    // we had walked up the parents chain to resolve it but we have not been successful and got stop by a TypeRef.
                    // Then we will use this TypeRef as the parent of the emit MemberRef record
                    //
                    tkParentEmit = tkParent;
                }
            }
            else if ((TypeFromToken(tkParentEmit) == mdtMethodDef &&
                      !isCallConv(CorSigUncompressCallingConv(pbSig), IMAGE_CEE_CS_CALLCONV_VARARG)) ||
                     (TypeFromToken(tkParentEmit) == mdtFieldDef))
            {
                // If the MemberRef's parent is already a non-vararg MethodDef or FieldDef, we can also
                // safely drop the MemberRef
                mrEmit = tkParentEmit;
                isRefOptimizedToDef = true;
                bDuplicate = true;
            }

            // If the Ref cannot be optimized to a Def or MemberRef to Def optmization is turned off, do the following.
            if (isRefOptimizedToDef == false || !((m_optimizeRefToDef & MDMemberRefToDef) == MDMemberRefToDef))
            {
                // does this MemberRef already exist in the emit scope?
                if ( m_fDupCheck && ImportHelper::FindMemberRef(
                    pMiniMdEmit,
                    tkParentEmit,
                    szNameImp,
                    (const COR_SIGNATURE *) qbSig.Ptr(),
                    cbEmit,
                    &mrEmit) == S_OK )
                {
                    // Yes, it does
                    bDuplicate = true;
                }
                else
                {
                    // No, it doesn't. Copy it over.
                    bDuplicate = false;
                    IfNullGo( pRecEmit = pMiniMdEmit->AddMemberRefRecord((RID *)&mrEmit) );
                    mrEmit = TokenFromRid( mrEmit, mdtMemberRef );

                    // Copy over the MemberRef context
                    IfFailGo(pMiniMdEmit->PutString(TBL_MemberRef, MemberRefRec::COL_Name, pRecEmit, szNameImp));
                    IfFailGo(pMiniMdEmit->PutToken(TBL_MemberRef, MemberRefRec::COL_Class, pRecEmit, tkParentEmit));
                    IfFailGo(pMiniMdEmit->PutBlob(TBL_MemberRef, MemberRefRec::COL_Signature, pRecEmit,
                                                qbSig.Ptr(), cbEmit));
                    IfFailGo(pMiniMdEmit->AddMemberRefToHash(mrEmit) );
                }
            }
            // record the token movement
            mrImp = TokenFromRid(i, mdtMemberRef);
            IfFailGo( pCurTkMap->InsertNotFound(mrImp, bDuplicate, mrEmit, &pTokenRec) );
        }
    }


ErrExit:
    return hr;
}   // MergeMemberRefs


//*****************************************************************************
// merge interface impl
//*****************************************************************************
HRESULT NEWMERGER::MergeInterfaceImpls( ) 
{
    HRESULT         hr = NOERROR;
    InterfaceImplRec    *pRecImport = NULL;
    InterfaceImplRec    *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    mdTypeDef       tkParent;
    mdInterfaceImpl iiEmit;
    bool            bDuplicate;
    TOKENREC        *pTokenRec;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountInterfaceImpls();

        // loop through all InterfaceImpl
        for (i = 1; i <= iCount; i++)
        {
            // only merge those InterfaceImpls that are marked
            if ( pMiniMdImport->GetFilterTable()->IsInterfaceImplMarked(TokenFromRid(i, mdtInterfaceImpl)) == false)
                continue;

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getInterfaceImpl(i);
            tkParent = pMiniMdImport->getClassOfInterfaceImpl(pRecImport);

            // does this TypeRef already exist in the emit scope?
            if ( pCurTkMap->Find(tkParent, &pTokenRec) )
            {
                if ( pTokenRec->m_isDuplicate )
                {
                    // parent in the emit scope
                    mdToken     tkParent;
                    mdToken     tkInterface;

                    // remap the typedef token
                    tkParent = pTokenRec->m_tkTo;

                    // remap the implemented interface token
                    tkInterface = pMiniMdImport->getInterfaceOfInterfaceImpl(pRecImport);
                    IfFailGo( pCurTkMap->Remap( tkInterface, &tkInterface) );

                    // Set duplicate flag
                    bDuplicate = true;

                    // find the corresponding interfaceimpl in the emit scope
                    if ( ImportHelper::FindInterfaceImpl(pMiniMdEmit, tkParent, tkInterface, &iiEmit) != S_OK )
                    {
                        // bad state!! We have a duplicate typedef but the interface impl is not the same!!

                        // continueable error
                        CheckContinuableErrorEx(
                            META_E_INTFCEIMPL_NOT_FOUND, 
                            pImportData,
                            TokenFromRid(i, mdtInterfaceImpl));

                        iiEmit = mdTokenNil;
                    }
                }
                else
                {
                    // No, it doesn't. Copy it over.
                    bDuplicate = false;
                    IfNullGo( pRecEmit = pMiniMdEmit->AddInterfaceImplRecord((RID *)&iiEmit) );

                    // copy the interfaceimp record over 
                    IfFailGo( CopyInterfaceImpl( pRecEmit, pImportData, pRecImport) );
                }
            }
            else
            {
                _ASSERTE( !"bad state!");
                IfFailGo( META_E_BADMETADATA );
            }

            // record the token movement
            IfFailGo( pCurTkMap->InsertNotFound(
                TokenFromRid(i, mdtInterfaceImpl), 
                bDuplicate, 
                TokenFromRid( iiEmit, mdtInterfaceImpl ), 
                &pTokenRec) );
        }
    }


ErrExit:
    return hr;
}   // MergeInterfaceImpls


//*****************************************************************************
// merge all of the constant for field, property, and parameter
//*****************************************************************************
HRESULT NEWMERGER::MergeConstants() 
{
    HRESULT         hr = NOERROR;
    ConstantRec     *pRecImport = NULL;
    ConstantRec     *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    ULONG           csEmit;                 // constant value is not a token
    mdToken         tkParentImp;
    TOKENREC        *pTokenRec;
    void const      *pValue;
    ULONG           cbBlob;
#if _DEBUG
    ULONG           typeParent;
#endif // _DEBUG

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountConstants();

        // loop through all Constants
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getConstant(i);
            tkParentImp = pMiniMdImport->getParentOfConstant(pRecImport);

            // only move those constant over if their parents are marked
            // If MDTOKENMAP::Find return false, we don't need to copy the constant value over
            if ( pCurTkMap->Find(tkParentImp, &pTokenRec) )
            {
                // If the parent is duplicated, no need to move over the constant value
                if ( !pTokenRec->m_isDuplicate )
                {
                    IfNullGo( pRecEmit = pMiniMdEmit->AddConstantRecord(&csEmit) );
                    pRecEmit->m_Type = pRecImport->m_Type;

                    // set the parent
                    IfFailGo( pMiniMdEmit->PutToken(TBL_Constant, ConstantRec::COL_Parent, pRecEmit, pTokenRec->m_tkTo) );

                    // move over the constant blob value
                    pValue = pMiniMdImport->getValueOfConstant(pRecImport, &cbBlob);
                    IfFailGo( pMiniMdEmit->PutBlob(TBL_Constant, ConstantRec::COL_Value, pRecEmit, pValue, cbBlob) );
                    IfFailGo( pMiniMdEmit->AddConstantToHash(csEmit) );
                }
                else
                {
                    // @FUTURE: more verification on the duplicate??
                }
            }
#if _DEBUG
            // Include this block of checkin only under Debug build. The reason is that 
            // Linker to choose all the error that we report (such as unmatched MethodDef or FieldDef)
            // as a continuable error. It is likely to hit this else while the tkparentImp is marked if there
            // ia any error reported earlier!!
            else
            {
                typeParent = TypeFromToken(tkParentImp);
                if (typeParent == mdtFieldDef)
                {
                    // FieldDef should not be marked.
                    if ( pMiniMdImport->GetFilterTable()->IsFieldMarked(tkParentImp) == false)
                        continue;
                }
                else if (typeParent == mdtParamDef)
                {
                    // ParamDef should not be marked.
                    if ( pMiniMdImport->GetFilterTable()->IsParamMarked(tkParentImp) == false)
                        continue;
                }
                else
                {
                    _ASSERTE(typeParent == mdtProperty);
                    // Property should not be marked.
                    if ( pMiniMdImport->GetFilterTable()->IsPropertyMarked(tkParentImp) == false)
                        continue;
                }

                // If we come to here, we have a constant that its parent is marked but we could not
                // find it in the map!! Bad state.

                _ASSERTE(!"Ignore this error if you have seen error reported earlier! Otherwise bad token map or bad metadata!");
            }
#endif // 0
            // Note that we don't need to record the token movement since constant is not a valid token kind.
        }
    }

ErrExit:
    return hr;
}   // MergeConstants


//*****************************************************************************
// Merge field marshal information
//*****************************************************************************
HRESULT NEWMERGER::MergeFieldMarshals() 
{
    HRESULT     hr = NOERROR;
    FieldMarshalRec *pRecImport = NULL;
    FieldMarshalRec *pRecEmit = NULL;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    ULONG       iCount;
    ULONG       i;
    ULONG       fmEmit;                 // FieldMarhsal is not a token 
    mdToken     tkParentImp;
    TOKENREC    *pTokenRec;
    void const  *pValue;
    ULONG       cbBlob;
#if _DEBUG
    ULONG       typeParent;
#endif // _DEBUG

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountFieldMarshals();

        // loop through all TypeRef
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getFieldMarshal(i);
            tkParentImp = pMiniMdImport->getParentOfFieldMarshal(pRecImport);

            // We want to merge only those field marshals that parents are marked.
            // Find will return false if the parent is not marked
            //
            if ( pCurTkMap->Find(tkParentImp, &pTokenRec) )
            {
                // If the parent is duplicated, no need to move over the constant value
                if ( !pTokenRec->m_isDuplicate )
                {
                    IfNullGo( pRecEmit = pMiniMdEmit->AddFieldMarshalRecord(&fmEmit) );

                    // set the parent
                    IfFailGo( pMiniMdEmit->PutToken(
                        TBL_FieldMarshal, 
                        FieldMarshalRec::COL_Parent, 
                        pRecEmit, 
                        pTokenRec->m_tkTo) );

                    // move over the constant blob value
                    pValue = pMiniMdImport->getNativeTypeOfFieldMarshal(pRecImport, &cbBlob);
                    IfFailGo( pMiniMdEmit->PutBlob(TBL_FieldMarshal, FieldMarshalRec::COL_NativeType, pRecEmit, pValue, cbBlob) );
                    IfFailGo( pMiniMdEmit->AddFieldMarshalToHash(fmEmit) );

                }
                else
                {
                    // @FUTURE: more verification on the duplicate??
                }
            }
#if _DEBUG
            else
            {
                typeParent = TypeFromToken(tkParentImp);

                if (typeParent == mdtFieldDef)
                {
                    // FieldDefs should not be marked
                    if ( pMiniMdImport->GetFilterTable()->IsFieldMarked(tkParentImp) == false)
                        continue;
                }
                else
                {
                    _ASSERTE(typeParent == mdtParamDef);
                    // ParamDefs should not be  marked
                    if ( pMiniMdImport->GetFilterTable()->IsParamMarked(tkParentImp) == false)
                        continue;
                }

                // If we come to here, that is we have FieldMarshal that its parent is marked and we don't find it
                // in the map!!!

                // either bad lookup map or bad metadata
                _ASSERTE(!"Ignore this assert if you have seen error reported earlier. Otherwise, it is bad state!");
            }
#endif // _DEBUG
        }
        // Note that we don't need to record the token movement since FieldMarshal is not a valid token kind.
    }

ErrExit:
    return hr;
}   // MergeFieldMarshals


//*****************************************************************************
// Merge class layout information
//*****************************************************************************
HRESULT NEWMERGER::MergeClassLayouts() 
{
    HRESULT         hr = NOERROR;
    ClassLayoutRec  *pRecImport = NULL;
    ClassLayoutRec  *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    ULONG           iRecord;                    // class layout is not a token
    mdToken         tkParentImp;
    TOKENREC        *pTokenRec;
    RID             ridClassLayout;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountClassLayouts();

        // loop through all TypeRef
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getClassLayout(i);
            tkParentImp = pMiniMdImport->getParentOfClassLayout(pRecImport);

            // only merge those TypeDefs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsTypeDefMarked(tkParentImp) == false)
                continue;

            if ( pCurTkMap->Find(tkParentImp, &pTokenRec) )
            {
                if ( !pTokenRec->m_isDuplicate )
                {
                    // If the parent is not duplicated, just copy over the classlayout information
                    IfNullGo( pRecEmit = pMiniMdEmit->AddClassLayoutRecord(&iRecord) );

                    // copy over the fix part information
                    pRecEmit->m_PackingSize = pRecImport->m_PackingSize;
                    pRecEmit->m_ClassSize = pRecImport->m_ClassSize;
                    IfFailGo( pMiniMdEmit->PutToken(TBL_ClassLayout, ClassLayoutRec::COL_Parent, pRecEmit, pTokenRec->m_tkTo));
                    IfFailGo( pMiniMdEmit->AddClassLayoutToHash(iRecord) );
                }
                else
                {

                    ridClassLayout = pMiniMdEmit->FindClassLayoutHelper(pTokenRec->m_tkTo);

                    if (InvalidRid(ridClassLayout))
                    {
                        // class is duplicated but not class layout info                        
                        CheckContinuableErrorEx(META_E_CLASS_LAYOUT_INCONSISTENT, pImportData, tkParentImp);
                    }
                    else
                    {
                        pRecEmit = pMiniMdEmit->getClassLayout(RidFromToken(ridClassLayout));
                        if (pMiniMdImport->getPackingSizeOfClassLayout(pRecImport) != pMiniMdEmit->getPackingSizeOfClassLayout(pRecEmit) || 
                            pMiniMdImport->getClassSizeOfClassLayout(pRecImport) != pMiniMdEmit->getClassSizeOfClassLayout(pRecEmit) )
                        {
                            CheckContinuableErrorEx(META_E_CLASS_LAYOUT_INCONSISTENT, pImportData, tkParentImp);
                        }
                    }
                }
            }
            else
            {
                // bad lookup map
                _ASSERTE( !"bad state!");
                IfFailGo( META_E_BADMETADATA );
            }
            // no need to record the index movement. Classlayout is not a token.
        }
    }
ErrExit:
    return hr;
}   // MergeClassLayouts

//*****************************************************************************
// Merge field layout information
//*****************************************************************************
HRESULT NEWMERGER::MergeFieldLayouts() 
{
    HRESULT         hr = NOERROR;
    FieldLayoutRec *pRecImport = NULL;
    FieldLayoutRec *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    ULONG           iRecord;                    // field layout2 is not a token.
    mdToken         tkFieldImp;
    TOKENREC        *pTokenRec;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountFieldLayouts();

        // loop through all FieldLayout records.
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getFieldLayout(i);
            tkFieldImp = pMiniMdImport->getFieldOfFieldLayout(pRecImport);
        
            // only merge those FieldDefs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsFieldMarked(tkFieldImp) == false)
                continue;

            if ( pCurTkMap->Find(tkFieldImp, &pTokenRec) )
            {
                if ( !pTokenRec->m_isDuplicate )
                {
                    // If the Field is not duplicated, just copy over the FieldLayout information
                    IfNullGo( pRecEmit = pMiniMdEmit->AddFieldLayoutRecord(&iRecord) );

                    // copy over the fix part information
                    pRecEmit->m_OffSet = pRecImport->m_OffSet;
                    IfFailGo( pMiniMdEmit->PutToken(TBL_FieldLayout, FieldLayoutRec::COL_Field, pRecEmit, pTokenRec->m_tkTo));
                    IfFailGo( pMiniMdEmit->AddFieldLayoutToHash(iRecord) );
                }
                else
                {
                    // @FUTURE: more verification??
                }
            }
            else
            {
                // bad lookup map
                _ASSERTE( !"bad state!");
                IfFailGo( META_E_BADMETADATA );
            }
            // no need to record the index movement. fieldlayout2 is not a token.
        }
    }

ErrExit:
    return hr;
}   // MergeFieldLayouts


//*****************************************************************************
// Merge field RVAs
//*****************************************************************************
HRESULT NEWMERGER::MergeFieldRVAs() 
{
    HRESULT         hr = NOERROR;
    FieldRVARec     *pRecImport = NULL;
    FieldRVARec     *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    ULONG           iRecord;                    // FieldRVA is not a token.
    mdToken         tkFieldImp;
    TOKENREC        *pTokenRec;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountFieldRVAs();

        // loop through all FieldRVA records.
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getFieldRVA(i);
            tkFieldImp = pMiniMdImport->getFieldOfFieldRVA(pRecImport);
        
            // only merge those FieldDefs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsFieldMarked(TokenFromRid(tkFieldImp, mdtFieldDef)) == false)
                continue;

            if ( pCurTkMap->Find(tkFieldImp, &pTokenRec) )
            {
                if ( !pTokenRec->m_isDuplicate )
                {
                    // If the Field is not duplicated, just copy over the FieldRVA information
                    IfNullGo( pRecEmit = pMiniMdEmit->AddFieldRVARecord(&iRecord) );

                    // copy over the fix part information
                    pRecEmit->m_RVA = pRecImport->m_RVA;
                    IfFailGo( pMiniMdEmit->PutToken(TBL_FieldRVA, FieldRVARec::COL_Field, pRecEmit, pTokenRec->m_tkTo));
                    IfFailGo( pMiniMdEmit->AddFieldRVAToHash(iRecord) );
                }
                else
                {
                    // @FUTURE: more verification??
                }
            }
            else
            {
                // bad lookup map
                _ASSERTE( !"bad state!");
                IfFailGo( META_E_BADMETADATA );
            }
            // no need to record the index movement. FieldRVA is not a token.
        }
    }

ErrExit:
    return hr;
}   // MergeFieldRVAs


//*****************************************************************************
// Merge MethodImpl information
//*****************************************************************************
HRESULT NEWMERGER::MergeMethodImpls() 
{
    HRESULT     hr = NOERROR;
    MethodImplRec   *pRecImport = NULL;
    MethodImplRec   *pRecEmit = NULL;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    ULONG       iCount;
    ULONG       i;
    RID         iRecord;
    mdTypeDef   tkClassImp;
    mdToken     tkBodyImp;
    mdToken     tkDeclImp;
    TOKENREC    *pTokenRecClass;
    mdToken     tkBodyEmit;
    mdToken     tkDeclEmit;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountMethodImpls();

        // loop through all the MethodImpls.
        for (i = 1; i <= iCount; i++)
        {
            // only merge those MethodImpls that are marked.
            if ( pMiniMdImport->GetFilterTable()->IsMethodImplMarked(i) == false)
                continue;

            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getMethodImpl(i);
            tkClassImp = pMiniMdImport->getClassOfMethodImpl(pRecImport);
            tkBodyImp = pMiniMdImport->getMethodBodyOfMethodImpl(pRecImport);
            tkDeclImp = pMiniMdImport->getMethodDeclarationOfMethodImpl(pRecImport);

            if ( pCurTkMap->Find(tkClassImp, &pTokenRecClass))
            {
                // If the TypeDef is duplicated, no need to move over the MethodImpl record.
                if ( !pTokenRecClass->m_isDuplicate )
                {
                    // Create a new record and set the data.

                    // @FUTURE: We might want to consider to change the error for the remap into a continuable error.
                    // Because we probably can continue merging for more data...

                    IfFailGo( pCurTkMap->Remap(tkBodyImp, &tkBodyEmit) );
                    IfFailGo( pCurTkMap->Remap(tkDeclImp, &tkDeclEmit) );
                    IfNullGo( pRecEmit = pMiniMdEmit->AddMethodImplRecord(&iRecord) );
                    IfFailGo( pMiniMdEmit->PutToken(TBL_MethodImpl, MethodImplRec::COL_Class, pRecEmit, pTokenRecClass->m_tkTo) );
                    IfFailGo( pMiniMdEmit->PutToken(TBL_MethodImpl, MethodImplRec::COL_MethodBody, pRecEmit, tkBodyEmit) );
                    IfFailGo( pMiniMdEmit->PutToken(TBL_MethodImpl, MethodImplRec::COL_MethodDeclaration, pRecEmit, tkDeclEmit) );
                    IfFailGo( pMiniMdEmit->AddMethodImplToHash(iRecord) );
                }
                else
                {
                    // @FUTURE: more verification on the duplicate??
                }
                // No need to record the token movement, MethodImpl is not a token.
            }
            else
            {
                // either bad lookup map or bad metadata
                _ASSERTE(!"bad state");
                IfFailGo( META_E_BADMETADATA );
            }
        }
    }
ErrExit:
    return hr;
}   // MergeMethodImpls


//*****************************************************************************
// Merge PInvoke
//*****************************************************************************
HRESULT NEWMERGER::MergePinvoke() 
{
    HRESULT         hr = NOERROR;
    ImplMapRec      *pRecImport = NULL;
    ImplMapRec      *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    mdModuleRef     mrImp;
    mdMethodDef     mdImp;
    RID             mdImplMap;
    TOKENREC        *pTokenRecMR;
    TOKENREC        *pTokenRecMD;

    USHORT          usMappingFlags;
    LPCUTF8         szImportName;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountImplMaps();

        // loop through all ImplMaps
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getImplMap(i);

            // Get the MethodDef token in the new space.
            mdImp = pMiniMdImport->getMemberForwardedOfImplMap(pRecImport);

            // only merge those MethodDefs that are marked
            if ( pMiniMdImport->GetFilterTable()->IsMethodMarked(mdImp) == false)
                continue;

            // Get the ModuleRef token in the new space.
            mrImp = pMiniMdImport->getImportScopeOfImplMap(pRecImport);

            // map the token to the new scope
            if (pCurTkMap->Find(mrImp, &pTokenRecMR) == false)
            {
                // This should never fire unless the module refs weren't merged
                // before this code ran.
                _ASSERTE(!"Parent ModuleRef not found in MERGER::MergePinvoke.  Bad state!");
                IfFailGo( META_E_BADMETADATA );
            }

            if (pCurTkMap->Find(mdImp, &pTokenRecMD) == false)
            {
                // This should never fire unless the method defs weren't merged
                // before this code ran.
                _ASSERTE(!"Parent MethodDef not found in MERGER::MergePinvoke.  Bad state!");
                IfFailGo( META_E_BADMETADATA );
            }


            // Get copy of rest of data.
            usMappingFlags = pMiniMdImport->getMappingFlagsOfImplMap(pRecImport);
            szImportName = pMiniMdImport->getImportNameOfImplMap(pRecImport);

            // If the method associated with PInvokeMap is not duplicated, then don't bother to look up the 
            // duplicated PInvokeMap information.
            if (pTokenRecMD->m_isDuplicate == true)
            {
                // Does the correct ImplMap entry exist in the emit scope?
                mdImplMap = pMiniMdEmit->FindImplMapHelper(pTokenRecMD->m_tkTo);
            }
            else
            {
                mdImplMap = mdTokenNil;
            }
            if (!InvalidRid(mdImplMap))
            {
                // Verify that the rest of the data is identical, else its an error.
                pRecEmit = pMiniMdEmit->getImplMap(mdImplMap);
                _ASSERTE(pMiniMdEmit->getMemberForwardedOfImplMap(pRecEmit) == pTokenRecMD->m_tkTo);
                if (pMiniMdEmit->getImportScopeOfImplMap(pRecEmit) != pTokenRecMR->m_tkTo ||
                    pMiniMdEmit->getMappingFlagsOfImplMap(pRecEmit) != usMappingFlags ||
                    strcmp(pMiniMdEmit->getImportNameOfImplMap(pRecEmit), szImportName))
                {
                    // Mis-matched p-invoke entries are found.
                    _ASSERTE(!"Mis-matched P-invoke entries during merge.  Bad State!");
                    IfFailGo(E_FAIL);
                }
            }
            else
            {
                IfNullGo( pRecEmit = pMiniMdEmit->AddImplMapRecord(&mdImplMap) );

                // Copy rest of data.
                IfFailGo( pMiniMdEmit->PutToken(TBL_ImplMap, ImplMapRec::COL_MemberForwarded, pRecEmit, pTokenRecMD->m_tkTo) );
                IfFailGo( pMiniMdEmit->PutToken(TBL_ImplMap, ImplMapRec::COL_ImportScope, pRecEmit, pTokenRecMR->m_tkTo) );
                IfFailGo( pMiniMdEmit->PutString(TBL_ImplMap, ImplMapRec::COL_ImportName, pRecEmit, szImportName) );
                pRecEmit->m_MappingFlags = usMappingFlags;
                IfFailGo( pMiniMdEmit->AddImplMapToHash(mdImplMap) );
            }
        }
    }


ErrExit:
    return hr;
}   // MergePinvoke


//*****************************************************************************
// Merge StandAloneSigs
//*****************************************************************************
HRESULT NEWMERGER::MergeStandAloneSigs() 
{
    HRESULT         hr = NOERROR;
    StandAloneSigRec    *pRecImport = NULL;
    StandAloneSigRec    *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    TOKENREC        *pTokenRec;
    mdSignature     saImp;
    mdSignature     saEmit;
    bool            fDuplicate;
    PCCOR_SIGNATURE pbSig;
    ULONG           cbSig;
    ULONG           cbEmit;
    CQuickBytes     qbSig;
    PCOR_SIGNATURE  rgSig;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountStandAloneSigs();

        // loop through all Signature
        for (i = 1; i <= iCount; i++)
        {
            // only merge those Signatures that are marked
            if ( pMiniMdImport->GetFilterTable()->IsSignatureMarked(TokenFromRid(i, mdtSignature)) == false)
                continue;

            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getStandAloneSig(i);
            pbSig = pMiniMdImport->getSignatureOfStandAloneSig(pRecImport, &cbSig);

            // This is a signature containing the return type after count of args
            // convert rid contained in signature to new scope
            IfFailGo(ImportHelper::MergeUpdateTokenInSig(    
                NULL,                       // Assembly emit scope.
                pMiniMdEmit,                // The emit scope.
                NULL, NULL, 0,              // Assembly import scope info.
                pMiniMdImport,              // The scope to merge into the emit scope.
                pbSig,                      // signature from the imported scope
                pCurTkMap,                // Internal token mapping structure.
                &qbSig,                     // [OUT] translated signature
                0,                          // start from first byte of the signature
                0,                          // don't care how many bytes consumed
                &cbEmit));                  // number of bytes write to cbEmit
            rgSig = ( PCOR_SIGNATURE ) qbSig.Ptr();

            hr = ImportHelper::FindStandAloneSig(
                pMiniMdEmit,
                rgSig,
                cbEmit,
                &saEmit );
            if ( hr == S_OK )
            {
                // find a duplicate
                fDuplicate = true;
            }
            else
            {
                // copy over
                fDuplicate = false;
                IfNullGo( pRecEmit = pMiniMdEmit->AddStandAloneSigRecord((ULONG *)&saEmit) );
                saEmit = TokenFromRid(saEmit, mdtSignature);
                IfFailGo( pMiniMdEmit->PutBlob(TBL_StandAloneSig, StandAloneSigRec::COL_Signature, pRecEmit, rgSig, cbEmit));
            }
            saImp = TokenFromRid(i, mdtSignature);

            // Record the token movement
            IfFailGo( pCurTkMap->InsertNotFound(saImp, fDuplicate, saEmit, &pTokenRec) );
        }
    }

ErrExit:
    return hr;
}   // MergeStandAloneSigs

    
//*****************************************************************************
// Merge DeclSecuritys
//*****************************************************************************
HRESULT NEWMERGER::MergeDeclSecuritys() 
{
    HRESULT         hr = NOERROR;
    DeclSecurityRec *pRecImport = NULL;
    DeclSecurityRec *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    mdToken         tkParentImp;
    TOKENREC        *pTokenRec;
    void const      *pValue;
    ULONG           cbBlob;
    mdPermission    pmImp;
    mdPermission    pmEmit;
    bool            fDuplicate;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountDeclSecuritys();

        // loop through all TypeRef
        for (i = 1; i <= iCount; i++)
        {
            // only merge those DeclSecurities that are marked
            if ( pMiniMdImport->GetFilterTable()->IsDeclSecurityMarked(TokenFromRid(i, mdtPermission)) == false)
                continue;
        
            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getDeclSecurity(i);
            tkParentImp = pMiniMdImport->getParentOfDeclSecurity(pRecImport);
            if ( pCurTkMap->Find(tkParentImp, &pTokenRec) )
            {
                if ( !pTokenRec->m_isDuplicate )
                {
                    // If the parent is not duplicated, just copy over the custom value
                    goto CopyPermission;
                }
                else
                {
                    // Try to see if the Permission is there in the emit scope or not.
                    // If not, move it over still
                    if ( ImportHelper::FindPermission(
                        pMiniMdEmit,
                        pTokenRec->m_tkTo,
                        pRecImport->m_Action,
                        &pmEmit) == S_OK )
                    {
                        // found a match
                        // @FUTURE: more verification??
                        fDuplicate = true;
                    }
                    else
                    {
                        // Parent is duplicated but the Permission is not. Still copy over the
                        // Permission.
CopyPermission:
                        fDuplicate = false;
                        IfNullGo( pRecEmit = pMiniMdEmit->AddDeclSecurityRecord((ULONG *)&pmEmit) );
                        pmEmit = TokenFromRid(pmEmit, mdtPermission);

                        pRecEmit->m_Action = pRecImport->m_Action;

                        // set the parent
                        IfFailGo( pMiniMdEmit->PutToken(
                            TBL_DeclSecurity, 
                            DeclSecurityRec::COL_Parent, 
                            pRecEmit, 
                            pTokenRec->m_tkTo) );

                        // move over the CustomAttribute blob value
                        pValue = pMiniMdImport->getPermissionSetOfDeclSecurity(pRecImport, &cbBlob);
                        IfFailGo( pMiniMdEmit->PutBlob(
                            TBL_DeclSecurity, 
                            DeclSecurityRec::COL_PermissionSet, 
                            pRecEmit, 
                            pValue, 
                            cbBlob));
                    }
                }
                pmEmit = TokenFromRid(pmEmit, mdtPermission);
                pmImp = TokenFromRid(i, mdtPermission);

                // Record the token movement
                IfFailGo( pCurTkMap->InsertNotFound(pmImp, fDuplicate, pmEmit, &pTokenRec) );
            }
            else
            {
                // bad lookup map
                _ASSERTE(!"bad state");
                IfFailGo( META_E_BADMETADATA );
            }
        }
    }

ErrExit:
    return hr;
}   // MergeDeclSecuritys


//*****************************************************************************
// Merge Strings
//*****************************************************************************
HRESULT NEWMERGER::MergeStrings() 
{
    HRESULT         hr = NOERROR;
    void            *pvStringBlob;
    ULONG           cbBlob;
    ULONG           ulImport = 0;
    ULONG           ulEmit;
    ULONG           ulNext;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    TOKENREC        *pTokenRec;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        ulImport = 0;
        while (ulImport != -1)
        {
            pvStringBlob = pMiniMdImport->GetUserStringNext(ulImport, &cbBlob, &ulNext);
            if (!cbBlob)
            {
                ulImport = ulNext;
                continue;
            }
            if ( pMiniMdImport->GetFilterTable()->IsUserStringMarked(TokenFromRid(ulImport, mdtString)) == false)
            {
                ulImport = ulNext;
                continue;
            }

            IfFailGo(pMiniMdEmit->PutUserString(pvStringBlob, cbBlob, &ulEmit));

            IfFailGo( pCurTkMap->InsertNotFound(
                TokenFromRid(ulImport, mdtString),
                false,
                TokenFromRid(ulEmit, mdtString),
                &pTokenRec) );
            ulImport = ulNext;
        }
    }
ErrExit:
    return hr;
}   // MergeStrings


//*****************************************************************************
// Merge CustomAttributes
//*****************************************************************************
HRESULT NEWMERGER::MergeCustomAttributes() 
{
    HRESULT         hr = NOERROR;
    CustomAttributeRec  *pRecImport = NULL;
    CustomAttributeRec  *pRecEmit = NULL;
    CMiniMdRW       *pMiniMdImport;
    CMiniMdRW       *pMiniMdEmit;
    ULONG           iCount;
    ULONG           i;
    mdToken         tkParentImp;            // Token of attributed object (parent).
    TOKENREC        *pTokenRec;             // Parent's remap.
    mdToken         tkType;                 // Token of attribute's type.
    TOKENREC        *pTypeRec;              // Type's remap.
    void const      *pValue;                // The actual value.
    ULONG           cbBlob;                 // Size of the value.
    mdToken         cvImp;
    mdToken         cvEmit;
    bool            fDuplicate;
    mdToken         tkModule = TokenFromRid(1, mdtModule);

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountCustomAttributes();

        // loop through all CustomAttribute
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            // compare it with the emit scope
            pRecImport = pMiniMdImport->getCustomAttribute(i);
            tkParentImp = pMiniMdImport->getParentOfCustomAttribute(pRecImport);
            tkType = pMiniMdImport->getTypeOfCustomAttribute(pRecImport);
            pValue = pMiniMdImport->getValueOfCustomAttribute(pRecImport, &cbBlob);

            // only merge those CustomAttributes that are marked
            if ( pMiniMdImport->GetFilterTable()->IsCustomAttributeMarked(TokenFromRid(i, mdtCustomAttribute)) == false)
                continue;

            // Check the type of the CustomAttribute. If it is not marked, then we don't need to move over the CustomAttributes.
            // This will only occur for compiler defined discardable CAs during linking.
            //
            if ( pMiniMdImport->GetFilterTable()->IsTokenMarked(tkType) == false)
                continue;
        
            if ( pCurTkMap->Find(tkParentImp, &pTokenRec) )
            {
                // If the From token type is different from the To token's type, we have optimized the ref to def. 
                // In this case, we are dropping the CA associated with the Ref tokens.
                //
                if (TypeFromToken(tkParentImp) == TypeFromToken(pTokenRec->m_tkTo))
                {

                    // If tkParentImp is a MemberRef and it is also mapped to a MemberRef in the merged scope with a MethodDef
                    // parent, then it is a MemberRef optimized to a MethodDef. We are keeping the MemberRef because it is a
                    // vararg call. So we can drop CAs on this MemberRef.
                    if (TypeFromToken(tkParentImp) == mdtMemberRef)
                    {
                        MemberRefRec    *pTempRec = pMiniMdEmit->getMemberRef(RidFromToken(pTokenRec->m_tkTo));
                        if (TypeFromToken(pMiniMdEmit->getClassOfMemberRef(pTempRec)) == mdtMethodDef)
                            continue;
                    }


                    if (! pCurTkMap->Find(tkType, &pTypeRec) )
                    {
                        _ASSERTE(!"CustomAttribute Type not found in output scope");
                        IfFailGo(META_E_BADMETADATA);
                    }

                    if ( pTokenRec->m_isDuplicate)
                    {
                        // Try to see if the custom value is there in the emit scope or not.
                        // If not, move it over still
                        hr = ImportHelper::FindCustomAttributeByToken(
                            pMiniMdEmit,
                            pTokenRec->m_tkTo,
                            pTypeRec->m_tkTo,
                            pValue,
                            cbBlob,
                            &cvEmit);
                
                        if ( hr == S_OK )
                        {
                            // found a match
                            // @FUTURE: more verification??
                            fDuplicate = true;
                        }
                        else
                        {
                            // We need to allow additive merge on TypeRef for CustomAttributes because compiler
                            // could build module but not assembly. They are hanging of Assembly level CAs on a bogus
                            // TypeRef. 
                            if (tkParentImp == TokenFromRid(1, mdtModule) || TypeFromToken(tkParentImp) == mdtTypeRef)
                            {
                                // clear the error
                                hr = NOERROR;

                                // custom value of module token!  Copy over the custom value
                                goto CopyCustomAttribute;
                            }
                            CheckContinuableErrorEx(META_E_MD_INCONSISTENCY, pImportData, TokenFromRid(i, mdtCustomAttribute));
                        }
                    }
                    else
                    {
CopyCustomAttribute:
                        if ((m_dwMergeFlags & DropMemberRefCAs) && TypeFromToken(pTokenRec->m_tkTo) == mdtMemberRef)
                        {
                            // CustomAttributes associated with MemberRef. If the parent of MemberRef is a MethodDef or FieldDef, drop
                            // the custom attribute.
                            MemberRefRec    *pMemberRefRec = pMiniMdEmit->getMemberRef(RidFromToken(pTokenRec->m_tkTo));
                            mdToken         mrParent = pMiniMdEmit->getClassOfMemberRef(pMemberRefRec);
                            if (TypeFromToken(mrParent) == mdtMethodDef || TypeFromToken(mrParent) == mdtFieldDef)
                            {
                                // Don't bother to copy over
                                continue;
                            }
                        }

                        // Parent is duplicated but the custom value is not. Still copy over the
                        // custom value.
                        fDuplicate = false;
                        IfNullGo( pRecEmit = pMiniMdEmit->AddCustomAttributeRecord((ULONG *)&cvEmit) );
                        cvEmit = TokenFromRid(cvEmit, mdtCustomAttribute);

                        // set the parent
                        IfFailGo( pMiniMdEmit->PutToken(TBL_CustomAttribute, CustomAttributeRec::COL_Parent, pRecEmit, pTokenRec->m_tkTo) );
                        // set the type
                        IfFailGo( pMiniMdEmit->PutToken(TBL_CustomAttribute, CustomAttributeRec::COL_Type, pRecEmit, pTypeRec->m_tkTo));

                        // move over the CustomAttribute blob value
                        pValue = pMiniMdImport->getValueOfCustomAttribute(pRecImport, &cbBlob);

                        IfFailGo( pMiniMdEmit->PutBlob(TBL_CustomAttribute, CustomAttributeRec::COL_Value, pRecEmit, pValue, cbBlob));
                        IfFailGo( pMiniMdEmit->AddCustomAttributesToHash(cvEmit) );
                    }
                    cvEmit = TokenFromRid(cvEmit, mdtCustomAttribute);
                    cvImp = TokenFromRid(i, mdtCustomAttribute);

                    // Record the token movement
                    IfFailGo( pCurTkMap->InsertNotFound(cvImp, pTokenRec->m_isDuplicate, cvEmit, &pTokenRec) );
                }
            }
            else
            {

                // either bad lookup map or bad metadata
                _ASSERTE(!"Bad state");
                IfFailGo( META_E_BADMETADATA );
            }
        }
    }

ErrExit:
    return hr;
}   // MergeCustomAttributes


//*******************************************************************************
// Helper to copy an InterfaceImpl record
//*******************************************************************************
HRESULT NEWMERGER::CopyInterfaceImpl(
    InterfaceImplRec    *pRecEmit,          // [IN] the emit record to fill
    MergeImportData     *pImportData,       // [IN] the importing context
    InterfaceImplRec    *pRecImp)           // [IN] the record to import
{
    HRESULT     hr;
    mdToken     tkParent;
    mdToken     tkInterface;
    CMiniMdRW   *pMiniMdEmit = GetMiniMdEmit();
    CMiniMdRW   *pMiniMdImp;
    MDTOKENMAP  *pCurTkMap;

    pMiniMdImp = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

    // set the current MDTokenMap
    pCurTkMap = pImportData->m_pMDTokenMap;

    tkParent = pMiniMdImp->getClassOfInterfaceImpl(pRecImp);
    tkInterface = pMiniMdImp->getInterfaceOfInterfaceImpl(pRecImp);

    IfFailGo( pCurTkMap->Remap(tkParent, &tkParent) );
    IfFailGo( pCurTkMap->Remap(tkInterface, &tkInterface) );

    IfFailGo( pMiniMdEmit->PutToken( TBL_InterfaceImpl, InterfaceImplRec::COL_Class, pRecEmit, tkParent) );
    IfFailGo( pMiniMdEmit->PutToken( TBL_InterfaceImpl, InterfaceImplRec::COL_Interface, pRecEmit, tkInterface) );

ErrExit:
    return hr;
}   // CopyInterfaceImpl


//*****************************************************************************
// Merge Assembly table
//*****************************************************************************
HRESULT NEWMERGER::MergeAssembly()
{
    HRESULT     hr = NOERROR;
    AssemblyRec *pRecImport = NULL;
    AssemblyRec *pRecEmit = NULL;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    LPCUTF8     szTmp;
    const BYTE  *pbTmp;
    ULONG       cbTmp;
    ULONG       iRecord;
    TOKENREC    *pTokenRec;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        if (!pMiniMdImport->getCountAssemblys())
            goto ErrExit;       // There is no Assembly in the import scope to merge.

        // Copy the Assembly map record to the Emit scope and send a token remap notifcation
        // to the client.  No duplicate checking needed since the Assembly can be present in
        // only one scope and there can be atmost one entry.
        pMiniMdEmit->PreUpdate();

        pRecImport = pMiniMdImport->getAssembly(1);
        IfNullGo( pRecEmit = pMiniMdEmit->AddAssemblyRecord(&iRecord));

        pRecEmit->m_HashAlgId = pRecImport->m_HashAlgId;
        pRecEmit->m_MajorVersion = pRecImport->m_MajorVersion;
        pRecEmit->m_MinorVersion = pRecImport->m_MinorVersion;
        pRecEmit->m_BuildNumber = pRecImport->m_BuildNumber;
        pRecEmit->m_RevisionNumber = pRecImport->m_RevisionNumber;
        pRecEmit->m_Flags = pRecImport->m_Flags;
    
        pbTmp = pMiniMdImport->getPublicKeyOfAssembly(pRecImport, &cbTmp);
        IfFailGo(pMiniMdEmit->PutBlob(TBL_Assembly, AssemblyRec::COL_PublicKey, pRecEmit,
                                    pbTmp, cbTmp));

        szTmp = pMiniMdImport->getNameOfAssembly(pRecImport);
        IfFailGo(pMiniMdEmit->PutString(TBL_Assembly, AssemblyRec::COL_Name, pRecEmit, szTmp));

        szTmp = pMiniMdImport->getLocaleOfAssembly(pRecImport);
        IfFailGo(pMiniMdEmit->PutString(TBL_Assembly, AssemblyRec::COL_Locale, pRecEmit, szTmp));

        // record the token movement.
        IfFailGo(pCurTkMap->InsertNotFound(
            TokenFromRid(1, mdtAssembly),
            false,
            TokenFromRid(iRecord, mdtAssembly),
            &pTokenRec));
    }
ErrExit:
    return hr;
}   // MergeAssembly




//*****************************************************************************
// Merge File table
//*****************************************************************************
HRESULT NEWMERGER::MergeFiles()
{
    HRESULT     hr = NOERROR;
    FileRec     *pRecImport = NULL;
    FileRec     *pRecEmit = NULL;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    LPCUTF8     szTmp;
    const void  *pbTmp;
    ULONG       cbTmp;
    ULONG       iCount;
    ULONG       i;
    ULONG       iRecord;
    TOKENREC    *pTokenRec;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountFiles();

        // Loop through all File records and copy them to the Emit scope.
        // Since there can only be one File table in all the scopes combined,
        // there isn't any duplicate checking that needs to be done.
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            pRecImport = pMiniMdImport->getFile(i);
            IfNullGo( pRecEmit = pMiniMdEmit->AddFileRecord(&iRecord));

            pRecEmit->m_Flags = pRecImport->m_Flags;

            szTmp = pMiniMdImport->getNameOfFile(pRecImport);
            IfFailGo(pMiniMdEmit->PutString(TBL_File, FileRec::COL_Name, pRecEmit, szTmp));

            pbTmp = pMiniMdImport->getHashValueOfFile(pRecImport, &cbTmp);
            IfFailGo(pMiniMdEmit->PutBlob(TBL_File, FileRec::COL_HashValue, pRecEmit, pbTmp, cbTmp));

            // record the token movement.
            IfFailGo(pCurTkMap->InsertNotFound(
                TokenFromRid(i, mdtFile),
                false,
                TokenFromRid(iRecord, mdtFile),
                &pTokenRec));
        }
    }
ErrExit:
    return hr;
}   // MergeFiles


//*****************************************************************************
// Merge ExportedType table
//*****************************************************************************
HRESULT NEWMERGER::MergeExportedTypes()
{
    HRESULT     hr = NOERROR;
    ExportedTypeRec  *pRecImport = NULL;
    ExportedTypeRec  *pRecEmit = NULL;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    LPCUTF8     szTmp;
    mdToken     tkTmp;
    ULONG       iCount;
    ULONG       i;
    ULONG       iRecord;
    TOKENREC    *pTokenRec;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountExportedTypes();

        // Loop through all ExportedType records and copy them to the Emit scope.
        // Since there can only be one ExportedType table in all the scopes combined,
        // there isn't any duplicate checking that needs to be done.
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            pRecImport = pMiniMdImport->getExportedType(i);
            IfNullGo( pRecEmit = pMiniMdEmit->AddExportedTypeRecord(&iRecord));

            pRecEmit->m_Flags = pRecImport->m_Flags;
            pRecEmit->m_TypeDefId = pRecImport->m_TypeDefId;

            szTmp = pMiniMdImport->getTypeNameOfExportedType(pRecImport);
            IfFailGo(pMiniMdEmit->PutString(TBL_ExportedType, ExportedTypeRec::COL_TypeName, pRecEmit, szTmp));

            szTmp = pMiniMdImport->getTypeNamespaceOfExportedType(pRecImport);
            IfFailGo(pMiniMdEmit->PutString(TBL_ExportedType, ExportedTypeRec::COL_TypeNamespace, pRecEmit, szTmp));

            tkTmp = pMiniMdImport->getImplementationOfExportedType(pRecImport);
            IfFailGo(pCurTkMap->Remap(tkTmp, &tkTmp));
            IfFailGo(pMiniMdEmit->PutToken(TBL_ExportedType, ExportedTypeRec::COL_Implementation,
                                        pRecEmit, tkTmp));


            // record the token movement.
            IfFailGo(pCurTkMap->InsertNotFound(
                TokenFromRid(i, mdtExportedType),
                false,
                TokenFromRid(iRecord, mdtExportedType),
                &pTokenRec));
        }
    }
ErrExit:
    return hr;
}   // MergeExportedTypes


//*****************************************************************************
// Merge ManifestResource table
//*****************************************************************************
HRESULT NEWMERGER::MergeManifestResources()
{
    HRESULT     hr = NOERROR;
    ManifestResourceRec *pRecImport = NULL;
    ManifestResourceRec *pRecEmit = NULL;
    CMiniMdRW   *pMiniMdImport;
    CMiniMdRW   *pMiniMdEmit;
    LPCUTF8     szTmp;
    mdToken     tkTmp;
    ULONG       iCount;
    ULONG       i;
    ULONG       iRecord;
    TOKENREC    *pTokenRec;

    MergeImportData *pImportData;
    MDTOKENMAP      *pCurTkMap;

    pMiniMdEmit = GetMiniMdEmit();
    
    for (pImportData = m_pImportDataList; pImportData != NULL; pImportData = pImportData->m_pNextImportData)
    {
        // for each import scope
        pMiniMdImport = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);

        // set the current MDTokenMap
        pCurTkMap = pImportData->m_pMDTokenMap;
        iCount = pMiniMdImport->getCountManifestResources();

        // Loop through all ManifestResource records and copy them to the Emit scope.
        // Since there can only be one ManifestResource table in all the scopes combined,
        // there isn't any duplicate checking that needs to be done.
        for (i = 1; i <= iCount; i++)
        {
            pMiniMdEmit->PreUpdate();

            pRecImport = pMiniMdImport->getManifestResource(i);
            IfNullGo( pRecEmit = pMiniMdEmit->AddManifestResourceRecord(&iRecord));

            pRecEmit->m_Offset = pRecImport->m_Offset;
            pRecEmit->m_Flags = pRecImport->m_Flags;

            szTmp = pMiniMdImport->getNameOfManifestResource(pRecImport);
            IfFailGo(pMiniMdEmit->PutString(TBL_ManifestResource, ManifestResourceRec::COL_Name,
                                        pRecEmit, szTmp));

            tkTmp = pMiniMdImport->getImplementationOfManifestResource(pRecImport);
            IfFailGo(pCurTkMap->Remap(tkTmp, &tkTmp));
            IfFailGo(pMiniMdEmit->PutToken(TBL_ManifestResource, ManifestResourceRec::COL_Implementation,
                                        pRecEmit, tkTmp));

            // record the token movement.
            IfFailGo(pCurTkMap->InsertNotFound(
                TokenFromRid(i, mdtManifestResource),
                false,
                TokenFromRid(iRecord, mdtManifestResource),
                &pTokenRec));
        }
    }
ErrExit:
    return hr;
}   // MergeManifestResources





//*****************************************************************************
// Error handling. Call back to host to see what they want to do!
//*****************************************************************************
HRESULT NEWMERGER::OnError(
    HRESULT     hrIn,
    MergeImportData *pImportData,
    mdToken     token)
{
    // This function does a QI and a Release on every call.  However, it should be 
    //  called very infrequently, and lets the scope just keep a generic handler.
    IMetaDataError  *pIErr = NULL;
    IUnknown        *pHandler = pImportData->m_pHandler;
    CMiniMdRW       *pMiniMd = &(pImportData->m_pRegMetaImport->m_pStgdb->m_MiniMd);
    CQuickArray<WCHAR> rName;           // Name of the TypeDef in unicode.
    LPCUTF8         szTypeName;
    LPCUTF8         szNSName;
    TypeDefRec      *pTypeRec;
    int             iLen;               // Length of a name.
    mdToken         tkParent;
    HRESULT         hr = NOERROR;

    if (pHandler && pHandler->QueryInterface(IID_IMetaDataError, (void**)&pIErr)==S_OK)
    {
        switch (hrIn)
        {
            case META_E_METHD_NOT_FOUND:
            case META_E_METHDIMPL_INCONSISTENT:
            {
                // get the type name and method name
                LPCUTF8     szMethodName;
                MethodRec   *pMethodRec;

                _ASSERTE(TypeFromToken(token) == mdtMethodDef);
                pMethodRec = pMiniMd->getMethod(RidFromToken(token));
                szMethodName = pMiniMd->getNameOfMethod(pMethodRec);

                IfFailGo( pMiniMd->FindParentOfMethodHelper(token, &tkParent) );
                pTypeRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
                szTypeName = pMiniMd->getNameOfTypeDef(pTypeRec);
                szNSName = pMiniMd->getNamespaceOfTypeDef(pTypeRec);

                iLen = ns::GetFullLength(szNSName, szTypeName);
                IfFailGo(rName.ReSize(iLen+1));
                ns::MakePath(rName.Ptr(), iLen+1, szNSName, szTypeName);
                MAKE_WIDEPTR_FROMUTF8(wzMethodName, szMethodName);

                PostError(hrIn, (LPWSTR) rName.Ptr(), wzMethodName, token);
                break;
            }
            case META_E_FIELD_NOT_FOUND:
            {
                // get the type name and method name
                LPCUTF8     szFieldName;
                FieldRec   *pFieldRec;

                _ASSERTE(TypeFromToken(token) == mdtFieldDef);
                pFieldRec = pMiniMd->getField(RidFromToken(token));
                szFieldName = pMiniMd->getNameOfField(pFieldRec);

                IfFailGo( pMiniMd->FindParentOfFieldHelper(token, &tkParent) );
                pTypeRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
                szTypeName = pMiniMd->getNameOfTypeDef(pTypeRec);
                szNSName = pMiniMd->getNamespaceOfTypeDef(pTypeRec);

                iLen = ns::GetFullLength(szNSName, szTypeName);
                IfFailGo(rName.ReSize(iLen+1));
                ns::MakePath(rName.Ptr(), iLen+1, szNSName, szTypeName);
                MAKE_WIDEPTR_FROMUTF8(wzFieldName, szFieldName);

                PostError(hrIn, (LPWSTR) rName.Ptr(), wzFieldName, token);
                break;
            }
            case META_E_EVENT_NOT_FOUND:
            {
                // get the type name and Event name
                LPCUTF8     szEventName;
                EventRec   *pEventRec;

                _ASSERTE(TypeFromToken(token) == mdtEvent);
                pEventRec = pMiniMd->getEvent(RidFromToken(token));
                szEventName = pMiniMd->getNameOfEvent(pEventRec);

                IfFailGo( pMiniMd->FindParentOfEventHelper(token, &tkParent) );
                pTypeRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
                szTypeName = pMiniMd->getNameOfTypeDef(pTypeRec);
                szNSName = pMiniMd->getNamespaceOfTypeDef(pTypeRec);

                iLen = ns::GetFullLength(szNSName, szTypeName);
                IfFailGo(rName.ReSize(iLen+1));
                ns::MakePath(rName.Ptr(), iLen+1, szNSName, szTypeName);
                MAKE_WIDEPTR_FROMUTF8(wzEventName, szEventName);

                PostError(hrIn, (LPWSTR) rName.Ptr(), wzEventName, token);
                break;
            }
            case META_E_PROP_NOT_FOUND:
            {
                // get the type name and method name
                LPCUTF8     szPropertyName;
                PropertyRec   *pPropertyRec;

                _ASSERTE(TypeFromToken(token) == mdtProperty);
                pPropertyRec = pMiniMd->getProperty(RidFromToken(token));
                szPropertyName = pMiniMd->getNameOfProperty(pPropertyRec);

                IfFailGo( pMiniMd->FindParentOfPropertyHelper(token, &tkParent) );
                pTypeRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
                szTypeName = pMiniMd->getNameOfTypeDef(pTypeRec);
                szNSName = pMiniMd->getNamespaceOfTypeDef(pTypeRec);

                iLen = ns::GetFullLength(szNSName, szTypeName);
                IfFailGo(rName.ReSize(iLen+1));
                ns::MakePath(rName.Ptr(), iLen+1, szNSName, szTypeName);
                MAKE_WIDEPTR_FROMUTF8(wzPropertyName, szPropertyName);

                PostError(hrIn, (LPWSTR) rName.Ptr(), wzPropertyName, token);
                break;
            }
            case META_S_PARAM_MISMATCH:
            {
                LPCUTF8     szMethodName;
                MethodRec   *pMethodRec;
                mdToken     tkMethod;

                _ASSERTE(TypeFromToken(token) == mdtParamDef);
                IfFailGo( pMiniMd->FindParentOfParamHelper(token, &tkMethod) );
                pMethodRec = pMiniMd->getMethod(RidFromToken(tkMethod));
                szMethodName = pMiniMd->getNameOfMethod(pMethodRec);

                IfFailGo( pMiniMd->FindParentOfMethodHelper(token, &tkParent) );
                pTypeRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
                szTypeName = pMiniMd->getNameOfTypeDef(pTypeRec);
                szNSName = pMiniMd->getNamespaceOfTypeDef(pTypeRec);

                iLen = ns::GetFullLength(szNSName, szTypeName);
                IfFailGo(rName.ReSize(iLen+1));
                ns::MakePath(rName.Ptr(), iLen+1, szNSName, szTypeName);
                MAKE_WIDEPTR_FROMUTF8(wzMethodName, szMethodName);

                // use the error hresult so that we can post the correct error.
                PostError(META_E_PARAM_MISMATCH, wzMethodName, (LPWSTR) rName.Ptr(), token);
                break;
            }
            case META_E_INTFCEIMPL_NOT_FOUND:
            {

                _ASSERTE(TypeFromToken(token) == mdtInterfaceImpl);
                tkParent = pMiniMd->getClassOfInterfaceImpl(pMiniMd->getInterfaceImpl(RidFromToken(token)));
                pTypeRec = pMiniMd->getTypeDef(RidFromToken(tkParent));
                szTypeName = pMiniMd->getNameOfTypeDef(pTypeRec);
                szNSName = pMiniMd->getNamespaceOfTypeDef(pTypeRec);

                iLen = ns::GetFullLength(szNSName, szTypeName);
                IfFailGo(rName.ReSize(iLen+1));
                ns::MakePath(rName.Ptr(), iLen+1, szNSName, szTypeName);

                PostError(hrIn, (LPWSTR) rName.Ptr(), token);
                break;
            }
            case META_E_CLASS_LAYOUT_INCONSISTENT:
            {
                // get the type name and method name

                _ASSERTE(TypeFromToken(token) == mdtTypeDef);
                pTypeRec = pMiniMd->getTypeDef(RidFromToken(token));
                szTypeName = pMiniMd->getNameOfTypeDef(pTypeRec);
                szNSName = pMiniMd->getNamespaceOfTypeDef(pTypeRec);

                iLen = ns::GetFullLength(szNSName, szTypeName);
                IfFailGo(rName.ReSize(iLen+1));
                ns::MakePath(rName.Ptr(), iLen+1, szNSName, szTypeName);

                PostError(hrIn, (LPWSTR) rName.Ptr(), token);
                break;
            }
            default:
            {
                PostError(hrIn, token);
                break;
            }
        }
        hr = pIErr->OnError(hrIn, token);
    }
    else
        hr = S_FALSE;
ErrExit:
    if (pIErr)
        pIErr->Release();
    return (hr);
} // HRESULT NEWMERGER::OnError()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\mdutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDUtil.cpp
//
// contains utility code to MD directory
//
//*****************************************************************************
#include "stdafx.h"
#include "metadata.h"
#include "MDUtil.h"
#include "RegMeta.h"
#include "Disp.h"
#include "MDCommon.h"
#include "ImportHelper.h"


// Enable these three lines to turn off thread safety
#ifdef MD_THREADSAFE
 #undef MD_THREADSAFE
#endif
// Enable this line to turn on thread safety                            
#define MD_THREADSAFE 1

#include <RwUtil.h>

// global variable to keep track all loaded modules
LOADEDMODULES	*g_LoadedModules = NULL;
UTSemReadWrite *LOADEDMODULES::m_pSemReadWrite = NULL;

//*****************************************************************************
// Add a RegMeta pointer to the loaded module list
//*****************************************************************************
HRESULT LOADEDMODULES::AddModuleToLoadedList(RegMeta *pRegMeta)
{
	HRESULT		hr = NOERROR;
	RegMeta		**ppRegMeta;

    LOCKWRITE();
    
	// create the dynamic array if it is not created yet.
	if (g_LoadedModules == NULL)
	{
		g_LoadedModules = new LOADEDMODULES;
        IfNullGo(g_LoadedModules);
	}

	ppRegMeta = g_LoadedModules->Append();
    IfNullGo(ppRegMeta);
	
	*ppRegMeta = pRegMeta;
    
ErrExit:    
    return hr;
}	// LOADEDMODULES::AddModuleToLoadedList

//*****************************************************************************
// Remove a RegMeta pointer from the loaded module list
//*****************************************************************************
BOOL LOADEDMODULES::RemoveModuleFromLoadedList(RegMeta *pRegMeta)
{
	int			count;
	int			index;
    BOOL        bRemoved = FALSE;
    ULONG       cRef;
    
    LOCKWRITE();
    
    // The cache is locked for write, so no other thread can obtain the RegMeta
    //  from the cache.  See if some other thread has a ref-count.
    cRef = pRegMeta->GetRefCount();
    
    // If some other thread has a ref-count, don't remove from the cache.
    if (cRef > 0)
        return FALSE;
    
	// If there is no loaded modules, don't bother
	if (g_LoadedModules == NULL)
	{
		return TRUE; // Can't be cached, same as if removed by this thread.
	}

	// loop through each loaded modules
	count = g_LoadedModules->Count();
	for (index = 0; index < count; index++)
	{
		if ((*g_LoadedModules)[index] == pRegMeta)
		{
			// found a match to remove
			g_LoadedModules->Delete(index);
            bRemoved = TRUE;
			break;
		}
	}

	// If no more loaded modules, delete the dynamic array
	if (g_LoadedModules->Count() == 0)
	{
		delete g_LoadedModules;
		g_LoadedModules = NULL;
	}
    
    return bRemoved;
}	// LOADEDMODULES::RemoveModuleFromLoadedList


//*****************************************************************************
// Remove a RegMeta pointer from the loaded module list
//*****************************************************************************
HRESULT LOADEDMODULES::ResolveTypeRefWithLoadedModules(
	mdTypeRef   tr,			            // [IN] TypeRef to be resolved.
	IMetaModelCommon *pCommon,  		// [IN] scope in which the typeref is defined.
	REFIID		riid,					// [IN] iid for the return interface
	IUnknown	**ppIScope,				// [OUT] return interface
	mdTypeDef	*ptd)					// [OUT] typedef corresponding the typeref
{
	HRESULT		hr = NOERROR;
	RegMeta		*pRegMeta;
    CQuickArray<mdTypeRef> cqaNesters;
    CQuickArray<LPCUTF8> cqaNesterNamespaces;
    CQuickArray<LPCUTF8> cqaNesterNames;
	int			count;
	int			index;

	if (g_LoadedModules == NULL)
	{
		// No loaded module!
		_ASSERTE(!"Bad state!");
		return E_FAIL;
	}

    LOCKREAD();
    
    // Get the Nesting hierarchy.
    IfFailGo(ImportHelper::GetNesterHierarchy(pCommon, tr, cqaNesters,
                                cqaNesterNamespaces, cqaNesterNames));

    count = g_LoadedModules->Count();
	for (index = 0; index < count; index++)
	{
		pRegMeta = (*g_LoadedModules)[index];

        hr = ImportHelper::FindNestedTypeDef(
                                pRegMeta->GetMiniMd(),
                                cqaNesterNamespaces,
                                cqaNesterNames,
                                mdTokenNil,
                                ptd);
		if (SUCCEEDED(hr))
		{
            // found a loaded module containing the TypeDef.
            hr = pRegMeta->QueryInterface(riid, (void **)ppIScope);			
            break;
        }
        else if (hr != CLDB_E_RECORD_NOTFOUND)
            IfFailGo(hr);
	}
	if (FAILED(hr))
	{
		// cannot find the match!
		hr = E_FAIL;
	}
ErrExit:
	return hr;
}	// LOADEDMODULES::ResolveTypeRefWithLoadedModules



//*****************************************************************************
// This is a routine to try to find a class implementation given its fully
// qualified name by using the CORPATH environment variable.  CORPATH is a list
// of directories (like PATH).  Before checking CORPATH, this checks the current
// directory, then the directory that the exe lives in.  The search is
// performed by parsing off one element at a time from the class name,
// appending it to the directory and looking for a subdirectory or image with
// that name.  If the subdirectory exists, it drills down into that subdirectory
// and tries the next element of the class name.  When it finally bottoms out
// but can't find the image it takes the rest of the fully qualified class name
// and appends them with intervening '.'s trying to find a matching DLL.
// Example:
//
// CORPATH=c:\bin;c:\prog
// classname = namespace.class
//
// checks the following things in order:
// c:\bin\namespace, (if <-exists) c:\bin\namespace\class.dll,
//		c:\bin\namespace.dll, c:\bin\namespace.class.dll
// c:\prog\namespace, (if <-exists) c:\prog\namespace\class.dll,
//		c:\prog\namespace.dll, c:\prog\namespace.class.dll
//*****************************************************************************
HRESULT CORPATHService::GetClassFromCORPath(
	LPWSTR		wzClassname,			// [IN] fully qualified class name
    mdTypeRef   tr,                     // [IN] TypeRef to be resolved.
    IMetaModelCommon *pCommon,          // [IN] Scope in which the TypeRef is defined.
	REFIID		riid,                   // [IN] Interface type to be returned.
	IUnknown	**ppIScope,             // [OUT] Scope in which the TypeRef resolves.
	mdTypeDef	*ptd)					// [OUT] typedef corresponding the typeref
{
    WCHAR		rcCorPath[1024];        // The CORPATH environment variable.
    LPWSTR		szCorPath = rcCorPath;  // Used to parse CORPATH.
    int			iLen;                   // Length of the directory.
    WCHAR		rcCorDir[_MAX_PATH];    // Buffer for the directory.
    WCHAR		*temp;                  // Used as a parsing temp.
	WCHAR		*szSemiCol;

    // Get the CORPATH environment variable.
    if (WszGetEnvironmentVariable(L"CORPATH", rcCorPath,
                                  sizeof(rcCorPath) / sizeof(WCHAR)))
	{
        // Force nul termination.
        rcCorPath[lengthof(rcCorPath)-1] = 0;

		// Try each directory in the path.
		for(;*szCorPath != L'\0';)
		{
			// Get the next directory off the path.
			if (szSemiCol = wcschr(szCorPath, L';'))
			{
				temp = szCorPath;
				*szSemiCol = L'\0';
				szCorPath = szSemiCol + 1;
			}
			else 
			{
				temp = szCorPath;
				szCorPath += wcslen(temp);
			}
			if ((iLen = (int)wcslen(temp)) >= _MAX_PATH)
				continue;
			wcscpy(rcCorDir, temp);

			// Check if we can find the class in the directory.
			if (CORPATHService::GetClassFromDir(wzClassname, rcCorDir, iLen, tr, pCommon, riid, ppIScope, ptd) == S_OK)
				return (NOERROR);
		}
	}

	//These should go before the path search, but it will cause test
	// some headaches right now, so we'll give them a little time to transition.

	// Try the current directory first.
	if ((iLen = WszGetCurrentDirectory(_MAX_PATH, rcCorDir)) > 0 &&
		CORPATHService::GetClassFromDir(wzClassname, rcCorDir, iLen, tr, pCommon, riid, ppIScope, ptd) == S_OK)
	{
		return (S_OK);
	}

	// Try the app directory next.
	if ((iLen = WszGetModuleFileName(NULL, rcCorDir, _MAX_PATH)) > 0)
	{
		// Back up to the last backslash.
		while (--iLen >= 0 && rcCorDir[iLen] != L'\\');
		if (iLen > 0 && 
			CORPATHService::GetClassFromDir(
					wzClassname, 
					rcCorDir, 
					iLen, 
					tr, 
					pCommon, 
					riid, 
					ppIScope, 
					ptd) == S_OK)
		{
			return (S_OK);
		}
	}

    // Couldn't find the class.
    return (S_FALSE);
}   // CORPATHService::GetClassFromCORPath

//*****************************************************************************
// This is used in conjunction with GetClassFromCORPath.  See it for details
// of the algorithm.  One thing to note is that the dir passed here must be
// _MAX_PATH size and will be written to by this routine.  This routine will
// frequently leave junk at the end of the directory string and dir[iLen] may
// not be '\0' on return.
//*****************************************************************************
HRESULT CORPATHService::GetClassFromDir(
	LPWSTR		wzClassname,			// Fully qualified class name.
	LPWSTR		dir,					// Directory to try.
	int			iLen,					// Length of the directory.
    mdTypeRef   tr,                     // TypeRef to resolve.
    IMetaModelCommon *pCommon,          // Scope in which the TypeRef is defined.
	REFIID		riid, 
	IUnknown	**ppIScope,
	mdTypeDef	*ptd)					// [OUT] typedef
{
    WCHAR	*temp;						// Used as a parsing temp.
	int		iTmp;
	bool	bContinue;					// Flag to check if the for loop should end.
	LPWSTR	wzSaveClassname;			// Saved offset into the class name string.
	int		iSaveLen;					// Saved length of the dir string.
	

	// Process the class name appending each segment of the name to the
	// directory until we find a DLL.
    for(;;)
    {
		bContinue = false;
        if ((temp = wcschr(wzClassname, NAMESPACE_SEPARATOR_WCHAR)) != NULL)
        {
            // Check for buffer overflow.
            if (iLen + 5 + (int) (temp - wzClassname) >= _MAX_PATH)
                break;

            // Append the next segment from the class spec to the directory.
            dir[iLen++] = L'\\';
            wcsncpy(dir+iLen, wzClassname, (int) (temp - wzClassname));
            iLen += (int) (temp - wzClassname);
            dir[iLen] = L'\0';
            wzClassname = temp+1;

            // Check if a directory by this name exists.
            DWORD iAttrs = WszGetFileAttributes(dir);
            if (iAttrs != 0xffffffff && (iAttrs & FILE_ATTRIBUTE_DIRECTORY))
            {
                // Next element in the class spec.
                bContinue = true;
				iSaveLen = iLen;
				wzSaveClassname = wzClassname;
            }
        }
        else
        {
            // Check for buffer overflow.
			iTmp = (int)wcslen(wzClassname);
            if (iLen + 5 + iTmp >= _MAX_PATH)
				break;
            dir[iLen++] = L'\\';
            wcscpy(dir+iLen, wzClassname);

			// Advance past the class name.
			iLen += iTmp;
			wzClassname += iTmp;
        }

        // Try to load the image.
        wcscpy(dir+iLen, L".dll");

        // OpenScope given the dll name and make sure that the class is defined in the module.
        if ( SUCCEEDED( CORPATHService::FindTypeDef(dir, tr, pCommon, riid, ppIScope, ptd) ) )
		{
			return (S_OK);
		}

		// If we didn't find the dll, try some more.
		while (*wzClassname != L'\0')
		{
			// Find the length of the next class name element.
		    if ((temp = wcschr(wzClassname, NAMESPACE_SEPARATOR_WCHAR)) == NULL)
				temp = wzClassname + wcslen(wzClassname);

			// Check for buffer overflow.
			if (iLen + 5 + (int) (temp - wzClassname) >= _MAX_PATH)
				break;

			// Tack on ".element.dll"
			dir[iLen++] = L'.';
			wcsncpy(dir+iLen, wzClassname, (int) (temp - wzClassname));
			iLen += (int) (temp - wzClassname);

			// Try to load the image.
			wcscpy(dir+iLen, L".dll");

			// OpenScope given the dll name and make sure that the class is defined in the module.
			if ( SUCCEEDED( CORPATHService::FindTypeDef(dir, tr, pCommon, riid, ppIScope, ptd) ) )
			{
				return (S_OK);
			}

			// Advance to the next class name element.
            wzClassname = temp;
			if (*wzClassname != '\0')
				++wzClassname;
        }
		if (bContinue)
		{
			iLen = iSaveLen;
			wzClassname = wzSaveClassname;
		}
		else
			break;
    }
    return (S_FALSE);
}   // CORPATHService::GetClassFromDir



//*************************************************************
//
// Open the file with anme wzModule and check to see if there is a type 
// with namespace/class of wzNamespace/wzType. If so, return the RegMeta
// corresponding to the file and the mdTypeDef of the typedef
//
//*************************************************************
HRESULT CORPATHService::FindTypeDef(
	LPWSTR		wzModule,				// name of the module that we are going to open
    mdTypeRef   tr,                     // TypeRef to resolve.
    IMetaModelCommon *pCommon,          // Scope in which the TypeRef is defined.
	REFIID		riid, 
	IUnknown	**ppIScope,
	mdTypeDef	*ptd )					// [OUT] the type that we resolve to
{
	HRESULT		hr = NOERROR;
	Disp		*pDisp = NULL;
	IMetaDataImport *pImport = NULL;
    CQuickArray<mdTypeRef> cqaNesters;
    CQuickArray<LPCUTF8> cqaNesterNamespaces;
    CQuickArray<LPCUTF8> cqaNesterNames;
    RegMeta     *pRegMeta;

	_ASSERTE(ppIScope && ptd);

	*ppIScope = NULL;

	pDisp = new Disp;

	if ( pDisp == NULL )
		IfFailGo( E_OUTOFMEMORY );

    IfFailGo( pDisp->OpenScope(wzModule, 0, IID_IMetaDataImport, (IUnknown	**)&pImport) );
    pRegMeta = static_cast<RegMeta *>(pImport);

    // Get the Nesting hierarchy.
    IfFailGo(ImportHelper::GetNesterHierarchy(pCommon, tr, cqaNesters,
                                cqaNesterNamespaces, cqaNesterNames));

    hr = ImportHelper::FindNestedTypeDef(
                                pRegMeta->GetMiniMd(),
                                cqaNesterNamespaces,
                                cqaNesterNames,
                                mdTokenNil,
                                ptd);
    if (SUCCEEDED(hr))
	    *ppIScope = pImport;
    else if (hr != CLDB_E_RECORD_NOTFOUND)
        IfFailGo(hr);

ErrExit:
	if (pDisp)
		delete pDisp;

	if ( FAILED(hr) )
	{
		if ( pImport )
			pImport->Release();
	}
	return hr;
}   // CORPATHService::FindTypeDef



//*******************************************************************************
//
// Determine the blob size base of the ELEMENT_TYPE_* associated with the blob.
// This cannot be a table lookup because ELEMENT_TYPE_STRING is an unicode string.
// The size of the blob is determined by calling wcsstr of the string + 1.
//
//*******************************************************************************
ULONG _GetSizeOfConstantBlob(
	DWORD		dwCPlusTypeFlag,			// ELEMENT_TYPE_*
	void		*pValue,					// BLOB value
	ULONG		cchString)					// String length in wide chars, or -1 for auto.
{
	ULONG		ulSize = 0;

	switch (dwCPlusTypeFlag)
	{
    case ELEMENT_TYPE_BOOLEAN:
		ulSize = sizeof(BYTE);
		break;
    case ELEMENT_TYPE_I1:
    case ELEMENT_TYPE_U1:
		ulSize = sizeof(BYTE);
		break;
    case ELEMENT_TYPE_CHAR:
    case ELEMENT_TYPE_I2:
    case ELEMENT_TYPE_U2:
		ulSize = sizeof(SHORT);
		break;
    case ELEMENT_TYPE_I4:
    case ELEMENT_TYPE_U4:
    case ELEMENT_TYPE_R4:
		ulSize = sizeof(LONG);
		break;
		
    case ELEMENT_TYPE_I8:
    case ELEMENT_TYPE_U8:
    case ELEMENT_TYPE_R8:
		ulSize = sizeof(DOUBLE);
		break;

    case ELEMENT_TYPE_STRING:
		if (pValue == 0)
			ulSize = 0;
		else
		if (cchString != -1)
			ulSize = cchString * sizeof(WCHAR);
		else
			ulSize = (ULONG)(sizeof(WCHAR) * wcslen((LPWSTR)pValue));
		break;

	case ELEMENT_TYPE_CLASS:
		ulSize = sizeof(IUnknown *);
		break;
	default:
		_ASSERTE(!"Not a valid type to specify default value!");
		break;
	}
	return ulSize;
}   // _GetSizeOfConstantBlob
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\tokenmapper.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// TokenMapper.cpp
//
// This helper class tracks mapped tokens from their old value to the new value
// which can happen when the data is optimized on save.
//
//*****************************************************************************
#include "stdafx.h"
#include <cor.h>
#include "TokenMapper.h"


#define INDEX_OF_TYPE(type) ((type) >> 24)
#define INDEX_FROM_TYPE(type) case INDEX_OF_TYPE(mdt ## type): return (tkix ## type)

//*****************************************************************************
// At this point, only a select set of token values are stored for remap.
// If others should become required, this needs to get updated.
//*****************************************************************************
int TokenMapper::IndexForType(mdToken tk)
{
	switch (INDEX_OF_TYPE(tk))
	{
		INDEX_FROM_TYPE(MethodDef);
		INDEX_FROM_TYPE(MemberRef);
		INDEX_FROM_TYPE(FieldDef);
	}
	
	return (-1);
}


TOKENMAP *TokenMapper::GetMapForType(mdToken tkType)
{
	_ASSERTE(IndexForType(tkType) < GetMaxMapSize());
	return (&m_rgMap[IndexForType(tkType)]);
}


//*****************************************************************************
// Called by the meta data engine when a token is remapped to a new location.
// This value is recorded in the m_rgMap array based on type and rid of the
// from token value.
//*****************************************************************************
HRESULT TokenMapper::Map(
	mdToken		tkFrom, 
	mdToken		tkTo)
{
	// Check for a type we don't care about.
	if (IndexForType(tkFrom) == -1)
		return (S_OK);

	_ASSERTE(IndexForType(tkFrom) < GetMaxMapSize());
	_ASSERTE(IndexForType(tkTo) < GetMaxMapSize());

	mdToken *pToken;
	ULONG ridFrom = RidFromToken(tkFrom);
	TOKENMAP *pMap = GetMapForType(tkFrom);

	// If there isn't enough entries, fill out array up to the count
	// and mark the token to nil so we know there is no valid data yet.
	if ((ULONG) pMap->Count() <= ridFrom)
	{
		for (int i=ridFrom - pMap->Count() + 1;  i;  i--) 
		{
			pToken = pMap->Append();
			if (!pToken)
				break;
			*pToken = mdTokenNil;
		}
		_ASSERTE(pMap->Get(ridFrom) == pToken);
	}
	else
		pToken = pMap->Get(ridFrom);
	if (!pToken)
		return (OutOfMemory());
	
	*pToken = tkTo;
	return (S_OK);
}


//*****************************************************************************
// Check the given token to see if it has moved to a new location.  If so,
// return true and give back the new token.
//*****************************************************************************
int TokenMapper::HasTokenMoved(
	mdToken		tkFrom,
	mdToken		&tkTo)
{
	mdToken		tk;

	if (IndexForType(tkFrom) == -1)
		return (-1);

	TOKENMAP *pMap = GetMapForType(tkFrom);

	// Assume nothing moves.
	tkTo = tkFrom;

	// If the array is smaller than the index, can't have moved.
	if ((ULONG) pMap->Count() <= RidFromToken(tkFrom))
		return (false);

	// If the entry is set to 0, then nothing there.
	tk = *pMap->Get(RidFromToken(tkFrom));
	if (tk == mdTokenNil)
		return (false);
	
	// Had to move to a new location, return that new location.
	tkTo = tk;
	return (true);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\metamodelenc.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MetaModelENC.cpp	  
//
// Implementation for applying ENC deltas to a MiniMd.
//
//*****************************************************************************
#include "stdafx.h"
#include <limits.h>
#include <PostError.h>
#include <MetaModelRW.h>
#include <StgIO.h>
#include <StgTiggerStorage.h>
#include "MDLog.h"
#include "RWUtil.h"

ULONG CMiniMdRW::m_SuppressedDeltaColumns[TBL_COUNT] = {0};

//*****************************************************************************
// Copy the data from one MiniMd to another.
//*****************************************************************************
HRESULT CMiniMdRW::ApplyRecordDelta(
	CMiniMdRW	&mdDelta,				// The delta MetaData.
	ULONG		ixTbl, 					// The table with the data.
	void		*pDelta, 				// The delta MetaData record.
	void		*pRecord)				// The record to update.
{
	ULONG		mask = m_SuppressedDeltaColumns[ixTbl];

	for (ULONG ixCol=0; ixCol<m_TableDefs[ixTbl].m_cCols; ++ixCol, mask>>=1)
	{	// Skip certain pointer columns.
		if (mask & 0x01)
			continue;
		ULONG val = mdDelta.GetCol(ixTbl, ixCol, pDelta);
		PutCol(ixTbl, ixCol, pRecord, val);
	}

	return S_OK;
} // HRESULT CMiniMdRW::ApplyRecordDelta()

//*****************************************************************************
// Apply a delta record to a table, generically.
//*****************************************************************************
HRESULT CMiniMdRW::ApplyTableDelta(	// S_OK or error.
	CMiniMdRW	&mdDelta,				// Interface to MD with the ENC delta.
	ULONG		ixTbl,					// Table index to update.
	RID			iRid,					// RID of the changed item.
	int			fc)						// Function code of update.
{
	HRESULT		hr = S_OK;				// A result.
	void		*pRec;					// Record in existing MetaData.
	void		*pDeltaRec;				// Record if Delta MetaData.
	RID			newRid;					// Rid of new record.

	// Get the delta record.
	pDeltaRec = mdDelta.GetDeltaRecord(ixTbl, iRid);
	// Get the record from the base metadata.
	if (iRid > m_Schema.m_cRecs[ixTbl])
	{	// Added record.  Each addition is the next one.
		_ASSERTE(iRid == m_Schema.m_cRecs[ixTbl] + 1);
		switch (ixTbl)
		{
		case TBL_TypeDef:
			pRec = AddTypeDefRecord(&newRid);
			break;
		case TBL_Method:
			pRec = AddMethodRecord(&newRid);
			break;
		case TBL_EventMap:
			pRec = AddEventMapRecord(&newRid);
			break;
		case TBL_PropertyMap:
			pRec = AddPropertyMapRecord(&newRid);
			break;
		default:
			pRec = AddRecord(ixTbl, &newRid);
			break;
		}
		IfNullGo(pRec);
		_ASSERTE(iRid == newRid);
	}
	else
	{	// Updated record.
		pRec = getRow(ixTbl, iRid);
	}

	// Copy the record info.
	ApplyRecordDelta(mdDelta, ixTbl, pDeltaRec, pRec);

ErrExit:
	return hr;
} // HRESULT CMiniMdRW::ApplyTableDelta()

//*****************************************************************************
// Get the record from a Delta MetaData that corresponds to the actual record.
//*****************************************************************************
void *CMiniMdRW::GetDeltaRecord(		// Returned record.
	ULONG		ixTbl, 					// Table.
	ULONG		iRid)					// Record in the table.
{
	ULONG		iMap;					// RID in map table.
	ENCMapRec	*pMap;					// Row in map table.
	// If no remap, just return record directly.
	if (m_Schema.m_cRecs[TBL_ENCMap] == 0 || ixTbl == TBL_Module)
		return getRow(ixTbl, iRid);

	// Use the remap table to find the physical row containing this logical row.
	iMap = (*m_rENCRecs)[ixTbl];
	pMap = getENCMap(iMap);

	// Search for desired record.
	while (TblFromRecId(pMap->m_Token) == ixTbl && RidFromRecId(pMap->m_Token) < iRid)
		pMap = getENCMap(++iMap);

	_ASSERTE(TblFromRecId(pMap->m_Token) == ixTbl && RidFromRecId(pMap->m_Token) == iRid);

	// Relative position within table's group in map is physical rid.
	iRid = iMap - (*m_rENCRecs)[ixTbl] + 1;

	return getRow(ixTbl, iRid);
} // void *CMiniMdRW::GetDeltaRecord()

//*****************************************************************************
// Given a MetaData with ENC changes, apply those changes to this MetaData.
//*****************************************************************************
HRESULT CMiniMdRW::ApplyHeapDeltas(		// S_OK or error.
	CMiniMdRW	&mdDelta)				// Interface to MD with the ENC delta.
{
	HRESULT		hr = S_OK;				// A result.
	ULONG		cbHeap;					// Size of a heap delta.
	void		*pHeap;					// Pointer to a heap delta.
	bool		bCopyHeapData=false;	// If true, make a copy of the delta heap.

	// Extend the string, blob, and guid pools with the new data.
	_ASSERTE(mdDelta.m_Strings.GetPoolSize() >= m_Strings.GetPoolSize());
	cbHeap = mdDelta.m_Strings.GetPoolSize() - m_Strings.GetPoolSize();
	if (cbHeap)
	{
		pHeap = mdDelta.m_Strings.GetData(m_Strings.GetPoolSize());
		IfFailGo(m_Strings.AddSegment(pHeap, cbHeap, bCopyHeapData));
	}
 	_ASSERTE(mdDelta.m_USBlobs.GetPoolSize() >= m_USBlobs.GetPoolSize());
	cbHeap = mdDelta.m_USBlobs.GetPoolSize() - m_USBlobs.GetPoolSize();
	if (cbHeap)
	{
		pHeap = mdDelta.m_USBlobs.GetData(m_USBlobs.GetPoolSize());
		IfFailGo(m_USBlobs.AddSegment(pHeap, cbHeap, bCopyHeapData));
	}
	_ASSERTE(mdDelta.m_Guids.GetPoolSize() >= m_Guids.GetPoolSize());
	cbHeap = mdDelta.m_Guids.GetPoolSize() - m_Guids.GetPoolSize();
	if (cbHeap)
	{
		pHeap = mdDelta.m_Guids.GetData(m_Guids.GetPoolSize());
		IfFailGo(m_Guids.AddSegment(pHeap, cbHeap, bCopyHeapData));
	}
 	_ASSERTE(mdDelta.m_Blobs.GetPoolSize() >= m_Blobs.GetPoolSize());
	cbHeap = mdDelta.m_Blobs.GetPoolSize() - m_Blobs.GetPoolSize();
	if (cbHeap)
	{
		pHeap = mdDelta.m_Blobs.GetData(m_Blobs.GetPoolSize());
		IfFailGo(m_Blobs.AddSegment(pHeap, cbHeap, bCopyHeapData));
	}


ErrExit:
	return hr;
} // HRESULT CMiniMdRW::ApplyHeapDeltas()

//*****************************************************************************
// Driver for the delta process.
//*****************************************************************************
HRESULT CMiniMdRW::ApplyDelta(			// S_OK or error.
	CMiniMdRW	&mdDelta)				// Interface to MD with the ENC delta.
{
	HRESULT		hr = S_OK;				// A result.
	ULONG		iENC;					// Loop control.
	ULONG		iRid;					// RID of some record.
	ULONG		iNew;					// RID of a new record.
	int			i;						// Loop control.
	ULONG		ixTbl;					// A table.
	int			ixTblPrev = -1;			// Table previously seen.

#ifdef _DEBUG        
	if (REGUTIL::GetConfigDWORD(L"MD_ApplyDeltaBreak", 0))
	{
        _ASSERTE(!"CMiniMDRW::ApplyDelta()");
	}
#endif // _DEBUG
	
    // Init the suppressed column table.  We know this one isn't zero...
	if (m_SuppressedDeltaColumns[TBL_TypeDef] == 0)
	{
		m_SuppressedDeltaColumns[TBL_EventMap]		= (1<<EventMapRec::COL_EventList);
		m_SuppressedDeltaColumns[TBL_PropertyMap]	= (1<<PropertyMapRec::COL_PropertyList);
		m_SuppressedDeltaColumns[TBL_EventMap]		= (1<<EventMapRec::COL_EventList);
		m_SuppressedDeltaColumns[TBL_Method]		= (1<<MethodRec::COL_ParamList);
		m_SuppressedDeltaColumns[TBL_TypeDef]		= (1<<TypeDefRec::COL_FieldList)|(1<<TypeDefRec::COL_MethodList);
	}

	// Verify the version of the MD.
	if (m_Schema.m_major != mdDelta.m_Schema.m_major || 
		m_Schema.m_minor != mdDelta.m_Schema.m_minor)
	{
		_ASSERTE(!"Version of Delta MetaData is a incompatible with current MetaData.");
		//@FUTURE: unique error in the future since we are not shipping ENC.
		return E_INVALIDARG;
	}

	// verify MVIDs.
	ModuleRec *pModDelta;
	ModuleRec *pModBase;
	pModDelta = mdDelta.getModule(1);
	pModBase = getModule(1);
	GUID *pGuidDelta = mdDelta.getMvidOfModule(pModDelta);
	GUID *pGuidBase = getMvidOfModule(pModBase);
	if (*pGuidDelta != *pGuidBase)
	{
		_ASSERTE(!"Delta MetaData has different base than current MetaData.");
		return E_INVALIDARG;
	}

    // Verify that the delta is based on the base.
    pGuidDelta = mdDelta.getEncBaseIdOfModule(pModDelta);
    pGuidBase = getEncIdOfModule(pModBase);
    if (*pGuidDelta != *pGuidBase)
    {
		_ASSERTE(!"The Delta MetaData is based on a different generation than the current MetaData.");
		return E_INVALIDARG;
    }

	// Let the other md prepare for sparse records.
	IfFailGo(mdDelta.StartENCMap());

	// Fix the heaps.
	IfFailGo(ApplyHeapDeltas(mdDelta));

	// Truncate some tables in prepareation to copy in new ENCLog data.
    for (i=0; (ixTbl = m_TruncatedEncTables[i]) != -1; ++i)
    {
        m_Table[ixTbl].Uninit();
        m_Table[ixTbl].InitNew(m_TableDefs[ixTbl].m_cbRec, mdDelta.m_Schema.m_cRecs[ixTbl]);
        m_Schema.m_cRecs[ixTbl] = 0;
    }

	// For each record in the ENC log...
	for (iENC=1; iENC<=mdDelta.m_Schema.m_cRecs[TBL_ENCLog]; ++iENC)
	{
		// Get the record, and the updated token.
		ENCLogRec *pENC = mdDelta.getENCLog(iENC);
		ENCLogRec *pENC2 = AddENCLogRecord(&iNew);
        IfNullGo(pENC2);
        ENCLogRec *pENC3;
		_ASSERTE(iNew == iENC);
		ULONG func = pENC->m_FuncCode;
		pENC2->m_FuncCode = pENC->m_FuncCode;
		pENC2->m_Token = pENC->m_Token;

		// What kind of record is this?
		if (IsRecId(pENC->m_Token))
		{	// Non-token table
			iRid = RidFromRecId(pENC->m_Token);
			ixTbl = TblFromRecId(pENC->m_Token);
		}
		else
		{	// Token table.
			iRid = RidFromToken(pENC->m_Token);
			ixTbl = GetTableForToken(pENC->m_Token);
		}

		// Switch based on the function code.
		switch (func)
		{
		case eDeltaMethodCreate:
			// Next ENC record will define the new Method.
			IfNullGo(AddMethodRecord());
			IfFailGo(AddMethodToTypeDef(iRid, m_Schema.m_cRecs[TBL_Method]));
			break;
			
		case eDeltaParamCreate:
			// Next ENC record will define the new Param.  This record is 
            //  tricky because params will be re-ordered based on their sequence,
            //  but the sequence isn't set until the NEXT record is applied.
            //  So, for ParamCreate only, apply the param record delta before
            //  adding the parent-child linkage.
			IfNullGo(AddParamRecord());

            // Should have recorded a Param delta after the Param add.
            _ASSERTE(iENC<mdDelta.m_Schema.m_cRecs[TBL_ENCLog]);
            pENC3 = mdDelta.getENCLog(iENC+1);
            _ASSERTE(pENC3->m_FuncCode == 0);
            _ASSERTE(GetTableForToken(pENC3->m_Token) == TBL_Param);
			IfFailGo(ApplyTableDelta(mdDelta, TBL_Param, RidFromToken(pENC3->m_Token), eDeltaFuncDefault));
            
            // Now that Param record is OK, set up linkage.
			IfFailGo(AddParamToMethod(iRid, m_Schema.m_cRecs[TBL_Param]));
			break;
			
		case eDeltaFieldCreate:
			// Next ENC record will define the new Field.
			IfNullGo(AddFieldRecord());
			IfFailGo(AddFieldToTypeDef(iRid, m_Schema.m_cRecs[TBL_Field]));
			break;
			
		case eDeltaPropertyCreate:
			// Next ENC record will define the new Property.
			IfNullGo(AddPropertyRecord());
			IfFailGo(AddPropertyToPropertyMap(iRid, m_Schema.m_cRecs[TBL_Property]));
			break;
			
		case eDeltaEventCreate:
			// Next ENC record will define the new Event.
			IfNullGo(AddEventRecord());
			IfFailGo(AddEventToEventMap(iRid, m_Schema.m_cRecs[TBL_Event]));
			break;
			
		case eDeltaFuncDefault:
			IfFailGo(ApplyTableDelta(mdDelta, ixTbl, iRid, func));
			break;
			
		default:
			_ASSERTE(!"Unexpected function in ApplyDelta");
			IfFailGo(E_UNEXPECTED);
			break;
		}
	}
	m_Schema.m_cRecs[TBL_ENCLog] = mdDelta.m_Schema.m_cRecs[TBL_ENCLog];

ErrExit:
	mdDelta.EndENCMap();
	return hr;
} // HRESULT CMiniMdRW::ApplyDelta()

//*****************************************************************************
//*****************************************************************************
HRESULT CMiniMdRW::StartENCMap()		// S_OK or error.
{
	HRESULT		hr = S_OK;				// A result.
	ULONG		iENC;					// Loop control.
	ULONG		ixTbl;					// A table.
	int			ixTblPrev = -1;			// Table previously seen.

	_ASSERTE(m_rENCRecs == 0);

	if (m_Schema.m_cRecs[TBL_ENCMap] == 0)
		return S_OK;

	// Build an array of pointers into the ENCMap table for fast access to the ENCMap
	//  for each table.
	m_rENCRecs = new ULONGARRAY;
	IfNullGo(m_rENCRecs);
	if (!m_rENCRecs->AllocateBlock(TBL_COUNT))
		IfFailGo(E_OUTOFMEMORY);
	for (iENC=1; iENC<=m_Schema.m_cRecs[TBL_ENCMap]; ++iENC)
	{
		ENCMapRec *pMap = getENCMap(iENC);
		ixTbl = TblFromRecId(pMap->m_Token);
		_ASSERTE((int)ixTbl >= ixTblPrev);
		_ASSERTE(ixTbl < TBL_COUNT);
		_ASSERTE(ixTbl != TBL_ENCMap);
		_ASSERTE(ixTbl != TBL_ENCLog);
		if ((int)ixTbl == ixTblPrev)
			continue;
		// Catch up on any skipped tables.
		while (ixTblPrev<(int)ixTbl)
			(*m_rENCRecs)[++ixTblPrev] = iENC;
	}
	while (ixTblPrev<TBL_COUNT-1)
		(*m_rENCRecs)[++ixTblPrev] = iENC;

ErrExit:
	return hr;
} // HRESULT CMiniMdRW::StartENCMap()

//*****************************************************************************
//*****************************************************************************
HRESULT CMiniMdRW::EndENCMap()			// S_OK or error.
{
	if (m_rENCRecs)
	{
		delete m_rENCRecs;
		m_rENCRecs = 0;
	}

	return S_OK;
} // HRESULT CMiniMdRW::EndENCMap()


// EOF.
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\compiler\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

#include <CrtWrap.h>
#include <WinWrap.h>
#include <utilcode.h>

#include <cor.h>
#include <corpriv.h>

#include "NSUtilPriv.h"

#include "UTSem.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\liteweightstgdbrw.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// LiteWeightStgdb.cpp
//
// This contains definition of class CLiteWeightStgDB. This is light weight
// read-only implementation for accessing compressed meta data format.
//
//*****************************************************************************
#include "stdafx.h"                     // Precompiled header.

#include "MetaModelRW.h"
#include "LiteWeightStgdb.h"

// include stgdatabase.h for GUID_POOL_STREAM definition
// #include "stgdatabase.h"

// include StgTiggerStorage for TiggerStorage definition
#include "StgTiggerStorage.h"
#include "StgIO.h"

#include <log.h>


extern "C" 
{
HRESULT FindImageMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData, DWORD dwFileLength);
HRESULT FindObjMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData, DWORD dwFileLength);
}


#ifndef TYPELIB_SIG
#define TYPELIB_SIG_MSFT                    0x5446534D  // MSFT
#define TYPELIB_SIG_SLTG                    0x47544C53  // SLTG
#endif

//*****************************************************************************
// Checks the given storage object to see if it is an NT PE image.
//*****************************************************************************
int _IsNTPEImage(                       // true if file is NT PE image.
    StgIO       *pStgIO)                // Storage object.
{
    LONG        lfanew=0;               // Offset in DOS header to NT header.
    ULONG       lSignature=0;           // For NT header signature.
    HRESULT     hr;
    
    // Read DOS header to find the NT header offset.
    if (FAILED(hr = pStgIO->Seek(60, FILE_BEGIN)) ||
        FAILED(hr = pStgIO->Read(&lfanew, sizeof(LONG), 0)))
    {
        return (false);
    }

    // Seek to the NT header and read the signature.
    if (FAILED(hr = pStgIO->Seek(lfanew, FILE_BEGIN)) ||
        FAILED(hr = pStgIO->Read(&lSignature, sizeof(ULONG), 0)) ||
        FAILED(hr = pStgIO->Seek(0, FILE_BEGIN)))
    {
        return (false);
    }

    // If the signature is a match, then we have a PE format.
    if (lSignature == IMAGE_NT_SIGNATURE)
        return (true);
    else
        return (false);
}

HRESULT _GetFileTypeForPathExt(StgIO *pStgIO, FILETYPE *piType)
{
    LPCWSTR     szPath;
    
    // Avoid confusion.
    *piType = FILETYPE_UNKNOWN;

    // If there is a path given, we can default to checking type.
    szPath = pStgIO->GetFileName();
    if (szPath && *szPath)
    {
        WCHAR       rcExt[_MAX_PATH];
        SplitPath(szPath, 0, 0, 0, rcExt);
        if (_wcsicmp(rcExt, L".obj") == 0)
            *piType = FILETYPE_NTOBJ;
        else if (_wcsicmp(rcExt, L".tlb") == 0)
            //@FUTURE: We should find the TLB signature(s).
            *piType = FILETYPE_TLB;
    }

    // All file types except .obj have a signature built in.  You should
    // not get to this code for those file types unless that file is corrupt,
    // or someone has changed a format without updating this code.
    _ASSERTE(*piType == FILETYPE_UNKNOWN || *piType == FILETYPE_NTOBJ || *piType == FILETYPE_TLB);

    // If we found a type, then you're ok.
    return (*piType != FILETYPE_UNKNOWN);
}

HRESULT _GetFileTypeForPath(StgIO *pStgIO, FILETYPE *piType)
{
    LPCWSTR     szDatabase = pStgIO->GetFileName();
    ULONG       lSignature=0;
    HRESULT     hr;
    
    // Assume native file.
    *piType = FILETYPE_CLB;

    // Need to read signature to see what type it is.
    if (!(pStgIO->GetFlags() & DBPROP_TMODEF_CREATE))
    {
        if (FAILED(hr = pStgIO->Read(&lSignature, sizeof(ULONG), 0)) ||
            FAILED(hr = pStgIO->Seek(0, FILE_BEGIN)))
        {
            return (hr);
        }

        if (lSignature == STORAGE_MAGIC_SIG)
            *piType = FILETYPE_CLB;
        else if ((WORD) lSignature == IMAGE_DOS_SIGNATURE && _IsNTPEImage(pStgIO))
            *piType = FILETYPE_NTPE;
        else if (lSignature == TYPELIB_SIG_MSFT || lSignature == TYPELIB_SIG_SLTG)
            *piType = FILETYPE_TLB;
        else if (!_GetFileTypeForPathExt(pStgIO, piType))
            return CLDB_E_FILE_CORRUPT;
    }
    return S_OK;
}


//*****************************************************************************
// Force generation of specialized versions.  While this may seem to defeat
//  the purpose of templates, it allows us to precisely control the 
//  specializations.  It also keeps the include file smaller.
//*****************************************************************************
void _nullRW()
{
    CLiteWeightStgdb<CMiniMdRW> RW;
        RW.Uninit();
}


//*****************************************************************************
// Prepare to go away.
//*****************************************************************************
CLiteWeightStgdbRW::~CLiteWeightStgdbRW()
{
    // Free up this stacks reference on the I/O object.
    if (m_pStgIO)
    {
        m_pStgIO->Release();
        m_pStgIO = NULL;
    }

    if (m_pStreamList) 
        delete m_pStreamList;
}

//*****************************************************************************
// Open an in-memory metadata section for read
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::InitOnMem(
    ULONG       cbData,                 // count of bytes in pData
    LPCVOID     pData,                  // points to meta data section in memory
    int         bReadOnly)              // If true, read-only.
{
    StgIO       *pStgIO = NULL;         // For file i/o.
    HRESULT     hr = NOERROR;

    if ((pStgIO = new StgIO) == 0)
        IfFailGo( E_OUTOFMEMORY);

    // Open the storage based on the pbData and cbData
    IfFailGo( pStgIO->Open(
        NULL, 
        STGIO_READ, 
        pData, 
        cbData, 
        NULL,
        NULL,
        NULL) );

    IfFailGo( InitFileForRead(pStgIO, bReadOnly) );

ErrExit:
    if (SUCCEEDED(hr))
    {
        m_pStgIO = pStgIO;
    }
    else
    {
        if (pStgIO)
            pStgIO->Release();
    }
    return hr;
}


//*****************************************************************************
// Given an StgIO, opens compressed streams and do proper initialization.
// This is a helper for other Init functions.
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::InitFileForRead(
    StgIO       *pStgIO,                // For file i/o.
    int         bReadOnly)              // If read-only open.
{

    TiggerStorage *pStorage = 0;        // Storage object.
    void        *pvData;
    ULONG       cbData;
    HRESULT     hr = NOERROR;

    // Allocate a new storage object which has IStorage on it.
    if ((pStorage = new TiggerStorage) == 0)
        IfFailGo( E_OUTOFMEMORY);

    // Init the storage object on the backing storage.
    OptionValue ov;
    m_MiniMd.GetOption(&ov);
    IfFailGo( hr = pStorage->Init(pStgIO, ov.m_RuntimeVersion) );

    // Load the string pool.
    if (SUCCEEDED(hr=pStorage->OpenStream(STRING_POOL_STREAM, &cbData, &pvData)))
        IfFailGo( m_MiniMd.InitPoolOnMem(MDPoolStrings, pvData, cbData, bReadOnly) );
    else 
    {
        if (hr != STG_E_FILENOTFOUND)
            IfFailGo(hr);
        IfFailGo(m_MiniMd.InitPoolOnMem(MDPoolStrings, 0, 0, 0));
    }

    // Load the user string blob pool.
    if (SUCCEEDED(hr=pStorage->OpenStream(US_BLOB_POOL_STREAM, &cbData, &pvData)))
        IfFailGo( m_MiniMd.InitPoolOnMem(MDPoolUSBlobs, pvData, cbData, bReadOnly) );
    else 
    {
        if (hr != STG_E_FILENOTFOUND)
            IfFailGo(hr);
        IfFailGo(m_MiniMd.InitPoolOnMem(MDPoolUSBlobs, 0, 0, 0));
    }

    // Load the guid pool.
    if (SUCCEEDED(hr=pStorage->OpenStream(GUID_POOL_STREAM,  &cbData, &pvData)))
        IfFailGo( m_MiniMd.InitPoolOnMem(MDPoolGuids, pvData, cbData, bReadOnly) );
    else 
    {
        if (hr != STG_E_FILENOTFOUND)
            IfFailGo(hr);
        IfFailGo(m_MiniMd.InitPoolOnMem(MDPoolGuids, 0, 0, 0));
    }

    // Load the blob pool.
    if (SUCCEEDED(hr=pStorage->OpenStream(BLOB_POOL_STREAM, &cbData, &pvData)))
        IfFailGo( m_MiniMd.InitPoolOnMem(MDPoolBlobs, pvData, cbData, bReadOnly) );
    else 
    {
        if (hr != STG_E_FILENOTFOUND)
            IfFailGo(hr);
        IfFailGo(m_MiniMd.InitPoolOnMem(MDPoolBlobs, 0, 0, 0));
    }

    // Open the metadata.
    hr = pStorage->OpenStream(COMPRESSED_MODEL_STREAM, &cbData, &pvData);
    if (hr == STG_E_FILENOTFOUND)
        IfFailGo(pStorage->OpenStream(ENC_MODEL_STREAM, &cbData, &pvData) );
    IfFailGo( m_MiniMd.InitOnMem(pvData, cbData, bReadOnly) ); 
    IfFailGo( m_MiniMd.PostInit(0) );
    
ErrExit:
    if (pStorage)
        delete pStorage;
    return hr;
} // HRESULT CLiteWeightStgdbRW::InitFileForRead()

//*****************************************************************************
// Open a metadata section for read
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::OpenForRead(
    LPCWSTR     szDatabase,             // Name of database.
    void        *pbData,                // Data to open on top of, 0 default.
    ULONG       cbData,                 // How big is the data.
    IStream     *pIStream,              // Optional stream to use.
    LPCWSTR     szSharedMem,            // Shared memory name for read.
    int         bReadOnly)              // If true, read-only.
{
    LPCWSTR     pNoFile=L"";            // Constant for empty file name.
    StgIO       *pStgIO = NULL;         // For file i/o.
    HRESULT     hr;

    m_pImage = NULL;
    m_dwImageSize = 0;
    m_eFileType = FILETYPE_UNKNOWN;
    // szDatabase, pbData, and pIStream are mutually exclusive.  Only one may be
    // non-NULL.  Having all 3 NULL means empty stream creation.
    //
    _ASSERTE(!(szDatabase && (pbData || pIStream)));
    _ASSERTE(!(pbData && (szDatabase || pIStream)));
    _ASSERTE(!(pIStream && (szDatabase || pbData)));

    // Open on memory needs there to be something to work with.
    if (pbData && cbData == 0)
        IfFailGo(CLDB_E_NO_DATA);

    // Make sure we have a path to work with.
    if (!szDatabase)
        szDatabase = pNoFile;

    // Sanity check the name.
    if (lstrlenW(szDatabase) >= _MAX_PATH)
        IfFailGo( E_INVALIDARG );

    // If we have storage to work with, init it and get type.
    if (*szDatabase || pbData || pIStream || szSharedMem)
    {
        // Allocate a storage instance to use for i/o.
        if ((pStgIO = new StgIO) == 0)
            IfFailGo( E_OUTOFMEMORY );

        // Open the storage so we can read the signature if there is already data.
        IfFailGo( pStgIO->Open(szDatabase, 
                               STGIO_READ, 
                               pbData, 
                               cbData, 
                               pIStream, 
                               szSharedMem, 
                               NULL) );         

        // Determine the type of file we are working with.
        IfFailGo( _GetFileTypeForPath(pStgIO, &m_eFileType) );
    }

    // Check for default type.
    if (m_eFileType == FILETYPE_CLB)
    {
        // Try the native .clb file.
        IfFailGo( InitFileForRead(pStgIO, bReadOnly) );
    }
    // PE/COFF executable/object format.  This requires us to find the .clb 
    // inside the binary before doing the Init.
    else if (m_eFileType == FILETYPE_NTPE || m_eFileType == FILETYPE_NTOBJ)
    {
        //@FUTURE: Ideally the FindImageMetaData function
        //@FUTURE:  would take the pStgIO and map only the part of the file where
        //@FUTURE:  our data lives, leaving the rest alone.  This would be smaller
        //@FUTURE:  working set for us.
        void        *ptr;
        ULONG       cbSize;

        // Map the entire binary for the FindImageMetaData function.
        IfFailGo( pStgIO->MapFileToMem(ptr, &cbSize) );

        // Find the .clb inside of the content.
        if (m_eFileType == FILETYPE_NTPE)
        {
            m_pImage = ptr;
            m_dwImageSize = cbSize;
            hr = FindImageMetaData(ptr, &ptr, (long *) &cbSize, cbSize);
        }
        else
            hr = FindObjMetaData(ptr, &ptr, (long *) &cbSize, cbSize);

        // Was the metadata found inside the PE file?
        if (FAILED(hr))
        {   
            // No clb in the PE, assume it is a type library.
            m_eFileType = FILETYPE_TLB;

            // Let the caller deal with a TypeLib.
            IfFailGo(CLDB_E_NO_DATA);
        }
        else
        {   
            // Metadata was found inside the file.
            // Now reset the base of the stg object so that all memory accesses
            // are relative to the .clb content.
            //
            IfFailGo( pStgIO->SetBaseRange(ptr, cbSize) );

            // Defer to the normal lookup.
            IfFailGo( InitFileForRead(pStgIO, bReadOnly) );
        }
    }
    else if (m_eFileType == FILETYPE_TLB)
    {
        // Let the caller deal with a TypeLib.
        IfFailGo(CLDB_E_NO_DATA);
    }
    // This spells trouble, we need to handle all types we might find.
    else
    {
        _ASSERTE(!"Unknown file type.");
        IfFailGo( E_FAIL );
    }

    // Save off everything.
    wcscpy(m_rcDatabase, szDatabase);

ErrExit:
 
    if (SUCCEEDED(hr))
    {
        m_pStgIO = pStgIO;
    }
    else
    {
        if (pStgIO)
            pStgIO->Release();
    }
    return (hr);
}

// Read/Write versions.
//*****************************************************************************
// Init the Stgdb and its subcomponents.
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::InitNew()
{ 
    InitializeLogging();
    LOG((LF_METADATA, LL_INFO10, "Metadata logging enabled\n"));

    //@FUTURE: should probably init the pools here instead of in the MiniMd.
    return m_MiniMd.InitNew();
}

//*****************************************************************************
// Determine what the size of the saved data will be.
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::GetSaveSize(// S_OK or error.
    CorSaveSize fSave,                  // Quick or accurate?
    ULONG       *pulSaveSize)           // Put the size here.
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       cbTotal = 0;            // The total size.
    ULONG       cbSize = 0;             // Size of a component.

    m_cbSaveSize = 0;

    // Allocate stream list if not already done.
    if (!m_pStreamList)
        IfNullGo(m_pStreamList = new STORAGESTREAMLST);
    else
        m_pStreamList->Clear();

    // Query the MiniMd for its size.
    IfFailGo(GetTablesSaveSize(fSave, &cbSize));
    cbTotal += cbSize;

    // Get the pools' sizes.
    IfFailGo(GetPoolSaveSize(STRING_POOL_STREAM, MDPoolStrings, &cbSize));
    cbTotal += cbSize;
    IfFailGo(GetPoolSaveSize(US_BLOB_POOL_STREAM, MDPoolUSBlobs, &cbSize));
    cbTotal += cbSize;
    IfFailGo(GetPoolSaveSize(GUID_POOL_STREAM, MDPoolGuids, &cbSize));
    cbTotal += cbSize;
    IfFailGo(GetPoolSaveSize(BLOB_POOL_STREAM, MDPoolBlobs, &cbSize));
    cbTotal += cbSize;

    // Finally, ask the storage system to add fixed overhead it needs for the
    // file format.  The overhead of each stream has already be calculated as
    // part of GetStreamSaveSize.  What's left is the signature and header
    // fixed size overhead.
    IfFailGo(TiggerStorage::GetStorageSaveSize(&cbTotal, 0));

    // Log the size info.
    LOG((LF_METADATA, LL_INFO10, "Metadata: GetSaveSize total is %d.\n", cbTotal));
    
    // The list of streams that will be saved are now in the stream save list.
    // Next step is to walk that list and fill out the correct offsets.  This is 
    // done here so that the data can be streamed without fixing up the header.
    TiggerStorage::CalcOffsets(m_pStreamList, 0);

    if (pulSaveSize)
        *pulSaveSize = cbTotal;
    m_cbSaveSize = cbTotal;

ErrExit:
    return hr;
} // HRESULT CLiteWeightStgdbRW::GetSaveSize()

//*****************************************************************************
// Get the save size of one of the pools.  Also adds the pool's stream to
//  the list of streams to be saved.
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::GetPoolSaveSize(
    LPCWSTR     szHeap,                 // Name of the heap stream.
    int         iPool,                  // The pool of which to get size.
    ULONG       *pcbSaveSize)           // Add pool data to this value.
{
    ULONG       cbSize = 0;             // Size of pool data.
    ULONG       cbStream;               // Size of just the stream.
    HRESULT     hr;

    *pcbSaveSize = 0;

    // If there is no data, then don't bother.
    if (m_MiniMd.IsPoolEmpty(iPool))
        return (S_OK);

    // Ask the pool to size its data.
    IfFailGo(m_MiniMd.GetPoolSaveSize(iPool, &cbSize));
    cbStream = cbSize;

    // Add this item to the save list.
    IfFailGo(AddStreamToList(cbSize, szHeap));


    // Ask the storage system to add stream fixed overhead.
    IfFailGo(TiggerStorage::GetStreamSaveSize(szHeap, cbSize, &cbSize));

    // Log the size info.
    LOG((LF_METADATA, LL_INFO10, "Metadata: GetSaveSize for %ls: %d data, %d total.\n",
        szHeap, cbStream, cbSize));

    // Give the size of the pool to the caller's total.  
    *pcbSaveSize = cbSize;

ErrExit:
    return hr;
}

//*****************************************************************************
// Get the save size of the metadata tables.  Also adds the tables stream to
//  the list of streams to be saved.
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::GetTablesSaveSize(
    CorSaveSize fSave,
    ULONG       *pcbSaveSize)           // Add pool data to this value.
{
    ULONG       cbSize = 0;             // Size of pool data.
    ULONG       cbStream;               // Size of just the stream.
    ULONG       bCompressed;            // Will the stream be compressed data?
    LPCWSTR     szName;                 // What will the name of the pool be?
    HRESULT     hr;

    *pcbSaveSize = 0;

    // Ask the metadata to size its data.
    IfFailGo(m_MiniMd.GetSaveSize(fSave, &cbSize, &bCompressed));
    cbStream = cbSize;
    m_bSaveCompressed = bCompressed;
    szName = m_bSaveCompressed ? COMPRESSED_MODEL_STREAM : ENC_MODEL_STREAM;

    // Add this item to the save list.
    IfFailGo(AddStreamToList(cbSize, szName));
    
    // Ask the storage system to add stream fixed overhead.
    IfFailGo(TiggerStorage::GetStreamSaveSize(szName, cbSize, &cbSize));

    // Log the size info.
    LOG((LF_METADATA, LL_INFO10, "Metadata: GetSaveSize for %ls: %d data, %d total.\n",
        szName, cbStream, cbSize));

    // Give the size of the pool to the caller's total.  
    *pcbSaveSize = cbSize;

ErrExit:
    return hr;
} // HRESULT CLiteWeightStgdbRW::GetTablesSaveSize()

//*****************************************************************************
// Add a stream, and its size, to the list of streams to be saved.
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::AddStreamToList(
    ULONG       cbSize,
    LPCWSTR     szName)
{
    HRESULT     hr = S_OK;
    STORAGESTREAM *pItem;               // New item to allocate & fill.

    // Add a new item to the end of the list.
    IfNullGo(pItem = m_pStreamList->Append());

    // Fill out the data.
    pItem->iOffset = 0;
    pItem->iSize = cbSize;
    VERIFY(WszWideCharToMultiByte(CP_ACP, 0, szName, -1, pItem->rcName, MAXSTREAMNAME, 0, 0) > 0);

ErrExit:
    return hr;
}

//*****************************************************************************
// Save the data to a stream.  A TiggerStorage sub-allocates streams within
//   the stream.
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::SaveToStream(
    IStream     *pIStream)
{
    HRESULT     hr = S_OK;              // A result.
    StgIO       *pStgIO = 0;
    TiggerStorage *pStorage = 0;

    // Allocate a storage subsystem and backing store.
    IfNullGo(pStgIO = new StgIO);
    IfNullGo(pStorage = new TiggerStorage);

    // Open around this stream for write.
    IfFailGo(pStgIO->Open(L"", DBPROP_TMODEF_DFTWRITEMASK, 0, 0, pIStream));
    OptionValue ov;
    m_MiniMd.GetOption(&ov);
    IfFailGo( pStorage->Init(pStgIO, ov.m_RuntimeVersion) );

    // Save worker will do tables, pools.
    IfFailGo(SaveToStorage(pStorage));

ErrExit:

    if (pStgIO)
        pStgIO->Release();
    if (pStorage)
        delete pStorage;
    return hr;
} // HRESULT CLiteWeightStgdbRW::PersistToStream()

//*****************************************************************************
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::SaveToStorage(
    TiggerStorage *pStorage)
{
    HRESULT     hr;                     // A result.
    LPCWSTR     szName;                 // Name of the tables stream.
    IStream     *pIStreamTbl = 0;
    ULONG       cb;

    // Must call GetSaveSize to cache the streams up front.
    if (!m_cbSaveSize)
        IfFailGo(GetSaveSize(cssAccurate, 0));

    // Save the header of the data file.
    IfFailGo(pStorage->WriteHeader(m_pStreamList, 0, NULL));

    // Create a stream and save the tables.
    szName = m_bSaveCompressed ? COMPRESSED_MODEL_STREAM : ENC_MODEL_STREAM;
    IfFailGo(pStorage->CreateStream(szName, 
            STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
            0, 0, &pIStreamTbl));
    IfFailGo(m_MiniMd.SaveTablesToStream(pIStreamTbl));
    pIStreamTbl->Release();
    pIStreamTbl = 0;

    // Save the pools.
    IfFailGo(SavePool(STRING_POOL_STREAM, pStorage, MDPoolStrings));
    IfFailGo(SavePool(US_BLOB_POOL_STREAM, pStorage, MDPoolUSBlobs));
    IfFailGo(SavePool(GUID_POOL_STREAM, pStorage, MDPoolGuids));
    IfFailGo(SavePool(BLOB_POOL_STREAM, pStorage, MDPoolBlobs));

    // Write the header to disk.
    IfFailGo(pStorage->WriteFinished(m_pStreamList, &cb));

    _ASSERTE(m_cbSaveSize == cb);

    // Let the Storage release some memory.
    pStorage->ResetBackingStore();

    m_MiniMd.SaveDone();

ErrExit:
    if (pIStreamTbl)
        pIStreamTbl->Release();
    delete m_pStreamList;
    m_pStreamList = 0;
    m_cbSaveSize = 0;
    return hr;
} // HRESULT CLiteWeightStgdbRW::SaveToStorage()

//*****************************************************************************
// Save a pool of data out to a stream.
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::SavePool(   // Return code.
    LPCWSTR     szName,                 // Name of stream on disk.
    TiggerStorage *pStorage,            // The storage to put data in.
    int         iPool)                  // The pool to save.
{
    IStream     *pIStream=0;            // For writing.
    HRESULT     hr;

    // If there is no data, then don't bother.
    if (m_MiniMd.IsPoolEmpty(iPool))
        return (S_OK);

    // Create the new stream to hold this table and save it.
    IfFailGo(pStorage->CreateStream(szName, 
            STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE, 
            0, 0, &pIStream));
    IfFailGo(m_MiniMd.SavePoolToStream(iPool, pIStream));

ErrExit:
    if (pIStream)
        pIStream->Release();
    return hr;
} // HRESULT CLiteWeightStgdbRW::SavePool()


//*****************************************************************************
// Save the metadata to a file.
//*****************************************************************************
HRESULT CLiteWeightStgdbRW::Save(       // S_OK or error.
    LPCWSTR     szDatabase,             // Name of file to which to save.
    DWORD       dwSaveFlags)            // Flags for the save.
{
    TiggerStorage *pStorage=0;          // IStorage object.
    StgIO       *pStgIO=0;              // Backing storage.
    HRESULT     hr = S_OK;

    if (!*m_rcDatabase)
    {
        if (!szDatabase)
        {
            // Make sure that a NULL is not passed in the first time around.
            _ASSERTE(!"Not allowed to pass a NULL for filename on the first call to Save.");
            return (E_INVALIDARG);
        }
        else
        {
            // Save the file name.
            wcscpy(m_rcDatabase, szDatabase);
        }
    }
    else if (szDatabase && _wcsicmp(szDatabase, m_rcDatabase) != 0)
    {
        // Allow for same name, case of multiple saves during session.
        // Changing the name on a scope which is already opened is not allowed.
        // There is no particular reason for this anymore, it was required
        // in the past when we were going to support multiple formats.
        //_ASSERTE(!"Rename of current scope.  Processing will continue.");
        // Save the file name.
        wcscpy(m_rcDatabase, szDatabase);
    }

    // Sanity check the name.
    if (lstrlenW(m_rcDatabase) >= _MAX_PATH)
        IfFailGo(E_INVALIDARG);

    m_eFileType = FILETYPE_CLB;

    // Allocate a new storage object.
    IfNullGo(pStgIO = new StgIO);

    // Create the output file.
    IfFailGo(pStgIO->Open(m_rcDatabase, DBPROP_TMODEF_DFTWRITEMASK));

    // Allocate an IStorage object to use.
    IfNullGo(pStorage = new TiggerStorage);

    // Init the storage object on the i/o system.
    OptionValue ov;
    m_MiniMd.GetOption(&ov);
    IfFailGo( pStorage->Init(pStgIO, ov.m_RuntimeVersion) );

    // Save the data.
    IfFailGo(SaveToStorage(pStorage));

ErrExit:
    if (pStgIO)
        pStgIO->Release();
    if (pStorage)
        delete pStorage;
    return (hr);
} // HRESULT CLiteWeightStgdbRW::Save()


// eof ------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\peparse.c ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
#pragma warning (disable : 4121) // ntkxapi.h(59) alignment warning
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef __unaligned
typedef WCHAR UNALIGNED *LPUWSTR, *PUWSTR;
typedef CONST WCHAR UNALIGNED *LPCUWSTR, *PCUWSTR;
#include <windows.h>
#include <CorHdr.h>
#include <ntimage.h>
#include "corerror.h"
#pragma warning (default : 4121)


STDAPI RuntimeReadHeaders(PBYTE hAddress, IMAGE_DOS_HEADER** ppDos,
                          IMAGE_NT_HEADERS** ppNT, IMAGE_COR20_HEADER** ppCor,
                          BOOL fDataMap, DWORD dwLength);
EXTERN_C PBYTE Cor_RtlImageRvaToVa(PIMAGE_NT_HEADERS NtHeaders,
                                   PBYTE Base,
                                   ULONG Rva,
                                   ULONG FileLength);


static const char g_szCORMETA[] = ".cormeta";


HRESULT FindImageMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData, DWORD dwFileLength)
{
    HRESULT             hr;
    IMAGE_DOS_HEADER   *pDos;
    IMAGE_NT_HEADERS   *pNt;
    IMAGE_COR20_HEADER *pCor;

    if (FAILED(hr = RuntimeReadHeaders(pImage, &pDos, &pNt, &pCor, TRUE, dwFileLength)))
        return hr;

    *ppMetaData = Cor_RtlImageRvaToVa(pNt,
                                      (PBYTE)pImage,
                                      pCor->MetaData.VirtualAddress,
                                      dwFileLength);
    *pcbMetaData = pCor->MetaData.Size;

    if (*ppMetaData == NULL || *pcbMetaData == 0)
        return COR_E_BADIMAGEFORMAT;
    return S_OK;
}


HRESULT FindObjMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData, DWORD dwFileLength)
{
    IMAGE_FILE_HEADER *pImageHdr;       // Header for the .obj file.
    IMAGE_SECTION_HEADER *pSectionHdr;  // Section header.
    WORD        i;                      // Loop control.

    // Get a pointer to the header and the first section.
    pImageHdr = (IMAGE_FILE_HEADER *) pImage;
    pSectionHdr = (IMAGE_SECTION_HEADER *)(pImageHdr + 1);

    // Avoid confusion.
    *ppMetaData = NULL;
    *pcbMetaData = 0;

    // Walk each section looking for .cormeta.
    for (i=0;  i<pImageHdr->NumberOfSections;  i++, pSectionHdr++)
    {
        // Simple comparison to section name.
        if (strcmp((const char *) pSectionHdr->Name, g_szCORMETA) == 0)
        {
            // Check that raw data in the section is actually within the file.
            if (pSectionHdr->PointerToRawData + pSectionHdr->SizeOfRawData > dwFileLength)
                break;
            *pcbMetaData = pSectionHdr->SizeOfRawData;
            *ppMetaData = (void *) ((long) pImage + pSectionHdr->PointerToRawData);
            break;
        }
    }

    // Check for errors.
    if (*ppMetaData == NULL || *pcbMetaData == 0)
        return (COR_E_BADIMAGEFORMAT);
    return (S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\imptlb.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
//  File: ImpTlb.CPP
//
//  History:
//      ---------------------------------------------------------------
//      Who     When        What
//      ---------------------------------------------------------------
//      WGE     970906      Created
//
// ===========================================================================
#include "stdafx.h"
#include "imptlb.h"
#include <PostError.h>
#include <StrongName.h>
#include <nsutilpriv.h>

#include "..\compiler\regmeta.h"
#include "..\compiler\importhelper.h"
#include "TlbUtils.h"                   // For GenerateMangledTypeName().
#include <TlbImpExp.h>

#ifdef wcsncmp 
 #undef wcsncmp
#endif
#ifdef wcsncpy
 #undef wcsncpy
#endif
_CRTIMP int __cdecl wcsncmp(const wchar_t *, const wchar_t *, size_t);
_CRTIMP wchar_t * __cdecl wcsncpy(wchar_t *, const wchar_t *, size_t);

// #define M11                          // Define to enable M11 features
#define S_CONVERSION_LOSS 3             // Non-error code meaning a conversion lost information.

#define ADD_ITF_MEMBERS_TO_CLASS        // Define to add interface members to the CoClass.
#define ITF_MEMBER_RESOLUTION_NAMEONLY  // Define to ignore signatures when looking for collisions (ie, when defined
                                        //  void Foo(int) and void Foo(String) collide).

// defines controlling ctor of non-creatable objects.
#define NONCREATABLE_CTOR_VISIBILITY mdAssem  // Define to a visibility flag.

#define MAX_CLASSNAME_SIZE 1024

#ifndef lengthof
#define lengthof(rg)    (sizeof(rg)/sizeof(rg[0]))
#endif

#ifndef IfNullGo
#define IfNullGo(x) do {if (!(x)) IfFailGo(E_OUTOFMEMORY);} while (0)
#endif

#define BUILD_CUSTOM_ATTRIBUTE(type,bytes)  {*reinterpret_cast<type*>(__pca) = bytes; __pca += sizeof(type); _ASSERTE(__pca-__ca <= sizeof(__ca));}
#define INIT_CUSTOM_ATTRIBUTE(n)            {_ASSERTE((n) <= (sizeof(__ca)-sizeof(SHORT)));__pca = __ca; BUILD_CUSTOM_ATTRIBUTE(USHORT,1);}
#define SIZEOF_CUSTOM_ATTRIBUTE()           (__pca - __ca)
#define PTROF_CUSTOM_ATTRIBUTE()            (&__ca[0])
#define DECLARE_CUSTOM_ATTRIBUTE(n)         BYTE __ca[(n)+sizeof(SHORT)*2], *__pca;__pca=__ca; INIT_CUSTOM_ATTRIBUTE(n);
#define APPEND_STRING_TO_CUSTOM_ATTRIBUTE(str) {int l = (int)strlen(str); __pca=(BYTE*)CPackedLen::PutLength(__pca,l);memcpy(__pca,str,l);__pca+=l;}
#define FINISH_CUSTOM_ATTRIBUTE()           {BUILD_CUSTOM_ATTRIBUTE(short,0);}

#define DECLARE_DYNLEN_CUSTOM_ATTRIBUTE(n)          CQuickArray<BYTE> __tmpCAArray; __tmpCAArray.ReSize(n + sizeof(SHORT)*2); BYTE *__ca, *__pca; __ca = __tmpCAArray.Ptr(); __pca=__ca; BUILD_CUSTOM_ATTRIBUTE(USHORT,1);
#define BUILD_DYNLEN_CUSTOM_ATTRIBUTE(type,bytes)   {*reinterpret_cast<type*>(__pca) = bytes; __pca += sizeof(type); _ASSERTE(__pca-__ca <= (int)__tmpCAArray.Size());}
#define FINISH_DYNLEN_CUSTOM_ATTRIBUTE()            {BUILD_DYNLEN_CUSTOM_ATTRIBUTE(short,0);}

#define APPEND_WIDE_STRING_TO_CUSTOM_ATTRIBUTE(str)                                             \
{                                                                                               \
    CQuickArray<char> __tmpStr;                                                                 \
    int __cStr = WszWideCharToMultiByte(CP_ACP, 0, str, -1, 0, 0, NULL, NULL);                  \
    __tmpStr.ReSize(__cStr);                                                                    \
    __cStr = WszWideCharToMultiByte(CP_ACP, 0, str, -1, __tmpStr.Ptr(), __cStr, NULL, NULL);    \
    __pca=(BYTE*)CPackedLen::PutLength(__pca,__cStr);                                           \
    memcpy(__pca,__tmpStr.Ptr(),__cStr);                                                        \
    __pca+=__cStr;                                                                              \
}

// The maximum number of bytes the encoding of a DWORD can take.
#define DWORD_MAX_CB 4

// The maximum number of bytes the encoding of a DWORD can take.
#define STRING_OVERHEAD_MAX_CB 4

// Use the unused variant types m_knowntypes for common types.
#define VT_SLOT_FOR_GUID         VT_EMPTY
#define VT_SLOT_FOR_IENUMERABLE  VT_NULL
#define VT_SLOT_FOR_MULTICASTDEL VT_I2
#define VT_SLOT_FOR_TYPE         VT_I4

static LPCWSTR szObject                             = L"System.Object";
static LPCWSTR szValueType                          = L"System.ValueType";
static LPCWSTR szEnum                               = L"System.Enum";

static LPCWSTR TLB_CLASSLIB_ARRAY                   = {L"System.Array"};
static LPCWSTR TLB_CLASSLIB_DATE                    = {L"System.DateTime"};
static LPCWSTR TLB_CLASSLIB_DECIMAL                 = {L"System.Decimal"};
static LPCWSTR TLB_CLASSLIB_VARIANT                 = {L"System.Variant"};
static LPCWSTR TLB_CLASSLIB_GUID                    = {L"System.Guid"};
static LPCWSTR TLB_CLASSLIB_IENUMERABLE             = {L"System.Collections.IEnumerable"};
static LPCWSTR TLB_CLASSLIB_MULTICASTDELEGATE       = {L"System.MulticastDelegate"};
static LPCWSTR TLB_CLASSLIB_TYPE                    = {L"System.Type"};

static LPCWSTR COM_STDOLE2                          = {L"StdOle"};
static LPCWSTR COM_GUID                             = {L"GUID"};

static const LPCWSTR        PROP_DECORATION_GET     = {L"get_"};
static const LPCWSTR        PROP_DECORATION_SET     = {L"set_"};
static const LPCWSTR        PROP_DECORATION_LET     = {L"let_"};
static const int            PROP_DECORATION_LEN     = 4;

static const LPCWSTR        DLL_EXTENSION           = {L".dll"};
static const int            DLL_EXTENSION_LEN       = 4;
static const LPCWSTR        EXE_EXTENSION           = {L".exe"};
static const int            EXE_EXTENSION_LEN       = 4;

static LPCWSTR const        OBJECT_INITIALIZER_NAME = {L".ctor"};
static const int            OBJECT_INITIALIZER_FLAGS = mdPublic | mdSpecialName;
static const int            OBJECT_INITIALIZER_IMPL_FLAGS = miNative | miRuntime | miInternalCall;
static const int            NONCREATABLE_OBJECT_INITIALIZER_FLAGS = NONCREATABLE_CTOR_VISIBILITY | mdSpecialName;

static const COR_SIGNATURE  OBJECT_INITIALIZER_SIG[3] = { 
    (IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS), 0, ELEMENT_TYPE_VOID };

static const int    DEFAULT_INTERFACE_FUNC_FLAGS    = mdPublic | mdVirtual | mdAbstract | mdHideBySig | mdNewSlot;
static const int    DEFAULT_PROPERTY_FUNC_FLAGS     = mdPublic | mdVirtual | mdAbstract | mdHideBySig | mdSpecialName | mdNewSlot;
static const int    DEFAULT_CONST_FIELD_FLAGS       = fdPublic | fdStatic | fdLiteral;
static const int    DEFAULT_RECORD_FIELD_FLAGS      = fdPublic;
static const int    DELEGATE_INVOKE_FUNC_FLAGS      = mdPublic | mdVirtual;

static const int    DEFAULT_ITF_FUNC_IMPL_FLAGS     = miNative | miRuntime | miInternalCall;

static const WCHAR         VTBL_GAP_FUNCTION[]      = {L"_VtblGap"};
static const int           VTBL_GAP_FUNCTION_FLAGS  = mdPublic | mdSpecialName;
static const int           VTBL_GAP_FUNC_IMPL_FLAGS = miRuntime;
static const COR_SIGNATURE VTBL_GAP_SIGNATURE[]     = {IMAGE_CEE_CS_CALLCONV_DEFAULT, 0, ELEMENT_TYPE_VOID};
static const LPCWSTR       VTBL_GAP_FORMAT_1        = {L"%ls%d"};
static const LPCWSTR       VTBL_GAP_FORMAT_N        = {L"%ls%d_%d"};

static const LPCWSTR       ENUM_TYPE_NAME           = {COR_ENUM_FIELD_NAME_W};
static const DWORD         ENUM_TYPE_FLAGS          = fdPublic;
static const COR_SIGNATURE ENUM_TYPE_SIGNATURE[]    = {IMAGE_CEE_CS_CALLCONV_FIELD, ELEMENT_TYPE_I4};
static const DWORD         ENUM_TYPE_SIGNATURE_SIZE = lengthof(ENUM_TYPE_SIGNATURE);

static const LPCWSTR       DYNAMIC_NAMESPACE_NAME   = {L"DynamicModule"};

static const LPCWSTR       UNSAFE_ITF_PREFIX        = {L"Unsafe."};

static const LPCWSTR       GET_ENUMERATOR_MEMBER_NAME = {L"GetEnumerator"};

static const WCHAR         CLASS_SUFFIX[]              = {L"Class"};
static const DWORD         CLASS_SUFFIX_LENGTH       = lengthof(CLASS_SUFFIX);
static const WCHAR         EVENT_ITF_SUFFIX[]          = {L"_Event"};
static const DWORD         EVENT_ITF_SUFFIX_LENGTH   = lengthof(EVENT_ITF_SUFFIX);
static const WCHAR         EVENT_PROVIDER_SUFFIX[]     = {L"_EventProvider"};
static const DWORD         EVENT_PROVIDER_SUFFIX_LENGTH = lengthof(EVENT_ITF_SUFFIX);
static const WCHAR         EVENT_HANDLER_SUFFIX[]      = {L"EventHandler"};
static const DWORD         EVENT_HANDLER_SUFFIX_LENGTH = lengthof(EVENT_HANDLER_SUFFIX);

static const WCHAR         EVENT_ADD_METH_PREFIX[]          = {L"add_"};
static const DWORD         EVENT_ADD_METH_PREFIX_LENGTH   = lengthof(EVENT_ADD_METH_PREFIX);
static const WCHAR         EVENT_REM_METH_PREFIX[]          = {L"remove_"};
static const DWORD         EVENT_REM_METH_PREFIX_LENGTH   = lengthof(EVENT_REM_METH_PREFIX);

static const WCHAR         DELEGATE_INVOKE_METH_NAME[]      = {L"Invoke"};
static const DWORD         DELEGATE_INVOKE_METH_NAME_LENGTH = lengthof(EVENT_ADD_METH_PREFIX);

// {C013B386-CC3E-4b6d-9B67-A3AE97274BBE}
static const GUID FREE_STATUS_GUID = 
{ 0xc013b386, 0xcc3e, 0x4b6d, { 0x9b, 0x67, 0xa3, 0xae, 0x97, 0x27, 0x4b, 0xbe } };

// {C013B387-CC3E-4b6d-9B67-A3AE97274BBE}
static const GUID DELETED_STATUS_GUID = 
{ 0xc013b387, 0xcc3e, 0x4b6d, { 0x9b, 0x67, 0xa3, 0xae, 0x97, 0x27, 0x4b, 0xbe } };

// {C013B388-CC3E-4b6d-9B67-A3AE97274BBE}
static const GUID USED_STATUS_GUID = 
{ 0xc013b388, 0xcc3e, 0x4b6d, { 0x9b, 0x67, 0xa3, 0xae, 0x97, 0x27, 0x4b, 0xbe } };

static const GUID IID_IEnumerable = 
{ 0x496b0abe, 0xcdee, 0x11d3, { 0x88, 0xe8, 0x00, 0x90, 0x27, 0x54, 0xc4, 0x3a } };

 #define STRUCTLAYOUT tdSequentialLayout
// ULONG_MAX is a flag meaning "don't convert".
static const ULONG rdwTypeFlags[] = {
    tdPublic | tdSealed,                                // TKIND_ENUM       = 0,
    tdPublic | tdSealed | tdBeforeFieldInit | STRUCTLAYOUT, // TKIND_RECORD    = TKIND_ENUM + 1,    
    tdPublic | tdAbstract,                              // TKIND_MODULE     = TKIND_RECORD + 1,
    tdPublic | tdInterface | tdAbstract | tdImport,     // TKIND_INTERFACE  = TKIND_MODULE + 1,
    tdPublic | tdInterface | tdAbstract | tdImport,     // TKIND_DISPATCH   = TKIND_INTERFACE + 1,
    tdPublic | tdImport,                                // TKIND_COCLASS    = TKIND_DISPATCH + 1,
    tdPublic | tdImport,                                // TKIND_ALIAS      = TKIND_COCLASS + 1,
    tdPublic | tdSealed | tdExplicitLayout,             // TKIND_UNION     = TKIND_ALIAS + 1,
    ULONG_MAX,                                          // TKIND_MAX        = TKIND_UNION + 1
};
static const LPCWSTR g_szTypekind[] = {
    L"Enum         ",
    L"Record       ",
    L"Module       ",
    L"Interface    ",
    L"Dispinterface",
    L"Coclass      ",
    L"Alias        ",
    L"Union        ",
};

#define NATIVE_TYPE_NONE ((CorNativeType)(NATIVE_TYPE_MAX+1))

#define NON_CONVERTED_PARAMS_FLAGS (PARAMFLAG_FRETVAL|PARAMFLAG_FLCID)


//*****************************************************************************
// External declarations.
//*****************************************************************************
extern mdAssemblyRef DefineAssemblyRefForImportedTypeLib(
    void        *pAssembly,             // Assembly importing the typelib.
    void        *pvModule,              // Module importing the typelib.
    IUnknown    *pIMeta,                // IMetaData* from import module.
    IUnknown    *pIUnk,                 // IUnknown to referenced Assembly.
    BSTR        *pwzNamespace,          // The namespace of the resolved assembly.
    BSTR        *pwzAsmName,            // The name of the resolved assembly.
    Assembly    **AssemblyRef);         // The resolved assembly.

extern mdAssemblyRef DefineAssemblyRefForExportedAssembly(
    LPCWSTR     szFullName,             // Assembly full name.
    IUnknown    *pIMeta);               // Metadata emit interface.

extern DWORD GetConfigDWORD(LPWSTR name, DWORD defValue);

//*****************************************************************************
// External accessor function for typelib import.
//*****************************************************************************
extern "C"
HRESULT __stdcall ImportTypeLib(
    LPCWSTR     szLibrary,              // Name of library being imported.
    ITypeLib    *pitlb,                 // The type library to import from.
    REFIID      riid,                   // Interface to return.
    void        **ppObj)                // Return pointer to object here.
{
    HRESULT     hr;                     // Conversion result.
    {
        CImportTlb     ImpTlb(szLibrary, pitlb, FALSE, FALSE, FALSE, FALSE);

        hr = ImpTlb.Import();
        if (SUCCEEDED(hr))
            hr = ImpTlb.GetInterface(riid, ppObj);
    }
    return hr;
} // HRESULT __stdcall ImportTypeLib()

static HRESULT _UnpackVariantToConstantBlob(VARIANT *pvar, BYTE *pcvType, void **pvValue, __int64 *pd);
static INT64 _DoubleDateToTicks(const double d);
static HRESULT TryGetFuncDesc(ITypeInfo *pITI, int i, FUNCDESC **ppFunc);


//*****************************************************************************
// Default notification object.
//*****************************************************************************
class CDefaultNotification : public ITypeLibImporterNotifySink
{
public:
        HRESULT STDMETHODCALLTYPE ResolveRef(IUnknown *pTLB, IUnknown **pAssembly)
    {
        *pAssembly = 0;
        return (S_OK);
    }
    HRESULT STDMETHODCALLTYPE ReportEvent(ImporterEventKind EventKind, HRESULT hr, BSTR bstrEventMsg)
    {
        // Message should be formatted by caller, so just print it.
        printf("%ls\n", bstrEventMsg);
        return (S_OK);
    }
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject)
    {
        *ppvObject = 0;
        return (E_NOINTERFACE);
    }
    ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return (1);
    }
    ULONG STDMETHODCALLTYPE Release(void)
    {
        return (0);
    }
};
CDefaultNotification g_DefaultNotification;

//*****************************************************************************
// Class factory.
//*****************************************************************************
CImportTlb* CImportTlb::CreateImporter(
    LPCWSTR     szLibrary, 
    ITypeLib    *pitlb, 
    BOOL        bGenerateTCEAdapters, 
    BOOL        bUnsafeInterfaces,
    BOOL        bSafeArrayAsSystemArray,
    BOOL        bTransformDispRetVals)
{
    return new CImportTlb(szLibrary, pitlb, bGenerateTCEAdapters, bUnsafeInterfaces, bSafeArrayAsSystemArray, bTransformDispRetVals);
} // CImportTlb* CImportTlb::CreateImporter()

//*****************************************************************************
// Default constructor.
//*****************************************************************************
CImportTlb::CImportTlb()
 :  m_szLibrary(0),
    m_pITLB(0),
    m_bGenerateTCEAdapters(false),
    m_bSafeArrayAsSystemArray(false),
    m_bTransformDispRetVals(false),
    m_pEmit(0),
    m_pImport(0),
    m_pITI(0),
    m_psAttr(0),
    m_arSystem(mdAssemblyRefNil),
    m_Notify(0),
    m_trValueType(0),
    m_trEnum(0),
    m_bUnsafeInterfaces(FALSE),
    m_tkSuppressCheckAttr(mdTokenNil),
    m_tdHasDefault(0),
    m_szName(0),
    m_szMember(0),
    m_wzNamespace(0),
    m_tkInterface(0),
    m_szInterface(0),
    m_pMemberNames(0),
    m_cMemberProps(0),
    m_ImplIface(eImplIfaceNone)
{
    // Clear the known types array.  The values will be lazily initialized.
    memset(m_tkKnownTypes, 0, sizeof(m_tkKnownTypes));
    memset(m_tkAttr, 0, sizeof(m_tkAttr));
} // CImportTlb::CImportTlb()

//*****************************************************************************
// Complex constructor.
//*****************************************************************************
CImportTlb::CImportTlb(
    LPCWSTR     szLibrary,              // Name of library being imported.   
    ITypeLib    *pitlb,                 // The type library to import from.  
    BOOL        bGenerateTCEAdapters,   // A flag indicating if the TCE adapters are being generated.
    BOOL        bUnsafeInterfaces,      // A flag indicating that runtime security checks should be disabled
    BOOL        bSafeArrayAsSystemArray,// A flag indicating whether to import SAFEARRAY's as System.Array's.
    BOOL        bTransformDispRetVals)   // A flag indicating if we should do [out,retval] transformation on disp only itfs.
 :  m_szLibrary(szLibrary),
    m_pITLB(pitlb),
    m_bGenerateTCEAdapters(bGenerateTCEAdapters),
    m_bUnsafeInterfaces(bUnsafeInterfaces),
    m_bSafeArrayAsSystemArray(bSafeArrayAsSystemArray),
    m_bTransformDispRetVals(bTransformDispRetVals),
    m_pEmit(0),
    m_pImport(0),
    m_pITI(0),
    m_psAttr(0),
    m_arSystem(mdAssemblyRefNil),
    m_Notify(0),
    m_trValueType(0),
    m_trEnum(0),
    m_tkSuppressCheckAttr(mdTokenNil),
    m_tdHasDefault(0),
    m_szName(0),
    m_szMember(0),
    m_wzNamespace(0),
    m_tkInterface(0),
    m_szInterface(0),
    m_pMemberNames(0),
    m_cMemberProps(0),
    m_ImplIface(eImplIfaceNone)
{
    if (pitlb)
        pitlb->AddRef();

    // Clear the known types array.  The values will be lazily initialized.
    memset(m_tkKnownTypes, 0, sizeof(m_tkKnownTypes));
    memset(m_tkAttr, 0, sizeof(m_tkAttr));
    
#if defined(TLB_STATS)
    m_bStats = QueryPerformanceFrequency(&m_freqVal);
#endif
} // CImportTlb::CImportTlb()

//*****************************************************************************
// Destructor.
//*****************************************************************************
CImportTlb::~CImportTlb()
{
    if (m_pEmit)
        m_pEmit->Release();
    if (m_pImport)
        m_pImport->Release();
    if (m_pITLB)
        m_pITLB->Release();
    if (m_Notify)
        m_Notify->Release();
    if (m_wzNamespace)
        ::SysFreeString(m_wzNamespace);
} // CImportTlb::~CImportTlb()


//*****************************************************************************
// Allow the user to specify a namespace to be used in the conversion.
//*****************************************************************************
HRESULT CImportTlb::SetNamespace(
    WCHAR const *pNamespace)
{
    HRESULT     hr=S_OK;                // A result.
    
    IfNullGo(m_wzNamespace=::SysAllocString(pNamespace));
    
ErrExit:
    
    return hr;
} // HRESULT CImportTlb::SetNamespace()

//*****************************************************************************
// Allow the user to specify a notification object to be used in the conversion.
//*****************************************************************************
HRESULT CImportTlb::SetNotification(
    ITypeLibImporterNotifySink *pNotify)
{
    _ASSERTE(m_Notify == 0);
    m_Notify = pNotify;
    pNotify->AddRef();

    return S_OK;
} // HRESULT CImportTlb::SetNotification()

//*****************************************************************************
// Allow the user to specify the MetaData scope to be used in the conversion.
//*****************************************************************************
HRESULT CImportTlb::SetMetaData(
    IUnknown    *pIUnk)
{
    HRESULT     hr;
    _ASSERTE(m_pEmit == 0);
    IfFailGo(pIUnk->QueryInterface(IID_IMetaDataEmit, (void**)&m_pEmit));
ErrExit:
    return hr;    
} // HRESULT CImportTlb::SetMetaData()

//*****************************************************************************
// Import given typelib.
//*****************************************************************************
HRESULT CImportTlb::ImportTypeLib(
    ITypeLib    *pITLB)
{
    m_pITLB = pITLB;
    return Import();
} // HRESULT CImportTlb::ImportTypeLib()

//*****************************************************************************
// Import given typeinfo.
//*****************************************************************************
HRESULT CImportTlb::ImportTypeInfo(
    ITypeInfo   *pITI,
    mdTypeDef *pCl)
{
    HRESULT     hr;                     // A result.
    VARIANT     vt = {0};               // For setting options.
    IMetaDataDispenserEx *pDisp = 0;    // To create export scope.

    m_psAttr = NULL;

    // Handle case with no callback.
    if (m_Notify == 0)
        m_Notify = &g_DefaultNotification;

    if (m_pEmit == 0)
    {   // Get a metadata scope to work with.
        IfFailGo(CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IMetaDataDispenserEx, (void **)&pDisp));
        vt.vt = VT_UI4;
        vt.ulVal = MDNoDupChecks;
        IfFailGo(pDisp->SetOption(MetaDataCheckDuplicatesFor, &vt));
        vt.ulVal = MDNotifyNone;
        IfFailGo(pDisp->SetOption(MetaDataNotificationForTokenMovement, &vt));
        IfFailGo(pDisp->DefineScope(CLSID_CorMetaDataRuntime, 0, IID_IMetaDataEmit,
                            (IUnknown **)&m_pEmit));
    }
    IfFailGo(m_pEmit->QueryInterface(IID_IMetaDataImport, (void **)&m_pImport));

    IfNullGo(m_wzNamespace=::SysAllocString(DYNAMIC_NAMESPACE_NAME));

    // Initialize the reserved names map.
    IfFailGo(m_ReservedNames.Init());

    // Create the Object classref record and AssemblyRef for mscorlib.dll.
    IfFailGo(_DefineSysRefs());    
    
    // Set the TypeInfo and retrieve the attributes.
    m_pITI = pITI;
    IfFailGo(m_pITI->GetTypeAttr(&m_psAttr));

    // Convert the typelib.
    IfFailGo(ConvertTypeInfo());

    // Set the output typedef token.
    *pCl = m_tdTypeDef;

ErrExit:
    if (m_psAttr)
    {
        m_pITI->ReleaseTypeAttr(m_psAttr);
        m_psAttr = NULL;
    }
    if (pDisp)
        pDisp->Release();

    m_pITI = NULL;

    return (hr);
} // HRESULT CImportTlb::ImportTypeInfo()

//*****************************************************************************
// Import a TypeLibrary into a CompLib.
//*****************************************************************************
HRESULT CImportTlb::Import()
{
    HRESULT     hr;                     // A result.
    mdModule    md;                     // Module token.
    VARIANT     vt = {0};               // For setting options.
    ITypeLib2   *pITLB2 = 0;            // To get custom attributes.
    IMetaDataDispenserEx *pDisp = 0;    // To create export scope.
    TLIBATTR    *psAttr=0;              // The library's attributes.
    BSTR        szLibraryName = 0;      // The library's name.
    LPCWSTR     wzFile;                 // The filename of the typelib (no path).
    LPCWSTR     wzSource;               // Source of the typelib, for CA.
    
    // Handle case with no callback.
    if (m_Notify == 0)
        m_Notify = &g_DefaultNotification;

    // Quick sanity check.
    if (!m_pITLB)
        return (E_INVALIDARG);

    // Check to see if the type library implements ITypeLib2.
    if (m_pITLB->QueryInterface(IID_ITypeLib2, (void **)&pITLB2) != S_OK)
        pITLB2 = 0;

    // If custom attribute for namespace exists, use it.
    if (pITLB2)
    {
        VARIANT vt;
        VariantInit(&vt);
        if (pITLB2->GetCustData(GUID_ManagedName, &vt) == S_OK)
        {   
            if (V_VT(&vt) == VT_BSTR)
            {
                // If there already was a namespace set, release it.
                if (m_wzNamespace)
                    SysFreeString(m_wzNamespace);
            
                // If the namespace ends with .dll then remove the extension.
                LPWSTR pDest = wcsstr(vt.bstrVal, DLL_EXTENSION);
                if (pDest && (pDest[DLL_EXTENSION_LEN] == 0 || pDest[DLL_EXTENSION_LEN] == ' '))
                    *pDest = 0;

                if (!pDest)
                {
                    // If the namespace ends with .exe then remove the extension.
                    pDest = wcsstr(vt.bstrVal, EXE_EXTENSION);
                    if (pDest && (pDest[EXE_EXTENSION_LEN] == 0 || pDest[EXE_EXTENSION_LEN] == ' '))
                        *pDest = 0;
                }

                if (pDest)
                {
                    // We removed the extension so re-allocate a string of the new length.
                    m_wzNamespace = SysAllocString(vt.bstrVal);
                    SysFreeString(vt.bstrVal);
                    IfNullGo(m_wzNamespace);
                }
                else
                {
                    // There was no extension to remove so we can use the string returned
                    // by GetCustData().
                    m_wzNamespace = vt.bstrVal;
                }        
            }
            else
            {
                VariantClear(&vt);
            }
        }
    }

    // Use the namespace name if we don't know the filename.
    if (!m_szLibrary)
        m_szLibrary = m_wzNamespace;
    
    // If the typelib was exported from COM+ to begin with, don't import it.
    if (pITLB2)
    {
        ::VariantInit(&vt);
        hr = pITLB2->GetCustData(GUID_ExportedFromComPlus, &vt);
        if (vt.vt != VT_EMPTY)
        {
            if (0)
            {
                // com emulates option is ON
            }
            else
            {
                IfFailGo(PostError(TLBX_E_CIRCULAR_IMPORT, m_szLibrary));
            }
        }
    }

    if (m_pEmit == 0)
    {
        // Get a metadata scope to work with.
        IfFailGo(CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IMetaDataDispenserEx, (void **)&pDisp));
        vt.vt = VT_UI4;
        vt.ulVal = MDNoDupChecks;
        IfFailGo(pDisp->SetOption(MetaDataCheckDuplicatesFor, &vt));
        vt.ulVal = MDNotifyNone;
        IfFailGo(pDisp->SetOption(MetaDataNotificationForTokenMovement, &vt));
        IfFailGo(pDisp->DefineScope(CLSID_CorMetaDataRuntime, 0, IID_IMetaDataEmit,
                            (IUnknown **)&m_pEmit));
    }
    IfFailGo(m_pEmit->QueryInterface(IID_IMetaDataImport, (void **)&m_pImport));

    // Initialize the reserved names map.
    IfFailGo(m_ReservedNames.Init());

    // Initialize the default interface to class interface map for the TLB being imported.
    IfFailGo(m_DefItfToClassItfMap.Init(m_pITLB, m_wzNamespace));

    // Create the Object classref record and AssemblyRef for mscorlib.dll.
    IfFailGo(_DefineSysRefs());    
    
    // Create the library record.
    IfFailGo(_NewLibraryObject());

    // Note that this was imported.
    IfFailGo(m_pITLB->GetLibAttr(&psAttr));
    if (SUCCEEDED(::QueryPathOfRegTypeLib(psAttr->guid, psAttr->wMajorVerNum, psAttr->wMinorVerNum,  psAttr->lcid, &szLibraryName)))
        wzSource = szLibraryName;
    else
        wzSource = m_szLibrary;
    IfFailGo(m_pImport->GetModuleFromScope(&md));
    // Skip the path or drive info 
    wzFile = wcsrchr(wzSource, L'\\');
    if (wzFile == 0)
    {   // That's odd, should have been a fully qualified path.  Just use an empty string.
        wzFile = L"";
    }
    else
    {   // skip leading backslash
        wzFile++;
    }

    // Convert the typelib.
    IfFailGo(ConvertTypeLib());

ErrExit:
    if (psAttr)
        m_pITLB->ReleaseTLibAttr(psAttr);
    if (szLibraryName)
        ::SysFreeString(szLibraryName);
    if (pITLB2)
        pITLB2->Release();
    if (pDisp)
        pDisp->Release();

    return (hr);
} // HRESULT CImportTlb::Import()

//*****************************************************************************
// Return a copy of the scope.
//*****************************************************************************
HRESULT CImportTlb::GetInterface(
    REFIID      riid,                   // Interface ID to return. 
    void        **pp)                   // Return pointer if successful.
{
    return (m_pEmit->QueryInterface(riid, pp));
} // HRESULT CImportTlb::GetInterface()
    
//*****************************************************************************
// Create the Complib to represent the TypeLib.
//*****************************************************************************
HRESULT CImportTlb::_NewLibraryObject()
{
    HRESULT             hr;                     // A result.
    TLIBATTR *          psAttr=0;               // The library's attributes.
    BSTR                szLibraryName=0;        // The library's name.
    CQuickArray<WCHAR>  rScopeName;             // The name of the scope.

    // Information about the library.
    IfFailGo(m_pITLB->GetLibAttr(&psAttr));
    IfFailGo(m_pITLB->GetDocumentation(MEMBERID_NIL, &szLibraryName, 0, 0, 0));

    // Create the scope name by using the typelib name and adding .dll.
    rScopeName.ReSize(SysStringLen(szLibraryName) + 5 * sizeof(WCHAR));
    swprintf(rScopeName.Ptr(), L"%s.dll", szLibraryName);

    IfFailGo(m_pEmit->SetModuleProps(rScopeName.Ptr()));

ErrExit:
    if (psAttr)
        m_pITLB->ReleaseTLibAttr(psAttr);

    if (szLibraryName)
        ::SysFreeString(szLibraryName);

    return (hr);
} // HRESULT CImportTlb::_NewLibraryObject()

//*****************************************************************************
// Define an assembly ref for mscorlib, typeref for Object.
//*****************************************************************************
HRESULT CImportTlb::_DefineSysRefs()
{
    HRESULT     hr;                     // A result.
    WCHAR       szPath[_MAX_PATH];
    WCHAR       szDrive[_MAX_DRIVE];
    WCHAR       szDir[_MAX_PATH];
    DWORD       dwLen;                  // Length of system directory name.
    IMetaDataDispenserEx *pDisp = 0;    // To import mscorlib.
    IMetaDataAssemblyImport *pAImp = 0; // To read mscorlib assembly.
    IMetaDataAssemblyEmit *pAEmit = 0;  // To create mscorlib assembly ref.
    ASSEMBLYMETADATA amd = {0};         // Assembly metadata.
    mdToken     tk;                     // A token.
    const void  *pvPublicKey;           // Public key.
    ULONG       cbPublicKey;            // Length of public key.
    BYTE        *pbToken=0;             // Compressed token for public key.
    ULONG       cbToken;                // Length of token.
    ULONG       ulHashAlg;              // Hash algorithm.
    DWORD       dwFlags;                // Assembly flags.
    
    // Get the dispenser.
    IfFailGo(CoCreateInstance(CLSID_CorMetaDataDispenser, NULL, CLSCTX_INPROC_SERVER,
                                IID_IMetaDataDispenserEx, (void **)&pDisp));
        
    // Get the name of mscorlib.
    //@todo: define, function, etc., instead of hard coded "mscorlib"
    dwLen = lengthof(szPath) - 13; // allow space for "mscorlib" ".dll" "\0"
    IfFailGo(pDisp->GetCORSystemDirectory(szPath, dwLen, &dwLen));
    SplitPath(szPath, szDrive, szDir, 0,0);
    MakePath(szPath, szDrive, szDir, L"mscorlib", L".dll");
    
    // Open the scope, get the details.
    IfFailGo(pDisp->OpenScope(szPath, 0, IID_IMetaDataAssemblyImport, (IUnknown**)&pAImp));
    IfFailGo(pAImp->GetAssemblyFromScope(&tk));
    IfFailGo(pAImp->GetAssemblyProps(tk, &pvPublicKey,&cbPublicKey, &ulHashAlg, 
        szPath,lengthof(szPath),&dwLen, &amd, &dwFlags));

    if (!StrongNameTokenFromPublicKey((BYTE*)(pvPublicKey),cbPublicKey, &pbToken,&cbToken))
    {
        hr = StrongNameErrorInfo();
        goto ErrExit;
    }
    dwFlags &= ~afPublicKey;
    
    // Define the assembly ref.
    IfFailGo(m_pEmit->QueryInterface(IID_IMetaDataAssemblyEmit, (void**)&pAEmit));
    IfFailGo(pAEmit->DefineAssemblyRef(pbToken,cbToken, szPath, &amd,0,0,dwFlags, &m_arSystem));
    
    IfFailGo(m_TRMap.DefineTypeRef(m_pEmit, m_arSystem, szObject, &m_trObject));
    
    m_tkKnownTypes[VT_DISPATCH] = m_trObject;
    m_tkKnownTypes[VT_UNKNOWN] = m_trObject;
    m_tkKnownTypes[VT_VARIANT] = m_trObject;
    
ErrExit:
    if (pbToken)
        StrongNameFreeBuffer(pbToken);
    if (pDisp)
        pDisp->Release();
    if (pAEmit)
        pAEmit->Release();
    if (pAImp)
        pAImp->Release();

    return hr;
} // HRESULT CImportTlb::_DefineSysRefs()

//*****************************************************************************
// Lazily get the token for a CustomAttribute.
//*****************************************************************************
HRESULT CImportTlb::GetAttrType(
    int         attr,                   // The attribute for which the type is desired.
    mdToken     *pTk)                   // Put the type here.
{
    HRESULT     hr = S_OK;              // A result.
    mdTypeRef   tr;                     // An intermediate typeref.
    DWORD           dwSigSize;          // The size of the sig for special sigs.
    DWORD           dwMaxSigSize;       // The max size of the special sig.
    COR_SIGNATURE   *pSig;              // Pointer to the start of the sig,
    COR_SIGNATURE   *pCurr;             // Current sig pointer.
    mdTypeRef       trType;             // The typeref for System.Type.

    _ASSERTE(attr >= 0);
    _ASSERTE(attr < ATTR_COUNT);

    //@todo: globally define these names.
#define INTEROP_ATTRIBUTE(x) static COR_SIGNATURE x##_SIG[] = INTEROP_##x##_SIG;
#define INTEROP_ATTRIBUTE_SPECIAL(x)
    INTEROP_ATTRIBUTES();
#undef INTEROP_ATTRIBUTE
#undef INTEROP_ATTRIBUTE_SPECIAL
#define INTEROP_ATTRIBUTE(x) \
    case ATTR_##x: \
        IfFailGo(m_pEmit->DefineTypeRefByName(m_arSystem, INTEROP_##x##_TYPE_W, &tr)); \
        IfFailGo(m_pEmit->DefineMemberRef(tr, L".ctor", x##_SIG, lengthof(x##_SIG), &m_tkAttr[attr])); \
        break;
#define INTEROP_ATTRIBUTE_SPECIAL(x)

    if (IsNilToken(m_tkAttr[attr]))
    {
        switch (attr)
        {
            INTEROP_ATTRIBUTES();

            case ATTR_COMEVENTINTERFACE:
            {
                // Retrieve token for System.Type.
                IfFailGo(GetKnownTypeToken(VT_SLOT_FOR_TYPE, &trType));

                // Build the sig.
                dwMaxSigSize = 5 + sizeof(mdTypeRef) * 2;
                pSig = (COR_SIGNATURE*)_alloca(dwMaxSigSize);
                pCurr = pSig;
                *pCurr++ = IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS;
                *pCurr++ = 2;
                *pCurr++ = ELEMENT_TYPE_VOID;
                *pCurr++ = ELEMENT_TYPE_CLASS;
                pCurr += CorSigCompressToken(trType, pCurr);
                *pCurr++ = ELEMENT_TYPE_CLASS;
                pCurr += CorSigCompressToken(trType, pCurr);
                dwSigSize = pCurr - pSig;
                _ASSERTE(dwSigSize <= dwMaxSigSize);

                // Declare the typeref and the member ref for the CA.
                IfFailGo(m_pEmit->DefineTypeRefByName(m_arSystem, INTEROP_COMEVENTINTERFACE_TYPE_W, &tr)); \
                IfFailGo(m_pEmit->DefineMemberRef(tr, L".ctor", pSig, dwSigSize, &m_tkAttr[attr])); \
                break;
            }

            case ATTR_COCLASS:
            {
                // Retrieve token for System.Type.
                IfFailGo(GetKnownTypeToken(VT_SLOT_FOR_TYPE, &trType));

                // Build the sig.
                dwMaxSigSize = 4 + sizeof(mdTypeRef);
                pSig = (COR_SIGNATURE*)_alloca(dwMaxSigSize);
                pCurr = pSig;
                *pCurr++ = IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS;
                *pCurr++ = 1;
                *pCurr++ = ELEMENT_TYPE_VOID;
                *pCurr++ = ELEMENT_TYPE_CLASS;
                pCurr += CorSigCompressToken(trType, pCurr);
                dwSigSize = pCurr - pSig;
                _ASSERTE(dwSigSize <= dwMaxSigSize);

                // Declare the typeref and the member ref for the CA.
                IfFailGo(m_pEmit->DefineTypeRefByName(m_arSystem, INTEROP_COCLASS_TYPE_W, &tr)); \
                IfFailGo(m_pEmit->DefineMemberRef(tr, L".ctor", pSig, dwSigSize, &m_tkAttr[attr])); \
                break;
            }
        }
    }
#undef INTEROP_ATTRIBUTE
#undef INTEROP_ATTRIBUTE_SPECIAL

    *pTk = m_tkAttr[attr];
ErrExit:
    return hr;  
} // HRESULT CImportTlb::GetAttrType()

//*****************************************************************************
// Create the TypeDefs.
//*****************************************************************************
HRESULT CImportTlb::ConvertTypeLib()
{
    HRESULT                 hr;              // A result.
    int                     cTi;             // Count of TypeInfos.
    int                     i;               // Loop control.

    // How many TypeInfos?
    IfFailGo(cTi = m_pITLB->GetTypeInfoCount());

    // Iterate over them.
    for (i=0; i<cTi; ++i)
    {
        // Get the TypeInfo.
        hr = m_pITLB->GetTypeInfo(i, &m_pITI);
        if (SUCCEEDED(hr))
        {
            // Retrieve the attributes of the type info.
            IfFailGo(m_pITI->GetTypeAttr(&m_psAttr));

            // Convert the TypeInfo.
            hr = ConvertTypeInfo();
            if (FAILED(hr))
            {
                if (hr == CEE_E_CVTRES_NOT_FOUND || hr == TLBX_I_RESOLVEREFFAILED)
                {   // Reflection emit is broken, no need to try to continue.
                    goto ErrExit;
                }

                BSTR szTypeInfoName = NULL;
                hr = m_pITI->GetDocumentation(MEMBERID_NIL, &szTypeInfoName, 0, 0, 0);
                if (SUCCEEDED(hr))
                    ReportEvent(NOTIF_CONVERTWARNING, TLBX_E_INVALID_TYPEINFO, szTypeInfoName);
                else
                    ReportEvent(NOTIF_CONVERTWARNING, TLBX_E_INVALID_TYPEINFO_UNNAMED, i);
                if (szTypeInfoName)
                    ::SysFreeString(szTypeInfoName);
#if defined(_DEBUG)                
                if (REGUTIL::GetConfigDWORD(L"MD_TlbImp_BreakOnErr", 0))
                    _ASSERTE(!"Invalid type");
#endif                
            }

            // Release for next TypeInfo.
            m_pITI->ReleaseTypeAttr(m_psAttr);
            m_psAttr = 0;
            m_pITI->Release();
            m_pITI = 0;
        }
    }

ErrExit:
    if (m_psAttr)
        m_pITI->ReleaseTypeAttr(m_psAttr);
    if (m_pITI)
        m_pITI->Release();
    return (hr);
} // HRESULT CImportTlb::ConvertTypeLib()

//*****************************************************************************
// Convert a single ITypeInfo into the scope.
//*****************************************************************************
HRESULT CImportTlb::ConvertTypeInfo()   // S_OK or error.
{
    HRESULT     hr;                     // A result.
    BSTR        bstrManagedName=0;      // Managed name (or part thereof).
    CQuickArray<WCHAR> qbClassName;     // The name of the class.
    ULONG       ulFlags;                // TypeDef flags.
    WORD        wTypeInfoFlags;         // TypeInfo flags.  Alias flags, if an alias.
    mdToken     tkAttr;                 // Attribute type for flags.
    TYPEKIND    tkindAlias;             // TYPEKIND of an aliased TypeInfo.
    GUID        guid;                   // GUID of the typeinfo.
    BOOL        bConversionLoss=false;  // If true, info was lost converting sigs.
    mdToken     tkParent;               // Parent of the typedef.
    mdToken     td;                     // For looking up a TypeDef.
    ITypeInfo2  *pITI2=0;               // For getting custom value.
    
#if defined(TLB_STATS)
    WCHAR       rcStats[16];            // Buffer for stats.
    LARGE_INTEGER __startVal;
    QueryPerformanceCounter(&__startVal); 
#endif
    
    m_tdTypeDef = mdTypeDefNil;
    
    // Get some information about the TypeInfo.
    IfFailGo(m_pITI->GetDocumentation(MEMBERID_NIL, &m_szName, 0, 0, 0));
    
    // Figure out the name.

    // If the type info is for a CoClass, we need to decorate the name.
    if (m_psAttr->typekind == TKIND_COCLASS)
    {
        // Generate a mangled name for the component.
        IfFailGo(GetManagedNameForCoClass(m_pITI, qbClassName));
        m_szMngName = qbClassName.Ptr();
    }   
    else 
    {
        IfFailGo(GetManagedNameForTypeInfo(m_pITI, m_wzNamespace, NULL, &bstrManagedName));
        m_szMngName = bstrManagedName;
    }
    
    // Assume that we will be able to convert the typeinfo.
    ulFlags = rdwTypeFlags[m_psAttr->typekind];
    guid = m_psAttr->guid;
    wTypeInfoFlags = m_psAttr->wTypeFlags;
    
    // If this typeinfo is an alias, see what it is an alias for.  If for a built-in
    //  type, we will just skip it.  If for a user-defined type, we will duplicate
    //  that definition under this alias' name and guid.
    if (m_psAttr->typekind == TKIND_ALIAS)
    {
        hr = _ResolveTypeDescAliasTypeKind(m_pITI, &m_psAttr->tdescAlias, &tkindAlias);
        IfFailGo(hr);
        if (hr == S_OK)
        {
            ITypeInfo   *pITIResolved;
            TYPEATTR    *psAttrResolved;
            IfFailGo(_ResolveTypeDescAlias(m_pITI, &m_psAttr->tdescAlias, &pITIResolved, &psAttrResolved, &guid));
            m_pITI->ReleaseTypeAttr(m_psAttr);
            m_pITI->Release();
            m_pITI = pITIResolved;
            m_psAttr = psAttrResolved; 

            // We should no longer have an alias.
            _ASSERTE(m_psAttr->typekind == tkindAlias);
            _ASSERTE(tkindAlias != TKIND_ALIAS);
            ulFlags = rdwTypeFlags[tkindAlias];
        }
        else
            ulFlags = ULONG_MAX;
    }
    else 
    if (m_psAttr->typekind == TKIND_INTERFACE ||
        (m_psAttr->typekind == TKIND_DISPATCH && m_psAttr->wTypeFlags & TYPEFLAG_FDUAL))
    {
        // If the interface is not derived from IUnknown, or not an interface, we can't convert it.
        if (IsIUnknownDerived(m_pITI, m_psAttr) != S_OK)
        {
            ReportEvent(NOTIF_CONVERTWARNING, TLBX_E_NOTIUNKNOWN, m_szName);
            ulFlags = ULONG_MAX;
        }
        // If the interface is not derived from IDispatch, but claims to be [dual], give a warning but convert it.
        if ((m_psAttr->wTypeFlags & TYPEFLAG_FDUAL) && IsIDispatchDerived(m_pITI, m_psAttr) != S_OK)
        {
            ReportEvent(NOTIF_CONVERTWARNING, TLBX_W_DUAL_NOT_DISPATCH, m_szName);
        }
    }
    else
    if (m_psAttr->typekind == TKIND_MODULE)
    {   // If module has no vars, skip it.  We currently don't import module functions.
        if (m_psAttr->cVars == 0)
            ulFlags = ULONG_MAX;
    }
    
    // If something we can convert...
    if (ulFlags != ULONG_MAX)
    {   
        // Interfaces derive from nil...
        if (IsTdInterface(ulFlags))
            tkParent = mdTypeDefNil;
        else  // ... enums from Enum, ...
        if (m_psAttr->typekind == TKIND_ENUM)
        {
            if (IsNilToken(m_trEnum))
                IfFailGo(m_TRMap.DefineTypeRef(m_pEmit, m_arSystem, szEnum, &m_trEnum));
            tkParent = m_trEnum;
        }
        else // ... structs from ValueType, ...
        if (m_psAttr->typekind == TKIND_RECORD || m_psAttr->typekind == TKIND_UNION)
        {
            if (IsNilToken(m_trValueType))
                IfFailGo(m_TRMap.DefineTypeRef(m_pEmit, m_arSystem, szValueType, &m_trValueType));
            tkParent = m_trValueType;
        }
        else // ... and classes derive from Object.
            tkParent = m_trObject;

        // The typelib importer generates metadata into an empty ReflectionEmit scope.  Because
        //  RE manages type names itself, duplicate checking is turned off.  Because of user-defined
        //  names (via CUSTOM), it is possible for the user to declare a duplicate.  So,
        //  before adding the new type, check for duplicates.
        hr = m_pImport->FindTypeDefByName(m_szMngName, mdTypeDefNil, &td);
        if (hr != CLDB_E_RECORD_NOTFOUND)
        {
            ReportEvent(NOTIF_CONVERTWARNING, TLBX_E_DUPLICATE_TYPE_NAME, m_szMngName);
            IfFailGo(TLBX_E_DUPLICATE_TYPE_NAME);
        }

        // Create the typedef.
        IfFailGo(m_pEmit->DefineTypeDef(m_szMngName, ulFlags, tkParent, 0, &m_tdTypeDef));
        IfFailGo(_AddGuidCa(m_tdTypeDef, guid));

        // Save the typeinfo flags.
        if (wTypeInfoFlags)
        {
            IfFailGo(GetAttrType(ATTR_TYPELIBTYPE, &tkAttr));
            DECLARE_CUSTOM_ATTRIBUTE(sizeof(WORD));
            BUILD_CUSTOM_ATTRIBUTE(WORD, wTypeInfoFlags);
            FINISH_CUSTOM_ATTRIBUTE();
            IfFailGo(m_pEmit->DefineCustomAttribute(m_tdTypeDef, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
        }

        // Mark unsafe interfaces (suppressed security runtime checks).
        if (m_bUnsafeInterfaces)
        {
            if (m_tkSuppressCheckAttr == mdTokenNil)
            {
                mdTypeRef       tr;
                COR_SIGNATURE   rSig[] = {IMAGE_CEE_CS_CALLCONV_DEFAULT_HASTHIS, 0, ELEMENT_TYPE_VOID};
                IfFailGo(m_pEmit->DefineTypeRefByName(m_arSystem, COR_SUPPRESS_UNMANAGED_CODE_CHECK_ATTRIBUTE, &tr));
                IfFailGo(m_pEmit->DefineMemberRef(tr, COR_CTOR_METHOD_NAME_W, rSig, lengthof(rSig), &m_tkSuppressCheckAttr));
            }

            DECLARE_CUSTOM_ATTRIBUTE(0);
            FINISH_CUSTOM_ATTRIBUTE();
            IfFailGo(m_pEmit->DefineCustomAttribute(m_tdTypeDef, m_tkSuppressCheckAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));
        }

        // Fill in the details depending on the type of the TypeInfo.
        switch (m_psAttr->typekind)
        {
        case TKIND_ENUM:
            hr = ConvEnum(m_pITI, m_psAttr);
            break;
            
        case TKIND_RECORD:
            hr = ConvRecord(m_pITI, m_psAttr, FALSE);
            break;
            
        case TKIND_UNION:
            hr = ConvRecord(m_pITI, m_psAttr, TRUE);
            break;
            
        case TKIND_MODULE:
            hr = ConvModule(m_pITI, m_psAttr);
            break;
            
        case TKIND_INTERFACE:
            hr = ConvIface(m_pITI, m_psAttr);
            break;
            
        case TKIND_DISPATCH:
            hr = ConvDispatch(m_pITI, m_psAttr);
            break;
            
        case TKIND_COCLASS:
            hr = ConvCoclass(m_pITI, m_psAttr);
            break;
            
        case TKIND_ALIAS:
            _ASSERTE(!"Alias should have been resolved!");
            break;
            
        default:
            _ASSERTE(!"Unexpected TYPEKIND");
            break;
        }
        if (FAILED(hr))
            goto ErrExit;
        
        if (hr == S_CONVERSION_LOSS)
        {
            bConversionLoss = true;
            IfFailGo(GetAttrType(ATTR_COMCONVERSIONLOSS, &tkAttr));
            DECLARE_CUSTOM_ATTRIBUTE(0);
            FINISH_CUSTOM_ATTRIBUTE();
            IfFailGo(m_pEmit->DefineCustomAttribute(m_tdTypeDef, tkAttr, PTROF_CUSTOM_ATTRIBUTE(),SIZEOF_CUSTOM_ATTRIBUTE(),0));
        }

    }
    
    if (bConversionLoss)
        hr = S_CONVERSION_LOSS;
    else
        hr = S_OK;
        
#if defined(TLB_STATS)
    LARGE_INTEGER __stopVal;
    QueryPerformanceCounter(&__stopVal);
    DWORD __delta;
    __delta = (DWORD)(__stopVal.QuadPart - __startVal.QuadPart);
    swprintf(rcStats, L"  %.2f", 
            ((float)__delta*1000)/(float)m_freqVal.QuadPart);
#endif
    
    // Report that this type has been converted.
    ReportEvent(NOTIF_TYPECONVERTED, TLBX_I_TYPEINFO_IMPORTED, m_szName);
    
ErrExit:
    if (pITI2)
        pITI2->Release();
    if (m_szName)
        ::SysFreeString(m_szName), m_szName = 0;
    if (bstrManagedName)
        ::SysFreeString(bstrManagedName);
    return (hr);
} // HRESULT CImportTlb::ConvertTypeInfo()

//*****************************************************************************
// Determine if the type explicitly implements IEnumerable.
//*****************************************************************************
HRESULT CImportTlb::ExplicitlyImplementsIEnumerable(
    ITypeInfo   *pITI,                  // ITypeInfo* to check for IEnumerable.
    TYPEATTR    *psAttr,                // TYPEATTR of TypeInfo.
    BOOL        fLookupPartner)         // Flag indicating if we should look at the partner itf.
{
    HREFTYPE    href;                   // HREFTYPE of an implemented interface.
    ITypeInfo   *pItiIface=0;           // ITypeInfo for an interface.
    TYPEATTR    *psAttrIface=0;         // TYPEATTR for an interface.
    BOOL        fFoundImpl = FALSE;
    int         i = 0;
    HRESULT     hr = S_OK;
    int         ImplFlags = 0;
    
    // Look through each of the implemented/inherited interfaces
    for (i=0; i<psAttr->cImplTypes && !fFoundImpl; ++i)
    {
        // Get an interface
        IfFailGo(pITI->GetRefTypeOfImplType(i, &href));
        IfFailGo(pITI->GetRefTypeInfo(href, &pItiIface));
        IfFailGo(pItiIface->GetTypeAttr(&psAttrIface));
        IfFailGo(pITI->GetImplTypeFlags(i, &ImplFlags));

        if (!(ImplFlags & IMPLTYPEFLAG_FSOURCE))
        {
            hr = ExplicitlyImplementsIEnumerable(pItiIface, psAttrIface, TRUE);
            if (hr == S_OK)
                fFoundImpl = TRUE;
            
            // Check this interface for the IEnumerable.
            if (psAttrIface->guid == IID_IEnumerable)
                fFoundImpl = TRUE;
        }

        pItiIface->ReleaseTypeAttr(psAttrIface);
        psAttrIface = 0;
        pItiIface->Release();
        pItiIface = 0;
    }

    if ( fLookupPartner && (pITI->GetRefTypeOfImplType(-1, &href) == S_OK) )
    {
        IfFailGo(pITI->GetRefTypeInfo(href, &pItiIface));
        IfFailGo(pItiIface->GetTypeAttr(&psAttrIface));

        hr = ExplicitlyImplementsIEnumerable(pItiIface, psAttrIface, FALSE);
        if (hr == S_OK)
            fFoundImpl = TRUE;
        
        // Check this interface for the IEnumerable.
        if (psAttrIface->guid == IID_IEnumerable)
            fFoundImpl = TRUE;   
    }


ErrExit:
    if (psAttrIface)
        pItiIface->ReleaseTypeAttr(psAttrIface);
    if (pItiIface)
        pItiIface->Release();
    
    return (fFoundImpl) ? S_OK : S_FALSE;
}


//*****************************************************************************
// Convert the details for a coclass.
//*****************************************************************************
HRESULT CImportTlb::ConvCoclass(        // S_OK or error.
    ITypeInfo   *pITI,                  // ITypeInfo* to convert.
    TYPEATTR    *psAttr)                // TYPEATTR of TypeInfo.
{
    BOOL        fHadDefaultItf = FALSE;
    HRESULT     hr;                     // A result.
    int         i;                      // Loop control.
    HREFTYPE    href;                   // HREFTYPE of an implemented interface.
    ITypeInfo   *pItiIface=0;           // ITypeInfo for an interface.
    TYPEATTR    *psAttrIface=0;         // TYPEATTR for an interface.
    int         ImplFlags;              // ImplType flags.
    mdToken     tkIface;                // Token for an interface.
    CQuickArray<mdToken> rImpls;        // Array of implemented interfaces.
    CQuickArray<mdToken> rEvents;       // Array of implemented event interfaces.
    CQuickArray<mdToken> rTmpImpls;     // Temporary array of impls.
    CQuickArray<ITypeInfo*> rImplTypes; // Array of implemented ITypeInfo*s.
    CQuickArray<ITypeInfo*> rSrcTypes;  // Array of source ITypeInfo*s.
    int         ixSrc;                  // Index into rSrcTypes for source interfaces.
    int         ixImpl;                 // Index into rImpls for implemented interface.
    int         ixTmpImpl;              // Index into rTmpImpls.
    mdToken     mdCtor;                 // Dummy token for the object initializer.
    mdToken     tkAttr;                 // Token for custom attribute type.
    mdToken     token;                  // Dummy token for typeref.
    BOOL        fInheritsIEnum = FALSE;

#ifdef _DEBUG
    int         bImplIEnumerable=0;     // If true, the class implements IEnumerable.
#endif

    // Size the rImpls and rSrcs arrays large enough for impls, events, the IEnumerable itf and two ending nulls.
    IfFailGo(rImpls.ReSize(psAttr->cImplTypes+2));
    memset(rImpls.Ptr(), 0, (psAttr->cImplTypes+2)*sizeof(mdToken));
    IfFailGo(rEvents.ReSize(psAttr->cImplTypes+1));
    memset(rEvents.Ptr(), 0, (psAttr->cImplTypes+1)*sizeof(mdToken));
    IfFailGo(rTmpImpls.ReSize(psAttr->cImplTypes+3));
    memset(rTmpImpls.Ptr(), 0, (psAttr->cImplTypes+3)*sizeof(mdToken));    
    IfFailGo(rImplTypes.ReSize(psAttr->cImplTypes+2));
    memset(rImplTypes.Ptr(), 0, (psAttr->cImplTypes+2)*sizeof(ITypeInfo*));
    IfFailGo(rSrcTypes.ReSize(psAttr->cImplTypes+1));
    memset(rSrcTypes.Ptr(), 0, (psAttr->cImplTypes+1)*sizeof(ITypeInfo*));
    ixImpl = -1;
    ixSrc = -1;
    ixTmpImpl = -1;

    if (ExplicitlyImplementsIEnumerable(pITI, psAttr) == S_OK)
        fInheritsIEnum = TRUE;

    // Build the list of implemented and event interfaces.
    // The EE cares about implemented interfaces, so we convert them to actual
    //  tokens and add them to the typedef.  VB cares about event interfaces,
    //  but we are going to add a list of typeref names as a custom attribute.
    //  We can't build the list as we go along, because the default may not
    //  be the first event source.  So, we store tokens for the implemented
    //  interfaces, but ITypeInfo*s for the event sources.
    for (i=0; i<psAttr->cImplTypes; ++i)
    {
        IfFailGo(pITI->GetRefTypeOfImplType(i, &href));
        IfFailGo(pITI->GetRefTypeInfo(href, &pItiIface));
        IfFailGo(pItiIface->GetTypeAttr(&psAttrIface));
        IfFailGo(pITI->GetImplTypeFlags(i, &ImplFlags));
        
        // If the interface is derived from IUnknown, or not an interface, we can't use it as an interface.
        // Don't add explicit IUnknown or IDispatch.
        if ((IsIUnknownDerived(pItiIface, psAttrIface) != S_OK && psAttrIface->typekind != TKIND_DISPATCH) ||
            psAttrIface->guid == IID_IDispatch ||
            psAttrIface->guid == IID_IUnknown)
        {
            pItiIface->ReleaseTypeAttr(psAttrIface);
            psAttrIface = 0;
            pItiIface->Release();
            pItiIface = 0;
            continue;
        }     

        // Add the event to the impls list or the events list.
        if (ImplFlags & IMPLTYPEFLAG_FSOURCE)
        {
            // Get the token for the event interface.
            IfFailGo(_GetTokenForEventItf(pItiIface, &tkIface));

            // Add the source interface to the list of source interfaces.
            ++ixSrc;

            // If this is explicitly the default source interface...
            if (ImplFlags & IMPLTYPEFLAG_FDEFAULT)
            {   
                // Put the def source ITypeInfo at the head of the list of source
                // ITypeInfo's.
                for (int ix = ixSrc; ix > 0; --ix)
                {
                    rSrcTypes[ix] = rSrcTypes[ix-1];
                    rEvents[ix] = rEvents[ix-1];
                }
                rEvents[0] = tkIface;
                rSrcTypes[0] = pItiIface;
            }
            else
            {
                rEvents[ixSrc] = tkIface;
                rSrcTypes[ixSrc] = pItiIface;
            }
        }
        else
        {   
            // Get the token for the interface.
            IfFailGo(_GetTokenForTypeInfo(pItiIface, FALSE, &tkIface));
    
            // Add the implemented interface to the list of implemented interfaces.
            ++ixImpl;

            // If this is explicitly the default interface...
            if (ImplFlags & IMPLTYPEFLAG_FDEFAULT)
            {   
                fHadDefaultItf = TRUE;
                // Put the new interface at the start of the list.
                for (int ix=ixImpl; ix > 0; --ix)
                {
                    rImpls[ix] = rImpls[ix-1];
                    rImplTypes[ix] = rImplTypes[ix-1];
                }
                rImpls[0] = tkIface;
                rImplTypes[0] = pItiIface;
            }
            else
            {
                rImpls[ixImpl] = tkIface;
                rImplTypes[ixImpl] = pItiIface;
            }
        }

        pItiIface->ReleaseTypeAttr(psAttrIface);
        psAttrIface = 0;
        pItiIface = 0;  // Pointer now owned by array.
    }

    // Create an interface that will represent the class.
    IfFailGo(_CreateClassInterface(pITI, rImplTypes[0], rImpls[0], rEvents[0], &tkIface));

    // Create a temporary array of interface tokens.
    if (fHadDefaultItf)
    {
        // default interface should be the first interface
        rTmpImpls[++ixTmpImpl] = rImpls[0];
        rTmpImpls[++ixTmpImpl] = tkIface;
    }
    else
    {        
        rTmpImpls[++ixTmpImpl] = tkIface;
        if (ixImpl >= 0)
            rTmpImpls[++ixTmpImpl] = rImpls[0];
    }
    if (ixSrc >= 0)
        rTmpImpls[++ixTmpImpl] = rEvents[0];
    if (ixImpl >= 0)
    {
        memcpy(&rTmpImpls[ixTmpImpl + 1], &rImpls[1], ixImpl * sizeof(mdTypeRef));
        ixTmpImpl += ixImpl;
    }
    if (ixSrc >= 0)
    {
        memcpy(&rTmpImpls[ixTmpImpl + 1], &rEvents[1], ixSrc * sizeof(mdTypeRef));
        ixTmpImpl += ixSrc;
    }

    // Check to see if the default interface has a member with a DISPID of DISPID_NEWENUM.
    BOOL fIEnumFound = FALSE;
    if (ixImpl >= 0)
    {
        // The ITypeInfo for the default interface had better be set.
        _ASSERTE(rImplTypes[0]);
        
        if ( (!fInheritsIEnum) && (HasNewEnumMember(rImplTypes[0]) == S_OK) )
        {
            IfFailGo(GetKnownTypeToken(VT_SLOT_FOR_IENUMERABLE, &tkIface));
            rTmpImpls[++ixTmpImpl] = tkIface;
            fIEnumFound = TRUE;
        }
    }

    // Else Check to see if the IEnumerable Custom Value exists on the CoClass.
    if (!fIEnumFound)
    {
        BOOL CVExists = FALSE;
        _ForceIEnumerableCVExists(pITI, &CVExists);
        if (CVExists && !fInheritsIEnum)
        {
            IfFailGo(GetKnownTypeToken(VT_SLOT_FOR_IENUMERABLE, &tkIface));
            rTmpImpls[++ixTmpImpl] = tkIface;
            fIEnumFound = TRUE;
        }
    }

    // Add the implemented interfaces and event interfaces to the TypeDef.
    IfFailGo(m_pEmit->SetTypeDefProps(m_tdTypeDef, ULONG_MAX/*Classflags*/, 
        ULONG_MAX, (mdToken*)rTmpImpls.Ptr()));

    // Create an initializer for the class.  
    ULONG ulFlags;
    if (psAttr->wTypeFlags & TYPEFLAG_FCANCREATE)
        ulFlags = OBJECT_INITIALIZER_FLAGS;
    else
        ulFlags = NONCREATABLE_OBJECT_INITIALIZER_FLAGS;
    {
        IfFailGo(m_pEmit->DefineMethod(m_tdTypeDef, OBJECT_INITIALIZER_NAME, ulFlags,
            OBJECT_INITIALIZER_SIG, sizeof(OBJECT_INITIALIZER_SIG), 0/*rva*/, OBJECT_INITIALIZER_IMPL_FLAGS/*flags*/, &mdCtor));
    }
    
    // Set ClassInterfaceType.None on the generated class.
    DECLARE_CUSTOM_ATTRIBUTE(sizeof(short));
    BUILD_CUSTOM_ATTRIBUTE(short, clsIfNone);
    IfFailGo(GetAttrType(ATTR_CLASSINTERFACE, &tkAttr));
    FINISH_CUSTOM_ATTRIBUTE();
    IfFailGo(m_pEmit->DefineCustomAttribute(m_tdTypeDef, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));

    // Iterate over the implemented interfaces, and add the members to the coclass.
    m_ImplIface = eImplIfaceDefault;
    for (i=0; i<=ixImpl; ++i)
    {   
        _ASSERTE(rImplTypes[i]);

        // Interface info.
        m_tkInterface = rImpls[i];
        pItiIface = rImplTypes[i];
        rImplTypes[i] = 0; // ownership transferred.
        
        // Get interface name for decoration.
        if (m_szInterface) 
            ::SysFreeString(m_szInterface), m_szInterface = 0;
        IfFailGo(pItiIface->GetDocumentation(MEMBERID_NIL, &m_szInterface, 0,0,0));

        // Add the interface members to the coclass.
        IfFailGo(pItiIface->GetTypeAttr(&psAttrIface));
        switch (psAttrIface->typekind)
        {
        case TKIND_DISPATCH:
            hr = ConvDispatch(pItiIface, psAttrIface, false);
            break;
        case TKIND_INTERFACE:
            hr = ConvIface(pItiIface, psAttrIface, false);
            break;
        default:
            hr = S_OK;
            _ASSERTE(!"Unexpected typekind for implemented interface");
        }
        pItiIface->ReleaseTypeAttr(psAttrIface);
        psAttrIface = 0;
        IfFailGo(hr);
        m_ImplIface = eImplIface;
        rImplTypes[i] = pItiIface;
        pItiIface = 0; // ownership transferred back.
    }

    // Add the methods of the event interfaces to the class.
    for (i=0; i<=ixSrc; ++i)
        IfFailGo(_AddSrcItfMembersToClass(rEvents[i]));

    // If there are source interfaces, add a custom value for that.
    if (ixSrc >= 0)
    {
        CQuickArray<char> rEvents;  // Output buffer.
        int cbCur;              // Current location in output buffer.
        int cbReq;              // Size of an individual piece.
        CQuickArray<WCHAR> rEvent;

        // Save 6 bytes at the beginning of the buffer for the custom attribute prolog and
        //  the string length.  The string length may require 1, 2, or 4 bytes to express.
        cbCur = 6;

        // For each event interface...
        for (int ix=0; ix <= ixSrc; ++ix)
        {
            pItiIface = rSrcTypes[ix];
            rSrcTypes[ix] = 0;

            // Get the typeref name for the interface.
            for(;;)
            {
                int cchReq;
                IfFailGo(_GetTokenForTypeInfo(pItiIface, FALSE, &token, rEvent.Ptr(), (int)rEvent.MaxSize(), &cchReq, TRUE));
                if (cchReq <= (int)rEvent.MaxSize())
                    break;
                IfFailGo(rEvent.ReSize(cchReq));
            }

            // Append to the buffer.  See how much space is required, get it.
            cbReq = WszWideCharToMultiByte(CP_UTF8,0, rEvent.Ptr(),-1, 0,0, 0,0);
            if (cbCur+cbReq+1 > (int)rEvents.MaxSize())
                IfFailGo(rEvents.ReSize(cbCur+cbReq+2));
            // Do the conversion.
            WszWideCharToMultiByte(CP_UTF8,0, rEvent.Ptr(),-1, rEvents.Ptr()+cbCur,cbReq, 0,0);
            cbCur += cbReq;
            pItiIface->Release();
        }
        pItiIface = 0;

        // Add an extra terminating 0.
        *(rEvents.Ptr()+cbCur) = 0;
        ++cbCur;

        // Now build the custom attribute.
        int iLen = cbCur - 6;
        char *pBytes = rEvents.Ptr();
        if (iLen < 0x7f)
            pBytes += 5, cbCur -= 3;
        else
        if (iLen < 0x3fff)
            pBytes += 4, cbCur -=2;
        else
            pBytes += 2;
        CPackedLen::PutLength(pBytes, iLen);
        pBytes -= 2;
        *(SHORT*)pBytes = 0x0001;
        *(USHORT*)(pBytes+cbCur) = 0;
        cbCur+=2;

        // Finally, store it.
        IfFailGo(GetAttrType(ATTR_COMSOURCEINTERFACES, &tkAttr));
        IfFailGo(m_pEmit->DefineCustomAttribute(m_tdTypeDef, tkAttr, pBytes, cbCur, 0));
    }

ErrExit:
    if (psAttrIface)
        pItiIface->ReleaseTypeAttr(psAttrIface);
    if (pItiIface)
        pItiIface->Release();
    // Clean up any left-over ITypeInfo*.
    for (ULONG ix=0; ix < rImplTypes.Size(); ++ix)
        if (rImplTypes[ix])
           (rImplTypes[ix])->Release();
    for (ULONG ix=0; ix < rSrcTypes.Size(); ++ix)
        if (rSrcTypes[ix])
           (rSrcTypes[ix])->Release();
    m_tkInterface = 0;
    if (m_szInterface)
        ::SysFreeString(m_szInterface), m_szInterface = 0;
    m_ImplIface = eImplIfaceNone;
    return (hr);
} // HRESULT CImportTlb::ConvCoclass()

//*****************************************************************************
// Convert an enum to a class with fields that have default values.
//*****************************************************************************
HRESULT CImportTlb::ConvEnum(           // S_OK or error.
    ITypeInfo   *pITI,                  // ITypeInfo* to convert.
    TYPEATTR    *psAttr)                // TYPEATTR of TypeInfo.
{
    HRESULT     hr;                     // A result.
    int         i;                      // Loop control.
    VARDESC     *psVar=0;               // VARDESC for a member.
    mdFieldDef  mdField;                // The FieldDef for the enum's type.

    // Create the field definition for the enum type.  Always import as an __int32.
    IfFailGo(m_pEmit->DefineField(m_tdTypeDef, ENUM_TYPE_NAME, ENUM_TYPE_FLAGS, ENUM_TYPE_SIGNATURE,ENUM_TYPE_SIGNATURE_SIZE, 
        0,0, -1, &mdField));

    // Iterate over the vars.
    for (i=0; i<psAttr->cVars; ++i)
    {
        // Get variable information.
        IfFailGo(pITI->GetVarDesc(i, &psVar));
        // Do the conversion.
        IfFailGo(_ConvConstant(pITI, psVar, true/*enum member*/));
        // Release for next var.
        pITI->ReleaseVarDesc(psVar);
        psVar = 0;
    }

    hr = S_OK;

ErrExit:
    if (psVar)
        pITI->ReleaseVarDesc(psVar);
    return (hr);
} // HRESULT CImportTlb::ConvEnum()

//*****************************************************************************
// Convert a record to a class with fields.
//*****************************************************************************
HRESULT CImportTlb::ConvRecord(         // S_OK or error.
    ITypeInfo   *pITI,                  // ITypeInfo* to convert.
    TYPEATTR    *psAttr,                // TYPEATTR of TypeInfo.
    BOOL        bUnion)                 // Convert as a union?
{
    HRESULT     hr=S_OK;                // A result.
    int         i;                      // Loop control.
    VARDESC     *psVar=0;               // VARDESC for a member.
    mdFieldDef  mdField;                // Token for a given field.
    CQuickArray<COR_FIELD_OFFSET> rLayout; // Array for layout information.
    BOOL        bConversionLoss=false;  // If true, some attributes were lost on conversion.

    // Unions with embedded Object Types can't really be converted.  Just reserve correct size.
    if (bUnion && (HasObjectFields(pITI, psAttr) == S_OK))
    {
        IfFailGo(m_pEmit->SetClassLayout(m_tdTypeDef, psAttr->cbAlignment, 0, psAttr->cbSizeInstance));
        goto ErrExit;
    }
    
    // Prepare for layout info.
    IfFailGo(rLayout.ReSize(psAttr->cVars+1));

    // Iterate over the vars.
    for (i=0; i<psAttr->cVars; ++i)
    {
        // Get variable information.
        IfFailGo(pITI->GetVarDesc(i, &psVar));
        // Do the conversion.
        IfFailGo(_ConvField(pITI, psVar, &mdField, bUnion));
        if (hr == S_CONVERSION_LOSS)
            bConversionLoss = true;
        // Save the layout info.
        rLayout[i].ridOfField = mdField;
        rLayout[i].ulOffset = psVar->oInst;
        // Release for next var.
        pITI->ReleaseVarDesc(psVar);
        psVar = 0;
    }

    // If it is a union, Save the layout information.
    if (bUnion)
    {
        rLayout[psAttr->cVars].ridOfField = mdFieldDefNil;
        IfFailGo(m_pEmit->SetClassLayout(m_tdTypeDef, psAttr->cbAlignment, rLayout.Ptr(), -1));
    }
    else // Not a union.  Preserve the alignment.
        IfFailGo(m_pEmit->SetClassLayout(m_tdTypeDef, psAttr->cbAlignment, 0, -1));

    if (bConversionLoss)
        hr = S_CONVERSION_LOSS;

ErrExit:
    if (psVar)
        pITI->ReleaseVarDesc(psVar);
    return (hr);
} // HRESULT CImportTlb::ConvRecord()

//*****************************************************************************
// Convert an module to a class with fields that have default values.
//  @FUTURE: convert methods as PInvoke methods.
//*****************************************************************************
HRESULT CImportTlb::ConvModule(         // S_OK or error.
    ITypeInfo   *pITI,                  // ITypeInfo* to convert.
    TYPEATTR    *psAttr)                // TYPEATTR of TypeInfo.
{
    HRESULT     hr;                     // A result.
    int         i;                      // Loop control.
    VARDESC     *psVar=0;               // VARDESC for a member.

    // Iterate over the vars.
    for (i=0; i<psAttr->cVars; ++i)
    {
        // Get variable information.
        IfFailGo(pITI->GetVarDesc(i, &psVar));
        // Do the conversion.
        IfFailGo(_ConvConstant(pITI, psVar));
        // Release for next var.
        pITI->ReleaseVarDesc(psVar);
        psVar = 0;
    }

    hr = S_OK;

ErrExit:
    if (psVar)
        pITI->ReleaseVarDesc(psVar);
    return (hr);
} // HRESULT CImportTlb::ConvModule()

//*****************************************************************************
// Convert metadata for an interface.
//*****************************************************************************
HRESULT CImportTlb::ConvIface(          // S_OK or error.
    ITypeInfo   *pITI,                  // ITypeInfo* to convert.
    TYPEATTR    *psAttr,                // TYPEATTR of TypeInfo.
    BOOL        bVtblGapFuncs)          // Vtable gap functions?
{
    HRESULT     hr;                     // A result.
    ITypeInfo   *pITIBase=0;            // ITypeInfo* of base interface.
    TYPEATTR    *psAttrBase=0;          // TYPEATTR of base interface.
    ITypeInfo   *pITISelf2=0;           // ITypeInfo* of partner.
    TYPEATTR    *psAttrSelf2=0;         // TYPEATTR of partner.
    mdToken     tkImpls[3]={0,0,0};     // Token of implemented interfaces.
    int         ixImpls = 0;            // Index of current implemented interface.
    HREFTYPE    href;                   // href of base interface.
    mdToken     tkIface;                // Token for an interface.
    BOOL        fInheritsIEnum = FALSE;
              
    // If there is a partner interface, prefer it.
    if (pITI->GetRefTypeOfImplType(-1, &href) == S_OK)
    {
        IfFailGo(pITI->GetRefTypeInfo(href, &pITISelf2));
        IfFailGo(pITISelf2->GetTypeAttr(&psAttrSelf2));
    }

    // Base interface?
    if (psAttr->cImplTypes == 1)
    {
        IfFailGo(pITI->GetRefTypeOfImplType(0, &href));
        IfFailGo(pITI->GetRefTypeInfo(href, &pITIBase));
        IfFailGo(pITIBase->GetTypeAttr(&psAttrBase));

        // If this interface extends something other than IDispatch or IUnknown, record that
        //  fact as an "implemented interface".
        if (psAttrBase->guid != IID_IDispatch && psAttrBase->guid != IID_IUnknown)
        {
            // Get Token of the base interface.
            IfFailGo(_GetTokenForTypeInfo(pITIBase, FALSE, &tkImpls[ixImpls++]));
        }
        else
        {   // Maybe we're "funky"...
            if (pITISelf2)
            {
                pITIBase->ReleaseTypeAttr(psAttrBase);
                pITIBase->Release();
                pITIBase = 0;
                psAttrBase = 0;

                if (psAttrSelf2->cImplTypes == 1)
                {
                    IfFailGo(pITISelf2->GetRefTypeOfImplType(0, &href));
                    IfFailGo(pITISelf2->GetRefTypeInfo(href, &pITIBase));
                    IfFailGo(pITIBase->GetTypeAttr(&psAttrBase));

                    if (psAttrBase->guid != IID_IDispatch && psAttrBase->guid != IID_IUnknown)
                    {
                        // Get Token of the base interface.
                        IfFailGo(_GetTokenForTypeInfo(pITIBase, FALSE, &tkImpls[ixImpls++]));
                    }
                }
            }
        }

        pITIBase->ReleaseTypeAttr(psAttrBase);
        psAttrBase = 0;
        pITIBase->Release();
        pITIBase = 0;
    }

    if (ExplicitlyImplementsIEnumerable(pITI, psAttr) == S_OK)
        fInheritsIEnum = TRUE;

    // If this interface has a NewEnum member then have it implement IEnumerable.
    if ( (!fInheritsIEnum) && (HasNewEnumMember(pITI) == S_OK) )
    {
        IfFailGo(GetKnownTypeToken(VT_SLOT_FOR_IENUMERABLE, &tkIface));
        tkImpls[ixImpls++] = tkIface;
    }

    // If not processing an implemented interface, add additional interface properties. 
    if (m_ImplIface == eImplIfaceNone)
    {
        // Set base interface as an implemented interface.
        if (tkImpls[0])
            IfFailGo(m_pEmit->SetTypeDefProps(m_tdTypeDef, ULONG_MAX/*flags*/, ULONG_MAX/*extends*/, tkImpls));

        // If the interface is not derived from IDispatch mark it as IUnknown based.
        if (IsIDispatchDerived(pITI, psAttr) == S_FALSE)
        {
            mdMemberRef mr;
            // Note that this is a vtable, but not IDispatch derived.
            // Custom attribute buffer.
            DECLARE_CUSTOM_ATTRIBUTE(sizeof(short));
            // Set up the attribute.
            BUILD_CUSTOM_ATTRIBUTE(short, ifVtable);
            // Store the attribute
            IfFailGo(GetAttrType(ATTR_INTERFACETYPE, &mr));
            FINISH_CUSTOM_ATTRIBUTE();
            IfFailGo(m_pEmit->DefineCustomAttribute(m_tdTypeDef, mr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));
        }
    }

    // Convert the members on the interface (and base interfaces).
    // If this interface had a "funky partner", base the conversion on that.
    if (pITISelf2)
        IfFailGo(_ConvIfaceMembers(pITISelf2, psAttrSelf2, bVtblGapFuncs, psAttr->wTypeFlags & TYPEFLAG_FDUAL, fInheritsIEnum));
    else
        IfFailGo(_ConvIfaceMembers(pITI, psAttr, bVtblGapFuncs, psAttr->wTypeFlags & TYPEFLAG_FDUAL, fInheritsIEnum));

ErrExit:
    if (psAttrSelf2)
        pITISelf2->ReleaseTypeAttr(psAttrSelf2);
    if (pITISelf2)
        pITISelf2->Release();
    if (psAttrBase)
        pITIBase->ReleaseTypeAttr(psAttrBase);
    if (pITIBase)
        pITIBase->Release();
    return (hr);
} // HRESULT CImportTlb::ConvIface()

//*****************************************************************************
// Convert the metadata for a dispinterface.  Try to convert as a normal
//  interface.
//*****************************************************************************
HRESULT CImportTlb::ConvDispatch(       // S_OK or error.
    ITypeInfo   *pITI,                  // ITypeInfo* to convert.
    TYPEATTR    *psAttr,                // TYPEATTR of TypeInfo.
    BOOL        bVtblGapFuncs)          // Vtable gap functions for interface implementations?
{
    HRESULT     hr;                     // A result.
    HREFTYPE    href;                   // Base interface href.
    ITypeInfo   *pITIBase=0;            // Base interface ITypeInfo.
    TYPEATTR    *psAttrBase=0;          // TYPEATTR of base interface.
    mdMemberRef mr;                     // MemberRef for custom value.
    DWORD       attr[2] = {0x00010001, 0x00000002};
    BYTE        bIface = ifDispatch;    // Custom value means "dispinterface"
    BOOL        fInheritsIEnum = FALSE;


    if (ExplicitlyImplementsIEnumerable(pITI, psAttr) == S_OK)
        fInheritsIEnum = TRUE;
    

    // If this is a dual interface, treat it like a normal interface.
    if ((psAttr->wTypeFlags & TYPEFLAG_FDUAL))
    {
        hr = ConvIface(pITI, psAttr, bVtblGapFuncs);
        goto ErrExit;
    }

    // If there is a vtable view of this interface (funky dispinterface).
    //  @FUTURE: what would be really nice here would be an alias mechanism, so that we could
    //   just point this dispinterface to that other interface, in those situations that it
    //   is dual.  OTOH, that is probably pretty rare, because if that other interface 
    //   were dual, why would the dispinterface even be needed?
    if (pITI->GetRefTypeOfImplType(-1, &href) == S_OK)
    {
        IfFailGo(pITI->GetRefTypeInfo(href, &pITIBase));
        IfFailGo(pITIBase->GetTypeAttr(&psAttrBase));

        IfFailGo(_ConvIfaceMembers(pITIBase, psAttrBase, bVtblGapFuncs, TRUE, fInheritsIEnum));
        pITIBase->ReleaseTypeAttr(psAttrBase);
        psAttrBase = 0;
        pITIBase->Release();
        pITIBase = 0;
        goto ErrExit;
    }

    // If not processing an implemented interface, mark the interface type.
    if (m_ImplIface == eImplIfaceNone)
    {
        // If this interface has a NewEnum member then have it implement IEnumerable.
        BOOL bHasNewEnumMember = FALSE;
        _ForceIEnumerableCVExists(pITI, &bHasNewEnumMember);
        
        if (bHasNewEnumMember && !fInheritsIEnum)
        {
            mdToken     tkImpl[2] = {0,0};
            IfFailGo(GetKnownTypeToken(VT_SLOT_FOR_IENUMERABLE, &tkImpl[0]));
            IfFailGo(m_pEmit->SetTypeDefProps(m_tdTypeDef, ULONG_MAX, ULONG_MAX, tkImpl));
        }

        // Note that this is a dispinterface.
        DECLARE_CUSTOM_ATTRIBUTE(sizeof(short));
        // Set up the attribute.
        BUILD_CUSTOM_ATTRIBUTE(short, ifDispatch);
        // Store the attribute
        IfFailGo(GetAttrType(ATTR_INTERFACETYPE, &mr));
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(m_tdTypeDef, mr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));
    }

    IfFailGo(_ConvDispatchMembers(pITI, psAttr, fInheritsIEnum));

ErrExit:
    if (psAttrBase)
        pITIBase->ReleaseTypeAttr(psAttrBase);
    if (pITIBase)
        pITIBase->Release();
    return (hr);
} // HRESULT CImportTlb::ConvDispatch()

//*****************************************************************************
// Determine if an interface is derived from IUnknown.
//*****************************************************************************
HRESULT CImportTlb::IsIUnknownDerived(
    ITypeInfo   *pITI,                  // The containing ITypeInfo.
    TYPEATTR    *psAttr)                // The ITypeInfo's TYPEATTR
{
    HRESULT     hr=S_OK;                // A result.

    HREFTYPE    href;                   // Base interface href.
    ITypeInfo   *pITIBase=0;            // Base interface ITypeInfo.
    TYPEATTR    *psAttrBase=0;          // TYPEATTR of base interface.

    // This should never be called on CoClasses.
    _ASSERTE(psAttr->typekind != TKIND_COCLASS);

    // If IDispatch or IUnknown, we've recursed far enough.
    if (IsEqualGUID(psAttr->guid, IID_IUnknown) || IsEqualGUID(psAttr->guid, IID_IDispatch))
    {
        goto ErrExit;
    }

    // Handle base interface.
    if (psAttr->cImplTypes == 1)
    {
        IfFailGo(pITI->GetRefTypeOfImplType(0, &href));
        IfFailGo(pITI->GetRefTypeInfo(href, &pITIBase));
        IfFailGo(pITIBase->GetTypeAttr(&psAttrBase));

        // IUnknow derived if base interface is.
        hr = IsIUnknownDerived(pITIBase, psAttrBase);
        pITIBase->ReleaseTypeAttr(psAttrBase);
        psAttrBase = 0;
        pITIBase->Release();
        pITIBase = 0;
    }
    else
    {   // No base interface, not IUnknown, not IDispatch.  Not very COM-ish, so don't try to handle.
        hr = S_FALSE;
    }

ErrExit:
    if (psAttrBase)
        pITIBase->ReleaseTypeAttr(psAttrBase);
    if (pITIBase)
        pITIBase->Release();
    return (hr);
} // HRESULT CImportTlb::IsIUnknownDerived()

//*****************************************************************************
// Determine if an interface is derived from IDispatch.  Note that a pure
//  dispinterface doesn't derive from IDispatch.
//*****************************************************************************
HRESULT CImportTlb::IsIDispatchDerived(
    ITypeInfo   *pITI,                  // The containing ITypeInfo.
    TYPEATTR    *psAttr)                // The ITypeInfo's TYPEATTR
{
    HRESULT     hr=S_OK;                // A result.

    HREFTYPE    href;                   // Base interface href.
    ITypeInfo   *pITIBase=0;            // Base interface ITypeInfo.
    TYPEATTR    *psAttrBase=0;          // TYPEATTR of base interface.

    // If IDispatch, we've recursed far enough.
    if (IsEqualGUID(psAttr->guid, IID_IDispatch))
    {
        goto ErrExit;
    }

    if (psAttr->typekind == TKIND_DISPATCH)
    {
        IfFailGo(pITI->GetRefTypeOfImplType(-1, &href));
        IfFailGo(pITI->GetRefTypeInfo(href, &pITIBase));
        IfFailGo(pITIBase->GetTypeAttr(&psAttrBase));

        // IDispatch derived if base interface is.
        hr = IsIDispatchDerived(pITIBase, psAttrBase);
        pITIBase->ReleaseTypeAttr(psAttrBase);
        psAttrBase = 0;
        pITIBase->Release();
        pITIBase = 0;
        
        goto ErrExit;
    }
    
    // Handle base interface.
    if (psAttr->cImplTypes == 1)
    {
        IfFailGo(pITI->GetRefTypeOfImplType(0, &href));
        IfFailGo(pITI->GetRefTypeInfo(href, &pITIBase));
        IfFailGo(pITIBase->GetTypeAttr(&psAttrBase));

        // IDispatch derived if base interface is.
        hr = IsIDispatchDerived(pITIBase, psAttrBase);
        pITIBase->ReleaseTypeAttr(psAttrBase);
        psAttrBase = 0;
        pITIBase->Release();
        pITIBase = 0;
    }
    else
    {   // No base interface, not IDispatch.  Done.
        hr = S_FALSE;
    }

ErrExit:
    if (psAttrBase)
        pITIBase->ReleaseTypeAttr(psAttrBase);
    if (pITIBase)
        pITIBase->Release();
    return (hr);
} // HRESULT CImportTlb::IsIDispatchDerived()

//*****************************************************************************
// Determine if an interface has a member with a DISPID of DISPID_NEWENUM.
//*****************************************************************************
HRESULT CImportTlb::HasNewEnumMember(   // S_OK if has NewEnum, S_FALSE otherwise.
    ITypeInfo   *pItfTI)                // The interface in question.
{
    HRESULT     hr = S_OK;              // A result.
    BOOL        bHasNewEnumMember=FALSE;// If true, has a NewEnum
    TYPEATTR    *pAttr = NULL;          // A TypeInfo's typeattr
    FUNCDESC    *pFuncDesc = NULL;      // A Function's FuncDesc
    VARDESC     *pVarDesc = NULL;       // A properties VarDesc
    int         i;                      // Loop control.
    ITypeInfo   *pITISelf2=0;           // Partner interface.
    HREFTYPE    href;                   // HREF of partner.
    WCHAR       IEnumCA[] = L"{CD2BC5C9-F452-4326-B714-F9C539D4DA58}";

    // If there is a partner interface, prefer it.
    if (pItfTI->GetRefTypeOfImplType(-1, &href) == S_OK)
    {
        IfFailGo(pItfTI->GetRefTypeInfo(href, &pITISelf2));
        pItfTI = pITISelf2;
    }

    // Retrieve the attributes of the interface.
    IfFailGo(pItfTI->GetTypeAttr(&pAttr));   

    if ((pAttr->typekind == TKIND_DISPATCH) || ((pAttr->typekind == TKIND_INTERFACE) && (IsIDispatchDerived(pItfTI, pAttr) == S_OK)))
    {
        // Check to see if the ForceIEnumerable custom value exists on the type
        _ForceIEnumerableCVExists(pItfTI, &bHasNewEnumMember);

        // Check to see if the interface has a function with a DISPID of DISPID_NEWENUM.
        for (i = 0; i < pAttr->cFuncs; i++)
        {
            IfFailGo(TryGetFuncDesc(pItfTI, i, &pFuncDesc));
            if (FuncIsNewEnum(pItfTI, pFuncDesc, i) == S_OK)
            {
                // Throw a warning if we find more than one func with DISPID_NEWENUM.
                if (bHasNewEnumMember == TRUE)
                {
                    BSTR ObjectName;
                    pItfTI->GetDocumentation(-1, &ObjectName, NULL, NULL, NULL);
                    ReportEvent(NOTIF_CONVERTWARNING, TLBX_E_INVALID_TYPEINFO, ObjectName);
                    SysFreeString(ObjectName);
                }

                // The interface has a function with a DISPID of DISPID_NEWENUM.
                bHasNewEnumMember = TRUE;
                break;
            }
            pItfTI->ReleaseFuncDesc(pFuncDesc);
            pFuncDesc = NULL;
        }

        // Check to see if the interface as a property with a DISPID of DISPID_NEWENUM.
        for (i = 0; i < pAttr->cVars; i++)
        {
            IfFailGo(pItfTI->GetVarDesc(i, &pVarDesc));
            if (PropertyIsNewEnum(pItfTI, pVarDesc, i) == S_OK)
            {
                // Throw a warning if we find more than one func with DISPID_NEWENUM.
                if (bHasNewEnumMember == TRUE)
                {
                    BSTR ObjectName;
                    pItfTI->GetDocumentation(-1, &ObjectName, NULL, NULL, NULL);
                    ReportEvent(NOTIF_CONVERTWARNING, TLBX_E_INVALID_TYPEINFO, ObjectName);
                    SysFreeString(ObjectName);
                }

                // The interface has a property with a DISPID of DISPID_NEWENUM.
                bHasNewEnumMember = TRUE;
                break;
            }
            pItfTI->ReleaseVarDesc(pVarDesc);
            pVarDesc = NULL;
        }
    }
    else
    {
        // Check to see if the ForceIEnumerable custom value exists on the type
        //  If it does, spit out a warning.
        _ForceIEnumerableCVExists(pItfTI, &bHasNewEnumMember);

        if (bHasNewEnumMember)
        {
            // Invalid custom attribute on the iface.
            BSTR CustomValue = SysAllocString((const WCHAR*)&IEnumCA[0]);
            BSTR ObjectName;
            pItfTI->GetDocumentation(-1, &ObjectName, NULL, NULL, NULL);
            
            ReportEvent(NOTIF_CONVERTWARNING, TLBX_W_IENUM_CA_ON_IUNK, CustomValue, ObjectName);

            SysFreeString(CustomValue);
            SysFreeString(ObjectName);

            bHasNewEnumMember = FALSE;
        }
    }

    hr = bHasNewEnumMember ? S_OK : S_FALSE;

ErrExit:
    if (pAttr)
        pItfTI->ReleaseTypeAttr(pAttr);
    if (pFuncDesc)
        pItfTI->ReleaseFuncDesc(pFuncDesc);
    if (pVarDesc)
        pItfTI->ReleaseVarDesc(pVarDesc);
    if (pITISelf2)
        pITISelf2->Release();
    return hr;
} // HRESULT CImportTlb::HasNewEnumMember(ITypeInfo *pItfTI)

//*****************************************************************************
// Determine if a given function is a valid NewEnum member.
//*****************************************************************************
HRESULT CImportTlb::FuncIsNewEnum(      // S_OK if the function is the NewEnum member S_FALSE otherwise.
    ITypeInfo *pITI,                    // The ITypeInfo that contains the function.                                    
    FUNCDESC *pFuncDesc,                // The function in question.
    DWORD index)                        // The function index
{

    HRESULT         hr = S_OK;
    BOOL            bIsValidNewEnum = FALSE;
    TYPEDESC*       pType = NULL;
    TYPEATTR*       pAttr = NULL;
    ITypeInfo*      pITIUD = NULL; 
    long            lDispSet = 0;
    
    _GetDispIDCA(pITI, index, &lDispSet, TRUE);

    if ((pFuncDesc->memid == DISPID_NEWENUM) || (lDispSet == DISPID_NEWENUM))
    {
        if (pFuncDesc->funckind == FUNC_DISPATCH)
        {
            if ((pFuncDesc->cParams == 0) &&
                ((pFuncDesc->invkind == INVOKE_PROPERTYGET) || (pFuncDesc->invkind == INVOKE_FUNC)))
            {
                pType = &pFuncDesc->elemdescFunc.tdesc;
            }
        }
        else if (pFuncDesc->funckind == FUNC_PUREVIRTUAL)
        {
            if ((pFuncDesc->cParams == 1) &&
                ((pFuncDesc->invkind == INVOKE_PROPERTYGET) || (pFuncDesc->invkind == INVOKE_FUNC)) &&
                (pFuncDesc->lprgelemdescParam[0].paramdesc.wParamFlags & PARAMFLAG_FRETVAL) &&
                (pFuncDesc->lprgelemdescParam[0].tdesc.vt == VT_PTR))
            {
                pType = pFuncDesc->lprgelemdescParam[0].tdesc.lptdesc;
            }
        }

        if (pType)
        {
            if (pType->vt == VT_UNKNOWN || pType->vt == VT_DISPATCH)
            {
                // The member returns an IUnknown * or an IDispatch * which is valid.
                bIsValidNewEnum = TRUE;
            }
            else if (pType->vt == VT_PTR)
            {
                pType =  pType->lptdesc;
                if (pType->vt == VT_USERDEFINED)
                {
                    IfFailGo(pITI->GetRefTypeInfo(pType->hreftype, &pITIUD));
                    IfFailGo(pITIUD->GetTypeAttr(&pAttr));
                    if (IsEqualGUID(pAttr->guid, IID_IEnumVARIANT) || 
                        IsEqualGUID(pAttr->guid, IID_IUnknown) ||
                        IsEqualGUID(pAttr->guid, IID_IDispatch))
                    {
                        // The member returns a valid interface type for a NewEnum member.
                        bIsValidNewEnum = TRUE;
                    }
                }
            }
        }
    }

ErrExit:
    if (pAttr)
        pITIUD->ReleaseTypeAttr(pAttr);
    if (pITIUD)
        pITIUD->Release();
    
    if (FAILED(hr))
        return hr;
    else 
        return bIsValidNewEnum ? S_OK : S_FALSE;
} // HRESULT CImportTlb::FuncIsNewEnum(FUNCDESC *pFuncDesc)

//*****************************************************************************
// Determine if a given function is a valid NewEnum member.
//*****************************************************************************
HRESULT CImportTlb::PropertyIsNewEnum(    // S_OK if the function is the NewEnum member S_FALSE otherwise.
    ITypeInfo *pITI,                      // The ITypeInfo that contains the property.
    VARDESC *pVarDesc,                    // The function in question.
    DWORD index)                          // The property index.
{
    HRESULT         hr = S_OK;
    BOOL            bIsValidNewEnum = FALSE;
    TYPEDESC*       pType = NULL;
    TYPEATTR*       pAttr = NULL;
    ITypeInfo*      pITIUD = NULL; 
    long            lDispSet = 0;

    _GetDispIDCA(pITI, index, &lDispSet, FALSE);
  
    if ( ((pVarDesc->memid == DISPID_NEWENUM) || (lDispSet == DISPID_NEWENUM)) && 
        (pVarDesc->elemdescVar.paramdesc.wParamFlags & PARAMFLAG_FRETVAL) &&
        (pVarDesc->wVarFlags & VARFLAG_FREADONLY))
    {
        pType = &pVarDesc->elemdescVar.tdesc;
        if (pType->vt == VT_UNKNOWN || pType->vt == VT_DISPATCH)
        {
            // The member returns an IUnknown * or an IDispatch * which is valid.
            bIsValidNewEnum = TRUE;
        }
        else if (pType->vt == VT_PTR)
        {
            pType =  pType->lptdesc;
            if (pType->vt == VT_USERDEFINED)
            {
                IfFailGo(pITI->GetRefTypeInfo(pType->hreftype, &pITIUD));
                IfFailGo(pITIUD->GetTypeAttr(&pAttr));
                if (IsEqualGUID(pAttr->guid, IID_IEnumVARIANT) || 
                    IsEqualGUID(pAttr->guid, IID_IUnknown) ||
                    IsEqualGUID(pAttr->guid, IID_IDispatch))
                {
                    // The member returns a valid interface type for a NewEnum member.
                    bIsValidNewEnum = TRUE;
                }
            }
        }
    }

ErrExit:
    if (pAttr)
        pITIUD->ReleaseTypeAttr(pAttr);
    if (pITIUD)
        pITIUD->Release();

    if (FAILED(hr))
        return hr;
    else 
        return bIsValidNewEnum ? S_OK : S_FALSE;
} // HRESULT CImportTlb::FuncIsNewEnum(FUNCDESC *pFuncDesc)

//*****************************************************************************
// Determine is a TypeInfo has any object fields.
//*****************************************************************************
HRESULT CImportTlb::HasObjectFields(    // S_OK, S_FALSE, or error.
    ITypeInfo   *pITI,                  // The TypeInfo in question.
    TYPEATTR    *psAttr)                // Attributes of the typeinfo.
{
    HRESULT     hr;                     // A result.
    
    int         i;                      // Loop control.
    VARDESC     *psVar=0;               // VARDESC for a member.

    // Iterate over the vars.
    for (i=0; i<psAttr->cVars; ++i)
    {
        // Get variable information.
        IfFailGo(pITI->GetVarDesc(i, &psVar));
        
        // See if it is an object type.
        IfFailGo(IsObjectType(pITI, &psVar->elemdescVar.tdesc));
        // If result is S_FALSE, not an Object; keep looking.
        if (hr == S_OK)
            goto ErrExit;
        
        // Release for next var.
        pITI->ReleaseVarDesc(psVar);
        psVar = 0;
    }

    hr = S_FALSE;    
    
ErrExit:
    if (psVar)
        pITI->ReleaseVarDesc(psVar);
    return hr;    
} // HRESULT CImportTlb::HasObjectFields()

//*****************************************************************************
// Is a given type an Object type?
//*****************************************************************************
HRESULT CImportTlb::IsObjectType(       // S_OK, S_FALSE, or error.
    ITypeInfo   *pITI,                  // The TypeInfo in question.
    const TYPEDESC *pType)              // The type.
{
    HRESULT     hr;                     // A result.
    TYPEDESC    tdTemp;                 // Copy of TYPEDESC, for R/W.
    ITypeInfo   *pITIAlias=0;           // Typeinfo of the aliased type.
    TYPEATTR    *psAttrAlias=0;         // TYPEATTR of the aliased typeinfo.
    int         bObjectField=false;     // The question to be answered.
    int         iByRef=0;               // Indirection.

    // Strip off leading VT_PTR and VT_BYREF
    while (pType->vt == VT_PTR)
        pType = pType->lptdesc, ++iByRef;
    if (pType->vt & VT_BYREF)
    {
        tdTemp = *pType;
        tdTemp.vt &= ~VT_BYREF;
        pType = &tdTemp;
        ++iByRef;
    }

    // Determine if the field is/has object type.
    switch (pType->vt)
    { 
    case VT_PTR:
        _ASSERTE(!"Should not have VT_PTR here");
        break;

    // These are object types.
    case VT_BSTR:
    case VT_DISPATCH:
    case VT_VARIANT:
    case VT_UNKNOWN:
    case VT_SAFEARRAY:
    case VT_LPSTR:
    case VT_LPWSTR:
        bObjectField = true;
        break;

    // A user-defined may or may not be/contain Object type.
    case VT_USERDEFINED:
        // User defined type.  Get the TypeInfo.
        IfFailGo(pITI->GetRefTypeInfo(pType->hreftype, &pITIAlias));
        IfFailGo(pITIAlias->GetTypeAttr(&psAttrAlias));

        // Some user defined class.  Is it a value class, or a VOS class?
        switch (psAttrAlias->typekind)
        {
        // Alias -- Is the aliased thing an Object type?
        case TKIND_ALIAS:
            hr = IsObjectType(pITIAlias, &psAttrAlias->tdescAlias);
            goto ErrExit;
        // Record/Enum/Union -- Does it contain an Object type?
        case TKIND_RECORD:
        case TKIND_ENUM:
        case TKIND_UNION:
            // Byref/Ptrto record is Object.  Contained record might be.
            if (iByRef)
                bObjectField = true;
            else
            {
                hr = HasObjectFields(pITIAlias, psAttrAlias);
                goto ErrExit;
            }
            break;
        // Class/Interface -- An Object Type.
        case TKIND_INTERFACE:
        case TKIND_DISPATCH:
        case TKIND_COCLASS:
            bObjectField = true;
            break;
        default:
            //case TKIND_MODULE: -- can't pass one of these as a parameter.
            _ASSERTE(!"Unexpected typekind for user defined type");
            bObjectField = true;
        } // switch (psAttrAlias->typekind)
        break;

    case VT_CY:
    case VT_DATE:
    case VT_DECIMAL:
        // Pointer to the value type is an object.  Contained one isn't.
        if (iByRef)
            bObjectField = true;
        else
            bObjectField = false;
        break;

    // A fixed array is an Object type.
    case VT_CARRAY:
        bObjectField = true;
        break;

    // Other types I4, etc., are not Object types.
    default:
        bObjectField = false;
        break;
    } // switch (vt=pType->vt)


    hr = bObjectField ? S_OK : S_FALSE;

ErrExit:
    if (psAttrAlias)
        pITIAlias->ReleaseTypeAttr(psAttrAlias);
    if (pITIAlias)
        pITIAlias->Release();

    return hr;
} // HRESULT CImportTlb::IsObjectType()

//*****************************************************************************
// Convert the functions on an interface.  Convert the functions on the
//  base interface first, because in COM Classic, parent's functions are also
//  in the derived interface's vtable.
//*****************************************************************************
HRESULT CImportTlb::_ConvIfaceMembers(
    ITypeInfo   *pITI,                  // The containing ITypeInfo.
    TYPEATTR    *psAttr,                // The ITypeInfo's TYPEATTR
    BOOL        bVtblGapFuncs,          // Add functions for vtblGaps?
    BOOL        bAddDispIds,            // Add DispIds to the member?
    BOOL        bInheritsIEnum)         // Inherits from IEnumerable.
{
    HRESULT     hr=S_OK;                // A result.
    int         i;                      // Loop control.
    FUNCDESC    *psFunc=0;              // FUNCDESC for a member.

    HREFTYPE    href;                   // Base interface href.
    ITypeInfo   *pITIBase=0;            // Base interface ITypeInfo.
    TYPEATTR    *psAttrBase=0;          // TYPEATTR of base interface.
    BOOL        bConversionLoss=false;  // If true, some attributes were lost on conversion.

    // If IDispatch or IUnknown, we've recursed far enough.
    if (IsEqualGUID(psAttr->guid, IID_IUnknown) || IsEqualGUID(psAttr->guid, IID_IDispatch))
    {
        m_Slot = (psAttr->cbSizeVft / sizeof(void*));
        goto ErrExit;
    }

    // Handle base interface.
    if (psAttr->cImplTypes == 1)
    {
        IfFailGo(pITI->GetRefTypeOfImplType(0, &href));
        IfFailGo(pITI->GetRefTypeInfo(href, &pITIBase));
        IfFailGo(pITIBase->GetTypeAttr(&psAttrBase));

        IfFailGo(_ConvIfaceMembers(pITIBase, psAttrBase, bVtblGapFuncs, bAddDispIds, bInheritsIEnum));
        pITIBase->ReleaseTypeAttr(psAttrBase);
        psAttrBase = 0;
        pITIBase->Release();
        pITIBase = 0;
    }
    else
    {   // No base interface, not IUnknown, not IDispatch.  We shouldn't be here.
        m_Slot = 0;
        _ASSERTE(!"Interface does not derive from IUnknown.");
    }

    // Loop over functions.
    IfFailGo(_FindFirstUserMethod(pITI, psAttr, &i));
    IfFailGo(BuildMemberList(pITI, i, psAttr->cFuncs, bInheritsIEnum));

    BOOL bAllowIEnum = !bInheritsIEnum;

    for (i=0; i<(int)m_MemberList.Size(); ++i)
    {
        // Convert the function.
        IfFailGo(_ConvFunction(pITI, &m_MemberList[i], bVtblGapFuncs, bAddDispIds, FALSE, &bAllowIEnum));
        if (hr == S_CONVERSION_LOSS)
            bConversionLoss = true;
    }

    // Add the property info.
    IfFailGo(_ConvPropertiesForFunctions(pITI, psAttr));
    
    if (bConversionLoss)
        hr = S_CONVERSION_LOSS;

ErrExit:
    // Release FuncDescs.
    FreeMemberList(pITI);

    if (psAttrBase)
        pITIBase->ReleaseTypeAttr(psAttrBase);
    if (pITIBase)
        pITIBase->Release();
    if (psFunc)
        pITI->ReleaseFuncDesc(psFunc);
    return (hr);
} // HRESULT CImportTlb::_ConvIfaceMembers()

//*****************************************************************************
// Convert the functions on a source interface to add_ and remove_ method.  
// Convert the functions on the base interface first, because in COM Classic, 
// parent's functions are also in the derived interface's vtable.
//*****************************************************************************
HRESULT CImportTlb::_ConvSrcIfaceMembers(
    ITypeInfo   *pITI,                  // The containing ITypeInfo.
    TYPEATTR    *psAttr,                // The ITypeInfo's TYPEATTR
    BOOL        fInheritsIEnum)
{
    HRESULT     hr=S_OK;                // A result.
    int         i;                      // Loop control.
    FUNCDESC    *psFunc=0;              // FUNCDESC for a member.

    HREFTYPE    href;                   // Base interface href.
    ITypeInfo   *pITIBase=0;            // Base interface ITypeInfo.
    TYPEATTR    *psAttrBase=0;          // TYPEATTR of base interface.
    BOOL        bConversionLoss=false;  // If true, some attributes were lost on conversion.

    // If IDispatch or IUnknown, we've recursed far enough.
    if (IsEqualGUID(psAttr->guid, IID_IUnknown) || IsEqualGUID(psAttr->guid, IID_IDispatch))
    {
        m_Slot = (psAttr->cbSizeVft / sizeof(void*));
        goto ErrExit;
    }

    // Handle base interface.
    if (psAttr->cImplTypes == 1)
    {
        IfFailGo(pITI->GetRefTypeOfImplType(0, &href));
        IfFailGo(pITI->GetRefTypeInfo(href, &pITIBase));
        IfFailGo(pITIBase->GetTypeAttr(&psAttrBase));

        IfFailGo(_ConvSrcIfaceMembers(pITIBase, psAttrBase, fInheritsIEnum));
        pITIBase->ReleaseTypeAttr(psAttrBase);
        psAttrBase = 0;
        pITIBase->Release();
        pITIBase = 0;
    }
    else
    {   // No base interface, not IUnknown, not IDispatch.  We shouldn't be here.
        m_Slot = 0;
        _ASSERTE(!"Interface does not derive from IUnknown.");
    }

    // Loop over functions.
    IfFailGo(_FindFirstUserMethod(pITI, psAttr, &i));
    IfFailGo(BuildMemberList(pITI, i, psAttr->cFuncs, fInheritsIEnum));
    for (i=0; i<(int)m_MemberList.Size(); ++i)
    {
        // Convert the function.
        IfFailGo(_GenerateEvent(pITI, &m_MemberList[i], fInheritsIEnum));
        if (hr == S_CONVERSION_LOSS)
            bConversionLoss = true;
    }
    
    if (bConversionLoss)
        hr = S_CONVERSION_LOSS;

ErrExit:
    // Release FuncDescs.
    FreeMemberList(pITI);

    if (psAttrBase)
        pITIBase->ReleaseTypeAttr(psAttrBase);
    if (pITIBase)
        pITIBase->Release();
    if (psFunc)
        pITI->ReleaseFuncDesc(psFunc);
    return (hr);
} // HRESULT CImportTlb::_ConvIfaceMembers()

//*****************************************************************************
// Add the property definitions for property functions.
//*****************************************************************************
HRESULT CImportTlb::_ConvPropertiesForFunctions(
    ITypeInfo   *pITI,                  // ITypeInfo* being converted.
    TYPEATTR    *psAttr)                // TypeAttr for the typeinfo.
{
    HRESULT     hr=S_OK;                // A result.
    int         ix;                     // Loop control.
    int         ix2;                    // More loop control.
    mdProperty  pd;                     // A property token.
    USHORT      ms;                     // Some method's semantics.
    mdToken     tk;                     // A method's token.
    mdMethodDef mdFuncs[6] ={0};        // Array of setter, getter, other.
    FUNCDESC    *psF=0;                 // FUNCDESC of Get, Put, or PutRef.
    TYPEDESC    *pProperty;             // TYPEDESC of property type.
    BOOL        bPropRetval;            // Is the property type a [retval]?
    ULONG       ixValue;                // Index of the value parameter for putters.
    int         ixVarArg;               // Index of vararg param, if any.
    CQuickBytes qbComSig;               // new signature 
    BYTE        *pbSig;                 // Pointer into the signature.
    ULONG       sigFlags;               // Signature handling flags.
    ULONG       cbTotal;                // Size of the signature.
    ULONG       cb;                     // Size of a signature element.
    LPWSTR      pszName;                // Possibly decorated name of property.
    CQuickArray<WCHAR> qbName;          // Buffer for name decoration.
    int         iSrcParam;              // Param count, as looping through params.
    int         cDestParams;            // Count of destination params.
    CQuickArray<BYTE> qbDummyNativeTypeBuf; // A dummy native type array.
    ULONG       iNativeOfs=0;           // Current offset in native type buffer.
    BOOL        bNewEnumMember=FALSE;   // Is this a NewEnum property?
    BOOL        bConversionLoss=FALSE;  // Was some type not fully converted?    
    int         cFound;                 // Functions found matching a given property.
    
    // Using semantics as an index, so be sure array is big enough.
    _ASSERTE(lengthof(mdFuncs) > msOther);
    
    for (ix=m_cMemberProps; ix<(int)m_MemberList.Size(); ++ix)
    {   // See if this one needs to be processed.
        if (m_MemberList[ix].m_mdFunc == 0)
            continue;
        
        MemberInfo *pMember = &m_MemberList[ix];
        pMember->GetFuncInfo(tk, ms);
        
        // Get the name.
        if (m_szMember)
            ::SysFreeString(m_szMember), m_szMember = 0;
        IfFailGo(pITI->GetDocumentation(pMember->m_psFunc->memid, &m_szMember, 0,0,0));
        
        // Found one.  Put in the right slot.
        _ASSERTE(ms == msGetter || ms == msSetter || ms==msOther);
        mdFuncs[msSetter] = mdFuncs[msGetter] = mdFuncs[msOther] = 0;
        mdFuncs[ms] = tk;
        pMember->m_mdFunc = 0;
        
        // Look for related functions.
        cFound = 1;
        for (ix2=ix+1; ix2<(int)m_MemberList.Size(); ++ix2)
        {
            MemberInfo *pMember2 = &m_MemberList[ix2];
            if (pMember2->m_mdFunc != 0 && pMember2->m_psFunc->memid == pMember->m_psFunc->memid)
            {   // Found a related function.
                pMember2->GetFuncInfo(tk, ms);
                _ASSERTE(ms == msGetter || ms == msSetter || ms==msOther);
                _ASSERTE(mdFuncs[ms] == 0);
                mdFuncs[ms] = tk;
                pMember2->m_mdFunc = 0;
                // If have found all three, don't bother looking for more.
                if (++cFound == 3)
                    break;
            }
        }
        
        // Build the signature for the property.
        hr = _GetFunctionPropertyInfo(pMember->m_psFunc, &ms, &psF, &pProperty, &bPropRetval);
        
        // The function really should have a property associated with it, to get here.  Check anyway.
        _ASSERTE(pProperty);
        if (!pProperty)
            continue;

        // Some sort of property accessor.
        IfFailGo(qbComSig.ReSize(CB_MAX_ELEMENT_TYPE + 1));
        pbSig = (BYTE *)qbComSig.Ptr();
        cbTotal = cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_PROPERTY, pbSig);
        // Count of parameters.
        
        // If this is a getter, see if there is a retval.
        if (psF->invkind == INVOKE_PROPERTYGET)
        {   // Examine each param, and count all except the [retval].
            for (cDestParams=iSrcParam=0; iSrcParam<psF->cParams; ++iSrcParam)
            {
                if ((psF->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & NON_CONVERTED_PARAMS_FLAGS) == 0)
                    ++cDestParams;
            }
            // There is no new value param for getters.
            ixValue = -1;
        }
        else
        {   
            // This is a putter, so 1 param is new value, others are indices (or lcid).
            for (cDestParams=iSrcParam=0; iSrcParam<psF->cParams-1; ++iSrcParam)
            {
                if ((psF->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & NON_CONVERTED_PARAMS_FLAGS) == 0)
                    ++cDestParams;
            }            
            // The last parameter is the new value.
            ixValue = psF->cParams - 1;
        }

        //-------------------------------------------------------------------------
        // See if there is a vararg param.
        ixVarArg = psF->cParams + 1;
        if (psF->cParamsOpt == -1)
        {
            // If this is a PROPERTYPUT or PROPERTYPUTREF, skip the last non-retval parameter (it
            //  is the new value to be set).
            BOOL bPropVal = (psF->invkind & (INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF)) ? TRUE : FALSE;
            // Find the vararg param.
            for (iSrcParam=psF->cParams-1; iSrcParam>=0; --iSrcParam)
            {
                // The count of optional params does not include any lcid params, nor does
                //  it include the return value, so skip those.
                if ((psF->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & (PARAMFLAG_FRETVAL|PARAMFLAG_FLCID)) != 0)
                    continue;
                // If haven't yet seen the property value, this param is it, so skip it, too.
                if (bPropVal)
                {
                    bPropVal = FALSE;
                    continue;
                }
                ixVarArg = iSrcParam;
                break;
            } // for (iSrcParam=cParams-1...
        }
        
        // Put in the count of index parameters.
        _ASSERTE(cDestParams >= 0);
        cb = CorSigCompressData(cDestParams, &pbSig[cbTotal]);
        cbTotal += cb;

        // Create the signature for the property type.
        sigFlags = SIG_ELEM | (bPropRetval ? SIG_RET : (SigFlags)0);
        IfFailGo(_ConvSignature(pITI, pProperty, sigFlags, qbComSig, cbTotal, &cbTotal, qbDummyNativeTypeBuf, 0, &iNativeOfs, bNewEnumMember));
        if (hr == S_CONVERSION_LOSS)
            bConversionLoss = true;

        // Fill in the "index" part of the property's signature.
        for (iSrcParam=0; iSrcParam<psF->cParams; ++iSrcParam)
        {
            if (psF->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & NON_CONVERTED_PARAMS_FLAGS)
                continue;
            if (iSrcParam == static_cast<int>(ixValue))
                continue;
            sigFlags = SIG_FUNC | SIG_USE_BYREF;
            if (iSrcParam == ixVarArg)
                sigFlags |= SIG_VARARG;
            IfFailGo(_ConvSignature(pITI, &psF->lprgelemdescParam[iSrcParam].tdesc, sigFlags, qbComSig, cbTotal, &cbTotal, qbDummyNativeTypeBuf, 0, &iNativeOfs, bNewEnumMember));
            if (hr == S_CONVERSION_LOSS)
                bConversionLoss = true;
        }

        // Get the property name.  Add interface name and make unique, if needed.
        // m_szInterface should be non-null if processing an implemented interface; should be null otherwise.
        _ASSERTE(m_ImplIface == eImplIfaceNone || m_szInterface != 0);
        IfFailGo(qbName.ReSize(wcslen(m_szMember)+2));
        wcscpy(qbName.Ptr(), m_szMember); 
        IfFailGo(GenerateUniqueMemberName(qbName, (PCCOR_SIGNATURE)qbComSig.Ptr(), cbTotal, m_szInterface, mdtProperty));
        pszName = qbName.Ptr();

        // Define the property.
        IfFailGo(m_pEmit->DefineProperty(m_tdTypeDef, pszName, 0/*dwFlags*/, 
                        (PCCOR_SIGNATURE) qbComSig.Ptr(), cbTotal, 0, 0, -1, 
                        mdFuncs[msSetter], mdFuncs[msGetter], &mdFuncs[msOther], 
                        &pd));

        // Handle dispids for non-implemented interfaces, and for default interface
        if (m_ImplIface != eImplIface)
        {
            // Set the dispid CA on the property.
            long lDispSet = 1;
            _SetDispIDCA(pITI, pMember->m_iMember, psF->memid, pd, TRUE, &lDispSet, TRUE);

            // If this property is default property, add a custom attribute to the class.
            if (lDispSet == DISPID_VALUE)
                IfFailGo(_AddDefaultMemberCa(m_tdTypeDef, m_szMember));
        }
        
        // Add the alias information if the type is an alias.
        IfFailGo(_HandleAliasInfo(pITI, pProperty, pd));
    }
    
    if (bConversionLoss)
        hr = S_CONVERSION_LOSS;

ErrExit:    
    if (m_szMember)
        ::SysFreeString(m_szMember), m_szMember=0;
    
    return hr;
} // HRESULT CImportTlb::_ConvPropertiesForFunctions()

//*****************************************************************************
// Convert the vars and functions of a dispinterface.  Vars actually turn
//  into a getter and possibly a setter.
//*****************************************************************************
HRESULT CImportTlb::_ConvDispatchMembers(
    ITypeInfo   *pITI,                  // ITypeInfo* to convert.
    TYPEATTR    *psAttr,                // TypeAttr of ITypeInfo.
    BOOL        fInheritsIEnum)
{
    HRESULT     hr;                     // A result.
    int         i;                      // Loop control.
    BOOL        bConversionLoss=FALSE;  // If true, some attributes were lost on conversion.

    IfFailGo(_FindFirstUserMethod(pITI, psAttr, &i));
    IfFailGo(BuildMemberList(pITI, i, psAttr->cFuncs, fInheritsIEnum));
    
    // Dispatch members really have no slot.
    m_Slot = 0;

    // Loop over properties.
    for (i=0; i<m_cMemberProps; ++i)
    {
        IfFailGo(_ConvProperty(pITI, &m_MemberList[i]));
    }

    // Loop over functions.
    BOOL bAllowIEnum = !fInheritsIEnum;
    for (; i<(int)m_MemberList.Size(); ++i)
    {
        // Get variable information.
        IfFailGo(_ConvFunction(pITI, &m_MemberList[i], FALSE, TRUE, FALSE, &bAllowIEnum));
        if (hr == S_CONVERSION_LOSS)
            bConversionLoss = TRUE;
    }

    // Add the property info.
    IfFailGo(_ConvPropertiesForFunctions(pITI, psAttr));
    
    if (bConversionLoss)
        hr = S_CONVERSION_LOSS;

ErrExit:
    // Free the func descs.
    FreeMemberList(pITI);

    return (hr);
} // HRESULT CImportTlb::_ConvDispatchMembers()

//*****************************************************************************
// Examine the functions on an interface, and skip the first 3 or first 7
//  if the functions are IUnknown or IDispatch members.
//*****************************************************************************
HRESULT CImportTlb::_FindFirstUserMethod(
    ITypeInfo   *pITI,                  // The Typedef to examine.
    TYPEATTR    *psAttr,                // TYPEATTR for the typedef.
    int         *pIx)                   // Put index of first user function here.
{
    HRESULT     hr = S_OK;              // A result.
    int         i;                      // Loop control.
    FUNCDESC    *psFunc=0;              // FUNCDESC for a member.
    BSTR        szName=0;               // A function's name.

    // Note:  this is a terrible hack, but in some situations the methods from IUnknown / IDispatch will
    //  show up as though native dispatch functions.
    i = 0;
    if (psAttr->cFuncs >= 3)
    {
        IfFailGo(TryGetFuncDesc(pITI, i, &psFunc));
        if (psFunc->memid == 0x60000000 &&
            psFunc->elemdescFunc.tdesc.vt == VT_VOID &&
            psFunc->cParams == 2 &&
            psFunc->lprgelemdescParam[0].tdesc.vt == VT_PTR && // -> VT_USERDEFINED
            psFunc->lprgelemdescParam[1].tdesc.vt == VT_PTR && // -> VT_PTR -> VT_VOID
            SUCCEEDED(pITI->GetDocumentation(psFunc->memid, &szName, 0,0,0)) &&
            (wcscmp(szName, L"QueryInterface") == 0) )
                i = 3;
        pITI->ReleaseFuncDesc(psFunc);
        psFunc=0;
        if (szName)
            ::SysFreeString(szName);
        szName = 0;
        if (psAttr->cFuncs >= 7)
        {
            IfFailGo(TryGetFuncDesc(pITI, i, &psFunc));
            if (psFunc->memid == 0x60010000 &&
                psFunc->elemdescFunc.tdesc.vt == VT_VOID &&
                psFunc->cParams == 1 &&
                psFunc->lprgelemdescParam[0].tdesc.vt == VT_PTR && // -> VT_UINT
                SUCCEEDED(pITI->GetDocumentation(psFunc->memid, &szName, 0,0,0)) &&
                (wcscmp(szName, L"GetTypeInfoCount") == 0) )
                    i = 7;
            pITI->ReleaseFuncDesc(psFunc);
            psFunc=0;
            if (szName)
                ::SysFreeString(szName);
            szName = 0;
        }
    }

    *pIx = i;

ErrExit:
    if (psFunc)
        pITI->ReleaseFuncDesc(psFunc);
    if (szName)
        ::SysFreeString(szName);
    return (hr);
} // HRESULT CImportTlb::_FindFirstUserMethod()

//*****************************************************************************
// Given a FUNCDESC that is has INVOKE_PROPERTY* decoration, determine
//  the role of the function, and the property signature type.
//*****************************************************************************
HRESULT CImportTlb::_GetFunctionPropertyInfo(
    FUNCDESC    *psFunc,                // Function for which to get info.
    USHORT      *pSemantics,            // Put appropriate semantics here.
    FUNCDESC    **ppSig,                // Put FUNCDESC for signature here.
    TYPEDESC    **ppProperty,           // Put TYPEDESC for return here.
    BOOL        *pbRetval)              // If true, the type is [retval]
{
    FUNCDESC    *psTmp;                 // FUNCDESC for some method.
    FUNCDESC    *psGet=0;               // FUNCDESC for Get method defining a property.
    FUNCDESC    *psPut=0;               // FUNCDESC for Put method defining a property.
    FUNCDESC    *psPutRef=0;            // FUNCDESC for PutRef method defining a property.
    FUNCDESC    *psF;                   // A FUNCDESC.
    TYPEDESC    *pReturn=0;             // The FUNCDESC's return type.
    int         cFound=0;               // Count of functions found.
    int         i;                      // Loop control.

    if (psFunc->invkind & INVOKE_PROPERTYGET)
    {   // A "Get", so return type is property type.
        *ppSig = psFunc;
        *pSemantics = msGetter;
    }
    else
    {   
        _ASSERTE(psFunc->invkind & (INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF));
        // Search for the "best" method from which to grab the signature.  We prefer the Get(),
        //  Followed by the Put(), followed by the PutRef()
        // Also look for Put() and PutRef(), so we can 
        for (int iFunc=0; iFunc<(int)m_MemberList.Size() && cFound<3; ++iFunc)
        {
            // Get a FUNCDESC from the list.
            psTmp = m_MemberList[iFunc].m_psFunc;

            // Is it for the same func?
            if (psTmp->memid != psFunc->memid)
                continue;

            // Is it the Get()?  If so, it is the one we want.
            if (psTmp->invkind & INVOKE_PROPERTYGET)
            {
                psGet = psTmp;
                ++cFound;
                continue;
            }

            // Is it the Put()?  Use it if we don't find a Get().
            if (psTmp->invkind & INVOKE_PROPERTYPUT)
            {
                psPut = psTmp;
                ++cFound;
                continue;
            }

            // Is it the PutRef()?  Keep track of it.
            if (psTmp->invkind & INVOKE_PROPERTYPUTREF)
            {
                psPutRef = psTmp;
                ++cFound;
            }
        }
        // Get the best FUNCDESC for the signature.
        *ppSig = psGet ? psGet : (psPut ? psPut : psFunc);

        // Determine whether this is a the "Set" or "VB specific Let" function.
        if (psFunc->invkind & INVOKE_PROPERTYPUTREF)
        {   // This function is the PROPERTYPUTREF.  Make it the setter.  If
            //  there is also a PROPERTYPUT, it will be the "letter".
            *pSemantics = msSetter;
        }
        else
        {   // We are looking at the PROPERTYPUT function (the "Let" function in native VB6.).
            
            // If there is also a PROPERTYPUTREF, make this the "VB Specific Let" function.
            if (psPutRef)
            {   // A PPROPERTYPUTREF also exists, so make this the "Let" function.
                *pSemantics = msOther;
            }
            else
            {   // There is no PROPERTYPUTREF, so make this the setter.
                *pSemantics = msSetter;
            }
        }
    }

    // Occasionally there is a property with no discernable type.  In that case, lose the 
    //  property on conversion.

    // Determine the type of the property, based on the "best" accessor.
    psF = *ppSig;
    *pbRetval = FALSE;
    if (psF->invkind & INVOKE_PROPERTYGET)
    {   // look for [retval].
        for (i=psF->cParams-1; i>=0; --i)
        {
            if (psF->lprgelemdescParam[i].paramdesc.wParamFlags & PARAMFLAG_FRETVAL)
            {   // will consume a level of indirection (later).
                *pbRetval = TRUE;
                pReturn = &psF->lprgelemdescParam[i].tdesc;
                break;
            }
        }
        // If no [retval], check return type.
        if (!pReturn && psF->elemdescFunc.tdesc.vt != VT_VOID && psF->elemdescFunc.tdesc.vt != VT_HRESULT)
            pReturn = &psF->elemdescFunc.tdesc;
        // If there is no type, don't try to set the getter.
        if (pReturn && pReturn->vt == VT_VOID)
            pReturn = 0;
    }
    else
    {   // Find lastmost param that isn't [retval].  (Should be the last param, but it is 
        //  possible to write an IDL with a PROPERTYPUT that has a [retval].
        for (i=psF->cParams-1; i>=0; --i)
        {
            if ((psF->lprgelemdescParam[psF->cParams-1].paramdesc.wParamFlags & PARAMFLAG_FRETVAL) == 0)
            {
                {   // First, and possibly only, param.
                    pReturn = &psF->lprgelemdescParam[i].tdesc;
                    break;
                }
            }
        }
    }

    if (pReturn == 0)
        *pSemantics = 0;
    *ppProperty = pReturn;

    return S_OK;
} // HRESULT CImportTlb::_GetFunctionPropertyInfo()

//*****************************************************************************
// Convert a function description to metadata entries.
//  
// This can be rather involved.  If the function is a INVOKE_PROPERTY*,
//  determine if it will be converted as a COM+ property, and if so, which
//  of up to three functions will be selected to provide the property 
//  signature.
// The function return type is found by scaning the parameters looking for 
//  [retval]s.
//*****************************************************************************
HRESULT CImportTlb::_ConvFunction(
    ITypeInfo   *pITI,                  // Containing TypeInfo.
    MemberInfo  *pMember,               // iNFO for the function.
    BOOL        bVtblGapFuncs,          // Add functions for vtblGaps?
    BOOL        bAddDispIds,            // Add DispIds to the member?
    BOOL        bDelegateInvokeMeth,    // Convert function for a delegate invoke
    BOOL*       bAllowIEnum)            // Allowed to change this function to GetEnumerator
{
    HRESULT     hr;                     // A result.
    int         iSrcParam;              // Param count, as looping through params.
    int         iDestParam;             // Param count, as looping through params.
    int         cDestParams;            // Count of destination params.
    int         ixOpt;                  // Index of first param that is optional due to cParamsOpt.
    int         ixVarArg;               // Index of vararg param, if any.
    mdMethodDef mdFunc;                 // Token of new member.
    BSTR        szTypeName=0;           // Name of the type.
    DWORD       dwFlags=0;              // Member flags.
    DWORD       dwImplFlags=0;          // The impl flags.
    WCHAR       *pszName=0;             // Possibly decorated name of member.
    CQuickArray<WCHAR> qbName;          // Buffer for decorated name.
    TYPEDESC    *pReturn=0;             // Return type.
    int         bRetval=false;          // Is the return result a [retval] parameter?
    int         ixRetval;               // Which param is the [retval]?
    TYPEDESC    *pReturnRetval=0;       // Return type from [retval] (incl. indirection).
    WORD        wRetFlags=0;            // Return type flags.
    ULONG       offset=0;               // Offset of function
    BSTR        *rszParamNames=0;       // Parameter names.
    UINT        iNames;                 // Count of actual names.
    CQuickBytes qbComSig;               // new signature 
    BYTE        *pbSig;                 // Pointer into the signature.
    ULONG       sigFlags;               // Signature handling flags.
    CQuickArray<BYTE> qbNativeBuf;      // Native type buffer.
    CQuickArray<BYTE> qbDummyNativeTypeBuf; // A dummy native type array.
    CQuickArray<ULONG> qbNativeOfs;     // Offset of native type for each param.
    CQuickArray<ULONG> qbNativeLen;     // Length of native type for each param.
    ULONG       iNativeOfs=0;           // Current offset in native type buffer.
    ULONG       iNewNativeOfs=0;        // New offset in native type buffer.
    ULONG       cb;                     // Size of an element.
    ULONG       cbTotal = 0;            // Size of the signature.
    int         bOleCall=false;         // Is the implementation OLE style?(HRESULT or IDispatch)
    USHORT      msSemantics=0;          // Property's methodsemantics.
    WCHAR       szSpecial[40];          // To build name of special function.
    mdToken     tkAttr;                 // Token for custom attribute type.
    BOOL        bConversionLoss=false;  // If true, some attributes were lost on conversion.
    enum {ParamRetval=-1, ParamNone=-2};
    int         iParamError=ParamNone;  // Index of param with conversion error.
    BOOL        bNewEnumMember = FALSE; // A flag indicating if the member is the NewEnum member.
    int         iLCIDParam = -1;        // Index of the LCID parameter.
    FUNCDESC    *psFunc = pMember->m_psFunc;

    // Retrieve the member name from the member info.
    IfNullGo(m_szMember = SysAllocString(bDelegateInvokeMeth ? DELEGATE_INVOKE_METH_NAME : pMember->m_pName));

    // Determine if the member is the new enum member.
    if ((*bAllowIEnum))
    {
        bNewEnumMember = FuncIsNewEnum(pITI, psFunc, pMember->m_iMember) == S_OK;
        
        // Once a method is converted in this interface, don't convert any more.
        if (bNewEnumMember)
            *bAllowIEnum = FALSE;
    }


    // We should NEVER have a new enum member when we are dealing with a delegate invoke meth.
    _ASSERTE(!(bNewEnumMember && bDelegateInvokeMeth));

    // If there is a gap in the vtable, emit a special function.
    if (bVtblGapFuncs)
    {
        if ((psFunc->oVft / sizeof(void*)) != m_Slot)
        {
            ULONG n = psFunc->oVft / sizeof(void*);
            // Make sure slot numbers are monotonically increasing.
            if (n < m_Slot)
            {
                IfFailGo(pITI->GetDocumentation(MEMBERID_NIL, &szTypeName, 0, 0, 0));
                IfFailGo(PostError(TLBX_E_BAD_VTABLE, m_szMember, szTypeName, m_szLibrary));
            }

            n -= m_Slot;
            if (n == 1)
                _snwprintf(szSpecial, lengthof(szSpecial), VTBL_GAP_FORMAT_1, VTBL_GAP_FUNCTION, m_Slot);
            else
                _snwprintf(szSpecial, lengthof(szSpecial), VTBL_GAP_FORMAT_N, VTBL_GAP_FUNCTION, m_Slot, n);
            IfFailGo(m_pEmit->DefineMethod(m_tdTypeDef, szSpecial, VTBL_GAP_FUNCTION_FLAGS, VTBL_GAP_SIGNATURE,sizeof(VTBL_GAP_SIGNATURE),
                0/* rva*/, VTBL_GAP_FUNC_IMPL_FLAGS, &mdFunc));
            m_Slot += n;
        }
        // What we will expect next time.
        ++m_Slot;
    }

    //-------------------------------------------------------------------------
    // Determine the return type.
    // If this is an hresult function, prepare to munge return, params.
    if (psFunc->elemdescFunc.tdesc.vt == VT_HRESULT)
    {
        bOleCall = true;
    }
    else
    {
        if ((psFunc->elemdescFunc.tdesc.vt != VT_VOID) && (psFunc->elemdescFunc.tdesc.vt != VT_HRESULT))
            pReturn = &psFunc->elemdescFunc.tdesc;
    }

    // Look for [RETVAL].
    for (iSrcParam=0; iSrcParam<psFunc->cParams; ++iSrcParam)
    {
        if (psFunc->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & PARAMFLAG_FRETVAL)
        {   
            // If already have a return, or a DISPATCH function, error.
            if (pReturn != 0)
            {   // Unexpected return found.
                ReportEvent(NOTIF_CONVERTWARNING, TLBX_E_AMBIGUOUS_RETURN, m_szName, m_szMember);
                IfFailGo(TLBX_E_AMBIGUOUS_RETURN);
            }
            else
            {   // Found a return type.
                wRetFlags = psFunc->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags;
                pReturn = &psFunc->lprgelemdescParam[iSrcParam].tdesc;
                bRetval = true;
                ixRetval = iSrcParam;
            }
            break;
        }
    }
    
    // Check to see if there is an LCID parameter.
    for (iSrcParam=0;iSrcParam<psFunc->cParams;iSrcParam++)
    {
        if (psFunc->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & PARAMFLAG_FLCID)
        {
            if (iLCIDParam != -1)
                IfFailGo(PostError(TLBX_E_MULTIPLE_LCIDS, m_szName, m_szMember));
            iLCIDParam = iSrcParam;
        }
    }

    //-------------------------------------------------------------------------
    // Size buffers to accomodate parameters.
    // Resize the native type length array.
    IfFailGo(qbNativeBuf.ReSize(1));
    IfFailGo(qbNativeLen.ReSize(psFunc->cParams + 1));
    IfFailGo(qbNativeOfs.ReSize(psFunc->cParams + 1));
    memset(qbNativeLen.Ptr(), 0, (psFunc->cParams + 1)*sizeof(int));
    memset(qbNativeOfs.Ptr(), 0, (psFunc->cParams + 1)*sizeof(int));

    // resize to make room for calling convention and count of argument
    IfFailGo(qbComSig.ReSize(CB_MAX_ELEMENT_TYPE + 1));
    pbSig = (BYTE *)qbComSig.Ptr();

    //-------------------------------------------------------------------------
    // Determine which params need to be marked optional, by virtue of cParamsOpt count.
    if (psFunc->cParamsOpt == 0)
        ixVarArg = ixOpt = psFunc->cParams + 1;
    else
    {
        if (psFunc->cParamsOpt == -1)
        {   // Varargs.
            ixVarArg = ixOpt = psFunc->cParams + 1;
            // If this is a PROPERTYPUT or PROPERTYPUTREF, skip the last non-retval parameter (it
            //  is the new value to be set).
            BOOL bPropVal = (psFunc->invkind & (INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF)) ? TRUE : FALSE;
            // Find the vararg param.
            for (iSrcParam=psFunc->cParams-1; iSrcParam>=0; --iSrcParam)
            {
                // The count of optional params does not include any lcid params, nor does
                //  it include the return value, so skip those.
                if ((psFunc->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & (PARAMFLAG_FRETVAL|PARAMFLAG_FLCID)) != 0)
                    continue;
                // If haven't yet seen the property value, this param is it, so skip it, too.
                if (bPropVal)
                {
                    bPropVal = FALSE;
                    continue;
                }
                ixVarArg = iSrcParam;
                break;
            } // for (iSrcParam=cParams-1...
        }
        else
        {   // ixOpt will be index of first optional parameter.
            short cOpt = psFunc->cParamsOpt;
            ixOpt = 0;
            ixVarArg = psFunc->cParams + 1;
            for (iSrcParam=psFunc->cParams-1; iSrcParam>=0; --iSrcParam)
            {
                // The count of optional params does not include any lcid params, nor does
                //  it include the return value, so skip those.
                if ((psFunc->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & (PARAMFLAG_FRETVAL|PARAMFLAG_FLCID)) == 0)
                {   
                    if (--cOpt == 0)
                    {
                        ixOpt = iSrcParam;
                        break;
                    }
                }
            } // for (iSrcParam=cParams-1...
        }
    }


    //-------------------------------------------------------------------------
    // Get the parameter names.
    rszParamNames = reinterpret_cast<BSTR*>(_alloca((psFunc->cParams+1) * sizeof(BSTR*)));

    // Get list of names.
    IfFailGo(pITI->GetNames(psFunc->memid, rszParamNames, psFunc->cParams+1, &iNames));

    // zero name pointer for non-named params.
    for (iSrcParam=iNames; iSrcParam<=psFunc->cParams; ++iSrcParam)
        rszParamNames[iSrcParam] = 0;

    //-------------------------------------------------------------------------
    // Convert the calling convention, param count, and return type.
    cDestParams = psFunc->cParams;
    if (bRetval)
        --cDestParams;
    if (iLCIDParam != -1)
        --cDestParams;

    if (pReturn)
    {   
        // Param count
        cbTotal = cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS, pbSig);
        cb = CorSigCompressData(cDestParams, &(pbSig[cbTotal]));
        cbTotal += cb;
        // Return type or [retval].
        if (bRetval)
            sigFlags = (SigFlags)(wRetFlags & SIG_FLAGS_MASK) | SIG_FUNC, iParamError=ixRetval;
        else
            sigFlags = SIG_FUNC, iParamError=ParamRetval;
        IfFailGo(_ConvSignature(pITI, pReturn, sigFlags, qbComSig, cbTotal, &cbTotal, qbNativeBuf, iNativeOfs, &iNewNativeOfs, bNewEnumMember));
        qbNativeLen[0] = iNewNativeOfs - iNativeOfs;
        qbNativeOfs[0] = iNativeOfs;
        iNativeOfs = iNewNativeOfs;
        if (hr == S_CONVERSION_LOSS)
            bConversionLoss = true;
    }
    else
    {   // No return value
        cbTotal = cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS, pbSig);
        cb = CorSigCompressData(cDestParams, &(pbSig[cbTotal]));
        cbTotal += cb;
        cb = CorSigCompressData(ELEMENT_TYPE_VOID, &pbSig[cbTotal]);
        cbTotal += cb;
    }

    //-------------------------------------------------------------------------
    // Translate each parameter.
    for (iSrcParam=0, iDestParam=0; iSrcParam<psFunc->cParams; ++iSrcParam)
    {
        if (!(psFunc->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & NON_CONVERTED_PARAMS_FLAGS))
        {
            sigFlags = (SigFlags)(psFunc->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & SIG_FLAGS_MASK) | SIG_FUNC | SIG_USE_BYREF;
            if (iSrcParam == ixVarArg)
                sigFlags |= SIG_VARARG;
            iParamError = iSrcParam;
            IfFailGo(_ConvSignature(pITI, &psFunc->lprgelemdescParam[iSrcParam].tdesc, sigFlags, qbComSig, cbTotal, &cbTotal, qbNativeBuf, iNativeOfs, &iNewNativeOfs, bNewEnumMember));
            qbNativeLen[iDestParam+1] = iNewNativeOfs - iNativeOfs;
            qbNativeOfs[iDestParam+1] = iNativeOfs;
            iNativeOfs = iNewNativeOfs;
            iDestParam++;
            if (hr == S_CONVERSION_LOSS)
                bConversionLoss = true;
        }
    }
    iParamError = ParamNone;

    //-------------------------------------------------------------------------
    // Get the previously decorated name.  Add interface name and make unique.
    if (bDelegateInvokeMeth)
    {
        pszName = (WCHAR*)DELEGATE_INVOKE_METH_NAME;
    }
    else
    {
        // m_szInterface should be non-null if processing an implemented interface; should be null otherwise.
        _ASSERTE(m_ImplIface == eImplIfaceNone || m_szInterface != 0);
        IfFailGo(qbName.ReSize(wcslen(pMember->m_pName)+2));
        wcscpy(qbName.Ptr(), pMember->m_pName); 
        IfFailGo(GenerateUniqueMemberName(qbName, (PCCOR_SIGNATURE)qbComSig.Ptr(), cbTotal, m_szInterface, mdtMethodDef));
        pszName = qbName.Ptr();
    }

    // Determine the function's semantics, flags and impl flags.
    if (!bDelegateInvokeMeth)
    {
    msSemantics = pMember->m_msSemantics;
        dwImplFlags = DEFAULT_ITF_FUNC_IMPL_FLAGS;
    dwFlags = msSemantics ? DEFAULT_PROPERTY_FUNC_FLAGS : DEFAULT_INTERFACE_FUNC_FLAGS;
    // If processing an implemented interface, remove the abstract bit.  Methods on classes are not abstract.
    if (m_ImplIface != eImplIfaceNone)
        dwFlags &= ~mdAbstract;
    }
    else
    {
        msSemantics = 0;
        dwImplFlags = miRuntime;
        dwFlags = DELEGATE_INVOKE_FUNC_FLAGS;
    }

    //-------------------------------------------------------------------------
    // Create the function definition in the metadata.
    IfFailGo(m_pEmit->DefineMethod(m_tdTypeDef, pszName, dwFlags, (PCCOR_SIGNATURE) qbComSig.Ptr(),cbTotal, 
        0 /* rva*/, dwImplFlags | (bOleCall ? 0 : miPreserveSig), &mdFunc));

    // If the method is part of a property, save info to set up the property.
    if (msSemantics)
        pMember->SetFuncInfo(mdFunc, msSemantics);
    
    // Handle dispids for non-implemented interfaces, and for default interface
    if (m_ImplIface != eImplIface)
    {
        // Add the DispIds if the flag is set.
        long lDispSet = 1;
        _SetDispIDCA(pITI, pMember->m_iMember, psFunc->memid, mdFunc, bAddDispIds, &lDispSet, TRUE);

        // If this method is the default, and not a property accessor, add a custom attribute to the class.
         if (lDispSet == DISPID_VALUE && msSemantics == 0)
            IfFailGo(_AddDefaultMemberCa(m_tdTypeDef, m_szMember));
    }
    
    DECLARE_CUSTOM_ATTRIBUTE(sizeof(int));
    
    // If this method has an LCID then set the LCIDConversion attribute.
    if (iLCIDParam != -1)
    {
        // Dispid for the function.
        BUILD_CUSTOM_ATTRIBUTE(int, iLCIDParam);
        IfFailGo(GetAttrType(ATTR_LCIDCONVERSION, &tkAttr));
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(mdFunc, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));
    }

    // Save the func flags for anyone that needs typelib's flags.
    if (psFunc->wFuncFlags)
    {
        IfFailGo(GetAttrType(ATTR_TYPELIBFUNC, &tkAttr));
        INIT_CUSTOM_ATTRIBUTE(sizeof(WORD));
        BUILD_CUSTOM_ATTRIBUTE(WORD, psFunc->wFuncFlags);
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(mdFunc, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
    }

    //-------------------------------------------------------------------------
    // Convert the param info for the return type.
    if (pReturn)
    {   // store return value parameter as sequence 0
        if (bRetval)
        {
            hr = _IsAlias(pITI, &psFunc->lprgelemdescParam[ixRetval].tdesc);
            IfFailGo(hr);
            if (qbNativeLen[0] || hr == S_OK)
            {
                IfFailGo(_ConvParam(pITI, mdFunc, 0, &psFunc->lprgelemdescParam[ixRetval], ParamNormal, 0 /*rszParamNames[ixRetval+1]*/, 
                    &qbNativeBuf[qbNativeOfs[0]], qbNativeLen[0]));
            }
        }
        else
        {
            hr = _IsAlias(pITI, &psFunc->elemdescFunc.tdesc);
            IfFailGo(hr);
            if (qbNativeLen[0] || hr == S_OK)
            {
                IfFailGo(_ConvParam(pITI, mdFunc, 0, &psFunc->elemdescFunc, ParamNormal, 0, 
                    &qbNativeBuf[qbNativeOfs[0]], qbNativeLen[0]));
            }
        }
    }

    //-------------------------------------------------------------------------
    // Convert parameter info (flags, native type, default value).
    for (iSrcParam=iDestParam=0; iSrcParam<psFunc->cParams; ++iSrcParam)
    {
        if ((psFunc->lprgelemdescParam[iSrcParam].paramdesc.wParamFlags & NON_CONVERTED_PARAMS_FLAGS) == 0)
        {
            ParamOpts opt = ParamNormal;
            if (iSrcParam >= ixOpt)
                opt = ParamOptional;
            else
            if (iSrcParam == ixVarArg)
                opt = ParamVarArg;
            iDestParam++;
            IfFailGo(_ConvParam(pITI, mdFunc, iDestParam, &psFunc->lprgelemdescParam[iSrcParam], opt, rszParamNames[iSrcParam + 1], 
                &qbNativeBuf[qbNativeOfs[iDestParam]], qbNativeLen[iDestParam]));
        }
    }

    
    //-------------------------------------------------------------------------
    // If processing an implemented interface, set up MethodImpls.
    if (m_ImplIface != eImplIfaceNone)
    {   
        // Define a memberref on the implemented interface.
        mdToken mrItfMember;
        IfFailGo(m_pEmit->DefineMemberRef(m_tkInterface, pMember->m_pName, (PCCOR_SIGNATURE) qbComSig.Ptr(),cbTotal, &mrItfMember));

        // Define a method impl.
        IfFailGo(m_pEmit->DefineMethodImpl(m_tdTypeDef, mdFunc, mrItfMember));
    }

    if (bConversionLoss)
    {
        hr = S_CONVERSION_LOSS;
        ReportEvent(NOTIF_CONVERTWARNING, TLBX_I_UNCONVERTABLE_ARGS, m_szName, m_szMember);
    }

ErrExit:
    // Special case for typeload load failures -- they're very hard to diagnose.
    if (hr == TYPE_E_CANTLOADLIBRARY)
    {
        if (iParamError >= 0 && iParamError < psFunc->cParams && rszParamNames[iParamError+1])
            ReportEvent(NOTIF_CONVERTWARNING, TLBX_E_PARAM_ERROR_NAMED, m_szName, rszParamNames[iParamError+1], m_szMember);
        else
            ReportEvent(NOTIF_CONVERTWARNING, TLBX_E_PARAM_ERROR_UNNAMED, m_szName, iParamError, m_szMember);
    }
    if (rszParamNames)
    {
        for (iSrcParam=0; iSrcParam<=psFunc->cParams; ++iSrcParam)
            if (rszParamNames[iSrcParam])
                ::SysFreeString(rszParamNames[iSrcParam]);
    }
    if (m_szMember)
        ::SysFreeString(m_szMember), m_szMember=0;
    if (szTypeName)
        ::SysFreeString(szTypeName);
    
    return (hr);
} // HRESULT CImportTlb::_ConvFunction()


HRESULT CImportTlb::_SetHiddenCA(mdTypeDef token)
{
    mdToken tkAttr;
    HRESULT hr = S_OK;
    
    DECLARE_CUSTOM_ATTRIBUTE(sizeof(short));
    BUILD_CUSTOM_ATTRIBUTE(short, TYPEFLAG_FHIDDEN);
    IfFailGo(GetAttrType(ATTR_TYPELIBTYPE, &tkAttr));
    FINISH_CUSTOM_ATTRIBUTE();
    m_pEmit->DefineCustomAttribute(token, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0);
    
ErrExit:
    return S_OK;    
}

HRESULT CImportTlb::_ForceIEnumerableCVExists(ITypeInfo* pITI, BOOL* CVExists)
{
    ITypeInfo2  *pITI2 = 0;
    *CVExists = FALSE;
    HRESULT hr = S_OK;

    pITI->QueryInterface(IID_ITypeInfo2, reinterpret_cast<void**>(&pITI2));

    if (pITI2)
    {
        VARIANT vCustomData;
        VariantInit(&vCustomData);

        IfFailGo(pITI2->GetCustData(GUID_ForceIEnumerable, &vCustomData));

        if (V_VT(&vCustomData) != VT_EMPTY)
            *CVExists = TRUE;
            
        VariantClear(&vCustomData);       
    }

ErrExit:
    if (pITI2)
        pITI2->Release();
        
    return S_OK;
}


HRESULT CImportTlb::_GetDispIDCA(
    ITypeInfo* pITI,
    int iMember,
    long* lDispSet,
    BOOL bFunc
    )
{
    ITypeInfo2  *pITI2=0;               // For getting custom value.
    HRESULT hr = S_OK;
    long lDispId;
    
    // Get the ITypeInfo2 interface if possible
    pITI->QueryInterface(IID_ITypeInfo2, reinterpret_cast<void**>(&pITI2));

    if (pITI2)
    {
        VARIANT vCustomData;
        VariantInit(&vCustomData);

        if (bFunc)
            IfFailGo(pITI2->GetFuncCustData(iMember, GUID_DispIdOverride, &vCustomData));
        else
            IfFailGo(pITI2->GetVarCustData(iMember, GUID_DispIdOverride, &vCustomData));

        if ((V_VT(&vCustomData) == VT_I2) || (V_VT(&vCustomData) == VT_I4))
        {
            hr = VariantChangeType(&vCustomData, &vCustomData, 0, VT_I4);
            if (hr == S_OK)
                lDispId = vCustomData.lVal;
        }

        VariantClear(&vCustomData);
    }

ErrExit:
    if (lDispSet != NULL)
        *lDispSet = lDispId;

    if (pITI2)
        pITI2->Release();
        
    return S_OK;
}



HRESULT CImportTlb::_SetDispIDCA(
    ITypeInfo* pITI,
    int iMember,
    long lDispId,
    mdToken func,
    BOOL fAlwaysAdd,
    long* lDispSet,
    BOOL bFunc
    )
{
    WCHAR DispIDCA[] = L"{CD2BC5C9-F452-4326-B714-F9C539D4DA58}";
    ITypeInfo2  *pITI2=0;               // For getting custom value.
    HRESULT hr = S_OK;
    
    // Get the ITypeInfo2 interface if possible
    pITI->QueryInterface(IID_ITypeInfo2, reinterpret_cast<void**>(&pITI2));

    if (pITI2)
    {
        VARIANT vCustomData;
        VariantInit(&vCustomData);

        if (bFunc)
            IfFailGo(pITI2->GetFuncCustData(iMember, GUID_DispIdOverride, &vCustomData));
        else
            IfFailGo(pITI2->GetVarCustData(iMember, GUID_DispIdOverride, &vCustomData));

        if ((V_VT(&vCustomData) == VT_I2) || (V_VT(&vCustomData) == VT_I4))
        {
            hr = VariantChangeType(&vCustomData, &vCustomData, 0, VT_I4);
            if (hr == S_OK)
            {
                lDispId = vCustomData.lVal;
                fAlwaysAdd = true;
            }
        }
        else if (V_VT(&vCustomData) != VT_EMPTY)
        {
            // Invalid Variant type on the data - spit out a warning.
            BSTR CustomValue = SysAllocString((const WCHAR*)&DispIDCA[0]);
            BSTR ObjectName;
            pITI2->GetDocumentation(iMember+1, &ObjectName, NULL, NULL, NULL);
            
            ReportEvent(NOTIF_CONVERTWARNING, TLBX_W_NON_INTEGRAL_CA_TYPE, CustomValue, ObjectName);

            SysFreeString(CustomValue);
            SysFreeString(ObjectName);
        }

        VariantClear(&vCustomData);
    }

    // Set the dispid CA on the property.
    if (fAlwaysAdd)
    {
        mdToken tkAttr;
        DECLARE_CUSTOM_ATTRIBUTE(sizeof(DISPID));
        BUILD_CUSTOM_ATTRIBUTE(DISPID, lDispId);
        IfFailGo(GetAttrType(ATTR_DISPID, &tkAttr));
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(func, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));
    }
    
ErrExit:
    if (lDispSet != NULL)
    {
        *lDispSet = lDispId;
    }

    if (pITI2)
        pITI2->Release();

    return S_OK;
}


HRESULT CImportTlb::_CheckForPropertyCustomAttributes(ITypeInfo* pITI, int index, INVOKEKIND* ikind)
{
    HRESULT     hr;
    VARIANT     vCustomData;
    ITypeInfo2* pITI2       = 0;
    BOOL        found       = FALSE;

    VariantInit(&vCustomData);

    // Get the ITypeInfo2 interface if possible
    pITI->QueryInterface(IID_ITypeInfo2, reinterpret_cast<void**>(&pITI2));
    if (pITI2)
    {
        // First, check for PropGet
        hr = pITI2->GetFuncCustData(index, GUID_PropGetCA, &vCustomData);
        IfFailGo(hr);
        if (V_VT(&vCustomData) != VT_EMPTY)
        {
            *ikind = INVOKE_PROPERTYGET;
            found = TRUE;
            goto ErrExit;
        }

        // Second, check for PropPut
        VariantClear(&vCustomData);
        VariantInit(&vCustomData);
        hr = pITI2->GetFuncCustData(index, GUID_PropPutCA, &vCustomData);
        IfFailGo(hr);
        if (V_VT(&vCustomData) != VT_EMPTY)
        {
            *ikind = INVOKE_PROPERTYPUT;
            found = TRUE;
            goto ErrExit;
        }
    }

ErrExit:
    VariantClear(&vCustomData);

    if (pITI2)
        pITI2->Release();

    if (found)
        return S_OK;

    return S_FALSE;
}

//*****************************************************************************
// Generate an event with an add and remove method 
//*****************************************************************************
HRESULT CImportTlb::_GenerateEvent(
    ITypeInfo   *pITI,                  // Containing TypeInfo.
    MemberInfo  *pMember,               // Info for the function
    BOOL        fInheritsIEnum)
{
    HRESULT             hr = S_OK;      // A result.
    mdMethodDef         mdAdd;          // Token of add_XXX method.
    mdMethodDef         mdRemove;       // Token of remove_XXX method.
    CQuickArray<WCHAR>  qbName;         // Buffer for decorated name.
    CQuickArray<BYTE>   qbSig;          // The signature.
    ULONG               cb;             // Size of an element.
    ULONG               cbTotal = 0;    // Size of the signature.
    mdTypeDef           tdDelegate;     // The delegate type def.
    mdEvent             tkEvent;        // The token for the event.

    // Generate the delegate.
    IfFailGo(_GenerateEventDelegate(pITI, pMember, &tdDelegate, fInheritsIEnum));

    // Generate the sig for the add and remove methods.
    qbSig.ReSize(CB_MAX_ELEMENT_TYPE * 2 + 1);
    cbTotal = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS, qbSig.Ptr());
    cb = CorSigCompressData(1, &(qbSig[cbTotal]));
    cbTotal += cb;
    cb = CorSigCompressData(ELEMENT_TYPE_VOID, &qbSig[cbTotal]);
    cbTotal += cb;
    cb = CorSigCompressData(ELEMENT_TYPE_CLASS, &qbSig[cbTotal]);
    cbTotal += cb;
    cb = CorSigCompressToken(tdDelegate, &qbSig[cbTotal]);
    cbTotal += cb;

    // Generate the add method.
    qbName.ReSize(EVENT_ADD_METH_PREFIX_LENGTH + wcslen(pMember->m_pName) + 1);
    swprintf(qbName.Ptr(), L"%s%s", EVENT_ADD_METH_PREFIX, pMember->m_pName);   
    IfFailGo(m_pEmit->DefineMethod(m_tdTypeDef, qbName.Ptr(), DEFAULT_INTERFACE_FUNC_FLAGS, 
        qbSig.Ptr(), cbTotal, 0 /* rva*/, DEFAULT_ITF_FUNC_IMPL_FLAGS, &mdAdd));

    // Generate the remove method.
    qbName.ReSize(EVENT_REM_METH_PREFIX_LENGTH + wcslen(pMember->m_pName) + 1);
    swprintf(qbName.Ptr(), L"%s%s", EVENT_REM_METH_PREFIX, pMember->m_pName);   
    IfFailGo(m_pEmit->DefineMethod(m_tdTypeDef, qbName.Ptr(), DEFAULT_INTERFACE_FUNC_FLAGS, 
        qbSig.Ptr(), cbTotal, 0 /* rva*/, DEFAULT_ITF_FUNC_IMPL_FLAGS, &mdRemove));

    // Define the event itself.
    IfFailGo(m_pEmit->DefineEvent(m_tdTypeDef, pMember->m_pName, 0, tdDelegate, 
        mdAdd, mdRemove, mdTokenNil, NULL, &tkEvent));

ErrExit:

    return (hr);
} // HRESULT CImportTlb::_GenerateEvent()

//*****************************************************************************
// Generate an add and remove method 
//*****************************************************************************
HRESULT CImportTlb::_GenerateEventDelegate(
    ITypeInfo   *pITI,                  // Containing TypeInfo.
    MemberInfo  *pMember,               // Info for the source interface func
    mdTypeDef   *ptd,                   // The output typedef.
    BOOL        fInheritsIEnum)
{
    HRESULT             hr = S_OK;                  // A result.
    BSTR                bstrSrcItfName = NULL;      // The name of the source interface.
    CQuickArray<WCHAR>  qbEventHandlerName;         // The name of the event handler.
    BSTR                szOldName = NULL;           // The old value m_tdTypeDef.
    mdTypeDef           tdOldTypeDef = NULL;        // The old value m_szName.
    CQuickArray<BYTE>   qbSig;                      // The signature.
    ULONG               cb;                         // Size of an element.
    ULONG               cbTotal = 0;                // Total size of signature.
    mdMethodDef         mdFunc;                     // The defined function.
    mdTypeRef           trMulticastDelegate;        // The type ref for System.MulticastDelegate.
    mdToken             tkAttr;                     // Custom attribute type.

    // Store the old values of the ITypeInfo name and of the current type def.
    szOldName = m_szName;
    tdOldTypeDef = m_tdTypeDef;
    m_szName = NULL;

    // Retrieve the full name of the source interface.
    IfFailGo(GetManagedNameForTypeInfo(pITI, m_wzNamespace, NULL, &bstrSrcItfName));

    // Generate a unique name for the event handler which will be of the form:
    //     <SrcItfName>_<MethodName>_EventHandler<PotentialSuffix>
    qbEventHandlerName.ReSize(wcslen(bstrSrcItfName) + wcslen(pMember->m_pName) + EVENT_HANDLER_SUFFIX_LENGTH + 6);
    swprintf(qbEventHandlerName.Ptr(), L"%s_%s%s", bstrSrcItfName, pMember->m_pName, EVENT_HANDLER_SUFFIX);
    IfFailGo(GenerateUniqueTypeName(qbEventHandlerName));

    // Set the information on the current type.
    IfNullGo(m_szName = SysAllocString(qbEventHandlerName.Ptr()));

    // Retrieve the parent type ref.
    IfFailGo(GetKnownTypeToken(VT_SLOT_FOR_MULTICASTDEL, &trMulticastDelegate));

    // Create the typedef for the event interface.
    IfFailGo(m_pEmit->DefineTypeDef(m_szName, tdPublic | tdSealed, trMulticastDelegate, NULL, &m_tdTypeDef));

     // Hide the interface from Object Browsers (EventHandler)
     _SetHiddenCA(m_tdTypeDef);

    // Make the interface ComVisible(false).
    {
        DECLARE_CUSTOM_ATTRIBUTE(sizeof(BYTE));
        BUILD_CUSTOM_ATTRIBUTE(BYTE, FALSE);
        IfFailGo(GetAttrType(ATTR_COMVISIBLE, &tkAttr));
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(m_tdTypeDef, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));
    }

    // Generate the sig for the constructor.
    qbSig.ReSize(CB_MAX_ELEMENT_TYPE * 2 + 1);
    cbTotal = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS, qbSig.Ptr());
    cb = CorSigCompressData(2, &(qbSig[cbTotal]));
    cbTotal += cb;
    cb = CorSigCompressData(ELEMENT_TYPE_VOID, &qbSig[cbTotal]);
    cbTotal += cb;
    cb = CorSigCompressData(ELEMENT_TYPE_OBJECT, &qbSig[cbTotal]);
    cbTotal += cb;
    cb = CorSigCompressData(ELEMENT_TYPE_U, &qbSig[cbTotal]);
    cbTotal += cb;

    // Generate the constructor.
    IfFailGo(m_pEmit->DefineMethod(m_tdTypeDef, OBJECT_INITIALIZER_NAME, OBJECT_INITIALIZER_FLAGS, 
        qbSig.Ptr(), cbTotal, 0 /* rva*/, miRuntime, &mdFunc));
    
    // Generate the invoke method.
    BOOL bAllowIEnum = !fInheritsIEnum;
    IfFailGo(_ConvFunction(pITI, pMember, FALSE, FALSE, TRUE, &bAllowIEnum));

    // Set the output typedef.
    *ptd = m_tdTypeDef;

ErrExit:
    if (m_szName)
        ::SysFreeString(m_szName);
    if (m_szMember)
        ::SysFreeString(m_szMember); m_szMember=0;
    if (bstrSrcItfName)
        ::SysFreeString(bstrSrcItfName);

    // Restore the initial values for the ITypeInfo name and the type def.
    m_szName = szOldName;
    m_tdTypeDef = tdOldTypeDef;

    return (hr);
} // HRESULT CImportTlb::_GenerateEventDelegate()

//*****************************************************************************
//*****************************************************************************
struct MDTOKENHASH : HASHLINK
{
    mdToken tkKey;
    mdToken tkData;
}; // struct MDTOKENHASH : HASHLINK

class CTokenHash : public CChainedHash<MDTOKENHASH>
{
public:
    virtual bool InUse(MDTOKENHASH *pItem)
    { return (pItem->tkKey != NULL); }

    virtual void SetFree(MDTOKENHASH *pItem)
    { 
        pItem->tkKey = NULL; 
        pItem->tkKey = NULL; 
    }

    virtual ULONG Hash(const void *pData)
    { 
        // Do case-insensitive hash
        return (ULONG)pData; 
    }

    virtual int Cmp(const void *pData, void *pItem){
        return reinterpret_cast<mdToken>(pData) != reinterpret_cast<MDTOKENHASH*>(pItem)->tkKey;
    }
}; // CTokenHash : public CChainedHash<MDTOKENHASH>

//*****************************************************************************
// Copy methods and events from a source interface to a class that sources the
//  given interface.
//*****************************************************************************
HRESULT CImportTlb::_AddSrcItfMembersToClass(   // S_OK or error.
    mdTypeRef   trSrcItf)                       // Typeref of the source interface.
{
    HRESULT             hr=S_OK;                // A result.
    ULONG               i;                      // Generic counter.
    HCORENUM            MemberEnum = NULL;      // The enum of members.
    ULONG               cMembers = 0;           // Temp count of members.
    mdTypeDef           tdSrcItf;               // A type def to the interface.
    mdEvent             tkItfEvent;             // The token of the interface event.
    mdEvent             tkClassEvent;           // The token of the class event.
    mdToken             tkEventType;            // The event type.
    mdMethodDef         mdItfMethod;            // The method def of the interface method.
    mdMethodDef         mdAddMethod;            // The add method.
    mdMethodDef         mdRemoveMethod;         // The remove method.
    mdMethodDef         mdFireMethod;           // The fire method.
    mdMethodDef         mdClassMethod;          // The method def of the class method.
    CQuickArray<mdMethodDef>  qbOtherMethods;   // The other methods for the property.
    ULONG               cchOtherMethods;        // The cound of other methods.
    CQuickArray<WCHAR>  qbMemberName;           // Name of the member.
    CQuickArray<WCHAR>  qbEventItfFullName;     // Full name of the event interface.
    CQuickArray<WCHAR>  qbEventItfName;         // Name of the event interface.
    ULONG               cchName;                // Length of a name, in wide chars.
    ULONG               ItfMemberAttr;          // The attributes of the interface member.
    ULONG               ItfMemberImplFlags;     // The impl flags of the interface member.               
    PCCOR_SIGNATURE     ItfMemberSig;           // The signature of the interface member.
    ULONG               ItfMemberSigSize;       // The size of the member signature.
    mdMemberRef         mrItfMember;            // A member ref to the interface member def.
    BSTR                bstrSrcItfName = NULL;  // The name of the CoClass.
    mdAssemblyRef       ar;                     // The assembly ref.
    CTokenHash          ItfMDToClassMDMap;      // The interface MD to class MD map.
    MDTOKENHASH *       pItem;                  // An item in the token hashtable.

    // Retrieve the name of the event interface.
    do {
        IfFailGo(m_pImport->GetTypeRefProps(
            trSrcItf, 
            &ar, 
            qbEventItfFullName.Ptr(), 
            (ULONG)qbEventItfFullName.MaxSize(), 
            &cchName));
        if (hr == CLDB_S_TRUNCATION)
        {
            IfFailGo(qbEventItfFullName.ReSize(cchName));
            continue;
        }
        break;
    } while (1);
    qbEventItfName.ReSize(cchName);
    ns::SplitPath(qbEventItfFullName.Ptr(), NULL, 0, qbEventItfName.Ptr(), qbEventItfName.Size());

    // Resolve the typeref to a typedef.
    IfFailGo(m_pImport->FindTypeDefByName(qbEventItfFullName.Ptr(), mdTokenNil, &tdSrcItf));

    // Define methods and method impl's for all the methods in the interface.
    while ((hr = m_pImport->EnumMethods(&MemberEnum, tdSrcItf, &mdItfMethod, 1, &cMembers)) == S_OK)
    {
        // Retrieve the method properties.
        do {
            IfFailGo(m_pImport->GetMethodProps(
                mdItfMethod,
                NULL,
                qbMemberName.Ptr(),
                (ULONG)qbMemberName.MaxSize(),
                &cchName,
                &ItfMemberAttr,
                &ItfMemberSig,
                &ItfMemberSigSize,
                NULL,
                &ItfMemberImplFlags));
            if (hr == CLDB_S_TRUNCATION)
            {
                IfFailGo(qbMemberName.ReSize(cchName));
                continue;
            }
            break;
        } while (1);

        // Define a member ref on the class to the interface member def.
        IfFailGo(m_pEmit->DefineMemberRef(trSrcItf, qbMemberName.Ptr(), ItfMemberSig, ItfMemberSigSize, &mrItfMember));

        // Generate a unique name for the class member.
        IfFailGo(GenerateUniqueMemberName(qbMemberName, NULL, 0, qbEventItfName.Ptr(), mdtMethodDef));

        // Define a member on the class.
        IfFailGo(m_pEmit->DefineMethod(m_tdTypeDef, qbMemberName.Ptr(), ItfMemberAttr & ~mdAbstract,
            ItfMemberSig, ItfMemberSigSize, 0/*rva*/, ItfMemberImplFlags, &mdClassMethod));

        // Define a method impl.
        IfFailGo(m_pEmit->DefineMethodImpl(m_tdTypeDef, mdClassMethod, mrItfMember));

        // Add the interface member to the map.
        pItem = ItfMDToClassMDMap.Add((const void *)mdItfMethod);
        pItem->tkKey = mdItfMethod;
        pItem->tkData = mdClassMethod;
    }
    IfFailGo(hr);

    m_pImport->CloseEnum(MemberEnum);
    MemberEnum = NULL;

    // Define all the events in the interface on the class.
    while ((hr = m_pImport->EnumEvents(&MemberEnum, tdSrcItf, &tkItfEvent, 1, &cMembers)) == S_OK)
    {
        // Retrieve the properties of the property.
        do {
            IfFailGo(m_pImport->GetEventProps(
                tkItfEvent,
                NULL,               
                qbMemberName.Ptr(),    
                (ULONG)qbMemberName.MaxSize(),
                &cchName,         
                &ItfMemberAttr,   
                &tkEventType,    
                &mdAddMethod,
                &mdRemoveMethod,
                &mdFireMethod,
                qbOtherMethods.Ptr(),
                (ULONG)qbOtherMethods.MaxSize(),
                &cchOtherMethods));
            if (hr == CLDB_S_TRUNCATION)
            {
                IfFailGo(qbMemberName.ReSize(cchName));
                IfFailGo(qbOtherMethods.ReSize(cchOtherMethods));
                continue;
            }
            break;
        } while (1);

        // NULL terminate the array of other methods.
        qbOtherMethods.ReSize(cchOtherMethods + 1);
        qbOtherMethods[cchOtherMethods] = NULL;

        // Replace all the interface method def's with the equivalent class method def's.
        if (!IsNilToken(mdAddMethod))
        {
            pItem = ItfMDToClassMDMap.Find((const void *)mdAddMethod);
            _ASSERTE(pItem);
            mdAddMethod = pItem->tkData;
        }
        if (!IsNilToken(mdRemoveMethod))
        {
            pItem = ItfMDToClassMDMap.Find((const void *)mdRemoveMethod);
            _ASSERTE(pItem);
            mdRemoveMethod = pItem->tkData;
        }
        if (!IsNilToken(mdFireMethod))
        {
            pItem = ItfMDToClassMDMap.Find((const void *)mdFireMethod);
            _ASSERTE(pItem);
            mdFireMethod = pItem->tkData;
        }
        for (i = 0; i < cchOtherMethods; i++)
        {
            _ASSERTE(!IsNilToken(qbOtherMethods[i]));
            pItem = ItfMDToClassMDMap.Find((const void *)qbOtherMethods[i]);
            _ASSERTE(pItem);
            qbOtherMethods[i] = pItem->tkData;
        }

        // Generate a unique name for the event.
        IfFailGo(GenerateUniqueMemberName(qbMemberName, NULL, 0, qbEventItfName.Ptr(), mdtEvent));

        // Define property on the class.
        IfFailGo(m_pEmit->DefineEvent(m_tdTypeDef, qbMemberName.Ptr(), ItfMemberAttr,
            tkEventType, mdAddMethod, mdRemoveMethod, mdFireMethod, qbOtherMethods.Ptr(), &tkClassEvent));
    }
    IfFailGo(hr);   

    m_pImport->CloseEnum(MemberEnum);
    MemberEnum = NULL;

ErrExit:
    if (MemberEnum)
        m_pImport->CloseEnum(MemberEnum);
    if (bstrSrcItfName)
        ::SysFreeString(bstrSrcItfName);

    return hr;

#undef ITF_MEMBER_SIG
#undef ITF_MEMBER_SIG_SIZE
} // HRESULT CImportTlb::_AddSrcItfMembersToClass()

//*****************************************************************************
// Compare the two signatures ignoring the return type. If the signatures
// match then TRUE will be returned, FALSE will be returned otherwise.
// This method assumes the two signatures are in the same scope.
//*****************************************************************************
HRESULT CImportTlb::CompareSigsIgnoringRetType(
    PCCOR_SIGNATURE pbSig1,           // The 1st method signature.
    ULONG           cbSig1,           // Size of the 1st method signature.
    PCCOR_SIGNATURE pbSig2,           // The 2nd method signature.
    ULONG           cbSig2)           // Size of the 2nd method signature.
{
    HRESULT             hr = S_OK;
    PCCOR_SIGNATURE     pbSig1Start;  
    PCCOR_SIGNATURE     pbSig2Start;  
    ULONG               Sig1ParamCount;
    ULONG               Sig2ParamCount;
    ULONG               cbSig1RetType;
    ULONG               cbSig2RetType;

    // Save the start of the signatures.
    pbSig1Start = pbSig1;  
    pbSig2Start = pbSig2;  

    // Skip the calling conventions.
    CorSigUncompressData(pbSig1);
    CorSigUncompressData(pbSig2);

    // Compare the param count.
    Sig1ParamCount = CorSigUncompressData(pbSig1);
    Sig2ParamCount = CorSigUncompressData(pbSig2);
    if (Sig1ParamCount != Sig2ParamCount)
        return S_FALSE;

    // Skip the return type.
    IfFailGo(_CountBytesOfOneArg(pbSig1, &cbSig1RetType));
    pbSig1 += cbSig1RetType;
    IfFailGo(_CountBytesOfOneArg(pbSig2, &cbSig2RetType));
    pbSig2 += cbSig2RetType;

    // Update the remaining sig sizes.
    cbSig1 -= (pbSig1 - pbSig1Start);
    cbSig2 -= (pbSig2 - pbSig2Start);

    // If the remaining sig sizes are different then the sigs don't match.
    if (cbSig1 != cbSig2)
        return S_FALSE;

    // Compare the rest of the sigs using memcmp.
    if (memcmp(pbSig1, pbSig2, cbSig1) != 0)
        return S_FALSE;

    // The parameters match.
    return S_OK;

ErrExit:
    // An error occured.
    return hr;
} // HRESULT CImportTlb::CompareSigsIgnoringRetType()

//*****************************************************************************
// Look up a method in the emit scope. This lookup method does not take the
// return type into account when comparing using a sig. So 2 methods with 
// the same name, same parameters and a different return type will be 
// considered the same.
//*****************************************************************************
HRESULT CImportTlb::FindMethod(         // S_OK or CLDB_E_RECORD_NOTFOUND, or error.
    mdTypeDef   td,                     // The method typedef.
    LPCWSTR     szName,                 // The method name.
    PCCOR_SIGNATURE pbReqSig,              // The method signature.
    ULONG       cbReqSig,               // Size of the method signature.
    mdMethodDef *pmb)                   // Put the method here.
{
    HRESULT             hr = S_OK;          // A result.
    PCCOR_SIGNATURE     pbFoundSig = NULL;  
    ULONG               cbFoundSig = 0;
    ULONG               MethodAttr;             
    ULONG               MethodImplFlags;     
    mdMethodDef         md;
    CQuickArray<WCHAR>  qbMethodName;
    HCORENUM            MethodEnum = NULL;
    ULONG               cMethods = 0;
    ULONG               cchName;
    BOOL                bMethodFound = FALSE;

    // Go through all the methods on the class looking for one with the
    // same name and same parameters.
    while ((hr = m_pImport->EnumMethods(&MethodEnum, td, &md, 1, &cMethods)) == S_OK)
    {
        // Retrieve the method properties.
        do {
            IfFailGo(m_pImport->GetMethodProps(
                md,
                NULL,
                qbMethodName.Ptr(),
                (ULONG)qbMethodName.MaxSize(),
                &cchName,
                &MethodAttr,
                &pbFoundSig,
                &cbFoundSig,
                NULL,
                &MethodImplFlags));
            if (hr == CLDB_S_TRUNCATION)
            {
                IfFailGo(qbMethodName.ReSize(cchName));
                continue;
            }
            break;
        } while (1);

        // Compare the name of the method.
        if (wcscmp(szName, qbMethodName.Ptr()) != 0)
            continue;

        // If the signature of the requested method is specified, then compare
        // the signature against the signature of the found method ignoring
        // the return type.
        if (pbReqSig)
        {
            IfFailGo(hr = CompareSigsIgnoringRetType(pbReqSig, cbReqSig, pbFoundSig, cbFoundSig));
            if (hr == S_FALSE)
                continue;           
        }

        // We have found the member.
        bMethodFound = TRUE;
        break;
    }
    IfFailGo(hr);

ErrExit:
    if (MethodEnum)
        m_pImport->CloseEnum(MethodEnum);

    return bMethodFound ? S_OK : CLDB_E_RECORD_NOTFOUND;
}

//*****************************************************************************
// Look up a property in the emit scope.
//*****************************************************************************
HRESULT CImportTlb::FindProperty(      // S_OK or CLDB_E_RECORD_NOTFOUND, or error.
    mdTypeDef   td,                     // The property typedef.
    LPCWSTR     szName,                 // The property name.
    PCCOR_SIGNATURE pbSig,                 // The property signature.
    ULONG       cbSig,                  // Size of the property signature.
    mdProperty  *ppr)                   // Put the property here.
{
    HRESULT     hr;                     // A result.
    RegMeta     *pRegMeta = (RegMeta*)(m_pEmit);
    LPCUTF8     szNameAnsi;
    szNameAnsi = UTF8STR(szName);

    hr = ImportHelper::FindProperty(
             &(pRegMeta->GetMiniStgdb()->m_MiniMd), 
             m_tdTypeDef, 
             szNameAnsi, 
             pbSig, 
             cbSig, 
             ppr);
    return hr;
} // HRESULT CImportTlb::FindProperty()

//*****************************************************************************
// Look up a event in the emit scope.
//*****************************************************************************
HRESULT CImportTlb::FindEvent(          // S_OK or CLDB_E_RECORD_NOTFOUND, or error.
    mdTypeDef   td,                     // The event typedef.
    LPCWSTR     szName,                 // The event name.
    mdEvent     *pev)                   // Put the event here.
{
    HRESULT     hr;                     // A result.
    RegMeta     *pRegMeta = (RegMeta*)(m_pEmit);
    LPCUTF8     szNameAnsi;
    szNameAnsi = UTF8STR(szName);

    hr = ImportHelper::FindEvent(
             &(pRegMeta->GetMiniStgdb()->m_MiniMd), 
             m_tdTypeDef, 
             szNameAnsi, 
             pev);
    return hr;
} // HRESULT CImportTlb::FindEvent()

//*****************************************************************************
// Checks to see if the specified TYPEDESC is an alias.
//*****************************************************************************
HRESULT CImportTlb::_IsAlias(
    ITypeInfo   *pITI,                  // The ITypeInfo containing the TYPEDESC.
    TYPEDESC    *pTypeDesc)             // The token of the param, field, etc.
{
    HRESULT     hr = S_FALSE;           // A result.
    ITypeInfo   *pTypeITI=0;            // The ITypeInfo of the type.
    ITypeLib    *pTypeTLB=0;            // The TLB that contains the type.
    TYPEATTR    *psTypeAttr=0;          // TYPEATTR of the type.

    // Drill down to the actual type that is pointed to.
    while (pTypeDesc->vt == VT_PTR)
        pTypeDesc = pTypeDesc->lptdesc;

    // If the parameter is an alias then we need to add a custom attribute to the 
    // parameter that describes the alias.
    if (pTypeDesc->vt == VT_USERDEFINED)
    {
        IfFailGo(pITI->GetRefTypeInfo(pTypeDesc->hreftype, &pTypeITI));
        IfFailGo(pTypeITI->GetTypeAttr(&psTypeAttr));
        if (psTypeAttr->typekind == TKIND_ALIAS)
        {
            hr = S_OK;
        }
    }

ErrExit:
    if (psTypeAttr)
        pTypeITI->ReleaseTypeAttr(psTypeAttr);
    if (pTypeITI)
        pTypeITI->Release();
    return hr;
} // HRESULT CImportTlb::_IsAlias()

//*****************************************************************************
// Add alias information if the TYPEDESC represents an alias.
//*****************************************************************************
HRESULT CImportTlb::_HandleAliasInfo(
    ITypeInfo   *pITI,                  // The ITypeInfo containing the TYPEDESC.
    TYPEDESC    *pTypeDesc,             // The TYPEDESC.
    mdToken     tk)                     // The token of the param, field, etc.
{
    HRESULT     hr = S_OK;              // A result.
    ITypeInfo   *pTypeITI=0;            // The ITypeInfo of the type.
    ITypeLib    *pTypeTLB=0;            // The TLB that contains the type.
    TYPEATTR    *psTypeAttr=0;          // TYPEATTR of the type.
    BSTR        bstrAliasTypeName=0;    // The name of the alias type.
    BSTR        bstrAliasTypeLibName=0; // The name of the typelib that contains the alias type.

    // Drill down to the actual type that is pointed to.
    while (pTypeDesc->vt == VT_PTR)
        pTypeDesc = pTypeDesc->lptdesc;

    // If the parameter is an alias then we need to add a custom attribute to the 
    // parameter that describes the alias.
    if (pTypeDesc->vt == VT_USERDEFINED)
    {
        IfFailGo(pITI->GetRefTypeInfo(pTypeDesc->hreftype, &pTypeITI));
        IfFailGo(pTypeITI->GetTypeAttr(&psTypeAttr));
        if (psTypeAttr->typekind == TKIND_ALIAS)
        {
            // Retrieve the name of the alias type.
            IfFailGo(pTypeITI->GetContainingTypeLib(&pTypeTLB, NULL));
            IfFailGo(GetNamespaceOfRefTlb(pTypeTLB, &bstrAliasTypeLibName, NULL));
            IfFailGo(GetManagedNameForTypeInfo(pTypeITI, bstrAliasTypeLibName, NULL, &bstrAliasTypeName));

            // Add the ComAliasName CA to the parameter.
            _AddStringCa(ATTR_COMALIASNAME, tk, bstrAliasTypeName);
        }
    }

ErrExit:
    if (psTypeAttr)
        pTypeITI->ReleaseTypeAttr(psTypeAttr);
    if (pTypeITI)
        pTypeITI->Release();
    if (pTypeTLB)
        pTypeTLB->Release();
    if (bstrAliasTypeLibName)
        ::SysFreeString(bstrAliasTypeLibName);   
    if (bstrAliasTypeName)
        ::SysFreeString(bstrAliasTypeName);
    return hr;
} // HRESULT CImportTlb::_HandleAliasInfo()

//*****************************************************************************
// Convert one of a function's parameters.
//*****************************************************************************
HRESULT CImportTlb::_ConvParam(
    ITypeInfo   *pITI,                  // Containing TypeInfo.
    mdMethodDef mdFunc,                 // Owning member.
    int         iSequence,              // Parameter sequence.
    const ELEMDESC *pdesc,              // Param flags, default value.
    ParamOpts   paramOpts,              // Is param normal, optional, or vararg?
    LPCWSTR     szName,                 // Name of the parameter.
    BYTE        *pbNative,              // Native type info, if any.
    ULONG       cbNative)               // Size of native type info.
{
    HRESULT     hr;                     // A result.
    mdParamDef  pdParam;                // Token of the parameter.
    DWORD       dwFlags;                // Param flags.
    USHORT      Sequence = static_cast<USHORT>(iSequence);
    BYTE        cvType  = ELEMENT_TYPE_VOID; // ELEMENT_TYPE_* flag for constant value
    void        *pcvValue;              // constant value blob
    __int64     d;                      // For cases where value is a date.
    int         bDecimal=0;             // If true, constant is a decimal.
    mdToken     tkAttr;                 // For custom attribute token.
    DECIMAL     decVal;                 // Decimal constant value.

    // Compute the flags.  Only make sense on non-return params.
    dwFlags = 0;
    if (iSequence > 0)
    {
        if (pdesc->paramdesc.wParamFlags & PARAMFLAG_FIN)
            dwFlags |= pdIn;
        if (pdesc->paramdesc.wParamFlags & PARAMFLAG_FOUT)
            dwFlags |= pdOut;
        if (pdesc->paramdesc.wParamFlags & PARAMFLAG_FOPT)
            dwFlags |= pdOptional;
        if (paramOpts == ParamOptional)
            dwFlags |= pdOptional;
    }

    // Get any default values.  Return type, param with iSequence==0, has no default.
    if (pdesc->paramdesc.wParamFlags & PARAMFLAG_FHASDEFAULT && iSequence != 0)
    {
        switch (pdesc->paramdesc.pparamdescex->varDefaultValue.vt)
        {
        case VT_CY:
        case VT_DECIMAL:
        case VT_DATE:
        case VT_UNKNOWN:
        case VT_DISPATCH:
            break;
        default:
            // This hack is because a typelib can store anything that can convert to VT_I4 with a value of 0
            //  for the default value of an interface pointer.  But, a VT_I2(0) confuses the consumers
            //  of the managed wrapper dll.  So, if it is an interface on the unmanaged side, make
            //  the constant value an ET_CLASS.
            if (cbNative > 0 && (*pbNative == NATIVE_TYPE_INTF ||
                                 *pbNative == NATIVE_TYPE_IUNKNOWN ||
                                 *pbNative == NATIVE_TYPE_IDISPATCH))
        {
                cvType = ELEMENT_TYPE_CLASS;
                pcvValue = 0;
        }
        else
            IfFailGo( _UnpackVariantToConstantBlob(&pdesc->paramdesc.pparamdescex->varDefaultValue, &cvType, &pcvValue, &d) );
        }
    }

    // Create the param definition.
    IfFailGo(m_pEmit->DefineParam(mdFunc, iSequence, szName, dwFlags, cvType, pcvValue, -1, &pdParam));

    // Add the native type if it there is any.
    if (cbNative > 0)
        IfFailGo(m_pEmit->SetFieldMarshal(pdParam, (PCCOR_SIGNATURE) pbNative, cbNative));

    if (pdesc->paramdesc.wParamFlags & PARAMFLAG_FHASDEFAULT && iSequence != 0)
    {
        switch (pdesc->paramdesc.pparamdescex->varDefaultValue.vt)
        {
        case VT_CY:
            IfFailGo(VarDecFromCy(pdesc->paramdesc.pparamdescex->varDefaultValue.cyVal, &decVal));
            DecimalCanonicalize(&decVal);           
            goto StoreDecimal;
        case VT_DECIMAL:
            // If there is a decimal constant value, set it as a custom attribute.
            {
            decVal = pdesc->paramdesc.pparamdescex->varDefaultValue.decVal;
        StoreDecimal:
            DECLARE_CUSTOM_ATTRIBUTE(sizeof(BYTE)+sizeof(BYTE)+sizeof(UINT)+sizeof(UINT)+sizeof(UINT));
            BUILD_CUSTOM_ATTRIBUTE(BYTE, decVal.scale);
            BUILD_CUSTOM_ATTRIBUTE(BYTE, decVal.sign);
            BUILD_CUSTOM_ATTRIBUTE(UINT, decVal.Hi32);
            BUILD_CUSTOM_ATTRIBUTE(UINT, decVal.Mid32);
            BUILD_CUSTOM_ATTRIBUTE(UINT, decVal.Lo32);
            IfFailGo(GetAttrType(ATTR_DECIMALVALUE, &tkAttr));
            FINISH_CUSTOM_ATTRIBUTE();
            IfFailGo(m_pEmit->DefineCustomAttribute(pdParam, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
            }
            break;
        case VT_DATE:
            {
            DECLARE_CUSTOM_ATTRIBUTE(sizeof(__int64));
            __int64 d = _DoubleDateToTicks(pdesc->paramdesc.pparamdescex->varDefaultValue.date);
            BUILD_CUSTOM_ATTRIBUTE(__int64, d);
            IfFailGo(GetAttrType(ATTR_DATETIMEVALUE, &tkAttr));
            FINISH_CUSTOM_ATTRIBUTE();
            IfFailGo(m_pEmit->DefineCustomAttribute(pdParam, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
            }
            break;
        case VT_UNKNOWN:
            {
            DECLARE_CUSTOM_ATTRIBUTE(0);
            IfFailGo(GetAttrType(ATTR_IUNKNOWNVALUE, &tkAttr));
            FINISH_CUSTOM_ATTRIBUTE();
            IfFailGo(m_pEmit->DefineCustomAttribute(pdParam, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
            }
            break;
        case VT_DISPATCH:
            {
            DECLARE_CUSTOM_ATTRIBUTE(0);
            IfFailGo(GetAttrType(ATTR_IDISPATCHVALUE, &tkAttr));
            FINISH_CUSTOM_ATTRIBUTE();
            IfFailGo(m_pEmit->DefineCustomAttribute(pdParam, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
            }
            break;
        default:
            break;
        }
    }

    // Add the alias information if the param is an alias.
    IfFailGo(_HandleAliasInfo(pITI, (TYPEDESC*)&pdesc->tdesc, pdParam));
    
    // If a vararg param, set the custom attribute.
    if (paramOpts == ParamVarArg)
    {
        mdToken     tkAttr;
        DECLARE_CUSTOM_ATTRIBUTE(0);
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(GetAttrType(ATTR_PARAMARRAY, &tkAttr));
        IfFailGo(m_pEmit->DefineCustomAttribute(pdParam, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));
    }

ErrExit:
    return hr;
} // HRESULT CImportTlb::_ConvParam()

//*****************************************************************************
// Convert a constant into a field with a default value.
//*****************************************************************************
HRESULT CImportTlb::_ConvConstant(
    ITypeInfo   *pITI,                  // Containing TypeInfo.
    VARDESC     *psVar,                 // VARDESC for the property.
    BOOL        bEnumMember)            // If true, type is containing class.
{
    HRESULT     hr;                     // A result.
    mdFieldDef  mdField;                // Token of the new field.
    DWORD       dwFlags;                // Member flags.
    CQuickBytes qbComSig;               // The COM+ Signature of the field.
    ULONG       cb, cbTotal;
    BYTE        cvType = ELEMENT_TYPE_VOID; // E_T_Type for constant value
    void        *pcvValue;              // Pointer to constant value data.
    mdToken     tkAttr;                 // Type for custom attribute.
    __int64     d;                      // For cases where value is a date.
    BOOL        bConversionLoss=false;  // If true, some attributes were lost on conversion.
    BYTE        *pbSig;                 // Pointer to signature bytes.
    CQuickArray<BYTE> qbNativeBuf;      // Native type buffer.
    ULONG       cbNative = 0;           // Size of native type.
    int         bDecimal = 0;           // If the value is a decimal.
    DECIMAL     decVal;                 // Decimal constant value.

    // Information about the member.
    IfFailGo(pITI->GetDocumentation(psVar->memid, &m_szMember, 0,0,0));

    // resize to make room for calling convention and count of argument
    IfFailGo(qbComSig.ReSize(CB_MAX_ELEMENT_TYPE * 4));
    pbSig = (BYTE *)qbComSig.Ptr();

    // Compute properties.
    dwFlags = DEFAULT_CONST_FIELD_FLAGS;

    // Build the signature.
    cbTotal = cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_FIELD, pbSig);
    if (bEnumMember)
    {
        cb = CorSigCompressData(ELEMENT_TYPE_VALUETYPE, &pbSig[cbTotal]);
        cbTotal += cb;
        cb = CorSigCompressToken(m_tdTypeDef, reinterpret_cast<ULONG*>(&pbSig[cbTotal]));
        cbTotal += cb;
    }
    else
    {
        // Use the conversion function to get the signature.
        ULONG cbSave = cbTotal;
        IfFailGo(_ConvSignature(pITI, &psVar->elemdescVar.tdesc, SIG_FLAGS_NONE, qbComSig, cbTotal, &cbTotal, qbNativeBuf, 0, &cbNative, FALSE));
        if (hr == S_CONVERSION_LOSS)
            bConversionLoss = true;
        if (psVar->elemdescVar.tdesc.vt == VT_DATE)
        {   // But for dates, convert it as long -- DateTime can't have a value.
            cbTotal = cbSave;
            cb = CorSigCompressData(cvType, &pbSig[cbTotal]);
            cbTotal += cb;
        }
    }
    
    // Get the default value.
    switch (psVar->lpvarValue->vt)
    {
    case VT_CY:
    case VT_DECIMAL:
    case VT_DATE:
    case VT_UNKNOWN:
    case VT_DISPATCH:
        break;
    default:
        // This hack is because a typelib can store anything that can convert to VT_I4 with a value of 0
        //  for the default value of an interface pointer.  But, a VT_I2(0) confuses the consumers
        //  of the managed wrapper dll.  So, if it is an interface on the unmanaged side, make
        //  the constant value an ET_CLASS.
        BYTE *pbNative = qbNativeBuf.Ptr();
        if (cbNative > 0 && (*pbNative == NATIVE_TYPE_INTF ||
                             *pbNative == NATIVE_TYPE_IUNKNOWN ||
                             *pbNative == NATIVE_TYPE_IDISPATCH))
        {
            cvType = ELEMENT_TYPE_CLASS;
            pcvValue = 0;
        }
        else
            IfFailGo( _UnpackVariantToConstantBlob(psVar->lpvarValue, &cvType, &pcvValue, &d) );
    }

    // Create the field definition.
    IfFailGo(m_pEmit->DefineField(m_tdTypeDef, m_szMember, dwFlags, (PCCOR_SIGNATURE)pbSig, cbTotal, 
        cvType, pcvValue, -1, &mdField));

    switch (psVar->lpvarValue->vt)
    {
    case VT_CY:
        IfFailGo(VarDecFromCy(psVar->lpvarValue->cyVal, &decVal));
        DecimalCanonicalize(&decVal);
        goto StoreDecimal;
    case VT_DECIMAL:
        // If there is a decimal constant value, set it as a custom attribute.
        {
        decVal = psVar->lpvarValue->decVal;
    StoreDecimal:
        DECLARE_CUSTOM_ATTRIBUTE(sizeof(BYTE)+sizeof(BYTE)+sizeof(UINT)+sizeof(UINT)+sizeof(UINT));
        BUILD_CUSTOM_ATTRIBUTE(BYTE, decVal.scale);
        BUILD_CUSTOM_ATTRIBUTE(BYTE, decVal.sign);
        BUILD_CUSTOM_ATTRIBUTE(UINT, decVal.Hi32);
        BUILD_CUSTOM_ATTRIBUTE(UINT, decVal.Mid32);
        BUILD_CUSTOM_ATTRIBUTE(UINT, decVal.Lo32);
        IfFailGo(GetAttrType(ATTR_DECIMALVALUE, &tkAttr));
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(mdField, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
        }
        break;
    case VT_DATE:
        {
        DECLARE_CUSTOM_ATTRIBUTE(sizeof(__int64));
        __int64 d = _DoubleDateToTicks(psVar->lpvarValue->date);
        BUILD_CUSTOM_ATTRIBUTE(__int64, d);
        IfFailGo(GetAttrType(ATTR_DATETIMEVALUE, &tkAttr));
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(mdField, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
        }
        break;
    case VT_UNKNOWN:
        {
        DECLARE_CUSTOM_ATTRIBUTE(0);
        IfFailGo(GetAttrType(ATTR_IUNKNOWNVALUE, &tkAttr));
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(mdField, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
        }
        break;
    case VT_DISPATCH:
        {
        DECLARE_CUSTOM_ATTRIBUTE(0);
        IfFailGo(GetAttrType(ATTR_IDISPATCHVALUE, &tkAttr));
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(mdField, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
        }
        break;
    default:
        break;
    }

    // Save the field flags.
    if (psVar->wVarFlags)
    {
        IfFailGo(GetAttrType(ATTR_TYPELIBVAR, &tkAttr));
        DECLARE_CUSTOM_ATTRIBUTE(sizeof(WORD));
        BUILD_CUSTOM_ATTRIBUTE(WORD, psVar->wVarFlags);
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(mdField, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
    }

    // Set up the native description, if any.
    if (cbNative > 0)
        IfFailGo(m_pEmit->SetFieldMarshal(mdField, (PCCOR_SIGNATURE) qbNativeBuf.Ptr(), cbNative));

    // Add the alias information if the type is an alias.
    IfFailGo(_HandleAliasInfo(pITI, &psVar->elemdescVar.tdesc, mdField));
    
    if (bConversionLoss)
    {
        hr = S_CONVERSION_LOSS;
        ReportEvent(NOTIF_CONVERTWARNING, TLBX_I_UNCONVERTABLE_FIELD, m_szName, m_szMember);
    }

ErrExit:
    if (m_szMember)
        ::SysFreeString(m_szMember), m_szMember=0;
    return (hr);
} // HRESULT CImportTlb::_ConvConstant()

//*****************************************************************************
// Convert a (record) field into a member.
//*****************************************************************************
HRESULT CImportTlb::_ConvField(
    ITypeInfo   *pITI,                  // Containing TypeInfo.
    VARDESC     *psVar,                 // VARDESC for the property.
    mdFieldDef  *pmdField,              // Put field token here.
    BOOL        bUnion)                 // Convert as a union?
{
    HRESULT     hr;                     // A result.
    DWORD       dwFlags;                // Member flags.
    CQuickBytes qbComSig;               // The COM+ Signature of the field.
    ULONG       cb, cbTotal;            // Size of a sig element, signature.
    BYTE        *pbSig;                 // Pointer to signature bytes.
    CQuickArray<BYTE> qbNativeBuf;      // Native type buffer.
    ULONG       cbNative;               // Size of native type.
    mdToken     tkAttr;                 // CustomAttribute type.
    BOOL        bConversionLoss=false;  // If true, some attributes were lost on conversion.

    // Information about the member.
    IfFailGo(pITI->GetDocumentation(psVar->memid, &m_szMember, 0,0,0));

    // Compute properties.
    dwFlags = DEFAULT_RECORD_FIELD_FLAGS;

    // resize to make room for calling convention and count of argument
    IfFailGo(qbComSig.ReSize(CB_MAX_ELEMENT_TYPE * 2));
    pbSig = (BYTE *)qbComSig.Ptr();

    // Build the signature.
    cbTotal = cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_FIELD, pbSig);
    IfFailGo(_ConvSignature(pITI, &psVar->elemdescVar.tdesc, SIG_FIELD, qbComSig, cbTotal, &cbTotal, qbNativeBuf, 0, &cbNative, FALSE));
    if (hr == S_CONVERSION_LOSS)
        bConversionLoss = true;

    // Create the field definition.
    IfFailGo(m_pEmit->DefineField(m_tdTypeDef, m_szMember, dwFlags, (PCCOR_SIGNATURE) qbComSig.Ptr(),cbTotal, 
        ELEMENT_TYPE_VOID, NULL, -1, pmdField));

    // Save the field flags.
    if (psVar->wVarFlags)
    {
        IfFailGo(GetAttrType(ATTR_TYPELIBVAR, &tkAttr));
        DECLARE_CUSTOM_ATTRIBUTE(sizeof(WORD));
        BUILD_CUSTOM_ATTRIBUTE(WORD, psVar->wVarFlags);
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(*pmdField, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(),0));
    }

    if (bConversionLoss)
    {
        IfFailGo(GetAttrType(ATTR_COMCONVERSIONLOSS, &tkAttr));
        DECLARE_CUSTOM_ATTRIBUTE(0);
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(*pmdField, tkAttr, PTROF_CUSTOM_ATTRIBUTE(),SIZEOF_CUSTOM_ATTRIBUTE(),0));
    }

    // Set up the native description, if any.
    if (cbNative > 0)
        IfFailGo(m_pEmit->SetFieldMarshal(*pmdField, (PCCOR_SIGNATURE) qbNativeBuf.Ptr(), cbNative));

    // Add the alias information if the type is an alias.
    IfFailGo(_HandleAliasInfo(pITI, &psVar->elemdescVar.tdesc, *pmdField));
    
    if (bConversionLoss)
    {
        hr = S_CONVERSION_LOSS;
        ReportEvent(NOTIF_CONVERTWARNING, TLBX_I_UNCONVERTABLE_FIELD, m_szName, m_szMember);
    }

ErrExit:
    if (m_szMember)
        ::SysFreeString(m_szMember), m_szMember=0;
    return (hr);
} // HRESULT CImportTlb::_ConvField()

//*****************************************************************************
// Convert a dispatch property into a pair of get/set functions.
//*****************************************************************************
HRESULT CImportTlb::_ConvProperty(
    ITypeInfo   *pITI,                  // Containing TypeInfo.
    MemberInfo  *pMember)               // VARDESC for the property.
{
    HRESULT     hr;                     // A result.
    mdMethodDef mdFuncGet;              // A get function.
    mdMethodDef mdFuncSet;              // A set function.
    mdProperty  pdProperty;             // Property on the two functions.
    DWORD       dwFlags;                // Function flags.
    WCHAR       *pszName=0;             // Decorated name of member.
    CQuickArray<WCHAR> qbName;          // Buffer for decorated name.
    CQuickBytes qbComSig;               // com signature buffer
    ULONG       cb;                     // Size of an element.
    ULONG       cbTotal = 0;            // Total size of signature.
    BYTE        *pbSig;                 // Pointer to signature buffer.
    BOOL        bConversionLoss=false;  // If true, some attributes were lost on conversion.
    CQuickArray<BYTE> qbNativeBuf;      // Native type buffer.
    ULONG       iNativeOfs=0;           // Current offset in native type buffer.
    VARDESC     *psVar = pMember->m_psVar;

    // Check to see if the property is the NewEnum member.
    if (PropertyIsNewEnum(pITI, psVar, pMember->m_iMember) == S_OK)
        return _ConvNewEnumProperty(pITI, psVar, pMember);

    // Get the name.
    IfFailGo(pITI->GetDocumentation(psVar->memid, &m_szMember, 0,0,0));

    // Create the get signature.
    IfFailGo(qbComSig.ReSize(CB_MAX_ELEMENT_TYPE * 2));
    pbSig = reinterpret_cast<BYTE*>(qbComSig.Ptr());
    cbTotal = cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS, pbSig);
    // Getter takes zero parameters.
    cb = CorSigCompressData(0, &(pbSig[cb]));
    cbTotal += cb;
    // Getter returns the property type.
    IfFailGo(_ConvSignature(pITI, &psVar->elemdescVar.tdesc, SIG_ELEM, qbComSig, cbTotal, &cbTotal, qbNativeBuf, 0, &iNativeOfs, FALSE));
    if (hr == S_CONVERSION_LOSS)
        bConversionLoss = true;

    // Getter properties.
    dwFlags = DEFAULT_PROPERTY_FUNC_FLAGS;
    // If processing an implemented interface, remove the abstract bit.  Methods on classes are not abstract.
    if (m_ImplIface != eImplIfaceNone)
        dwFlags &= ~mdAbstract;

    // Get the previously decorated name.  Add interface name and make unique.
    // m_szInterface should be non-null if processing an implemented interface; should be null otherwise.
    _ASSERTE(m_ImplIface == eImplIfaceNone || m_szInterface != 0);
    IfFailGo(qbName.ReSize(wcslen(pMember->m_pName)+2));
    wcscpy(qbName.Ptr(), pMember->m_pName); 
    IfFailGo(GenerateUniqueMemberName(qbName, (PCCOR_SIGNATURE)qbComSig.Ptr(), cbTotal, m_szInterface, mdtMethodDef));
    pszName = qbName.Ptr();

    // Create the get Accessor.
    IfFailGo(m_pEmit->DefineMethod(m_tdTypeDef, pszName, dwFlags, (PCCOR_SIGNATURE) qbComSig.Ptr(), cbTotal, 
        0/*RVA*/, DEFAULT_ITF_FUNC_IMPL_FLAGS, &mdFuncGet));
   
    // Handle dispids for non-implemented interfaces, and for default interface
    if (m_ImplIface != eImplIface)
    {
        // Set the Dispid CA.
        _SetDispIDCA(pITI, pMember->m_iMember, psVar->memid, mdFuncGet, TRUE, NULL, FALSE);
    }
    
    // If processing an implemented interface, set up MethodImpls.
    if (m_ImplIface != eImplIfaceNone)
    {
        // Define a memberref on the implemented interface.
        mdToken mrItfMember;
        IfFailGo(m_pEmit->DefineMemberRef(m_tkInterface, pMember->m_pName, (PCCOR_SIGNATURE) qbComSig.Ptr(),cbTotal, &mrItfMember));

        // Define a method impl.
        IfFailGo(m_pEmit->DefineMethodImpl(m_tdTypeDef, mdFuncGet, mrItfMember));
    }

    // If not a read-only var, create the setter.
    if ((psVar->wVarFlags & VARFLAG_FREADONLY) == 0)
    {
        // Create the setter signature.
        IfFailGo(qbComSig.ReSize(CB_MAX_ELEMENT_TYPE * 3));
        pbSig = reinterpret_cast<BYTE*>(qbComSig.Ptr());
        cbTotal = cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS, pbSig);
        // Setter takes one parameter.
        cb = CorSigCompressData(1, &(pbSig[cb]));
        cbTotal += cb;
        // Setter returns nothing.
        cb = CorSigCompressData(ELEMENT_TYPE_VOID, &pbSig[cbTotal]);
        cbTotal += cb;
        // Setter takes the property type.
        IfFailGo(_ConvSignature(pITI, &psVar->elemdescVar.tdesc, SIG_ELEM, qbComSig, cbTotal, &cbTotal, qbNativeBuf, 0, &iNativeOfs, FALSE));
        if (hr == S_CONVERSION_LOSS)
            bConversionLoss = true;

        // Setter properties.
        dwFlags = DEFAULT_PROPERTY_FUNC_FLAGS;
        // If processing an implemented interface, remove the abstract bit.  Methods on classes are not abstract.
        if (m_ImplIface != eImplIfaceNone)
            dwFlags &= ~mdAbstract;

        // Get the previously decorated name.  Add interface name and make unique.
        // m_szInterface should be non-null if processing an implemented interface; should be null otherwise.
        _ASSERTE(m_ImplIface == eImplIfaceNone || m_szInterface != 0);
        IfFailGo(qbName.ReSize(wcslen(pMember->m_pName2)+2));
        wcscpy(qbName.Ptr(), pMember->m_pName2); 
        IfFailGo(GenerateUniqueMemberName(qbName, (PCCOR_SIGNATURE)qbComSig.Ptr(), cbTotal, m_szInterface, mdtMethodDef));
        pszName = qbName.Ptr();

        // Create the setter Accessor.
        IfFailGo(m_pEmit->DefineMethod(m_tdTypeDef, pszName, dwFlags, (PCCOR_SIGNATURE) qbComSig.Ptr(),cbTotal, 
            0/*RVA*/, DEFAULT_ITF_FUNC_IMPL_FLAGS, &mdFuncSet));

        // Handle dispids for non-implemented interfaces, and for default interface
        if (m_ImplIface != eImplIface)
        {
            // Set the Dispid CA.
            _SetDispIDCA(pITI, pMember->m_iMember, psVar->memid, mdFuncSet, TRUE, NULL, FALSE);
        }
        
        // If processing an implemented interface, set up MethodImpls.
        if (m_ImplIface != eImplIfaceNone)
        {
            // Define a memberref on the implemented interface.
            mdToken mrItfMember;
            IfFailGo(m_pEmit->DefineMemberRef(m_tkInterface, pMember->m_pName2, (PCCOR_SIGNATURE) qbComSig.Ptr(),cbTotal, &mrItfMember));

            // Define a method impl.
            IfFailGo(m_pEmit->DefineMethodImpl(m_tdTypeDef, mdFuncSet, mrItfMember));
        }
    }
    else
    {   // read-only, setter method is nil.
        mdFuncSet = mdMethodDefNil;
    }

    // Create the property signature: 'type', or <fieldcallconv><type>
    cbTotal = cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_PROPERTY, pbSig);
    cb = CorSigCompressData(0, &(pbSig[cb]));
    cbTotal += cb;
    // Property is just the property type.
    IfFailGo(_ConvSignature(pITI, &psVar->elemdescVar.tdesc, SIG_ELEM, qbComSig, cbTotal, &cbTotal, qbNativeBuf, 0, &iNativeOfs, FALSE));
    if (hr == S_CONVERSION_LOSS)
        bConversionLoss = true;

    // Get the property name.  Add interface name and make unique, if needed.
    // m_szInterface should be non-null if processing an implemented interface; should be null otherwise.
    _ASSERTE(m_ImplIface == eImplIfaceNone || m_szInterface != 0);
    IfFailGo(qbName.ReSize(wcslen(m_szMember)+2));
    wcscpy(qbName.Ptr(), m_szMember); 
    IfFailGo(GenerateUniqueMemberName(qbName, (PCCOR_SIGNATURE)qbComSig.Ptr(), cbTotal, m_szInterface, mdtProperty));
    pszName = qbName.Ptr();

    // Set up the Property on the two methods.
    IfFailGo(m_pEmit->DefineProperty(m_tdTypeDef, pszName, 0/*dwFlags*/, (PCCOR_SIGNATURE) qbComSig.Ptr(),cbTotal, ELEMENT_TYPE_VOID, NULL/*default*/, -1,
        mdFuncSet, mdFuncGet, NULL, &pdProperty));

    // Handle dispids for non-implemented interfaces, and for default interface
    if (m_ImplIface != eImplIface)
    {
        // Set the Dispid CA on the property.
        long lDispSet = 1;
        _SetDispIDCA(pITI, pMember->m_iMember, psVar->memid, pdProperty, TRUE, &lDispSet, FALSE);

        // If this property is default property, add a custom attribute to the class.
        if (lDispSet == DISPID_VALUE)
            IfFailGo(_AddDefaultMemberCa(m_tdTypeDef, m_szMember));
    }

    // Add the alias information if the type is an alias.
    IfFailGo(_HandleAliasInfo(pITI, &psVar->elemdescVar.tdesc, pdProperty));

    if (bConversionLoss)
    {
        hr = S_CONVERSION_LOSS;
        ReportEvent(NOTIF_CONVERTWARNING, TLBX_I_UNCONVERTABLE_ARGS, m_szName, m_szMember);
    }

ErrExit:
    if (m_szMember)
        ::SysFreeString(m_szMember), m_szMember=0;
    return (hr);
} // HRESULT CImportTlb::_ConvProperty()

//*****************************************************************************
// Convert the NewEnum dispatch property into the GetEnumerator method.
//*****************************************************************************
HRESULT CImportTlb::_ConvNewEnumProperty(
    ITypeInfo   *pITI,                  // Containing TypeInfo.
    VARDESC     *psVar,                 // VARDESC for the property.
    MemberInfo  *pMember)
{
    HRESULT     hr;                     // A result.
    mdMethodDef mdGetEnum;              // The GetEnumerator method.
    CQuickBytes qbComSig;               // com signature buffer
    ULONG       cb;                     // Size of an element.
    ULONG       cbTotal = 0;            // Total size of signature.
    BYTE        *pbSig;                 // Pointer to signature buffer.
    BOOL        bConversionLoss=false;  // If true, some attributes were lost on conversion.
    CQuickArray<BYTE> qbNativeBuf;      // Native type buffer.
    ULONG       iNativeOfs=0;           // Current offset in native type buffer.

    // Get the name.
    IfFailGo(pITI->GetDocumentation(psVar->memid, &m_szMember, 0,0,0));

    // Create the GetEnumerator signature.
    IfFailGo(qbComSig.ReSize(CB_MAX_ELEMENT_TYPE * 2));
    pbSig = reinterpret_cast<BYTE*>(qbComSig.Ptr());
    cbTotal = cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_DEFAULT | IMAGE_CEE_CS_CALLCONV_HASTHIS, pbSig);

    // GetEnumerator takes zero parameters.
    cb = CorSigCompressData(0, &(pbSig[cb]));
    cbTotal += cb;

    // Getter returns the property type.
    IfFailGo(_ConvSignature(pITI, &psVar->elemdescVar.tdesc, SIG_ELEM, qbComSig, cbTotal, &cbTotal, qbNativeBuf, 0, &iNativeOfs, TRUE));
    if (hr == S_CONVERSION_LOSS)
        bConversionLoss = true;

    // Create the GetEnumerator method.
    IfFailGo(m_pEmit->DefineMethod(m_tdTypeDef, GET_ENUMERATOR_MEMBER_NAME, DEFAULT_INTERFACE_FUNC_FLAGS, (PCCOR_SIGNATURE) qbComSig.Ptr(), cbTotal, 
        0/*RVA*/, DEFAULT_ITF_FUNC_IMPL_FLAGS, &mdGetEnum));

    // Set the Dispid CA.
    _SetDispIDCA(pITI, pMember->m_iMember, psVar->memid, mdGetEnum, TRUE, NULL, FALSE);

    // Add the alias information if the type is an alias.
    IfFailGo(_HandleAliasInfo(pITI, &psVar->elemdescVar.tdesc, mdGetEnum));

    if (bConversionLoss)
    {
        hr = S_CONVERSION_LOSS;
        ReportEvent(NOTIF_CONVERTWARNING, TLBX_I_UNCONVERTABLE_ARGS, m_szName, m_szMember);
    }

ErrExit:
    if (m_szMember)
        ::SysFreeString(m_szMember), m_szMember=0;
    return (hr);
} // HRESULT CImportTlb::_ConvNewEnumProperty()

//*****************************************************************************
// Given an ITypeLib*, come up with a namespace name.  Use the typelib name
//  unless there is one specified via custom attribute.
//
// NOTE:  This returns the member variable m_wzNamespace if the typelib
//  is the importing typelib.  That must not be freed!
//*****************************************************************************
HRESULT CImportTlb::GetNamespaceOfRefTlb(
    ITypeLib    *pITLB,                 // TypeLib for which to get namespace name.
    BSTR        *pwzNamespace,          // Put the name here.
    CImpTlbDefItfToClassItfMap **ppDefItfToClassItfMap) // Put def itf to class itf map here.
{
    mdAssemblyRef arDummy;
    BSTR          wzAsmName = NULL;
    HRESULT       hr = S_OK;
        
    // If already resolved, just return assembly ref.
    if (!m_LibRefs.Find(pITLB, &arDummy, pwzNamespace, &wzAsmName, NULL, ppDefItfToClassItfMap))
    {
        // Add a reference to the typelib.
        IfFailGo(_AddTlbRef(pITLB, &arDummy, pwzNamespace, &wzAsmName, ppDefItfToClassItfMap));
    }

ErrExit:
    if (wzAsmName)
        ::SysFreeString(wzAsmName);

    return hr;
} // HRESULT CImportTlb::GetNamespaceOfRefTlb()

//*****************************************************************************
// Given a TYPEDESC, resolve the USERDEFINED to the TYPEKIND.
//*****************************************************************************
HRESULT CImportTlb::_ResolveTypeDescAliasTypeKind(
    ITypeInfo   *pITIAlias,             // The typeinfo containing the typedesc.
    TYPEDESC    *ptdesc,                // The typedesc.
    TYPEKIND    *ptkind)                // Put the aliased typekind.
{
    HRESULT     hr;                     // A result.
    ITypeInfo   *pTIResolved=0;     // The resolved ITypeInfo.
    TYPEATTR    *psResolved=0;      // The resolved TypeInfo's TYPEATTR

    if (ptdesc->vt != VT_USERDEFINED)
    {
        *ptkind = TKIND_MAX;
        return S_FALSE;
    }

    hr = _ResolveTypeDescAlias(pITIAlias, ptdesc, &pTIResolved, &psResolved);
    if (hr == S_OK)
        *ptkind = psResolved->typekind;
    else
        *ptkind = TKIND_MAX;

    if (psResolved)
        pTIResolved->ReleaseTypeAttr(psResolved);
    if (pTIResolved)
        pTIResolved->Release();

    return hr;
} // HRESULT CImportTlb::_ResolveTypeDescAliasTypeKind()

//*****************************************************************************
// Given a TYPEDESC in a TypeInfo, eliminate aliases (get to the aliased
//  type).
//*****************************************************************************
HRESULT CImportTlb::_ResolveTypeDescAlias(
    ITypeInfo   *pITIAlias,             // The typeinfo containing the typedesc.
    const TYPEDESC  *ptdesc,            // The typedesc.
    ITypeInfo   **ppTIResolved,         // Put the aliased ITypeInfo here.
    TYPEATTR    **ppsAttrResolved,      // Put the ITypeInfo's TYPEATTR here.
    GUID        *pGuid)                 // Caller may want aliased object's guid.
{
    HRESULT     hr;                     // A result.
    ITypeInfo   *pITI=0;                // Referenced typeinfo.
    TYPEATTR    *psAttr=0;              // TYPEATTR of referenced typeinfo.

    // If the TDESC isn't a USERDEFINED, it is already resolved.
    if (ptdesc->vt != VT_USERDEFINED)
    {
        *ppTIResolved = pITIAlias;
        pITIAlias->AddRef();
        // Need to addref the [out] psAttr.  Only way to do it:
        IfFailGo(pITIAlias->GetTypeAttr(ppsAttrResolved));
        hr = S_FALSE;
        goto ErrExit;
    }

    // The TYPEDESC is a USERDEFINED.  Get the TypeInfo.
    IfFailGo(pITIAlias->GetRefTypeInfo(ptdesc->hreftype, &pITI));
    IfFailGo(pITI->GetTypeAttr(&psAttr));

    // If the caller needs the aliased object's guid, get it now.
    if (pGuid && *pGuid == GUID_NULL && psAttr->guid != GUID_NULL)
        *pGuid = psAttr->guid;

    // If the userdefined typeinfo is not itself an alias, then it is what the alias aliases.
    //  Also, if the userdefined typeinfo is an alias to a builtin type, then the builtin
    //  type is what the alias aliases.
    if (psAttr->typekind != TKIND_ALIAS || psAttr->tdescAlias.vt != VT_USERDEFINED)
    {
        *ppsAttrResolved = psAttr;
        *ppTIResolved = pITI;
        if (psAttr->typekind == TKIND_ALIAS)
            hr = S_FALSE;
        psAttr = 0;
        pITI = 0;
        goto ErrExit;
    }

    // The userdefined type was itself an alias to a userdefined type.  Alias to what?
    hr = _ResolveTypeDescAlias(pITI, &psAttr->tdescAlias, ppTIResolved, ppsAttrResolved, pGuid);

ErrExit:
    if (psAttr)
        pITI->ReleaseTypeAttr(psAttr);
    if (pITI)
        pITI->Release();
    return hr;
} // HRESULT CImportTlb::_ResolveTypeDescAlias()

//*****************************************************************************
// Create the TypeInfo records (AKA classes, AKA critters).
//*****************************************************************************
HRESULT CImportTlb::GetKnownTypeToken(
    VARTYPE     vt,                     // The type for which the token is desired.
    mdTypeRef   *ptr)                   // Put the token here.
{
    HRESULT     hr = S_OK;                  // A result.

    _ASSERTE((vt >= VT_CY && vt <= VT_DECIMAL) || (vt == VT_SAFEARRAY) || (vt == VT_SLOT_FOR_GUID) || (vt == VT_SLOT_FOR_IENUMERABLE) || (vt == VT_SLOT_FOR_MULTICASTDEL) || (vt == VT_SLOT_FOR_TYPE));

    // If it has already been added, just return it.
    if (m_tkKnownTypes[vt])
    {
        *ptr = m_tkKnownTypes[vt];
        goto ErrExit;
    }

    // Not yet created, so create the typeref now.
    switch (vt)
    {
    //=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+=+
    // WARNING:  the VT_EMPTY slot is used for System.GUID!!        
    case VT_SLOT_FOR_GUID:
        _ASSERTE(VT_SLOT_FOR_GUID == VT_EMPTY);
        IfFailGo(m_TRMap.DefineTypeRef(         
            m_pEmit,                        // The emit scope.
            m_arSystem,                     // The system assemblyref.
            TLB_CLASSLIB_GUID,              // URL of the TypeDef, wide chars.
            &m_tkKnownTypes[VT_SLOT_FOR_GUID]));    // Put mdTypeRef here
        break;

    // WARNING:  the VT_NULL slot is used for System.Collections.IEnumerable!!        
    case VT_SLOT_FOR_IENUMERABLE:
        _ASSERTE(VT_SLOT_FOR_IENUMERABLE == VT_NULL);
        IfFailGo(m_TRMap.DefineTypeRef(         
            m_pEmit,                        // The emit scope.
            m_arSystem,                     // The system assemblyref.
            TLB_CLASSLIB_IENUMERABLE,       // URL of the TypeDef, wide chars.
            &m_tkKnownTypes[VT_SLOT_FOR_IENUMERABLE]));    // Put mdTypeRef here
        break;

    // WARNING:  the VT_I2 slot is used for System.MulticastDelegate!!        
    case VT_SLOT_FOR_MULTICASTDEL:
        _ASSERTE(VT_SLOT_FOR_MULTICASTDEL == VT_I2);
        IfFailGo(m_TRMap.DefineTypeRef(         
            m_pEmit,                        // The emit scope.
            m_arSystem,                     // The system assemblyref.
            TLB_CLASSLIB_MULTICASTDELEGATE, // URL of the TypeDef, wide chars.
            &m_tkKnownTypes[VT_SLOT_FOR_MULTICASTDEL]));    // Put mdTypeRef here
        break;

    // WARNING:  the VT_I4 slot is used for System.MulticastDelegate!!        
    case VT_SLOT_FOR_TYPE:
        _ASSERTE(VT_SLOT_FOR_TYPE == VT_I4);
        IfFailGo(m_TRMap.DefineTypeRef(         
            m_pEmit,                        // The emit scope.
            m_arSystem,                     // The system assemblyref.
            TLB_CLASSLIB_TYPE,              // URL of the TypeDef, wide chars.
            &m_tkKnownTypes[VT_SLOT_FOR_TYPE]));    // Put mdTypeRef here
        break;

    case VT_CY:
        IfFailGo(m_TRMap.DefineTypeRef(         
            m_pEmit,                        // The emit scope.
            m_arSystem,                     // The system assemblyref.
            TLB_CLASSLIB_DECIMAL,           // URL of the TypeDef, wide chars.
            &m_tkKnownTypes[VT_CY]));       // Put mdTypeRef here
        break;
        
    case VT_DATE:
        IfFailGo(m_TRMap.DefineTypeRef(         
            m_pEmit,                        // The emit scope.
            m_arSystem,                     // The system assemblyref.
            TLB_CLASSLIB_DATE,              // URL of the TypeDef, wide chars.
            &m_tkKnownTypes[VT_DATE]));     // Put mdTypeRef here
        break;

    case VT_DECIMAL:
        IfFailGo(m_TRMap.DefineTypeRef(         
            m_pEmit,                        // The emit scope.
            m_arSystem,                     // The system assemblyref.
            TLB_CLASSLIB_DECIMAL,           // URL of the TypeDef, wide chars.
            &m_tkKnownTypes[VT_DECIMAL]));  // Put mdTypeRef here
        break;

    case VT_SAFEARRAY:
        IfFailGo(m_TRMap.DefineTypeRef(         
            m_pEmit,                        // The emit scope.
            m_arSystem,                     // The system assemblyref.
            TLB_CLASSLIB_ARRAY,             // URL of the TypeDef, wide chars.
            &m_tkKnownTypes[VT_SAFEARRAY]));  // Put mdTypeRef here
        break;
            
    default:
        _ASSERTE(!"Unknown type in GetKnownTypes");
        IfFailGo(E_INVALIDARG);
    }

    _ASSERTE(!IsNilToken(m_tkKnownTypes[vt]));
    *ptr = m_tkKnownTypes[vt];
    
ErrExit:
    return hr;
} // HRESULT CImportTlb::GetKnownTypeToken()


//*****************************************************************************
// Given an ITypeInfo for a coclass, return an ITypeInfo for the default
//  interface.  This is either the explicitly marked default, or the first
//  non-source interface.
//*****************************************************************************
HRESULT CImportTlb::GetDefaultInterface(    // Error, S_OK or S_FALSE.
    ITypeInfo *pCoClassTI,                  // The TypeInfo of the coclass.
    ITypeInfo **pDefaultItfTI)              // The returned default interface.
{
    HRESULT     hr;                 // A result
    HREFTYPE    href;               // HREFTYPE of an implemented interface.
    INT         ImplFlags;          // ImplType flags.
    ITypeInfo   *pITI=NULL;         // ITypeInfo for an interface.
    TYPEATTR    *pCoClassTypeAttr;  // The type attributes of the coclass.
    int         NumInterfaces;      // The number of interfaces on the coclass.
    int         i;                  // A counter.

    // Initialize the default interface to NULL.
    *pDefaultItfTI = NULL;

    // Retrieve the number of interfaces the coclass has
    IfFailGo(pCoClassTI->GetTypeAttr(&pCoClassTypeAttr));
    NumInterfaces = pCoClassTypeAttr->cImplTypes;
    pCoClassTI->ReleaseTypeAttr(pCoClassTypeAttr);

    for (i=0; i < NumInterfaces; i++)
    {
        IfFailGo(pCoClassTI->GetImplTypeFlags(i, &ImplFlags));

        if ((ImplFlags & (IMPLTYPEFLAG_FSOURCE | IMPLTYPEFLAG_FDEFAULT)) == IMPLTYPEFLAG_FDEFAULT)
        {
            // We have found a default interface.
            if (*pDefaultItfTI)
                (*pDefaultItfTI)->Release();

            IfFailGo(pCoClassTI->GetRefTypeOfImplType(i, &href));
            IfFailGo(pCoClassTI->GetRefTypeInfo(href, pDefaultItfTI));
            break;
        } 
        else if (!(ImplFlags & IMPLTYPEFLAG_FSOURCE) && !(*pDefaultItfTI))
        {
            // If this is the first normal interface we encounter then we need to 
            // hang on to it in case we don't find any default interfaces. If that
            // happens then this is the one that will be returned.
            IfFailGo(pCoClassTI->GetRefTypeOfImplType(i, &href));
            IfFailGo(pCoClassTI->GetRefTypeInfo(href, pDefaultItfTI));
        }       
    }

    // Return either S_OK or S_FALSE depending on if we have found a default interface.
    if (*pDefaultItfTI)
        return S_OK;
    else
        return S_FALSE;

ErrExit:
    if (pITI)
        pITI->Release();

    return hr;
} // HRESULT CImportTlb::GetDefaultInterface()

//*****************************************************************************
// Given a TypeInfo, return a TypeDef/TypeRef token.
//*****************************************************************************
HRESULT CImportTlb::_GetTokenForTypeInfo(
    ITypeInfo   *pITI,                  // ITypeInfo for which to get token.
    BOOL        bConvDefItfToClassItf,  // If TRUE, convert the def itf to its class itf.
    mdToken     *pToken,                // Put the token here.
    LPWSTR      pszTypeRef,             // Optional, put the name here.
    int         chTypeRef,              // Size of the name buffer.
    int         *pchTypeRef,            // Optional, put size of name here.
    BOOL        bAsmQualifiedName)      // Assembly qualified name or not?
{
    HRESULT     hr;                     // A result.
    ITypeLib    *pITLB=0;               // Containing typelib.
    BSTR        bstrNamespace=0;        // Namespace of the type.
    BSTR        bstrFullName=0;         // Fully qualified name of type.
    BSTR        bstrTempName=0;         // Temp name.
    BSTR        bstrAsmName=0;          // Assembly name.
    LPCWSTR     strTypeName=0;          // The type name.
    mdAssemblyRef ar;                   // The typelib's assembly ref.
    TYPEATTR*   psAttr = 0;             // The TYPEATTR for the type info.
    CImpTlbDefItfToClassItfMap *pDefItfToClassItfMap; // The default interface to class interface map.

    // Get the library.
    IfFailGo(pITI->GetContainingTypeLib(&pITLB, 0));
   
    // Resolve the external reference.
    IfFailGo(_AddTlbRef(pITLB, &ar, &bstrNamespace, &bstrAsmName, &pDefItfToClassItfMap));

    // If are converting default interfaces to class interfaces, then check
    // to see if we need to do the convertion for the current ITypeInfo.
    if (bConvDefItfToClassItf)
    {
        // Retrieve the TYPEATTR.
        IfFailGo(pITI->GetTypeAttr(&psAttr));

        // If we are dealing with an interface, then check to see if there
        // is a class interface we should use.
        if (psAttr->typekind == TKIND_INTERFACE || psAttr->typekind == TKIND_DISPATCH)
        {
            strTypeName = pDefItfToClassItfMap->GetClassItfName(psAttr->guid);
        }
    }

    // If we haven't found a class interface, then use the current interface.
    if (!strTypeName)
    {
    // Get the name of the typeinfo.
    IfFailGo(GetManagedNameForTypeInfo(pITI, bstrNamespace, NULL, &bstrFullName));
        strTypeName = bstrFullName;
    }
    
    // Give name back to caller, if desired.
    if (pszTypeRef)
        wcsncpy(pszTypeRef, strTypeName, chTypeRef);
    if (pchTypeRef)
        *pchTypeRef = (int)(wcslen(strTypeName) + 1);

    // Define the TypeRef (will return any existing typeref).
    IfFailGo(m_TRMap.DefineTypeRef(m_pEmit, ar, strTypeName, pToken));

    // If the caller desires an assembly qualified name, then provide it.
    if (bAsmQualifiedName)
    {
        int cchAsmQualifiedName = SysStringLen(bstrFullName) + SysStringLen(bstrAsmName) + 2;
        IfNullGo(bstrTempName = ::SysAllocStringLen(0, cchAsmQualifiedName));
        ns::MakeAssemblyQualifiedName(bstrTempName, cchAsmQualifiedName + 1, bstrFullName, SysStringLen(bstrFullName), bstrAsmName, SysStringLen(bstrAsmName));
        SysFreeString(bstrFullName);
        bstrFullName = bstrTempName;
    }

    // Give name back to caller, if desired.
    if (pszTypeRef)
        wcsncpy(pszTypeRef, bstrFullName, chTypeRef);
    if (pchTypeRef)
        *pchTypeRef = (int)(wcslen(bstrFullName) + 1);

ErrExit:
    if (bstrNamespace)
        ::SysFreeString(bstrNamespace);
    if (bstrFullName)
        ::SysFreeString(bstrFullName);
    if (bstrAsmName)
        ::SysFreeString(bstrAsmName);
    if (pITLB)
        pITLB->Release();
    if (psAttr)
        pITI->ReleaseTypeAttr(psAttr);

    return (hr);
} // HRESULT CImportTlb::_GetTokenForTypeInfo()

//*****************************************************************************
// Given a TypeInfo for a source interface, creates a new event interface
// if none exists or returns an existing one.
//*****************************************************************************
HRESULT CImportTlb::_GetTokenForEventItf(ITypeInfo *pSrcItfITI, mdTypeRef *ptr)
{
    HRESULT             hr = S_OK;                  // A result.   
    ImpTlbEventInfo*    pEventInfo;                 // The event information.
    BSTR                bstrSrcItfName = NULL;      // The name of the CoClass.
    CQuickArray<WCHAR>  qbEventItfName;             // The name of the event interface.
    CQuickArray<WCHAR>  qbEventProviderName;        // The name of the event provider.
    mdToken             tkAttr;                     // Custom attribute type.
    BSTR                szOldName = NULL;           // The old value m_tdTypeDef.
    mdTypeDef           tdOldTypeDef = NULL;        // The old value m_szName.
    TYPEATTR*           psAttr = 0;                 // The TYPEATTR for the source interface.
    mdTypeRef           trEventItf;                 // A type ref to the event interface.
    ITypeLib*           pTypeTLB;                   // The typelib containing this interface.
    mdAssemblyRef       ar;                         // Dummy AssmRef.
    BSTR                wzNamespace=0;              // Namespace of the event interface assembly.
    BSTR                wzAsmName=0;                // Assembly name of the event interface assembly.
    Assembly*           SrcItfAssembly=0;           // The Source Event Interface assembly.
    CQuickArray<WCHAR>  qbSrcItfName;               // The name of the source interface.
    CImpTlbDefItfToClassItfMap *pDefItfToClassItfMap;   // The default interface to class interface map.
    BOOL                fInheritsIEnum = FALSE;

    // Retrieve the namespace of the typelib containing this source interface.
    IfFailGo(pSrcItfITI->GetContainingTypeLib(&pTypeTLB, NULL));

    // Resolve the external reference.
    IfFailGo(_AddTlbRef(pTypeTLB, &ar, &wzNamespace, &wzAsmName, &pDefItfToClassItfMap));

    // Get the assembly + namespace the source interface resides in.  
    //  May return all NULL - indicating the importing assembly.
    m_LibRefs.Find(pTypeTLB, &ar, &wzNamespace, &wzAsmName, &SrcItfAssembly, NULL);
    if (SrcItfAssembly == NULL)
        SrcItfAssembly = m_pAssembly;

    // Retrieve the full name of the source interface.
    if (wzNamespace)
        IfFailGo(GetManagedNameForTypeInfo(pSrcItfITI, (WCHAR*)wzNamespace, NULL, &bstrSrcItfName));
    else
        IfFailGo(GetManagedNameForTypeInfo(pSrcItfITI, m_wzNamespace, NULL, &bstrSrcItfName));    	

    // Start by looking up the event information for the source itf type info.
    pEventInfo = m_EventInfoMap.FindEventInfo(bstrSrcItfName);
    if (pEventInfo)
    {
        SysFreeString(bstrSrcItfName);
        *ptr = pEventInfo->trEventItf;
        return S_OK;
    }

    // Store the old values of the ITypeInfo name and of the current type def.
    szOldName = m_szName;
    tdOldTypeDef = m_tdTypeDef;
    m_szName = NULL;

    // Get some information about the TypeInfo.
    IfFailGo(pSrcItfITI->GetDocumentation(MEMBERID_NIL, &m_szName, 0, 0, 0));
    IfFailGo(pSrcItfITI->GetTypeAttr(&psAttr));

    if (ExplicitlyImplementsIEnumerable(pSrcItfITI, psAttr) == S_OK)
        fInheritsIEnum = TRUE;

    // Generate a unique name for the event interface which will be of the form:
	//     <ImportingAssemblyNamespace>.<SrcItfName>_Event<PotentialSuffix>

        // Strip the namespace
        IfFailGo(qbSrcItfName.ReSize(wcslen(bstrSrcItfName) + 2));
        ns::SplitPath((WCHAR*)bstrSrcItfName, NULL, 0, qbSrcItfName.Ptr(), wcslen(bstrSrcItfName) + 1);

        // Add the namespace of the importing typelib and the event suffix
        IfFailGo(qbEventItfName.ReSize(qbSrcItfName.Size() + wcslen(m_wzNamespace) + EVENT_ITF_SUFFIX_LENGTH + 7));
        swprintf(qbEventItfName.Ptr(), L"%s.%s%s", m_wzNamespace, qbSrcItfName.Ptr(), EVENT_ITF_SUFFIX);
	    IfFailGo(GenerateUniqueTypeName(qbEventItfName));

    // Generate a unique name for the event provider which will be of the form:
    //     <ImportingAssemblyNamespace>.<SrcItfName>_EventProvider<PotentialSuffix>

        // Add the namespace of the importing typelib and the event suffix
        IfFailGo(qbEventProviderName.ReSize(qbSrcItfName.Size() + wcslen(m_wzNamespace) + EVENT_PROVIDER_SUFFIX_LENGTH + 7));
        swprintf(qbEventProviderName.Ptr(), L"%s.%s%s", m_wzNamespace, qbSrcItfName.Ptr(), EVENT_PROVIDER_SUFFIX);
	    IfFailGo(GenerateUniqueTypeName(qbEventProviderName));

    // Add the event provider as a reserved name.
    m_ReservedNames.AddReservedName(qbEventProviderName.Ptr());

    // Create the typedef for the event interface.
    IfFailGo(m_pEmit->DefineTypeDef(qbEventItfName.Ptr(), tdPublic | tdInterface | tdAbstract, mdTypeDefNil, NULL, &m_tdTypeDef));

    // Hide the event interface from the VB object browser (_Event)
    _SetHiddenCA(m_tdTypeDef);

    // Make the interface ComVisible(false).
    {
        DECLARE_CUSTOM_ATTRIBUTE(sizeof(BYTE));
        BUILD_CUSTOM_ATTRIBUTE(BYTE, FALSE);
        IfFailGo(GetAttrType(ATTR_COMVISIBLE, &tkAttr));
        FINISH_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(m_tdTypeDef, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));
    }

    // Set the ComEventInterface CA on the interface.
    {
        CQuickBytes asmQualifiedSrcItfName;
        if (!ns::MakeAssemblyQualifiedName(asmQualifiedSrcItfName, bstrSrcItfName, wzAsmName))
            IfFailGo(E_OUTOFMEMORY);
        DECLARE_DYNLEN_CUSTOM_ATTRIBUTE(wcslen((WCHAR*)asmQualifiedSrcItfName.Ptr()) + 5 + wcslen(qbEventProviderName.Ptr()) + 5);
        APPEND_WIDE_STRING_TO_CUSTOM_ATTRIBUTE((WCHAR*)asmQualifiedSrcItfName.Ptr());
        APPEND_WIDE_STRING_TO_CUSTOM_ATTRIBUTE(qbEventProviderName.Ptr());
        IfFailGo(GetAttrType(ATTR_COMEVENTINTERFACE, &tkAttr));
        FINISH_DYNLEN_CUSTOM_ATTRIBUTE();
        IfFailGo(m_pEmit->DefineCustomAttribute(m_tdTypeDef, tkAttr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));
    }

    // Add the add_XXX and remove_XXX methods to the event interface.
    IfFailGo(_ConvSrcIfaceMembers(pSrcItfITI, psAttr, fInheritsIEnum));

    // Define a typeref for the event interface.
    IfFailGo(m_pEmit->DefineTypeRefByName(TokenFromRid(1, mdtModule), qbEventItfName.Ptr(), &trEventItf));
    
    // Add the event info to the map.
    IfFailGo(m_EventInfoMap.AddEventInfo(bstrSrcItfName, trEventItf, qbEventItfName.Ptr(), qbEventProviderName.Ptr(), SrcItfAssembly));

    // Set the out type ref.
    *ptr = trEventItf;

ErrExit:
    if (bstrSrcItfName)
        ::SysFreeString(bstrSrcItfName);
    if (m_szName)
        ::SysFreeString(m_szName);
    if (psAttr)
        pSrcItfITI->ReleaseTypeAttr(psAttr);
    if (pTypeTLB)
        pTypeTLB->Release();

    // Restore the initial values for the ITypeInfo name and the type def.
    m_szName = szOldName;
    m_tdTypeDef = tdOldTypeDef;

    return (hr);
} // HRESULT CImportTlb::_GetTokenForEventItf()

//*****************************************************************************
// Creates an interface with the same name as the class and which implements
// the default interface and the default event interface.
//*****************************************************************************
HRESULT CImportTlb::_CreateClassInterface(ITypeInfo *pCoClassITI, ITypeInfo *pDefItfITI, mdTypeRef trDefItf, mdTypeRef rtDefEvItf, mdToken *ptr)
{
    HRESULT     hr = S_OK;              // A result.
    CQuickArray<mdToken> rImpls;        // Array of implemented interfaces.
    int         ixImpl = -1;            // Index into rImpls for implemented interface.
    mdTypeDef   tdTypeDef;              // The class interface typedef.
    BSTR        bstrFullName = NULL;    // The name of the CoClass.
    TYPEATTR    *psAttrIface=0;         // TYPEATTR for an interface.
    CQuickArray<WCHAR> qbClassName;     // The name of the class.

    rImpls.ReSize(3);
    memset(rImpls.Ptr(), 0, 3 * sizeof(mdToken));
    if (trDefItf)
        rImpls[++ixImpl] = trDefItf;
    if (rtDefEvItf)
        rImpls[++ixImpl] = rtDefEvItf;

    // Retrieve the TypeAttr for the interface.
    if (pDefItfITI)
        IfFailGo(pDefItfITI->GetTypeAttr(&psAttrIface));

    // Retrieve the name of the CoClass.
    IfFailGo(GetManagedNameForTypeInfo(pCoClassITI, m_wzNamespace, NULL, &bstrFullName));

    // Create the typedef.
    IfFailGo(m_pEmit->DefineTypeDef(bstrFullName, rdwTypeFlags[TKIND_INTERFACE], mdTypeDefNil, 0, &tdTypeDef));

    // Set the IID to the IID of the default interface.
    IfFailGo(_AddGuidCa(tdTypeDef, psAttrIface ? psAttrIface->guid : GUID_NULL));

    // Add the CoClass CA to the interface.
    _AddStringCa(ATTR_COCLASS, tdTypeDef, m_szMngName);

    // Add the implemented interfaces and event interfaces to the TypeDef.
    IfFailGo(m_pEmit->SetTypeDefProps(tdTypeDef, ULONG_MAX/*Classflags*/, 
        ULONG_MAX, (mdToken*)rImpls.Ptr()));

    // Set the out type def.
    *ptr = tdTypeDef;

ErrExit:
    if (bstrFullName)
        ::SysFreeString(bstrFullName);
    if (psAttrIface)
        pDefItfITI->ReleaseTypeAttr(psAttrIface);

    return (hr);
} // HRESULT CImportTlb::_CreateClassInterface()

//*****************************************************************************
// Creates an interface with the same name as the class and which implements
// the default interface and the default event interface.
//*****************************************************************************
HRESULT CImportTlb::GetManagedNameForCoClass(ITypeInfo *pITI, CQuickArray<WCHAR> &qbClassName)
{ 
    HRESULT     hr = S_OK;              // A result.
    BSTR        bstrFullName=0;         // Fully qualified name of type.

    // Retrieve the name of the CoClass.
    IfFailGo(GetManagedNameForTypeInfo(pITI, m_wzNamespace, NULL, &bstrFullName));

    // Resize the class name to accomodate the Class and potential suffix.
    qbClassName.ReSize(wcslen(bstrFullName) + CLASS_SUFFIX_LENGTH + 6);

    // Set the class name to the CoClass name suffixed with Class.
    swprintf(qbClassName.Ptr(), L"%s%s", bstrFullName, CLASS_SUFFIX);

    // Generate a unique name for the class.
    IfFailGo(GenerateUniqueTypeName(qbClassName));

ErrExit:
    if (bstrFullName)
        ::SysFreeString(bstrFullName);

    return (hr);
} // HRESULT CImportTlb::GetManagedNameForCoClass()

//*****************************************************************************
// Creates an interface with the same name as the class and which implements
// the default interface and the default event interface.
//*****************************************************************************
HRESULT CImportTlb::GenerateUniqueTypeName(CQuickArray<WCHAR> &qbTypeName)
{ 
    HRESULT     hr = S_OK;              // A result.
    WCHAR       *pSuffix=0;             // Location for suffix.
    WCHAR       *pName=0;               // The name without the namespace.
    int         iSuffix=2;              // Starting value for suffix.
    mdToken     td;                     // For looking up a TypeDef.
    BSTR        szTypeInfoName=0;       // Name of a typeinfo.
    ITypeInfo   *pITI=0;                // A typeinfo.

    // Resize the class name to accomodate the Class and potential suffix.
    qbTypeName.ReSize(wcslen(qbTypeName.Ptr()) + 6);

    // Set the suffix pointer.
    pSuffix = qbTypeName.Ptr() + wcslen(qbTypeName.Ptr());

    // Set the name pointer.
    pName = ns::FindSep(qbTypeName.Ptr()) + 1;

    // Attempt to find a class name that is not in use.
    for (;;)
    {
        // First check to see if the type name is in use in the metadata we 
        // have emitted so far.
        hr = m_pImport->FindTypeDefByName(qbTypeName.Ptr(), mdTypeDefNil, &td);
        if (hr == CLDB_E_RECORD_NOTFOUND)
        {
            // It is not in use in the metadata but we still need to check the
            // typelib because the type might not have been emitted yet.
            USHORT cReq = 4;
            USHORT cFound = cReq;
            BOOL bTypeInTlb = FALSE;
            CQuickArray<ITypeInfo *> qbTI;
            CQuickArray<MEMBERID> qbMemId;
            
            // Retrieve all the instances of the name in the typelib.
            do
            {
                // Double the number of requested names.
                cReq *= 2;

                // Resize the array's to accomodate the resquested names.
                qbTI.ReSize(cReq);
                qbMemId.ReSize(cReq);

                // Request the names.
                cFound = cReq;
                IfFailGo(m_pITLB->FindName(pName, 0, qbTI.Ptr(), qbMemId.Ptr(), &cFound));

                // Release all the ITypeInfo's. 
                for (int i = 0; i < cFound; i++)
                    qbTI[i]->Release();
            }
            while (cReq == cFound);

            // Check to see if one of the instances of the name is for a type.
            for (int i = 0; i < cFound; i++)
            {
                if (qbMemId[i] == MEMBERID_NIL)
                {
                    bTypeInTlb = TRUE;
                    break;
                }
            }

            // If the type name exists in the typelib, but we didn't find it as a type,
            //  we still need to do a deeper check, due to how FindName() works.
            if (!bTypeInTlb && cFound > 0)
            {
                int                     cTi;             // Count of TypeInfos.
                int                     i;               // Loop control.

                //@todo: this iterates over every typeinfo every time!  We could cache
                // the names, and skip the types already converted.  However, this should
                // be pretty rare.

                // How many TypeInfos?
                IfFailGo(cTi = m_pITLB->GetTypeInfoCount());

                // Iterate over them.
                for (i=0; i<cTi; ++i)
                {
                    // Get the TypeInfo, and its name.
                    IfFailGo(m_pITLB->GetTypeInfo(i, &pITI));
                    IfFailGo(pITI->GetDocumentation(MEMBERID_NIL, &szTypeInfoName, 0, 0, 0));
                    if (wcscmp(pName, szTypeInfoName) == 0)
                    {
                        bTypeInTlb = TRUE;
                        break;
                    }

                    // Release for next TypeInfo.
                    ::SysFreeString(szTypeInfoName);
                    szTypeInfoName = 0;
                    pITI->Release();
                    pITI = 0;
                }
            }

            // The type name is not in the typelib and not in the metadata then we still
            // need to check to see if is a reserved name.
            if (!bTypeInTlb)
            {
                if (!m_ReservedNames.IsReservedName(qbTypeName.Ptr()))
                {
                    // The name is not a reserved name so we can use it.
                    break;
                }
            }
        }
        IfFailGo(hr);

        // Append the new suffix to the class name.
        swprintf(pSuffix, L"_%i", iSuffix++);
    }

ErrExit:
    if (szTypeInfoName)
        ::SysFreeString(szTypeInfoName);
    if (pITI)
        pITI->Release();
    return (hr);
} // HRESULT CImportTlb::GenerateUniqueTypeName()

//*****************************************************************************
// Generate a unique member name based on the interface member name.
//*****************************************************************************
HRESULT CImportTlb::GenerateUniqueMemberName(// S_OK or error
    CQuickArray<WCHAR> &qbMemberName,       // Original name of member.
    PCCOR_SIGNATURE pSig,                   // Signature of the member.
    ULONG       cSig,                       // Length of the signature.
    LPCWSTR     szPrefix,                   // Possible prefix for decoration.
    mdToken     type)                       // Is it a property? (Not a method?)
{
    HRESULT     hr;                         // A result.
    mdToken     tkMember;                   // Dummy location for token.
    WCHAR       *pSuffix=0;                 // Location for suffix.
    int         iSuffix=2;                  // Starting value for suffix.

    // Try to find a member name that is not already in use.
    for (;;)
    {   // See if this is (finally) a unique member or property.
        switch (type)
        {
        case mdtProperty:
            hr = FindProperty(m_tdTypeDef, qbMemberName.Ptr(), 0, 0, &tkMember);
            // If name is OK as property, check that there is no method or 
            // property with the name.
            if (hr == CLDB_E_RECORD_NOTFOUND)
                hr = FindMethod(m_tdTypeDef, qbMemberName.Ptr(), 0,0, &tkMember);
            if (hr == CLDB_E_RECORD_NOTFOUND)
                hr = FindEvent(m_tdTypeDef, qbMemberName.Ptr(),  &tkMember);
            break;
        case mdtMethodDef:
            hr = FindMethod(m_tdTypeDef, qbMemberName.Ptr(), pSig, cSig, &tkMember);
            // If name is OK as method, check that there is no property or 
            // event with the name.
            if (hr == CLDB_E_RECORD_NOTFOUND)
                hr = FindProperty(m_tdTypeDef, qbMemberName.Ptr(), 0,0, &tkMember);
            if (hr == CLDB_E_RECORD_NOTFOUND)
                hr = FindEvent(m_tdTypeDef, qbMemberName.Ptr(),  &tkMember);
            break;
        case mdtEvent:
            hr = FindEvent(m_tdTypeDef, qbMemberName.Ptr(),  &tkMember);
            // If name is OK as event, check that there is no property or 
            // method with the name.
            if (hr == CLDB_E_RECORD_NOTFOUND)
                hr = FindProperty(m_tdTypeDef, qbMemberName.Ptr(), 0,0, &tkMember);
            if (hr == CLDB_E_RECORD_NOTFOUND)
                hr = FindMethod(m_tdTypeDef, qbMemberName.Ptr(), 0,0, &tkMember);
            break;
        default:
            // Unexpected type.  Make noise, but let it pass.
            _ASSERTE(!"Unexpected token type in GenerateUniqueMemberName");
            hr = CLDB_E_RECORD_NOTFOUND;
        }

        // If name was not found, it is unique.
        if (hr == CLDB_E_RECORD_NOTFOUND)
        {
            hr = S_OK;
            goto ErrExit;
        }
        // Test for failure.
        IfFailGo(hr);
        
        // Make a test decoration.
        if (szPrefix)
        {
            int iLenPrefix, iLenName;
            iLenPrefix = wcslen(szPrefix);  
            iLenName = wcslen(qbMemberName.Ptr());
            IfFailGo(qbMemberName.ReSize(iLenName + iLenPrefix + 2));
            // Shift by prefix length, plus '_'.  Note use of overlap-safe move.
            memmove(&qbMemberName[iLenPrefix+1], &qbMemberName[0], (iLenName+1)*sizeof(WCHAR));
            wcscpy(qbMemberName.Ptr(), szPrefix);
            qbMemberName[iLenPrefix] = L'_';
            szPrefix = 0;
            // Try again with prefix before trying a suffix.
            continue;
        }
        if (!pSuffix)
        {
            IfFailGo(qbMemberName.ReSize(wcslen(qbMemberName.Ptr()) + 6));
            pSuffix = qbMemberName.Ptr() + wcslen(qbMemberName.Ptr());
        }
        swprintf(pSuffix, L"_%i", iSuffix++);
    } 

ErrExit:
    return hr;
} // HRESULT CImportTlb::GenerateUniqueMemberName()

//*****************************************************************************
// Convert a TYPEDESC to a COM+ signature.
//
// Conversion rules:
//  integral types are converted as-is.
//  strings to strings, with native type decoration.
//  VT_UNKNOWN, VT_DISPATCH as ref class (ie, Object)
//  VT_PTR -> VT_USERDEFINED interface as Object
//  VT_USERDEFINED record as value type.
//
// With SIG_FUNC:
//  PTR to valuetype depends on other flags:
//   [IN] or [RETVAL] valuetype + NATIVE_TYPE_LPSTRUCT
//   [OUT] or [IN, OUT] byref valuetype 
//  PTR to integral type:
//   [IN] @todo: see atti
//   [OUT] [IN, OUT] byref type
//   [RETVAL] type
//  PTR to object
//   [IN] @todo: see atti
//   [OUT] [IN, OUT] byref object
//   [RETVAL] object
// 
// With SIG_FIELD:
//  PTR to integral type adds ELEMENT_TYPE_PTR.
//
// Conversion proceeds in three steps.
//  1) Parse the COM type info.  Accumulate VT_PTR and VT_BYREF into a count
//     of indirections.  Follow TKIND_ALIAS to determine the ultimate aliased
//     type, and for non-user-defined types, convert that ultimate type.
//     Collect array sizes and udt names.  Determine element type and native
//     type.
//  2) Normalize to COM+ types.  Determine if there is conversion loss.
//  3) Emit the COM+ signature.  Recurse to handle array types.  Add native
//     type info if there is any.
//*****************************************************************************
HRESULT CImportTlb::_ConvSignature(     // S_OK, S_CONVERSION_LOSS, or error.
    ITypeInfo   *pITI,                  // [IN] The typeinfo containing the TYPEDESC.
    const TYPEDESC *pType,              // [IN] The TYPEDESC to convert.
    ULONG       Flags,                  // [IN] Flags describing the TYPEDESC.
    CQuickBytes &qbSigBuf,              // [IN, OUT] A CQuickBytes containing the signature.
    ULONG       cbSig,                  // [IN] Where to start building the signature.
    ULONG       *pcbSig,                // [OUT] Where the signature ends (ix of first byte past; where to start next).
    CQuickArray<BYTE> &qbNativeTypeBuf, // [IN, OUT] A CQuickBytes containing the native type.
    ULONG       cbNativeType,           // [IN] Where to start building the native type.
    ULONG       *pcbNativeType,         // [OUT] Where the native type ends (ix of first byte past; where to start next).
    BOOL        bNewEnumMember,         // [IN] A flag indicating if the member is the NewEnum member.
    int         iByRef)                 // [IN] ByRef count of caller (for recursive calls).
{
    HRESULT     hr=S_OK;                // A result.
    TYPEDESC    tdTemp;                 // Copy of TYPEDESC, for R/W.
    VARTYPE     vt;                     // The typelib signature element.
    int         bByRef=false;           // If true, convert first pointer as "ELEMENT_TYPE_BYREF".
    COR_SIGNATURE et=0;                 // The COM+ signature element.
    mdToken     tk=0;                   // Token from some COM+ signature element.
    ULONG       nt=NATIVE_TYPE_NONE;    // Native type decoration.
    ITypeInfo   *pITIAlias=0;           // Typeinfo of the aliased type.
    TYPEATTR    *psAttrAlias=0;         // TYPEATTR of the aliased typeinfo.
    ITypeInfo   *pITIUD=0;              // TypeInfo of an aliased UserDefined type.
    ITypeLib    *pITLBUD=0;             // TypeLib of an aliased UserDefined type.
    BSTR        bstrNamespace=0;        // Namespace name.
    BSTR        bstrName=0;             // UserDefined name.
    int         bConversionLoss=false;  // If true, the conversion was lossy.
    BYTE        *pbSig;                 // Byte pointer for easy pointer math.
    ULONG       cb;                     // Size of a signature element.
    ULONG       cElems=0;               // Count of elements in an array.
    int         i;                      // Loop control.
    TYPEATTR    *psAttr = 0;            // The TYPEATTR for the user defined type being converted.
    StdConvertibleItfInfo *pConvertionInfo = 0; // The standard convertible interface information.
    CQuickArray<BYTE> qbNestedNativeType;// A native type buffer used for array sig convertion.
    ULONG       iNestedNativeTypeOfs=0;  // A native type offset.
    ULONG       nested=NATIVE_TYPE_NONE; // A nested native type.

    // VT_ to ELEMENT_TYPE_ translation table.
    struct VtSig 
    {
        CorElementType  et;
        CorNativeType   nt;
        short           flags;
    };

    // The VARIANT_TYPE to sig mapping table. 
    static const VtSig
    _VtInfo[MAX_TLB_VT] =
    {   
        // Relies on {0} initializing the entire sub-structure to 0.
        {ELEMENT_TYPE_MAX,      NATIVE_TYPE_NONE, 0},       //    VT_EMPTY        = 0
        {ELEMENT_TYPE_MAX,      NATIVE_TYPE_NONE, 0},       //    VT_NULL         = 1
        {ELEMENT_TYPE_I2,       NATIVE_TYPE_NONE, 0},       //    VT_I2           = 2
        {ELEMENT_TYPE_I4,       NATIVE_TYPE_NONE, 0},       //    VT_I4           = 3
        {ELEMENT_TYPE_R4,       NATIVE_TYPE_NONE, 0},       //    VT_R4           = 4
        {ELEMENT_TYPE_R8,       NATIVE_TYPE_NONE, 0},       //    VT_R8           = 5
        {ELEMENT_TYPE_VALUETYPE,NATIVE_TYPE_CURRENCY, 0},   //    VT_CY           = 6
        {ELEMENT_TYPE_VALUETYPE,NATIVE_TYPE_NONE, 0},       //    VT_DATE         = 7
        {ELEMENT_TYPE_STRING,   NATIVE_TYPE_BSTR, 0},       //    VT_BSTR         = 8
        {ELEMENT_TYPE_OBJECT,   NATIVE_TYPE_IDISPATCH, 0},  //    VT_DISPATCH     = 9
        {ELEMENT_TYPE_I4,       NATIVE_TYPE_ERROR, 0},      //    VT_ERROR        = 10 scode
        {ELEMENT_TYPE_BOOLEAN,  NATIVE_TYPE_NONE, 0},       //    VT_BOOL         = 11
        {ELEMENT_TYPE_OBJECT,   NATIVE_TYPE_STRUCT, 0},     //    VT_VARIANT      = 12
        {ELEMENT_TYPE_OBJECT,   NATIVE_TYPE_IUNKNOWN, 0},   //    VT_UNKNOWN      = 13
        {ELEMENT_TYPE_VALUETYPE,NATIVE_TYPE_NONE, 0},       //    VT_DECIMAL      = 14
        {ELEMENT_TYPE_MAX,      NATIVE_TYPE_NONE, 0},       //                    = 15
        {ELEMENT_TYPE_I1,       NATIVE_TYPE_NONE, 0},       //    VT_I1           = 16
        {ELEMENT_TYPE_U1,       NATIVE_TYPE_NONE, 0},       //    VT_UI1          = 17
        {ELEMENT_TYPE_U2,       NATIVE_TYPE_NONE, 0},       //    VT_UI2          = 18
        {ELEMENT_TYPE_U4,       NATIVE_TYPE_NONE, 0},       //    VT_UI4          = 19
        {ELEMENT_TYPE_I8,       NATIVE_TYPE_NONE, 0},       //    VT_I8           = 20
        {ELEMENT_TYPE_U8,       NATIVE_TYPE_NONE, 0},       //    VT_UI8          = 21
        
    // it would be nice to convert these as I and U, with NT_I4 and NT_U4, but that doesn't work.
        {ELEMENT_TYPE_I4,       NATIVE_TYPE_NONE, 0},       //    VT_INT          = 22     INT is I4 on win32
        {ELEMENT_TYPE_U4,       NATIVE_TYPE_NONE, 0},       //    VT_UINT         = 23     UINT is UI4 on win32

        {ELEMENT_TYPE_VOID,     NATIVE_TYPE_NONE, 0},       //    VT_VOID         = 24
    
        {ELEMENT_TYPE_I4,       NATIVE_TYPE_ERROR, 0},      //    VT_HRESULT      = 25
        {ELEMENT_TYPE_MAX,      NATIVE_TYPE_NONE, 0},       //    VT_PTR          = 26
        {ELEMENT_TYPE_MAX,      NATIVE_TYPE_NONE, 0},       //    VT_SAFEARRAY    = 27
        {ELEMENT_TYPE_SZARRAY,  NATIVE_TYPE_FIXEDARRAY, 0}, //    VT_CARRAY       = 28
        {ELEMENT_TYPE_MAX,      NATIVE_TYPE_NONE, 0},       //    VT_USERDEFINED  = 29
        {ELEMENT_TYPE_STRING,   NATIVE_TYPE_LPSTR, 0},      //    VT_LPSTR        = 30
        {ELEMENT_TYPE_STRING,   NATIVE_TYPE_LPWSTR, 0},     //    VT_LPWSTR       = 31
    };

    _ASSERTE(pType && pcbSig &&  pcbNativeType);

    //-------------------------------------------------------------------------
    // Parse COM signature

    // Strip off leading VT_PTR and VT_BYREF
    while (pType->vt == VT_PTR)
        pType = pType->lptdesc, ++iByRef;
    if (pType->vt & VT_BYREF)
    {
        tdTemp = *pType;
        tdTemp.vt &= ~VT_BYREF;
        ++iByRef;
        pType = &tdTemp;
    }

    // Determine the element type, and possibly the token and/or native type.
    switch (vt=pType->vt)
    { 
    case VT_PTR:
        _ASSERTE(!"Should not have VT_PTR here");
        break;

    // These are all known types (plus GUID).
    case VT_CY:
    case VT_DATE:
    case VT_DECIMAL:
        IfFailGo(GetKnownTypeToken(vt, &tk));
        et = _VtInfo[vt].et;
        nt = _VtInfo[vt].nt;
        break;

    case VT_SAFEARRAY:
        if (m_bSafeArrayAsSystemArray && !IsSigVarArg(Flags))
        {
            IfFailGo(GetKnownTypeToken(vt, &tk));
            et = ELEMENT_TYPE_CLASS;
            nt = NATIVE_TYPE_SAFEARRAY;
        }
        else
        {
            IfFailGo(GetKnownTypeToken(vt, &tk));
            et = ELEMENT_TYPE_SZARRAY;
            nt = NATIVE_TYPE_SAFEARRAY;
        }
        break;

    case VT_USERDEFINED:
        // Resolve the alias to the ultimate aliased type.
        IfFailGo(_ResolveTypeDescAlias(pITI, pType, &pITIAlias, &psAttrAlias));

        // If the aliased type was built-in, convert that built-in type.
        if (psAttrAlias->typekind == TKIND_ALIAS)
        {   // Recurse to follow the alias chain.
            _ASSERTE(psAttrAlias->tdescAlias.vt != VT_USERDEFINED);
            hr = _ConvSignature(pITIAlias, &psAttrAlias->tdescAlias, Flags, qbSigBuf, cbSig, pcbSig, qbNativeTypeBuf, cbNativeType, pcbNativeType, bNewEnumMember, iByRef);
            goto ErrExit;
        }

        // If the type is a coclass then we need to retrieve the default interface and
        //  substitute it for the coclass.  Look up on the resolved alias, because it is
        //  that class that has a default interface.
        if (psAttrAlias->typekind == TKIND_COCLASS)
        {
            ITypeInfo *pDefaultItf = NULL;
            hr = GetDefaultInterface(pITIAlias, &pDefaultItf);
            if ((hr != S_OK) || !pDefaultItf)
            {
                hr = E_UNEXPECTED;
                goto ErrExit;
            }

            pITIUD = pDefaultItf;
        }
        else
        {   // USERDEFINED class/interface/record/union/enum.  Retrieve the type 
            //  info for the user defined type.  Note: use the TKIND_ALIAS typeinfo 
            //  itself for this conversion (not the aliased type) to preserve 
            //  names, lib locations, etc.
            IfFailGo(pITI->GetRefTypeInfo(pType->hreftype, &pITIUD));
        }

        // pITIUD points to the typeinfo for which we'll create a signature.
        IfFailGo(pITIUD->GetDocumentation(MEMBERID_NIL, &bstrName, 0,0,0));
        IfFailGo(pITIUD->GetContainingTypeLib(&pITLBUD, 0));
        IfFailGo(pITIUD->GetTypeAttr(&psAttr));
        IfFailGo(GetNamespaceNameForTypeLib(pITLBUD, &bstrNamespace));

        // If the "User Defined Type" is GUID in StdOle2, convert to M.R.GUID
        if (_wcsicmp(bstrNamespace, COM_STDOLE2) == 0 && wcscmp(bstrName, COM_GUID) == 0)
        {   // Classlib valuetype GUID.
            et = ELEMENT_TYPE_VALUETYPE;
            IfFailGo(GetKnownTypeToken(VT_SLOT_FOR_GUID, &tk));
        }
        else
        {   // Some user defined class.  Is it a value class, or a VOS class?
            tk = 0;
            switch (psAttrAlias->typekind)
            {
            case TKIND_RECORD:
            case TKIND_ENUM:
            case TKIND_UNION:
                et = ELEMENT_TYPE_VALUETYPE;
                break;
            case TKIND_INTERFACE:
            case TKIND_DISPATCH:
            case TKIND_COCLASS:
                // A pointer to a user defined type of interface/dispatch/coclass 
                //  is a straight COM+ object (the ref is implicit), so eliminate 
                //  one byref count for those.
                // Somehow, there are typelibs written with ([out, retval] IFoo *pOut);
                if (iByRef <= 0)
                {   
                    // convert to an int.
                    bConversionLoss = true;
                    tk = 0;
                    et = ELEMENT_TYPE_I;
                    nt = NATIVE_TYPE_NONE;
                    iByRef = 0;
                    break;
                }
                else
                {
                    --iByRef;

                    // Check for references to Stdole2.IUnknown or Stdole2.IDispatch.
                    if (psAttr->guid == IID_IUnknown)
                    {
                        vt = VT_UNKNOWN;
                        goto IsReallyUnknown;
                    }
                    else if (psAttr->guid == IID_IDispatch)
                    {
                        vt = VT_DISPATCH;
                        goto IsReallyUnknown;
                    }
                    
                    // Check to see if this user defined type is one of the standard ones
                    // we generate custom marshalers for.
                    pConvertionInfo = GetConvertionInfoFromNativeIID(psAttr->guid);
                    if (pConvertionInfo)
                    {
                        // Convert the UTF8 string to unicode.
                        int MngTypeNameStrLen = (int)(strlen(pConvertionInfo->m_strMngTypeName) + 1);
                        WCHAR *strFullyQualifiedMngTypeName = (WCHAR *)_alloca(MngTypeNameStrLen * sizeof(WCHAR));
                        int ret = WszMultiByteToWideChar(CP_UTF8, 0, pConvertionInfo->m_strMngTypeName, MngTypeNameStrLen, strFullyQualifiedMngTypeName, MngTypeNameStrLen);
                        _ASSERTE(ret != 0);
                        if (!ret)
                            IfFailGo(HRESULT_FROM_WIN32(GetLastError()));

                        // Create a TypeRef to the marshaller.
                        IfFailGo(m_TRMap.DefineTypeRef(m_pEmit, m_arSystem, strFullyQualifiedMngTypeName, &tk));

                        // The type is a standard interface that we need to convert.
                        et = ELEMENT_TYPE_CLASS;
                        nt = NATIVE_TYPE_CUSTOMMARSHALER;
                        break;
                    }
                }
                et = ELEMENT_TYPE_CLASS;
                nt = NATIVE_TYPE_INTF;
                break;
            default:
                //case TKIND_MODULE: -- can't pass one of these as a parameter.
                //case TKIND_ALIAS: -- should already be resolved.
                _ASSERTE(!"Unexpected typekind for user defined type");
                et = ELEMENT_TYPE_END;
            } // switch (psAttrAlias->typekind)
        }
        break;

    IsReallyUnknown:
    case VT_UNKNOWN:
    case VT_DISPATCH:
        // If the NewEnum member, retrieve the custom marshaler information for IEnumVARIANT.
        if (bNewEnumMember && (pConvertionInfo=GetConvertionInfoFromNativeIID(IID_IEnumVARIANT)))
        {
            // Convert the UTF8 string to unicode.
            int MngTypeNameStrLen = (int)(strlen(pConvertionInfo->m_strMngTypeName) + 1);
            WCHAR *strFullyQualifiedMngTypeName = (WCHAR *)_alloca(MngTypeNameStrLen * sizeof(WCHAR));
            int ret = WszMultiByteToWideChar(CP_UTF8, 0, pConvertionInfo->m_strMngTypeName, MngTypeNameStrLen, strFullyQualifiedMngTypeName, MngTypeNameStrLen);
            _ASSERTE(ret != 0);
            if (!ret)
                IfFailGo(HRESULT_FROM_WIN32(GetLastError()));

            // Create a TypeRef to the marshaller.
            IfFailGo(m_TRMap.DefineTypeRef(m_pEmit, m_arSystem, strFullyQualifiedMngTypeName, &tk));

            // The type is a standard interface that we need to convert.
            et = ELEMENT_TYPE_CLASS;
            nt = NATIVE_TYPE_CUSTOMMARSHALER;
        }
        else
        {
            et = _VtInfo[vt].et;
            nt = _VtInfo[vt].nt;
        }
        break;

    case VT_CARRAY:
        // Determine the count of elements.
        for (cElems=1, i=0; i<pType->lpadesc->cDims; ++i)
            cElems *= pType->lpadesc->rgbounds[i].cElements;

        // Set the native type based on weither we are dealing with a field or a method sig.
        if (IsSigField(Flags))
        {
            nt = NATIVE_TYPE_FIXEDARRAY;
        }
        else
        {
            nt = NATIVE_TYPE_ARRAY;
        }

        // Set the element type.
        et = _VtInfo[vt].et;
        break;

    case VT_BOOL:
        // Special case for VARIANT_BOOL: If a field of a struct or union, convert
        //  as ET_I2.
        if (IsSigField(Flags))
            vt = VT_I2;
        // Fall through to default case.

    default:
        if (vt > VT_LPWSTR)
        {
            ReportEvent(NOTIF_CONVERTWARNING, TLBX_E_BAD_VT_TYPE, vt, m_szName, m_szMember);
            IfFailGo(PostError(TLBX_E_BAD_VT_TYPE, vt, m_szName, m_szMember));
        }
        _ASSERTE(vt <= VT_LPWSTR && _VtInfo[vt].et != ELEMENT_TYPE_MAX);
        et = _VtInfo[vt].et;
        nt = _VtInfo[vt].nt;
        break;
    } // switch (vt=pType->vt)

    //-------------------------------------------------------------------------
    // Normalize to COM+ types.

    // At this point the type, flags, and pointer nesting are known.  Is this a legal combination?
    //  If not, what is the appropriate "simplifing assumption"?

    if (et == ELEMENT_TYPE_VOID)
    {
        if (IsSigField(Flags))
        {   // A void as a field.  No byref.
            iByRef = 0;
        }
        else
        {   
            // Param or return type.  "void *" -> ET_I, "void **", "void ***",... -> ET_BYREF ET_I
            if (iByRef > 1)
                iByRef = 1;
            else
            if (iByRef == 1)
                iByRef = 0;
        }
        bConversionLoss = true;
        tk = 0;
        et = ELEMENT_TYPE_I;
        nt = NATIVE_TYPE_NONE;
    }

    if (iByRef)
    {
        if (et == ELEMENT_TYPE_VALUETYPE && iByRef >= 2)
        {
            bConversionLoss = true;
            tk = 0;
            et = ELEMENT_TYPE_I;
            nt = NATIVE_TYPE_NONE;
            iByRef = 0;
        }
        else
        {
            switch (Flags & SIG_TYPE_MASK)
            {
            case SIG_FIELD:
                // If ptr to valuetype or class type, we can't handle it.
                if (et == ELEMENT_TYPE_END || 
                    et == ELEMENT_TYPE_CLASS || 
                    et == ELEMENT_TYPE_OBJECT || 
                    et == ELEMENT_TYPE_VALUETYPE)
                {
                    bConversionLoss = true;
                    tk = 0;
                    et = ELEMENT_TYPE_I;
                    nt = NATIVE_TYPE_NONE;
                    iByRef = 0;
                }
                break;
            case SIG_FUNC:
                // Pointer to value type?
                if (et == ELEMENT_TYPE_VALUETYPE)
                {   
                    // For [retval], eat one level of indirection; otherwise turn one into BYREF
                    if (IsSigOutRet(Flags))
                    {   // [out, retval], so reduce one level of indirection.
                        --iByRef;
                    }
                    else
                    {   // Favor BYREF over NATIVE_TYPE_LPSTRUCT
                        if (IsSigUseByref(Flags))
                        {
                            bByRef = true;
                            --iByRef;
                        }
                        if (iByRef > 0)
                        {
                            nt = NATIVE_TYPE_LPSTRUCT;
                            --iByRef;
                        }
                    }
                }
                else // Pointer to Object or base type.
                {   
                    if (IsSigRet(Flags))
                    {   // [retval] so consume one indirection.
                        _ASSERTE(iByRef > 0);
                        --iByRef;
                    }
                    if (iByRef > 0 && IsSigUseByref(Flags))
                    {
                        bByRef = true;
                        --iByRef;
                    }
                }
                break;
            case SIG_ELEM:
                // This case comes up when a property type is from a [retval].
                if (IsSigRet(Flags))
                {
                    if (iByRef > 0)
                        --iByRef;
                }
                break;
            }
        }
    } // if (iByRef)

    //-------------------------------------------------------------------------
    // We don't want any ET_PTR, so if there are any byref counts left, bail.
    if (iByRef)
    {
        bConversionLoss = true;
        tk = 0;
        et = ELEMENT_TYPE_I;
        nt = NATIVE_TYPE_NONE;
        iByRef = 0;
        bByRef = false;
    }
    
    //-------------------------------------------------------------------------
    // Build COM+ signature.

    // Type has been analyzed, and possibly modified.  Emit the COM+ signature.
    _ASSERTE(et != ELEMENT_TYPE_MAX);
    _ASSERTE(et != ELEMENT_TYPE_END);

    // If it is a pointer to something, emit that now.
    if (bByRef || iByRef)
    {
        // Size the array to hold the elements.
        IfFailGo(qbSigBuf.ReSize(cbSig + CB_MAX_ELEMENT_TYPE * (iByRef+(bByRef?1:0))));
        pbSig = reinterpret_cast<BYTE*>(qbSigBuf.Ptr());

        // Put in any leading "BYREF"
        if (bByRef)
        {
            pbSig = reinterpret_cast<BYTE*>(qbSigBuf.Ptr());
            cb = CorSigCompressData(ELEMENT_TYPE_BYREF, &pbSig[cbSig]);
            cbSig += cb;
        }

        // Put in the "PTR"s.
        while (iByRef-- > 0)
        {
            cb = CorSigCompressData(ELEMENT_TYPE_PTR, &pbSig[cbSig]);
            cbSig += cb;
        }
    }

    // Emit the type.
    IfFailGo(qbSigBuf.ReSize(cbSig + CB_MAX_ELEMENT_TYPE));
    pbSig = reinterpret_cast<BYTE*>(qbSigBuf.Ptr());
    cb = CorSigCompressData(et, &pbSig[cbSig]);
    cbSig += cb;

    // Add the class type, the array information, etc.
    switch (et)
    {
    case ELEMENT_TYPE_CLASS:
    case ELEMENT_TYPE_VALUETYPE:
        // Size the array to hold the token.
        IfFailGo(qbSigBuf.ReSize(cbSig + CB_MAX_ELEMENT_TYPE));
        pbSig = reinterpret_cast<BYTE*>(qbSigBuf.Ptr());

        // If the token hasn't been resolved yet, do that now.
        if (tk == 0)
        {
            _ASSERTE(pITIUD);
            IfFailGo(_GetTokenForTypeInfo(pITIUD, TRUE, &tk));
        }
        cb = CorSigCompressToken(tk, reinterpret_cast<ULONG*>(&pbSig[cbSig]));
        cbSig += cb;
        break;

    case ELEMENT_TYPE_SZARRAY:
        // map to SZARRAY <subtype>
        IfFailGo(qbSigBuf.ReSize(cbSig + CB_MAX_ELEMENT_TYPE));
        pbSig = reinterpret_cast<BYTE*>(qbSigBuf.Ptr());
        // Recurse on the type.
        IfFailGo(_ConvSignature(pITI, &pType->lpadesc->tdescElem, SIG_ELEM, qbSigBuf, cbSig, &cbSig, qbNestedNativeType, 0, &iNestedNativeTypeOfs, bNewEnumMember));
        if (hr == S_CONVERSION_LOSS)
            bConversionLoss = true;
        break;

    case VT_DISPATCH:       
    case VT_UNKNOWN:
    default:
        _ASSERTE(tk == 0);
        // et, nt assigned above.
        break;
    } // switch (et)

    // Do any native type info.
    if (nt != NATIVE_TYPE_NONE) 
    {
        if (iNestedNativeTypeOfs > 0)
            CorSigUncompressData(reinterpret_cast<PCCOR_SIGNATURE>(qbNestedNativeType.Ptr()), &nested);
        
        if (nt == NATIVE_TYPE_FIXEDARRAY)
        {
            IfFailGo(qbNativeTypeBuf.ReSize(cbNativeType + NATIVE_TYPE_MAX_CB * 2 + DWORD_MAX_CB));
            cbNativeType += CorSigCompressData(nt, &qbNativeTypeBuf[cbNativeType]);
            cbNativeType += CorSigCompressData(cElems, &qbNativeTypeBuf[cbNativeType]);            
            if (nested == NATIVE_TYPE_BSTR || nested == NATIVE_TYPE_LPWSTR || nested == NATIVE_TYPE_LPSTR)
            {   // Use the nested type.
                cbNativeType += CorSigCompressData(nested, &qbNativeTypeBuf[cbNativeType]);
            }
            else
            {   // Use a default sub type.
                cbNativeType += CorSigCompressData(NATIVE_TYPE_MAX, &qbNativeTypeBuf[cbNativeType]);
            }
        }
        else if (nt == NATIVE_TYPE_ARRAY)
        {
            IfFailGo(qbNativeTypeBuf.ReSize(cbNativeType + NATIVE_TYPE_MAX_CB * 2 + DWORD_MAX_CB * 2));
            cbNativeType += CorSigCompressData(nt, &qbNativeTypeBuf[cbNativeType]);
            if (nested == NATIVE_TYPE_BSTR || nested == NATIVE_TYPE_LPWSTR || nested == NATIVE_TYPE_LPSTR)
            {   // Use the nested type.
                cbNativeType += CorSigCompressData(nested, &qbNativeTypeBuf[cbNativeType]);
            }
            else
            {   // Use a default sub type.
                cbNativeType += CorSigCompressData(NATIVE_TYPE_MAX, &qbNativeTypeBuf[cbNativeType]);
            }
            // Use zero for param index.
            cbNativeType += CorSigCompressData(0, &qbNativeTypeBuf[cbNativeType]);
            // Use count from typelib for elem count.
            cbNativeType += CorSigCompressData(cElems, &qbNativeTypeBuf[cbNativeType]);
        }
        else if (nt == NATIVE_TYPE_SAFEARRAY)
        {
            BOOL bPtrArray = FALSE;
            CQuickArray<WCHAR> rTemp;
            CQuickArray<char> rTypeName;
            LPUTF8 strTypeName = "";
            TYPEDESC *pTypeDesc = &pType->lpadesc->tdescElem;
            VARTYPE ArrayElemVT = pTypeDesc->vt;

            if (ArrayElemVT == VT_PTR)
            {
                bPtrArray = TRUE;
                pTypeDesc = pType->lpadesc->tdescElem.lptdesc;
                ArrayElemVT = pTypeDesc->vt;
                if (ArrayElemVT != VT_USERDEFINED)
                {
                    // We do not support deep marshalling pointers.
                    ArrayElemVT = VT_INT;
                    bConversionLoss = TRUE;
                }
            }

            // If we are dealing with a safe array of user defined types and if we 
            // are importing safe array's as System.Array then add the SafeArrayUserDefSubType.
            if (ArrayElemVT == VT_USERDEFINED)
            {
                // Resolve the alias to the ultimate aliased type.
                IfFailGo(_ResolveTypeDescAlias(pITI, pTypeDesc, &pITIAlias, &psAttrAlias));

                // If the type is a coclass then we need to retrieve the default interface and
                //  substitute it for the coclass.  Look up on the resolved alias, because it is
                //  that class that has a default interface.
                if (psAttrAlias->typekind == TKIND_COCLASS)
                {
                    ITypeInfo *pDefaultItf = NULL;
                    hr = GetDefaultInterface(pITIAlias, &pDefaultItf);
                    if ((hr != S_OK) || !pDefaultItf)
                    {
                        hr = E_UNEXPECTED;
                        goto ErrExit;
                    }

                    pITIUD = pDefaultItf;
                }
                else
                {   // USERDEFINED interface/record/union/enum.  Retrieve the type 
                    //  info for the user defined type.  Note: use the TKIND_ALIAS typeinfo 
                    //  itself for this conversion (not the aliased type) to preserve 
                    //  names, lib locations, etc.
                    IfFailGo(pITI->GetRefTypeInfo(pTypeDesc->hreftype, &pITIUD));
                }

                // pITIUD points to the typeinfo for which we'll create a signature.
                IfFailGo(pITIUD->GetTypeAttr(&psAttr));

                // Get the typeref name for the type.
                for(;;)
                {
                    int cchReq;
                    mdToken tkDummy;
                    IfFailGo(_GetTokenForTypeInfo(pITIUD, TRUE, &tkDummy, rTemp.Ptr(), (int)rTemp.MaxSize(), &cchReq, TRUE));
                    if (cchReq <= (int)rTemp.MaxSize())
                        break;
                    IfFailGo(rTemp.ReSize(cchReq));
                }

                // Convert the type name to UTF8.
                ULONG cbReq = WszWideCharToMultiByte(CP_UTF8, 0, rTemp.Ptr(), -1, 0, 0, 0, 0);
                rTypeName.ReSize(cbReq + 1);
                WszWideCharToMultiByte(CP_UTF8, 0, rTemp.Ptr(), -1, rTypeName.Ptr(), cbReq, 0, 0);

                // Determine the safe array element VT.
                switch (psAttrAlias->typekind)
                {
                    case TKIND_RECORD:
                    case TKIND_ENUM:
                    case TKIND_UNION:
                        if (bPtrArray)
                        {
                            ArrayElemVT = VT_INT;
                            bConversionLoss = TRUE;
                        }
                        else
                        {
                            ArrayElemVT = psAttrAlias->typekind == TKIND_ENUM ? VT_I4 : VT_RECORD;
                            strTypeName = rTypeName.Ptr();
                        }
                        break;

                    case TKIND_INTERFACE:
                    case TKIND_DISPATCH:
                    case TKIND_COCLASS:
                        if (!bPtrArray)
                        {
                            ArrayElemVT = VT_INT;
                            bConversionLoss = TRUE;
                        }
                        else
                        {
                            if (IsIDispatchDerived(pITIUD, psAttr) == S_FALSE)
                                ArrayElemVT = VT_UNKNOWN;
                            else
                                ArrayElemVT = VT_DISPATCH;
                            strTypeName = rTypeName.Ptr();
                        }
                        break;
                }

                // If we are not converting the SAFEARRAY to a System.Array, then
                // we don't need to encode the name of the user defined type.
                if (!m_bSafeArrayAsSystemArray)
                    strTypeName = "";
            }

            // Make sure the native type buffer is large enough.
            ULONG TypeNameStringLen = (ULONG)strlen(strTypeName);
            IfFailGo(qbNativeTypeBuf.ReSize(cbNativeType + NATIVE_TYPE_MAX_CB * 2 + DWORD_MAX_CB + TypeNameStringLen + STRING_OVERHEAD_MAX_CB));

            // Add the native type to the native type info.
            cbNativeType += CorSigCompressData(nt, &qbNativeTypeBuf[cbNativeType]);

            // Add the VARTYPE of the array.
            cbNativeType += CorSigCompressData(ArrayElemVT, &qbNativeTypeBuf[cbNativeType]);

            // Add the type name to the native type info.
            BYTE *pNativeType = (BYTE*)CPackedLen::PutLength(&qbNativeTypeBuf[cbNativeType], TypeNameStringLen);
            cbNativeType += (ULONG)(pNativeType - &qbNativeTypeBuf[cbNativeType]);
            memcpy(&qbNativeTypeBuf[cbNativeType], strTypeName, TypeNameStringLen);
            cbNativeType += TypeNameStringLen;
        }
        else if (nt == NATIVE_TYPE_CUSTOMMARSHALER)
        {
            // Calculate the length of each string and then the total length of the native type info.
            ULONG MarshalerTypeNameStringLen = (ULONG)strlen(pConvertionInfo->m_strCustomMarshalerTypeName);
            ULONG CookieStringLen = (ULONG)strlen(pConvertionInfo->m_strCookie);
            ULONG TotalNativeTypeLen = MarshalerTypeNameStringLen + CookieStringLen;
            BYTE *pNativeType = 0;

            // Make sure the native type buffer is large enough.
            IfFailGo(qbNativeTypeBuf.ReSize(cbNativeType + NATIVE_TYPE_MAX_CB + TotalNativeTypeLen + STRING_OVERHEAD_MAX_CB * 4));

            // Add the native type to the native type info.
            cbNativeType += CorSigCompressData(nt, &qbNativeTypeBuf[cbNativeType]);

            // Add an empty string for the typelib guid.
            pNativeType = (BYTE*)CPackedLen::PutLength(&qbNativeTypeBuf[cbNativeType], 0);
            cbNativeType += (ULONG)(pNativeType - &qbNativeTypeBuf[cbNativeType]);

            // Add an empty string for the unmanaged type name.
            pNativeType = (BYTE*)CPackedLen::PutLength(&qbNativeTypeBuf[cbNativeType], 0);
            cbNativeType += (ULONG)(pNativeType - &qbNativeTypeBuf[cbNativeType]);

            // Add the name of the custom marshaler to the native type info.
            pNativeType = (BYTE*)CPackedLen::PutLength(&qbNativeTypeBuf[cbNativeType], MarshalerTypeNameStringLen);
            cbNativeType += (ULONG)(pNativeType - &qbNativeTypeBuf[cbNativeType]);
            memcpy(&qbNativeTypeBuf[cbNativeType], pConvertionInfo->m_strCustomMarshalerTypeName, MarshalerTypeNameStringLen);
            cbNativeType += MarshalerTypeNameStringLen;

            // Add the cookie to the native type info.
            pNativeType = (BYTE*)CPackedLen::PutLength(&qbNativeTypeBuf[cbNativeType], CookieStringLen);
            cbNativeType += (ULONG)(pNativeType - &qbNativeTypeBuf[cbNativeType]);
            memcpy(&qbNativeTypeBuf[cbNativeType], pConvertionInfo->m_strCookie, CookieStringLen);
            cbNativeType += CookieStringLen;
        }
        else
        {
            IfFailGo(qbNativeTypeBuf.ReSize(cbNativeType + NATIVE_TYPE_MAX_CB + 1));
            cbNativeType += CorSigCompressData(nt, &qbNativeTypeBuf[cbNativeType]);
        }
    }

    // Return the size of the native type to the caller.
    *pcbNativeType = cbNativeType;

    // Return size to caller.
    *pcbSig = cbSig;

    // If there was a conversion loss, change the return code.
    if (bConversionLoss)
        hr = S_CONVERSION_LOSS;

ErrExit:
    if (bstrNamespace)
        ::SysFreeString(bstrNamespace);
    if (bstrName)
        ::SysFreeString(bstrName);
    if(psAttrAlias)
        pITIAlias->ReleaseTypeAttr(psAttrAlias);
    if (pITIAlias)
        pITIAlias->Release();
    if (psAttr)
        pITIUD->ReleaseTypeAttr(psAttr);
    if (pITIUD)
        pITIUD->Release();
    if (pITLBUD)
        pITLBUD->Release();

    return hr;
} // HRESULT CImportTlb::_ConvSignature()

//*****************************************************************************
// Build a sorted list of functions to convert.  (Sort by vtable offset.)
//*****************************************************************************
HRESULT CImportTlb::BuildMemberList(
    ITypeInfo   *pITI,                  // TypeInfo with functions.
    int         iStart,                 // First function to take.
    int         iEnd,                   // Last function to take.
    BOOL        bInheritsIEnum)         // Inherits from IEnumerable.
{
    HRESULT     hr;                     // A result.
    int         bNeedSort = false;      // If true, need to sort the array.
    int         ix = 0;                 // Loop counter.
    int         oVftPrev = -1;          // To see if oVft is increasing.
    TYPEATTR    *psAttr = 0;            // TypeAttr for pITI.
    FUNCDESC    *psFunc;                // A FUNCDESC.
    LPWSTR      pszName;                // Working pointer for name.
    BSTR        bstrName=0;             // Name from typelib.
    ITypeInfo2  *pITI2=0;               // To get custom attributes.
    VARIANT     vt;                     // Variant type.
    BOOL        bFunctionToGetter;      // Did a given getter come from a managed function?

    IfFailGo(pITI->GetTypeAttr(&psAttr));
    pITI->QueryInterface(IID_ITypeInfo2, reinterpret_cast<void**>(&pITI2));
    ::VariantInit(&vt);

    // Get the vars.
    IfFailGo(m_MemberList.ReSize(psAttr->cVars + iEnd - iStart));
    memset(m_MemberList.Ptr(), 0, m_MemberList.Size()*sizeof(MemberInfo));
    for (ix=0; ix<psAttr->cVars; ++ix)
    {
        IfFailGo(pITI->GetVarDesc(ix, &(m_MemberList[ix].m_psVar)));
        m_MemberList[ix].m_iMember = ix;
    }
    m_cMemberProps = psAttr->cVars;
                    
    // Get the funcs.
    for (; iStart<iEnd; ++iStart, ++ix)
    {
        IfFailGo(TryGetFuncDesc(pITI, iStart, &(m_MemberList[ix].m_psFunc)));
        psFunc = m_MemberList[ix].m_psFunc;
        if (psFunc->oVft < oVftPrev)
            bNeedSort = true;
        oVftPrev = psFunc->oVft;
        m_MemberList[ix].m_iMember = iStart;
    }

    if (bNeedSort)
    {
        class Sorter : public CQuickSort<MemberInfo> 
        {
            typedef CImportTlb::MemberInfo MemberInfo;
        public:
            Sorter(MemberInfo *p, int n) : CQuickSort<MemberInfo>(p,n) {}
            virtual int Compare(MemberInfo *p1, MemberInfo *p2)
            { 
                if (p1->m_psFunc->oVft < p2->m_psFunc->oVft)
                    return -1;
                if (p1->m_psFunc->oVft == p2->m_psFunc->oVft)
                    return 0;
                return 1;
            }
        };
        Sorter sorter(m_MemberList.Ptr()+m_cMemberProps, (int)m_MemberList.Size()-m_cMemberProps);
        sorter.Sort();
        // Check for duplicates.
        oVftPrev = -1;
        for (int ix=m_cMemberProps; ix<(int)m_MemberList.Size(); ++ix)
        {
            if (m_MemberList[ix].m_psFunc->oVft == oVftPrev)
            {
                hr = TLBX_E_BAD_VTABLE;
                break;
            }
            oVftPrev = m_MemberList[ix].m_psFunc->oVft;
        }
    }

    // Build the list of unique names.
    m_pMemberNames = new CWCHARPool;
    IfNullGo(m_pMemberNames);
    
    // Property names.  No possibility of collisions.
    for (ix=0; ix<m_cMemberProps; ++ix)
    {
        IfFailGo(pITI->GetDocumentation(m_MemberList[ix].m_psVar->memid, &bstrName, 0,0,0));
        IfNullGo(pszName = m_pMemberNames->Alloc(wcslen(bstrName)+PROP_DECORATION_LEN+1));
        wcscpy(pszName, PROP_DECORATION_GET);
        wcscat(pszName, bstrName);
        m_MemberList[ix].m_pName = pszName;
        if ((m_MemberList[ix].m_psVar->wVarFlags & VARFLAG_FREADONLY) == 0)
        {
            IfNullGo(pszName = m_pMemberNames->Alloc(wcslen(bstrName)+PROP_DECORATION_LEN+1));
            wcscpy(pszName, PROP_DECORATION_SET);
            wcscat(pszName, bstrName);
            m_MemberList[ix].m_pName2 = pszName;
        }
        ::SysFreeString(bstrName);
        bstrName = 0;
    }
    
    // Function names.  Because of get_/set_ decoration, collisions are possible.
    for (ix=m_cMemberProps; ix<(int)m_MemberList.Size(); ++ix)
    {
        int bNewEnumMember = FALSE;

        // Build a name based on invkind.
        psFunc = m_MemberList[ix].m_psFunc;

        // Unless we are doing the [out, retval] transformation for disp only interfaces,
        // we need to clear the [retval] flag.
        if (!m_bTransformDispRetVals)
        {
            if (psFunc->funckind == FUNC_DISPATCH)
            {   // If [RETVAL] is set, clear it.
                for (int i=0; i<psFunc->cParams; ++i)
                    if ((psFunc->lprgelemdescParam[i].paramdesc.wParamFlags & PARAMFLAG_FRETVAL) != 0)
                        psFunc->lprgelemdescParam[i].paramdesc.wParamFlags &= ~PARAMFLAG_FRETVAL;
            }
        }

        BOOL bExplicitManagedName = FALSE;
        if ( (!bNewEnumMember) && (!bInheritsIEnum) && (FuncIsNewEnum(pITI, psFunc, m_MemberList[ix].m_iMember) == S_OK) )
        {   
            // The member is the new enum member so set its name to GetEnumerator.
            IfNullGo(bstrName = SysAllocString(GET_ENUMERATOR_MEMBER_NAME));
            bNewEnumMember = TRUE;

            // Setting this prevents more than one method in this interface from implementing NewEnum.
            bInheritsIEnum = TRUE;
        }
        else
        {
            // If the managed name custom value is set for this member, then use it.
            if (pITI2)
            {
                hr = pITI2->GetFuncCustData(m_MemberList[ix].m_iMember, GUID_ManagedName, &vt);
                if (hr == S_OK && vt.vt == VT_BSTR)
                {
                    IfNullGo(bstrName = SysAllocString(vt.bstrVal));
                    bExplicitManagedName = TRUE;
                }
                ::VariantClear(&vt);
            }

            if (!bstrName)
                IfFailGo(pITI->GetDocumentation(psFunc->memid, &bstrName, 0,0,0));
        }

        // If this is a property getter, see if it was originally a function.
        bFunctionToGetter = FALSE;
        if (psFunc->invkind == INVOKE_PROPERTYGET && pITI2)
        {
            hr = pITI2->GetFuncCustData(m_MemberList[ix].m_iMember, GUID_Function2Getter, &vt);
            if (hr == S_OK && vt.vt == VT_I4 && vt.lVal == 1)
                bFunctionToGetter = TRUE;
            ::VariantClear(&vt);
        }

        // Check for the propget and propset custom attributes if this not already a property.
        if ( (psFunc->invkind & (INVOKE_PROPERTYGET | INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF)) == 0 )
        {
            INVOKEKIND ikind;
            if (S_OK == _CheckForPropertyCustomAttributes(pITI, m_MemberList[ix].m_iMember, &ikind))
                psFunc->invkind = ikind;
        }        

        // If this is a property accessor, but not the 'new enum member', and not 
        //  originally from a managed function (that was exported as a getter),
        //  decorate the name appropriately. If the managed name was set explicitly by
        //  the Guid_ManagedName attribute, then don't try an decorate it.
        if (!bExplicitManagedName && (psFunc->invkind & (INVOKE_PROPERTYGET | INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF) && !bNewEnumMember && !bFunctionToGetter))
        {
            IfNullGo(pszName = m_pMemberNames->Alloc(wcslen(bstrName)+PROP_DECORATION_LEN+1));

            USHORT      msSemantics=0;          // Property's methodsemantics.
            FUNCDESC    *psF;                   // FUNCDESC of Get, Put, or PutRef.
            TYPEDESC    *pProperty;             // TYPEDESC of property type.
            BOOL        bPropRetval;            // Is the property type a [retval]?
            hr = _GetFunctionPropertyInfo(psFunc, &msSemantics, &psF, &pProperty, &bPropRetval);
            m_MemberList[ix].m_msSemantics = msSemantics;
            switch(msSemantics)
            {
            case msGetter:
                wcscpy(pszName, PROP_DECORATION_GET);
                break;
            case msSetter:
                wcscpy(pszName, PROP_DECORATION_SET);
                break;
            case msOther:
                wcscpy(pszName, PROP_DECORATION_LET);
                break;
            default:
                _ASSERTE(msSemantics == 0);
                *pszName = 0;
                break;
            }
            wcscat(pszName, bstrName);
        }
        else
        {
            IfNullGo(pszName = m_pMemberNames->Alloc(wcslen(bstrName)+1));
            wcscpy(pszName, bstrName);
        }

        // Check for name collision, restore original name if collision occurs.
        for (int index=0; index<ix; index++)
        {
            if ( (m_MemberList[index].m_pName) && (wcscmp(pszName, m_MemberList[index].m_pName) == 0) )
            {
                wcscpy(pszName, bstrName);
                m_MemberList[ix].m_msSemantics = 0;
            }
        }
        
        // Save the unique name.
        m_MemberList[ix].m_pName = pszName;
        ::SysFreeString(bstrName);
        bstrName = 0;
    }
    
ErrExit:
    if (pITI2)
        pITI2->Release();
    if (psAttr)
        pITI->ReleaseTypeAttr(psAttr);
    if (bstrName)
        ::SysFreeString(bstrName);
    ::VariantClear(&vt);
    return hr;
} // HRESULT CImportTlb::BuildMemberList()

//*****************************************************************************
// Free the list built in BuildMemberList().
//*****************************************************************************
HRESULT CImportTlb::FreeMemberList(
    ITypeInfo   *pITI)                  // TypeInfo with functions.
{
    int         ix;                     // Loop control.
    for (ix=0; ix<m_cMemberProps; ++ix)
        pITI->ReleaseVarDesc(m_MemberList[ix].m_psVar);
    m_cMemberProps = 0;
    for (; ix<(int)m_MemberList.Size(); ++ix)
        pITI->ReleaseFuncDesc(m_MemberList[ix].m_psFunc);
    m_MemberList.ReSize(0);
    if (m_pMemberNames)
    {
        delete m_pMemberNames;
        m_pMemberNames = 0;
    }
    return S_OK;
} // HRESULT CImportTlb::FreeMemberList()

//*****************************************************************************
// Set a GUID CustomAttribute on an object.
//*****************************************************************************
HRESULT CImportTlb::_AddGuidCa(         // S_OK or error.
    mdToken     tkObj,                  // Object to be attributed.
    REFGUID     guid)                   // The GUID.
{
    HRESULT     hr;                     // A result.
    mdMemberRef mr;                     // MemberRef for GUID CA.
    WCHAR       wzGuid[40];             // Buffer for Guid, Unicode.
    CHAR        szGuid[40];             // Buffer for Guid, Ansi.
    DECLARE_CUSTOM_ATTRIBUTE(40);
        
    // If GUID_NULL, don't store it.
    if (guid == GUID_NULL)
        return S_OK;
    
    // Get the GUID as a string.
    // ----+----1----+----2----+----3----+----4
    // {12345678-1234-1234-1234-123456789012}
    GuidToLPWSTR(guid, wzGuid, lengthof(wzGuid));
    _ASSERTE(wzGuid[37] == L'}');
    wzGuid[37] = L'\0';
    WszWideCharToMultiByte(CP_UTF8, 0, wzGuid+1,-1, szGuid,sizeof(szGuid), 0,0);
    
    // Put it in the Custom Attribute.
    APPEND_STRING_TO_CUSTOM_ATTRIBUTE(szGuid);
    
    // Store the attribute
    IfFailGo(GetAttrType(ATTR_GUID, &mr));
    FINISH_CUSTOM_ATTRIBUTE();
    IfFailGo(m_pEmit->DefineCustomAttribute(tkObj, mr, PTROF_CUSTOM_ATTRIBUTE(), SIZEOF_CUSTOM_ATTRIBUTE(), 0));
    
ErrExit:
    return hr;    
} // HRESULT CImportTlb::_AddGuidCa()
    
//*****************************************************************************
// Add a default member as a custom attribute.
//*****************************************************************************
HRESULT CImportTlb::_AddDefaultMemberCa(// S_OK or error.
    mdToken     tkObj,                  // TypeDef with default member.
    LPCWSTR     wzName)                 // Name of the default member.
{   
    // Only set once per typedef.
    if (tkObj == m_tdHasDefault)
        return S_OK;
    m_tdHasDefault = tkObj;
    
    return _AddStringCa(ATTR_DEFAULTMEMBER, tkObj, wzName);
} // HRESULT CImportTlb::_AddDefaultMemberCa()
    
//*****************************************************************************
// Add a string custom attribute of the given type to the token.
//*****************************************************************************
HRESULT CImportTlb::_AddStringCa(       // S_OK or error.
    int         attr,                   // The type of the CA.
    mdToken     tk,                     // Token to add the CA to.
    LPCWSTR     wzString)               // String to put in the CA.
{
    HRESULT     hr;                     // A result.
    mdMemberRef mr;                     // MemberRef for DefaultMember CA.
    BYTE        *pca;                   // Pointer to custom attribute.
    BYTE        *ca;                    // Pointer to custom attribute.
    int         wzLen;                  // Length of wide string.
    int         len;                    // Length of the string.
    CQuickArray<BYTE> buf;
    
    // Prolog, up to 4 bytes length, string, epilog
    wzLen = (int)wcslen(wzString);
    len = WszWideCharToMultiByte(CP_UTF8,0, wzString, wzLen, 0,0, 0,0);
    IfFailGo(buf.ReSize(2 + 4 + len + 2));
    ca = pca = buf.Ptr();
    
    // Add prolog.
    *reinterpret_cast<USHORT*>(pca) = 1;
    pca += sizeof(USHORT);
    
    // Add length.
    pca = reinterpret_cast<BYTE*>(CPackedLen::PutLength(pca, len));
    
    // Add string.
    WszWideCharToMultiByte(CP_UTF8,0, wzString, wzLen, reinterpret_cast<char*>(pca), len, 0, 0);
    pca += len;
    
    // Add epilog.
    *reinterpret_cast<USHORT*>(pca) = 0;
    pca += sizeof(USHORT);
    
    // Store the attribute
    IfFailGo(GetAttrType(attr, &mr));
    IfFailGo(m_pEmit->DefineCustomAttribute(tk, mr, ca, (ULONG)(pca-ca), 0));
    
ErrExit:
    return hr;    
} // HRESULT CImportTlb::_AddStringCa()

//*****************************************************************************
// Add a referenced typelib to the list of referenced typelibs.  Check if
//  it is "this" typelib first.
//*****************************************************************************
HRESULT CImportTlb::_AddTlbRef(         // S_OK or error.
    ITypeLib        *pITLB,             // The referenced typelib.
    mdAssemblyRef   *par,               // The AssemblyRef in this module.
    BSTR            *pwzNamespace,      // The namespace contained in the resolved assembly.
    BSTR            *pwzAsmName,        // The name of the resolved assembly.
    CImpTlbDefItfToClassItfMap **ppDefItfToClassItfMap) // The default interface to class interface map.
{
    HRESULT          hr = S_OK;                       // A result.
    IUnknown         *pIUnk=0;                        // IUnknown for external assembly.
    mdAssemblyRef    ar=0;                            // Assembly ref in the module containing the typeref.
    ITypeLib2        *pITLB2=0;                       // To get custom attributes.
    VARIANT          vt;                              // Variant type.
    Assembly*        ResolvedAssembly=0;              // The resolved assembly.
    CImpTlbDefItfToClassItfMap *pDefItfToClassItfMap; // Temp def itf to class itf map.

    	
    // Validate the arguments.
    _ASSERTE(pITLB && par && pwzNamespace && pwzAsmName);

    // Initialize the out parameters to NULL.
    *par = mdTokenNil;
    *pwzNamespace = NULL;
    *pwzAsmName = NULL;
    if (ppDefItfToClassItfMap)
        *ppDefItfToClassItfMap = NULL;

    // If not the importing typelib, add it to the list.
    if (pITLB == m_pITLB)
    {   // Not an external assembly.
        //*par = mdAssemblyRefNil;
        *par = TokenFromRid(1, mdtModule);
        IfNullGo(*pwzNamespace = SysAllocStringLen(m_wzNamespace, SysStringLen(m_wzNamespace)));
        *pwzAsmName = NULL;
        if (ppDefItfToClassItfMap)
            *ppDefItfToClassItfMap = &m_DefItfToClassItfMap;
        return S_OK;
    }

    // If already resolved, just return assembly ref.
    if (m_LibRefs.Find(pITLB, par, pwzNamespace, pwzAsmName, NULL, ppDefItfToClassItfMap))
        return S_OK;

    // See if the typelib was exported, in which case it already has assembly ref information.
    ::VariantInit(&vt);
    if (pITLB->QueryInterface(IID_ITypeLib2, reinterpret_cast<void**>(&pITLB2)) == S_OK)
    {
        hr = pITLB2->GetCustData(GUID_ExportedFromComPlus, &vt);
        if (vt.vt == VT_BSTR)
        {
            // Use the CA data to get a reference.
            //CQuickArray<BYTE> rBuf;
            //int iLen;
            // The buffer should have been converted with CP_ACP, and should convert back directly.
            //IfFailGo(rBuf.ReSize(iLen=::SysStringLen(vt.bstrVal)));
            //if (iLen=WszWideCharToMultiByte(CP_ACP,0, vt.bstrVal,iLen, (char*)rBuf.Ptr(),iLen, 0,0))
            {
                // Define the assembly ref for the exported assembly.
                //ar = DefineAssemblyRefForExportedAssembly(rBuf.Ptr(),(DWORD)rBuf.Size(), m_pEmit);
                ar = DefineAssemblyRefForExportedAssembly(vt.bstrVal, m_pEmit);

                // Retrieve the namespace from the typelib.
                IfFailGo(GetNamespaceNameForTypeLib(pITLB, pwzNamespace));

                // Set the assembly name.
                IfNullGo(*pwzAsmName = SysAllocStringLen(vt.bstrVal, SysStringLen(vt.bstrVal)));
            }
        }
    }    
    
    // If it wasn't directly converted to a reference, callback to the resolver.
    if (IsNilToken(ar))
    {
        // Get the assembly for that typelib.
        if (FAILED(m_Notify->ResolveRef(pITLB, &pIUnk)))
            IfFailGo(TLBX_I_RESOLVEREFFAILED);

        // If a NULL assembly was returned, then stop converting the type but 
        // continue the import.
        if (pIUnk == NULL)
            IfFailGo(TLBX_E_INVALID_TYPEINFO);

        // Create an assembly ref in local assembly for referenced assembly.
        ar = DefineAssemblyRefForImportedTypeLib(m_pAssembly, m_pModule, m_pEmit, pIUnk, pwzNamespace, pwzAsmName, &ResolvedAssembly);
    }
    
    // Make sure the ref was resolved before adding to cache.
    if (IsNilToken(ar))
        IfFailGo(TLBX_I_RESOLVEREFFAILED);
    
    // Add the TLB to the list of references.
    IfNullGo(pDefItfToClassItfMap = m_LibRefs.Add(pITLB, this, ar, *pwzNamespace, *pwzAsmName, ResolvedAssembly));

    // Set the output parameters.
    *par = ar;
    if (ppDefItfToClassItfMap)
        *ppDefItfToClassItfMap = pDefItfToClassItfMap;

ErrExit:
    if (FAILED(hr))
    {
        if (*pwzNamespace)
            SysFreeString(*pwzNamespace);
        if (*pwzAsmName)
            SysFreeString(*pwzAsmName);
    }
    if (pIUnk)
        pIUnk->Release();
    if (pITLB2)
        pITLB2->Release();
    VariantClear(&vt);

    return hr;
} // HRESULT CImportTlb::_AddTlbRef()

//*****************************************************************************
// Error reporting helper.
//*****************************************************************************
HRESULT CImportTlb::ReportEvent(        // Returns the original HR.
    int         ev,                     // The event kind.
    int         hrRpt,                  // HR.
    ...)                                // Variable args.
{
    HRESULT     hr;                     // A result.
    va_list     marker;                 // User text.
    BSTR        bstrBuf=0;              // BSTR for bufferrr.
    BSTR        bstrMsg=0;              // BSTR for message.
    const int   iSize = 1024;           // Message size;
    
    // We need a BSTR anyway for the call to ReportEvent, so just allocate a
    //  big one for the buffer.
    IfNullGo(bstrBuf = ::SysAllocStringLen(0, iSize));
    
    // Format the message.
    va_start(marker, hrRpt);
    hr = FormatRuntimeErrorVa(bstrBuf, iSize, hrRpt, marker);
    va_end(marker);
    
    // Display it.
    IfNullGo(bstrMsg = ::SysAllocString(bstrBuf));
    m_Notify->ReportEvent(static_cast<ImporterEventKind>(ev), hrRpt, bstrMsg);
    
ErrExit:    
    // Clean up.
    if (bstrBuf)
        ::SysFreeString(bstrBuf);
    if (bstrMsg)
        ::SysFreeString(bstrMsg);
    return hrRpt;
} // HRESULT CImportTlb::ReportEvent()

//*****************************************************************************
// Helper function to perform the shared functions of creating a TypeRef.
//*****************************************************************************
HRESULT CImpTlbTypeRef::DefineTypeRef(  // S_OK or error.
    IMetaDataEmit *pEmit,               // Emit interface.
    mdAssemblyRef ar,                   // The system assemblyref.
    const LPCWSTR szURL,                // URL of the TypeDef, wide chars.
    mdTypeRef   *ptr)                   // Put mdTypeRef here
{
    HRESULT     hr = S_OK;              // A result.
    LPCWSTR     szLookup;               // The name to look up.
    mdToken     tkNester;               // Token of enclosing class.
    
    // If the name contains a '+', this is a nested type.  The first part becomes
    //  the resolution scope for the part after the '+'.
    szLookup = wcsrchr(szURL, NESTED_SEPARATOR_WCHAR);
    if (szLookup)
    {
        CQuickArray<WCHAR> qbName;
        IfFailGo(qbName.ReSize(szLookup - szURL + 1));
        wcsncpy(qbName.Ptr(), szURL, szLookup - szURL);
        qbName[szLookup - szURL] = L'\0';
        IfFailGo(DefineTypeRef(pEmit, ar, qbName.Ptr(), &tkNester));
        ar = tkNester;
        ++szLookup;
    }
    else
        szLookup = szURL;

    // Look for the item in the map.
    CImpTlbTypeRef::TokenOfTypeRefHashKey sSearch, *pMapped;

    sSearch.tkResolutionScope = ar;
    sSearch.szName = szLookup;
    pMapped = m_Map.Find(&sSearch);

    if (pMapped)
    {
        *ptr = pMapped->tr;
        goto ErrExit;
    }

    // Wasn't found, create a new one and add to the map.
    hr = pEmit->DefineTypeRefByName(ar, szLookup, ptr);
    if (SUCCEEDED(hr))
    {
        sSearch.tr = *ptr;
        pMapped = m_Map.Add(&sSearch);
        IfNullGo(pMapped);
    }

ErrExit:
    return (hr);
} // HRESULT CImpTlbTypeRef::DefineTypeRef()

//*****************************************************************************
// Free the held typelibs in the list of imported typelibs.
//*****************************************************************************
CImpTlbLibRef::~CImpTlbLibRef()
{
    for (ULONG i = 0; i < Size(); i++)
    {
        SysFreeString(operator[](i).szNameSpace);
        delete operator[](i).pDefItfToClassItfMap;
    }
} // CImpTlbLibRef::~CImpTlbLibRef()

//*****************************************************************************
// Add a new typelib reference to the list.
//*****************************************************************************
CImpTlbDefItfToClassItfMap * CImpTlbLibRef::Add(
    ITypeLib    *pITLB,
    CImportTlb  *pImporter,
    mdAssemblyRef ar,
    BSTR wzNamespace,
    BSTR wzAsmName,
    Assembly* assm)
{
    HRESULT     hr;                     // A result.
    TLIBATTR    *pAttr=0;               // A typelib attribute.
    ULONG       i;                      // Index.
    CTlbRef     *pTlbRef=0;             // A pointer to the TlbRef struct.
    
    // Validate the arguments.
    _ASSERTE(wzNamespace);
    _ASSERTE(wzAsmName);

    IfFailGo(pITLB->GetLibAttr(&pAttr));
    
#if defined(_DEBUG)
    for (i=0; i<Size(); ++i)
    {
        if (operator[](i).guid == pAttr->guid)
        {
            _ASSERTE(!"External TypeLib already referenced");
            goto ErrExit;
        }
    }
#else
    i  = (ULONG)Size();
#endif    

    // Allocate and initialize the default interface to class interface map.
    CImpTlbDefItfToClassItfMap *pDefItfToClassItfMap = new CImpTlbDefItfToClassItfMap();
    IfNullGo(pDefItfToClassItfMap);
    IfFailGo(pDefItfToClassItfMap->Init(pITLB, wzNamespace));

    // Attemp to resize the array.
    if (ReSize(i+1) == S_OK)
    {
        pTlbRef = &operator[](i);
        pTlbRef->guid = pAttr->guid;
        pTlbRef->ar = ar;
        IfNullGo(pTlbRef->szNameSpace = SysAllocString(wzNamespace));
        IfNullGo(pTlbRef->szAsmName = SysAllocString(wzAsmName));
        pTlbRef->pDefItfToClassItfMap = pDefItfToClassItfMap;
        pTlbRef->Asm = assm;
        pDefItfToClassItfMap = NULL;
    }
    
ErrExit:
    if (FAILED(hr))
    {
        if (pTlbRef && pTlbRef->szNameSpace)
            SysFreeString(pTlbRef->szNameSpace);
        if (pTlbRef && pTlbRef->szAsmName)
            SysFreeString(pTlbRef->szAsmName);
    }
    if (pAttr)
        pITLB->ReleaseTLibAttr(pAttr);
    if (pDefItfToClassItfMap)
        delete pDefItfToClassItfMap;
    return SUCCEEDED(hr) ? pTlbRef->pDefItfToClassItfMap : NULL;
} // void CImpTlbLibRef::Add()

//*****************************************************************************
// Find an existing typelib reference.
//*****************************************************************************
int CImpTlbLibRef::Find(
    ITypeLib    *pITLB,
    mdAssemblyRef *par,
    BSTR *pwzNamespace,
    BSTR *pwzAsmName,
    Assembly** assm,
    CImpTlbDefItfToClassItfMap **ppDefItfToClassItfMap)
{
    HRESULT     hr;                     // A result.
    TLIBATTR    *pAttr=0;               // A typelib attribute.
    int         rslt = FALSE;           // Return result.
    ULONG       i;                      // Loop control.
    
    _ASSERTE(pwzNamespace);
    _ASSERTE(pwzAsmName);

    // Initalize the out parameters to NULL.
    *pwzNamespace = NULL;
    *pwzAsmName = NULL;

    if (assm) 
    	*assm = NULL;

    IfFailGo(pITLB->GetLibAttr(&pAttr));
    
    for (i=0; i<Size(); ++i)
    {
        if (operator[](i).guid == pAttr->guid)
        {
            *par = operator[](i).ar;
            IfNullGo(*pwzNamespace = SysAllocString(operator[](i).szNameSpace));
            IfNullGo(*pwzAsmName = SysAllocString(operator[](i).szAsmName));
            if (ppDefItfToClassItfMap)
                *ppDefItfToClassItfMap = operator[](i).pDefItfToClassItfMap;
            if (assm)
            	*assm = operator[](i).Asm;
            rslt = TRUE;
            goto ErrExit;
        }
    }
    
ErrExit:
    if (FAILED(hr))
    {
        if (*pwzNamespace)
            SysFreeString(*pwzNamespace);
        if (*pwzAsmName)
            SysFreeString(*pwzAsmName);
    }
    if (pAttr)
        pITLB->ReleaseTLibAttr(pAttr);
    return rslt;
} // void CImpTlbLibRef::Find()

//*****************************************************************************
// unpack variant to an ELEMENT_TYPE_* plus a blob value
// If VT_BOOL, it is a two-byte value.
//*****************************************************************************
HRESULT _UnpackVariantToConstantBlob(VARIANT *pvar, BYTE *pcvType, void **pvValue, __int64 *pd)
{
    HRESULT     hr = NOERROR;

    switch (pvar->vt)
    {
    case VT_BOOL:
        *pcvType = ELEMENT_TYPE_BOOLEAN;
        *((VARIANT_BOOL **)pvValue) = &(pvar->boolVal);
        break;
    case VT_I1:
        *pcvType = ELEMENT_TYPE_I1;
        *((CHAR **)pvValue) = &(pvar->cVal);
        break;
    case VT_UI1:
        *pcvType = ELEMENT_TYPE_U1;
        *((BYTE **)pvValue) = &(pvar->bVal);
        break;
    case VT_I2:
        *pcvType = ELEMENT_TYPE_I2;
        *((SHORT **)pvValue) = &(pvar->iVal);
        break;
    case VT_UI2:
        *pcvType = ELEMENT_TYPE_U2;
        *((USHORT **)pvValue) = &(pvar->uiVal);
        break;
    case VT_I4:
        *pcvType = ELEMENT_TYPE_I4;
        *((LONG **)pvValue) = &(pvar->lVal);
        break;
    case VT_UI4:
        *pcvType = ELEMENT_TYPE_U4;
        *((ULONG **)pvValue) = &(pvar->ulVal);
        break;
    case VT_R4:
        *pcvType = ELEMENT_TYPE_R4;
        *((float **)pvValue) = &(pvar->fltVal);
        break;      
    case VT_I8:
        *pcvType = ELEMENT_TYPE_I8;
        *((LONGLONG **)pvValue) = &(pvar->cyVal.int64);
        break;
    case VT_R8:
        *pcvType = ELEMENT_TYPE_R8;
        *((double **)pvValue) = &(pvar->dblVal);
        break;
    case VT_BSTR:
        *pcvType = ELEMENT_TYPE_STRING;
        *((BSTR *)pvValue) = pvar->bstrVal;     
        break;

    case VT_DATE:
        *pcvType = ELEMENT_TYPE_I8;
        *pd = _DoubleDateToTicks(pvar->date);
        *((LONGLONG **)pvValue) = pd;
        break;
    case VT_UNKNOWN:
    case VT_DISPATCH:
        *pcvType = ELEMENT_TYPE_CLASS;
        _ASSERTE(pvar->punkVal == NULL);
        *((IUnknown ***)pvValue) = &(pvar->punkVal);        
        break;
    default:
        _ASSERTE(!"Not a valid type to specify default value!");
        IfFailGo( META_E_BAD_INPUT_PARAMETER );
        break;
    }
ErrExit:
    return hr;
} // HRESULT _UnpackVariantToConstantBlob()

//*****************************************************************************
// Stolen from classlib.
//*****************************************************************************
INT64 _DoubleDateToTicks(const double d)
{
    const INT64 MillisPerSecond = 1000;
    const INT64 MillisPerDay = MillisPerSecond * 60 * 60 * 24;
    const INT64 TicksPerMillisecond = 10000;
    const INT64 TicksPerSecond = TicksPerMillisecond * 1000;
    const INT64 TicksPerMinute = TicksPerSecond * 60;
    const INT64 TicksPerHour = TicksPerMinute * 60;
    const INT64 TicksPerDay = TicksPerHour * 24;
    const int DaysPer4Years = 365 * 4 + 1;
    const int DaysPer100Years = DaysPer4Years * 25 - 1;
    const int DaysPer400Years = DaysPer100Years * 4 + 1;
    const int DaysTo1899 = DaysPer400Years * 4 + DaysPer100Years * 3 - 367;
    const INT64 DoubleDateOffset = DaysTo1899 * TicksPerDay;
    const int DaysTo10000 = DaysPer400Years * 25 - 366;
    const INT64 MaxMillis = DaysTo10000 * MillisPerDay;

    INT64 millis = (INT64)(d * MillisPerDay + (d >= 0? 0.5: -0.5));
    if (millis < 0) millis -= (millis % MillisPerDay) * 2;
    millis += DoubleDateOffset / TicksPerMillisecond;
    if (millis < 0 || millis >= MaxMillis) {
        return 0;
    }
    return millis * TicksPerMillisecond;
} // INT64 _DoubleDateToTicks()


//*****************************************************************************
// Wrapper for GetFuncDesc to catch errors.
//*****************************************************************************
static HRESULT TryGetFuncDesc(          // S_OK or error.
    ITypeInfo   *pITI,                  // ITypeInfo with function.
    int         i,                      // Function index.
    FUNCDESC    **ppFunc)               // Put FUNCDESC here.
{
    HRESULT     hr;                     // A return code.
    __try
    {
        hr = pITI->GetFuncDesc(i, ppFunc);
    }
    __except(1)
    {
        hr = PostError(TLBX_E_TLB_EXCEPTION, _exception_code());
    }
    
    return hr;
} // static HRESULT TryGetFuncDesc()

//*****************************************************************************
// Implementation of a hashed ResolutionScope+Name to TypeRef map.
//*****************************************************************************
void CImpTlbTypeRef::CTokenOfTypeRefHash::Clear()
{
#if defined(_DEBUG)
    // printf("Name to TypeRef cache: %d buckets, %d used, %d collisions\n", Buckets(), Count(), Collisions());
#endif
    CClosedHash<class TokenOfTypeRefHashKey>::Clear();
} // void CImpTlbTypeRef::CTokenOfTypeRefHash::Clear()

unsigned long CImpTlbTypeRef::CTokenOfTypeRefHash::Hash(const TokenOfTypeRefHashKey *pData)
{
    // Starting value for hash.
    ULONG   hash = 5381;
    
    // Hash in the resolution scope token.
    const BYTE *pbData = reinterpret_cast<const BYTE *>(&pData->tkResolutionScope);
    int iSize = 4;
    while (--iSize >= 0)
    {
        hash = ((hash << 5) + hash) ^ *pbData;
        ++pbData;
    }

    // Hash in the typeref name.
    LPCWSTR szStr = pData->szName;
    int     c;
    while ((c = *szStr) != 0)
    {
        hash = ((hash << 5) + hash) ^ c;
        ++szStr;
    }

    return hash;
} // unsigned long CImpTlbTypeRef::CTokenOfTypeRefHash::Hash()

unsigned long CImpTlbTypeRef::CTokenOfTypeRefHash::Compare(const TokenOfTypeRefHashKey *p1, TokenOfTypeRefHashKey *p2)
{
    // Resolution scopes are fast to compare.
    if (p1->tkResolutionScope < p2->tkResolutionScope)
        return -1;
    if (p1->tkResolutionScope > p2->tkResolutionScope)
        return 1;
    // But if they are the same, compare the names.
    return wcscmp(p1->szName, p2->szName);
} // unsigned long CImpTlbTypeRef::CTokenOfTypeRefHash::Compare()

CImpTlbTypeRef::CTokenOfTypeRefHash::ELEMENTSTATUS CImpTlbTypeRef::CTokenOfTypeRefHash::Status(TokenOfTypeRefHashKey *p)
{
    if (p->tkResolutionScope == static_cast<mdToken>(FREE))
        return (FREE);
    if (p->tkResolutionScope == static_cast<mdToken>(DELETED))
        return (DELETED);
    return (USED);
} // CImpTlbTypeRef::CTokenOfTypeRefHash::ELEMENTSTATUS CImpTlbTypeRef::CTokenOfTypeRefHash::Status()

void CImpTlbTypeRef::CTokenOfTypeRefHash::SetStatus(TokenOfTypeRefHashKey *p, ELEMENTSTATUS s)
{
    p->tkResolutionScope = static_cast<mdToken>(s);
} // void CImpTlbTypeRef::CTokenOfTypeRefHash::SetStatus()

void *CImpTlbTypeRef::CTokenOfTypeRefHash::GetKey(TokenOfTypeRefHashKey *p)
{
    return p;
} // void *CImpTlbTypeRef::CTokenOfTypeRefHash::GetKey()

CImpTlbTypeRef::TokenOfTypeRefHashKey* CImpTlbTypeRef::CTokenOfTypeRefHash::Add(const TokenOfTypeRefHashKey *pData)
{
    LPWSTR pName;
    const void *pvData = pData;
    TokenOfTypeRefHashKey *pNew = Super::Add(const_cast<void*>(pvData));
    if (pNew == 0)
        return 0;
    pNew->szName = pName = m_Names.Alloc(wcslen(pData->szName)+1);
    if (pNew->szName == 0)
        return 0;
    wcscpy(pName, pData->szName);
    pNew->tkResolutionScope = pData->tkResolutionScope;
    pNew->tr = pData->tr;

    return pNew;
} // TokenOfTypeRefHashKey* CImpTlbTypeRef::CTokenOfTypeRefHash::Add()

//*****************************************************************************
// Implementation of a hashed ITypeInfo * source interface to event information
// map.
//*****************************************************************************
HRESULT CImpTlbEventInfoMap::AddEventInfo(LPCWSTR szSrcItfName, mdTypeRef trEventItf, LPCWSTR szEventItfName, LPCWSTR szEventProviderName, Assembly* SrcItfAssembly)
{
    ImpTlbEventInfo sNew;
    sNew.szSrcItfName = szSrcItfName;
    sNew.trEventItf = trEventItf;
    sNew.szEventItfName = szEventItfName;
    sNew.szEventProviderName = szEventProviderName;
    sNew.SrcItfAssembly = SrcItfAssembly;
    return Add(&sNew) != NULL ? S_OK : E_OUTOFMEMORY;
} // BOOL CImpTlbEventInfoMap::AddEventInfo()

ImpTlbEventInfo *CImpTlbEventInfoMap::FindEventInfo(LPCWSTR szSrcItfName)
{
    ImpTlbEventInfo sSearch, *pMapped;
    sSearch.szSrcItfName = szSrcItfName;
    pMapped = Find(&sSearch);
    return pMapped;
} // ImpTlbEventInfo *CImpTlbEventInfoMap::FindEventInfo()

HRESULT CImpTlbEventInfoMap::GetEventInfoList(CQuickArray<ImpTlbEventInfo*> &qbEvInfoList)
{
    HRESULT hr = S_OK;
    int cCurrEvInfo = 0;

    // Resise the event info list.
    IfFailGo(qbEvInfoList.ReSize(Count()));

    // Retrieve the first event info.
    ImpTlbEventInfo *pEvInfo = GetFirst();

    // Add all the event info's to the list.
    while (pEvInfo)
    {
        qbEvInfoList[cCurrEvInfo++] = pEvInfo;
        pEvInfo = GetNext(pEvInfo);
    }

ErrExit:
    return hr;    
} // HRESULT CImpTlbEventInfoMap::GetEventInfoList()

unsigned long CImpTlbEventInfoMap::Hash(const ImpTlbEventInfo *pData)
{
    // Starting value for hash.
    ULONG   hash = 5381;
    
    // Hash in the source interface name.
    LPCWSTR szStr = pData->szSrcItfName;
    int     c;
    while ((c = *szStr) != 0)
    {
        hash = ((hash << 5) + hash) ^ c;
        ++szStr;
    }

    return hash;
} // unsigned long CImpTlbEventInfoMap::Hash()

unsigned long CImpTlbEventInfoMap::Compare(const ImpTlbEventInfo *p1, ImpTlbEventInfo *p2)
{
    // Compare the source interface names.
    return wcscmp(p1->szSrcItfName, p2->szSrcItfName);
} // unsigned long CImpTlbEventInfoMap::Compare()

CImpTlbEventInfoMap::ELEMENTSTATUS CImpTlbEventInfoMap::Status(ImpTlbEventInfo *p)
{
    if (p->szSrcItfName == reinterpret_cast<LPCWSTR>(FREE))
        return (FREE);
    if (p->szSrcItfName == reinterpret_cast<LPCWSTR>(DELETED))
        return (DELETED);
    return (USED);
} // CImpTlbEventInfoMap::ELEMENTSTATUS CImpTlbEventInfoMap::Status()

void CImpTlbEventInfoMap::SetStatus(ImpTlbEventInfo *p, ELEMENTSTATUS s)
{
    p->szSrcItfName = reinterpret_cast<LPCWSTR>(s);
} // void CImpTlbEventInfoMap::SetStatus()

void *CImpTlbEventInfoMap::GetKey(ImpTlbEventInfo *p)
{
    return p;
} // void *CImpTlbEventInfoMap::GetKey()

ImpTlbEventInfo* CImpTlbEventInfoMap::Add(const ImpTlbEventInfo *pData)
{
    // Add the new entry to the map.
    const void *pvData = pData;
    ImpTlbEventInfo *pNew = Super::Add(const_cast<void*>(pvData));
    if (pNew == 0)
        return 0;

    // Copy the source interface name.
    pNew->szSrcItfName = m_Names.Alloc(wcslen(pData->szSrcItfName)+1);
    if (pNew->szSrcItfName == 0)
        return 0;
    wcscpy((LPWSTR)pNew->szSrcItfName, pData->szSrcItfName);

    // Copy the event interface type def.
    pNew->trEventItf = pData->trEventItf;

    // Copy the event interface name.
    pNew->szEventItfName = m_Names.Alloc(wcslen(pData->szEventItfName)+1);
    if (pNew->szEventItfName == 0)
        return 0;
    wcscpy((LPWSTR)pNew->szEventItfName, pData->szEventItfName);

    // Copy the event provider name.
    pNew->szEventProviderName = m_Names.Alloc(wcslen(pData->szEventProviderName)+1);
    if (pNew->szEventProviderName == 0)
        return 0;
    wcscpy((LPWSTR)pNew->szEventProviderName, pData->szEventProviderName);

    // Copy the Source Interface Assembly pointer
    pNew->SrcItfAssembly = pData->SrcItfAssembly;
    
    // Return the new entry.
    return pNew;
} // ImpTlbEventInfo* CImpTlbEventInfoMap::Add()

CImpTlbDefItfToClassItfMap::CImpTlbDefItfToClassItfMap() 
: CClosedHash<class ImpTlbClassItfInfo>(101) 
, m_bstrNameSpace(NULL) 
{
}

CImpTlbDefItfToClassItfMap::~CImpTlbDefItfToClassItfMap() 
{ 
    Clear(); 
    if (m_bstrNameSpace)
    {
        ::SysFreeString(m_bstrNameSpace);
        m_bstrNameSpace = NULL;
    }
}

HRESULT CImpTlbDefItfToClassItfMap::Init(ITypeLib *pTlb, BSTR bstrNameSpace)
{
    HRESULT                 hr;                     // A result.
    int                     cTi;                    // Count of TypeInfos.
    int                     i;                      // Loop control.
    TYPEATTR                *psAttr=0;              // TYPEATTR for the ITypeInfo.
    TYPEATTR                *psDefItfAttr=0;        // TYPEATTR for the default interface.
    ITypeInfo               *pITI=0;                // The ITypeInfo.
    ITypeInfo               *pDefItfITI=0;          // The ITypeInfo for the default interface.

    // Save the namespace.
    IfNullGo(m_bstrNameSpace = SysAllocString(bstrNameSpace));

    // How many TypeInfos?
    IfFailGo(cTi = pTlb->GetTypeInfoCount());

    // Iterate over them.
    for (i = 0; i < cTi; ++i)
    {
        // Get the TypeInfo.
        hr = pTlb->GetTypeInfo(i, &pITI);
        if (SUCCEEDED(hr))
        {
            // Retrieve the attributes of the type info.
            IfFailGo(pITI->GetTypeAttr(&psAttr));

            // If we are dealing with a CoClass, then set up the default interface to 
            // class interface mapping.
            if (psAttr->typekind == TKIND_COCLASS)
                IfFailGo(AddCoClassInterfaces(pITI, psAttr));

            // Release for next TypeInfo.
            if (psAttr)
            {
                pITI->ReleaseTypeAttr(psAttr);
                psAttr = 0;
            }
            if (pITI)
            {
                pITI->Release();
                pITI = 0;
            }
        }
    }

ErrExit:
    if (psAttr)
        pITI->ReleaseTypeAttr(psAttr);
    if (pITI)
        pITI->Release();

    return (hr);
}

HRESULT CImpTlbDefItfToClassItfMap::AddCoClassInterfaces(ITypeInfo *pCoClassITI, TYPEATTR *pCoClassTypeAttr)
{
    HRESULT     hr;                 // A result
    HREFTYPE    href;               // HREFTYPE of an implemented interface.
    INT         ImplFlags;          // ImplType flags.
    int         NumInterfaces;      // The number of interfaces on the coclass.
    int         i;                  // A counter.
    ITypeInfo   *pItfITI=0;         // The ITypeInfo for the current interface.
    ITypeInfo   *pBaseItfITI=0;     // The ITypeInfo for the base interface.
    TYPEATTR    *psItfAttr=0;       // TYPEATTR for the interface.
    BSTR        bstrClassItfName=0; // The name of the class interface.

    // Retrieve the name of the CoClass.
    IfFailGo(GetManagedNameForTypeInfo(pCoClassITI, m_bstrNameSpace, NULL, &bstrClassItfName));

    // Retrieve the default interface for the CoClass.
    IfFailGo(CImportTlb::GetDefaultInterface(pCoClassITI, &pItfITI));

    // If there is a default interface, then add it to the map.
    if (hr == S_OK)
    {
        // Retrieve the attributes of the default interface type info.
        IfFailGo(pItfITI->GetTypeAttr(&psItfAttr));

        // If there already is a CoClass that implements this 
        // interface then we do not want to do the mapping.
        ImpTlbClassItfInfo sSearch, *pMapped;
        sSearch.ItfIID = psItfAttr->guid;
        pMapped = Find(&sSearch);
        if (pMapped)
        {
            // There already is a CoClass that implements the interface so 
            // we set the class itf name to NULL to indicate not to do the def 
            // itf to class itf convertion for this interface.
            pMapped->szClassItfName = NULL;
        }
        else
        {
            // Unless the default interface is IUnknown or IDispatch, add the 
            // def itf to class itf entry to the map.       
            if (psItfAttr->guid != IID_IUnknown && psItfAttr->guid != IID_IDispatch)
            {
                ImpTlbClassItfInfo sNew;
                sNew.ItfIID = psItfAttr->guid;
                sNew.szClassItfName = bstrClassItfName;
                IfNullGo(Add(&sNew)); 
            }
        }

        // Release for next interface.
        pItfITI->ReleaseTypeAttr(psItfAttr);
        psItfAttr = 0;  
        pItfITI->Release();
        pItfITI = 0;
    }

    // Retrieve the number of interfaces the coclass has
    NumInterfaces = pCoClassTypeAttr->cImplTypes;

    // Go through all the interfaces and add them to the map.
    for (i=0; i < NumInterfaces; i++)
    {
        // Get the impl flags.
        IfFailGo(pCoClassITI->GetImplTypeFlags(i, &ImplFlags));

        // If this is an implemented interface.
        if (!(ImplFlags & IMPLTYPEFLAG_FSOURCE))
        {
            IfFailGo(pCoClassITI->GetRefTypeOfImplType(i, &href));
            IfFailGo(pCoClassITI->GetRefTypeInfo(href, &pItfITI));

            do
            {
                // Retrieve the attributes of the interface type info.
                IfFailGo(pItfITI->GetTypeAttr(&psItfAttr));

                // If there already is a CoClass that implements this 
                // interface then we do not want to do the mapping.
                ImpTlbClassItfInfo sSearch, *pMapped;
                sSearch.ItfIID = psItfAttr->guid;
                pMapped = Find(&sSearch);
                if (pMapped)
                {
                    // There already is a CoClass that implements the interface. If that
                    // CoClass is not the current one, then we we set the class itf name 
                    // to NULL to indicate not to do the def itf to class itf convertion 
                    // for this interface.
                    if (pMapped->szClassItfName && wcscmp(pMapped->szClassItfName, bstrClassItfName) != 0)
                        pMapped->szClassItfName = NULL;
                }
                else
                {
                    // Add an entry with a NULL name to prevent future substitutions.
                    ImpTlbClassItfInfo sNew;
                    sNew.ItfIID = psItfAttr->guid;
                    sNew.szClassItfName = NULL;
                    IfNullGo(Add(&sNew)); 
                }

                // If there is a base interface, then handle it also.
                if (psItfAttr->cImplTypes == 1)
                {
                    IfFailGo(pItfITI->GetRefTypeOfImplType(0, &href));
                    IfFailGo(pItfITI->GetRefTypeInfo(href, &pBaseItfITI));                       
                }

                // Release for next interface.
                if (psItfAttr)
                {
                    pItfITI->ReleaseTypeAttr(psItfAttr);
                    psItfAttr = 0;
                }
                if (pItfITI)
                {
                    pItfITI->Release();
                    pItfITI = 0;
                }

                // Set the current interface to the base interface.
                pItfITI = pBaseItfITI;
                pBaseItfITI = 0;
            }
            while(pItfITI);
        }       
    }

ErrExit:
    if (psItfAttr)
        pItfITI->ReleaseTypeAttr(psItfAttr);
    if (pItfITI)
        pItfITI->Release();
    if (bstrClassItfName)
        ::SysFreeString(bstrClassItfName);

    return hr;
}

LPCWSTR CImpTlbDefItfToClassItfMap::GetClassItfName(IID &rItfIID)
{
    ImpTlbClassItfInfo sSearch, *pMapped;
    sSearch.ItfIID = rItfIID;
    pMapped = Find(&sSearch);
    return pMapped ? pMapped->szClassItfName : NULL;
}

unsigned long CImpTlbDefItfToClassItfMap::Hash(const ImpTlbClassItfInfo *pData)
{
    // Starting value for hash.
    ULONG   hash = 5381;
    
    // Hash in the IID.
    const BYTE *pbData = reinterpret_cast<const BYTE *>(&pData->ItfIID);
    int iSize = sizeof(IID);
    while (--iSize >= 0)
    {
        hash = ((hash << 5) + hash) ^ *pbData;
        ++pbData;
    }

    return hash;
} // unsigned long CImpTlbDefItfToClassItfMap::Hash()

unsigned long CImpTlbDefItfToClassItfMap::Compare(const ImpTlbClassItfInfo *p1, ImpTlbClassItfInfo *p2)
{
    // Compare the IID's.
    return memcmp(&p1->ItfIID, &p2->ItfIID, sizeof(IID));
} // unsigned long CImpTlbEventInfoMap::Compare()

CImpTlbDefItfToClassItfMap::ELEMENTSTATUS CImpTlbDefItfToClassItfMap::Status(ImpTlbClassItfInfo *p)
{
    if (IsEqualGUID(p->ItfIID, FREE_STATUS_GUID))
    {
        return (FREE);
    }
    else if (IsEqualGUID(p->ItfIID, DELETED_STATUS_GUID))
    {
        return (DELETED);
    }
    return (USED);
} // CImpTlbDefItfToClassItfMap::ELEMENTSTATUS CImpTlbEventInfoMap::Status()

void CImpTlbDefItfToClassItfMap::SetStatus(ImpTlbClassItfInfo *p, ELEMENTSTATUS s)
{
    if (s == FREE)
    {
        p->ItfIID = FREE_STATUS_GUID;
    }
    else if (s == DELETED)
    {
        p->ItfIID = DELETED_STATUS_GUID;
    }
    else
    {
        _ASSERTE(!"Invalid status!");
    }
} // void CImpTlbDefItfToClassItfMap::SetStatus()

void *CImpTlbDefItfToClassItfMap::GetKey(ImpTlbClassItfInfo *p)
{
    return p;
} // void *CImpTlbDefItfToClassItfMap::GetKey()

ImpTlbClassItfInfo* CImpTlbDefItfToClassItfMap::Add(const ImpTlbClassItfInfo *pData)
{
    // Add the new entry to the map.
    const void *pvData = pData;
    ImpTlbClassItfInfo *pNew = Super::Add(const_cast<void*>(pvData));
    if (pNew == 0)
        return 0;

    // Copy the IID.
    pNew->ItfIID = pData->ItfIID;

    // Copy the class interface name.
    if (pData->szClassItfName)
    {
        pNew->szClassItfName = m_Names.Alloc(wcslen(pData->szClassItfName)+1);
        if (pNew->szClassItfName == 0)
            return 0;
        wcscpy((LPWSTR)pNew->szClassItfName, pData->szClassItfName);
    }
    else
    {
        pNew->szClassItfName = NULL;
    }

    // Return the new entry.
    return pNew;
} // ImpTlbEventInfo* CImpTlbEventInfoMap::Add()

// EOF =======================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\mdinternalrw.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
//  File: MDInternalRW.CPP
//  Notes:
//      
//
// ===========================================================================
#include "stdafx.h"
#include "..\runtime\MDInternalRO.h"
#include "..\compiler\RegMeta.h"    
#include "..\compiler\ImportHelper.h"
#include "MDInternalRW.h"
#include "MetaModelRO.h"
#include "LiteWeightStgdb.h"
#include "sighelper.h"

#undef __unaligned

#ifdef _DEBUG
#define MD_AssertIfConvertToRW L"MD_ASSERTECONVERT"
#endif // _DEBUG

HRESULT _GetFixedSigOfVarArg(           // S_OK or error.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob of COM+ method signature
    ULONG   cbSigBlob,                  // [IN] size of signature
    CQuickBytes *pqbSig,                // [OUT] output buffer for fixed part of VarArg Signature
    ULONG   *pcbSigBlob);               // [OUT] number of bytes written to the above output buffer

HRESULT _FillMDDefaultValue(
    BYTE        bType,
    void const *pValue,
    MDDefaultValue  *pMDDefaultValue);

//*****************************************************************************
// Serve as a delegator to call ImportHelper::MergeUpdateTokenInSig. Or we will
// need to include ImportHelper into our md\runtime directory.
//*****************************************************************************
HRESULT TranslateSigHelper(             // S_OK or error.
    CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Assembly emit scope.
    CMiniMdRW   *pMiniMdEmit,           // [IN] The emit scope.
    IMetaModelCommon *pAssemCommon,     // [IN] Assembly import scope.
    const void  *pbHashValue,           // [IN] Hash value.
    ULONG       cbHashValue,            // [IN] Size in bytes.
    IMetaModelCommon *pCommon,          // [IN] The scope to merge into the emit scope.
    PCCOR_SIGNATURE pbSigImp,           // [IN] signature from the imported scope
    MDTOKENMAP  *ptkMap,                // [IN] Internal OID mapping structure.
    CQuickBytes *pqkSigEmit,            // [OUT] translated signature
    ULONG       cbStartEmit,            // [IN] start point of buffer to write to
    ULONG       *pcbImp,                // [OUT] total number of bytes consumed from pbSigImp
    ULONG       *pcbEmit)               // [OUT] total number of bytes write to pqkSigEmit
{
    return ImportHelper::MergeUpdateTokenInSig(
        pMiniMdAssemEmit,       // [IN] Assembly emit scope.
        pMiniMdEmit,            // [IN] The emit scope.
        pAssemCommon,           // [IN] Assembly import scope.
        pbHashValue,            // [IN] Hash value.
        cbHashValue,            // [IN] Size in bytes.
        pCommon,                // [IN] The scope to merge into the emit scope.
        pbSigImp,               // [IN] signature from the imported scope
        ptkMap,                 // [IN] Internal OID mapping structure.
        pqkSigEmit,             // [OUT] translated signature
        cbStartEmit,            // [IN] start point of buffer to write to
        pcbImp,                 // [OUT] total number of bytes consumed from pbSigImp
        pcbEmit);               // [OUT] total number of bytes write to pqkSigEmit

} // HRESULT TranslateSigHelper()


//*****************************************************************************
// Given an IMDInternalImport on a CMiniMd[RO], convert to CMiniMdRW.
//*****************************************************************************
STDAPI ConvertRO2RW(
    IUnknown    *pRO,                   // [IN] The RO interface to convert.
    REFIID      riid,                   // [IN] The interface desired.
    void        **ppIUnk)               // [OUT] Return interface on success.
{
    HRESULT     hr = S_OK;              // A result.
    IMDInternalImportENC *pRW = 0;      // To test the RW-ness of the input iface.
    MDInternalRW *pInternalRW = 0;      // Gets the new RW object.

    // Avoid confusion.
    *ppIUnk = 0;

    // If the interface is already RW, done, just return.
    if (pRO->QueryInterface(IID_IMDInternalImportENC, (void**)&pRW) == S_OK)
    {
        hr = pRO->QueryInterface(riid, ppIUnk);
        goto ErrExit;
    }

    // Create the new RW object.
    pInternalRW = new MDInternalRW;
    IfNullGo( pInternalRW );

    // Init from the RO object.  Convert as read-only; QI will make writable if
    //  so needed.
    IfFailGo( pInternalRW->InitWithRO(static_cast<MDInternalRO*>(pRO), true)); 
    IfFailGo( pInternalRW->QueryInterface(riid, ppIUnk) );

ErrExit:
    if (pRW)
        pRW->Release();
    // Clean up the object and [OUT] interface on error.
    if (FAILED(hr))
    {
        if (pInternalRW)
            delete pInternalRW;
        *ppIUnk = 0;
    }
    else if (pInternalRW)
        pInternalRW->Release();

    return hr;
} // STDAPI ConvertRO2RW()


//*****************************************************************************
// Helper to get the internal interface with RW format
//*****************************************************************************
HRESULT GetInternalWithRWFormat(
    LPVOID      pData, 
    ULONG       cbData, 
    DWORD       flags,                  // [IN] MDInternal_OpenForRead or MDInternal_OpenForENC
    REFIID      riid,                   // [in] The interface desired.
    void        **ppIUnk)               // [out] Return interface on success.
{
    MDInternalRW *pInternalRW = NULL;
    HRESULT     hr;

    *ppIUnk = 0;
    pInternalRW = new MDInternalRW;
    IfNullGo( pInternalRW );
    IfFailGo( pInternalRW->Init(
            const_cast<void*>(pData), 
            cbData, 
            (flags == ofRead) ? true : false) );
    IfFailGo( pInternalRW->QueryInterface(riid, ppIUnk) );
ErrExit:
    if (FAILED(hr))
    {
        if (pInternalRW)
            delete pInternalRW;
        *ppIUnk = 0;
    }
    else if ( pInternalRW )
        pInternalRW->Release();
    return hr;
} // HRESULT GetInternalWithRWFormat()


//*****************************************************************************
// This function returns a IMDInternalImport interface based on the given
// public import interface i.e IMetaDataEmit or IMetaDataImport.
//*****************************************************************************
STDAPI GetMDInternalInterfaceFromPublic(
    void        *pIUnkPublic,           // [IN] Given public interface.
    REFIID      riid,                   // [in] The interface desired.
    void        **ppIUnkInternal)       // [out] Return interface on success.
{
    HRESULT     hr = S_OK;
    RegMeta     *pMeta = (RegMeta*)(pIUnkPublic);
    MDInternalRW *pInternalRW = NULL;
    bool        isLockedForWrite = false;

    // IMDInternalImport is the only internal import interface currently supported by
    // this function.
    _ASSERTE(riid == IID_IMDInternalImport && pIUnkPublic && ppIUnkInternal);

    
    if (pIUnkPublic == NULL || ppIUnkInternal == NULL)
        IfFailGo(E_INVALIDARG);

    *ppIUnkInternal = pMeta->GetCachedInternalInterface(TRUE);
    if (*ppIUnkInternal)
    {
        // there is already a cached Internal interface. GetCachedInternalInterface does add ref the 
        // returned interface 
        //        
        // We are done!
        goto ErrExit;
    }

    _ASSERTE( pMeta->GetReaderWriterLock() );
    pMeta->GetReaderWriterLock()->LockWrite();
    isLockedForWrite = true;

    // check again. Maybe someone else beat us to setting the internal interface while we are waiting
    // for the write lock. Don't need to grab the read lock since we already have the write lock.
    *ppIUnkInternal = pMeta->GetCachedInternalInterface(FALSE);
    if (*ppIUnkInternal)
    {
        // there is already a cached Internal interface. GetCachedInternalInterface does add ref the 
        // returned interface 
        //        
        // We are done!
        goto ErrExit;
    }
        
    // now create the compressed object
    IfNullGo( pInternalRW = new MDInternalRW );
    IfFailGo( pInternalRW->InitWithStgdb((IUnknown*)pIUnkPublic, pMeta->GetMiniStgdb() ) );
    IfFailGo( pInternalRW->QueryInterface(riid, ppIUnkInternal) );

    // MDInternalRW is created with ref count of one.
    pInternalRW->Release();

    // make the public object and the internal object point to each other.
    _ASSERTE( pInternalRW->GetReaderWriterLock() == NULL && pMeta->GetReaderWriterLock() != NULL );
    IfFailGo( pMeta->SetCachedInternalInterface(pInternalRW) );
    IfFailGo( pInternalRW->SetCachedPublicInterface((IUnknown *)pIUnkPublic) );
    IfFailGo( pInternalRW->SetReaderWriterLock(pMeta->GetReaderWriterLock() ));

ErrExit:
    if (isLockedForWrite == true)
        pMeta->GetReaderWriterLock()->UnlockWrite();
    if (FAILED(hr))
    {
        if (pInternalRW)
            delete pInternalRW;
        if (ppIUnkInternal)
            *ppIUnkInternal = 0;
    }
    return hr;
} // STDAPI GetMDInternalInterfaceFromPublic()


//*****************************************************************************
// This function returns the requested public interface based on the given
// internal import interface. It is caller's responsibility to Release ppIUnkPublic
//*****************************************************************************
STDAPI GetMDPublicInterfaceFromInternal(
    void        *pIUnkInternal,         // [IN] Given internal interface.
    REFIID      riid,                   // [in] The interface desired.
    void        **ppIUnkPublic)         // [out] Return interface on success.
{
    HRESULT     hr = S_OK;
    IMDInternalImport *pInternalImport = 0;;
    IUnknown    *pIUnkPublic = NULL;
    OptionValue optVal = { MDDupAll, MDRefToDefDefault, MDNotifyDefault, MDUpdateFull, MDErrorOutOfOrderDefault , MDThreadSafetyOn};
    RegMeta     *pMeta = 0;
    bool        isLockedForWrite = false;

    _ASSERTE(pIUnkInternal && ppIUnkPublic);
    *ppIUnkPublic = 0;

#ifdef _DEBUG
    {
        ULONG len;
        len = WszGetEnvironmentVariable(MD_AssertIfConvertToRW, NULL, 0);
        if (len)
        {
            _ASSERTE(!"Converting!");
        }
    }
#endif // _DEBUG

    IfFailGo(ConvertRO2RW((IUnknown*)pIUnkInternal, IID_IMDInternalImport, (void **)&pInternalImport));

    pIUnkPublic = pInternalImport->GetCachedPublicInterface(TRUE);
    if ( pIUnkPublic )
    {
        // There is already a cached public interface. GetCachedPublicInterface already AddRef the returned 
        // public interface. We want to QueryInterface the riid...
        // We are done!
        hr = pIUnkPublic->QueryInterface(riid, ppIUnkPublic);
        pIUnkPublic->Release();
        goto ErrExit;
    }

    // grab the write lock when we are creating the corresponding regmeta for the public interface
    _ASSERTE( pInternalImport->GetReaderWriterLock() != NULL );
    isLockedForWrite = true;
    pInternalImport->GetReaderWriterLock()->LockWrite();

    // check again. Maybe someone else beat us to setting the public interface while we are waiting
    // for the write lock. Don't need to grab the read lock since we already have the write lock.
    *ppIUnkPublic = pInternalImport->GetCachedPublicInterface(FALSE);
    if ( *ppIUnkPublic )
    {
        // there is already a cached public interface. GetCachedPublicInterface already AddRef the returned 
        // public interface.
        // We are done!
        goto ErrExit;
    }
        
    pMeta = new RegMeta(&optVal, FALSE);
    _ASSERTE(pMeta != NULL);
    IfNullGo(pMeta);

    IfFailGo( pMeta->InitWithStgdb((IUnknown*)pInternalImport, ((MDInternalRW*)pInternalImport)->GetMiniStgdb()) );
    IfFailGo( pMeta->QueryInterface(riid, ppIUnkPublic) );

    // make the public object and the internal object point to each other.
    _ASSERTE( pMeta->GetReaderWriterLock() == NULL );
    IfFailGo( pMeta->SetCachedInternalInterface(pInternalImport) );
    IfFailGo( pInternalImport->SetCachedPublicInterface((IUnknown *) *ppIUnkPublic) );
    IfFailGo( pMeta->SetReaderWriterLock(pInternalImport->GetReaderWriterLock() ));

    // Add the new RegMeta to the cache.
    IfFailGo( pMeta->AddToCache() );
    
ErrExit:
    if (isLockedForWrite) 
        pInternalImport->GetReaderWriterLock()->UnlockWrite();

    if (pInternalImport)
        pInternalImport->Release();
    if (FAILED(hr))
    {
        if (pMeta)
            delete pMeta;
        *ppIUnkPublic = 0;
    }
    return hr;
} // STDAPI GetMDPublicInterfaceFromInternal()

//*****************************************************************************
// Converts an internal MD import API into the read/write version of this API.
// This could support edit and continue, or modification of the metadata at
// runtime (say for profiling).
//*****************************************************************************
STDAPI ConvertMDInternalImport(         // S_OK, S_FALSE (no conversion), or error.
    IMDInternalImport *pIMD,            // [in] The metadata to be updated.
    IMDInternalImport **ppIMD)          // [out] Put the RW here.
{
    HRESULT     hr;                     // A result.
    IMDInternalImportENC *pENC = NULL;  // ENC interface on the metadata.

    _ASSERTE(pIMD != NULL);
    _ASSERTE(ppIMD != NULL);

    // Test whether the MD is already RW.
    hr = pIMD->QueryInterface(IID_IMDInternalImportENC, (void**)&pENC);
    if (FAILED(hr))
    {   // Not yet RW, so do the conversion.
        IfFailGo(ConvertRO2RW(pIMD, IID_IMDInternalImport, (void**)ppIMD));
    }
    else
    {   // Already converted; give back same pointer.
        *ppIMD = pIMD;
        hr = S_FALSE;
    }

ErrExit:
    if (pENC)
        pENC->Release();
    return (hr);
} // STDAPI ConvertMDInternalImport()
    




//*****************************************************************************
// Constructor
//*****************************************************************************
MDInternalRW::MDInternalRW()
 :  m_cRefs(1),
    m_pStgdb(NULL),
    m_fOwnStgdb(false),
    m_pUnk(NULL),
    m_pIMetaDataHelper(NULL),
    m_pSemReadWrite(NULL),
    m_pUserUnk(NULL),
    m_fOwnSem(false)
{
} // MDInternalRW::MDInternalRW()



//*****************************************************************************
// Destructor
//*****************************************************************************
MDInternalRW::~MDInternalRW()
{
    LOCKWRITE();
    if (m_pIMetaDataHelper)
    {
        // The internal object is going away before the public object.
        // If the internal object owns the reader writer lock, transfer the ownership
        // to the public object and clear the cached internal interface from the public interface.
        
        m_pIMetaDataHelper->SetCachedInternalInterface(NULL);
        m_pIMetaDataHelper = NULL;
        m_fOwnSem = false;
        
    }

    UNLOCKWRITE();

    if (m_pSemReadWrite && m_fOwnSem)
        delete m_pSemReadWrite;

    if ( m_pStgdb && m_fOwnStgdb )
    {
        // we own the stgdb so we need to uninit and delete it.
        m_pStgdb->Uninit();
        delete m_pStgdb;
    }
    if ( m_pUserUnk )
        m_pUserUnk->Release();
    if ( m_pUnk )
        m_pUnk->Release();
}   // MDInternalRW::~MDInternalRW()


//*****************************************************************************
// Set or clear the cached public interfaces.
// NOTE:: Caller should take a Write lock on the reader writer lock. 
//*****************************************************************************
HRESULT MDInternalRW::SetCachedPublicInterface(IUnknown *pUnk)
{
    IMetaDataHelper *pHelper = NULL;
    HRESULT         hr = NOERROR;

    if (pUnk)
    {
        if ( m_pIMetaDataHelper )
        {
            // Internal object and public regmeta should be one to one mapping!!
            _ASSERTE(!"Bad state!");
        }

        IfFailRet( pUnk->QueryInterface(IID_IMetaDataHelper, (void **) &pHelper) );
        _ASSERTE(pHelper);

        m_pIMetaDataHelper = pHelper;        
        pHelper->Release();
    }
    else
    {
        // public object is going away before the internal object. If we don't own the 
        // reader writer lock, just take over the ownership.
        m_fOwnSem = true;
        m_pIMetaDataHelper = NULL;
    }
    return hr;
} // HRESULT MDInternalRW::SetCachedPublicInterface()


//*****************************************************************************
// Clear the cached public interfaces.
//*****************************************************************************
IUnknown *MDInternalRW::GetCachedPublicInterface(BOOL fWithLock)
{
    IUnknown        *pRet;
    if (fWithLock)
    {
        LOCKREAD();
        pRet = m_pIMetaDataHelper;
    }
    else
    {
        pRet = m_pIMetaDataHelper;
    }
    
    if (pRet)
        pRet->AddRef();
    return pRet;
} // IUnknown *MDInternalRW::GetCachedPublicInterface()


//*****************************************************************************
// Get the Reader-Writer lock
//*****************************************************************************
UTSemReadWrite *MDInternalRW::GetReaderWriterLock()
{
    return getReaderWriterLock();
} // UTSemReadWrite *MDInternalRW::GetReaderWriterLock()

//*****************************************************************************
// IUnknown
//*****************************************************************************
ULONG MDInternalRW::AddRef()
{
    return (InterlockedIncrement((long *) &m_cRefs));
} // ULONG MDInternalRW::AddRef()

ULONG MDInternalRW::Release()
{
    ULONG   cRef;

    cRef = InterlockedDecrement((long *) &m_cRefs);
    if (!cRef)
    {
        LOG((LOGMD, "MDInternalRW(0x%08x)::destruction\n", this));
        delete this;
    }
    return (cRef);
} // ULONG MDInternalRW::Release()

HRESULT MDInternalRW::QueryInterface(REFIID riid, void **ppUnk)
{
    *ppUnk = 0;

    if (riid == IID_IUnknown)
        *ppUnk = (IUnknown *) (IMDInternalImport *) this;

    else if (riid == IID_IMDInternalImport)
        *ppUnk = (IMDInternalImport *) this;

    else if (riid == IID_IMDInternalImportENC)
        *ppUnk = (IMDInternalImportENC *) this;

    else
        return (E_NOINTERFACE);
    AddRef();
    return (S_OK);
} // HRESULT MDInternalRW::QueryInterface()


//*****************************************************************************
// Initialize 
//*****************************************************************************
HRESULT MDInternalRW::Init(
    LPVOID      pData,                  // points to meta data section in memory
    ULONG       cbData,                 // count of bytes in pData
    int         bReadOnly)              // Is it open for read only?
{
    CLiteWeightStgdbRW *pStgdb = NULL;
    HRESULT     hr = NOERROR;
    OptionValue optVal = { MDDupAll, MDRefToDefDefault, MDNotifyDefault, MDUpdateFull, MDErrorOutOfOrderDefault, MDThreadSafetyOn };

    pStgdb = new CLiteWeightStgdbRW;    
    IfNullGo( pStgdb );

    m_pSemReadWrite = new UTSemReadWrite;
    IfNullGo( m_pSemReadWrite);
    m_fOwnSem = true;

    IfFailGo( pStgdb->InitOnMem(cbData, (BYTE*)pData, bReadOnly) );
    pStgdb->m_MiniMd.SetOption(&optVal);
    m_tdModule = COR_GLOBAL_PARENT_TOKEN;
    m_fOwnStgdb = true;
    m_pStgdb = pStgdb;

ErrExit:
    // clean up upon errors
    if (FAILED(hr) && pStgdb != NULL)
    {
        delete pStgdb;
    }
    return hr;
} // HRESULT MDInternalRW::Init()



//*****************************************************************************
// Initialize with an existing RegMeta. 
//*****************************************************************************
HRESULT MDInternalRW::InitWithStgdb(
    IUnknown        *pUnk,              // The IUnknow that owns the life time for the existing stgdb
    CLiteWeightStgdbRW *pStgdb)         // existing light weight stgdb
{
    // m_fOwnSem should be false because this is the case where we create the internal interface given a public
    // interface.

    m_tdModule = COR_GLOBAL_PARENT_TOKEN;
    m_fOwnStgdb = false;
    m_pStgdb = pStgdb;

    // remember the owner of the light weight stgdb
    // AddRef it to ensure the lifetime
    //
    m_pUnk = pUnk;
    m_pUnk->AddRef();
    return NOERROR;
} // HRESULT MDInternalRW::InitWithStgdb()


//*****************************************************************************
// Initialize with an existing RO format
//*****************************************************************************
HRESULT MDInternalRW::InitWithRO(
    MDInternalRO *pRO, 
    int         bReadOnly)
{
    CLiteWeightStgdbRW *pStgdb = NULL;
    HRESULT     hr = NOERROR;
    OptionValue optVal = { MDDupAll, MDRefToDefDefault, MDNotifyDefault, MDUpdateFull, MDErrorOutOfOrderDefault, MDThreadSafetyOn };

    pStgdb = new CLiteWeightStgdbRW;
    IfNullGo( pStgdb );

    m_pSemReadWrite = new UTSemReadWrite;
    IfNullGo( m_pSemReadWrite);
    m_fOwnSem = true;

    IfFailGo( pStgdb->m_MiniMd.InitOnRO(&pRO->m_LiteWeightStgdb.m_MiniMd, bReadOnly) );
    pStgdb->m_MiniMd.SetOption(&optVal);
    m_tdModule = COR_GLOBAL_PARENT_TOKEN;
    m_fOwnStgdb = true;
    m_pStgdb = pStgdb;

ErrExit:
    // clean up upon errors
    if (FAILED(hr) && pStgdb != NULL)
    {
        delete pStgdb;
    }
    return hr;
} // HRESULT MDInternalRW::InitWithRO()


//*****************************************************************************
// Given a scope, determine whether imported from a typelib.
//*****************************************************************************
HRESULT MDInternalRW::TranslateSigWithScope(
    IMDInternalImport *pAssemImport,    // [IN] import assembly scope.
    const void  *pbHashValue,           // [IN] hash value for the import assembly.
    ULONG       cbHashValue,            // [IN] count of bytes in the hash value.
    PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
    ULONG       cbSigBlob,              // [IN] count of bytes of signature
    IMetaDataAssemblyEmit *pAssemEmit,  // [IN] assembly emit scope.
    IMetaDataEmit *emit,                // [IN] emit interface
    CQuickBytes *pqkSigEmit,            // [OUT] buffer to hold translated signature
    ULONG       *pcbSig)                // [OUT] count of bytes in the translated signature
{
    HRESULT     hr = NOERROR;
    ULONG       cbEmit;
    IMetaModelCommon *pCommon = GetMetaModelCommon();
    RegMeta     *pEmitRM = static_cast<RegMeta*>(emit);
    RegMeta     *pAssemEmitRM = static_cast<RegMeta*>(pAssemEmit);

    IfFailGo( TranslateSigHelper(                   // S_OK or error.
            pAssemEmitRM ? &pAssemEmitRM->m_pStgdb->m_MiniMd : 0, // The assembly emit scope.
            &pEmitRM->m_pStgdb->m_MiniMd,           // The emit scope.
            pAssemImport ? pAssemImport->GetMetaModelCommon() : 0, // Assembly scope where the signature is from.
            pbHashValue,                            // Hash value for the import scope.
            cbHashValue,                            // Size in bytes.
            pCommon,                                // The scope where signature is from.
            pbSigBlob,                              // signature from the imported scope
            NULL,                                   // Internal OID mapping structure.
            pqkSigEmit,                             // [OUT] translated signature
            0,                                      // start from first byte of the signature
            0,                                      // don't care how many bytes consumed
            &cbEmit));                              // [OUT] total number of bytes write to pqkSigEmit
    *pcbSig = cbEmit;
ErrExit:    
    return hr;
} // HRESULT MDInternalRW::TranslateSigWithScope()


//*****************************************************************************
// Given a scope, return the number of tokens in a given table 
//*****************************************************************************
ULONG MDInternalRW::GetCountWithTokenKind(     // return hresult
    DWORD       tkKind)                 // [IN] pass in the kind of token. 
{
    ULONG       ulCount = 0;    
    LOCKREAD();

    switch (tkKind)
    {
    case mdtTypeDef: 
        ulCount = m_pStgdb->m_MiniMd.getCountTypeDefs() - 1;
        break;
    case mdtTypeRef: 
        ulCount = m_pStgdb->m_MiniMd.getCountTypeRefs();
        break;
    case mdtMethodDef:
        ulCount = m_pStgdb->m_MiniMd.getCountMethods();
        break;
    case mdtFieldDef:
        ulCount = m_pStgdb->m_MiniMd.getCountFields();
        break;
    case mdtMemberRef:
        ulCount = m_pStgdb->m_MiniMd.getCountMemberRefs();
        break;
    case mdtInterfaceImpl:
        ulCount = m_pStgdb->m_MiniMd.getCountInterfaceImpls();
        break;
    case mdtParamDef:
        ulCount = m_pStgdb->m_MiniMd.getCountParams();
        break;
    case mdtFile:
        ulCount = m_pStgdb->m_MiniMd.getCountFiles();
        break;
    case mdtAssemblyRef:
        ulCount = m_pStgdb->m_MiniMd.getCountAssemblyRefs();
        break;
    case mdtAssembly:
        ulCount = m_pStgdb->m_MiniMd.getCountAssemblys();
        break;
    case mdtCustomAttribute:
        ulCount = m_pStgdb->m_MiniMd.getCountCustomAttributes();
        break;
    case mdtModule:
        ulCount = m_pStgdb->m_MiniMd.getCountModules();
        break;
    case mdtPermission:
        ulCount = m_pStgdb->m_MiniMd.getCountDeclSecuritys();
        break;
    case mdtSignature:
        ulCount = m_pStgdb->m_MiniMd.getCountStandAloneSigs();
        break;
    case mdtEvent:
        ulCount = m_pStgdb->m_MiniMd.getCountEvents();
        break;
    case mdtProperty:
        ulCount = m_pStgdb->m_MiniMd.getCountPropertys();
        break;
    case mdtModuleRef:
        ulCount = m_pStgdb->m_MiniMd.getCountModuleRefs();
        break;
    case mdtTypeSpec:
        ulCount = m_pStgdb->m_MiniMd.getCountTypeSpecs();
        break;
    case mdtExportedType:
        ulCount = m_pStgdb->m_MiniMd.getCountExportedTypes();
        break;
    case mdtManifestResource:
        ulCount = m_pStgdb->m_MiniMd.getCountManifestResources();
        break;
    default:
#ifdef _DEBUG
        if(REGUTIL::GetConfigDWORD(L"AssertOnBadImageFormat", 1))
		    _ASSERTE(!"Invalid Blob Offset");
#endif     
		ulCount = 0;
		break;
    }
    return ulCount;
} // ULONG MDInternalRW::GetCountWithTokenKind()



//*******************************************************************************
// Enumerator helpers
//*******************************************************************************   


//*****************************************************************************
// enumerator init for typedef
//*****************************************************************************
HRESULT MDInternalRW::EnumTypeDefInit( // return hresult
    HENUMInternal *phEnum)              // [OUT] buffer to fill for enumerator data
{
    HRESULT     hr = NOERROR;
    LOCKREAD();

    _ASSERTE(phEnum);

    memset(phEnum, 0, sizeof(HENUMInternal));
    phEnum->m_tkKind = mdtTypeDef;

    if ( m_pStgdb->m_MiniMd.HasDelete() )
    {
        HENUMInternal::InitDynamicArrayEnum(phEnum);

        phEnum->m_tkKind = mdtTypeDef;
        for (ULONG index = 2; index <= m_pStgdb->m_MiniMd.getCountTypeDefs(); index ++ )
        {
            TypeDefRec       *pTypeDefRec = m_pStgdb->m_MiniMd.getTypeDef( index );
            if (IsDeletedName(m_pStgdb->m_MiniMd.getNameOfTypeDef(pTypeDefRec)) )
            {   
                continue;
            }
            IfFailGo( HENUMInternal::AddElementToEnum(
                phEnum, 
                TokenFromRid(index, mdtTypeDef) ) );
        }
    }
    else
    {
        phEnum->m_EnumType = MDSimpleEnum;
        phEnum->m_ulCount = m_pStgdb->m_MiniMd.getCountTypeDefs();

        // Skip over the global model typedef
        //
        // phEnum->m_ulCur : the current rid that is not yet enumerated
        // phEnum->m_ulStart : the first rid that will be returned by enumerator
        // phEnum->m_ulEnd : the last rid that will be returned by enumerator
        phEnum->m_ulStart = phEnum->m_ulCur = 2;
        phEnum->m_ulEnd = phEnum->m_ulCount + 1;
        phEnum->m_ulCount --;
    }
ErrExit:
    
    return hr;
} // HRESULT MDInternalRW::EnumTypeDefInit()


//*****************************************************************************
// get the number of typedef in a scope
//*****************************************************************************
ULONG MDInternalRW::EnumTypeDefGetCount(
    HENUMInternal *phEnum)              // [IN] the enumerator to retrieve information  
{
    _ASSERTE(phEnum->m_tkKind == mdtTypeDef);
    return phEnum->m_ulCount;
} // ULONG MDInternalRW::EnumTypeDefGetCount()


//*****************************************************************************
// enumerator for typedef
//*****************************************************************************
bool MDInternalRW::EnumTypeDefNext( // return hresult
    HENUMInternal *phEnum,              // [IN] input enum
    mdTypeDef   *ptd)                   // [OUT] return token
{
    return EnumNext(
        phEnum,             
        ptd);
} // bool MDInternalRW::EnumTypeDefNext()


//*****************************************
// Reset the enumerator to the beginning.
//***************************************** 
void MDInternalRW::EnumTypeDefReset(
    HENUMInternal *phEnum)              // [IN] the enumerator to be reset  
{
    EnumReset(phEnum);
} // void MDInternalRW::EnumTypeDefReset()


//*****************************************
// Close the enumerator. Only for read/write mode that we need to close the cursor.
// Hopefully with readonly mode, it will be a no-op
//***************************************** 
void MDInternalRW::EnumTypeDefClose(
    HENUMInternal *phEnum)              // [IN] the enumerator to be closed
{
    EnumClose(phEnum);
} // void MDInternalRW::EnumTypeDefClose()


//*****************************************************************************
// enumerator init for MethodImpl
//*****************************************************************************
HRESULT MDInternalRW::EnumMethodImplInit( // return hresult
    mdTypeDef       td,                   // [IN] TypeDef over which to scope the enumeration.
    HENUMInternal   *phEnumBody,          // [OUT] buffer to fill for enumerator data for MethodBody tokens.
    HENUMInternal   *phEnumDecl)          // [OUT] buffer to fill for enumerator data for MethodDecl tokens.
{
    HRESULT     hr = NOERROR;
    int         ridCur;
    mdToken     tkMethodBody;
    mdToken     tkMethodDecl;
    MethodImplRec *pRec;
    HENUMInternal hEnum;
    LOCKREAD();

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_MethodImpl) )        
    {
        // MethodImpl table is not sorted. 
        CONVERT_READ_TO_WRITE_LOCK();
    }

    _ASSERTE(TypeFromToken(td) == mdtTypeDef && !IsNilToken(td));
    _ASSERTE(phEnumBody && phEnumDecl);

    memset(phEnumBody, 0, sizeof(HENUMInternal));
    memset(phEnumDecl, 0, sizeof(HENUMInternal));
    memset(&hEnum, 0, sizeof(HENUMInternal));

    HENUMInternal::InitDynamicArrayEnum(phEnumBody);
    HENUMInternal::InitDynamicArrayEnum(phEnumDecl);

    phEnumBody->m_tkKind = (TBL_MethodImpl << 24);
    phEnumDecl->m_tkKind = (TBL_MethodImpl << 24);

    // Get the range of rids.
    IfFailGo( m_pStgdb->m_MiniMd.FindMethodImplHelper(td, &hEnum) );

    while (HENUMInternal::EnumNext(&hEnum, (mdToken *)&ridCur))
    {
        // Get the MethodBody and MethodDeclaration tokens for the current
        // MethodImpl record.
        pRec = m_pStgdb->m_MiniMd.getMethodImpl(ridCur);
        tkMethodBody = m_pStgdb->m_MiniMd.getMethodBodyOfMethodImpl(pRec);
        tkMethodDecl = m_pStgdb->m_MiniMd.getMethodDeclarationOfMethodImpl(pRec);

        // Add the Method body/declaration pairs to the Enum
        IfFailGo( HENUMInternal::AddElementToEnum(phEnumBody, tkMethodBody ) );
        IfFailGo( HENUMInternal::AddElementToEnum(phEnumDecl, tkMethodDecl ) );
    }
ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
    return hr;
} // HRESULT MDInternalRW::EnumMethodImplInit()

//*****************************************************************************
// get the number of MethodImpls in a scope
//*****************************************************************************
ULONG MDInternalRW::EnumMethodImplGetCount(
    HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.  
    HENUMInternal   *phEnumDecl)        // [IN] MethodDecl enumerator.
{
    _ASSERTE((phEnumBody->m_tkKind >> 24) == TBL_MethodImpl  &&
             (phEnumDecl->m_tkKind >> 24) == TBL_MethodImpl);
    _ASSERTE(phEnumBody->m_EnumType == MDDynamicArrayEnum &&
             phEnumDecl->m_EnumType == MDDynamicArrayEnum);
    _ASSERTE(phEnumBody->m_ulCount == phEnumDecl->m_ulCount);

    return phEnumBody->m_ulCount;
} // ULONG MDInternalRW::EnumMethodImplGetCount()


//*****************************************************************************
// enumerator for MethodImpl.
//*****************************************************************************
bool MDInternalRW::EnumMethodImplNext(  // return hresult
    HENUMInternal   *phEnumBody,        // [IN] input enum for MethodBody
    HENUMInternal   *phEnumDecl,        // [IN] input enum for MethodDecl
    mdToken         *ptkBody,           // [OUT] return token for MethodBody
    mdToken         *ptkDecl)           // [OUT] return token for MethodDecl
{
    _ASSERTE((phEnumBody->m_tkKind >> 24) == TBL_MethodImpl &&
             (phEnumDecl->m_tkKind >> 24) == TBL_MethodImpl);
    _ASSERTE(phEnumBody->m_EnumType == MDDynamicArrayEnum &&
             phEnumDecl->m_EnumType == MDDynamicArrayEnum);
    _ASSERTE(phEnumBody->m_ulCount == phEnumDecl->m_ulCount);
    _ASSERTE(ptkBody && ptkDecl);

    EnumNext(phEnumBody, ptkBody);
    return EnumNext(phEnumDecl, ptkDecl);
} // bool MDInternalRW::EnumMethodImplNext()


//*****************************************
// Reset the enumerator to the beginning.
//***************************************** 
void MDInternalRW::EnumMethodImplReset(
    HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.
    HENUMInternal   *phEnumDecl)        // [IN] MethodDecl enumerator.
{
    _ASSERTE((phEnumBody->m_tkKind >> 24) == TBL_MethodImpl &&
             (phEnumDecl->m_tkKind >> 24) == TBL_MethodImpl);
    _ASSERTE(phEnumBody->m_EnumType == MDDynamicArrayEnum &&
             phEnumDecl->m_EnumType == MDDynamicArrayEnum);
    _ASSERTE(phEnumBody->m_ulCount == phEnumDecl->m_ulCount);

    EnumReset(phEnumBody);
    EnumReset(phEnumDecl);
} // void MDInternalRW::EnumMethodImplReset()


//*****************************************
// Close the enumerator.
//***************************************** 
void MDInternalRW::EnumMethodImplClose(
    HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.
    HENUMInternal   *phEnumDecl)        // [IN] MethodDecl enumerator.
{
    _ASSERTE((phEnumBody->m_tkKind >> 24) == TBL_MethodImpl &&
             (phEnumDecl->m_tkKind >> 24) == TBL_MethodImpl);
    _ASSERTE(phEnumBody->m_EnumType == MDDynamicArrayEnum &&
             phEnumDecl->m_EnumType == MDDynamicArrayEnum);
    _ASSERTE(phEnumBody->m_ulCount == phEnumDecl->m_ulCount);

    EnumClose(phEnumBody);
    EnumClose(phEnumDecl);
} // void MDInternalRW::EnumMethodImplClose()

//******************************************************************************
// enumerator for global functions
//******************************************************************************
HRESULT MDInternalRW::EnumGlobalFunctionsInit(  // return hresult
    HENUMInternal   *phEnum)            // [OUT] buffer to fill for enumerator data
{
    return EnumInit(mdtMethodDef, m_tdModule, phEnum);
} // HRESULT MDInternalRW::EnumGlobalFunctionsInit()


//******************************************************************************
// enumerator for global fields
//******************************************************************************
HRESULT MDInternalRW::EnumGlobalFieldsInit( // return hresult
    HENUMInternal   *phEnum)            // [OUT] buffer to fill for enumerator data
{
    return EnumInit(mdtFieldDef, m_tdModule, phEnum);
} // HRESULT MDInternalRW::EnumGlobalFieldsInit()


//*****************************************
// Enumerator initializer
//***************************************** 
HRESULT MDInternalRW::EnumInit(     // return S_FALSE if record not found
    DWORD       tkKind,                 // [IN] which table to work on
    mdToken     tkParent,               // [IN] token to scope the search
    HENUMInternal *phEnum)              // [OUT] the enumerator to fill 
{
    HRESULT     hr = S_OK;
    ULONG       ulStart, ulEnd;
    ULONG       index;
    LOCKREAD();

    // Vars for query.
    _ASSERTE(phEnum);
    memset(phEnum, 0, sizeof(HENUMInternal));

    // cache the tkKind and the scope
    phEnum->m_tkKind = TypeFromToken(tkKind);

    TypeDefRec  *pRec;

    phEnum->m_EnumType = MDSimpleEnum;

    switch (TypeFromToken(tkKind))
    {
    case mdtFieldDef:
        pRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(tkParent));
        ulStart = m_pStgdb->m_MiniMd.getFieldListOfTypeDef(pRec);
        ulEnd = m_pStgdb->m_MiniMd.getEndFieldListOfTypeDef(pRec);
        if ( m_pStgdb->m_MiniMd.HasDelete() )
        {
            HENUMInternal::InitDynamicArrayEnum(phEnum);
            for (index = ulStart; index < ulEnd; index ++ )
            {
                FieldRec       *pFieldRec = m_pStgdb->m_MiniMd.getField(m_pStgdb->m_MiniMd.GetFieldRid(index));
                if (IsFdRTSpecialName(pFieldRec->m_Flags) && IsDeletedName(m_pStgdb->m_MiniMd.getNameOfField(pFieldRec)) )
                {   
                    continue;
                }
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    TokenFromRid(m_pStgdb->m_MiniMd.GetFieldRid(index), mdtFieldDef) ) );
            }
        }
        else if (m_pStgdb->m_MiniMd.HasIndirectTable(TBL_Field))
        {
            HENUMInternal::InitDynamicArrayEnum(phEnum);
            for (index = ulStart; index < ulEnd; index ++ )
            {
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    TokenFromRid(m_pStgdb->m_MiniMd.GetFieldRid(index), mdtFieldDef) ) );
            }
        }
        else
        {
            HENUMInternal::InitSimpleEnum( mdtFieldDef, ulStart, ulEnd, phEnum);
        }
        break;

    case mdtMethodDef:      
        pRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(tkParent));
        ulStart = m_pStgdb->m_MiniMd.getMethodListOfTypeDef(pRec);
        ulEnd = m_pStgdb->m_MiniMd.getEndMethodListOfTypeDef(pRec);
        if ( m_pStgdb->m_MiniMd.HasDelete() )
        {
            HENUMInternal::InitDynamicArrayEnum(phEnum);
            for (index = ulStart; index < ulEnd; index ++ )
            {
                MethodRec       *pMethodRec = m_pStgdb->m_MiniMd.getMethod(m_pStgdb->m_MiniMd.GetMethodRid(index));
                if (IsMdRTSpecialName(pMethodRec->m_Flags) && IsDeletedName(m_pStgdb->m_MiniMd.getNameOfMethod(pMethodRec)) )
                {   
                    continue;
                }
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    TokenFromRid(m_pStgdb->m_MiniMd.GetMethodRid(index), mdtMethodDef) ) );
            }
        }
        else if (m_pStgdb->m_MiniMd.HasIndirectTable(TBL_Method))
        {
            HENUMInternal::InitDynamicArrayEnum(phEnum);
            for (index = ulStart; index < ulEnd; index ++ )
            {
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    TokenFromRid(m_pStgdb->m_MiniMd.GetMethodRid(index), mdtMethodDef) ) );
            }
        }
        else
        {
            HENUMInternal::InitSimpleEnum( mdtMethodDef, ulStart, ulEnd, phEnum);
        }
        break;

        break;
    
    case mdtInterfaceImpl:
        if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_InterfaceImpl) )        
        {
            // virtual sort table will be created!
            //
            CONVERT_READ_TO_WRITE_LOCK();
        }

        IfFailGo( m_pStgdb->m_MiniMd.GetInterfaceImplsForTypeDef(RidFromToken(tkParent), &ulStart, &ulEnd) );
        if ( m_pStgdb->m_MiniMd.IsSorted( TBL_InterfaceImpl ) )
        {
            // These are index to InterfaceImpl table directly
            HENUMInternal::InitSimpleEnum( mdtInterfaceImpl, ulStart, ulEnd, phEnum);
        }
        else
        {
            // These are index to VirtualSort table. Skip over one level direction.
            HENUMInternal::InitDynamicArrayEnum(phEnum);
            for (index = ulStart; index < ulEnd; index ++ )
            {
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    TokenFromRid(m_pStgdb->m_MiniMd.GetInterfaceImplRid(index), mdtInterfaceImpl) ) );
            }
        }
        break;

    case mdtProperty:
        RID         ridPropertyMap;
        PropertyMapRec *pPropertyMapRec;

        // get the starting/ending rid of properties of this typedef
        ridPropertyMap = m_pStgdb->m_MiniMd.FindPropertyMapFor(RidFromToken(tkParent));
        if (!InvalidRid(ridPropertyMap))
        {
            pPropertyMapRec = m_pStgdb->m_MiniMd.getPropertyMap(ridPropertyMap);
            ulStart = m_pStgdb->m_MiniMd.getPropertyListOfPropertyMap(pPropertyMapRec);
            ulEnd = m_pStgdb->m_MiniMd.getEndPropertyListOfPropertyMap(pPropertyMapRec);
            if ( m_pStgdb->m_MiniMd.HasDelete() )
            {
                HENUMInternal::InitDynamicArrayEnum(phEnum);
                for (index = ulStart; index < ulEnd; index ++ )
                {
                    PropertyRec       *pPropertyRec = m_pStgdb->m_MiniMd.getProperty(m_pStgdb->m_MiniMd.GetPropertyRid(index));
                    if (IsPrRTSpecialName(pPropertyRec->m_PropFlags) && IsDeletedName(m_pStgdb->m_MiniMd.getNameOfProperty(pPropertyRec)) )
                    {   
                        continue;
                    }
                    IfFailGo( HENUMInternal::AddElementToEnum(
                        phEnum, 
                        TokenFromRid(m_pStgdb->m_MiniMd.GetPropertyRid(index), mdtProperty) ) );
                }
            }
            else if (m_pStgdb->m_MiniMd.HasIndirectTable(TBL_Property))
            {
                HENUMInternal::InitDynamicArrayEnum(phEnum);
                for (index = ulStart; index < ulEnd; index ++ )
                {
                    IfFailGo( HENUMInternal::AddElementToEnum(
                        phEnum, 
                        TokenFromRid(m_pStgdb->m_MiniMd.GetPropertyRid(index), mdtProperty) ) );
                }
            }
            else
            {
                HENUMInternal::InitSimpleEnum( mdtProperty, ulStart, ulEnd, phEnum);
            }
        }
        break;

    case mdtEvent:
        RID         ridEventMap;
        EventMapRec *pEventMapRec;

        // get the starting/ending rid of events of this typedef
        ridEventMap = m_pStgdb->m_MiniMd.FindEventMapFor(RidFromToken(tkParent));
        if (!InvalidRid(ridEventMap))
        {
            pEventMapRec = m_pStgdb->m_MiniMd.getEventMap(ridEventMap);
            ulStart = m_pStgdb->m_MiniMd.getEventListOfEventMap(pEventMapRec);
            ulEnd = m_pStgdb->m_MiniMd.getEndEventListOfEventMap(pEventMapRec);
            if ( m_pStgdb->m_MiniMd.HasDelete() )
            {
                HENUMInternal::InitDynamicArrayEnum(phEnum);
                for (index = ulStart; index < ulEnd; index ++ )
                {
                    EventRec       *pEventRec = m_pStgdb->m_MiniMd.getEvent(m_pStgdb->m_MiniMd.GetEventRid(index));
                    if (IsEvRTSpecialName(pEventRec->m_EventFlags) && IsDeletedName(m_pStgdb->m_MiniMd.getNameOfEvent(pEventRec)) )
                    {   
                        continue;
                    }
                    IfFailGo( HENUMInternal::AddElementToEnum(
                        phEnum, 
                        TokenFromRid(m_pStgdb->m_MiniMd.GetEventRid(index), mdtEvent) ) );
                }
            }
            else if (m_pStgdb->m_MiniMd.HasIndirectTable(TBL_Event))
            {
                HENUMInternal::InitDynamicArrayEnum(phEnum);
                for (index = ulStart; index < ulEnd; index ++ )
                {
                    IfFailGo( HENUMInternal::AddElementToEnum(
                        phEnum, 
                        TokenFromRid(m_pStgdb->m_MiniMd.GetEventRid(index), mdtEvent) ) );
                }
            }
            else
            {
                HENUMInternal::InitSimpleEnum( mdtEvent, ulStart, ulEnd, phEnum);
            }
        }
        break;

    case mdtParamDef:
        _ASSERTE(TypeFromToken(tkParent) == mdtMethodDef);

        MethodRec *pMethodRec;
        pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(tkParent));

        // figure out the start rid and end rid of the parameter list of this methoddef
        ulStart = m_pStgdb->m_MiniMd.getParamListOfMethod(pMethodRec);
        ulEnd = m_pStgdb->m_MiniMd.getEndParamListOfMethod(pMethodRec);
        if (m_pStgdb->m_MiniMd.HasIndirectTable(TBL_Param))
        {
            HENUMInternal::InitDynamicArrayEnum(phEnum);
            for (index = ulStart; index < ulEnd; index ++ )
            {
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    TokenFromRid(m_pStgdb->m_MiniMd.GetParamRid(index), mdtParamDef) ) );
            }
        }
        else
        {
            HENUMInternal::InitSimpleEnum( mdtParamDef, ulStart, ulEnd, phEnum);
        }
        break;
    case mdtCustomAttribute:
        if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_CustomAttribute) )        
        {
            // CA's map table table will be sorted!
            //
            CONVERT_READ_TO_WRITE_LOCK();
        }

        IfFailGo( m_pStgdb->m_MiniMd.GetCustomAttributeForToken(tkParent, &ulStart, &ulEnd) );
        if ( m_pStgdb->m_MiniMd.IsSorted( TBL_CustomAttribute ) )
        {
            // These are index to CustomAttribute table directly
            HENUMInternal::InitSimpleEnum( mdtCustomAttribute, ulStart, ulEnd, phEnum);
        }
        else
        {
            // These are index to VirtualSort table. Skip over one level direction.
            HENUMInternal::InitDynamicArrayEnum(phEnum);
            for (index = ulStart; index < ulEnd; index ++ )
            {
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    TokenFromRid(m_pStgdb->m_MiniMd.GetCustomAttributeRid(index), mdtCustomAttribute) ) );
            }
        }
        break;
    case mdtAssemblyRef:
        _ASSERTE(IsNilToken(tkParent));
        phEnum->m_ulStart = 1;
        phEnum->m_ulEnd = m_pStgdb->m_MiniMd.getCountAssemblyRefs() + 1;
        break;
    case mdtFile:
        _ASSERTE(IsNilToken(tkParent));
        phEnum->m_ulStart = 1;
        phEnum->m_ulEnd = m_pStgdb->m_MiniMd.getCountFiles() + 1;
        break;
    case mdtExportedType:
        _ASSERTE(IsNilToken(tkParent));
        if ( m_pStgdb->m_MiniMd.HasDelete() )
        {
            HENUMInternal::InitDynamicArrayEnum(phEnum);

            phEnum->m_tkKind = mdtExportedType;
            for (ULONG index = 1; index <= m_pStgdb->m_MiniMd.getCountExportedTypes(); index ++ )
            {
                ExportedTypeRec       *pExportedTypeRec = m_pStgdb->m_MiniMd.getExportedType( index );
                if (IsDeletedName(m_pStgdb->m_MiniMd.getTypeNameOfExportedType(pExportedTypeRec)) )
                {   
                    continue;
                }
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    TokenFromRid(index, mdtExportedType) ) );
            }
        }
        else
        {
            phEnum->m_ulStart = 1;
            phEnum->m_ulEnd = m_pStgdb->m_MiniMd.getCountExportedTypes() + 1;
        }
        break;
    case mdtManifestResource:
        _ASSERTE(IsNilToken(tkParent));
        phEnum->m_ulStart = 1;
        phEnum->m_ulEnd = m_pStgdb->m_MiniMd.getCountManifestResources() + 1;
        break;
    default:
        _ASSERTE(!"ENUM INIT not implemented for the uncompressed format!");
		IfFailGo(E_NOTIMPL);
        break;
    }
    phEnum->m_ulCount = phEnum->m_ulEnd - phEnum->m_ulStart;
    phEnum->m_ulCur = phEnum->m_ulStart;
ErrExit:
    // we are done
    
    return (hr);
} // HRESULT MDInternalRW::EnumInit()



//*****************************************
// Enumerator initializer
//***************************************** 
HRESULT MDInternalRW::EnumAllInit(      // return S_FALSE if record not found
    DWORD       tkKind,                 // [IN] which table to work on
    HENUMInternal *phEnum)              // [OUT] the enumerator to fill 
{
    HRESULT     hr = S_OK;
    LOCKREAD();

    // Vars for query.
    _ASSERTE(phEnum);
    memset(phEnum, 0, sizeof(HENUMInternal));

    // cache the tkKind and the scope
    phEnum->m_tkKind = TypeFromToken(tkKind);
    phEnum->m_EnumType = MDSimpleEnum;

    switch (TypeFromToken(tkKind))
    {
    case mdtTypeRef:
        phEnum->m_ulCount = m_pStgdb->m_MiniMd.getCountTypeRefs();
        break;

    case mdtMemberRef:      
        phEnum->m_ulCount = m_pStgdb->m_MiniMd.getCountMemberRefs();
        break;

    case mdtSignature:
        phEnum->m_ulCount = m_pStgdb->m_MiniMd.getCountStandAloneSigs();
        break;

    default:
        _ASSERTE(!"Bad token kind!");
        break;
    }
    phEnum->m_ulStart = phEnum->m_ulCur = 1;
    phEnum->m_ulEnd = phEnum->m_ulCount + 1;

    // we are done
    
    return (hr);
} // HRESULT MDInternalRW::EnumAllInit()


//*****************************************
// get the count
//***************************************** 
ULONG MDInternalRW::EnumGetCount(
    HENUMInternal *phEnum)              // [IN] the enumerator to retrieve information  
{
    _ASSERTE(phEnum);
    return phEnum->m_ulCount;
} // ULONG MDInternalRW::EnumGetCount()

//*****************************************
// Get next value contained in the enumerator
//***************************************** 
bool MDInternalRW::EnumNext(
    HENUMInternal *phEnum,              // [IN] the enumerator to retrieve information  
    mdToken     *ptk)                   // [OUT] token to scope the search
{
    _ASSERTE(phEnum && ptk);
    if (phEnum->m_ulCur >= phEnum->m_ulEnd)
        return false;

    if ( phEnum->m_EnumType == MDSimpleEnum )
    {
        *ptk = phEnum->m_ulCur | phEnum->m_tkKind;
        phEnum->m_ulCur++;
    }
    else 
    {
        TOKENLIST       *pdalist = (TOKENLIST *)&(phEnum->m_cursor);

        _ASSERTE( phEnum->m_EnumType == MDDynamicArrayEnum );
        *ptk = *( pdalist->Get(phEnum->m_ulCur++) );
    }
    return true;
} // bool MDInternalRW::EnumNext()


//*****************************************
// Reset the enumerator to the beginning.
//***************************************** 
void MDInternalRW::EnumReset(
    HENUMInternal *phEnum)              // [IN] the enumerator to be reset  
{
    _ASSERTE(phEnum);
    _ASSERTE( phEnum->m_EnumType == MDSimpleEnum || phEnum->m_EnumType == MDDynamicArrayEnum);

    // not using CRCURSOR 
    phEnum->m_ulCur = phEnum->m_ulStart;
} // void MDInternalRW::EnumReset()


//*****************************************
// Close the enumerator. Only for read/write mode that we need to close the cursor.
// Hopefully with readonly mode, it will be a no-op
//***************************************** 
void MDInternalRW::EnumClose(
    HENUMInternal *phEnum)              // [IN] the enumerator to be closed
{
    _ASSERTE( phEnum->m_EnumType == MDSimpleEnum || phEnum->m_EnumType == MDDynamicArrayEnum);
    HENUMInternal::ClearEnum(phEnum);
} // void MDInternalRW::EnumClose()


//*****************************************
// Enumerator initializer for PermissionSets
//***************************************** 
HRESULT MDInternalRW::EnumPermissionSetsInit(// return S_FALSE if record not found
    mdToken     tkParent,               // [IN] token to scope the search
    CorDeclSecurity Action,             // [IN] Action to scope the search
    HENUMInternal *phEnum)              // [OUT] the enumerator to fill 
{
    HRESULT     hr = NOERROR;
    DeclSecurityRec *pDecl;
    RID         ridCur;
    RID         ridEnd;
    LOCKREAD();


    _ASSERTE(phEnum);
    _ASSERTE(!IsNilToken(tkParent));

    phEnum->m_EnumType = MDSimpleEnum;

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_DeclSecurity) )        
    {
        // DeclSecurity lookup table will be created!
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }
    IfFailGo( m_pStgdb->m_MiniMd.GetDeclSecurityForToken(tkParent, &ridCur, &ridEnd) );
    if ( m_pStgdb->m_MiniMd.IsSorted( TBL_DeclSecurity ) )
    {
        // These are index to DeclSecurity table directly
        if (Action != dclActionNil)
        {
            for (; ridCur < ridEnd; ridCur++)
            {
                pDecl = m_pStgdb->m_MiniMd.getDeclSecurity(ridCur);
                if (Action == m_pStgdb->m_MiniMd.getActionOfDeclSecurity(pDecl))
                {
                    // found a match
                    HENUMInternal::InitSimpleEnum( mdtPermission, ridCur, ridCur+1, phEnum);
                    goto ErrExit;
                }
            }
            hr = CLDB_E_RECORD_NOTFOUND;
        }
        else
        {
            HENUMInternal::InitSimpleEnum( mdtPermission, ridCur, ridEnd, phEnum);
        }
    }
    else
    {
        // These are index to VirtualSort table. Skip over one level direction.
        if (Action != dclActionNil)
        {
            RID         ridActual;

            for (; ridCur < ridEnd; ridCur++)
            {
                ridActual = m_pStgdb->m_MiniMd.GetDeclSecurityRid(ridCur);
                pDecl = m_pStgdb->m_MiniMd.getDeclSecurity(ridActual);
                if (Action == m_pStgdb->m_MiniMd.getActionOfDeclSecurity(pDecl))
                {
                    // found a match
                    HENUMInternal::InitSimpleEnum( mdtPermission, ridActual, ridActual+1, phEnum);
                    goto ErrExit;
                }
            }
            hr = CLDB_E_RECORD_NOTFOUND;
        }
        else
        {
            HENUMInternal::InitDynamicArrayEnum(phEnum);
            for (; ridCur < ridEnd; ridCur++)
            {
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    TokenFromRid(m_pStgdb->m_MiniMd.GetDeclSecurityRid(ridCur), mdtPermission) ) );
            }
        }
    }
ErrExit:
    
    return (hr);
} // HRESULT MDInternalRW::EnumPermissionSetsInit()

//***************************************** 
// Enumerator initializer for CustomAttributes
//***************************************** 
HRESULT MDInternalRW::EnumCustomAttributeByNameInit(// return S_FALSE if record not found
    mdToken     tkParent,               // [IN] token to scope the search
    LPCSTR      szName,                 // [IN] CustomAttribute's name to scope the search
    HENUMInternal *phEnum)              // [OUT] the enumerator to fill 
{
    return m_pStgdb->m_MiniMd.CommonEnumCustomAttributeByName(tkParent, szName, false, phEnum);
}   // HRESULT MDInternalRW::EnumCustomAttributeByNameInit


//*****************************************
// Nagivator helper to navigate back to the parent token given a token.
// For example, given a memberdef token, it will return the containing typedef.
//
// the mapping is as following:
//  ---given child type---------parent type
//  mdMethodDef                 mdTypeDef
//  mdFieldDef                  mdTypeDef
//  mdInterfaceImpl             mdTypeDef
//  mdParam                     mdMethodDef
//  mdProperty                  mdTypeDef
//  mdEvent                     mdTypeDef
//
//***************************************** 
HRESULT MDInternalRW::GetParentToken(
    mdToken     tkChild,                // [IN] given child token
    mdToken     *ptkParent)             // [OUT] returning parent
{
    HRESULT     hr = NOERROR;
    LOCKREAD();

    _ASSERTE(ptkParent);

    switch (TypeFromToken(tkChild))
    {
    case mdtMethodDef:
        if ( !m_pStgdb->m_MiniMd.IsParentTableOfMethodValid() )
        {
            // we need to take a write lock since parent table for Method might be rebuilt!
            CONVERT_READ_TO_WRITE_LOCK();
        }
        IfFailGo( m_pStgdb->m_MiniMd.FindParentOfMethodHelper(RidFromToken(tkChild), ptkParent ) );
        RidToToken(*ptkParent, mdtTypeDef);
        break;

    case mdtFieldDef:
        if ( !m_pStgdb->m_MiniMd.IsParentTableOfMethodValid() )
        {
            // we need to take a write lock since parent table for Method might be rebuilt!
            CONVERT_READ_TO_WRITE_LOCK();
        }
        IfFailGo( m_pStgdb->m_MiniMd.FindParentOfFieldHelper(RidFromToken(tkChild), ptkParent ) );
        RidToToken(*ptkParent, mdtTypeDef);
        break;

    case mdtParamDef:
        if ( !m_pStgdb->m_MiniMd.IsParentTableOfMethodValid() )
        {
            // we need to take a write lock since parent table for Method might be rebuilt!
            CONVERT_READ_TO_WRITE_LOCK();
        }
        *ptkParent = m_pStgdb->m_MiniMd.FindParentOfParam( RidFromToken(tkChild) );
        RidToToken(*ptkParent, mdtParamDef);
        break;

    case mdtMemberRef:
        {
            MemberRefRec    *pRec;
            pRec = m_pStgdb->m_MiniMd.getMemberRef(RidFromToken(tkChild));
            *ptkParent = m_pStgdb->m_MiniMd.getClassOfMemberRef(pRec);
            break;
        }

    case mdtCustomAttribute:
        {
            CustomAttributeRec  *pRec;
            pRec = m_pStgdb->m_MiniMd.getCustomAttribute(RidFromToken(tkChild));
            *ptkParent = m_pStgdb->m_MiniMd.getParentOfCustomAttribute(pRec);
            break;
        }
    case mdtEvent:
    case mdtProperty:
    default:
        _ASSERTE(!"NYI: for compressed format!");
        break;
    }
ErrExit:
    return hr;
} // HRESULT MDInternalRW::GetParentToken()

//*****************************************************************************
// Get information about a CustomAttribute.
//*****************************************************************************
void MDInternalRW::GetCustomAttributeProps( // S_OK or error.
    mdCustomAttribute at,                   // The attribute.
    mdToken     *pTkType)               // Put attribute type here.
{
    // Getting the custom value prop with a token, no need to lock!

    _ASSERTE(TypeFromToken(at) == mdtCustomAttribute);

    // Do a linear search on compressed version as we do not want to
    // depends on ICR.
    //
    CustomAttributeRec *pCustomAttributeRec;

    pCustomAttributeRec = m_pStgdb->m_MiniMd.getCustomAttribute(RidFromToken(at));
    *pTkType = m_pStgdb->m_MiniMd.getTypeOfCustomAttribute(pCustomAttributeRec);
} // void MDInternalRW::GetCustomAttributeProps()


//*****************************************************************************
// return custom value
//*****************************************************************************
void MDInternalRW::GetCustomAttributeAsBlob(
    mdCustomAttribute cv,               // [IN] given custom attribute token
    void const  **ppBlob,               // [OUT] return the pointer to internal blob
    ULONG       *pcbSize)               // [OUT] return the size of the blob
{
    // Getting the custom value prop with a token, no need to lock!

    _ASSERTE(ppBlob && pcbSize && TypeFromToken(cv) == mdtCustomAttribute);

    CustomAttributeRec *pCustomAttributeRec;

    pCustomAttributeRec = m_pStgdb->m_MiniMd.getCustomAttribute(RidFromToken(cv));

    *ppBlob = m_pStgdb->m_MiniMd.getValueOfCustomAttribute(pCustomAttributeRec, pcbSize);
} // void MDInternalRW::GetCustomAttributeAsBlob()

//*****************************************************************************
// Helper function to lookup and retrieve a CustomAttribute.
//*****************************************************************************
HRESULT MDInternalRW::GetCustomAttributeByName( // S_OK or error.
    mdToken     tkObj,                  // [IN] Object with Custom Attribute.
    LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
    const void  **ppData,               // [OUT] Put pointer to data here.
    ULONG       *pcbData)               // [OUT] Put size of data here.
{
    LOCKREAD();
    return m_pStgdb->m_MiniMd.CommonGetCustomAttributeByName(tkObj, szName, ppData, pcbData);
} // HRESULT MDInternalRW::GetCustomAttributeByName()

//*****************************************************************************
// return scope properties
//*****************************************************************************
void MDInternalRW::GetScopeProps(
    LPCSTR      *pszName,               // [OUT] scope name
    GUID        *pmvid)                 // [OUT] version id
{
    LOCKREAD();
    _ASSERTE(pszName || pmvid);

    ModuleRec *pModuleRec;

    // there is only one module record
    pModuleRec = m_pStgdb->m_MiniMd.getModule(1);

    if (pmvid)
        *pmvid = *(m_pStgdb->m_MiniMd.getMvidOfModule(pModuleRec));
    if (pszName)
        *pszName = m_pStgdb->m_MiniMd.getNameOfModule(pModuleRec);
    
} // void MDInternalRW::GetScopeProps()


//*****************************************************************************
// Find a given member in a TypeDef (typically a class).
//*****************************************************************************
HRESULT MDInternalRW::FindMethodDef(// S_OK or error.
    mdTypeDef   classdef,               // The owning class of the member.
    LPCSTR      szName,                 // Name of the member in utf8.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
    mdMethodDef *pmethoddef)            // Put MemberDef token here.
{
    LOCKREAD();

    _ASSERTE(szName && pmethoddef);

    return ImportHelper::FindMethod(&(m_pStgdb->m_MiniMd),
                                    classdef,
                                    szName,
                                    pvSigBlob,
                                    cbSigBlob,
                                    pmethoddef);
}

//*****************************************************************************
// Find a given member in a TypeDef (typically a class).
//*****************************************************************************
HRESULT MDInternalRW::FindMethodDefUsingCompare(// S_OK or error.
    mdTypeDef   classdef,               // The owning class of the member.
    LPCSTR      szName,                 // Name of the member in utf8.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
    PSIGCOMPARE pSignatureCompare,      // [IN] Routine to compare signatures
    void*       pSignatureArgs,         // [IN] Additional info to supply the compare function
    mdMethodDef *pmethoddef)            // Put MemberDef token here.
{
    return E_NOTIMPL;
}

//*****************************************************************************
// Find a given param of a Method.
//*****************************************************************************
HRESULT MDInternalRW::FindParamOfMethod(// S_OK or error.
    mdMethodDef md,                     // [IN] The owning method of the param.
    ULONG       iSeq,                   // [IN] The sequence # of the param.
    mdParamDef  *pparamdef)             // [OUT] Put ParamDef token here.
{
    ParamRec    *pParamRec;
    RID         ridStart, ridEnd;
    HRESULT     hr = NOERROR;
    LOCKREAD();

    _ASSERTE(TypeFromToken(md) == mdtMethodDef && pparamdef);

    // get the methoddef record
    MethodRec *pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(md));

    // figure out the start rid and end rid of the parameter list of this methoddef
    ridStart = m_pStgdb->m_MiniMd.getParamListOfMethod(pMethodRec);
    ridEnd = m_pStgdb->m_MiniMd.getEndParamListOfMethod(pMethodRec);

    // loop through each param
    //
    for (; ridStart < ridEnd; ridStart++)
    {
        pParamRec = m_pStgdb->m_MiniMd.getParam( m_pStgdb->m_MiniMd.GetParamRid(ridStart) );
        if (iSeq == m_pStgdb->m_MiniMd.getSequenceOfParam( pParamRec) )
        {
            // parameter has the sequence number matches what we are looking for
            *pparamdef = TokenFromRid( m_pStgdb->m_MiniMd.GetParamRid(ridStart), mdtParamDef );
            goto ErrExit;
        }
    }
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    
    return hr;
} // HRESULT MDInternalRW::FindParamOfMethod()



//*****************************************************************************
// return a pointer which points to meta data's internal string 
// return the the type name in utf8
//*****************************************************************************
void MDInternalRW::GetNameOfTypeDef(// return hresult
    mdTypeDef   classdef,               // given typedef
    LPCSTR*     pszname,                // pointer to an internal UTF8 string
    LPCSTR*     psznamespace)           // pointer to the namespace.
{
    // No need to lock this method.

    _ASSERTE(pszname && psznamespace && TypeFromToken(classdef) == mdtTypeDef);

    TypeDefRec *pTypeDefRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(classdef));
    *pszname = m_pStgdb->m_MiniMd.getNameOfTypeDef(pTypeDefRec);
    *psznamespace = m_pStgdb->m_MiniMd.getNamespaceOfTypeDef(pTypeDefRec);

    _ASSERTE(!pszname || !*pszname || !strchr(*pszname, '/'));
    _ASSERTE(!psznamespace || !*psznamespace || !strchr(*psznamespace, '/'));
} // void MDInternalRW::GetNameOfTypeDef()


//*****************************************************************************
// return pDual indicating if the given TypeDef is marked as a Dual interface
//*****************************************************************************
HRESULT MDInternalRW::GetIsDualOfTypeDef(// return hresult
    mdTypeDef   classdef,               // given classdef
    ULONG       *pDual)                 // [OUT] return dual flag here.
{
    ULONG       iFace=0;                // Iface type.
    HRESULT     hr;                     // A result.

    // no need to lock at this level

    hr = GetIfaceTypeOfTypeDef(classdef, &iFace);
    if (hr == S_OK)
        *pDual = (iFace == ifDual);
    else
        *pDual = 1;

    return (hr);
} // HRESULT MDInternalRW::GetIsDualOfTypeDef()

HRESULT MDInternalRW::GetIfaceTypeOfTypeDef(
    mdTypeDef   classdef,               // [IN] given classdef.
    ULONG       *pIface)                // [OUT] 0=dual, 1=vtable, 2=dispinterface
{
    HRESULT     hr;                     // A result.
    const BYTE  *pVal;                  // The custom value.
    ULONG       cbVal;                  // Size of the custom value.
    ULONG       ItfType = DEFAULT_COM_INTERFACE_TYPE;    // Set the interface type to the default.

    // all of the public functions that it calls have proper locked

    // If the value is not present, the class is assumed dual.
    hr = GetCustomAttributeByName(classdef, INTEROP_INTERFACETYPE_TYPE, (const void**)&pVal, &cbVal);
    if (hr == S_OK)
    {
        _ASSERTE("The ComInterfaceType custom attribute is invalid" && cbVal);
        _ASSERTE("ComInterfaceType custom attribute does not have the right format" && (*pVal == 0x01) && (*(pVal + 1) == 0x00));
        ItfType = *(pVal + 2);
        if (ItfType >= ifLast)
            ItfType = DEFAULT_COM_INTERFACE_TYPE;
    }

    // Set the return value.
    *pIface = ItfType;

    return (hr);
} // HRESULT MDInternalRW::GetIfaceTypeOfTypeDef()

//*****************************************************************************
// Given a methoddef, return a pointer to methoddef's name
//*****************************************************************************
LPCSTR MDInternalRW::GetNameOfMethodDef(
    mdMethodDef     md)
{
    // name of method will not change. So no need to lock

    MethodRec *pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(md));
    return (m_pStgdb->m_MiniMd.getNameOfMethod(pMethodRec));
} // LPCSTR MDInternalRW::GetNameOfMethodDef()


//*****************************************************************************
// Given a methoddef, return a pointer to methoddef's signature and methoddef's name
//*****************************************************************************
LPCSTR MDInternalRW::GetNameAndSigOfMethodDef(
    mdMethodDef methoddef,              // [IN] given memberdef
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{

    // we don't need lock here because name and signature will not change

    // Output parameter should not be NULL
    _ASSERTE(ppvSigBlob && pcbSigBlob);
    _ASSERTE(TypeFromToken(methoddef) == mdtMethodDef);

    MethodRec *pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(methoddef));
    *ppvSigBlob = m_pStgdb->m_MiniMd.getSignatureOfMethod(pMethodRec, pcbSigBlob);

    return GetNameOfMethodDef(methoddef);
} // LPCSTR MDInternalRW::GetNameAndSigOfMethodDef()


//*****************************************************************************
// Given a FieldDef, return a pointer to FieldDef's name in UTF8
//*****************************************************************************
LPCSTR MDInternalRW::GetNameOfFieldDef(// return hresult
    mdFieldDef  fd)                     // given field 
{
    // we don't need lock here because name of field will not change

    FieldRec *pFieldRec = m_pStgdb->m_MiniMd.getField(RidFromToken(fd));
    return m_pStgdb->m_MiniMd.getNameOfField(pFieldRec);
} // LPCSTR MDInternalRW::GetNameOfFieldDef()


//*****************************************************************************
// Given a classdef, return a pointer to classdef's name in UTF8
//*****************************************************************************
void MDInternalRW::GetNameOfTypeRef(  // return TypeDef's name
    mdTypeRef   classref,               // [IN] given typeref
    LPCSTR      *psznamespace,          // [OUT] return typeref name
    LPCSTR      *pszname)               // [OUT] return typeref namespace
{
    _ASSERTE(TypeFromToken(classref) == mdtTypeRef);

    // we don't need lock here because name of a typeref will not change

    TypeRefRec *pTypeRefRec = m_pStgdb->m_MiniMd.getTypeRef(RidFromToken(classref));
    *psznamespace = m_pStgdb->m_MiniMd.getNamespaceOfTypeRef(pTypeRefRec);
    *pszname = m_pStgdb->m_MiniMd.getNameOfTypeRef(pTypeRefRec);
} // void MDInternalRW::GetNameOfTypeRef()

//*****************************************************************************
// return the resolutionscope of typeref
//*****************************************************************************
mdToken MDInternalRW::GetResolutionScopeOfTypeRef(
    mdTypeRef   classref)               // given classref
{
    LOCKREAD();

    _ASSERTE(TypeFromToken(classref) == mdtTypeRef && RidFromToken(classref));

    TypeRefRec *pTypeRefRec = m_pStgdb->m_MiniMd.getTypeRef(RidFromToken(classref));
    return m_pStgdb->m_MiniMd.getResolutionScopeOfTypeRef(pTypeRefRec);
} // mdToken MDInternalRW::GetResolutionScopeOfTypeRef()

//*****************************************************************************
// Given a name, find the corresponding TypeRef.
//*****************************************************************************
HRESULT MDInternalRW::FindTypeRefByName(  // S_OK or error.
    LPCSTR      szNamespace,            // [IN] Namespace for the TypeRef.
    LPCSTR      szName,                 // [IN] Name of the TypeRef.
    mdToken     tkResolutionScope,      // [IN] Resolution Scope fo the TypeRef.
    mdTypeRef   *ptk)                   // [OUT] TypeRef token returned.
{
    HRESULT     hr = NOERROR;

    LOCKREAD();
    _ASSERTE(ptk);

    // initialize the output parameter
    *ptk = mdTypeRefNil;

    // Treat no namespace as empty string.
    if (!szNamespace)
        szNamespace = "";

    // It is a linear search here. Do we want to instantiate the name hash?
    ULONG       cTypeRefRecs = m_pStgdb->m_MiniMd.getCountTypeRefs();
    TypeRefRec *pTypeRefRec;
    LPCUTF8     szNamespaceTmp;
    LPCUTF8     szNameTmp;
    mdToken     tkRes;

    for (ULONG i = 1; i <= cTypeRefRecs; i++)
    {
        pTypeRefRec = m_pStgdb->m_MiniMd.getTypeRef(i);

        tkRes = m_pStgdb->m_MiniMd.getResolutionScopeOfTypeRef(pTypeRefRec);
        if (IsNilToken(tkRes))
        {
            if (!IsNilToken(tkResolutionScope))
                continue;
        }
        else if (tkRes != tkResolutionScope)
            continue;

        szNamespaceTmp = m_pStgdb->m_MiniMd.getNamespaceOfTypeRef(pTypeRefRec);
        if (strcmp(szNamespace, szNamespaceTmp))
            continue;

        szNameTmp = m_pStgdb->m_MiniMd.getNameOfTypeRef(pTypeRefRec);
        if (!strcmp(szNameTmp, szName))
        {
            *ptk = TokenFromRid(i, mdtTypeRef);
            goto ErrExit;
        }
    }

    // cannot find the typedef
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    return (hr);
} // HRESULT MDInternalRW::FindTypeRefByName()

//*****************************************************************************
// return flags for a given class
//*****************************************************************************
void MDInternalRW::GetTypeDefProps(
    mdTypeDef   td,                     // given classdef
    DWORD       *pdwAttr,               // return flags on class
    mdToken     *ptkExtends)            // [OUT] Put base class TypeDef/TypeRef here.
{
    LOCKREAD();

    TypeDefRec *pTypeDefRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(td));

    if (ptkExtends)
    {
        *ptkExtends = m_pStgdb->m_MiniMd.getExtendsOfTypeDef(pTypeDefRec);
    }
    if (pdwAttr)
    {
        *pdwAttr = m_pStgdb->m_MiniMd.getFlagsOfTypeDef(pTypeDefRec);
    }
} // void MDInternalRW::GetTypeDefProps()


//*****************************************************************************
// return guid pointer to MetaData internal guid pool given a given class
//*****************************************************************************
HRESULT MDInternalRW::GetItemGuid(      // return hresult
    mdToken     tkObj,                  // given item.
    CLSID       *pGuid)                 // [OUT] put guid here.
{

    HRESULT     hr;                     // A result.
    const BYTE  *pBlob;                 // Blob with dispid.
    ULONG       cbBlob;                 // Length of blob.
    WCHAR       wzBlob[40];             // Wide char format of guid.
    int         ix;                     // Loop control.

    // Get the GUID, if any.
    hr = GetCustomAttributeByName(tkObj, INTEROP_GUID_TYPE, (const void**)&pBlob, &cbBlob);
    if (hr != S_FALSE)
    {
        // Should be in format.  Total length == 41
        // <0x0001><0x24>01234567-0123-0123-0123-001122334455<0x0000>
        if ((cbBlob != 41) || (*(USHORT*)pBlob != 1))
            IfFailGo(E_INVALIDARG);
        for (ix=1; ix<=36; ++ix)
            wzBlob[ix] = pBlob[ix+2];
        wzBlob[0] = '{';
        wzBlob[37] = '}';
        wzBlob[38] = 0;
        hr = IIDFromString(wzBlob, pGuid);
    }
    else
        *pGuid = GUID_NULL;
    
ErrExit:
    return hr;
} // HRESULT MDInternalRW::GetItemGuid()

//*****************************************************************************
// // get enclosing class of NestedClass
//***************************************************************************** 
HRESULT MDInternalRW::GetNestedClassProps(  // S_OK or error
    mdTypeDef   tkNestedClass,      // [IN] NestedClass token.
    mdTypeDef   *ptkEnclosingClass) // [OUT] EnclosingClass token.
{
    HRESULT     hr = NOERROR;
    RID         rid;

    LOCKREAD();

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_NestedClass) )        
    {
        // NestedClass table is not sorted. 
        CONVERT_READ_TO_WRITE_LOCK();
    }


    // This is a binary search thus we need to grap a read lock. Or this table
    // might be sorted underneath our feet.

    _ASSERTE(TypeFromToken(tkNestedClass) == mdtTypeDef && ptkEnclosingClass);

    rid = m_pStgdb->m_MiniMd.FindNestedClassFor(RidFromToken(tkNestedClass));

    if (InvalidRid(rid))
        hr = CLDB_E_RECORD_NOTFOUND;
    else
    {
        NestedClassRec *pRecord = m_pStgdb->m_MiniMd.getNestedClass(rid);
        *ptkEnclosingClass = m_pStgdb->m_MiniMd.getEnclosingClassOfNestedClass(pRecord);
    }

    return hr;
} // HRESULT MDInternalRW::GetNestedClassProps()


//*******************************************************************************
// Get count of Nested classes given the enclosing class.
//*******************************************************************************
ULONG MDInternalRW::GetCountNestedClasses(  // return count of Nested classes.
    mdTypeDef   tkEnclosingClass)       // [IN]Enclosing class.
{
    ULONG       ulCount;
    ULONG       ulRetCount = 0;
    NestedClassRec *pRecord;

    _ASSERTE(TypeFromToken(tkEnclosingClass) == mdtTypeDef && !IsNilToken(tkEnclosingClass));

    ulCount = m_pStgdb->m_MiniMd.getCountNestedClasss();

    for (ULONG i = 1; i <= ulCount; i++)
    {
        pRecord = m_pStgdb->m_MiniMd.getNestedClass(i);
        if (tkEnclosingClass == m_pStgdb->m_MiniMd.getEnclosingClassOfNestedClass(pRecord))
            ulRetCount++;
    }
    return ulRetCount;
} // ULONG MDInternalRW::GetCountNestedClasses()

//*******************************************************************************
// Return array of Nested classes given the enclosing class.
//*******************************************************************************
ULONG MDInternalRW::GetNestedClasses(   // Return actual count.
    mdTypeDef   tkEnclosingClass,       // [IN] Enclosing class.
    mdTypeDef   *rNestedClasses,        // [OUT] Array of nested class tokens.
    ULONG       ulNestedClasses)        // [IN] Size of array.
{
    ULONG       ulCount;
    ULONG       ulRetCount = 0;
    NestedClassRec *pRecord;

    _ASSERTE(TypeFromToken(tkEnclosingClass) == mdtTypeDef &&
             !IsNilToken(tkEnclosingClass));

    ulCount = m_pStgdb->m_MiniMd.getCountNestedClasss();

    for (ULONG i = 1; i <= ulCount; i++)
    {
        pRecord = m_pStgdb->m_MiniMd.getNestedClass(i);
        if (tkEnclosingClass == m_pStgdb->m_MiniMd.getEnclosingClassOfNestedClass(pRecord))
        {
            if ((ulRetCount+1) <= ulNestedClasses)  // ulRetCount is 0 based.
                rNestedClasses[ulRetCount] = m_pStgdb->m_MiniMd.getNestedClassOfNestedClass(pRecord);
            ulRetCount++;
        }
    }
    return ulRetCount;
} // ULONG MDInternalRW::GetNestedClasses()

//*******************************************************************************
// return the ModuleRef properties
//*******************************************************************************
void MDInternalRW::GetModuleRefProps(   // return hresult
    mdModuleRef mur,                // [IN] moduleref token
    LPCSTR      *pszName)           // [OUT] buffer to fill with the moduleref name
{
    _ASSERTE(TypeFromToken(mur) == mdtModuleRef);
    _ASSERTE(pszName);
    
    LOCKREAD();

    ModuleRefRec *pModuleRefRec = m_pStgdb->m_MiniMd.getModuleRef(RidFromToken(mur));
    *pszName = m_pStgdb->m_MiniMd.getNameOfModuleRef(pModuleRefRec);
} // void MDInternalRW::GetModuleRefProps()



//*****************************************************************************
// Given a scope and a methoddef, return a pointer to methoddef's signature
//*****************************************************************************
PCCOR_SIGNATURE MDInternalRW::GetSigOfMethodDef(
    mdMethodDef methoddef,              // given a methoddef 
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{
    // Output parameter should not be NULL
    _ASSERTE(pcbSigBlob);
    _ASSERTE(TypeFromToken(methoddef) == mdtMethodDef);

    // We don't change MethodDef signature. No need to lock.

    MethodRec *pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(methoddef));
    return m_pStgdb->m_MiniMd.getSignatureOfMethod(pMethodRec, pcbSigBlob);
} // PCCOR_SIGNATURE MDInternalRW::GetSigOfMethodDef()


//*****************************************************************************
// Given a scope and a fielddef, return a pointer to fielddef's signature
//*****************************************************************************
PCCOR_SIGNATURE MDInternalRW::GetSigOfFieldDef(
    mdFieldDef  fielddef,               // given a methoddef 
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{

    _ASSERTE(pcbSigBlob);
    _ASSERTE(TypeFromToken(fielddef) == mdtFieldDef);

    // We don't change Field's signature. No need to lock.

    FieldRec *pFieldRec = m_pStgdb->m_MiniMd.getField(RidFromToken(fielddef));
    return m_pStgdb->m_MiniMd.getSignatureOfField(pFieldRec, pcbSigBlob);
} // PCCOR_SIGNATURE MDInternalRW::GetSigOfFieldDef()


//*****************************************************************************
// Turn a signature token into a pointer to the real signature data.
//
//@FUTURE: for short term we have a problem where there is no way to get a 
// fixed up address for a blob and do Merge at the same time.  So we've created
// this dummy table called StandAloneSig which you hand out a rid for.  This
// makes finding the sig an extra indirection that is not required.  The 
// Model Compression save code needs to map the token into a byte offset in
// the heap.  Perhaps we can have another mdt* type to switch on the difference.
// But ultimately it has to simply be "pBlobHeapBase + RidFromToken(mdSig)".
//*****************************************************************************
PCCOR_SIGNATURE MDInternalRW::GetSigFromToken(// S_OK or error.
    mdSignature mdSig,                  // [IN] Signature token.
    ULONG       *pcbSig)                // [OUT] return size of signature.
{
    // We don't change token's signature. Thus no need to lock.

    switch (TypeFromToken(mdSig))
    {
    case mdtSignature:
        {
        StandAloneSigRec *pRec;
        pRec = m_pStgdb->m_MiniMd.getStandAloneSig(RidFromToken(mdSig));
        return m_pStgdb->m_MiniMd.getSignatureOfStandAloneSig(pRec, pcbSig);
        }
    case mdtTypeSpec:
        {
        TypeSpecRec *pRec;
        pRec = m_pStgdb->m_MiniMd.getTypeSpec(RidFromToken(mdSig));
        return m_pStgdb->m_MiniMd.getSignatureOfTypeSpec(pRec, pcbSig);
        }
    case mdtMethodDef:
        return GetSigOfMethodDef(mdSig, pcbSig);
    case mdtFieldDef:
        return GetSigOfFieldDef(mdSig, pcbSig);
    }

    // not a known token type.
    _ASSERTE(!"Unexpected token type");
    *pcbSig = 0;
    return NULL;
} // PCCOR_SIGNATURE MDInternalRW::GetSigFromToken()


//*****************************************************************************
// Given methoddef, return the flags
//*****************************************************************************
DWORD MDInternalRW::GetMethodDefProps(  // return mdPublic, mdAbstract, etc
    mdMethodDef md)
{
    // flags can change. 
    DWORD       flags;

    LOCKREAD();


    MethodRec *pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(md));
    flags = m_pStgdb->m_MiniMd.getFlagsOfMethod(pMethodRec);
    
    return flags;
} // DWORD MDInternalRW::GetMethodDefProps()



//*****************************************************************************
// Given a scope and a methoddef, return RVA and impl flags
//*****************************************************************************
void MDInternalRW::GetMethodImplProps(  
    mdToken     tk,                     // [IN] MethodDef
    ULONG       *pulCodeRVA,            // [OUT] CodeRVA
    DWORD       *pdwImplFlags)          // [OUT] Impl. Flags
{
    _ASSERTE(TypeFromToken(tk) == mdtMethodDef);

    LOCKREAD();

    MethodRec *pMethodRec = m_pStgdb->m_MiniMd.getMethod(RidFromToken(tk));

    if (pulCodeRVA)
    {
        *pulCodeRVA = m_pStgdb->m_MiniMd.getRVAOfMethod(pMethodRec);
    }

    if (pdwImplFlags)
    {
        *pdwImplFlags = m_pStgdb->m_MiniMd.getImplFlagsOfMethod(pMethodRec);
    }
    
} // void MDInternalRW::GetMethodImplProps()


//*****************************************************************************
// return the field RVA
//*****************************************************************************
HRESULT MDInternalRW::GetFieldRVA(  
    mdToken     fd,                     // [IN] FieldDef
    ULONG       *pulCodeRVA)            // [OUT] CodeRVA
{
    _ASSERTE(TypeFromToken(fd) == mdtFieldDef);
    _ASSERTE(pulCodeRVA);
    ULONG       iRecord;
    HRESULT     hr = NOERROR;

    LOCKREAD();

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_FieldRVA) )        
    {
        // FieldRVA table is not sorted. 
        CONVERT_READ_TO_WRITE_LOCK();
    }

    iRecord = m_pStgdb->m_MiniMd.FindFieldRVAHelper(fd);
    if (InvalidRid(iRecord))
    {
        if (pulCodeRVA)
            *pulCodeRVA = 0;
        hr = CLDB_E_RECORD_NOTFOUND;
    }
    else
    {
        FieldRVARec *pFieldRVARec = m_pStgdb->m_MiniMd.getFieldRVA(iRecord);

        *pulCodeRVA = m_pStgdb->m_MiniMd.getRVAOfFieldRVA(pFieldRVARec);
    }
    return hr;
} // HRESULT MDInternalRW::GetFieldRVA()


//*****************************************************************************
// Given a fielddef, return the flags. Such as fdPublic, fdStatic, etc
//*****************************************************************************
DWORD MDInternalRW::GetFieldDefProps(      
    mdFieldDef  fd)                     // given memberdef
{
    _ASSERTE(TypeFromToken(fd) == mdtFieldDef);
    DWORD       dwFlags;
    LOCKREAD();

    FieldRec *pFieldRec = m_pStgdb->m_MiniMd.getField(RidFromToken(fd));
    dwFlags = m_pStgdb->m_MiniMd.getFlagsOfField(pFieldRec);
    
    return dwFlags;
} // DWORD MDInternalRW::GetFieldDefProps()


//*****************************************************************************
// return default value of a token(could be paramdef, fielddef, or property)
//*****************************************************************************
HRESULT MDInternalRW::GetDefaultValue(   // return hresult
    mdToken     tk,                     // [IN] given FieldDef, ParamDef, or Property
    MDDefaultValue  *pMDDefaultValue)   // [OUT] default value
{
    _ASSERTE(pMDDefaultValue);

    HRESULT     hr;
    BYTE        bType;
    const       VOID *pValue;
    ULONG       cbValue;
    RID         rid;
    ConstantRec *pConstantRec;

    LOCKREAD();

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_Constant) )        
    {
        // Constant table will be sorted!
        //
        CONVERT_READ_TO_WRITE_LOCK();
    }

    rid = m_pStgdb->m_MiniMd.FindConstantHelper(tk);
    if (InvalidRid(rid))
    {
        pMDDefaultValue->m_bType = ELEMENT_TYPE_VOID;
        return S_OK;
    }
    pConstantRec = m_pStgdb->m_MiniMd.getConstant(rid);

    // get the type of constant value
    bType = m_pStgdb->m_MiniMd.getTypeOfConstant(pConstantRec);

    // get the value blob
    pValue = m_pStgdb->m_MiniMd.getValueOfConstant(pConstantRec, &cbValue);

    // convert it to our internal default value representation
    hr = _FillMDDefaultValue(bType, pValue, pMDDefaultValue);
    pMDDefaultValue->m_cbSize = cbValue;
    return hr;
} // HRESULT MDInternalRW::GetDefaultValue()


//*****************************************************************************
// Given a scope and a methoddef/fielddef, return the dispid
//*****************************************************************************
HRESULT MDInternalRW::GetDispIdOfMemberDef(     // return hresult
    mdToken     tk,                     // given methoddef or fielddef
    ULONG       *pDispid)               // Put the dispid here.
{
    HRESULT     hr;                     // A result.
    const BYTE  *pBlob;                 // Blob with dispid.
    ULONG       cbBlob;                 // Length of blob.

    // No need to lock this function. All of the function that it is calling is already locked!

    // Get the DISPID, if any.
    _ASSERTE(pDispid);

    *pDispid = DISPID_UNKNOWN;
    hr = GetCustomAttributeByName(tk, INTEROP_DISPID_TYPE, (const void**)&pBlob, &cbBlob);
    if (hr != S_FALSE)
    {
        // Check that this might be a dispid.
        if (cbBlob >= (sizeof(*pDispid)+2))
            *pDispid = *reinterpret_cast<UNALIGNED const ULONG *>(pBlob+2);
        else
            IfFailGo(E_INVALIDARG);
    }
    
ErrExit:
    return hr;
} // HRESULT MDInternalRW::GetDispIdOfMemberDef()


//*****************************************************************************
// Given interfaceimpl, return the TypeRef/TypeDef and flags
//*****************************************************************************
mdToken MDInternalRW::GetTypeOfInterfaceImpl( // return hresult
    mdInterfaceImpl iiImpl)             // given a interfaceimpl
{
    // no need to lock this function. 

    _ASSERTE(TypeFromToken(iiImpl) == mdtInterfaceImpl);

    InterfaceImplRec *pIIRec = m_pStgdb->m_MiniMd.getInterfaceImpl(RidFromToken(iiImpl));
    return m_pStgdb->m_MiniMd.getInterfaceOfInterfaceImpl(pIIRec);      
} // mdToken MDInternalRW::GetTypeOfInterfaceImpl()


//*****************************************************************************
// Given a classname, return the typedef
//*****************************************************************************
HRESULT MDInternalRW::FindTypeDef(      // return hresult
    LPCSTR      szNamespace,            // [IN] Namespace for the TypeDef.
    LPCSTR      szName,                 // [IN] Name of the TypeDef.
    mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef of enclosing class.
    mdTypeDef   *ptypedef)              // [OUT] return typedef
{
    LOCKREAD();

    _ASSERTE(ptypedef);

    // initialize the output parameter
    *ptypedef = mdTypeDefNil;

    return ImportHelper::FindTypeDefByName(&(m_pStgdb->m_MiniMd),
                                        szNamespace,
                                        szName,
                                        tkEnclosingClass,
                                        ptypedef);
} // HRESULT MDInternalRW::FindTypeDef()

//*****************************************************************************
// Given a memberref, return a pointer to memberref's name and signature
//*****************************************************************************
LPCSTR MDInternalRW::GetNameAndSigOfMemberRef(  // meberref's name
    mdMemberRef memberref,              // given a memberref 
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{

    // MemberRef's name and sig won't change. Don't need to lock this.

    _ASSERTE(TypeFromToken(memberref) == mdtMemberRef);

    MemberRefRec *pMemberRefRec = m_pStgdb->m_MiniMd.getMemberRef(RidFromToken(memberref));
    if (ppvSigBlob)
    {
        _ASSERTE(pcbSigBlob);
        *ppvSigBlob = m_pStgdb->m_MiniMd.getSignatureOfMemberRef(pMemberRefRec, pcbSigBlob);
    }
    return m_pStgdb->m_MiniMd.getNameOfMemberRef(pMemberRefRec);
} // LPCSTR MDInternalRW::GetNameAndSigOfMemberRef()



//*****************************************************************************
// Given a memberref, return parent token. It can be a TypeRef, ModuleRef, or a MethodDef
//*****************************************************************************
mdToken MDInternalRW::GetParentOfMemberRef(   // return parent token
    mdMemberRef memberref)              // given a typedef
{
    mdToken     tk;
    LOCKREAD();

    // parent for MemberRef can change. See SetParent.

    _ASSERTE(TypeFromToken(memberref) == mdtMemberRef);

    MemberRefRec *pMemberRefRec = m_pStgdb->m_MiniMd.getMemberRef(RidFromToken(memberref));
    tk = m_pStgdb->m_MiniMd.getClassOfMemberRef(pMemberRefRec);
    
    return tk;
} // mdToken MDInternalRW::GetParentOfMemberRef()



//*****************************************************************************
// return properties of a paramdef
//*****************************************************************************/
LPCSTR MDInternalRW::GetParamDefProps (
    mdParamDef  paramdef,               // given a paramdef
    USHORT      *pusSequence,           // [OUT] slot number for this parameter
    DWORD       *pdwAttr)               // [OUT] flags
{
    LOCKREAD();
    LPCSTR      szName;

    // parent for MemberRef can change. See SetParamProps.

    _ASSERTE(TypeFromToken(paramdef) == mdtParamDef);
    ParamRec *pParamRec = m_pStgdb->m_MiniMd.getParam(RidFromToken(paramdef));
    if (pdwAttr)
    {
        *pdwAttr = m_pStgdb->m_MiniMd.getFlagsOfParam(pParamRec);
    }
    if (pusSequence)
    {
        *pusSequence = m_pStgdb->m_MiniMd.getSequenceOfParam(pParamRec);
    }
    szName = m_pStgdb->m_MiniMd.getNameOfParam(pParamRec);
    
    return szName;
} // LPCSTR MDInternalRW::GetParamDefProps ()


//*****************************************************************************
// Get property info for the method.
//*****************************************************************************
HRESULT MDInternalRW::GetPropertyInfoForMethodDef(  // Result.
    mdMethodDef md,                     // [IN] memberdef
    mdProperty  *ppd,                   // [OUT] put property token here
    LPCSTR      *pName,                 // [OUT] put pointer to name here
    ULONG       *pSemantic)             // [OUT] put semantic here
{
    MethodSemanticsRec *pSemantics;
    RID         ridCur;
    RID         ridMax;
    USHORT      usSemantics;
    HRESULT     hr = S_OK;
    LOCKREAD();

    ridMax = m_pStgdb->m_MiniMd.getCountMethodSemantics();
    for (ridCur = 1; ridCur <= ridMax; ridCur++)
    {
        pSemantics = m_pStgdb->m_MiniMd.getMethodSemantics(ridCur);
        if (md == m_pStgdb->m_MiniMd.getMethodOfMethodSemantics(pSemantics))
        {
            // match the method
            usSemantics = m_pStgdb->m_MiniMd.getSemanticOfMethodSemantics(pSemantics);
            if (usSemantics == msGetter || usSemantics == msSetter)
            {
                // Make sure that it is not an invalid entry
                if (m_pStgdb->m_MiniMd.getAssociationOfMethodSemantics(pSemantics) != mdPropertyNil)
                {
                    // found a match. Fill out the output parameters
                    PropertyRec     *pProperty;
                    mdProperty      prop;
                    prop = m_pStgdb->m_MiniMd.getAssociationOfMethodSemantics(pSemantics);
                        
                    if (ppd)
                        *ppd = prop;
                    pProperty = m_pStgdb->m_MiniMd.getProperty(RidFromToken(prop));

                    if (pName)
                        *pName = m_pStgdb->m_MiniMd.getNameOfProperty(pProperty);

                    if (pSemantic)
                        *pSemantic =  usSemantics;
                    goto ErrExit;
                }
            }
        }
    }
    
    hr = S_FALSE;
ErrExit:
    return hr;
} // HRESULT MDInternalRW::GetPropertyInfoForMethodDef()

//*****************************************************************************
// return the pack size of a class
//*****************************************************************************
HRESULT  MDInternalRW::GetClassPackSize(
    mdTypeDef   td,                     // [IN] give typedef
    DWORD       *pdwPackSize)           // [OUT] 
{
    HRESULT     hr = NOERROR;

    LOCKREAD();

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_ClassLayout) )        
    {
        // ClassLayout table is not sorted. 
        CONVERT_READ_TO_WRITE_LOCK();
    }

    // SetClassLayout can change this value.

    _ASSERTE(TypeFromToken(td) == mdtTypeDef && pdwPackSize);

    ClassLayoutRec *pRec;
    RID         ridClassLayout = m_pStgdb->m_MiniMd.FindClassLayoutHelper(td);

    if (InvalidRid(ridClassLayout))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }

    pRec = m_pStgdb->m_MiniMd.getClassLayout(RidFromToken(ridClassLayout));
    *pdwPackSize = m_pStgdb->m_MiniMd.getPackingSizeOfClassLayout(pRec);
ErrExit:
    return hr;
} // HRESULT  MDInternalRW::GetClassPackSize()


//*****************************************************************************
// return the total size of a value class
//*****************************************************************************
HRESULT MDInternalRW::GetClassTotalSize( // return error if a class does not have total size info
    mdTypeDef   td,                     // [IN] give typedef
    ULONG       *pulClassSize)          // [OUT] return the total size of the class
{
    _ASSERTE(TypeFromToken(td) == mdtTypeDef && pulClassSize);

    ClassLayoutRec *pRec;
    HRESULT     hr = NOERROR;
    RID         ridClassLayout;

    LOCKREAD();

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_ClassLayout) )        
    {
        // ClassLayout table is not sorted. 
        CONVERT_READ_TO_WRITE_LOCK();
    }

    // SetClassLayout can change this value.
    ridClassLayout = m_pStgdb->m_MiniMd.FindClassLayoutHelper(td);
    if (InvalidRid(ridClassLayout))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }

    pRec = m_pStgdb->m_MiniMd.getClassLayout(RidFromToken(ridClassLayout));
    *pulClassSize = m_pStgdb->m_MiniMd.getClassSizeOfClassLayout(pRec);
ErrExit:
    return hr;
} // HRESULT MDInternalRW::GetClassTotalSize()


//*****************************************************************************
// init the layout enumerator of a class
//*****************************************************************************
HRESULT  MDInternalRW::GetClassLayoutInit(
    mdTypeDef   td,                     // [IN] give typedef
    MD_CLASS_LAYOUT *pmdLayout)         // [OUT] set up the status of query here
{
    HRESULT     hr = NOERROR;
    LOCKREAD();
    _ASSERTE(TypeFromToken(td) == mdtTypeDef);

    // Do we need to lock this function? Can clints add more Fields on a TypeDef?

    // initialize the output parameter
    _ASSERTE(pmdLayout);
    memset(pmdLayout, 0, sizeof(MD_CLASS_LAYOUT));

    TypeDefRec  *pTypeDefRec;

    // record for this typedef in TypeDef Table
    pTypeDefRec = m_pStgdb->m_MiniMd.getTypeDef(RidFromToken(td));

    // find the starting and end field for this typedef
    pmdLayout->m_ridFieldCur = m_pStgdb->m_MiniMd.getFieldListOfTypeDef(pTypeDefRec);
    pmdLayout->m_ridFieldEnd = m_pStgdb->m_MiniMd.getEndFieldListOfTypeDef(pTypeDefRec);

    
    return hr;
} // HRESULT  MDInternalRW::GetClassLayoutInit()

//*****************************************************************************
// enum the next the field layout 
//*****************************************************************************
HRESULT MDInternalRW::GetClassLayoutNext(
    MD_CLASS_LAYOUT *pLayout,           // [IN|OUT] set up the status of query here
    mdFieldDef  *pfd,                   // [OUT] field def
    ULONG       *pulOffset)             // [OUT] field offset or sequence
{
    HRESULT     hr = S_OK;

    _ASSERTE(pfd && pulOffset && pLayout);

    RID         iLayout2;
    FieldLayoutRec *pRec;

    LOCKREAD();

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_FieldLayout) )        
    {
        // FieldLayout table is not sorted. 
        CONVERT_READ_TO_WRITE_LOCK();
    }

    // We need to lock this function. Becaus FindFieldLayoutHelper might trigger sort if more Fields on other types are
    // introduced during the meantime.

    while (pLayout->m_ridFieldCur < pLayout->m_ridFieldEnd)
    {
        mdFieldDef fd = TokenFromRid(m_pStgdb->m_MiniMd.GetFieldRid(pLayout->m_ridFieldCur), mdtFieldDef);
        iLayout2 = m_pStgdb->m_MiniMd.FindFieldLayoutHelper(fd);
        pLayout->m_ridFieldCur++;
        if (!InvalidRid(iLayout2))
        {
            pRec = m_pStgdb->m_MiniMd.getFieldLayout(iLayout2);
            *pulOffset = m_pStgdb->m_MiniMd.getOffSetOfFieldLayout(pRec);
            _ASSERTE(*pulOffset != ULONG_MAX);
            *pfd = fd;
            goto ErrExit;
        }
    }

    *pfd = mdFieldDefNil;
    hr = S_FALSE;

    // fall through

ErrExit:
    return hr;
} // HRESULT MDInternalRW::GetClassLayoutNext()


//*****************************************************************************
// return the field's native type signature
//*****************************************************************************
HRESULT MDInternalRW::GetFieldMarshal(  // return error if no native type associate with the token
    mdToken     tk,                     // [IN] given fielddef or paramdef
    PCCOR_SIGNATURE *pSigNativeType,    // [OUT] the native type signature
    ULONG       *pcbNativeType)         // [OUT] the count of bytes of *ppvNativeType
{
    // output parameters have to be supplied
    _ASSERTE(pcbNativeType);

    RID         rid;
    FieldMarshalRec *pFieldMarshalRec;
    HRESULT     hr = NOERROR;

    LOCKREAD();

    // We need to lock this function. Becaus FindFieldMarshalHelper might trigger sort if more Fields on other types are
    // introduced during the meantime.

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_FieldMarshal)  )        
    {
        // FieldMarshal table is not sorted. 
        CONVERT_READ_TO_WRITE_LOCK();
    }

    // find the row containing the marshal definition for tk
    rid = m_pStgdb->m_MiniMd.FindFieldMarshalHelper(tk);
    if (InvalidRid(rid))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    pFieldMarshalRec = m_pStgdb->m_MiniMd.getFieldMarshal(rid);

    // get the native type 
    *pSigNativeType = m_pStgdb->m_MiniMd.getNativeTypeOfFieldMarshal(pFieldMarshalRec, pcbNativeType);
ErrExit:
    return hr;
} // HRESULT MDInternalRW::GetFieldMarshal()



//*****************************************
// property APIs
//*****************************************

//*****************************************************************************
// Find property by name
//*****************************************************************************
HRESULT  MDInternalRW::FindProperty(
    mdTypeDef   td,                     // [IN] given a typdef
    LPCSTR      szPropName,             // [IN] property name
    mdProperty  *pProp)                 // [OUT] return property token
{
    HRESULT     hr = NOERROR;
    LOCKREAD();

    // output parameters have to be supplied
    _ASSERTE(TypeFromToken(td) == mdtTypeDef && pProp);

    PropertyMapRec *pRec;
    PropertyRec *pProperty;
    RID         ridPropertyMap;
    RID         ridCur;
    RID         ridEnd;
    LPCUTF8     szName;

    ridPropertyMap = m_pStgdb->m_MiniMd.FindPropertyMapFor(RidFromToken(td));
    if (InvalidRid(ridPropertyMap))
    {
        // not found!
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }

    pRec = m_pStgdb->m_MiniMd.getPropertyMap(ridPropertyMap);

    // get the starting/ending rid of properties of this typedef
    ridCur = m_pStgdb->m_MiniMd.getPropertyListOfPropertyMap(pRec);
    ridEnd = m_pStgdb->m_MiniMd.getEndPropertyListOfPropertyMap(pRec);

    for ( ; ridCur < ridEnd; ridCur ++ )
    {
        pProperty = m_pStgdb->m_MiniMd.getProperty( m_pStgdb->m_MiniMd.GetPropertyRid(ridCur) );
        szName = m_pStgdb->m_MiniMd.getNameOfProperty( pProperty );
        if ( strcmp(szName, szPropName) ==0 )
        {
            // Found the match. Set the output parameter and we are done.
            *pProp = TokenFromRid( m_pStgdb->m_MiniMd.GetPropertyRid(ridCur), mdtProperty );
            goto ErrExit;
        }
    }

    // not found
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    
    return (hr);

} // HRESULT  MDInternalRW::FindProperty()



//*****************************************************************************
// return the properties of a property
//*****************************************************************************
void  MDInternalRW::GetPropertyProps(
    mdProperty  prop,                   // [IN] property token
    LPCSTR      *pszProperty,           // [OUT] property name
    DWORD       *pdwPropFlags,          // [OUT] property flags.
    PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob
    ULONG       *pcbSig)                // [OUT] count of bytes in *ppvSig
{
    HRESULT     hr = NOERROR;
    LOCKREAD();

    // output parameters have to be supplied
    _ASSERTE(TypeFromToken(prop) == mdtProperty);

    PropertyRec     *pProperty;
    ULONG           cbSig;

    pProperty = m_pStgdb->m_MiniMd.getProperty(RidFromToken(prop));

    // get name of the property
    if (pszProperty)
        *pszProperty = m_pStgdb->m_MiniMd.getNameOfProperty(pProperty);

    // get the flags of property
    if (pdwPropFlags)
        *pdwPropFlags = m_pStgdb->m_MiniMd.getPropFlagsOfProperty(pProperty);

    // get the type of the property
    if (ppvSig)
    {
        *ppvSig = m_pStgdb->m_MiniMd.getTypeOfProperty(pProperty, &cbSig);
        if (pcbSig) 
        {
            *pcbSig = cbSig;
        }
    }
    
} // void  MDInternalRW::GetPropertyProps()


//**********************************
//
// Event APIs
//
//**********************************

//*****************************************************************************
// return an event by given the name
//*****************************************************************************
HRESULT  MDInternalRW::FindEvent(
    mdTypeDef   td,                     // [IN] given a typdef
    LPCSTR      szEventName,            // [IN] event name
    mdEvent     *pEvent)                // [OUT] return event token
{
    HRESULT     hr = NOERROR;
    LOCKREAD();

    // output parameters have to be supplied
    _ASSERTE(TypeFromToken(td) == mdtTypeDef && pEvent);

    EventMapRec *pRec;
    EventRec    *pEventRec;
    RID         ridEventMap;
    RID         ridCur;
    RID         ridEnd;
    LPCUTF8     szName;

    ridEventMap = m_pStgdb->m_MiniMd.FindEventMapFor(RidFromToken(td));
    if (InvalidRid(ridEventMap))
    {
        // not found!
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    pRec = m_pStgdb->m_MiniMd.getEventMap(ridEventMap);

    // get the starting/ending rid of properties of this typedef
    ridCur = m_pStgdb->m_MiniMd.getEventListOfEventMap(pRec);
    ridEnd = m_pStgdb->m_MiniMd.getEndEventListOfEventMap(pRec);

    for (; ridCur < ridEnd; ridCur ++)
    {
        pEventRec = m_pStgdb->m_MiniMd.getEvent( m_pStgdb->m_MiniMd.GetEventRid(ridCur) );
        szName = m_pStgdb->m_MiniMd.getNameOfEvent( pEventRec );
        if ( strcmp(szName, szEventName) ==0 )
        {
            // Found the match. Set the output parameter and we are done.
            *pEvent = TokenFromRid( m_pStgdb->m_MiniMd.GetEventRid(ridCur), mdtEvent );
            goto ErrExit;
        }
    }

    // not found
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    
    return (hr);
} // HRESULT  MDInternalRW::FindEvent()


//*****************************************************************************
// return the properties of an event
//*****************************************************************************
void  MDInternalRW::GetEventProps(           // S_OK, S_FALSE, or error.
    mdEvent     ev,                         // [IN] event token
    LPCSTR      *pszEvent,                  // [OUT] Event name
    DWORD       *pdwEventFlags,             // [OUT] Event flags.
    mdToken     *ptkEventType)          // [OUT] EventType class
{
    LOCKREAD();
    EventRec    *pEvent;

    // output parameters have to be supplied
    _ASSERTE(TypeFromToken(ev) == mdtEvent);

    pEvent = m_pStgdb->m_MiniMd.getEvent(RidFromToken(ev));
    if (pszEvent)
        *pszEvent = m_pStgdb->m_MiniMd.getNameOfEvent(pEvent);
    if (pdwEventFlags)
        *pdwEventFlags = m_pStgdb->m_MiniMd.getEventFlagsOfEvent(pEvent);
    if (ptkEventType)
        *ptkEventType = m_pStgdb->m_MiniMd.getEventTypeOfEvent(pEvent);
    
} // void  MDInternalRW::GetEventProps()


//*****************************************************************************
// Find methoddef of a particular associate with a property or an event
//*****************************************************************************
HRESULT  MDInternalRW::FindAssociate(
    mdToken     evprop,                 // [IN] given a property or event token
    DWORD       dwSemantics,            // [IN] given a associate semantics(setter, getter, testdefault, reset)
    mdMethodDef *pmd)                   // [OUT] return method def token 
{
    HRESULT     hr = NOERROR;
    RID         rid;
    MethodSemanticsRec *pMethodSemantics;

    // output parameters have to be supplied
    _ASSERTE(pmd);
    _ASSERTE(TypeFromToken(evprop) == mdtEvent || TypeFromToken(evprop) == mdtProperty);

    LOCKREAD();

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_MethodSemantics) )        
    {
        // MethodSemantics table is not sorted. 
        CONVERT_READ_TO_WRITE_LOCK();
    }

    hr = m_pStgdb->m_MiniMd.FindAssociateHelper(evprop, dwSemantics, &rid);
    if (SUCCEEDED(hr))
    {
        pMethodSemantics = m_pStgdb->m_MiniMd.getMethodSemantics(rid);
        *pmd = m_pStgdb->m_MiniMd.getMethodOfMethodSemantics(pMethodSemantics);
    }
    return hr;
} // HRESULT  MDInternalRW::FindAssociate()


//*****************************************************************************
// get counts of methodsemantics associated with a particular property/event
//*****************************************************************************
void MDInternalRW::EnumAssociateInit(
    mdToken     evprop,                 // [IN] given a property or an event token
    HENUMInternal *phEnum)              // [OUT] cursor to hold the query result
{
    HRESULT     hr;

    LOCKREAD();

    // output parameters have to be supplied
    _ASSERTE(phEnum);
    _ASSERTE(TypeFromToken(evprop) == mdtEvent || TypeFromToken(evprop) == mdtProperty);

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_MethodSemantics) )        
    {
        // MethodSemantics table is not sorted. 
        CONVERT_READ_TO_WRITE_LOCK();
    }

    hr = m_pStgdb->m_MiniMd.FindMethodSemanticsHelper(evprop, phEnum);
    _ASSERTE(SUCCEEDED(hr));
} // void MDInternalRW::EnumAssociateInit()


//*****************************************************************************
// get all methodsemantics associated with a particular property/event
//*****************************************************************************
void MDInternalRW::GetAllAssociates(
    HENUMInternal *phEnum,              // [OUT] cursor to hold the query result
    ASSOCIATE_RECORD *pAssociateRec,    // [OUT] struct to fill for output
    ULONG       cAssociateRec)          // [IN] size of the buffer
{
    LOCKREAD();

    // @FUTURE: rewrite the EnumAssociateInit and GetAllAssociates. Because we might add more properties and events.
    // Then we might resort MethodSemantics table. So this can be totally out of ssync.

    _ASSERTE(phEnum && pAssociateRec);

    MethodSemanticsRec *pSemantics;
    RID         ridCur;
    int         index = 0;
    _ASSERTE(cAssociateRec == phEnum->m_ulCount);

    // Convert from row pointers to RIDs.
    while (HENUMInternal::EnumNext(phEnum, (mdToken *)&ridCur))
    {
        pSemantics = m_pStgdb->m_MiniMd.getMethodSemantics(ridCur);

        pAssociateRec[index].m_memberdef = m_pStgdb->m_MiniMd.getMethodOfMethodSemantics(pSemantics);
        pAssociateRec[index].m_dwSemantics = m_pStgdb->m_MiniMd.getSemanticOfMethodSemantics(pSemantics);
        index++;
    }
    
} // void MDInternalRW::GetAllAssociates()


//*****************************************************************************
// Get the Action and Permissions blob for a given PermissionSet.
//*****************************************************************************
void MDInternalRW::GetPermissionSetProps(
    mdPermission pm,                    // [IN] the permission token.
    DWORD       *pdwAction,             // [OUT] CorDeclSecurity.
    void const  **ppvPermission,        // [OUT] permission blob.
    ULONG       *pcbPermission)         // [OUT] count of bytes of pvPermission.
{
    _ASSERTE(TypeFromToken(pm) == mdtPermission);
    _ASSERTE(pdwAction && ppvPermission && pcbPermission);

    DeclSecurityRec *pPerm;
    LOCKREAD();

    pPerm = m_pStgdb->m_MiniMd.getDeclSecurity(RidFromToken(pm));
    *pdwAction = m_pStgdb->m_MiniMd.getActionOfDeclSecurity(pPerm);
    *ppvPermission = m_pStgdb->m_MiniMd.getPermissionSetOfDeclSecurity(pPerm, pcbPermission);
    
} // void MDInternalRW::GetPermissionSetProps()


//*****************************************************************************
// Get the String given the String token.
//*****************************************************************************
LPCWSTR MDInternalRW::GetUserString(    // Offset into the string blob heap.
    mdString    stk,                    // [IN] the string token.
    ULONG       *pchString,             // [OUT] count of characters in the string.
    BOOL        *pbIs80Plus)            // [OUT] specifies where there are extended characters >= 0x80.
{
    LPWSTR wszTmp;

    // no need to lock this function. 

    _ASSERTE(pchString);
    wszTmp = (LPWSTR) (m_pStgdb->m_MiniMd.GetUserString(RidFromToken(stk), pchString));
	if (*pchString != 0)
	{
		_ASSERTE((*pchString % sizeof(WCHAR)) == 1);
		*pchString /= sizeof(WCHAR);
		if (pbIs80Plus)
			*pbIs80Plus = *(reinterpret_cast<PBYTE>(wszTmp + *pchString));
	}
    return wszTmp;
}   // LPCWSTR MDInternalRW::GetUserString()


//*****************************************************************************
// Get the properties for the given Assembly token.
//*****************************************************************************
void MDInternalRW::GetAssemblyProps(
    mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
    const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
    ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
    ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
    LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
    AssemblyMetaDataInternal *pMetaData,// [OUT] Assembly MetaData.
    DWORD       *pdwAssemblyFlags)      // [OUT] Flags.
{
    AssemblyRec *pRecord;

    LOCKREAD();

    _ASSERTE(TypeFromToken(mda) == mdtAssembly && RidFromToken(mda));
    pRecord = m_pStgdb->m_MiniMd.getAssembly(RidFromToken(mda));

    if (ppbPublicKey)
        *ppbPublicKey = m_pStgdb->m_MiniMd.getPublicKeyOfAssembly(pRecord, pcbPublicKey);
    if (pulHashAlgId)
        *pulHashAlgId = m_pStgdb->m_MiniMd.getHashAlgIdOfAssembly(pRecord);
    if (pszName)
        *pszName = m_pStgdb->m_MiniMd.getNameOfAssembly(pRecord);
    if (pMetaData)
    {
        pMetaData->usMajorVersion = m_pStgdb->m_MiniMd.getMajorVersionOfAssembly(pRecord);
        pMetaData->usMinorVersion = m_pStgdb->m_MiniMd.getMinorVersionOfAssembly(pRecord);
        pMetaData->usBuildNumber = m_pStgdb->m_MiniMd.getBuildNumberOfAssembly(pRecord);
        pMetaData->usRevisionNumber = m_pStgdb->m_MiniMd.getRevisionNumberOfAssembly(pRecord);
        pMetaData->szLocale = m_pStgdb->m_MiniMd.getLocaleOfAssembly(pRecord);
        pMetaData->ulProcessor = 0;
        pMetaData->ulOS = 0;
    }
    if (pdwAssemblyFlags)
    {
        *pdwAssemblyFlags = m_pStgdb->m_MiniMd.getFlagsOfAssembly(pRecord);

        // Turn on the afPublicKey if PublicKey blob is not empty
        DWORD cbPublicKey;
        m_pStgdb->m_MiniMd.getPublicKeyOfAssembly(pRecord, &cbPublicKey);
        if (cbPublicKey)
            *pdwAssemblyFlags |= afPublicKey;
    }
} // void MDInternalRW::GetAssemblyProps()

//*****************************************************************************
// Get the properties for the given AssemblyRef token.
//*****************************************************************************
void MDInternalRW::GetAssemblyRefProps(
    mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
    const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
    ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
    LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
    AssemblyMetaDataInternal *pMetaData,// [OUT] Assembly MetaData.
    const void  **ppbHashValue,         // [OUT] Hash blob.
    ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
    DWORD       *pdwAssemblyRefFlags)   // [OUT] Flags.
{
    AssemblyRefRec  *pRecord;

    LOCKREAD();

    _ASSERTE(TypeFromToken(mdar) == mdtAssemblyRef && RidFromToken(mdar));
    pRecord = m_pStgdb->m_MiniMd.getAssemblyRef(RidFromToken(mdar));

    if (ppbPublicKeyOrToken)
        *ppbPublicKeyOrToken = m_pStgdb->m_MiniMd.getPublicKeyOrTokenOfAssemblyRef(pRecord, pcbPublicKeyOrToken);
    if (pszName)
        *pszName = m_pStgdb->m_MiniMd.getNameOfAssemblyRef(pRecord);
    if (pMetaData)
    {
        pMetaData->usMajorVersion = m_pStgdb->m_MiniMd.getMajorVersionOfAssemblyRef(pRecord);
        pMetaData->usMinorVersion = m_pStgdb->m_MiniMd.getMinorVersionOfAssemblyRef(pRecord);
        pMetaData->usBuildNumber = m_pStgdb->m_MiniMd.getBuildNumberOfAssemblyRef(pRecord);
        pMetaData->usRevisionNumber = m_pStgdb->m_MiniMd.getRevisionNumberOfAssemblyRef(pRecord);
        pMetaData->szLocale = m_pStgdb->m_MiniMd.getLocaleOfAssemblyRef(pRecord);
        pMetaData->ulProcessor = 0;
        pMetaData->ulOS = 0;
    }
    if (ppbHashValue)
        *ppbHashValue = m_pStgdb->m_MiniMd.getHashValueOfAssemblyRef(pRecord, pcbHashValue);
    if (pdwAssemblyRefFlags)
        *pdwAssemblyRefFlags = m_pStgdb->m_MiniMd.getFlagsOfAssemblyRef(pRecord);
} // void MDInternalRW::GetAssemblyRefProps()

//*****************************************************************************
// Get the properties for the given File token.
//*****************************************************************************
void MDInternalRW::GetFileProps(
    mdFile      mdf,                    // [IN] The File for which to get the properties.
    LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
    const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
    ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
    DWORD       *pdwFileFlags)          // [OUT] Flags.
{
    FileRec     *pRecord;

    LOCKREAD();

    _ASSERTE(TypeFromToken(mdf) == mdtFile && RidFromToken(mdf));
    pRecord = m_pStgdb->m_MiniMd.getFile(RidFromToken(mdf));

    if (pszName)
        *pszName = m_pStgdb->m_MiniMd.getNameOfFile(pRecord);
    if (ppbHashValue)
        *ppbHashValue = m_pStgdb->m_MiniMd.getHashValueOfFile(pRecord, pcbHashValue);
    if (pdwFileFlags)
        *pdwFileFlags = m_pStgdb->m_MiniMd.getFlagsOfFile(pRecord);
} // void MDInternalRW::GetFileProps()

//*****************************************************************************
// Get the properties for the given ExportedType token.
//*****************************************************************************
void MDInternalRW::GetExportedTypeProps(
    mdExportedType   mdct,                   // [IN] The ExportedType for which to get the properties.
    LPCSTR      *pszNamespace,          // [OUT] Buffer to fill with name.
    LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
    mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
    mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
    DWORD       *pdwExportedTypeFlags)       // [OUT] Flags.
{
    ExportedTypeRec  *pRecord;

    LOCKREAD();

    _ASSERTE(TypeFromToken(mdct) == mdtExportedType && RidFromToken(mdct));
    pRecord = m_pStgdb->m_MiniMd.getExportedType(RidFromToken(mdct));

    if (pszNamespace)
        *pszNamespace = m_pStgdb->m_MiniMd.getTypeNamespaceOfExportedType(pRecord);
    if (pszName)
        *pszName = m_pStgdb->m_MiniMd.getTypeNameOfExportedType(pRecord);
    if (ptkImplementation)
        *ptkImplementation = m_pStgdb->m_MiniMd.getImplementationOfExportedType(pRecord);
    if (ptkTypeDef)
        *ptkTypeDef = m_pStgdb->m_MiniMd.getTypeDefIdOfExportedType(pRecord);
    if (pdwExportedTypeFlags)
        *pdwExportedTypeFlags = m_pStgdb->m_MiniMd.getFlagsOfExportedType(pRecord);
} // void MDInternalRW::GetExportedTypeProps()

//*****************************************************************************
// Get the properties for the given Resource token.
//*****************************************************************************
void MDInternalRW::GetManifestResourceProps(
    mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
    LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
    mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
    DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
    DWORD       *pdwResourceFlags)      // [OUT] Flags.
{
    ManifestResourceRec *pRecord;

    LOCKREAD();

    _ASSERTE(TypeFromToken(mdmr) == mdtManifestResource && RidFromToken(mdmr));
    pRecord = m_pStgdb->m_MiniMd.getManifestResource(RidFromToken(mdmr));

    if (pszName)
        *pszName = m_pStgdb->m_MiniMd.getNameOfManifestResource(pRecord);
    if (ptkImplementation)
        *ptkImplementation = m_pStgdb->m_MiniMd.getImplementationOfManifestResource(pRecord);
    if (pdwOffset)
        *pdwOffset = m_pStgdb->m_MiniMd.getOffsetOfManifestResource(pRecord);
    if (pdwResourceFlags)
        *pdwResourceFlags = m_pStgdb->m_MiniMd.getFlagsOfManifestResource(pRecord);
} // void MDInternalRW::GetManifestResourceProps()

//*****************************************************************************
// Find the ExportedType given the name.
//*****************************************************************************
STDMETHODIMP MDInternalRW::FindExportedTypeByName( // S_OK or error
    LPCSTR      szNamespace,            // [IN] Namespace of the ExportedType.   
    LPCSTR      szName,                 // [IN] Name of the ExportedType.   
    mdExportedType   tkEnclosingType,        // [IN] Enclosing ExportedType.
    mdExportedType   *pmct)                  // [OUT] Put ExportedType token here.
{
    _ASSERTE(szName && pmct);

    LOCKREAD();
    IMetaModelCommon *pCommon = static_cast<IMetaModelCommon*>(&m_pStgdb->m_MiniMd);
    return pCommon->CommonFindExportedType(szNamespace, szName, tkEnclosingType, pmct);
} // STDMETHODIMP MDInternalRW::FindExportedTypeByName()

//*****************************************************************************
// Find the ManifestResource given the name.
//*****************************************************************************
STDMETHODIMP MDInternalRW::FindManifestResourceByName(// S_OK or error
    LPCSTR      szName,                 // [IN] Name of the resource.   
    mdManifestResource *pmmr)           // [OUT] Put ManifestResource token here.
{
    _ASSERTE(szName && pmmr);

    ManifestResourceRec *pRecord;
    ULONG       cRecords;               // Count of records.
    LPCUTF8     szNameTmp = 0;          // Name obtained from the database.
    ULONG       i;
    HRESULT     hr = S_OK;
    
    LOCKREAD();
    
    cRecords = m_pStgdb->m_MiniMd.getCountManifestResources();

    // Search for the ExportedType.
    for (i = 1; i <= cRecords; i++)
    {
        pRecord = m_pStgdb->m_MiniMd.getManifestResource(i);
        szNameTmp = m_pStgdb->m_MiniMd.getNameOfManifestResource(pRecord);
        if (! strcmp(szName, szNameTmp))
        {
            *pmmr = TokenFromRid(i, mdtManifestResource);
            goto ErrExit;
        }
    }
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    
    return hr;
} // STDMETHODIMP MDInternalRW::FindManifestResourceByName()

//*****************************************************************************
// Get the Assembly token from the given scope.
//*****************************************************************************
HRESULT MDInternalRW::GetAssemblyFromScope( // S_OK or error
    mdAssembly  *ptkAssembly)           // [OUT] Put token here.
{
    _ASSERTE(ptkAssembly);

    if (m_pStgdb->m_MiniMd.getCountAssemblys())
    {
        *ptkAssembly = TokenFromRid(1, mdtAssembly);
        return S_OK;
    }
    else
        return CLDB_E_RECORD_NOTFOUND;
} // HRESULT MDInternalRW::GetAssemblyFromScope()

//*******************************************************************************
// return properties regarding a TypeSpec
//*******************************************************************************
void MDInternalRW::GetTypeSpecFromToken(   // S_OK or error.
    mdTypeSpec typespec,                // [IN] Signature token.
    PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.
    ULONG      *pcbSig)                 // [OUT] return size of signature.
{    
    // no need to lock this function. TypeSpec token content does not change.

    _ASSERTE(TypeFromToken(typespec) == mdtTypeSpec);
    _ASSERTE(ppvSig && pcbSig);

    TypeSpecRec *pRec = m_pStgdb->m_MiniMd.getTypeSpec( RidFromToken(typespec) );
    *ppvSig = m_pStgdb->m_MiniMd.getSignatureOfTypeSpec( pRec, pcbSig );
} // void MDInternalRW::GetTypeSpecFromToken()

//*****************************************************************************
// Return contents of Pinvoke given the forwarded member token.
//***************************************************************************** 
HRESULT MDInternalRW::GetPinvokeMap(
    mdToken     tk,                     // [IN] FieldDef, MethodDef or MethodImpl.
    DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
    LPCSTR      *pszImportName,         // [OUT] Import name.
    mdModuleRef *pmrImportDLL)          // [OUT] ModuleRef token for the target DLL.
{
    ImplMapRec  *pRecord;
    ULONG       iRecord;
    HRESULT     hr = S_OK;

    LOCKREAD();

    if ( !m_pStgdb->m_MiniMd.IsSorted(TBL_ImplMap) )        
    {
        // ImplMap table is not sorted. 
        CONVERT_READ_TO_WRITE_LOCK();
    }

    // This could cause sorting if more ImplMap is introduced during ENC. 
    iRecord = m_pStgdb->m_MiniMd.FindImplMapHelper(tk);
    if (InvalidRid(iRecord))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    else
        pRecord = m_pStgdb->m_MiniMd.getImplMap(iRecord);

    if (pdwMappingFlags)
        *pdwMappingFlags = m_pStgdb->m_MiniMd.getMappingFlagsOfImplMap(pRecord);
    if (pszImportName)
        *pszImportName = m_pStgdb->m_MiniMd.getImportNameOfImplMap(pRecord);
    if (pmrImportDLL)
        *pmrImportDLL = m_pStgdb->m_MiniMd.getImportScopeOfImplMap(pRecord);
ErrExit:
    return hr;
} // HRESULT MDInternalRW::GetPinvokeMap()

HRESULT _ConvertTextSigToComSig(        // Return hresult.
    IMDInternalImport *pImport,
    BOOL        fCreateTrIfNotFound,    // create typeref if not found or not
    LPCSTR      pSignature,             // class file format signature
    CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
    ULONG       *pcbCount);              // [OUT] the result size of signature

//*****************************************************************************
// convert a text signature to com format
//*****************************************************************************
HRESULT MDInternalRW::ConvertTextSigToComSig(// Return hresult.
    BOOL        fCreateTrIfNotFound,    // create typeref if not found or not
    LPCSTR      pSignature,             // class file format signature
    CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
    ULONG       *pcbCount)              // [OUT] the result size of signature
{
    return _ConvertTextSigToComSig( this, fCreateTrIfNotFound, pSignature, pqbNewSig, pcbCount);
} // HRESULT _ConvertTextSigToComSig()

//*****************************************************************************
// This is a way for the EE to associate some data with this RW metadata to 
//  be released when this RW goes away.  This is useful when a RO metadata is
//  converted to RW, because arbitrary threads can be executing in the RO.
//  So, we hold onto the RO here, and when the module shuts down, we release it.
//*****************************************************************************
HRESULT MDInternalRW::SetUserContextData(// S_OK or E_NOTIMPL
    IUnknown    *pIUnk)                 // The user context.
{
    // Only one chance to do this.
    if (m_pUserUnk)
        return E_UNEXPECTED;
    m_pUserUnk = pIUnk;
    return S_OK;
} // HRESULT MDInternalRW::SetUserContextData()

//*****************************************************************************
// determine if a token is valid or not
//*****************************************************************************
BOOL MDInternalRW::IsValidToken(        // True or False.
    mdToken     tk)                     // [IN] Given token.
{
    bool        bRet = false;           // default to invalid token
    RID         rid = RidFromToken(tk);
    
    // no need to lock on this function. 
    if(rid)
    {
        switch (TypeFromToken(tk))
        {
        case mdtModule:
            // can have only one module record
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountModules());
            break;
        case mdtTypeRef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountTypeRefs());
            break;
        case mdtTypeDef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountTypeDefs());
            break;
        case mdtFieldDef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountFields());
            break;
        case mdtMethodDef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountMethods());
            break;
        case mdtParamDef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountParams());
            break;
        case mdtInterfaceImpl:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountInterfaceImpls());
            break;
        case mdtMemberRef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountMemberRefs());
            break;
        case mdtCustomAttribute:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountCustomAttributes());
            break;
        case mdtPermission:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountDeclSecuritys());
            break;
        case mdtSignature:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountStandAloneSigs());
            break;
        case mdtEvent:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountEvents());
            break;
        case mdtProperty:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountPropertys());
            break;
        case mdtModuleRef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountModuleRefs());
            break;
        case mdtTypeSpec:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountTypeSpecs());
            break;
        case mdtAssembly:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountAssemblys());
            break;
        case mdtAssemblyRef:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountAssemblyRefs());
            break;
        case mdtFile:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountFiles());
            break;
        case mdtExportedType:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountExportedTypes());
            break;
        case mdtManifestResource:
            bRet = (rid <= m_pStgdb->m_MiniMd.getCountManifestResources());
            break;
        case mdtString:
            // need to check the user string heap
            if (m_pStgdb->m_MiniMd.m_USBlobs.IsValidCookie(rid))
                bRet = true;
            break;
        default:
            // Don't assert here, just return false
            // _ASSERTE(!"Unknown token kind!");
            _ASSERT(bRet == false);
            break;
        }
    }
    return bRet;
} // BOOL MDInternalRW::IsValidToken()

mdModule MDInternalRW::GetModuleFromScope(void)
{
    return TokenFromRid(1, mdtModule);
} // mdModule MDInternalRW::GetModuleFromScope()

//*****************************************************************************
// Given a MetaData with ENC changes, apply those changes to this MetaData.
//*****************************************************************************
HRESULT MDInternalRW::ApplyEditAndContinue( // S_OK or error.
    MDInternalRW *pDeltaMD)             // Interface to MD with the ENC delta.
{
    LOCKWRITE();

    HRESULT     hr;                     // A result.
    // Get the MiniMd on the delta.
    CMiniMdRW   &mdDelta = pDeltaMD->m_pStgdb->m_MiniMd;
    CMiniMdRW   &mdBase = m_pStgdb->m_MiniMd;

    IfFailGo(mdBase.ConvertToRW());

    IfFailGo(mdBase.ApplyDelta(mdDelta));
ErrExit:
    return hr;
} // HRESULT MDInternalRW::ApplyEditAndContinue()

//*****************************************************************************
// Given a MetaData with ENC changes, enumerate the changed tokens.
//*****************************************************************************
HRESULT MDInternalRW::EnumDeltaTokensInit(  // return hresult
    HENUMInternal   *phEnum)            // Enumerator to initialize.
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       index;                  // Loop control.
    ENCLogRec   *pRec;                  // An ENCLog record.

    // Vars for query.
    _ASSERTE(phEnum);
    memset(phEnum, 0, sizeof(HENUMInternal));

    // cache the tkKind and the scope
    phEnum->m_tkKind = 0;

    phEnum->m_EnumType = MDSimpleEnum;

    HENUMInternal::InitDynamicArrayEnum(phEnum);
    for (index = 1; index <= m_pStgdb->m_MiniMd.m_Schema.m_cRecs[TBL_ENCLog]; ++index)
    {
        // Get the token type; see if it is a real token.
        pRec = m_pStgdb->m_MiniMd.getENCLog(index);
        if (CMiniMdRW::IsRecId(pRec->m_Token))
            continue;
        // If there is a function code, that means that this flags a child-record
        //  addition.  The child record will generate its own token, so did the
        //  parent, so skip the record.
        if (pRec->m_FuncCode)
            continue;

        IfFailGo( HENUMInternal::AddElementToEnum(
            phEnum, 
            pRec->m_Token));
    }

ErrExit:
    // we are done
    return (hr);
} // HRESULT MDInternalRW::EnumDeltaTokensInit()


//*****************************************************************************
// Static function to apply a delta md.  This is what the EE calls to apply
//  the metadata updates from an update PE to live metadata.
// MAY REPLACE THE IMDInternalImport POINTER!.
//*****************************************************************************
HRESULT MDApplyEditAndContinue(         // S_OK or error.
    IMDInternalImport **ppIMD,          // [in, out] The metadata to be updated.
    IMDInternalImportENC *pDeltaMD)     // [in] The delta metadata.
{
    HRESULT     hr;                     // A result.
    IMDInternalImportENC *pENC;         // ENC interface on the metadata.

    // If the input metadata isn't RW, convert it.
    hr = (*ppIMD)->QueryInterface(IID_IMDInternalImportENC, (void**)&pENC);
    if (FAILED(hr))
    {
        IfFailGo(ConvertRO2RW(*ppIMD, IID_IMDInternalImportENC, (void**)&pENC));
        // Replace the old interface pointer with the ENC one. 
        (*ppIMD)->Release();
        IfFailGo(pENC->QueryInterface(IID_IMDInternalImport, (void**)ppIMD));
    }

    // Apply the delta to the input metadata.
    hr = pENC->ApplyEditAndContinue(static_cast<MDInternalRW*>(pDeltaMD));

ErrExit:
    if (pENC)
        pENC->Release();
    return hr;
} // HRESULT MDApplyEditAndContinue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\metamodelrw.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MetaModelRW.cpp
//
// Implementation for the Read/Write MiniMD code.
//
//*****************************************************************************
#include "stdafx.h"
#include <limits.h>
#include <PostError.h>
#include <MetaModelRW.h>
#include <StgIO.h>
#include <StgTiggerStorage.h>
#include "MDLog.h"
#include "RWUtil.h"
#include "..\compiler\importhelper.h"
#include "MetaData.h"

#pragma intrinsic(memcpy)

#define AUTO_GROW                       // Start the database with 2-byte columns.
// #define ORGANIZE_POOLS
#if defined(AUTO_GROW) && defined(ORGANIZE_POOLS)
#undef ORGANIZE_POOLS
#endif

//********** RidMap ***********************************************************
typedef CDynArray<RID> RIDMAP;



//********** Types. ***********************************************************
#define INDEX_ROW_COUNT_THRESHOLD 25


//********** Locals. **********************************************************
#define IX_STRING_POOL 0
#define IX_US_BLOB_POOL 1
#define IX_GUID_POOL 2
#define IX_BLOB_POOL 3
static ULONG g_PoolSizeInfo[2][4][2] =
{ // # of bytes in pool, # of buckets in hash.
    {   // Small pool sizes.
        {20000,     449},
        {5000,      150},
        {256,       16},
        {20000,     449}
    },
    {   // Large pool sizes.  Note on the origin of the values:  I built the
        //  class library to get the sizes and number of items.  The string
        //  and blob pools are rounded up to just under the next page.  The
        //  value of 4271 was chosen so that the initial bucket allocation
        //  would be sufficient to hold the string and blob hashes (ie, we'll
        //  get that big anyway, so start out there), and is a prime number
        //  selected otherwise at random.
        {256000,    4271},  // Strings
        {40000,     800},   // User literal string Blobs.
        {256,       16},    // Guids
        {106400,    4271}   // Blobs
    }
};
static ULONG g_HashSize[2] =
{
    257, 709
};
static ULONG g_TblSizeInfo[2][TBL_COUNT] =
{
    // Small table sizes.  From VBA library.
    {
       1,              // Module
       90,             // TypeRef
       65,             // TypeDef
       0,              // FieldPtr
       400,            // Field
       0,              // MethodPtr
       625,            // Method
       0,              // ParamPtr
       1200,           // Param
       6,              // InterfaceImpl
       500,            // MemberRef
       400,            // Constant
       650,            // CustomAttribute
       0,              // FieldMarshal
       0,              // DeclSecurity
       0,              // ClassLayout
       0,              // FieldLayout
       175,            // StandAloneSig
       0,              // EventMap
       0,              // EventPtr
       0,              // Event
       5,              // PropertyMap
       0,              // PropertyPtr
       25,             // Property
       45,             // MethodSemantics
       20,             // MethodImpl
       0,              // ModuleRef
       0,              // TypeSpec
       0,              // ImplMap @FUTURE: Update with the right number.
       0,              // FieldRVA @UTURE: Update with the right number.
       0,              // ENCLog
       0,              // ENCMap
       0,              // Assembly @UTURE: Update with the right number.
       0,              // AssemblyProcessor @FUTURE: Update with the right number.
       0,              // AssemblyOS @FUTURE: Update with the right number.
       0,              // AssemblyRef @FUTURE: Update with the right number.
       0,              // AssemblyRefProcessor @FUTURE: Update with the right number.
       0,              // AssemblyRefOS @FUTURE: Update with the right number.
       0,              // File @FUTURE: Update with the right number.
       0,              // ExportedType @FUTURE: Update with the right number.
       0,              // ManifestResource @FUTURE: Update with the right number.
       0,              // NestedClass
    },
    // Large table sizes.  From MSCORLIB.
    {
       1,              // Module
       400,            // TypeRef
       3300,           // TypeDef
       0,              // FieldPtr
       4000,           // Field
       0,              // MethodPtr
       92000,          // Method
       0,              // ParamPtr
       48000,          // Param
       900,            // InterfaceImpl
       3137,           // MemberRef
       2400,           // Constant
       71100,          // CustomAttribute
       27500,          // FieldMarshal
       111,            // DeclSecurity
       2,              // ClassLayout
       16,             // FieldLayout
       489,            // StandAloneSig
       0,              // EventMap
       0,              // EventPtr
       10800,          // Event
       400,            // PropertyMap
       0,              // PropertyPtr
       30000,          // Property
       71000,          // MethodSemantics
       38600,          // MethodImpl
       0,              // ModuleRef
       0,              // TypeSpec
       0,              // ImplMap @FUTURE: Update with the right number.
       0,              // FieldRVA @FUTURE: Update with the right number.
       0,              // ENCLog
       0,              // ENCMap
       1,              // Assembly @FUTURE: Update with the right number.
       0,              // AssemblyProcessor @FUTURE: Update with the right number.
       0,              // AssemblyOS @FUTURE: Update with the right number.
       1,              // AssemblyRef @FUTURE: Update with the right number.
       0,              // AssemblyRefProcessor @FUTURE: Update with the right number.
       0,              // AssemblyRefOS @FUTURE: Update with the right number.
       0,              // File @FUTURE: Update with the right number.
       0,              // ExportedType @FUTURE: Update with the right number.
       0,              // ManifestResource @FUTURE: Update with the right number.
       0,              // NestedClass
    }
};

struct TblIndex
{
    ULONG       m_iName;                // Name column.
    ULONG       m_iParent;              // Parent column, if any.
    ULONG       m_Token;                // Token of the table.
};

// Table to drive generic named-item indexing.
TblIndex g_TblIndex[TBL_COUNT] =
{
    {-1,        -1,     mdtModule},     // Module
    {TypeRefRec::COL_Name,      -1,  mdtTypeRef},   // TypeRef
    {TypeDefRec::COL_Name,      -1,  mdtTypeDef},   // TypeDef
    {-1,        -1,     -1},            // FieldPtr
    {-1,        -1,     mdtFieldDef},   // Field
    {-1,        -1,     -1},            // MethodPtr
    {-1,        -1,     mdtMethodDef},  // Method
    {-1,        -1,     -1},            // ParamPtr
    {-1,        -1,     mdtParamDef},   // Param
    {-1,        -1,     mdtInterfaceImpl},      // InterfaceImpl
    {MemberRefRec::COL_Name,    MemberRefRec::COL_Class,  mdtMemberRef},    // MemberRef
    {-1,        -1,     -1},            // Constant
    {-1,        -1,     mdtCustomAttribute},// CustomAttribute
    {-1,        -1,     -1},            // FieldMarshal
    {-1,        -1,     mdtPermission}, // DeclSecurity
    {-1,        -1,     -1},            // ClassLayout
    {-1,        -1,     -1},            // FieldLayout
    {-1,        -1,     mdtSignature},  // StandAloneSig
    {-1,        -1,     -1},            // EventMap
    {-1,        -1,     -1},            // EventPtr
    {-1,        -1,     mdtEvent},      // Event
    {-1,        -1,     -1},            // PropertyMap
    {-1,        -1,     -1},            // PropertyPtr
    {-1,        -1,     mdtProperty},   // Property
    {-1,        -1,     -1},            // MethodSemantics
    {-1,        -1,     -1},            // MethodImpl
    {-1,        -1,     mdtModuleRef},  // ModuleRef
    {-1,        -1,     mdtTypeSpec},   // TypeSpec
    {-1,        -1,     -1},            // ImplMap  @FUTURE:  Check that these are the right entries here.
    {-1,        -1,     -1},            // FieldRVA  @FUTURE:  Check that these are the right entries here.
    {-1,        -1,     -1},            // ENCLog
    {-1,        -1,     -1},            // ENCMap
    {-1,        -1,     mdtAssembly},   // Assembly @FUTURE: Update with the right number.
    {-1,        -1,     -1},            // AssemblyProcessor @FUTURE: Update with the right number.
    {-1,        -1,     -1},            // AssemblyOS @FUTURE: Update with the right number.
    {-1,        -1,     mdtAssemblyRef},// AssemblyRef @FUTURE: Update with the right number.
    {-1,        -1,     -1},            // AssemblyRefProcessor @FUTURE: Update with the right number.
    {-1,        -1,     -1},            // AssemblyRefOS @FUTURE: Update with the right number.
    {-1,        -1,     mdtFile},       // File @FUTURE: Update with the right number.
    {-1,        -1,     mdtExportedType},    // ExportedType @FUTURE: Update with the right number.
    {-1,        -1,     mdtManifestResource},// ManifestResource @FUTURE: Update with the right number.
    {-1,        -1,     -1},            // NestedClass
};

ULONG CMiniMdRW::m_TruncatedEncTables[] =
{
	TBL_ENCLog,
	TBL_ENCMap,
    -1
};

//*****************************************************************************
// Given a token type, return the table index.
//*****************************************************************************
ULONG CMiniMdRW::GetTableForToken(      // Table index, or -1.
    mdToken     tkn)                    // Token to find.
{
    ULONG       ixTbl;                  // Loop control.
    ULONG       type = TypeFromToken(tkn);

    // Get the type -- if a string, no associated table.
    if (type >= mdtString)
        return -1;
    // Table number is same as high-byte of token.
    ixTbl = type >> 24;
    // Make sure.
    _ASSERTE(g_TblIndex[ixTbl].m_Token == type);

    return ixTbl;
} // ULONG CMiniMdRW::GetTableForToken()

//*****************************************************************************
// Given a Table index, return the Token type.
//*****************************************************************************
mdToken CMiniMdRW::GetTokenForTable(    // Token type, or -1.
    ULONG       ixTbl)                  // Table index.
{
    _ASSERTE(g_TblIndex[ixTbl].m_Token == (ixTbl<<24)  || g_TblIndex[ixTbl].m_Token == -1);
    return g_TblIndex[ixTbl].m_Token;
} // ULONG CMiniMdRW::GetTokenForTable()

//*****************************************************************************
// Helper classes for sorting MiniMdRW tables.
//*****************************************************************************
class CQuickSortMiniMdRW
{
protected:
    CMiniMdRW   &m_MiniMd;                  // The MiniMd with the data.
    ULONG       m_ixTbl;                    // The table.
    ULONG       m_ixCol;                    // The column.
    int         m_iCount;                   // How many items in array.
    int         m_iElemSize;                // Size of one element.
    RIDMAP      *m_pRidMap;                 // Rid map that need to be swapped as we swap data

    BYTE        m_buf[128];                 // For swapping.

    void *getRow(ULONG ix) { return m_MiniMd.m_Table[m_ixTbl].GetRecord(ix); }
    void SetSorted() { m_MiniMd.SetSorted(m_ixTbl, true); }

public:
    CQuickSortMiniMdRW(
        CMiniMdRW   &MiniMd,                // MiniMd with the data.
        ULONG       ixTbl,                  // The table.
        ULONG       ixCol)                  // The column.
     :  m_MiniMd(MiniMd),
        m_ixTbl(ixTbl),
        m_ixCol(ixCol),
        m_pRidMap(NULL)
    {
        m_iElemSize = m_MiniMd.m_TableDefs[m_ixTbl].m_cbRec;
        _ASSERTE(m_iElemSize <= sizeof(m_buf));
    }

    // set the RidMap
    void SetRidMap(RIDMAP *pRidMap) { m_pRidMap = pRidMap; }

    //*****************************************************************************
    // Call to sort the array.
    //*****************************************************************************
    void Sort()
    {
        _ASSERTE(m_MiniMd.IsSortable(m_ixTbl));
        m_iCount = m_MiniMd.vGetCountRecs(m_ixTbl);

        // We are going to sort tables. Invalidate the hash tables
        if ( m_MiniMd.m_pLookUpHashs[m_ixTbl] != NULL )
        {
            delete m_MiniMd.m_pLookUpHashs[m_ixTbl];
            m_MiniMd.m_pLookUpHashs[m_ixTbl] = NULL;
        }


        SortRange(1, m_iCount);

        // The table is sorted until its next change.
        SetSorted();
    }

    //*****************************************************************************
    // Override this function to do the comparison.
    //*****************************************************************************
    virtual int Compare(                    // -1, 0, or 1
        int         iLeft,                  // First item to compare.
        int         iRight)                 // Second item to compare.
    {
        void *pLeft = getRow(iLeft);
        void *pRight = getRow(iRight);
        ULONG ulLeft = m_MiniMd.GetCol(m_ixTbl, m_ixCol, pLeft);
        ULONG ulRight = m_MiniMd.GetCol(m_ixTbl, m_ixCol, pRight);

        if (ulLeft < ulRight)
            return -1;
        if (ulLeft == ulRight)
            return 0;
        return 1;
    }

private:
    void SortRange(
        int         iLeft,
        int         iRight)
    {
        int         iLast;
        int         i;                      // loop variable.

        // if less than two elements you're done.
        if (iLeft >= iRight)
            return;

        // The mid-element is the pivot, move it to the left.
        if (Compare(iLeft, (iLeft+iRight)/2))
            Swap(iLeft, (iLeft+iRight)/2);
        iLast = iLeft;

        // move everything that is smaller than the pivot to the left.
        for(i = iLeft+1; i <= iRight; i++)
            if (Compare(i, iLeft) < 0)
                Swap(i, ++iLast);

        // Put the pivot to the point where it is in between smaller and larger elements.
        if (Compare(iLeft, iLast))
            Swap(iLeft, iLast);

        // Sort the each partition.
        SortRange(iLeft, iLast-1);
        SortRange(iLast+1, iRight);
    }

protected:
    inline void Swap(
        int         iFirst,
        int         iSecond)
    {
        if (iFirst == iSecond) return;
        memcpy(m_buf, getRow(iFirst), m_iElemSize);
        memcpy(getRow(iFirst), getRow(iSecond), m_iElemSize);
        memcpy(getRow(iSecond), m_buf, m_iElemSize);
        if (m_pRidMap)
        {
            RID         ridTemp;
            ridTemp = *(m_pRidMap->Get(iFirst));
            *(m_pRidMap->Get(iFirst)) = *(m_pRidMap->Get(iSecond));
            *(m_pRidMap->Get(iSecond)) = ridTemp;
        }
    }

}; // class CQuickSortMiniMdRW
class CStableSortMiniMdRW : public CQuickSortMiniMdRW
{
public:
    CStableSortMiniMdRW(
        CMiniMdRW   &MiniMd,                // MiniMd with the data.
        ULONG       ixTbl,                  // The table.
        ULONG       ixCol)                  // The column.
        :   CQuickSortMiniMdRW(MiniMd, ixTbl, ixCol)
    {}

    //*****************************************************************************
    // Call to sort the array.
    //*****************************************************************************
    void Sort()
    {
        int     i;                      // Outer loop counter.
        int     j;                      // Inner loop counter.
        int     bSwap;                  // Early out.

        _ASSERTE(m_MiniMd.IsSortable(m_ixTbl));
        m_iCount = m_MiniMd.vGetCountRecs(m_ixTbl);

        for (i=m_iCount; i>1; --i)
        {
            bSwap = 0;
            for (j=1; j<i; ++j)
            {
                if (Compare(j, j+1) > 0)
                {
                    Swap(j, j+1);
                    bSwap = 1;
                }
            }
            // If made a full pass w/o swaps, done.
            if (!bSwap)
                break;
        }

        // The table is sorted until its next change.
        SetSorted();
    }

}; // class CStableSortMiniMdRW
//-------------------------------------------------------------------------
#define SORTER(tbl,key) CQuickSortMiniMdRW sort##tbl##(*this, TBL_##tbl, tbl##Rec::COL_##key);
#define STABLESORTER(tbl,key)   CStableSortMiniMdRW sort##tbl##(*this, TBL_##tbl, tbl##Rec::COL_##key);
//-------------------------------------------------------------------------



//********** Code. ************************************************************


//*****************************************************************************
// Ctor / dtor.
//*****************************************************************************
#if defined(_DEBUG)
static bool bENCDeltaOnly = false;
#endif
CMiniMdRW::CMiniMdRW()
 :  m_pHandler(0),
    m_bReadOnly(false),
    m_bPostGSSMod(false),
    m_bPreSaveDone(false),
    m_cbSaveSize(0),
    m_pMemberRefHash(0),
    m_pMemberDefHash(0),
    m_pNamedItemHash(0),
    m_pMethodMap(0),
    m_pFieldMap(0),
    m_pPropertyMap(0),
    m_pEventMap(0),
    m_pParamMap(0),
    m_iSizeHint(0),
    m_pFilterTable(0),
    m_pTokenRemapManager(0),
    m_pHostFilter(0),
    m_rENCRecs(0)
{
#ifdef _DEBUG        
	if (REGUTIL::GetConfigDWORD(L"MD_EncDelta", 0))
	{
        bENCDeltaOnly = true;
	}
    if (REGUTIL::GetConfigDWORD(L"MD_MiniMDBreak", 0))
    {
        _ASSERTE(!"CMiniMdRW::CMiniMdRW()");
    }
#endif // _DEBUG

    ZeroMemory(&m_OptionValue, sizeof(OptionValue));

    // initialize the embeded lookuptable struct.  Further initialization, after constructor.
    for (ULONG ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        m_pVS[ixTbl] = 0;
        m_pLookUpHashs[ixTbl] = 0;
    }

    // Assume that we can sort tables as needed.
    memset(m_bSortable, 1, sizeof(m_bSortable));

    // Initialize the global array of Ptr table indices.
    g_PtrTableIxs[TBL_Field].m_ixtbl = TBL_FieldPtr;
    g_PtrTableIxs[TBL_Field].m_ixcol = FieldPtrRec::COL_Field;
    g_PtrTableIxs[TBL_Method].m_ixtbl = TBL_MethodPtr;
    g_PtrTableIxs[TBL_Method].m_ixcol = MethodPtrRec::COL_Method;
    g_PtrTableIxs[TBL_Param].m_ixtbl = TBL_ParamPtr;
    g_PtrTableIxs[TBL_Param].m_ixcol = ParamPtrRec::COL_Param;
    g_PtrTableIxs[TBL_Property].m_ixtbl = TBL_PropertyPtr;
    g_PtrTableIxs[TBL_Property].m_ixcol = PropertyPtrRec::COL_Property;
    g_PtrTableIxs[TBL_Event].m_ixtbl = TBL_EventPtr;
    g_PtrTableIxs[TBL_Event].m_ixcol = EventPtrRec::COL_Event;

    // AUTO_GROW initialization
    m_maxRid = m_maxIx = 0;
    m_limIx = USHRT_MAX >> 1;
    m_limRid = USHRT_MAX >> AUTO_GROW_CODED_TOKEN_PADDING;
    m_eGrow = eg_ok;
#if defined(_DEBUG)
    {
        for (ULONG iMax=0, iCdTkn=0; iCdTkn<CDTKN_COUNT; ++iCdTkn)
        {
            CCodedTokenDef const *pCTD = &g_CodedTokens[iCdTkn];
            if (pCTD->m_cTokens > iMax)
                iMax = pCTD->m_cTokens;
        }
        // If assert fires, change define for AUTO_GROW_CODED_TOKEN_PADDING.
        _ASSERTE(CMiniMdRW::m_cb[iMax] == AUTO_GROW_CODED_TOKEN_PADDING);
    }
#endif

} // CMiniMdRW::CMiniMdRW()

CMiniMdRW::~CMiniMdRW()
{
    // Un-initialize the embeded lookuptable struct
    for (ULONG ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (m_pVS[ixTbl])
        {
            m_pVS[ixTbl]->Uninit();
            delete m_pVS[ixTbl];
        }
        if ( m_pLookUpHashs[ixTbl] != NULL )
            delete m_pLookUpHashs[ixTbl];

    }
    if (m_pFilterTable)
        delete m_pFilterTable;

    if (m_rENCRecs)
        delete [] m_rENCRecs;

    if (m_pHandler)
        m_pHandler->Release(), m_pHandler = 0;
    if (m_pHostFilter)
        m_pHostFilter->Release();
    if (m_pMemberRefHash)
        delete m_pMemberRefHash;
    if (m_pMemberDefHash)
        delete m_pMemberDefHash;
    if (m_pNamedItemHash)
        delete m_pNamedItemHash;
    if (m_pMethodMap)
        delete m_pMethodMap;
    if (m_pFieldMap)
        delete m_pFieldMap;
    if (m_pPropertyMap)
        delete m_pPropertyMap;
    if (m_pEventMap)
        delete m_pEventMap;
    if (m_pParamMap)
        delete m_pParamMap;
    if (m_pTokenRemapManager)
        delete m_pTokenRemapManager;
} // CMiniMdRW::~CMiniMdRW()


//*****************************************************************************
// return all found CAs in an enumerator
//*****************************************************************************
HRESULT CMiniMdRW::CommonEnumCustomAttributeByName( // S_OK or error.
    mdToken     tkObj,                  // [IN] Object with Custom Attribute.
    LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
    bool        fStopAtFirstFind,       // [IN] just find the first one
    HENUMInternal* phEnum)              // enumerator to fill up
{
    HRESULT     hr = S_OK;              // A result.
    HRESULT     hrRet = S_FALSE;        // Assume that we won't find any 
    ULONG       ridStart, ridEnd;       // Loop start and endpoints.
    CLookUpHash *pHashTable = m_pLookUpHashs[TBL_CustomAttribute];

    _ASSERTE(phEnum != NULL);

    memset(phEnum, 0, sizeof(HENUMInternal));

    phEnum->m_tkKind = mdtCustomAttribute;

    HENUMInternal::InitDynamicArrayEnum(phEnum);


    if (pHashTable)
    {
        // table is not sorted and hash is not built so we have to create dynmaic array 
        // create the dynamic enumerator.
        TOKENHASHENTRY *p;
        ULONG       iHash;
        int         pos;

        // Hash the data.
        iHash = HashCustomAttribute(tkObj);

        // Go through every entry in the hash chain looking for ours.
        for (p = pHashTable->FindFirst(iHash, pos);
             p;
             p = pHashTable->FindNext(pos))
        {

            if ( CompareCustomAttribute( tkObj, szName, RidFromToken(p->tok)) )
            {
                hrRet = S_OK;

                // If here, found a match.
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    p->tok));
                if (fStopAtFirstFind)
                    goto ErrExit;
            }
        }
    }
    else
    {
        // Get the list of custom values for the parent object.
        if ( IsSorted(TBL_CustomAttribute) )
        {
            ridStart = getCustomAttributeForToken(tkObj, &ridEnd);
            // If found none, done.
            if (ridStart == 0)
                goto ErrExit;
        }
        else
        {
            // linear scan of entire table.
            ridStart = 1;
            ridEnd = getCountCustomAttributes() + 1;
        }

        // Look for one with the given name.
        for (; ridStart < ridEnd; ++ridStart)
        {
            if ( CompareCustomAttribute( tkObj, szName, ridStart) )
            {
                // If here, found a match.
                hrRet = S_OK;
                IfFailGo( HENUMInternal::AddElementToEnum(
                    phEnum, 
                    TokenFromRid(ridStart, mdtCustomAttribute)));
                if (fStopAtFirstFind)
                    goto ErrExit;
            }
        }
    }

ErrExit:
    if (FAILED(hr))
        return hr;
    return hrRet;
} // HRESULT CommonEnumCustomAttributeByName()



//*****************************************************************************
// return just the blob value of the first found CA matching the query.
//*****************************************************************************
HRESULT CMiniMdRW::CommonGetCustomAttributeByName( // S_OK or error.
    mdToken     tkObj,                  // [IN] Object with Custom Attribute.
    LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
	const void	**ppData,				// [OUT] Put pointer to data here.
	ULONG		*pcbData)				// [OUT] Put size of data here.
{
    HRESULT         hr;
    ULONG           cbData;
    HENUMInternal   hEnum;
    mdCustomAttribute ca;
    CustomAttributeRec *pRec;

    hr = CommonEnumCustomAttributeByName(tkObj, szName, true, &hEnum);
    if (hr != S_OK)
        goto ErrExit;

    if (ppData)
    {
        // now get the record out.
        if (pcbData == 0)
            pcbData = &cbData;

        if (HENUMInternal::EnumNext(&hEnum, &ca))
        {
            pRec = getCustomAttribute(RidFromToken(ca));
            *ppData = getValueOfCustomAttribute(pRec, pcbData);
        }
        else
        {
            _ASSERTE(!"Enum returned no items after EnumInit returned S_OK");
            hr = S_FALSE;
        }
    }
ErrExit:
    HENUMInternal::ClearEnum(&hEnum);
    return hr;
}   // CommonGetCustomAttributeByName

//*****************************************************************************
// unmark everything in this module
//*****************************************************************************
HRESULT CMiniMdRW::UnmarkAll()
{
    HRESULT     hr = NOERROR;
    ULONG       ulSize = 0;
    ULONG       ixTbl;
    FilterTable *pFilter;

    // find the max rec count with all tables
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (vGetCountRecs(ixTbl) > ulSize)
            ulSize = vGetCountRecs(ixTbl);
    }
    IfNullGo( pFilter = GetFilterTable() );
    IfFailGo( pFilter->UnmarkAll(this, ulSize) );

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::UnmarkAll()


//*****************************************************************************
// mark everything in this module
//*****************************************************************************
HRESULT CMiniMdRW::MarkAll()
{
    HRESULT     hr = NOERROR;
    ULONG       ulSize = 0;
    ULONG       ixTbl;
    FilterTable *pFilter;

    // find the max rec count with all tables
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (vGetCountRecs(ixTbl) > ulSize)
            ulSize = vGetCountRecs(ixTbl);
    }
    IfNullGo( pFilter = GetFilterTable() );
    IfFailGo( pFilter->MarkAll(this, ulSize) );

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::MarkAll()

//*****************************************************************************
// This will trigger FilterTable to be created
//*****************************************************************************
FilterTable *CMiniMdRW::GetFilterTable()
{
    if (m_pFilterTable == NULL)
    {
        m_pFilterTable = new FilterTable;
    }
    return m_pFilterTable;
}


//*****************************************************************************
// Calculate the map between TypeRef and TypeDef
//*****************************************************************************
HRESULT CMiniMdRW::CalculateTypeRefToTypeDefMap()
{
    HRESULT         hr = NOERROR;
    ULONG           index;
    TypeRefRec      *pTypeRefRec;
    LPCSTR          szName;
    LPCSTR          szNamespace;
    mdToken         td;
    mdToken         tkResScope;

    for (index = 1; index<= m_Schema.m_cRecs[TBL_TypeRef]; index++)
    {
        pTypeRefRec = getTypeRef(index);

        // Get the name and namespace of the TypeRef.
        szName = getNameOfTypeRef(pTypeRefRec);
        szNamespace = getNamespaceOfTypeRef(pTypeRefRec);
        tkResScope = getResolutionScopeOfTypeRef(pTypeRefRec);

        // Iff the name is found in the typedef table, then use
        // that value instead.   Won't be found if typeref is trully external.
        hr = ImportHelper::FindTypeDefByName(this, szNamespace, szName,
            (TypeFromToken(tkResScope) == mdtTypeRef) ? tkResScope : mdTokenNil,
            &td);
        if (hr != S_OK)
        {
            // don't propagate the error in the Find
            hr = NOERROR;
            continue;
        }
        *(GetTypeRefToTypeDefMap()->Get(index)) = td;
    }

    return  hr;
} // HRESULT CMiniMdRW::CalculateTypeRefToTypeDefMap()


//*****************************************************************************
// Set a remap handler.
//*****************************************************************************
HRESULT CMiniMdRW::SetHandler(
    IUnknown    *pIUnk)
{
    if (m_pHandler)
        m_pHandler->Release(), m_pHandler = 0;

    if (pIUnk)
    {
        // ignore the error for QI the IHostFilter
        pIUnk->QueryInterface(IID_IHostFilter, reinterpret_cast<void**>(&m_pHostFilter));

        return pIUnk->QueryInterface(IID_IMapToken, reinterpret_cast<void**>(&m_pHandler));
    }


    return S_OK;
} // HRESULT CMiniMdRW::SetHandler()

//*****************************************************************************
// Set a Options
//*****************************************************************************
HRESULT CMiniMdRW::SetOption(
    OptionValue *pOptionValue)
{
    HRESULT     hr = NOERROR;
    ULONG       ixTbl = 0;				// Loop control.
	int			i;						// Loop control.

    if ((pOptionValue->m_UpdateMode & MDUpdateMask) == MDUpdateENC)
    {
         _ASSERTE(0 && "MDUpdateENC is not impl for V1");
         return E_NOTIMPL;
    }

    m_OptionValue = *pOptionValue;

    // Turn off delta metadata bit -- can't be used due to EE assumptions about delta PEs.
    // Inspect ApplyEditAndContinue for details.
    m_OptionValue.m_UpdateMode &= ~MDUpdateDelta;

#if defined(_DEBUG)
    if ((m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateENC &&
        bENCDeltaOnly)
        m_OptionValue.m_UpdateMode |= MDUpdateDelta;
#endif

    // if a scope is previously updated as incremental, then it should not be open again
    // with full update for read/write.
    //
    if ((m_Schema.m_heaps & CMiniMdSchema::HAS_DELETE) &&
        (m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateFull &&
        m_bReadOnly == false)
    {
        IfFailGo( CLDB_E_BADUPDATEMODE );
    }

    if ((m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateIncremental)
        m_Schema.m_heaps |= CMiniMdSchema::HAS_DELETE;

    // Set the value of sortable based on the options.
	switch (m_OptionValue.m_UpdateMode & MDUpdateMask)
	{
	case MDUpdateFull:
		// Always sortable.
		for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
			m_bSortable[ixTbl] = 1;
		break;
	case MDUpdateENC:
		// Never sortable.
		for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
			m_bSortable[ixTbl] = 0;

		// Truncate some tables.
        for (i=0; (ixTbl = m_TruncatedEncTables[i]) != -1; ++i)
		{
			m_Table[ixTbl].Uninit();
			m_Table[ixTbl].InitNew(m_TableDefs[ixTbl].m_cbRec, 0);
			m_Schema.m_cRecs[ixTbl] = 0;
		}

        // Out-of-order is expected in an ENC scenario, never an error.
        m_OptionValue.m_ErrorIfEmitOutOfOrder = MDErrorOutOfOrderNone;

		break;
	case MDUpdateIncremental:
		// Sortable if no external token.
		for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
			m_bSortable[ixTbl] = (GetTokenForTable(ixTbl) == -1);
		break;
	case MDUpdateExtension:
		// Never sortable.
		for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
			m_bSortable[ixTbl] = 0;
		break;
	default:
        _ASSERTE(!"Internal error -- unknown save mode");
        return E_INVALIDARG;
	}

    // If this is an ENC session, track the generations.
    if (!m_bReadOnly && (m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateENC)
    {
        //_ASSERTE(!"ENC!");
        ULONG   uVal;
        ModuleRec *pMod;
        GUID    encid;
        
        // Get the module record.
        pMod = getModule(1);
        
        // Copy EncId as BaseId.
        uVal = GetCol(TBL_Module, ModuleRec::COL_EncId, pMod);
        PutCol(TBL_Module, ModuleRec::COL_EncBaseId, pMod, uVal);

        // Allocate a new GUID for EncId.
        IfFailGo(CoCreateGuid(&encid));
        PutGuid(TBL_Module, ModuleRec::COL_EncId, pMod, encid);
    }

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::SetOption()

//*****************************************************************************
// Get Options
//*****************************************************************************
HRESULT CMiniMdRW::GetOption(
    OptionValue *pOptionValue)
{
    *pOptionValue = m_OptionValue;
    return S_OK;
} // HRESULT CMiniMdRW::GetOption()

//*****************************************************************************
// Smart MapToken.  Only calls client if token really changed.
//*****************************************************************************
HRESULT CMiniMdRW::MapToken(            // Return value from user callback.
    RID         from,                   // Old rid.
    RID         to,                     // New rid.
    mdToken     tkn)                    // Token type.
{
    HRESULT     hr = S_OK;
    TOKENREC    *pTokenRec;
    MDTOKENMAP  *pMovementMap;
    // If not change, done.
    if (from==to)
        return S_OK;

    pMovementMap = GetTokenMovementMap();
    _ASSERTE( GetTokenMovementMap() );
    if (pMovementMap)
        IfFailRet( pMovementMap->AppendRecord( TokenFromRid(from, tkn), false, TokenFromRid(to, tkn), &pTokenRec ) );

    // Notify client.
    if ( m_pHandler )
    {
        LOG((LOGMD, "CMiniMdRW::MapToken (remap): from 0x%08x to 0x%08x\n", TokenFromRid(from,tkn), TokenFromRid(to,tkn)));
        return m_pHandler->Map(TokenFromRid(from,tkn), TokenFromRid(to,tkn));
    }
    else
        return hr;
} // HRESULT CMiniMdCreate::MapToken()

//*****************************************************************************
// Set max, lim, based on data.
//*****************************************************************************
void CMiniMdRW::ComputeGrowLimits()
{
    // @FUTURE: it would be useful to be able to grow any database.
    m_maxRid = m_maxIx = ULONG_MAX;
    m_limIx = USHRT_MAX << 1;
    m_limRid = USHRT_MAX << 1; //@FUTURE: calculate automatically.
    m_eGrow = eg_grown;
} // void CMiniMdRW::ComputeGrowLimits()

//*****************************************************************************
// Initialization of a new writable MiniMd's pools.
//*****************************************************************************
HRESULT CMiniMdRW::InitPoolOnMem(
    int         iPool,                  // The pool to initialize.
    void        *pbData,                // The data from which to init.
    ULONG       cbData,                 // Size of data.
    int         bReadOnly)              // Is the memory read-only?
{
    HRESULT     hr;                     // A result.

    switch (iPool)
    {
    case MDPoolStrings:
        if (pbData == 0)
            hr = m_Strings.InitNew();
        else
            hr = m_Strings.InitOnMem(pbData, cbData, bReadOnly);
        break;
    case MDPoolGuids:
        if (pbData == 0)
            hr = m_Guids.InitNew();
        else
            hr = m_Guids.InitOnMem(pbData, cbData, bReadOnly);
        break;
    case MDPoolBlobs:
        if (pbData == 0)
            hr = m_Blobs.InitNew();
        else
            hr = m_Blobs.InitOnMem(pbData, cbData, bReadOnly);
        break;
    case MDPoolUSBlobs:
        if (pbData == 0)
            hr = m_USBlobs.InitNew();
        else
            hr = m_USBlobs.InitOnMem(pbData, cbData, bReadOnly);
        break;
    default:
        hr = E_INVALIDARG;
    }

    return hr;
} // HRESULT CMiniMdRW::InitPoolOnMem()

//*****************************************************************************
// Initialization of a new writable MiniMd
//*****************************************************************************
HRESULT CMiniMdRW::InitOnMem(
    const void  *pvBuf,                 // The data from which to init.
	ULONG		ulBufLen,				// The data size
    int         bReadOnly)              // Is the memory read-only?
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       cbData;                 // Size of the schema structure.
	ULONG		ulTotalSize;
    BYTE        *pBuf = const_cast<BYTE*>(reinterpret_cast<const BYTE*>(pvBuf));
    int         i;                      // Loop control.
    RecordOpenFlags fReadOnly;

    // post contruction initialize the embeded lookuptable struct
    for (ULONG ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (g_Tables[ixTbl].m_Def.m_iKey < g_Tables[ixTbl].m_Def.m_cCols)
        {
            m_pVS[ixTbl] = new VirtualSort;
            IfNullGo(m_pVS[ixTbl]);

            m_pVS[ixTbl]->Init(ixTbl, g_Tables[ixTbl].m_Def.m_iKey, this);
        }
    }
	
    // Covnvert our Open flag to the enum so we can open the record
	if (bReadOnly == TRUE)
	{
		fReadOnly = READ_ONLY;
	}
	else
	{
		fReadOnly = READ_WRITE;
	}

    // Uncompress the schema from the buffer into our structures.
    cbData = m_Schema.LoadFrom(pvBuf);

    // Do we know how to read this?
    if (m_Schema.m_major != METAMODEL_MAJOR_VER || m_Schema.m_minor != METAMODEL_MINOR_VER)
        return PostError(CLDB_E_FILE_OLDVER, m_Schema.m_major,m_Schema.m_minor);

    // Populate the schema and initialize the pointers to the rest of the data.
    ulTotalSize = SchemaPopulate2();
	if(ulTotalSize > ulBufLen) return PostError(CLDB_E_FILE_CORRUPT);

    // Initialize the tables.
    pBuf += cbData;
    for (i=0; i<TBL_COUNT; ++i)
    {
        if (m_Schema.m_cRecs[i])
        {
			ULONG cbTable = m_TableDefs[i].m_cbRec * m_Schema.m_cRecs[i];
			m_Table[i].InitOnMem(m_TableDefs[i].m_cbRec, pBuf, cbTable, fReadOnly);
			pBuf += cbTable;
        }
        else
            m_Table[i].InitNew(m_TableDefs[i].m_cbRec, 0);
    }

    if (bReadOnly == false)
    {
        // variable to indicate if tables are large, small or mixed.
        int         fMixed = false;
        int         iSize = 0;
        CMiniColDef *pCols;                 // The col defs to init.
        int         iCol;

        for (i=0; i<TBL_COUNT && fMixed == false; i++)
        {
            pCols = m_TableDefs[i].m_pColDefs;
            for (iCol = 0; iCol < m_TableDefs[i].m_cCols && fMixed == false; iCol++)
            {
                if (IsFixedType(m_TableDefs[i].m_pColDefs[iCol].m_Type) == false)
                {
                    if (iSize == 0)
                    {
                        iSize = m_TableDefs[i].m_pColDefs[iCol].m_cbColumn;
                    }
                    else
                    {
                        if (iSize != m_TableDefs[i].m_pColDefs[iCol].m_cbColumn)
                        {
                            fMixed = true;
                        }
                    }
                }
            }
        }
        if (fMixed)
        {
            // grow everything to large
            ExpandTables();
            ComputeGrowLimits();
        }
        else
        {
            if (iSize == 2)
            {
                // small schema
                m_maxRid = m_maxIx = USHRT_MAX;
                m_limIx = (USHORT) (USHRT_MAX << 1);
                m_limRid = (USHORT) (USHRT_MAX << 1);
                m_eGrow = eg_ok;
            }
            else
            {
                // large schema
                ComputeGrowLimits();
            }
        }
    }
    else
    {
        // Set the limits so we will know when to grow the database.
        ComputeGrowLimits();
    }

    // Track records that this MD started with.
    m_StartupSchema = m_Schema;
    m_cbStartupPool[MDPoolStrings] = m_Strings.GetPoolSize();
    m_cbStartupPool[MDPoolGuids] = m_Guids.GetPoolSize();
    m_cbStartupPool[MDPoolUSBlobs] = m_USBlobs.GetPoolSize();
    m_cbStartupPool[MDPoolBlobs] = m_Blobs.GetPoolSize();

    m_bReadOnly = bReadOnly ? 1 : 0;

ErrExit:    
    return hr;
} // HRESULT CMiniMdRW::InitOnMem()

//*****************************************************************************
// Validate cross-stream consistency.
//*****************************************************************************
HRESULT CMiniMdRW::PostInit(
    int         iLevel)
{
    HRESULT     hr = S_OK;
    ULONG       cbStrings;              // Size of strings.
    ULONG       cbBlobs;                // Size of blobs.

    cbStrings =  m_Strings.GetPoolSize();
    cbBlobs = m_Blobs.GetPoolSize();

    // Last valid byte of string pool better be nul.
    if (cbStrings > 0 && *m_Strings.GetString(cbStrings-1) != '\0')
        IfFailGo(CLDB_E_FILE_CORRUPT);

    // if iLevel > 0, consider chaining through the blob heap.

#if 0 // this catches **some** corruptions.  Don't catch just some.
    // If no blobs or no strings:  that's very rare, so verify that
    //  there really shouldn't be.  Any valid db with no strings and
    //  no blobs must be pretty small.
    if (cbStrings == 0 || cbBlobs == 0)
    {
        // Look at every table...
        for (ULONG ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
        {
            // Look at every row...
            for (RID rid=1; rid<=m_Schema.m_cRecs[ixTbl]; ++rid)
            {
                void *pRow = getRow(ixTbl, rid);
                ULONG iVal;
                // Look at every column...
                for (ULONG ixCol=0; ixCol<m_TableDefs[ixTbl].m_cCols; ++ixCol)
                {   // Validate strings and blobs.
                    switch (m_TableDefs[ixTbl].m_pColDefs[ixCol].m_Type)
                    {
                    case iSTRING:
                        iVal = GetCol(ixTbl, ixCol, pRow);
                        if (iVal >= cbStrings)
                            IfFailGo(CLDB_E_FILE_CORRUPT);
                        break;
                    case iBLOB:
                        iVal = GetCol(ixTbl, ixCol, pRow);
                        if (iVal >= cbBlobs)
                            IfFailGo(CLDB_E_FILE_CORRUPT);
                        break;
                    default:
                         break;
                    }
                } // for (ixCol...
            } // for (rid...
        } // for (ixTbl...
    }
#endif // this catches **some** corruptions.  Don't catch just some.

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::PostInit()

//*****************************************************************************
// Init a CMiniMdRW from the data in a CMiniMd [RO].
//*****************************************************************************
HRESULT CMiniMdRW::InitOnRO(                    // S_OK or error.
    CMiniMd     *pMd,                           // The MiniMd to update from.
    int         bReadOnly)                      // Will updates be allowed?
{
    HRESULT     hr = S_OK;                      // A result.
    ULONG       i, j;                           // Loop control.
    ULONG       cbHeap;                         // Size of a heap.

    RecordOpenFlags fReadOnly;

    // post contruction initialize the embeded lookuptable struct
    for (ULONG ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (g_Tables[ixTbl].m_Def.m_iKey < g_Tables[ixTbl].m_Def.m_cCols)
        {
            m_pVS[ixTbl] = new VirtualSort;
            IfNullGo(m_pVS[ixTbl]);

            m_pVS[ixTbl]->Init(ixTbl, g_Tables[ixTbl].m_Def.m_iKey, this);
        }
    }
	
	// Covnvert our Open flag to the enum so we can open the record
	if (bReadOnly == TRUE)
	{
		fReadOnly = READ_ONLY;
	}
	else
	{
		fReadOnly = READ_WRITE;
	}

    // Init the schema.
    m_Schema = pMd->m_Schema;
    SchemaPopulate2();
    for (i=0; i<TBL_COUNT; ++i)
    {
        _ASSERTE(m_TableDefs[i].m_cCols == pMd->m_TableDefs[i].m_cCols);
        m_TableDefs[i].m_cbRec = pMd->m_TableDefs[i].m_cbRec;

        for (j=0; j<m_TableDefs[i].m_cCols; ++j)
        {
            _ASSERTE(m_TableDefs[i].m_pColDefs[j].m_Type == pMd->m_TableDefs[i].m_pColDefs[j].m_Type);
            m_TableDefs[i].m_pColDefs[j].m_cbColumn = pMd->m_TableDefs[i].m_pColDefs[j].m_cbColumn;
            m_TableDefs[i].m_pColDefs[j].m_oColumn = pMd->m_TableDefs[i].m_pColDefs[j].m_oColumn;
        }
    }

    // Init the heaps.
    _ASSERTE(pMd->m_Strings.GetNextSeg() == 0);
    cbHeap = pMd->m_Strings.GetSegSize();
    if (cbHeap)
        IfFailGo(m_Strings.InitOnMem((void*)pMd->m_Strings.GetSegData(), pMd->m_Strings.GetSegSize(), bReadOnly));
    else
        IfFailGo(m_Strings.InitNew(0, 0));

    _ASSERTE(pMd->m_USBlobs.GetNextSeg() == 0);
    cbHeap = pMd->m_USBlobs.GetSegSize();
    if (cbHeap)
        IfFailGo(m_USBlobs.InitOnMem((void*)pMd->m_USBlobs.GetSegData(), pMd->m_USBlobs.GetSegSize(), bReadOnly));
    else
        IfFailGo(m_USBlobs.InitNew(0, 0));

    _ASSERTE(pMd->m_Guids.GetNextSeg() == 0);
    cbHeap = pMd->m_Guids.GetSegSize();
    if (cbHeap)
        IfFailGo(m_Guids.InitOnMem((void*)pMd->m_Guids.GetSegData(), pMd->m_Guids.GetSegSize(), bReadOnly));
    else
        IfFailGo(m_Guids.InitNew(0, 0));

    _ASSERTE(pMd->m_Blobs.GetNextSeg() == 0);
    cbHeap = pMd->m_Blobs.GetSegSize();
    if (cbHeap)
        IfFailGo(m_Blobs.InitOnMem((void*)pMd->m_Blobs.GetSegData(), pMd->m_Blobs.GetSegSize(), bReadOnly));
    else
        IfFailGo(m_Blobs.InitNew(0, 0));


    // Init the record pools
    for (i=0; i<TBL_COUNT; ++i)
    {
        if (m_Schema.m_cRecs[i] > 0)
        {
            IfFailGo(m_Table[i].InitOnMem(m_TableDefs[i].m_cbRec, pMd->getRow(i, 1), m_Schema.m_cRecs[i]*m_TableDefs[i].m_cbRec, fReadOnly));
	        // The compressed, read-only tables are always sorted
		    SetSorted(i, true);
        }
        else
        {
            IfFailGo(m_Table[i].InitNew(m_TableDefs[i].m_cbRec, 2));
            // An empty table can be considered unsorted.
            SetSorted(i, false);
        }
    }

    // Set the limits so we will know when to grow the database.
    ComputeGrowLimits();

    // Track records that this MD started with.
    m_StartupSchema = m_Schema;
    m_cbStartupPool[MDPoolStrings] = m_Strings.GetPoolSize();
    m_cbStartupPool[MDPoolGuids] = m_Guids.GetPoolSize();
    m_cbStartupPool[MDPoolUSBlobs] = m_USBlobs.GetPoolSize();
    m_cbStartupPool[MDPoolBlobs] = m_Blobs.GetPoolSize();

    m_bReadOnly = bReadOnly ? 1 : 0;

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::InitOnRO()

//*****************************************************************************
// Convert a read-only to read-write.  Copies data.
//*****************************************************************************
HRESULT CMiniMdRW::ConvertToRW()
{
    HRESULT     hr=S_OK;                // A result.
    int         i;                      // Loop control.

    // Check for already done.
    if (!m_bReadOnly)
        goto ErrExit;

    IfFailGo(m_Strings.ConvertToRW());
    IfFailGo(m_Guids.ConvertToRW());
    IfFailGo(m_USBlobs.ConvertToRW());
    IfFailGo(m_Blobs.ConvertToRW());

    // Init the record pools
    for (i=0; i<TBL_COUNT; ++i)
    {
        IfFailGo(m_Table[i].ConvertToRW());
    }

    // Set the limits so we will know when to grow the database.
    ComputeGrowLimits();

    // Track records that this MD started with.
    m_StartupSchema = m_Schema;
    m_cbStartupPool[MDPoolStrings] = m_Strings.GetPoolSize();
    m_cbStartupPool[MDPoolGuids] = m_Guids.GetPoolSize();
    m_cbStartupPool[MDPoolUSBlobs] = m_USBlobs.GetPoolSize();
    m_cbStartupPool[MDPoolBlobs] = m_Blobs.GetPoolSize();

    // No longer read-only.
    m_bReadOnly = 0;

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::ConvertToRW()

//*****************************************************************************
// Initialization of a new writable MiniMd
//*****************************************************************************
HRESULT CMiniMdRW::InitNew()
{
    HRESULT     hr=S_OK;                // A result.
    int         i;                      // Loop control.
    ULONG       iMax=0;                 // For counting largest table.
    bool        bAuto=true;             // Start small, grow as needed.

    // post contruction initialize the embeded lookuptable struct
    for (ULONG ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (g_Tables[ixTbl].m_Def.m_iKey < g_Tables[ixTbl].m_Def.m_cCols)
        {
            m_pVS[ixTbl] = new VirtualSort;
            IfNullGo(m_pVS[ixTbl]);

            m_pVS[ixTbl]->Init(ixTbl, g_Tables[ixTbl].m_Def.m_iKey, this);
        }
    }
	
    // Initialize the Schema.
    m_Schema.InitNew();

#if defined(AUTO_GROW)
    if (bAuto && m_iSizeHint == 0)
    {
        // OutputDebugStringA("Default small tables enabled\n");
        // How big are the various pool inidices?
        m_Schema.m_heaps = 0;
        // How many rows in various tables?
        for (i=0; i<TBL_COUNT; ++i)
            m_Schema.m_cRecs[i] = 0;

        // Compute how many bits required to hold.
        m_Schema.m_rid = 1;
        m_maxRid = m_maxIx = 0;
        m_limIx = USHRT_MAX >> 1;
        m_limRid = USHRT_MAX >> AUTO_GROW_CODED_TOKEN_PADDING;
        m_eGrow = eg_ok;
    }
    else
#endif // AUTO_GROW
    {
        // OutputDebugStringA("Default small tables disabled\n");
        // How big are the various pool inidices?
        m_Schema.m_heaps = 0;
        m_Schema.m_heaps |= CMiniMdSchema::HEAP_STRING_4;
        m_Schema.m_heaps |= CMiniMdSchema::HEAP_GUID_4;
        m_Schema.m_heaps |= CMiniMdSchema::HEAP_BLOB_4;

        // How many rows in various tables?
        for (i=0; i<TBL_COUNT; ++i)
            m_Schema.m_cRecs[i] = USHRT_MAX+1;

        // Compute how many bits required to hold.
        m_Schema.m_rid = 16;
        m_maxRid = m_maxIx = ULONG_MAX;
        m_limIx = USHRT_MAX << 1;
        m_limRid = USHRT_MAX << 1; //@FUTURE: calculate automatically.
        m_eGrow = eg_grown;
    }

    // Now call base class function to calculate the offsets, sizes.
    SchemaPopulate2();

    // Initialize the record heaps.
    for (i=0; i<TBL_COUNT; ++i)
    {   // Don't really have any records yet.
        m_Schema.m_cRecs[i] = 0;
        m_Table[i].InitNew(m_TableDefs[i].m_cbRec, g_TblSizeInfo[m_iSizeHint][i]);

        // Create tables as un-sorted.  We hope to add all records, then sort just once.
        SetSorted(i, false);
    }

    // Initialize string, guid, and blob heaps.
    m_Strings.InitNew(g_PoolSizeInfo[m_iSizeHint][IX_STRING_POOL][0], g_PoolSizeInfo[m_iSizeHint][IX_STRING_POOL][1]);
    m_USBlobs.InitNew(g_PoolSizeInfo[m_iSizeHint][IX_US_BLOB_POOL][0], g_PoolSizeInfo[m_iSizeHint][IX_US_BLOB_POOL][1]);
    m_Guids.InitNew(g_PoolSizeInfo[m_iSizeHint][IX_GUID_POOL][0], g_PoolSizeInfo[m_iSizeHint][IX_GUID_POOL][1]);
    m_Blobs.InitNew(g_PoolSizeInfo[m_iSizeHint][IX_BLOB_POOL][0], g_PoolSizeInfo[m_iSizeHint][IX_BLOB_POOL][1]);

    // Track records that this MD started with.
    m_StartupSchema = m_Schema;

    // New db is never read-only.
    m_bReadOnly = 0;

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::InitNew()

//*****************************************************************************
// Apply a set of table extensions to this MD.
//*****************************************************************************
HRESULT CMiniMdRW::ApplyTablesExtension(
    const void  *pvBuf,                 // The data from which to init.
    int         bReadOnly)              // Is the memory read-only?
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       cbData;                 // Size of the schema structure.
    BYTE        *pBuf = const_cast<BYTE*>(reinterpret_cast<const BYTE*>(pvBuf));
    int         ixTbl;                  // Loop control.
    CMiniMdSchema Schema;               // Schema of the new data.
#if _DEBUG
    CMiniTableDef sTableDef;            // Table def for consistency check.
#endif // _DEBUG

    // Uncompress the schema from the buffer into our structures.
    cbData = Schema.LoadFrom(pvBuf);

    // Do we know how to read this?
    if (Schema.m_major != METAMODEL_MAJOR_VER || Schema.m_minor != METAMODEL_MINOR_VER)
        return CLDB_E_FILE_OLDVER;

    // Add the data to the tables.
    pBuf += cbData;
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (Schema.m_cRecs[ixTbl])
        {
            DEBUG_STMT(InitColsForTable(Schema, ixTbl, &sTableDef, 0));
            _ASSERTE(sTableDef.m_cbRec == m_TableDefs[ixTbl].m_cbRec);
            ULONG cbTable = m_TableDefs[ixTbl].m_cbRec * Schema.m_cRecs[ixTbl];
            IfFailGo(m_Table[ixTbl].AddSegment(pBuf, cbTable, true));
            pBuf += cbTable;
        }
    }

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::ApplyTablesExtension()

//*****************************************************************************
// Initialization of a new writable MiniMd's pools.
//*****************************************************************************
HRESULT CMiniMdRW::ApplyPoolExtension(
    int         iPool,                  // The pool to initialize.
    void        *pbData,                // The data from which to init.
    ULONG       cbData,                 // Size of data.
    int         bReadOnly)              // Is the memory read-only?
{
    HRESULT     hr;                     // A result.

    switch (iPool)
    {
    case MDPoolStrings:
        IfFailGo(m_Strings.AddSegment(pbData, cbData, !bReadOnly));
        break;
    case MDPoolGuids:
        IfFailGo(m_Guids.AddSegment(pbData, cbData, !bReadOnly));
        break;
    case MDPoolBlobs:
        IfFailGo(m_Blobs.AddSegment(pbData, cbData, !bReadOnly));
        break;
    case MDPoolUSBlobs:
        IfFailGo(m_USBlobs.AddSegment(pbData, cbData, !bReadOnly));
        break;
    default:
        hr = E_INVALIDARG;
    }

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::ApplyPoolExtension()

//*****************************************************************************
// Determine how big the tables would be when saved.
//*****************************************************************************
HRESULT CMiniMdRW::GetFullSaveSize(         // S_OK or error.
    CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
    ULONG       *pulSaveSize,           // [OUT] Put the size here.
    DWORD       *pbSaveCompressed)      // [OUT] Will the saved data be fully compressed?
{
    HRESULT     hr=S_OK;                // A result.
    CMiniTableDef   sTempTable;         // Definition for a temporary table.
    CQuickArray<CMiniColDef> rTempCols; // Definition for a temp table's columns.
    BYTE        SchemaBuf[sizeof(CMiniMdSchema)];   //Buffer for compressed schema.
    ULONG       cbAlign;                // Bytes needed for alignment.
    ULONG       cbTable;                // Bytes in a table.
    ULONG       cbTotal;                // Bytes written.
    int         i;                      // Loop control.

    _ASSERTE(m_bPreSaveDone);

    // Determine if the stream is "fully compressed", ie no pointer tables.
    *pbSaveCompressed = true;
    for (i=0; i<TBL_COUNT; ++i)
    {
        if (HasIndirectTable(i))
        {
            *pbSaveCompressed = false;
            break;
        }
    }

    // Build the header.
    CMiniMdSchema Schema = m_Schema;
    m_Strings.GetSaveSize(&cbTable);
    if (cbTable > USHRT_MAX)
        Schema.m_heaps |= CMiniMdSchema::HEAP_STRING_4;
    else
        Schema.m_heaps &= ~CMiniMdSchema::HEAP_STRING_4;

    m_Blobs.GetSaveSize(&cbTable);
    if (cbTable > USHRT_MAX)
        Schema.m_heaps |= CMiniMdSchema::HEAP_BLOB_4;
    else
        Schema.m_heaps &= ~CMiniMdSchema::HEAP_BLOB_4;

    m_Guids.GetSaveSize(&cbTable);
    if (cbTable > USHRT_MAX)
        Schema.m_heaps |= CMiniMdSchema::HEAP_GUID_4;
    else
        Schema.m_heaps &= ~CMiniMdSchema::HEAP_GUID_4;

    cbTotal = Schema.SaveTo(SchemaBuf);
    if ( (cbAlign = Align4(cbTotal) - cbTotal) != 0)
        cbTotal += cbAlign;

    // For each table...
    ULONG ixTbl;
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (vGetCountRecs(ixTbl))
        {
            // Determine how big the compressed table will be.

            // Allocate a def for the temporary table.
            sTempTable = m_TableDefs[ixTbl];
#if defined(AUTO_GROW)
            if (m_eGrow == eg_grown)
#endif // AUTO_GROW
            {
                CMiniColDef *pCols=m_TableDefs[ixTbl].m_pColDefs;
                IfFailGo(rTempCols.ReSize(sTempTable.m_cCols));
                sTempTable.m_pColDefs = rTempCols.Ptr();

                // Initialize temp table col defs based on actual counts of data in the
                //  real tables.
                InitColsForTable(Schema, ixTbl, &sTempTable, 1);
            }

            cbTable = sTempTable.m_cbRec * vGetCountRecs(ixTbl);
            cbTotal += cbTable;
        }
    }

    // Pad with at least 2 bytes and align on 4 bytes.
    cbAlign = Align4(cbTotal) - cbTotal;
    if (cbAlign < 2)
        cbAlign += 4;
    cbTotal += cbAlign;

    *pulSaveSize = cbTotal;
    m_cbSaveSize = cbTotal;

ErrExit:
    return hr;
} // STDMETHODIMP CMiniMdRW::GetFullSaveSize()

//*****************************************************************************
// GetSaveSize for saving just the delta (ENC) data.
//*****************************************************************************
HRESULT CMiniMdRW::GetENCSaveSize(          // S_OK or error.
    ULONG       *pulSaveSize)           // [OUT] Put the size here.
{
    HRESULT     hr=S_OK;                // A result.
    CQuickArray<CMiniColDef> rTempCols; // Definition for a temp table's columns.
    BYTE        SchemaBuf[sizeof(CMiniMdSchema)];   //Buffer for compressed schema.
    ULONG       cbAlign;                // Bytes needed for alignment.
    ULONG       cbTable;                // Bytes in a table.
    ULONG       cbTotal;                // Bytes written.
    ULONG       ixTbl;                  // Loop control.

    // If not saving deltas, defer to full GetSaveSize.
    if ((m_OptionValue.m_UpdateMode & MDUpdateDelta) == 0)
    {
        DWORD bCompressed;
        return GetFullSaveSize(cssAccurate, pulSaveSize, &bCompressed);
    }

    // Build the header.
    CMiniMdSchema Schema = m_Schema;
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
        Schema.m_cRecs[ixTbl] = m_rENCRecs[ixTbl].Count();
    Schema.m_cRecs[TBL_Module] = m_Schema.m_cRecs[TBL_Module];
    Schema.m_cRecs[TBL_ENCLog] = m_Schema.m_cRecs[TBL_ENCLog];
    Schema.m_cRecs[TBL_ENCMap] = m_Schema.m_cRecs[TBL_ENCMap];

    cbTotal = Schema.SaveTo(SchemaBuf);
    if ( (cbAlign = Align4(cbTotal) - cbTotal) != 0)
        cbTotal += cbAlign;

    // Accumulate size of each table...
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {   // ENC tables are special.
        if (ixTbl == TBL_ENCLog || ixTbl == TBL_ENCMap || ixTbl == TBL_Module)
            cbTable = m_Schema.m_cRecs[ixTbl] * m_TableDefs[ixTbl].m_cbRec;
        else
            cbTable = Schema.m_cRecs[ixTbl] * m_TableDefs[ixTbl].m_cbRec;
        cbTotal += cbTable;
    }

    // Pad with at least 2 bytes and align on 4 bytes.
    cbAlign = Align4(cbTotal) - cbTotal;
    if (cbAlign < 2)
        cbAlign += 4;
    cbTotal += cbAlign;

    *pulSaveSize = cbTotal;
    m_cbSaveSize = cbTotal;

//ErrExit:
    return hr;
} // STDMETHODIMP CMiniMdRW::GetENCSaveSize()

//*****************************************************************************
// GetSaveSize for saving just the extensions to the tables.
//*****************************************************************************
HRESULT CMiniMdRW::GetExtensionSaveSize(// S_OK or error.
    ULONG       *pulSaveSize)           // [OUT] Put the size here.
{
    HRESULT     hr=S_OK;                // A result.
    CQuickArray<CMiniColDef> rTempCols; // Definition for a temp table's columns.
    BYTE        SchemaBuf[sizeof(CMiniMdSchema)];   //Buffer for compressed schema.
    ULONG       cbAlign;                // Bytes needed for alignment.
    ULONG       cbTable;                // Bytes in a table.
    ULONG       cbTotal;                // Bytes written.
    ULONG       ixTbl;                  // Loop control.

    // No pre-save manipulation of data.

    // Determine which tables will have data.
    CMiniMdSchema Schema = m_Schema;
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
        Schema.m_cRecs[ixTbl] -= m_StartupSchema.m_cRecs[ixTbl];

    // Size of the header.
    cbTotal = Schema.SaveTo(SchemaBuf);
    if ( (cbAlign = Align4(cbTotal) - cbTotal) != 0)
        cbTotal += cbAlign;

    // Size of data in each table...
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        cbTable = m_TableDefs[ixTbl].m_cbRec * Schema.m_cRecs[ixTbl];
        cbTotal += cbTable;
    }

    // Align.
    if ( (cbAlign = Align4(cbTotal) - cbTotal) != 0)
        cbTotal += cbAlign;

    *pulSaveSize = cbTotal;
    m_cbSaveSize = cbTotal;

    return hr;
} // STDMETHODIMP CMiniMdRW::GetExtensionSaveSize()

//*****************************************************************************
// Determine how big the tables would be when saved.
//*****************************************************************************
HRESULT CMiniMdRW::GetSaveSize(         // S_OK or error.
    CorSaveSize fSave,                  // [IN] cssAccurate or cssQuick.
    ULONG       *pulSaveSize,           // [OUT] Put the size here.
    DWORD       *pbSaveCompressed)      // [OUT] Will the saved data be fully compressed?
{
    HRESULT     hr;                     // A result.

    // Prepare the data for save.
    IfFailGo(PreSave());

    switch (m_OptionValue.m_UpdateMode & MDUpdateMask)
    {
    case MDUpdateFull:
        hr = GetFullSaveSize(fSave, pulSaveSize, pbSaveCompressed);
        break;
    case MDUpdateIncremental:
        hr = GetFullSaveSize(fSave, pulSaveSize, pbSaveCompressed);
        // never save compressed if it is incremental compilation.
        *pbSaveCompressed = false;
        break;
    case MDUpdateENC:
        *pbSaveCompressed = false;
        hr = GetENCSaveSize(pulSaveSize);
        break;
    case MDUpdateExtension:
        *pbSaveCompressed = false;
        hr = GetExtensionSaveSize(pulSaveSize);
        break;
    default:
        _ASSERTE(!"Internal error -- unknown save mode");
        return E_INVALIDARG;
    }

ErrExit:
    return hr;
} // STDMETHODIMP CMiniMdRW::GetSaveSize()

//*****************************************************************************
// Determine how big a pool would be when saved full size.
//*****************************************************************************
HRESULT CMiniMdRW::GetFullPoolSaveSize( // S_OK or error.
    int         iPool,                  // The pool of interest.
    ULONG       *pulSaveSize)           // [OUT] Put the size here.
{
    HRESULT     hr;                     // A result.

    switch (iPool)
    {
    case MDPoolStrings:
        hr = m_Strings.GetSaveSize(pulSaveSize);
        break;
    case MDPoolGuids:
        hr = m_Guids.GetSaveSize(pulSaveSize);
        break;
    case MDPoolBlobs:
        hr = m_Blobs.GetSaveSize(pulSaveSize);
        break;
    case MDPoolUSBlobs:
        hr = m_USBlobs.GetSaveSize(pulSaveSize);
        break;
    default:
        hr = E_INVALIDARG;
    }

    return hr;
} // HRESULT CMiniMdRW::GetFullPoolSaveSize()

//*****************************************************************************
// Determine how big a pool would be when saved ENC size.
//*****************************************************************************
HRESULT CMiniMdRW::GetENCPoolSaveSize(  // S_OK or error.
    int         iPool,                  // The pool of interest.
    ULONG       *pulSaveSize)           // [OUT] Put the size here.
{
    //@FUTURE: implement ENC delta.
    return GetFullPoolSaveSize(iPool, pulSaveSize);
} // HRESULT CMiniMdRW::GetENCPoolSaveSize()

//*****************************************************************************
// Determine how big a pool would be when saved Extension size.
//*****************************************************************************
HRESULT CMiniMdRW::GetExtensionPoolSaveSize(    // S_OK or error.
    int         iPool,                  // The pool of interest.
    ULONG       *pulSaveSize)           // [OUT] Put the size here.
{
    ULONG       cbSize;                 // Total size of a pool.

    //@FUTURE: Implement a PartialSaveSize.
    switch (iPool)
    {
    case MDPoolStrings:
        cbSize = m_Strings.GetPoolSize() - m_cbStartupPool[MDPoolStrings];
        break;
    case MDPoolGuids:
        cbSize = m_Guids.GetPoolSize() - m_cbStartupPool[MDPoolGuids];
        break;
    case MDPoolBlobs:
        cbSize = m_Blobs.GetPoolSize() - m_cbStartupPool[MDPoolBlobs];
        break;
    case MDPoolUSBlobs:
        cbSize = m_USBlobs.GetPoolSize() - m_cbStartupPool[MDPoolUSBlobs];
        break;
    default:
        return E_INVALIDARG;
    }

    cbSize = Align4(cbSize);
    *pulSaveSize = cbSize;

    return S_OK;
} // HRESULT CMiniMdRW::GetExtensionPoolSaveSize()

//*****************************************************************************
// Determine how big a pool would be when saved.
//*****************************************************************************
HRESULT CMiniMdRW::GetPoolSaveSize(     // S_OK or error.
    int         iPool,                  // The pool of interest.
    ULONG       *pulSaveSize)           // [OUT] Put the size here.
{
    HRESULT     hr;                     // A result.

    switch (m_OptionValue.m_UpdateMode & MDUpdateMask)
    {
    case MDUpdateFull:
    case MDUpdateIncremental:
        hr = GetFullPoolSaveSize(iPool, pulSaveSize);
        break;
    case MDUpdateENC:
        hr = GetENCPoolSaveSize(iPool, pulSaveSize);
        break;
    case MDUpdateExtension:
        hr = GetExtensionPoolSaveSize(iPool, pulSaveSize);
        break;
    default:
        _ASSERTE(!"Internal error -- unknown save mode");
        return E_INVALIDARG;
    }

    return hr;
} // STDMETHODIMP CMiniMdRW::GetPoolSaveSize()

//*****************************************************************************
// Is the given pool empty?
//*****************************************************************************
int CMiniMdRW::IsPoolEmpty(             // True or false.
    int         iPool)                  // The pool of interest.
{
    switch (iPool)
    {
    case MDPoolStrings:
        return m_Strings.IsEmpty();
    case MDPoolGuids:
        return m_Guids.IsEmpty();
    case MDPoolBlobs:
        return m_Blobs.IsEmpty();
    case MDPoolUSBlobs:
        return m_USBlobs.IsEmpty();
    }
    return true;
} // int CMiniMdRW::IsPoolEmpty()


//*****************************************************************************
// Initialized TokenRemapManager
//*****************************************************************************
HRESULT CMiniMdRW::InitTokenRemapManager()
{
    HRESULT     hr = NOERROR;

    if ( m_pTokenRemapManager == NULL )
    {
        // allocate TokenRemapManager
        m_pTokenRemapManager = new TokenRemapManager;
        IfNullGo(m_pTokenRemapManager);
    }

    // initialize the ref to def optimization map
    IfFailGo( m_pTokenRemapManager->ClearAndEnsureCapacity(m_Schema.m_cRecs[TBL_TypeRef], m_Schema.m_cRecs[TBL_MemberRef]));

ErrExit:
    return hr;
}

//*****************************************************************************
// Perform any available pre-save optimizations.
//*****************************************************************************
HRESULT CMiniMdRW::PreSaveFull()
{
    HRESULT     hr = S_OK;              // A result.
    RID         ridPtr;                 // A RID from a pointer table.

    if (m_bPreSaveDone)
        return hr;

    // Don't yet know what the save size will be.
    m_cbSaveSize = 0;
    m_bSaveCompressed = false;

    // Convert any END_OF_TABLE values for tables with child pointer tables.
    IfFailGo(ConvertMarkerToEndOfTable(TBL_TypeDef,
                                    TypeDefRec::COL_MethodList,
                                    m_Schema.m_cRecs[TBL_Method]+1,
                                    m_Schema.m_cRecs[TBL_TypeDef]));
    IfFailGo(ConvertMarkerToEndOfTable(TBL_TypeDef,
                                    TypeDefRec::COL_FieldList,
                                    m_Schema.m_cRecs[TBL_Field]+1,
                                    m_Schema.m_cRecs[TBL_TypeDef]));
    IfFailGo(ConvertMarkerToEndOfTable(TBL_Method,
                                    MethodRec::COL_ParamList,
                                    m_Schema.m_cRecs[TBL_Param]+1,
                                    m_Schema.m_cRecs[TBL_Method]));
    IfFailGo(ConvertMarkerToEndOfTable(TBL_PropertyMap,
                                    PropertyMapRec::COL_PropertyList,
                                    m_Schema.m_cRecs[TBL_Property]+1,
                                    m_Schema.m_cRecs[TBL_PropertyMap]));
    IfFailGo(ConvertMarkerToEndOfTable(TBL_EventMap,
                                    EventMapRec::COL_EventList,
                                    m_Schema.m_cRecs[TBL_Event]+1,
                                    m_Schema.m_cRecs[TBL_EventMap]));

    // If there is a handler and in "Full" mode, eliminate the intermediate tables.
    if (m_pHandler && (m_OptionValue.m_UpdateMode &MDUpdateMask) == MDUpdateFull)
    {
        // If there is a handler, and not in E&C, save as fully compressed.
        m_bSaveCompressed = true;

        // Temporary tables for new Fields, Methods, Params and FieldLayouts.
        RecordPool NewFields;
        NewFields.InitNew(m_TableDefs[TBL_Field].m_cbRec, m_Schema.m_cRecs[TBL_Field]);
        RecordPool NewMethods;
        NewMethods.InitNew(m_TableDefs[TBL_Method].m_cbRec, m_Schema.m_cRecs[TBL_Method]);
        RecordPool NewParams;
        NewParams.InitNew(m_TableDefs[TBL_Param].m_cbRec, m_Schema.m_cRecs[TBL_Param]);
        RecordPool NewEvents;
        NewEvents.InitNew(m_TableDefs[TBL_Event].m_cbRec, m_Schema.m_cRecs[TBL_Event]);
        RecordPool NewPropertys;
        NewPropertys.InitNew(m_TableDefs[TBL_Property].m_cbRec, m_Schema.m_cRecs[TBL_Property]);

        // If we have any indirect table for Field or Method and we are about to reorder these
        // tables, the MemberDef hash table will be invalid after the token movement. So invalidate
        // the hash.
        if (HasIndirectTable(TBL_Field) && HasIndirectTable(TBL_Method) && m_pMemberDefHash)
        {
            delete m_pMemberDefHash;
            m_pMemberDefHash = NULL;
        }

        // Enumerate fields and copy.
        if (HasIndirectTable(TBL_Field))
        {
            for (ridPtr=1; ridPtr<=m_Schema.m_cRecs[TBL_Field]; ++ridPtr)
            {
                void *pOldPtr = m_Table[TBL_FieldPtr].GetRecord(ridPtr);
                RID ridOld;
                ridOld = GetCol(TBL_FieldPtr, FieldPtrRec::COL_Field, pOldPtr);
                void *pOld = m_Table[TBL_Field].GetRecord(ridOld);
                RID ridNew;
                void *pNew = NewFields.AddRecord(&ridNew);
                IfNullGo(pNew);
                _ASSERTE(ridNew == ridPtr);
                memcpy(pNew, pOld, m_TableDefs[TBL_Field].m_cbRec);

                // Let the caller know of the token change.
                MapToken(ridOld, ridNew, mdtFieldDef);
            }
        }

        // Enumerate methods and copy.
        if (HasIndirectTable(TBL_Method) || HasIndirectTable(TBL_Param))
        {
            for (ridPtr=1; ridPtr<=m_Schema.m_cRecs[TBL_Method]; ++ridPtr)
            {
                MethodRec *pOld;
                void *pNew = NULL;
                if (HasIndirectTable(TBL_Method))
                {
                    void *pOldPtr = m_Table[TBL_MethodPtr].GetRecord(ridPtr);
                    RID ridOld;
                    ridOld = GetCol(TBL_MethodPtr, MethodPtrRec::COL_Method, pOldPtr);
                    pOld = getMethod(ridOld);
                    RID ridNew;
                    pNew = NewMethods.AddRecord(&ridNew);
                    IfNullGo(pNew);
                    _ASSERTE(ridNew == ridPtr);
                    memcpy(pNew, pOld, m_TableDefs[TBL_Method].m_cbRec);

                    // Let the caller know of the token change.
                    MapToken(ridOld, ridNew, mdtMethodDef);
                }
                else
                    pOld = getMethod(ridPtr);

                // Handle the params of the method.
                if (HasIndirectTable(TBL_Method))
                    PutCol(TBL_Method, MethodRec::COL_ParamList, pNew, NewParams.Count()+1);
                RID ixStart = getParamListOfMethod(pOld);
                RID ixEnd = getEndParamListOfMethod(pOld);
                for (; ixStart<ixEnd; ++ixStart)
                {
                    RID     ridParam;
                    if (HasIndirectTable(TBL_Param))
                    {
                        void *pOldPtr = m_Table[TBL_ParamPtr].GetRecord(ixStart);
                        ridParam = GetCol(TBL_ParamPtr, ParamPtrRec::COL_Param, pOldPtr);
                    }
                    else
                        ridParam = ixStart;
                    void *pOld = m_Table[TBL_Param].GetRecord(ridParam);
                    RID ridNew;
                    void *pNew = NewParams.AddRecord(&ridNew);
                    IfNullGo(pNew);
                    memcpy(pNew, pOld, m_TableDefs[TBL_Param].m_cbRec);

                    // Let the caller know of the token change.
                    MapToken(ridParam, ridNew, mdtParamDef);
                }
            }
        }

        // Get rid of EventPtr and PropertyPtr table as well
        // Enumerate fields and copy.
        if (HasIndirectTable(TBL_Event))
        {
            for (ridPtr=1; ridPtr<=m_Schema.m_cRecs[TBL_Event]; ++ridPtr)
            {
                void *pOldPtr = m_Table[TBL_EventPtr].GetRecord(ridPtr);
                RID ridOld;
                ridOld = GetCol(TBL_EventPtr, EventPtrRec::COL_Event, pOldPtr);
                void *pOld = m_Table[TBL_Event].GetRecord(ridOld);
                RID ridNew;
                void *pNew = NewEvents.AddRecord(&ridNew);
                IfNullGo(pNew);
                _ASSERTE(ridNew == ridPtr);
                memcpy(pNew, pOld, m_TableDefs[TBL_Event].m_cbRec);

                // Let the caller know of the token change.
                MapToken(ridOld, ridNew, mdtEvent);
            }
        }

        if (HasIndirectTable(TBL_Property))
        {
            for (ridPtr=1; ridPtr<=m_Schema.m_cRecs[TBL_Property]; ++ridPtr)
            {
                void *pOldPtr = m_Table[TBL_PropertyPtr].GetRecord(ridPtr);
                RID ridOld;
                ridOld = GetCol(TBL_PropertyPtr, PropertyPtrRec::COL_Property, pOldPtr);
                void *pOld = m_Table[TBL_Property].GetRecord(ridOld);
                RID ridNew;
                void *pNew = NewPropertys.AddRecord(&ridNew);
                IfNullGo(pNew);
                _ASSERTE(ridNew == ridPtr);
                memcpy(pNew, pOld, m_TableDefs[TBL_Property].m_cbRec);

                // Let the caller know of the token change.
                MapToken(ridOld, ridNew, mdtProperty);
            }
        }


        // Replace the old tables with the new, sorted ones.
        if (HasIndirectTable(TBL_Field))
            m_Table[TBL_Field].ReplaceContents(&NewFields);
        if (HasIndirectTable(TBL_Method))
            m_Table[TBL_Method].ReplaceContents(&NewMethods);
        if (HasIndirectTable(TBL_Method) || HasIndirectTable(TBL_Param))
            m_Table[TBL_Param].ReplaceContents(&NewParams);
        if (HasIndirectTable(TBL_Property))
            m_Table[TBL_Property].ReplaceContents(&NewPropertys);
        if (HasIndirectTable(TBL_Event))
            m_Table[TBL_Event].ReplaceContents(&NewEvents);

        // Empty the pointer tables table.
        m_Schema.m_cRecs[TBL_FieldPtr] = 0;
        m_Schema.m_cRecs[TBL_MethodPtr] = 0;
        m_Schema.m_cRecs[TBL_ParamPtr] = 0;
        m_Schema.m_cRecs[TBL_PropertyPtr] = 0;
        m_Schema.m_cRecs[TBL_EventPtr] = 0;

        // invalidated the parent look up tables
        if (m_pMethodMap)
        {
            delete m_pMethodMap;
            m_pMethodMap = NULL;
        }
        if (m_pFieldMap)
        {
            delete m_pFieldMap;
            m_pFieldMap = NULL;
        }
        if (m_pPropertyMap)
        {
            delete m_pPropertyMap;
            m_pPropertyMap = NULL;
        }
        if (m_pEventMap)
        {
            delete m_pEventMap;
            m_pEventMap = NULL;
        }
        if (m_pParamMap)
        {
            delete m_pParamMap;
            m_pParamMap = NULL;
        }
    }

    // Do the ref to def fixup before fix up with token movement
    IfFailGo( FixUpRefToDef() );

    //
    // We need to fix up all of the reference to Field, Method, Param, Event and Property
    //
    // Fix up MemberRef's parent, which can be either MethodDef, TypeRef or ModuleRef
    // Fix up the constant's parent, which could be a field or a parameter
    // Fix up FieldMarshal's parent, which could be a field or a a parameter
    // Fix up MethodImpl's Class, MethodBody and MethodDeclaration.
    // Fix up security table's parent, which could be a FieldDef, MethodDef, Parameter, Event, or Property
    // Fix up CustomAttribute table's parent, which could be a FieldDef, MethoDef, Parameter, Event or Property
    // Fix up Property table's BackingField, EventChanging, EventChanged
    // Fix up MethodSemantics' Method and Association.
    // Fix up ImplMap table.
    // Fix up FieldRVA table.
    // Fix up FieldLayout table.
    //
    // Only call to do the fixup if there is any token movement
    //
    if ( GetTokenMovementMap() && GetTokenMovementMap()->Count() )
    {
        IfFailGo( FixUpMemberRefTable() );
        IfFailGo( FixUpMethodSemanticsTable() );
        IfFailGo( FixUpConstantTable() );
        IfFailGo( FixUpFieldMarshalTable() );
        IfFailGo( FixUpMethodImplTable() );
        IfFailGo( FixUpDeclSecurityTable() );
        IfFailGo( FixUpCustomAttributeTable() );
        IfFailGo( FixUpImplMapTable() );
        IfFailGo( FixUpFieldRVATable() );
        IfFailGo( FixUpFieldLayoutTable() );
    }


    // Sort tables for binary searches.
    if ((m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateFull ||
        (m_OptionValue.m_UpdateMode & MDUpdateMask)  == MDUpdateIncremental)
    {
        // Sort tables as required
        //-------------------------------------------------------------------------
        // Module order is preserved
        // TypeRef order is preserved
        // TypeDef order is preserved
        // Field grouped and pointed to by TypeDef
        // Method grouped and pointed to by TypeDef
        // Param grouped and pointed to by Method
        // InterfaceImpl sorted here
        // MemberRef order is preserved
        // Constant sorted here
        // CustomAttribute sorted INCORRECTLY!! here
        // FieldMarshal sorted here
        // DeclSecurity sorted here
        // ClassLayout created in order with TypeDefs
        // FieldLayout grouped and pointed to by ClassLayouts
        // StandaloneSig order is preserved
        // TypeSpec order is preserved
        // EventMap created in order at conversion (by Event Parent)
        // Event sorted by Parent at conversion
        // PropertyMap created in order at conversion (by Property Parent)
        // Property sorted by Parent at conversion
        // MethodSemantics sorted by Association at conversion.
        // MethodImpl sorted here.
        // Sort the constant table by parent.
        // Sort the nested class table by NestedClass.

        // Always sort Constant table
        SORTER(Constant,Parent);
        sortConstant.Sort();

        // Always sort the FieldMarshal table by Parent.
        SORTER(FieldMarshal,Parent);
        sortFieldMarshal.Sort();

        // Always sort the MethodSematics
        SORTER(MethodSemantics,Association);
        sortMethodSemantics.Sort();

        // Always Sort the ClassLayoutTable by parent.
        SORTER(ClassLayout, Parent);
        sortClassLayout.Sort();

        // Always Sort the FieldLayoutTable by parent.
        SORTER(FieldLayout, Field);
        sortFieldLayout.Sort();

        // Always Sort the ImplMap table by the parent.
        SORTER(ImplMap, MemberForwarded);
        sortImplMap.Sort();

        // Always Sort the FieldRVA table by the Field.
        SORTER(FieldRVA, Field);
        sortFieldRVA.Sort();

        // Always Sort the NestedClass table by the NestedClass.
        SORTER(NestedClass, NestedClass);
        sortNestedClass.Sort();

        // Always Sort the MethodImpl table by the Class.
        SORTER(MethodImpl, Class);
        sortMethodImpl.Sort();

        // Some tokens are not moved in ENC mode; only "full" mode.
        if ((m_OptionValue.m_UpdateMode & MDUpdateMask)  == MDUpdateFull)
        {
            RIDMAP      ridmapCustomAttribute;
            RIDMAP      ridmapInterfaceImpl;
            RIDMAP      ridmapDeclSecurity;
            ULONG       i;

            // ensure size is big enough
            IfNullGo(ridmapCustomAttribute.AllocateBlock(m_Schema.m_cRecs[TBL_CustomAttribute] + 1));
            IfNullGo(ridmapInterfaceImpl.AllocateBlock(m_Schema.m_cRecs[TBL_InterfaceImpl] + 1));
            IfNullGo(ridmapDeclSecurity.AllocateBlock(m_Schema.m_cRecs[TBL_DeclSecurity] + 1));

            // initialize the rid map
            for (i=0; i <= m_Schema.m_cRecs[TBL_CustomAttribute] ; i++)
            {
                *(ridmapCustomAttribute.Get(i)) = i;
            }
            for (i=0; i <= m_Schema.m_cRecs[TBL_InterfaceImpl] ; i++)
            {
                *(ridmapInterfaceImpl.Get(i)) = i;
            }
            for (i=0; i <= m_Schema.m_cRecs[TBL_DeclSecurity] ; i++)
            {
                *(ridmapDeclSecurity.Get(i)) = i;
            }

            // Sort the CustomAttribute table by parent.
            SORTER(CustomAttribute,Parent);
            sortCustomAttribute.SetRidMap(&ridmapCustomAttribute);
            sortCustomAttribute.Sort();

            // Sort the InterfaceImpl table by class.
            STABLESORTER(InterfaceImpl,Class);
            sortInterfaceImpl.SetRidMap(&ridmapInterfaceImpl);
            sortInterfaceImpl.Sort();

            // Sort the DeclSecurity table by parent.
            SORTER(DeclSecurity,Parent);
            sortDeclSecurity.SetRidMap(&ridmapDeclSecurity);
            sortDeclSecurity.Sort();


            for (i=1; i <= m_Schema.m_cRecs[TBL_CustomAttribute] ; i++)
            {
                // LOG((LOGMD, "Token %4x  ====>>>> Token %4x\n",
                //  TokenFromRid(ridmapCustomAttribute[i], mdtCustomAttribute),
                //  TokenFromRid(i, mdtCustomAttribute)));
                MapToken(ridmapCustomAttribute[i], i, mdtCustomAttribute);
            }
            for (i=1; i <= m_Schema.m_cRecs[TBL_InterfaceImpl] ; i++)
            {
                // LOG((LOGMD, "Token %4x  ====>>>> Token %4x\n",
                //  TokenFromRid(ridmapInterfaceImpl[i], mdtInterfaceImpl),
                //  TokenFromRid(i, mdtInterfaceImpl)));
                MapToken(ridmapInterfaceImpl[i], i, mdtInterfaceImpl);
            }
            for (i=1; i <= m_Schema.m_cRecs[TBL_DeclSecurity] ; i++)
            {
                // LOG((LOGMD, "Token %4x  ====>>>> Token %4x\n",
                //  TokenFromRid(ridmapDeclSecurity[i], mdtPermission),
                //  TokenFromRid(i, mdtPermission)));
                MapToken(ridmapDeclSecurity[i], i, mdtPermission);
            }

            // clear the RIDMAP
            ridmapCustomAttribute.Clear();
            ridmapInterfaceImpl.Clear();
            ridmapDeclSecurity.Clear();
        }

    //-------------------------------------------------------------------------
    } // enclosing scope required for initialization ("goto" above skips initialization).

#if defined(ORGANIZE_POOLS)
    // Only organize the pools on a full save.
    if ((m_OptionValue.m_UpdateMode & MDUpdateMask)  == MDUpdateFull)
    {
        IfFailGo(m_Guids.OrganizeBegin());
        IfFailGo(m_Strings.OrganizeBegin());
        IfFailGo(m_Blobs.OrganizeBegin());

        // For each table...
        ULONG ixTbl;
        for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
        {
            if (vGetCountRecs(ixTbl))
            {   // Mark each Blob, String, and GUID item.
                // For each row in the data.
                RID rid;
                for (rid=1; rid<=m_Schema.m_cRecs[ixTbl]; ++rid)
                {
                    void *pRow = m_Table[ixTbl].GetRecord(rid);
                    // For each column.
                    for (ULONG ixCol=0; ixCol<m_TableDefs[ixTbl].m_cCols; ++ixCol)
                    {   // If a heaped type...
                        switch (m_TableDefs[ixTbl].m_pColDefs[ixCol].m_Type)
                        {
                        case iSTRING:
                            m_Strings.OrganizeMark(GetCol(ixTbl, ixCol, pRow));
                            break;
                        case iGUID:
                            m_Guids.OrganizeMark(GetCol(ixTbl, ixCol, pRow));
                            break;
                        case iBLOB:
                            m_Blobs.OrganizeMark(GetCol(ixTbl, ixCol, pRow));
                            break;
                        default:
                             break;
                        }
                    } // for (ixCol...
                } // for (rid...
            } // if (vGetCountRecs()...
        } // for (ixTbl...

        IfFailGo(m_Guids.OrganizePool());
        IfFailGo(m_Strings.OrganizePool());
        IfFailGo(m_Blobs.OrganizePool());
    }
#endif // defined(ORGANIZE_POOLS)

    m_bPreSaveDone = true;

    // send the Ref->Def optmization notification to host
    if ( m_pHandler )
    {
        TOKENMAP *ptkmap = GetMemberRefToMemberDefMap();
        MDTOKENMAP *ptkRemap = GetTokenMovementMap();
        int     iCount = m_Schema.m_cRecs[TBL_MemberRef];
        mdToken tkTo;
        mdToken tkDefTo;
        int     i;
        MemberRefRec *pMemberRefRec;        // A MemberRefRec.
        const COR_SIGNATURE *pvSig;         // Signature of the MemberRef.
        ULONG       cbSig;                  // Size of the signature blob.

        // loop through all LocalVar
        for (i = 1; i <= iCount; i++)
        {
            tkTo = *(ptkmap->Get(i));
            if ( RidFromToken(tkTo) != mdTokenNil)
            {
                // so far, the parent of memberref can be changed to only fielddef or methoddef
                // or it will remain unchanged.
                //
                _ASSERTE( TypeFromToken(tkTo) == mdtFieldDef || TypeFromToken(tkTo) == mdtMethodDef );

                pMemberRefRec = getMemberRef(i);
                pvSig = getSignatureOfMemberRef(pMemberRefRec, &cbSig);

                // Don't turn mr's with vararg's into defs, because the variable portion
                // of the call is kept in the mr signature.
                if (pvSig && isCallConv(*pvSig, IMAGE_CEE_CS_CALLCONV_VARARG))
                    continue;

                // ref is optimized to the def

                // now remap the def since def could be moved again.
                tkDefTo = ptkRemap->SafeRemap(tkTo);

                // when Def token moves, it will not change type!!
                _ASSERTE( TypeFromToken(tkTo) == TypeFromToken(tkDefTo) );
                LOG((LOGMD, "MapToken (remap): from 0x%08x to 0x%08x\n", TokenFromRid(i, mdtMemberRef), tkDefTo));
                m_pHandler->Map(TokenFromRid(i, mdtMemberRef), tkDefTo);
            }
        }
    }
ErrExit:

    return hr;
} // HRESULT CMiniMdRW::PreSaveFull()

//*****************************************************************************
// ENC-specific pre-safe work.
//*****************************************************************************
HRESULT CMiniMdRW::PreSaveEnc()
{
    HRESULT     hr;
    int         iNew;                   // Insertion point for new tokens.
    ULONG       *pul;                   // Found token.
    ULONG       iRid;                   // RID from a token.
    ULONG       ixTbl;                  // Table from an ENC record.
    ULONG       cRecs;                  // Count of records in a table.

    IfFailGo(PreSaveFull());

    // Turn off pre-save bit so that we can add ENC map records.
    m_bPreSaveDone = false;

    if (m_Schema.m_cRecs[TBL_ENCLog])
    {   // Keep track of ENC recs we've seen.
        _ASSERTE(m_rENCRecs == 0);
        m_rENCRecs = new ULONGARRAY[TBL_COUNT];
        IfNullGo(m_rENCRecs);

        // Create the temporary table.
        RecordPool TempTable;
        IfFailGo(TempTable.InitNew(m_TableDefs[TBL_ENCLog].m_cbRec, m_Schema.m_cRecs[TBL_ENCLog]));

        // For each row in the data.
        RID     rid;
        ULONG   iKept=0;
        for (rid=1; rid<=m_Schema.m_cRecs[TBL_ENCLog]; ++rid)
        {
            ENCLogRec *pFrom = reinterpret_cast<ENCLogRec*>(m_Table[TBL_ENCLog].GetRecord(rid));

            // Keep this record?
            if (pFrom->m_FuncCode == 0)
            {   // No func code.  Skip if we've seen this token before.

                // What kind of record is this?
                if (IsRecId(pFrom->m_Token))
                {   // Non-token table
                    iRid = RidFromRecId(pFrom->m_Token);
                    ixTbl = TblFromRecId(pFrom->m_Token);
                }
                else
                {   // Token table.
                    iRid = RidFromToken(pFrom->m_Token);
                    ixTbl = GetTableForToken(pFrom->m_Token);

                }

                CBinarySearch<ULONG> searcher(m_rENCRecs[ixTbl].Ptr(), m_rENCRecs[ixTbl].Count());
                pul = const_cast<ULONG*>(searcher.Find(&iRid, &iNew));
                // If we found the token, don't keep the record.
                if (pul != 0)
                {
                    LOG((LOGMD, "PreSave ENCLog skipping duplicate token %d", pFrom->m_Token));
                    continue;
                }
                // First time token was seen, so keep track of it.
                IfNullGo(pul = m_rENCRecs[ixTbl].Insert(iNew));
                *pul = iRid;
            }

            // Keeping the record, so allocate the new record to hold it.
            ++iKept;
            RID ridNew;
            ENCLogRec *pTo = reinterpret_cast<ENCLogRec*>(TempTable.AddRecord(&ridNew));
            IfNullGo(pTo);
            _ASSERTE(ridNew == iKept);

            // copy the data.
            *pTo = *pFrom;
        }

        // Keep the expanded table.
        IfFailGo(m_Table[TBL_ENCLog].ReplaceContents(&TempTable));
        m_Schema.m_cRecs[TBL_ENCLog] = iKept;

        // If saving only deltas, build the ENC Map table.
        if ((m_OptionValue.m_UpdateMode & MDUpdateDelta))
        {
            cRecs = 0;
            for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
                cRecs += m_rENCRecs[ixTbl].Count();
            m_Table[TBL_ENCMap].Uninit();
            IfFailGo(m_Table[TBL_ENCMap].InitNew(m_TableDefs[TBL_ENCMap].m_cbRec, cRecs));
            cRecs = 0;
            for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
            {
                ENCMapRec *pNew;
                ULONG iNew;
                for (int i=0; i<m_rENCRecs[ixTbl].Count(); ++i)
                {
                    pNew = AddENCMapRecord(&iNew); // pre-allocated for all rows.
                    _ASSERTE(iNew == ++cRecs);
                    pNew->m_Token = RecIdFromRid(m_rENCRecs[ixTbl][i], ixTbl);
                }
            }
        }
    }

    // Turn pre-save bit back on.
    m_bPreSaveDone = true;
    
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::PreSaveEnc()

HRESULT CMiniMdRW::PreSaveExtension()
{
    HRESULT     hr;

    IfFailGo(PreSaveFull());

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::PreSaveExtension()

//*****************************************************************************
// Perform any appropriate pre-save optimization or reorganization.
//*****************************************************************************
HRESULT CMiniMdRW::PreSave()            // S_OK or error.
{
    HRESULT     hr=S_OK;                // A result.

#ifdef _DEBUG        
	if (REGUTIL::GetConfigDWORD(L"MD_PreSaveBreak", 0))
	{
        _ASSERTE(!"CMiniMdRW::PreSave()");
	}
#endif // _DEBUG

    if (m_bPreSaveDone)
        return hr;

    switch (m_OptionValue.m_UpdateMode & MDUpdateMask)
    {
    case MDUpdateFull:
    case MDUpdateIncremental:
        hr = PreSaveFull();
        break;
    case MDUpdateENC:
        hr = PreSaveEnc();
        break;
    case MDUpdateExtension:
        hr = PreSaveExtension();
        break;
    default:
        _ASSERTE(!"Internal error -- unknown save mode");
        return E_INVALIDARG;
    }

    return hr;
} // STDMETHODIMP CMiniMdRW::PreSave()

//*****************************************************************************
// Perform any necessary post-save cleanup.
//*****************************************************************************
HRESULT CMiniMdRW::PostSave()
{
    // Return the pools to normal operating state.
    if (m_bPreSaveDone)
    {
#if defined(ORGANIZE_POOLS)
        if ((m_OptionValue.m_UpdateMode & MDUpdateMask)  == MDUpdateFull)
        {
            m_Strings.OrganizeEnd();
            m_Guids.OrganizeEnd();
            m_Blobs.OrganizeEnd();
        }
#endif // defined(ORGANIZE_POOLS)
    }

    if (m_rENCRecs)
    {
        delete [] m_rENCRecs;
        m_rENCRecs = 0;
    }

    m_bPreSaveDone = false;

    return S_OK;
} // HRESULT CMiniMdRW::PostSave()

//*****************************************************************************
// Save the tables to the stream.
//*****************************************************************************
HRESULT CMiniMdRW::SaveFullTablesToStream(
    IStream     *pIStream)
{
    HRESULT     hr;                     // A result.
    CMiniTableDef   sTempTable;         // Definition for a temporary table.
    CQuickArray<CMiniColDef> rTempCols; // Definition for a temp table's columns.
    BYTE        SchemaBuf[sizeof(CMiniMdSchema)];   //Buffer for compressed schema.
    ULONG       cbAlign;                // Bytes needed for alignment.
    ULONG       cbTable;                // Bytes in a table.
    ULONG       cbTotal;                // Bytes written.
    static const unsigned char zeros[8] = {0}; // For padding and alignment.

    // Write the header.
    CMiniMdSchema Schema = m_Schema;
    m_Strings.GetSaveSize(&cbTable);
    if (cbTable > USHRT_MAX)
        Schema.m_heaps |= CMiniMdSchema::HEAP_STRING_4;
    else
        Schema.m_heaps &= ~CMiniMdSchema::HEAP_STRING_4;

    m_Guids.GetSaveSize(&cbTable);
    if (cbTable > USHRT_MAX)
        Schema.m_heaps |= CMiniMdSchema::HEAP_GUID_4;
    else
        Schema.m_heaps &= ~CMiniMdSchema::HEAP_GUID_4;

    m_Blobs.GetSaveSize(&cbTable);
    if (cbTable > USHRT_MAX)
        Schema.m_heaps |= CMiniMdSchema::HEAP_BLOB_4;
    else
        Schema.m_heaps &= ~CMiniMdSchema::HEAP_BLOB_4;

    cbTotal = Schema.SaveTo(SchemaBuf);
    IfFailGo(pIStream->Write(SchemaBuf, cbTotal, 0));
    if ( (cbAlign = Align4(cbTotal) - cbTotal) != 0)
        IfFailGo(pIStream->Write(&hr, cbAlign, 0));
    cbTotal += cbAlign;

    // For each table...
    ULONG ixTbl;
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (vGetCountRecs(ixTbl))
        {
            // Compress the records by allocating a new, temporary, table and
            //  copying the rows from the one to the new.

#if defined(AUTO_GROW)
            // If the table was grown, shrink it as much as possible.
            if (m_eGrow == eg_grown)
#endif
            {

                // Allocate a def for the temporary table.
                sTempTable = m_TableDefs[ixTbl];
                CMiniColDef *pCols=m_TableDefs[ixTbl].m_pColDefs;
                IfFailGo(rTempCols.ReSize(sTempTable.m_cCols));
                sTempTable.m_pColDefs = rTempCols.Ptr();

                // Initialize temp table col defs based on actual counts of data in the
                //  real tables.
                InitColsForTable(Schema, ixTbl, &sTempTable, 1);

                // Create the temporary table.
                RecordPool TempTable;
                TempTable.InitNew(sTempTable.m_cbRec, m_Schema.m_cRecs[ixTbl]);

                // For each row in the data.
                RID rid;
                for (rid=1; rid<=m_Schema.m_cRecs[ixTbl]; ++rid)
                {
                    RID ridNew;
                    void *pRow = m_Table[ixTbl].GetRecord(rid);
                    void *pNew = TempTable.AddRecord(&ridNew);
                    _ASSERTE(rid == ridNew);

                    // For each column.
                    for (ULONG ixCol=0; ixCol<sTempTable.m_cCols; ++ixCol)
                    {
                        // Copy the data to the temp table.
                        ULONG ulVal = GetCol(ixTbl, ixCol, pRow);
#if defined(ORGANIZE_POOLS)
                        //@FUTURE: pool remap.
                        switch (m_TableDefs[ixTbl].m_pColDefs[ixCol].m_Type)
                        {
                        case iSTRING:
                            IfFailGo(m_Strings.OrganizeRemap(ulVal, &ulVal));
                            break;
                        case iGUID:
                            IfFailGo(m_Guids.OrganizeRemap(ulVal, &ulVal));
                            break;
                        case iBLOB:
                            IfFailGo(m_Blobs.OrganizeRemap(ulVal, &ulVal));
                            break;
                        default:
                             break;
                        }
#endif // defined(ORGANIZE_POOLS)
                        PutCol(rTempCols[ixCol], pNew, ulVal);
                    }
                }           // Persist the temp table to the stream.
                TempTable.GetSaveSize(&cbTable);
                _ASSERTE(cbTable == sTempTable.m_cbRec * vGetCountRecs(ixTbl));
                cbTotal += cbTable;
                IfFailGo(TempTable.PersistToStream(pIStream));
            }
#if defined(AUTO_GROW)
            else
            {   // Didn't grow, so just persist directly to stream.
                m_Table[ixTbl].GetSaveSize(&cbTable);
                _ASSERTE(cbTable == m_TableDefs[ixTbl].m_cbRec * vGetCountRecs(ixTbl));
                cbTotal += cbTable;
                IfFailGo(m_Table[ixTbl].PersistToStream(pIStream));
            }
#endif // AUTO_GROW
        }
    }

    // Pad with at least 2 bytes and align on 4 bytes.
    cbAlign = Align4(cbTotal) - cbTotal;
    if (cbAlign < 2)
        cbAlign += 4;
    IfFailGo(pIStream->Write(zeros, cbAlign, 0));
    cbTotal += cbAlign;
    _ASSERTE(m_cbSaveSize == 0 || m_cbSaveSize == cbTotal);

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::SaveFullTablesToStream()

//*****************************************************************************
// Save the tables to the stream.
//*****************************************************************************
HRESULT CMiniMdRW::SaveENCTablesToStream(
    IStream     *pIStream)
{
    HRESULT     hr;                     // A result.
    CQuickArray<CMiniColDef> rTempCols; // Definition for a temp table's columns.
    BYTE        SchemaBuf[sizeof(CMiniMdSchema)];   //Buffer for compressed schema.
    ULONG       cbAlign;                // Bytes needed for alignment.
    ULONG       cbTable;                // Bytes in a table.
    ULONG       cbTotal;                // Bytes written.
    ULONG       ixTbl;                  // Table counter.
    static const unsigned char zeros[8] = {0}; // For padding and alignment.

    // If not deltas, defer to full save.
    if ((m_OptionValue.m_UpdateMode & MDUpdateDelta) == 0)
        return SaveFullTablesToStream(pIStream);

    // Write the header.
    CMiniMdSchema Schema = m_Schema;
    Schema.m_heaps |= CMiniMdSchema::DELTA_ONLY;
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
        Schema.m_cRecs[ixTbl] = m_rENCRecs[ixTbl].Count();
    Schema.m_cRecs[TBL_Module] = m_Schema.m_cRecs[TBL_Module];
    Schema.m_cRecs[TBL_ENCLog] = m_Schema.m_cRecs[TBL_ENCLog];
    Schema.m_cRecs[TBL_ENCMap] = m_Schema.m_cRecs[TBL_ENCMap];

    cbTotal = Schema.SaveTo(SchemaBuf);
    IfFailGo(pIStream->Write(SchemaBuf, cbTotal, 0));
    if ( (cbAlign = Align4(cbTotal) - cbTotal) != 0)
        IfFailGo(pIStream->Write(&hr, cbAlign, 0));
    cbTotal += cbAlign;

    // For each table...
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (ixTbl == TBL_ENCLog || ixTbl == TBL_ENCMap || ixTbl == TBL_Module)
        {
            if (m_Schema.m_cRecs[ixTbl] == 0)
                continue; // pretty strange if ENC has no enc data.
            // Persist the ENC table.
            m_Table[ixTbl].GetSaveSize(&cbTable);
            _ASSERTE(cbTable == m_TableDefs[ixTbl].m_cbRec * m_Schema.m_cRecs[ixTbl]);
            cbTotal += cbTable;
            IfFailGo(m_Table[ixTbl].PersistToStream(pIStream));
        }
        else
        if (Schema.m_cRecs[ixTbl])
        {
            // Copy just the delta records.

            // Create the temporary table.
            RecordPool TempTable;
            TempTable.InitNew(m_TableDefs[ixTbl].m_cbRec, Schema.m_cRecs[ixTbl]);

            // For each row in the data.
            RID rid;
            for (ULONG iDelta=0; iDelta<Schema.m_cRecs[ixTbl]; ++iDelta)
            {
                RID ridNew;
                rid = m_rENCRecs[ixTbl][iDelta];
                void *pRow = m_Table[ixTbl].GetRecord(rid);
                void *pNew = TempTable.AddRecord(&ridNew);
                _ASSERTE(iDelta+1 == ridNew);

                memcpy(pNew, pRow, m_TableDefs[ixTbl].m_cbRec);
            }
            // Persist the temp table to the stream.
            TempTable.GetSaveSize(&cbTable);
            _ASSERTE(cbTable == m_TableDefs[ixTbl].m_cbRec * Schema.m_cRecs[ixTbl]);
            cbTotal += cbTable;
            IfFailGo(TempTable.PersistToStream(pIStream));
        }
    }

    // Pad with at least 2 bytes and align on 4 bytes.
    cbAlign = Align4(cbTotal) - cbTotal;
    if (cbAlign < 2)
        cbAlign += 4;
    IfFailGo(pIStream->Write(zeros, cbAlign, 0));
    cbTotal += cbAlign;
    _ASSERTE(m_cbSaveSize == 0 || m_cbSaveSize == cbTotal);

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::SaveENCTablesToStream()

//*****************************************************************************
// Save the tables to the stream.
//*****************************************************************************
HRESULT CMiniMdRW::SaveExtensionTablesToStream(
    IStream     *pIStream)
{
    HRESULT     hr;                     // A result.
    CQuickArray<CMiniColDef> rTempCols; // Definition for a temp table's columns.
    BYTE        SchemaBuf[sizeof(CMiniMdSchema)];   //Buffer for compressed schema.
    ULONG       cbAlign;                // Bytes needed for alignment.
    ULONG       cbTable;                // Bytes in a table.
    ULONG       cbSkip;                 // Bytes to skip in a table.
    ULONG       cbTotal;                // Bytes written.
    ULONG       ixTbl;                  // Loop control.

    // Write the header. Determine which tables will have data.
    CMiniMdSchema Schema = m_Schema;
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
        Schema.m_cRecs[ixTbl] -= m_StartupSchema.m_cRecs[ixTbl];

    cbTotal = Schema.SaveTo(SchemaBuf);
    IfFailGo(pIStream->Write(SchemaBuf, cbTotal, 0));
    if ( (cbAlign = Align4(cbTotal) - cbTotal) != 0)
        IfFailGo(pIStream->Write(&hr, cbAlign, 0));
    cbTotal += cbAlign;

    // For each table...
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        if (Schema.m_cRecs[ixTbl])
        {   // Sanity check on table size.
            m_Table[ixTbl].GetSaveSize(&cbTable);
            _ASSERTE(cbTable == m_TableDefs[ixTbl].m_cbRec * m_Schema.m_cRecs[ixTbl]);
            // But we're saving only part of the table.
            cbSkip = m_StartupSchema.m_cRecs[ixTbl] * m_TableDefs[ixTbl].m_cbRec;
            cbTable -= cbSkip;
            IfFailGo(m_Table[ixTbl].PersistPartialToStream(pIStream, cbSkip));
            cbTotal += cbTable;
        }
    }

    // Align.
    if ( (cbAlign = Align4(cbTotal) - cbTotal) != 0)
        IfFailGo(pIStream->Write(&hr, cbAlign, 0));
    cbTotal += cbAlign;
    _ASSERTE(m_cbSaveSize == 0 || m_cbSaveSize == cbTotal);

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::SaveExtensionTablesToStream()

//*****************************************************************************
// Save the tables to the stream.
//*****************************************************************************
HRESULT CMiniMdRW::SaveTablesToStream(
    IStream     *pIStream)              // The stream.
{
    HRESULT     hr;                     // A result.

    // Prepare the data for save.
    IfFailGo(PreSave());

    switch (m_OptionValue.m_UpdateMode & MDUpdateMask)
    {
    case MDUpdateFull:
    case MDUpdateIncremental:
        hr = SaveFullTablesToStream(pIStream);
        break;
    case MDUpdateENC:
        hr = SaveENCTablesToStream(pIStream);
        break;
    case MDUpdateExtension:
        hr = SaveExtensionTablesToStream(pIStream);
        break;
    default:
        _ASSERTE(!"Internal error -- unknown save mode");
        return E_INVALIDARG;
    }

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::SaveTablesToStream()

//*****************************************************************************
// Save a full pool to the stream.
//*****************************************************************************
HRESULT CMiniMdRW::SaveFullPoolToStream(
    int         iPool,                  // The pool.
    IStream     *pIStream)              // The stream.
{
    HRESULT     hr;                     // A result.

    switch (iPool)
    {
    case MDPoolStrings:
        hr = m_Strings.PersistToStream(pIStream);
        break;
    case MDPoolGuids:
        hr = m_Guids.PersistToStream(pIStream);
        break;
    case MDPoolBlobs:
        hr = m_Blobs.PersistToStream(pIStream);
        break;
    case MDPoolUSBlobs:
        hr = m_USBlobs.PersistToStream(pIStream);
        break;
    default:
        hr = E_INVALIDARG;
    }

    return hr;
} // HRESULT CMiniMdRW::SaveFullPoolToStream()

//*****************************************************************************
// Save a ENC pool to the stream.
//*****************************************************************************
HRESULT CMiniMdRW::SaveENCPoolToStream(
    int         iPool,                  // The pool.
    IStream     *pIStream)              // The stream.
{
    return SaveFullPoolToStream(iPool, pIStream);
} // HRESULT CMiniMdRW::SaveENCPoolToStream()

//*****************************************************************************
// Save a Extension pool to the stream.
//*****************************************************************************
HRESULT CMiniMdRW::SaveExtensionPoolToStream(
    int         iPool,                  // The pool.
    IStream     *pIStream)              // The stream.
{
    HRESULT     hr;                     // A result.

    switch (iPool)
    {
    case MDPoolStrings:
        hr = m_Strings.PersistPartialToStream(pIStream, m_cbStartupPool[MDPoolStrings]);
        break;
    case MDPoolGuids:
        hr = m_Guids.PersistPartialToStream(pIStream, m_cbStartupPool[MDPoolGuids]);
        break;
    case MDPoolBlobs:
        hr = m_Blobs.PersistPartialToStream(pIStream, m_cbStartupPool[MDPoolBlobs]);
        break;
    case MDPoolUSBlobs:
        hr = m_USBlobs.PersistPartialToStream(pIStream, m_cbStartupPool[MDPoolUSBlobs]);
        break;
    default:
        hr = E_INVALIDARG;
    }

    return hr;
} // HRESULT CMiniMdRW::SaveExtensionPoolToStream()

//*****************************************************************************
// Save a pool to the stream.
//*****************************************************************************
HRESULT CMiniMdRW::SavePoolToStream(    // S_OK or error.
    int         iPool,                  // The pool.
    IStream     *pIStream)              // The stream.
{
    HRESULT     hr;                     // A result.
    switch (m_OptionValue.m_UpdateMode & MDUpdateMask)
    {
    case MDUpdateFull:
    case MDUpdateIncremental:
        hr = SaveFullPoolToStream(iPool, pIStream);
        break;
    case MDUpdateENC:
        hr = SaveENCPoolToStream(iPool, pIStream);
        break;
    case MDUpdateExtension:
        hr = SaveExtensionPoolToStream(iPool, pIStream);
        break;
    default:
        _ASSERTE(!"Internal error -- unknown save mode");
        return E_INVALIDARG;
    }

    return hr;
} // HRESULT CMiniMdRW::SavePoolToStream()

//*****************************************************************************
// Expand a table from the initial (hopeful) 2-byte column sizes to the large
//  (but always adequate) 4-byte column sizes.
//*****************************************************************************
HRESULT CMiniMdRW::ExpandTables()
{
    HRESULT     hr;                     // A result.
    CMiniMdSchema   Schema;             // Temp schema by which to build tables.
    ULONG       ixTbl;                  // Table counter.

    // Allow function to be called many times.
    if (m_eGrow == eg_grown)
        return (S_OK);

    // OutputDebugStringA("Growing tables to large size.\n");

    // Make pool indices the large size.
    Schema.m_heaps = 0;
    Schema.m_heaps |= CMiniMdSchema::HEAP_STRING_4;
    Schema.m_heaps |= CMiniMdSchema::HEAP_GUID_4;
    Schema.m_heaps |= CMiniMdSchema::HEAP_BLOB_4;

    // Make Row counts the large size.
    memset(Schema.m_cRecs, 0, sizeof(Schema.m_cRecs));
    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
        Schema.m_cRecs[ixTbl] = USHRT_MAX+1;

    // Compute how many bits required to hold a rid.
    Schema.m_rid = 16;

    for (ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
    {
        IfFailGo(ExpandTableColumns(Schema, ixTbl));
    }

    // Things are bigger now.
    m_Schema.m_rid = 16;
    m_Schema.m_heaps |= CMiniMdSchema::HEAP_STRING_4;
    m_Schema.m_heaps |= CMiniMdSchema::HEAP_GUID_4;
    m_Schema.m_heaps |= CMiniMdSchema::HEAP_BLOB_4;
    m_iStringsMask = 0xffffffff;
    m_iGuidsMask = 0xffffffff;
    m_iBlobsMask = 0xffffffff;

    // Remember that we've grown.
    m_eGrow = eg_grown;

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::ExpandTables()

//*****************************************************************************
// Expand the sizes of a tables columns according to a new schema.  When this
//  happens, all RID and Pool index columns expand from 2 to 4 bytes.
//*****************************************************************************
HRESULT CMiniMdRW::ExpandTableColumns(
    CMiniMdSchema &Schema,
    ULONG       ixTbl)
{
    HRESULT     hr;                     // A result.
    CMiniTableDef   sTempTable;         // Definition for a temporary table.
    CQuickArray<CMiniColDef> rTempCols; // Definition for a temp table's columns.
    ULONG       ixCol;                  // Column counter.
    ULONG       cbFixed;                // Count of bytes that don't move.
    CMiniColDef *pFromCols;             // Definitions of "from" columns.
    CMiniColDef *pToCols;               // Definitions of "To" columns.
    ULONG       cMoveCols;              // Count of columns to move.
    ULONG       cFixedCols;             // Count of columns to move.

    // Allocate a def for the temporary table.
    sTempTable = m_TableDefs[ixTbl];
    IfFailGo(rTempCols.ReSize(sTempTable.m_cCols));
    sTempTable.m_pColDefs = rTempCols.Ptr();

    // Initialize temp table col defs based on counts of data in the tables.
    InitColsForTable(Schema, ixTbl, &sTempTable, 1);

    if (vGetCountRecs(ixTbl))
    {
        // Analyze the column definitions to determine the unchanged vs changed parts.
        cbFixed = 0;
        for (ixCol=0; ixCol<sTempTable.m_cCols; ++ixCol)
        {
            if (sTempTable.m_pColDefs[ixCol].m_oColumn != m_TableDefs[ixTbl].m_pColDefs[ixCol].m_oColumn ||
                    sTempTable.m_pColDefs[ixCol].m_cbColumn != m_TableDefs[ixTbl].m_pColDefs[ixCol].m_cbColumn)
                break;
            cbFixed += sTempTable.m_pColDefs[ixCol].m_cbColumn;
        }
        if (ixCol == sTempTable.m_cCols)
        {
            // no column is changing. We are done.
            goto ErrExit;
        }
        cFixedCols = ixCol;
        pFromCols = &m_TableDefs[ixTbl].m_pColDefs[ixCol];
        pToCols   = &sTempTable.m_pColDefs[ixCol];
        cMoveCols = sTempTable.m_cCols - ixCol;
        for (; ixCol<sTempTable.m_cCols; ++ixCol)
        {
            _ASSERTE(sTempTable.m_pColDefs[ixCol].m_cbColumn == 4);
        }

        // Create the temporary table.
        RecordPool TempTable;
        TempTable.InitNew(sTempTable.m_cbRec, m_Schema.m_cRecs[ixTbl] * 2);

        // For each row in the data.
        RID		rid;				// Row iterator.
		void	*pContext;			// Context for fast iteration.
		// Get first source record.
		BYTE *pFrom = reinterpret_cast<BYTE*>(m_Table[ixTbl].GetFirstRecord(&pContext));

        for (rid=1; rid<=m_Schema.m_cRecs[ixTbl]; ++rid)
        {
            RID ridNew;
            BYTE *pTo = reinterpret_cast<BYTE*>(TempTable.AddRecord(&ridNew));
            _ASSERTE(rid == ridNew);

            // Move the fixed part.
            memcpy(pTo, pFrom, cbFixed);

            // Expand the expanded parts.
            for (ixCol=0; ixCol<cMoveCols; ++ixCol)
            {
                if ( m_TableDefs[ixTbl].m_pColDefs[cFixedCols + ixCol].m_cbColumn == sizeof(USHORT))
                    *(ULONG*)(pTo + pToCols[ixCol].m_oColumn) = *(USHORT*)(pFrom + pFromCols[ixCol].m_oColumn);
                else
                    *(ULONG*)(pTo + pToCols[ixCol].m_oColumn) = *(ULONG*)(pFrom + pFromCols[ixCol].m_oColumn);
            }

			// Next source record.
			pFrom = reinterpret_cast<BYTE*>(m_Table[ixTbl].GetNextRecord(pFrom, &pContext));
        }

        // Keep the expanded table.
        m_Table[ixTbl].ReplaceContents(&TempTable);
    }
    else
    {   // No data, so just reinitialize.
        m_Table[ixTbl].Uninit();
        IfFailGo(m_Table[ixTbl].InitNew(sTempTable.m_cbRec, g_TblSizeInfo[0][ixTbl]));
    }

    // Keep the new column defs.
    for (ixCol=0; ixCol<sTempTable.m_cCols; ++ixCol)
        m_TableDefs[ixTbl].m_pColDefs[ixCol] = sTempTable.m_pColDefs[ixCol];
    m_TableDefs[ixTbl].m_cbRec = sTempTable.m_cbRec;

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::ExpandTableColumns()


//*****************************************************************************
// Used by caller to let us know save is completed.
//*****************************************************************************
HRESULT CMiniMdRW::SaveDone()
{
    PostSave();

    return S_OK;
} // HRESULT CMiniMdRW::SaveDone()

//*****************************************************************************
// General post-token-move table fixup.
//*****************************************************************************
HRESULT CMiniMdRW::FixUpTable(
    ULONG       ixTbl)                  // Index of table to fix.
{
    HRESULT     hr = S_OK;              // A result.
    ULONG       i, j;                   // Loop control.
    ULONG       cRows;                  // Count of rows in table.
    void        *pRec;                  // Pointer to row data.
    mdToken     tk;                     // A token.
    ULONG       rCols[16];              // List of columns with token data.
    ULONG       cCols;                  // Count of columns with token data.

    // If no remaps, nothing to do.
    if (GetTokenMovementMap() == NULL)
        return S_OK;

    // Find the columns with token data.
    cCols = 0;
    for (i=0; i<m_TableDefs[ixTbl].m_cCols; ++i)
    {
        if (m_TableDefs[ixTbl].m_pColDefs[i].m_Type <= iCodedTokenMax)
            rCols[cCols++] = i;
    }
    _ASSERTE(cCols);
    if (cCols == 0)
        return S_OK;

    cRows = m_Schema.m_cRecs[ixTbl];

    // loop through all Rows
    for (i = 1; i<=cRows; ++i)
    {
        pRec = getMemberRef(i);
        for (j=0; j<cCols; ++j)
        {
            tk = GetToken(ixTbl, rCols[j], pRec);
            tk = GetTokenMovementMap()->SafeRemap(tk);
            IfFailGo(PutToken(ixTbl, rCols[j], pRec, tk));
        }
    }

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FixUpTable()

//*****************************************************************************
// Fixup MemberRef table with token movement
//*****************************************************************************
HRESULT CMiniMdRW::FixUpMemberRefTable()
{
    ULONG       i;
    ULONG       iCount;
    MemberRefRec *pRecEmit;
    HRESULT     hr = NOERROR;
    mdToken     tk;

    if (GetTokenMovementMap() == NULL)
        return NOERROR;

    iCount = m_Schema.m_cRecs[TBL_MemberRef];

    // loop through all LocalVar
    for (i = 1; i <= iCount; i++)
    {
        pRecEmit = getMemberRef(i);
        tk = getClassOfMemberRef(pRecEmit);
        IfFailGo( PutToken(TBL_MemberRef, MemberRefRec::COL_Class, pRecEmit, GetTokenMovementMap()->SafeRemap(tk)) );
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FixUpMemberRefTable()


//*****************************************************************************
// Fixup Constant table with token movement
//*****************************************************************************
HRESULT CMiniMdRW::FixUpConstantTable()
{
    ULONG       i;
    ULONG       iCount;
    ConstantRec *pRecEmit;
    HRESULT     hr = NOERROR;
    mdToken     tk;

    if (GetTokenMovementMap() == NULL)
        return NOERROR;

    iCount = m_Schema.m_cRecs[TBL_Constant];

    // loop through all LocalVar
    for (i = 1; i <= iCount; i++)
    {
        pRecEmit = getConstant(i);
        tk = getParentOfConstant(pRecEmit);
        IfFailGo( PutToken(TBL_Constant, ConstantRec::COL_Parent, pRecEmit, GetTokenMovementMap()->SafeRemap(tk)) );
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FixUpConstantTable()

//*****************************************************************************
// Fixup FieldMarshal table with token movement
//*****************************************************************************
HRESULT CMiniMdRW::FixUpFieldMarshalTable()
{
    ULONG       i;
    ULONG       iCount;
    FieldMarshalRec *pRecEmit;
    HRESULT     hr = NOERROR;
    mdToken     tk;

    if (GetTokenMovementMap() == NULL)
        return NOERROR;

    iCount = m_Schema.m_cRecs[TBL_FieldMarshal];

    // loop through all LocalVar
    for (i = 1; i <= iCount; i++)
    {
        pRecEmit = getFieldMarshal(i);
        tk = getParentOfFieldMarshal(pRecEmit);
        IfFailGo( PutToken( TBL_FieldMarshal, FieldMarshalRec::COL_Parent, pRecEmit, GetTokenMovementMap()->SafeRemap(tk)) );
    }
ErrExit:
    return hr;

} // HRESULT CMiniMdRW::FixUpFieldMarshalTable()

//*****************************************************************************
// Fixup MethodImpl table with token movement
//*****************************************************************************
HRESULT CMiniMdRW::FixUpMethodImplTable()
{
    ULONG       i;
    ULONG       iCount;
    MethodImplRec *pRecEmit;
    HRESULT     hr = NOERROR;
    mdTypeDef   td;
    mdMethodDef mdBody;
    mdMethodDef mdDecl;

    if (GetTokenMovementMap() == NULL)
        return NOERROR;

    iCount = m_Schema.m_cRecs[TBL_MethodImpl];

    // loop through all LocalVar
    for (i = 1; i <= iCount; i++)
    {
        pRecEmit = getMethodImpl(i);
        td = getClassOfMethodImpl(pRecEmit);
        IfFailGo( PutToken(TBL_MethodImpl, MethodImplRec::COL_Class,
                        pRecEmit, GetTokenMovementMap()->SafeRemap(td)) );
        mdBody = getMethodBodyOfMethodImpl(pRecEmit);
        IfFailGo( PutToken(TBL_MethodImpl, MethodImplRec::COL_MethodBody,
                        pRecEmit, GetTokenMovementMap()->SafeRemap(mdBody)) );
        mdDecl = getMethodDeclarationOfMethodImpl(pRecEmit);
        IfFailGo( PutToken(TBL_MethodImpl, MethodImplRec::COL_MethodDeclaration,
                        pRecEmit, GetTokenMovementMap()->SafeRemap(mdDecl)) );
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FixUpMethodImplTable()

//*****************************************************************************
// Fixup DeclSecurity table with token movement
//*****************************************************************************
HRESULT CMiniMdRW::FixUpDeclSecurityTable()
{
    ULONG       i;
    ULONG       iCount;
    DeclSecurityRec *pRecEmit;
    HRESULT     hr = NOERROR;
    mdToken     tk;

    if (GetTokenMovementMap() == NULL)
        return NOERROR;

    iCount = m_Schema.m_cRecs[TBL_DeclSecurity];

    // loop through all LocalVar
    for (i = 1; i <= iCount; i++)
    {
        pRecEmit = getDeclSecurity(i);
        tk = getParentOfDeclSecurity(pRecEmit);
        IfFailGo( PutToken(TBL_DeclSecurity, DeclSecurityRec::COL_Parent, pRecEmit, GetTokenMovementMap()->SafeRemap(tk)) );
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FixUpDeclSecurityTable()

//*****************************************************************************
// Fixup CustomAttribute table with token movement
//*****************************************************************************
HRESULT CMiniMdRW::FixUpCustomAttributeTable()
{
    ULONG       i;
    ULONG       iCount;
    CustomAttributeRec *pRecEmit;
    HRESULT     hr = NOERROR;
    mdToken     tk;

    if (GetTokenMovementMap() == NULL)
        return NOERROR;

    iCount = m_Schema.m_cRecs[TBL_CustomAttribute];

    // loop through all LocalVar
    for (i = 1; i <= iCount; i++)
    {
        pRecEmit = getCustomAttribute(i);
        tk = getParentOfCustomAttribute(pRecEmit);
        IfFailGo( PutToken(TBL_CustomAttribute, CustomAttributeRec::COL_Parent, pRecEmit, GetTokenMovementMap()->SafeRemap(tk)) );
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FixUpCustomAttributeTable()

//*****************************************************************************
// Fixup MethodSemantics table with token movement
//*****************************************************************************
HRESULT CMiniMdRW::FixUpMethodSemanticsTable()
{
    ULONG       i;
    ULONG       iCount;
    MethodSemanticsRec *pRecEmit;
    HRESULT     hr = NOERROR;
    mdToken     tk;

    if (GetTokenMovementMap() == NULL)
        return NOERROR;

    iCount = m_Schema.m_cRecs[TBL_MethodSemantics];

    // loop through all LocalVar
    for (i = 1; i <= iCount; i++)
    {
        pRecEmit = getMethodSemantics(i);

        // remap the backing field, EventChanging, and EventChanged
        tk = getMethodOfMethodSemantics(pRecEmit);
        IfFailGo( PutToken(TBL_MethodSemantics, MethodSemanticsRec::COL_Method, pRecEmit, GetTokenMovementMap()->SafeRemap(tk)) );
        tk = getAssociationOfMethodSemantics(pRecEmit);
        IfFailGo( PutToken(TBL_MethodSemantics, MethodSemanticsRec::COL_Association, pRecEmit, GetTokenMovementMap()->SafeRemap(tk)) );
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FixUpMethodSemanticsTable()

//*****************************************************************************
// Fixup ImplMap table with token movement
//*****************************************************************************
HRESULT CMiniMdRW::FixUpImplMapTable()
{
    ULONG       i;
    ULONG       iCount;
    ImplMapRec  *pRecEmit;
    HRESULT     hr = NOERROR;
    mdToken     tk;

    if (GetTokenMovementMap() == NULL)
        return NOERROR;

    iCount = m_Schema.m_cRecs[TBL_ImplMap];

    // loop through all ImplMap
    for (i = 1; i <= iCount; i++)
    {
        pRecEmit = getImplMap(i);
        tk = getMemberForwardedOfImplMap(pRecEmit);
        IfFailGo( PutToken(TBL_ImplMap, ImplMapRec::COL_MemberForwarded, pRecEmit, GetTokenMovementMap()->SafeRemap(tk)) );
        tk = getImportScopeOfImplMap(pRecEmit);
        IfFailGo( PutToken(TBL_ImplMap, ImplMapRec::COL_ImportScope, pRecEmit, GetTokenMovementMap()->SafeRemap(tk)) );
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FixUpImplMapTable()

//*****************************************************************************
// Fixup FieldRVA table with token movement
//*****************************************************************************
HRESULT CMiniMdRW::FixUpFieldRVATable()
{
    ULONG       i;
    ULONG       iCount;
    FieldRVARec *pRecEmit;
    HRESULT     hr = NOERROR;
    mdFieldDef  tkfd;

    if (GetTokenMovementMap() == NULL)
        return NOERROR;

    iCount = m_Schema.m_cRecs[TBL_FieldRVA];

    // loop through all FieldRVA entries.
    for (i = 1; i <= iCount; i++)
    {
        pRecEmit = getFieldRVA(i);
        tkfd = getFieldOfFieldRVA(pRecEmit);
        IfFailGo( PutToken(TBL_FieldRVA, FieldRVARec::COL_Field, pRecEmit, GetTokenMovementMap()->SafeRemap(tkfd)) );
    }
ErrExit:
    return hr;
}

//*****************************************************************************
// Fixup FieldLayout table with token movement
//*****************************************************************************
HRESULT CMiniMdRW::FixUpFieldLayoutTable()
{
    ULONG       i;
    ULONG       iCount;
    FieldLayoutRec *pRecEmit;
    HRESULT     hr = NOERROR;
    mdFieldDef  tkfd;

    iCount = m_Schema.m_cRecs[TBL_FieldLayout];

    // loop through all FieldLayout entries.
    for (i = 1; i <= iCount; i++)
    {
        pRecEmit = getFieldLayout(i);
        tkfd = getFieldOfFieldLayout(pRecEmit);
        IfFailGo( PutToken(TBL_FieldLayout, FieldLayoutRec::COL_Field,
                           pRecEmit, GetTokenMovementMap()->SafeRemap(tkfd)) );
    }
ErrExit:
    return hr;
} // CMiniMdRW::FixUpFieldLayoutTable()


//*****************************************************************************
// Fixup all the embedded ref to corresponding def before we remap tokens movement.
//*****************************************************************************
HRESULT CMiniMdRW::FixUpRefToDef()
{
    return NOERROR;
} // CMiniMdRW::FixUpRefToDef()


//*****************************************************************************
// Given a pointer to a row, what is the RID of the row?
//*****************************************************************************
RID CMiniMdRW::Impl_GetRidForRow(       // RID corresponding to the row pointer.
    const void  *pvRow,                 // Pointer to the row.
    ULONG       ixtbl)                  // Which table.
{
    return m_Table[ixtbl].GetIndexForRecord(pvRow);
} // RID CMiniMdRW::Impl_GetRidForRow()

//*****************************************************************************
// Given a table with a pointer (index) to a sequence of rows in another
//  table, get the RID of the end row.  This is the STL-ish end; the first row
//  not in the list.  Thus, for a list of 0 elements, the start and end will
//  be the same.
//*****************************************************************************
int CMiniMdRW::Impl_GetEndRidForColumn( // The End rid.
    const void  *pvRec,                 // Row that references another table.
    int         ixTbl,                  // Table containing the row.
    CMiniColDef &def,                   // Column containing the RID into other table.
    int         ixTbl2)                 // The other table.
{
    ULONG rid = Impl_GetRidForRow(pvRec, ixTbl);
    ULONG ixEnd;

    // Last rid in range from NEXT record, or count of table, if last record.
    _ASSERTE(rid <= m_Schema.m_cRecs[ixTbl]);
    if (rid < m_Schema.m_cRecs[ixTbl])
    {

        ixEnd = getIX(getRow(ixTbl, rid+1), def);
        // We use a special value, 'END_OF_TABLE' (currently 0), to indicate
		//  end-of-table.  If we find the special value we'll have to compute
		//  the value to return.  If we don't find the special value, then
		//  the value is correct.
		if (ixEnd != END_OF_TABLE)
			return ixEnd;
	}

	// Either the child pointer value in the next row was END_OF_TABLE, or
	//  the row is the last row of the table.  In either case, we must return
	//  a value which will work out to the END of the child table.  That
	//  value depends on the value in the row itself -- if the row contains
	//  END_OF_TABLE, there are no children, and to make the subtraction
	//  work out, we return END_OF_TABLE for the END value.  If the row
	//  contains some value, then we return the actual END count.
    if (getIX(getRow(ixTbl, rid), def) == END_OF_TABLE)
        ixEnd = END_OF_TABLE;
    else
        ixEnd = m_Schema.m_cRecs[ixTbl2] + 1;

    return ixEnd;
} // int CMiniMd::Impl_GetEndRidForColumn()

//*****************************************************************************
// Add a row to any table.
//*****************************************************************************
void *CMiniMdRW::AddRecord(             // S_OK or error.
    ULONG       ixTbl,                  // The table to expand.
    ULONG       *pRid)                  // Put RID here.
{
#if defined(AUTO_GROW)
    ULONG       rid;                    // Always get the rid back.
    if (!pRid) pRid = &rid;
#endif

    _ASSERTE(ixTbl < TBL_COUNT);
    _ASSERTE(!m_bPreSaveDone && "Cannot add records after PreSave and before Save.");
    void * pRslt = m_Table[ixTbl].AddRecord(pRid);
    if (pRslt)
    {
#if defined(AUTO_GROW)
        if (*pRid > m_maxRid)
        {
            m_maxRid = *pRid;
            if (m_maxRid > m_limRid && m_eGrow == eg_ok)
            {
                // OutputDebugStringA("Growing tables due to Record overflow.\n");
                m_eGrow = eg_grow, m_maxRid = m_maxIx = ULONG_MAX;
            }
        }
#endif // AUTO_GROW
        ++m_Schema.m_cRecs[ixTbl];
        // handled in RecordPool now: memset(pRslt, 0, m_TableDefs[ixTbl].m_cbRec);
        SetSorted(ixTbl, false);
        if (m_pVS[ixTbl])
            m_pVS[ixTbl]->m_isMapValid = false;
    }
    return pRslt;
} // void *CMiniMdRW::AddRecord()

//*****************************************************************************
// Add a row to the TypeDef table, and initialize the pointers to other tables.
//*****************************************************************************
TypeDefRec *CMiniMdRW::AddTypeDefRecord(ULONG *pRid)
{
    TypeDefRec *pRecord = reinterpret_cast<TypeDefRec*>(AddRecord(TBL_TypeDef, pRid));
    if (pRecord == 0)
        return 0;

	PutCol(TBL_TypeDef, TypeDefRec::COL_MethodList, pRecord, NewRecordPointerEndValue(TBL_Method));
	PutCol(TBL_TypeDef, TypeDefRec::COL_FieldList, pRecord, NewRecordPointerEndValue(TBL_Field));

    return pRecord;
} // TypeDefRec *CMiniMdRW::AddTypeDefRecord()

//*****************************************************************************
// Add a row to the Method table, and initialize the pointers to other tables.
//*****************************************************************************
MethodRec *CMiniMdRW::AddMethodRecord(ULONG *pRid)
{
    MethodRec *pRecord = reinterpret_cast<MethodRec*>(AddRecord(TBL_Method, pRid));
    if (pRecord == 0)
        return 0;

	PutCol(TBL_Method, MethodRec::COL_ParamList, pRecord, NewRecordPointerEndValue(TBL_Param));

    return pRecord;
} // MethodRec *CMiniMdRW::AddMethodRecord()

//*****************************************************************************
// Add a row to the EventMap table, and initialize the pointers to other tables.
//*****************************************************************************
EventMapRec *CMiniMdRW::AddEventMapRecord(ULONG *pRid)
{
    EventMapRec *pRecord = reinterpret_cast<EventMapRec*>(AddRecord(TBL_EventMap, pRid));
    if (pRecord == 0)
        return 0;

	PutCol(TBL_EventMap, EventMapRec::COL_EventList, pRecord, NewRecordPointerEndValue(TBL_Event));

    SetSorted(TBL_EventMap, false);

    return pRecord;
} // MethodRec *CMiniMdRW::AddEventMapRecord()

//*********************************************************************************
// Add a row to the PropertyMap table, and initialize the pointers to other tables.
//*********************************************************************************
PropertyMapRec *CMiniMdRW::AddPropertyMapRecord(ULONG *pRid)
{
    PropertyMapRec *pRecord = reinterpret_cast<PropertyMapRec*>(AddRecord(TBL_PropertyMap, pRid));
    if (pRecord == 0)
        return 0;

	PutCol(TBL_PropertyMap, PropertyMapRec::COL_PropertyList, pRecord, NewRecordPointerEndValue(TBL_Property));

    SetSorted(TBL_PropertyMap, false);

    return pRecord;
} // MethodRec *CMiniMdRW::AddPropertyMapRecord()

//*****************************************************************************
// converting a ANSI heap string to unicode string to an output buffer
//*****************************************************************************
HRESULT CMiniMdRW::Impl_GetStringW(ULONG ix, LPWSTR szOut, ULONG cchBuffer, ULONG *pcchBuffer)
{
    LPCSTR      szString;               // Single byte version.
    int         iSize;                  // Size of resulting string, in wide chars.
    HRESULT     hr = NOERROR;

    szString = getString(ix);

    if ( *szString == 0 )
    {
        // If emtpy string "", return pccBuffer 0
        if ( szOut && cchBuffer )
            szOut[0] = L'\0';
        if ( pcchBuffer )
            *pcchBuffer = 0;
        goto ErrExit;
    }
    if (!(iSize=::WszMultiByteToWideChar(CP_UTF8, 0, szString, -1, szOut, cchBuffer)))
    {
        // What was the problem?
        DWORD dwNT = GetLastError();

        // Not truncation?
        if (dwNT != ERROR_INSUFFICIENT_BUFFER)
            IfFailGo( HRESULT_FROM_NT(dwNT) );

        // Truncation error; get the size required.
        if (pcchBuffer)
            *pcchBuffer = ::WszMultiByteToWideChar(CP_UTF8, 0, szString, -1, szOut, 0);

        hr = CLDB_S_TRUNCATION;
        goto ErrExit;
    }
    if (pcchBuffer)
        *pcchBuffer = iSize;

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::Impl_GetStringW()

//*****************************************************************************
// Get a column value from a row.  Signed types are sign-extended to the full
//  ULONG; unsigned types are 0-extended.
//*****************************************************************************
ULONG CMiniMdRW::GetCol(                // Column data.
    ULONG       ixTbl,                  // Index of the table.
    ULONG       ixCol,                  // Index of the column.
    void        *pvRecord)              // Record with the data.
{
    HRESULT     hr = S_OK;
    BYTE        *pRecord;               // The row.
    BYTE        *pData;                 // The item in the row.
    ULONG       val;                    // The return value.
    // Valid Table, Column, Row?
    _ASSERTE(ixTbl < TBL_COUNT);
    _ASSERTE(ixCol < g_Tables[ixTbl].m_Def.m_cCols);

    // Column size, offset
    CMiniColDef *pColDef = &m_TableDefs[ixTbl].m_pColDefs[ixCol];

    pRecord = reinterpret_cast<BYTE*>(pvRecord);
    pData = pRecord + pColDef->m_oColumn;

    switch (pColDef->m_cbColumn)
    {
    case 1:
        val = *pData;
        break;
    case 2:
        if (pColDef->m_Type == iSHORT)
            val = static_cast<LONG>(*reinterpret_cast<SHORT*>(pData));
        else
            val = *reinterpret_cast<USHORT*>(pData);
        break;
    case 4:
        val = *reinterpret_cast<ULONG*>(pData);
        break;
    default:
        _ASSERTE(!"Unexpected column size");
        return 0;
    }

    return val;
} // ULONG CMiniMdRW::GetCol()

//*****************************************************************************
// General token column fetcher.
//*****************************************************************************
mdToken CMiniMdRW::GetToken(
    ULONG       ixTbl,                  // Index of the table.
    ULONG       ixCol,                  // Index of the column.
    void        *pvRecord)              // Record with the data.
{
    ULONG       tkn;                    // Token from the table.

    // Valid Table, Column, Row?
    _ASSERTE(ixTbl < TBL_COUNT);
    _ASSERTE(ixCol < g_Tables[ixTbl].m_Def.m_cCols);

    // Column description.
    CMiniColDef *pColDef = &m_TableDefs[ixTbl].m_pColDefs[ixCol];

    // Is the column just a RID?
    if (pColDef->m_Type <= iRidMax)
    {
        tkn = GetCol(ixTbl, ixCol, pvRecord); //pColDef, pvRecord, RidFromToken(tk));
        tkn = TokenFromRid(tkn, GetTokenForTable(pColDef->m_Type));
    }
    else // Is it a coded token?
    if (pColDef->m_Type <= iCodedTokenMax)
    {
        const CCodedTokenDef *pCdTkn = &g_CodedTokens[pColDef->m_Type - iCodedToken];
        tkn = decodeToken(GetCol(ixTbl, ixCol, pvRecord), pCdTkn->m_pTokens, pCdTkn->m_cTokens);
    }
    else // It is an error.
    {
        _ASSERTE(!"GetToken called on unexpected column type");
        tkn = 0;
    }

    return tkn;
} // mdToken CMiniMdRW::GetToken()

//*****************************************************************************
// Put a column value into a row.  The value is passed as a ULONG; 1, 2, or 4
//  bytes are stored into the column.  No table is specified, and the coldef
//  is passed directly.  This allows putting data into other buffers, such as
//  the temporary table used for saving.
//*****************************************************************************
HRESULT CMiniMdRW::PutCol(              // S_OK or E_UNEXPECTED.
    CMiniColDef ColDef,                 // The col def.
    void        *pvRecord,              // The row.
    ULONG       uVal)                   // Value to put.
{
    HRESULT     hr = S_OK;
    BYTE        *pRecord;               // The row.
    BYTE        *pData;                 // The item in the row.

    pRecord = reinterpret_cast<BYTE*>(pvRecord);
    pData = pRecord + ColDef.m_oColumn;

    switch (ColDef.m_cbColumn)
    {
    case 1:
        // Don't store a value that would overflow.
        if (uVal > UCHAR_MAX)
            return E_INVALIDARG;
        *pData = static_cast<BYTE>(uVal);
        break;
    case 2:
        if (uVal > USHRT_MAX)
            return E_INVALIDARG;
        *reinterpret_cast<USHORT*>(pData) = static_cast<USHORT>(uVal);
        break;
    case 4:
        *reinterpret_cast<ULONG*>(pData) = uVal;
        break;
    default:
        _ASSERTE(!"Unexpected column size");
        return E_UNEXPECTED;
    }

    return hr;
} // HRESULT CMiniMdRW::PutCol()

//*****************************************************************************
// Put a column value into a row.  The value is passed as a ULONG; 1, 2, or 4
//  bytes are stored into the column.
//*****************************************************************************

//*****************************************************************************
// Add a string to the string pool, and store the offset in the cell.
//*****************************************************************************
HRESULT CMiniMdRW::PutString(           // S_OK or E_UNEXPECTED.
    ULONG       ixTbl,                  // The table.
    ULONG       ixCol,                  // The column.
    void        *pvRecord,              // The row.
    LPCSTR      szString)               // Value to put.
{
    HRESULT     hr = S_OK;
    ULONG       iOffset;                // The new string.

    // Valid Table, Column, Row?
    _ASSERTE(ixTbl < TBL_COUNT);
    _ASSERTE(ixCol < g_Tables[ixTbl].m_Def.m_cCols);

    // Column description.
    _ASSERTE(m_TableDefs[ixTbl].m_pColDefs[ixCol].m_Type == iSTRING);

    // @FUTURE:  Set iOffset to 0 for empty string.  Work around the bug in
    // StringPool that does not handle empty strings correctly.
    if (szString && !*szString)
        iOffset = 0;
    else
        IfFailGo(AddString(szString, &iOffset));

    hr = PutCol(m_TableDefs[ixTbl].m_pColDefs[ixCol], pvRecord, iOffset);

#if defined(AUTO_GROW)
    if (m_maxIx != ULONG_MAX)
        m_Strings.GetSaveSize(&iOffset);
    if (iOffset > m_maxIx)
    {
        m_maxIx = iOffset;
        if (m_maxIx > m_limIx && m_eGrow == eg_ok)
        {
            // OutputDebugStringA("Growing tables due to String overflow.\n");
            m_eGrow = eg_grow, m_maxRid = m_maxIx = ULONG_MAX;
        }
    }
#endif // AUTO_GROW

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::PutString()

//*****************************************************************************
// Add a string to the string pool, and store the offset in the cell.
//*****************************************************************************
HRESULT CMiniMdRW::PutStringW(          // S_OK or E_UNEXPECTED.
    ULONG       ixTbl,                  // The table.
    ULONG       ixCol,                  // The column.
    void        *pvRecord,              // The row.
    LPCWSTR     szString)               // Value to put.
{
    HRESULT     hr = S_OK;
    ULONG       iOffset;                // The new string.

    // Valid Table, Column, Row?
    _ASSERTE(ixTbl < TBL_COUNT);
    _ASSERTE(ixCol < g_Tables[ixTbl].m_Def.m_cCols);

    // Column description.
    _ASSERTE(m_TableDefs[ixTbl].m_pColDefs[ixCol].m_Type == iSTRING);

    // Special case for empty string for StringPool
    if (szString && !*szString)
        iOffset = 0;
    else
        IfFailGo(AddStringW(szString, &iOffset));

    hr = PutCol(m_TableDefs[ixTbl].m_pColDefs[ixCol], pvRecord, iOffset);

#if defined(AUTO_GROW)
    if (m_maxIx != ULONG_MAX)
        m_Strings.GetSaveSize(&iOffset);
    if (iOffset > m_maxIx)
    {
        m_maxIx = iOffset;
        if (m_maxIx > m_limIx && m_eGrow == eg_ok)
        {
            // OutputDebugStringA("Growing tables due to String overflow.\n");
            m_eGrow = eg_grow, m_maxRid = m_maxIx = ULONG_MAX;
        }
    }
#endif // AUTO_GROW

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::PutStringW()

//*****************************************************************************
// Add a guid to the guid pool, and store the index in the cell.
//*****************************************************************************
HRESULT CMiniMdRW::PutGuid(             // S_OK or E_UNEXPECTED.
    ULONG       ixTbl,                  // The table.
    ULONG       ixCol,                  // The column.
    void        *pvRecord,              // The row.
    REFGUID     guid)                   // Value to put.
{
    HRESULT     hr = S_OK;
    ULONG       iOffset;                // The new guid.

    // Valid Table, Column, Row?
    _ASSERTE(ixTbl < TBL_COUNT);
    _ASSERTE(ixCol < g_Tables[ixTbl].m_Def.m_cCols);

    // Column description.
    _ASSERTE(m_TableDefs[ixTbl].m_pColDefs[ixCol].m_Type == iGUID);

    IfFailGo(AddGuid(guid, &iOffset));

    hr = PutCol(m_TableDefs[ixTbl].m_pColDefs[ixCol], pvRecord, iOffset);

#if defined(AUTO_GROW)
    if (m_maxIx != ULONG_MAX)
        m_Guids.GetSaveSize(&iOffset);
    if (iOffset > m_maxIx)
    {
        m_maxIx = iOffset;
        if (m_maxIx > m_limIx && m_eGrow == eg_ok)
        {
            // OutputDebugStringA("Growing tables due to GUID overflow.\n");
            m_eGrow = eg_grow, m_maxRid = m_maxIx = ULONG_MAX;
        }
    }
#endif // AUTO_GROW

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::PutGuid()

//*****************************************************************************
// Put a token into a cell.  If the column is a coded token, perform the
//  encoding first.
//*****************************************************************************
HRESULT CMiniMdRW::PutToken(            // S_OK or E_UNEXPECTED.
    ULONG       ixTbl,                  // The table.
    ULONG       ixCol,                  // The column.
    void        *pvRecord,              // The row.
    mdToken     tk)                     // Value to put.
{
    HRESULT     hr = S_OK;
    ULONG       cdTkn;                  // The new coded token.

    // Valid Table, Column, Row?
    _ASSERTE(ixTbl < TBL_COUNT);
    _ASSERTE(ixCol < g_Tables[ixTbl].m_Def.m_cCols);

    // Column description.
    CMiniColDef ColDef = m_TableDefs[ixTbl].m_pColDefs[ixCol];

    // Is the column just a RID?
    if (ColDef.m_Type <= iRidMax)
        hr = PutCol(ColDef, pvRecord, RidFromToken(tk));
    else // Is it a coded token?
    if (ColDef.m_Type <= iCodedTokenMax)
    {
        const CCodedTokenDef *pCdTkn = &g_CodedTokens[ColDef.m_Type - iCodedToken];
        cdTkn = encodeToken(RidFromToken(tk), TypeFromToken(tk), pCdTkn->m_pTokens, pCdTkn->m_cTokens);
        hr = PutCol(ColDef, pvRecord, cdTkn);
    }
    else // It is an error.
    {
        _ASSERTE(!"PutToken called on unexpected column type");
    }

    return hr;
} // HRESULT CMiniMdRW::PutToken()

//*****************************************************************************
// Add a blob to the blob pool, and store the offset in the cell.
//*****************************************************************************
HRESULT CMiniMdRW::PutBlob(             // S_OK or error.
    ULONG       ixTbl,                  // Table with the row.
    ULONG       ixCol,                  // Column to set.
    void        *pvRecord,              // The row.
    const void  *pvData,                // Blob data.
    ULONG       cbData)                 // Size of the blob data.
{
    HRESULT     hr = S_OK;
    ULONG       iOffset;                // The new blob index.

    // Valid Table, Column, Row?
    _ASSERTE(ixTbl < TBL_COUNT);
    _ASSERTE(ixCol < g_Tables[ixTbl].m_Def.m_cCols);

    // Column description.
    _ASSERTE(m_TableDefs[ixTbl].m_pColDefs[ixCol].m_Type == iBLOB);

    IfFailGo(AddBlob(pvData, cbData, &iOffset));

    hr = PutCol(m_TableDefs[ixTbl].m_pColDefs[ixCol], pvRecord, iOffset);

#if defined(AUTO_GROW)
    if (m_maxIx != ULONG_MAX)
        m_Blobs.GetSaveSize(&iOffset);
    if (iOffset > m_maxIx)
    {
        m_maxIx = iOffset;
        if (m_maxIx > m_limIx && m_eGrow == eg_ok)
        {
            // OutputDebugStringA("Growing tables due to Blob overflow.\n");
            m_eGrow = eg_grow, m_maxRid = m_maxIx = ULONG_MAX;
        }
    }
#endif // AUTO_GROW

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::PutBlob()

//*****************************************************************************
// Given a table with a pointer to another table, add a row in the second table
//  at the end of the range of rows belonging to some parent.
//*****************************************************************************
void *CMiniMdRW::AddChildRowIndirectForParent(  // New row, or NULL.
    ULONG       tblParent,              // Parent table.
    ULONG       colParent,              // Column in parent table.
    ULONG       tblChild,               // Child table, pointed to by parent cell.
    RID         ridParent)              // Rid of parent row.
{
    ULONG       ixInsert;               // Index of new row.
    void        *pInsert;               // Pointer to new row.
    ULONG       i;                      // Loop control.
    void        *pRow;                  // A parent row.
    ULONG       ixChild;                // Some child record RID.

    // If the row in the parent table is the last row, just append.
    if (ridParent == vGetCountRecs(tblParent))
    {
         return AddRecord(tblChild);
    }

    // Determine the index at which to insert a row.
    ixInsert = GetCol(tblParent, colParent, getRow(tblParent, ridParent+1));

    // Insert the row.
    pInsert = m_Table[tblChild].InsertRecord(ixInsert);
    if (pInsert == 0)
        return 0;
    // Count the inserted record.
    ++m_Schema.m_cRecs[tblChild];

#if defined(AUTO_GROW)
    if (m_Schema.m_cRecs[tblChild] > m_maxRid)
    {
        m_maxRid = m_Schema.m_cRecs[tblChild];
        if (m_maxRid > m_limRid && m_eGrow == eg_ok)
            m_eGrow = eg_grow, m_maxIx = m_maxRid = ULONG_MAX;
    }
#endif // AUTO_GROW

    // Adjust the rest of the rows in the table.
    for (i=vGetCountRecs(tblParent); i>ridParent; --i)
    {
        pRow = getRow(tblParent, i);
        ixChild = GetCol(tblParent, colParent, pRow);
        ++ixChild;
        PutCol(tblParent, colParent, pRow, ixChild);
    }

    return pInsert;
} // void *CMiniMdRW::AddChildRowIndirectForParent()

//*****************************************************************************
// Given a Parent and a Child, this routine figures if there needs to be an
// indirect table and creates it if needed.  Else it just update the pointers
// in the entries contained in the parent table.
//*****************************************************************************
HRESULT CMiniMdRW::AddChildRowDirectForParent(
    ULONG       tblParent,              // Parent table.
    ULONG       colParent,              // Column in parent table.
    ULONG       tblChild,               // Child table, pointed to by parent cell.
    RID         ridParent)              // Rid of parent row.
{
    HRESULT     hr = S_OK;              // A result.
    void        *pRow;                  // A row in the parent table.
    RID         ixChild;                // Rid of a child record.

    if (m_Schema.m_cRecs[tblChild-1] != 0)
    {
        // If there already exists an indirect table, just return.
        hr = S_FALSE;
        goto ErrExit;
    }

    // If the parent record has subsequent parent records with children,
    //  we will now need to build a pointer table.
    //
    // The canonical form of a child pointer in a parent record is to point to
    //  the start of the child list.  A record with no children will point
    //  to the same location as its subsequent record (that is, if A and B *could*
    //  have a child record, but only B *does*, both A and B will point to the
    //  same place.  If the last record in the parent table has no child records,
    //  it will point one past the end of the child table.  This is patterned
	//  after the STL's inclusive-BEGIN and exclusive-END.
    // This has the unfortunate side effect that if a child record is added to
    //  a parent not at the end of its table, *all* of the subsequent parent records
    //  will have to be updated to point to the new "1 past end of child table"
    //  location.
    // Therefore, as an optimization, we will also recognize a special marker,
    //  END_OF_TABLE (currently 0), to mean "past eot".
    //
    // If the child pointer of the record getting the new child is END_OF_TABLE,
    //  then there is no subsequent child pointer.  We need to fix up this parent
    //  record, and any previous parent records with END_OF_TABLE to point to the
    //  new child record.
    // If the child pointer of this parent record is not END_OF_TABLE, but the
    //  child pointer of the next parent record is, then there is nothing at
    //  all that needs to be done.
    // If the child pointer of the next parent record is not END_OF_TABLE, then
    //  we will have to build a pointer table.

    // Get the parent record, and see if its child pointer is END_OF_TABLE.  If so,
    //  fix the parent, and all previous END_OF_TABLE valued parent records.
    pRow = getRow(tblParent, ridParent);
    ixChild = GetCol(tblParent, colParent, pRow);
    if (ixChild == END_OF_TABLE)
    {
        IfFailGo(ConvertMarkerToEndOfTable(tblParent, colParent, m_Schema.m_cRecs[tblChild], ridParent));
        goto ErrExit;
    }

    // The parent did not have END_OF_TABLE for its child pointer.  If it was the last
    //  record in the table, there is nothing more to do.
    if (ridParent == m_Schema.m_cRecs[tblParent])
        goto ErrExit;

    // The parent't didn't have END_OF_TABLE, and there are more rows in parent table.
    //  If the next parent record's child pointer is END_OF_TABLE, then all of the
    //  remaining records are OK.
    pRow = getRow(tblParent, ridParent+1);
    ixChild = GetCol(tblParent, colParent, pRow);
    if (ixChild == END_OF_TABLE)
        goto ErrExit;

    // The next record was not END_OF_TABLE, so some adjustment will be required.
    //  If it points to the actual END of the table, there are no more child records
    //  and the child pointers can be adjusted to the new END of the table.
    if (ixChild == m_Schema.m_cRecs[tblChild])
    {
        for (ULONG i=m_Schema.m_cRecs[tblParent]; i>ridParent; --i)
        {
            pRow = getRow(tblParent, i);
            IfFailGo(PutCol(tblParent, colParent, pRow, ixChild+1));
        }
        goto ErrExit;
    }

    // The next record contained a pointer to some actual child data.  That means that
    //  this is an out-of-order insertion.  We must create an indirect table.
    // Convert any END_OF_TABLE to actual END of table value.  Note that a record has
	//  just been added to the child table, and not yet to the parent table, so the END
	//  should currently point to the last valid record (instead of the usual first invalid
	//  rid).
    IfFailGo(ConvertMarkerToEndOfTable(tblParent, colParent, m_Schema.m_cRecs[tblChild], m_Schema.m_cRecs[tblParent]));
    // Create the indirect table.
    IfFailGo(CreateIndirectTable(tblChild));
    hr = S_FALSE;

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddChildRowDirectForParent()

//*****************************************************************************
// Starting with some location, convert special END_OF_TABLE values into
//  actual end of table values (count of records + 1).
//*****************************************************************************
HRESULT CMiniMdRW::ConvertMarkerToEndOfTable(
    ULONG       tblParent,              // Parent table to convert.
    ULONG       colParent,              // Column in parent table.
    ULONG       ixEnd,                  // Value to store to child pointer.
    RID         ridParent)              // Rid of parent row to start with (work down).
{
    HRESULT     hr;                     // A result.
    void        *pRow;                  // A row in the parent table.
    RID         ixChild;                // Rid of a child record.

    for (; ridParent > 0; --ridParent)
    {
        pRow = getRow(tblParent, ridParent);
        ixChild = GetCol(tblParent, colParent, pRow);
        // Finished when rows no longer have special value.
        if (ixChild != END_OF_TABLE)
            break;
        IfFailGo(PutCol(tblParent, colParent, pRow, ixEnd));
    }
    // Success.
    hr = S_OK;

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::ConvertMarkerToEndOfTable()

//*****************************************************************************
// Given a Table ID this routine creates the corresponding pointer table with
// the entries in the given Table ID less one.  It doesn't create the last
// entry by default, since its the last entry that caused the Indirect table to
// be required in most cases and will need to inserted at the appropriate location
// with AddChildRowIndirectForParent() function.  So, be VERY CAREFUL when using this function!
//*****************************************************************************
HRESULT CMiniMdRW::CreateIndirectTable( // S_OK or error.
    ULONG       ixTbl,                  // Given Table.
    BOOL        bOneLess /* = true */)  // if true, create one entry less.
{
    void        *pRecord;
    ULONG       cRecords;
    HRESULT     hr = S_OK;

    if (m_OptionValue.m_ErrorIfEmitOutOfOrder)
    {
        // @FUTURE:: meichint
        // Can I use some bit fields and reduce the code size here??
        //
        if (ixTbl == TBL_Field && ( m_OptionValue.m_ErrorIfEmitOutOfOrder & MDFieldOutOfOrder ) )
        {
            _ASSERTE(!"Out of order emit of field token!");
            return CLDB_E_RECORD_OUTOFORDER;
        }
        else if (ixTbl == TBL_Method && ( m_OptionValue.m_ErrorIfEmitOutOfOrder & MDMethodOutOfOrder ) )
        {
            _ASSERTE(!"Out of order emit of method token!");
            return CLDB_E_RECORD_OUTOFORDER;
        }
        else if (ixTbl == TBL_Param && ( m_OptionValue.m_ErrorIfEmitOutOfOrder & MDParamOutOfOrder ) )
        {
            _ASSERTE(!"Out of order emit of param token!");
            return CLDB_E_RECORD_OUTOFORDER;
        }
        else if (ixTbl == TBL_Property && ( m_OptionValue.m_ErrorIfEmitOutOfOrder & MDPropertyOutOfOrder ) )
        {
            _ASSERTE(!"Out of order emit of property token!");
            return CLDB_E_RECORD_OUTOFORDER;
        }
        else if (ixTbl == TBL_Event && ( m_OptionValue.m_ErrorIfEmitOutOfOrder & MDEventOutOfOrder ) )
        {
            _ASSERTE(!"Out of order emit of event token!");
            return CLDB_E_RECORD_OUTOFORDER;
        }
    }

    _ASSERTE(! HasIndirectTable(ixTbl));

    cRecords = vGetCountRecs(ixTbl);
    if (bOneLess)
        cRecords--;

    // Create one less than the number of records in the given table.
    for (ULONG i = 1; i <= cRecords ; i++)
    {
        IfNullGo(pRecord = AddRecord(g_PtrTableIxs[ixTbl].m_ixtbl));
        IfFailGo(PutCol(g_PtrTableIxs[ixTbl].m_ixtbl, g_PtrTableIxs[ixTbl].m_ixcol, pRecord, i));
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::CreateIndirectTable()

//*****************************************************************************
// The new paramter may not have been emitted in sequence order.  So
// check the current parameter and move it up in the indirect table until
// we find the right home.
//*****************************************************************************
void CMiniMdRW::FixParamSequence(
    RID         md)                     // Rid of method with new parameter.
{
    MethodRec *pMethod = getMethod(md);
    RID ixStart = getParamListOfMethod(pMethod);
    RID ixEnd = getEndParamListOfMethod(pMethod);
    int iSlots = 0;

    // Param table should not be empty at this point.
    _ASSERTE(ixEnd > ixStart);

    // Get a pointer to the new guy.
    RID ridNew;
    ParamPtrRec *pNewParamPtr;
    if (HasIndirectTable(TBL_Param))
    {
        pNewParamPtr = getParamPtr(--ixEnd);
        ridNew = GetCol(TBL_ParamPtr, ParamPtrRec::COL_Param, pNewParamPtr);
    }
    else
        ridNew = --ixEnd;

    ParamRec *pNewParam = getParam(ridNew);

    // Walk the list forward looking for the insert point.
    for (; ixStart<ixEnd; --ixEnd)
    {
        // Get the current parameter record.
        RID ridOld;
        if (HasIndirectTable(TBL_Param))
        {
            ParamPtrRec *pParamPtr = getParamPtr(ixEnd - 1);
            ridOld = GetCol(TBL_ParamPtr, ParamPtrRec::COL_Param, pParamPtr);
        }
        else
            ridOld = ixEnd - 1;

        ParamRec *pParamRec = getParam(ridOld);

        // If the new record belongs before this existing record, slide
        // all of the old stuff down.
        if (pNewParam->m_Sequence < pParamRec->m_Sequence)
            ++iSlots;
        else
            break;
    }

    // If the item is out of order, move everything down one slot and
    // copy the new guy into the new location.  Because the heap can be
    // split, this must be done carefully.
    //@Future: one could write a more complicated but faster routine that
    // copies blocks within heaps.
    if (iSlots)
    {
        // Create an indirect table if there isn't one already.  This is because,
        // we can't change tokens that have been handed out, in this case the
        // param tokens.
        if (! HasIndirectTable(TBL_Param))
        {
            CreateIndirectTable(TBL_Param, false);
            pNewParamPtr = getParamPtr(getEndParamListOfMethod(pMethod) - 1);
        }
        int cbCopy = m_TableDefs[TBL_ParamPtr].m_cbRec;
        void *pbBackup = _alloca(cbCopy);
        memcpy(pbBackup, pNewParamPtr, cbCopy);

        for (ixEnd=getEndParamListOfMethod(pMethod)-1;  iSlots;  iSlots--, --ixEnd)
        {
            ParamPtrRec *pTo = getParamPtr(ixEnd);
            ParamPtrRec *pFrom = getParamPtr(ixEnd - 1);
            memcpy(pTo, pFrom, cbCopy);
        }

        ParamPtrRec *pTo = getParamPtr(ixEnd);
        memcpy(pTo, pbBackup, cbCopy);
    }
} // void CMiniMdRW::FixParamSequence()

//*****************************************************************************
// Given a MethodDef and its parent TypeDef, add the MethodDef to the parent,
//  adjusting the MethodPtr table if it exists or if it needs to be created.
//*****************************************************************************
HRESULT CMiniMdRW::AddMethodToTypeDef(  // S_OK or error.
    RID         td,                     // The TypeDef to which to add the Method.
    RID         md)                     // MethodDef to add to TypeDef.
{
    HRESULT     hr;
    void        *pPtr;

    // Add direct if possible.
    IfFailGo(AddChildRowDirectForParent(TBL_TypeDef, TypeDefRec::COL_MethodList, TBL_Method, td));

    // If couldn't add direct...
    if (hr == S_FALSE)
    {   // Add indirect.
        IfNullGo(pPtr = AddChildRowIndirectForParent(TBL_TypeDef, TypeDefRec::COL_MethodList, TBL_MethodPtr, td));
        hr = PutCol(TBL_MethodPtr, MethodPtrRec::COL_Method, pPtr, md);

        // Add the <md, td> to the method parent lookup table.
        IfFailGo(AddMethodToLookUpTable(TokenFromRid(md, mdtMethodDef), td) );
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddMethodToTypeDef()

//*****************************************************************************
// Given a FieldDef and its parent TypeDef, add the FieldDef to the parent,
//  adjusting the FieldPtr table if it exists or if it needs to be created.
//*****************************************************************************
HRESULT CMiniMdRW::AddFieldToTypeDef(   // S_OK or error.
    RID   td,                           // The TypeDef to which to add the Field.
    RID   md)                           // FieldDef to add to TypeDef.
{
    HRESULT     hr;
    void        *pPtr;

    // Add direct if possible.
    IfFailGo(AddChildRowDirectForParent(TBL_TypeDef, TypeDefRec::COL_FieldList, TBL_Field, td));

    // If couldn't add direct...
    if (hr == S_FALSE)
    {   // Add indirect.
        IfNullGo(pPtr = AddChildRowIndirectForParent(TBL_TypeDef, TypeDefRec::COL_FieldList, TBL_FieldPtr, td));
        hr = PutCol(TBL_FieldPtr, FieldPtrRec::COL_Field, pPtr, md);

        // Add the <md, td> to the field parent lookup table.
        IfFailGo(AddFieldToLookUpTable(TokenFromRid(md, mdtFieldDef), td));
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddFieldToTypeDef()

//*****************************************************************************
// Given a Param and its parent Method, add the Param to the parent,
// adjusting the ParamPtr table if there is an indirect table.
//*****************************************************************************
HRESULT CMiniMdRW::AddParamToMethod(    // S_OK or error.
    RID         md,                     // The MethodDef to which to add the Param.
    RID         pd)                     // Param to add to MethodDef.
{
    HRESULT     hr;
    void        *pPtr;

    IfFailGo(AddChildRowDirectForParent(TBL_Method, MethodRec::COL_ParamList, TBL_Param, md));
    if (hr == S_FALSE)
    {
        IfNullGo(pPtr = AddChildRowIndirectForParent(TBL_Method, MethodRec::COL_ParamList, TBL_ParamPtr, md));
        IfFailGo(PutCol(TBL_ParamPtr, ParamPtrRec::COL_Param, pPtr, pd));

        // Add the <pd, md> to the field parent lookup table.
        IfFailGo(AddParamToLookUpTable(TokenFromRid(pd, mdtParamDef), md));
    }
    FixParamSequence(md);

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddParamToMethod()

//*****************************************************************************
// Given a Property and its parent PropertyMap, add the Property to the parent,
// adjusting the PropertyPtr table.
//*****************************************************************************
HRESULT CMiniMdRW::AddPropertyToPropertyMap(    // S_OK or error.
    RID         pmd,                    // The PropertyMap to which to add the Property.
    RID         pd)                     // Property to add to PropertyMap.
{
    HRESULT     hr;
    void        *pPtr;

    IfFailGo(AddChildRowDirectForParent(TBL_PropertyMap, PropertyMapRec::COL_PropertyList,
                                    TBL_Property, pmd));
    if (hr == S_FALSE)
    {
        IfNullGo(pPtr = AddChildRowIndirectForParent(TBL_PropertyMap, PropertyMapRec::COL_PropertyList,
                                        TBL_PropertyPtr, pmd));
        hr = PutCol(TBL_PropertyPtr, PropertyPtrRec::COL_Property, pPtr, pd);
    }


ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddPropertyToPropertyMap()

//*****************************************************************************
// Given a Event and its parent EventMap, add the Event to the parent,
// adjusting the EventPtr table.
//*****************************************************************************
HRESULT CMiniMdRW::AddEventToEventMap(  // S_OK or error.
    ULONG       emd,                    // The EventMap to which to add the Event.
    RID         ed)                     // Event to add to EventMap.
{
    HRESULT     hr;
    void        *pPtr;

    IfFailGo(AddChildRowDirectForParent(TBL_EventMap, EventMapRec::COL_EventList,
                                    TBL_Event, emd));
    if (hr == S_FALSE)
    {
        IfNullGo(pPtr = AddChildRowIndirectForParent(TBL_EventMap, EventMapRec::COL_EventList,
                                        TBL_EventPtr, emd));
        hr = PutCol(TBL_EventPtr, EventPtrRec::COL_Event, pPtr, ed);
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddEventToEventMap()

//*****************************************************************************
// Find helper for a constant. This will trigger constant table to be sorted if it is not.
//*****************************************************************************
RID CMiniMdRW::FindConstantHelper(      // return index to the constant table
    mdToken     tkParent)               // Parent token.
{
    _ASSERTE(TypeFromToken(tkParent) != 0);

    // If sorted, use the faster lookup
    if (IsSorted(TBL_Constant))
    {
        return FindConstantFor(RidFromToken(tkParent), TypeFromToken(tkParent));
    }
    return GenericFindWithHash(TBL_Constant, ConstantRec::COL_Parent, tkParent);
} // RID CMiniMdRW::FindConstantHelper()

//*****************************************************************************
// Find helper for a FieldMarshal. This will trigger FieldMarshal table to be sorted if it is not.
//*****************************************************************************
RID CMiniMdRW::FindFieldMarshalHelper(  // return index to the field marshal table
    mdToken     tkParent)               // Parent token. Can be a FieldDef or ParamDef.
{
    _ASSERTE(TypeFromToken(tkParent) != 0);

    // If sorted, use the faster lookup
    if (IsSorted(TBL_FieldMarshal))
    {
        return FindFieldMarshalFor(RidFromToken(tkParent), TypeFromToken(tkParent));
    }
    return GenericFindWithHash(TBL_FieldMarshal, FieldMarshalRec::COL_Parent, tkParent);
} // RID CMiniMdRW::FindFieldMarshalHelper()


//*****************************************************************************
// Find helper for a method semantics.
// This will look up methodsemantics based on its status!
// Can return out of memory error because of the enumerator.
//*****************************************************************************
HRESULT CMiniMdRW::FindMethodSemanticsHelper(// return HRESULT
    mdToken     tkAssociate,            // Event or property token
    HENUMInternal *phEnum)              // fill in the enum
{
    ULONG       ridStart, ridEnd;
    ULONG       index;
    MethodSemanticsRec *pMethodSemantics;
    HRESULT     hr = NOERROR;
    CLookUpHash *pHashTable = m_pLookUpHashs[TBL_MethodSemantics];

    _ASSERTE(TypeFromToken(tkAssociate) != 0);

    if (IsSorted(TBL_MethodSemantics))
    {
        ridStart = getAssociatesForToken(tkAssociate, &ridEnd);
        HENUMInternal::InitSimpleEnum(0, ridStart, ridEnd, phEnum);
    }
    else if (pHashTable)
    {
        TOKENHASHENTRY *p;
        ULONG       iHash;
        int         pos;

        // Hash the data.
        HENUMInternal::InitDynamicArrayEnum(phEnum);
        iHash = HashToken(tkAssociate);

        // Go through every entry in the hash chain looking for ours.
        for (p = pHashTable->FindFirst(iHash, pos);
             p;
             p = pHashTable->FindNext(pos))
        {
            pMethodSemantics = getMethodSemantics(p->tok);
            if (getAssociationOfMethodSemantics(pMethodSemantics) == tkAssociate)
            {
                IfFailGo( HENUMInternal::AddElementToEnum(phEnum, p->tok) );
            }
        }
    }
    else
    {
        // linear search
        HENUMInternal::InitDynamicArrayEnum(phEnum);
        for (index = 1; index <= getCountMethodSemantics(); index++)
        {
            pMethodSemantics = getMethodSemantics(index);
            if (getAssociationOfMethodSemantics(pMethodSemantics) == tkAssociate)
            {
                IfFailGo( HENUMInternal::AddElementToEnum(phEnum, index) );
            }
        }
    }
ErrExit:
    return hr;
} // RID CMiniMdRW::FindMethodSemanticsHelper()


//*****************************************************************************
// Find helper for a method semantics given a associate and semantics.
// This will look up methodsemantics based on its status!
// Return CLDB_E_RECORD_NOTFOUND if cannot find the matching one
//*****************************************************************************
HRESULT CMiniMdRW::FindAssociateHelper(// return HRESULT
    mdToken     tkAssociate,            // Event or property token
    DWORD       dwSemantics,            // [IN] given a associate semantics(setter, getter, testdefault, reset)
    RID         *pRid)                  // [OUT] return matching row index here
{
    ULONG       ridStart, ridEnd;
    ULONG       index;
    MethodSemanticsRec *pMethodSemantics;
    HRESULT     hr = NOERROR;
    CLookUpHash *pHashTable = m_pLookUpHashs[TBL_MethodSemantics];

    _ASSERTE(TypeFromToken(tkAssociate) != 0);

    if (pHashTable)
    {
        TOKENHASHENTRY *p;
        ULONG       iHash;
        int         pos;

        // Hash the data.
        iHash = HashToken(tkAssociate);

        // Go through every entry in the hash chain looking for ours.
        for (p = pHashTable->FindFirst(iHash, pos);
             p;
             p = pHashTable->FindNext(pos))
        {
            pMethodSemantics = getMethodSemantics(p->tok);
            if (pMethodSemantics->m_Semantic == dwSemantics && getAssociationOfMethodSemantics(pMethodSemantics) == tkAssociate)
            {
                *pRid = p->tok;
                goto ErrExit;
            }
        }
    }
    else
    {
        if (IsSorted(TBL_MethodSemantics))
        {
            ridStart = getAssociatesForToken(tkAssociate, &ridEnd);
        }
        else
        {
            ridStart = 1;
            ridEnd = getCountMethodSemantics() + 1;
        }

        for (index = ridStart; index < ridEnd ; index++)
        {
            pMethodSemantics = getMethodSemantics(index);
            if (pMethodSemantics->m_Semantic == dwSemantics && getAssociationOfMethodSemantics(pMethodSemantics) == tkAssociate)
            {
                *pRid = index;
                goto ErrExit;
            }
        }
    }
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    return hr;
} // RID CMiniMdRW::FindAssociateHelper()


//*****************************************************************************
// Find helper for a MethodImpl.
// This will trigger MethodImpl table to be sorted if it is not.
//*****************************************************************************
HRESULT CMiniMdRW::FindMethodImplHelper(// return HRESULT
    mdTypeDef   td,                     // TypeDef token for the Class.
    HENUMInternal *phEnum)              // fill in the enum
{
    ULONG       ridStart, ridEnd;
    ULONG       index;
    MethodImplRec *pMethodImpl;
    HRESULT     hr = NOERROR;
    CLookUpHash *pHashTable = m_pLookUpHashs[TBL_MethodImpl];

    _ASSERTE(TypeFromToken(td) == mdtTypeDef);

    if (IsSorted(TBL_MethodImpl))
    {
        ridStart = getMethodImplsForClass(RidFromToken(td), &ridEnd);
        HENUMInternal::InitSimpleEnum(0, ridStart, ridEnd, phEnum);
    }
    else if (pHashTable)
    {
        TOKENHASHENTRY *p;
        ULONG       iHash;
        int         pos;

        // Hash the data.
        HENUMInternal::InitDynamicArrayEnum(phEnum);
        iHash = HashToken(td);

        // Go through every entry in the hash chain looking for ours.
        for (p = pHashTable->FindFirst(iHash, pos);
             p;
             p = pHashTable->FindNext(pos))
        {
            pMethodImpl = getMethodImpl(p->tok);
            if (getClassOfMethodImpl(pMethodImpl) == td)
            {
                IfFailGo( HENUMInternal::AddElementToEnum(phEnum, p->tok) );
            }
        }
    }
    else
    {
        // linear search
        HENUMInternal::InitDynamicArrayEnum(phEnum);
        for (index = 1; index <= getCountMethodImpls(); index++)
        {
            pMethodImpl = getMethodImpl(index);
            if (getClassOfMethodImpl(pMethodImpl) == td)
            {
                IfFailGo( HENUMInternal::AddElementToEnum(phEnum, index) );
            }
        }
    }
ErrExit:
    return hr;
} // RID CMiniMdRW::FindMethodImplHelper()


//*****************************************************************************
// Find helper for a ClassLayout. This will trigger ClassLayout table to be sorted if it is not.
//*****************************************************************************
RID CMiniMdRW::FindClassLayoutHelper(   // return index to the ClassLayout table
    mdTypeDef   tkParent)               // Parent token.
{
    _ASSERTE(TypeFromToken(tkParent) == mdtTypeDef);

    // If sorted, use the faster lookup
    if (IsSorted(TBL_ClassLayout))
    {
        return FindClassLayoutFor(RidFromToken(tkParent));
    }
    return GenericFindWithHash(TBL_ClassLayout, ClassLayoutRec::COL_Parent, tkParent);
} // RID CMiniMdRW::FindClassLayoutHelper()

//*****************************************************************************
// Find helper for a FieldLayout. This will trigger FieldLayout table to be sorted if it is not.
//*****************************************************************************
RID CMiniMdRW::FindFieldLayoutHelper(   // return index to the FieldLayout table
    mdFieldDef  tkField)                // Field RID.
{
    _ASSERTE(TypeFromToken(tkField) == mdtFieldDef);

    // If sorted, use the faster lookup
    if (IsSorted(TBL_FieldLayout))
    {
        return FindFieldLayoutFor(RidFromToken(tkField));
    }
    return GenericFindWithHash(TBL_FieldLayout, FieldLayoutRec::COL_Field, tkField);
} // RID CMiniMdRW::FindFieldLayoutHelper()

//*****************************************************************************
// Find helper for a ImplMap. This will trigger ImplMap table to be sorted if it is not.
//*****************************************************************************
RID CMiniMdRW::FindImplMapHelper(       // return index to the ImplMap table
    mdToken     tk)                     // Member forwarded token.
{
    _ASSERTE(TypeFromToken(tk) != 0);

    // If sorted, use the faster lookup
    if (IsSorted(TBL_ImplMap))
    {
        return FindImplMapFor(RidFromToken(tk), TypeFromToken(tk));
    }
    return GenericFindWithHash(TBL_ImplMap, ImplMapRec::COL_MemberForwarded, tk);
} // RID CMiniMdRW::FindImplMapHelper()


//*****************************************************************************
// Find helper for a FieldRVA. This will trigger FieldRVA table to be sorted if it is not.
//*****************************************************************************
RID CMiniMdRW::FindFieldRVAHelper(      // return index to the FieldRVA table
    mdFieldDef   tkField)               // Field token.
{
    _ASSERTE(TypeFromToken(tkField) == mdtFieldDef);

    // If sorted, use the faster lookup
    if (IsSorted(TBL_FieldRVA))
    {
        return FindFieldRVAFor(RidFromToken(tkField));
    }
    return GenericFindWithHash(TBL_FieldRVA, FieldRVARec::COL_Field, tkField);
}   // RID CMiniMdRW::FindFieldRVAHelper()

//*****************************************************************************
// Find helper for a NestedClass. This will trigger NestedClass table to be sorted if it is not.
//*****************************************************************************
RID CMiniMdRW::FindNestedClassHelper(   // return index to the NestedClass table
    mdTypeDef   tkClass)                // NestedClass RID.
{
    // If sorted, use the faster lookup
     if (IsSorted(TBL_NestedClass))
    {
        return FindNestedClassFor(RidFromToken(tkClass));
    }
    return GenericFindWithHash(TBL_NestedClass, NestedClassRec::COL_NestedClass, tkClass);
} // RID CMiniMdRW::FindNestedClassHelper()


//*************************************************************************
// generic find helper with hash table
//*************************************************************************
RID CMiniMdRW::GenericFindWithHash(     // Return code.
	ULONG		ixTbl,					// Table with hash
	ULONG		ixCol,					// col that we hash.
	mdToken     tkTarget)   			// token to be find in the hash
{
    ULONG       index;
    mdToken     tkHash;
    void        *pRec;
    CLookUpHash *pHashTable = m_pLookUpHashs[ixTbl];

    // Partial check -- only one rid for table 0, so if type is 0, rid should be 1.
    _ASSERTE(TypeFromToken(tkTarget) != 0 || RidFromToken(tkTarget) == 1);

    if (pHashTable == NULL)
    {
        HRESULT         hr;
        hr = GenericBuildHashTable(ixTbl, ixCol);
        if (FAILED(hr))
        {
            if (m_pLookUpHashs[ixTbl])
                delete m_pLookUpHashs[ixTbl];
            m_pLookUpHashs[ixTbl] = NULL;
        }
    }

    if (pHashTable)
    {
        TOKENHASHENTRY *p;
        ULONG       iHash;
        int         pos;

        // Hash the data.
        iHash = HashToken(tkTarget);

        // Go through every entry in the hash chain looking for ours.
        for (p = pHashTable->FindFirst(iHash, pos);
             p;
             p = pHashTable->FindNext(pos))
        {
            pRec = m_Table[ixTbl].GetRecord(p->tok);

            // get the column value that we will hash
            tkHash = GetToken(ixTbl, ixCol, pRec);
            if (tkHash == tkTarget)
            {
                // found the match
                return p->tok;
            }
        }
    }
    else
    {
        // linear search
        for (index = 1; index <= vGetCountRecs(ixTbl); index++)
        {
            pRec = m_Table[ixTbl].GetRecord(index);
            tkHash = GetToken(ixTbl, ixCol, pRec);
            if (tkHash == tkTarget)
            {
                // found the match
                return index;
            }
        }
    }
    return 0;
}   // GenericFindWithHash


//*************************************************************************
// Build a hash table for the specified table if the size exceed the thresholds.
//*************************************************************************
HRESULT CMiniMdRW::GenericBuildHashTable(// Return code.
	ULONG		ixTbl,					// Table with hash
	ULONG		ixCol)					// col that we hash.
{
    HRESULT     hr = S_OK;
    CLookUpHash *pHashTable = m_pLookUpHashs[ixTbl];
    void        *pRec;
    mdToken     tkHash;
    ULONG       iHash;
    TOKENHASHENTRY *pEntry;

    // If the hash table hasn't been built it, see if it should get faulted in.
    if (!pHashTable)
    {
        ULONG ridEnd = vGetCountRecs(ixTbl);

        // @FUTURE: we need to init the size of the hash table corresponding to the current
        // size of table in E&C's case.
        //
        if (ridEnd + 1 > INDEX_ROW_COUNT_THRESHOLD)
        {
            // Create a new hash.
            pHashTable = new CLookUpHash;
            IfNullGo( pHashTable );
            IfFailGo(pHashTable->NewInit(g_HashSize[m_iSizeHint]));

            // cache the hash table
            m_pLookUpHashs[ixTbl] = pHashTable;

            // Scan every entry already in the table, add it to the hash.
            for (ULONG index = 1; index <= ridEnd; index ++ )
            {
                pRec = m_Table[ixTbl].GetRecord(index);

                // get the column value that we will hash
                tkHash = GetToken(ixTbl, ixCol, pRec);

                // hash the value
                iHash = HashToken(tkHash);

                pEntry = pHashTable->Add(iHash);
                IfNullGo( pEntry );
                pEntry->tok = index;
            }
        }
    }
ErrExit:
    return hr;
}   // HRESULT CMiniMdRW::GenericBuildHashTable

//*************************************************************************
// Add a rid from a table into a hash. We will hash on the ixCol of the ixTbl.
//*************************************************************************
HRESULT CMiniMdRW::GenericAddToHash(    // Return code.
	ULONG		ixTbl,					// Table with hash
	ULONG		ixCol,					// column that we hash by calling HashToken.
	RID         rid)					// Token of new guy into the ixTbl.
{
    HRESULT     hr = S_OK;
    CLookUpHash *pHashTable = m_pLookUpHashs[ixTbl];
    void        *pRec;
    mdToken     tkHash;
    ULONG       iHash;
    TOKENHASHENTRY *pEntry;

    // If the hash table hasn't been built it, see if it should get faulted in.
    if (!pHashTable)
    {
        IfFailGo( GenericBuildHashTable(ixTbl, ixCol) );
    }
    else
    {
        pRec = m_Table[ixTbl].GetRecord(rid);

        tkHash = GetToken(ixTbl, ixCol, pRec);
        iHash = HashToken(tkHash);
        pEntry = pHashTable->Add(iHash);
        IfNullGo( pEntry );
        pEntry->tok = rid;
    }

ErrExit:
    return (hr);

}   // HRESULT CMiniMdRW::GenericAddToHash


//*****************************************************************************
// look up a table by a col given col value is ulVal.
//*****************************************************************************
HRESULT CMiniMdRW::LookUpTableByCol(    // S_OK or error
    ULONG       ulVal,                  // Value for which to search.
    VirtualSort *pVSTable,              // A VirtualSort on the table, if any.
    RID         *pRidStart,             // Put RID of first match here.
    RID         *pRidEnd)               // [OPTIONAL] Put RID of end match here.
{
    HRESULT     hr = NOERROR;
    ULONG       ixTbl;
    ULONG       ixCol;

    _ASSERTE(pVSTable);
    ixTbl = pVSTable->m_ixTbl;
    ixCol = pVSTable->m_ixCol;
    if (IsSorted(ixTbl))
    {
        // Table itself is sorted so we don't need to build a virtual sort table.
        // Binary search on the table directly.
        //
        *pRidStart = SearchTableForMultipleRows(
            ixTbl,
            m_TableDefs[ixTbl].m_pColDefs[ixCol],
            ulVal,
            pRidEnd );
    }
    else
    {
        if ( pVSTable->m_isMapValid == false )
        {
            int         iCount;

            // build the parallel VirtualSort table
            if ( pVSTable->m_pMap == 0 )
            {

                // the first time that we build the VS table. We need to allocate the TOKENMAP
                pVSTable->m_pMap = new TOKENMAP;
                IfNullGo( pVSTable->m_pMap );
            }

            // ensure the look up table is big enough
            iCount = pVSTable->m_pMap->Count();
            if ( pVSTable->m_pMap->AllocateBlock(m_Schema.m_cRecs[ixTbl] + 1 - iCount) == 0 )
                IfFailGo( E_OUTOFMEMORY );

            // now build the table
            // Element 0 of m_pMap will never be used, its just being initialized anyway.
            for ( ULONG i = 0; i <= m_Schema.m_cRecs[ixTbl]; i++ )
            {
                *(pVSTable->m_pMap->Get(i)) = i;
            }
            // sort the table
            pVSTable->Sort();
        }
        // binary search on the LookUp
        {
            const void  *pRow;                  // Row from a table.
            ULONG       val;                    // Value from a row.
            CMiniColDef *pCol;
            int         lo,mid,hi;              // binary search indices.
            RID         ridEnd, ridBegin;

            pCol = m_TableDefs[ixTbl].m_pColDefs;

            // Start with entire table.
            lo = 1;
            hi = vGetCountRecs( ixTbl );
            // While there are rows in the range...
            while ( lo <= hi )
            {   // Look at the one in the middle.
                mid = (lo + hi) / 2;
                pRow = vGetRow( ixTbl, (ULONG)*(pVSTable->m_pMap->Get(mid)) );
                val = getIX( pRow, pCol[ixCol] );

                // If equal to the target, done.
                if ( val == ulVal )
                    break;
                // If middle item is too small, search the top half.
                if ( val < ulVal )
                    lo = mid + 1;
                else // but if middle is to big, search bottom half.
                    hi = mid - 1;
            }
            if ( lo > hi )
            {
                // Didn't find anything that matched.
                *pRidStart = 0;
                if (pRidEnd) *pRidEnd = 0;
                goto ErrExit;
            }


            // Now mid is pointing to one of the several records that match the search.
            // Find the beginning and find the end.
            ridBegin = mid;

            // End will be at least one larger than found record.
            ridEnd = ridBegin + 1;

            // Search back to start of group.
            while ( ridBegin > 1 &&
                    getIX(vGetRow(ixTbl, (ULONG)*(pVSTable->m_pMap->Get(ridBegin-1))), pCol[ixCol]) == ulVal )
                --ridBegin;

            // If desired, search forward to end of group.
            if ( pRidEnd )
            {
                while ( ridEnd <= vGetCountRecs(ixTbl) &&
                       getIX( vGetRow(ixTbl, (ULONG)*(pVSTable->m_pMap->Get(ridEnd))) , pCol[ixCol]) == ulVal )
                    ++ridEnd;
                *pRidEnd = ridEnd;
            }
            *pRidStart = ridBegin;
        }
    }

    // fall through
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::LookUpTableByCol()

RID CMiniMdRW::Impl_SearchTableRW(      // Rid of item, or 0.
    ULONG       ixTbl,                  // Table to search.
    ULONG       ixCol,                  // Column to search.
    ULONG       ulTarget)               // Value to search for.
{
    HRESULT     hr=S_OK;                // A result.
    RID         iRid;                   // The resulting RID.
    RID         iRidEnd;                // Unused.

    // Look up.
    hr = LookUpTableByCol(ulTarget, m_pVS[ixTbl], &iRid, &iRidEnd);
    if (FAILED(hr))
        iRid = 0;
    else // Convert to real RID.
        iRid = GetRidFromVirtualSort(ixTbl, iRid);

    return iRid;
} // RID CMiniMdRW::Impl_SearchTableRW()

//*****************************************************************************
// Search a table for the row containing the given key value.
//  EG. Constant table has pointer back to Param or Field.
//*****************************************************************************
RID CMiniMdRW::vSearchTable(		    // RID of matching row, or 0.
    ULONG       ixTbl,                  // Table to search.
    CMiniColDef sColumn,                // Sorted key column, containing search value.
    ULONG       ulTarget)               // Target for search.
{
    const void  *pRow;                  // Row from a table.
    ULONG       val;                    // Value from a row.

    int         lo,mid,hi;              // binary search indices.

    // Binary search requires sorted table.
    _ASSERTE(IsSorted(ixTbl));

    // Start with entire table.
    lo = 1;
    hi = vGetCountRecs(ixTbl);
    // While there are rows in the range...
    while (lo <= hi)
    {   // Look at the one in the middle.
        mid = (lo + hi) / 2;
        pRow = vGetRow(ixTbl, mid);
        val = getIX(pRow, sColumn);
        // If equal to the target, done.
        if (val == ulTarget)
            return mid;
        // If middle item is too small, search the top half.
        if (val < ulTarget || val == END_OF_TABLE)
            lo = mid + 1;
        else // but if middle is to big, search bottom half.
            hi = mid - 1;
    }
    // Didn't find anything that matched.
    return 0;
} // RID CMiniMdRW::vSearchTable()

//*****************************************************************************
// Search a table for the highest-RID row containing a value that is less than
//  or equal to the target value.  EG.  TypeDef points to first Field, but if
//  a TypeDef has no fields, it points to first field of next TypeDef.
// This is complicated by the possible presence of columns containing
//  END_OF_TABLE values, which are not necessarily in greater than
//  other values.  However, this invalid-rid value will occur only at the
//  end of the table.
//*****************************************************************************
RID CMiniMdRW::vSearchTableNotGreater( // RID of matching row, or 0.
    ULONG       ixTbl,                  // Table to search.
    CMiniColDef sColumn,                // the column def containing search value
    ULONG       ulTarget)               // target for search
{
    const void  *pRow;                  // Row from a table.
    ULONG       cRecs;                  // Rows in the table.
    ULONG       val;                    // Value from a table.
    ULONG       lo,mid,hi;              // binary search indices.

    cRecs = vGetCountRecs(ixTbl);

    // Start with entire table.
    lo = 1;
    hi = cRecs;
    // If no recs, return.
    if (lo > hi)
        return 0;
    // While there are rows in the range...
    while (lo <= hi)
    {   // Look at the one in the middle.
        mid = (lo + hi) / 2;
        pRow = vGetRow(ixTbl, mid);
        val = getIX(pRow, sColumn);
        // If equal to the target, done searching.
        if (val == ulTarget)
            break;
        // If middle item is too small, search the top half.
        if (val < ulTarget && val != END_OF_TABLE)
            lo = mid + 1;
        else // but if middle is to big, search bottom half.
            hi = mid - 1;
    }
    // May or may not have found anything that matched.  Mid will be close, but may
    //  be to high or too low.  It should point to the highest acceptable
    //  record.

    // If the value is greater than the target, back up just until the value is
    //  less than or equal to the target.  SHOULD only be one step.
    if (val > ulTarget || val == END_OF_TABLE)
    {
        while (val > ulTarget || val == END_OF_TABLE)
        {
            _ASSERTE(mid > 1);
            // If no recs match, return.
            if (mid == 1)
                return 0;
            --mid;
            pRow = vGetRow(ixTbl, mid);
            val = getIX(pRow, sColumn);
        }
    }
    else
    {
        // Value is less than or equal to the target.  As long as the next
        //  record is also acceptable, move forward.
        while (mid < cRecs)
        {
            // There is another record.  Get its value.
            pRow = vGetRow(ixTbl, mid+1);
            val = getIX(pRow, sColumn);
            // If that record is too high, stop.
            if (val > ulTarget || val == END_OF_TABLE)
                break;
            mid++;
        }
    }

    // Return the value that's just less than the target.
    return mid;
} // RID CMiniMdRW::vSearchTableNotGreater()



//*****************************************************************************
// Add a new memberref to the hash table.
//*****************************************************************************
HRESULT CMiniMdRW::AddMemberRefToHash(  // Return code.
    mdMemberRef mr)                     // Token of new guy.
{
    HRESULT     hr = S_OK;

    // If the hash table hasn't been built it, see if it should get faulted in.
    if (!m_pMemberRefHash)
    {
        ULONG ridEnd = getCountMemberRefs();
        if (ridEnd + 1 > INDEX_ROW_COUNT_THRESHOLD)
        {
            // Create a new hash.
            m_pMemberRefHash = new CMemberRefHash;
            IfNullGo( m_pMemberRefHash );
            IfFailGo(m_pMemberRefHash->NewInit(g_HashSize[m_iSizeHint]));

            // Scan every entry already in the table, add it to the hash.
            for (ULONG index = 1; index <= ridEnd; index ++ )
            {
                MemberRefRec *pMemberRef = getMemberRef(index);

                ULONG iHash = HashMemberRef(getClassOfMemberRef(pMemberRef),
                            getNameOfMemberRef(pMemberRef));

                TOKENHASHENTRY * pEntry = m_pMemberRefHash->Add(iHash);
                IfNullGo( pEntry );
                pEntry->tok = TokenFromRid(index, mdtMemberRef);
            }
        }
    }
    else
    {
        MemberRefRec *pMemberRef = getMemberRef(RidFromToken(mr));

        ULONG iHash = HashMemberRef(getClassOfMemberRef(pMemberRef),
                    getNameOfMemberRef(pMemberRef));

        TOKENHASHENTRY * pEntry = m_pMemberRefHash->Add(iHash);
        IfNullGo( pEntry );
        pEntry->tok = TokenFromRid(RidFromToken(mr), mdtMemberRef);

    }

ErrExit:
    return (hr);
} // HRESULT CMiniMdRW::AddMemberRefToHash()

//*****************************************************************************
// If the hash is built, search for the item.
//*****************************************************************************
int CMiniMdRW::FindMemberRefFromHash(   // How did it work.
    mdToken     tkParent,               // Parent token.
    LPCUTF8     szName,                 // Name of item.
    PCCOR_SIGNATURE pvSigBlob,          // Signature.
    ULONG       cbSigBlob,              // Size of signature.
    mdMemberRef *pmr)                   // Return if found.
{
    // If the table is there, look for the item in the chain of items.
    if (m_pMemberRefHash)
    {
        TOKENHASHENTRY *p;
        ULONG       iHash;
        int         pos;

        // Hash the data.
        iHash = HashMemberRef(tkParent, szName);

        // Go through every entry in the hash chain looking for ours.
        for (p = m_pMemberRefHash->FindFirst(iHash, pos);
             p;
             p = m_pMemberRefHash->FindNext(pos))
        {
            if ((CompareMemberRefs(p->tok, tkParent, szName, pvSigBlob, cbSigBlob) == S_OK)
				&&(*pmr != p->tok))
            {
                *pmr = p->tok;
                return (Found);
            }
        }

        return (NotFound);
    }
    else
        return (NoTable);
} // int CMiniMdRW::FindMemberRefFromHash()

//*****************************************************************************
// Check a given mr token to see if this one is a match.
//*****************************************************************************
HRESULT CMiniMdRW::CompareMemberRefs(   // S_OK match, S_FALSE no match.
    mdMemberRef mr,                     // Token to check.
    mdToken     tkPar,                  // Parent token.
    LPCUTF8     szNameUtf8,             // Name of item.
    PCCOR_SIGNATURE pvSigBlob,          // Signature.
    ULONG       cbSigBlob)              // Size of signature.
{
    MemberRefRec    *pMemberRef;
    LPCUTF8         szNameUtf8Tmp;
    PCCOR_SIGNATURE pvSigBlobTmp;
    ULONG           cbSigBlobTmp;

    pMemberRef = getMemberRef(RidFromToken(mr));
    if (!IsNilToken(tkPar))
    {
        // If caller specifies the tkPar and tkPar doesn't match,
        // try the next memberref.
        //
        if (tkPar != getClassOfMemberRef(pMemberRef))
            return (S_FALSE);
    }

    szNameUtf8Tmp = getNameOfMemberRef(pMemberRef);
    if ( strcmp(szNameUtf8Tmp, szNameUtf8) == 0 )
    {
        if ( pvSigBlob == NULL )
        {
            return (S_OK);
        }

        // Name matched. Now check the signature if caller suplies signature
        //
        if (cbSigBlob && pvSigBlob)
        {
            pvSigBlobTmp = getSignatureOfMemberRef(pMemberRef, &cbSigBlobTmp);
            if ( cbSigBlobTmp == cbSigBlob && memcmp(pvSigBlob, pvSigBlobTmp, cbSigBlob) == 0 )
            {
                return (S_OK);
            }
        }
    }
    return (S_FALSE);
} // HRESULT CMiniMdRW::CompareMemberRefs()


//*****************************************************************************
// Add a new memberdef to the hash table.
//*****************************************************************************
HRESULT CMiniMdRW::AddMemberDefToHash(  // Return code.
    mdToken     tkMember,               // Token of new guy. It can be MethodDef or FieldDef
    mdToken     tkParent)               // Parent token.
{
    HRESULT     hr = S_OK;
    ULONG       iHash;
    MEMBERDEFHASHENTRY *pEntry;

    // If the hash table hasn't been built it, see if it should get faulted in.
    if (!m_pMemberDefHash)
    {
        IfFailGo( CreateMemberDefHash() );
    }
    else
    {
        LPCUTF8 szName;
        if (TypeFromToken(tkMember) == mdtMethodDef)
        {
           szName = getNameOfMethod( getMethod(RidFromToken(tkMember)) );
        }
        else
        {
            _ASSERTE(TypeFromToken(tkMember) == mdtFieldDef);
           szName = getNameOfField( getField(RidFromToken(tkMember)) );
        }

        iHash = HashMemberDef(tkParent, szName);

        pEntry = m_pMemberDefHash->Add(iHash);
        IfNullGo( pEntry );
        pEntry->tok = tkMember;
        pEntry->tkParent = tkParent;

    }

ErrExit:
    return (hr);
} //HRESULT CMiniMdRW::AddMemberDefToHash()


//*****************************************************************************
// Create MemberDef Hash
//*****************************************************************************
HRESULT CMiniMdRW::CreateMemberDefHash()  // Return code.
{
    HRESULT     hr = S_OK;
    ULONG       iHash;
    MEMBERDEFHASHENTRY *pEntry;

    // If the hash table hasn't been built it, see if it should get faulted in.
    if (!m_pMemberDefHash)
    {
        ULONG       ridMethod = getCountMethods();
        ULONG       ridField = getCountFields();
        ULONG       iType;
        ULONG       ridStart, ridEnd;
        TypeDefRec  *pRec;
        MethodRec   *pMethod;
        FieldRec    *pField;

        if ((ridMethod + ridField + 1) > INDEX_ROW_COUNT_THRESHOLD)
        {
            // Create a new hash.
            m_pMemberDefHash = new CMemberDefHash;
            IfNullGo( m_pMemberDefHash );
            IfFailGo(m_pMemberDefHash->NewInit(g_HashSize[m_iSizeHint]));

            for (iType = 1; iType <= getCountTypeDefs(); iType++)
            {
		        pRec = getTypeDef(iType);
		        ridStart = getMethodListOfTypeDef(pRec);
		        ridEnd = getEndMethodListOfTypeDef(pRec);

                // add all of the methods of this typedef into hash table
                for (ridStart; ridStart < ridEnd; ridStart++ )
                {
                    pMethod = getMethod(GetMethodRid(ridStart));

                    iHash = HashMemberDef(TokenFromRid(iType, mdtTypeDef), getNameOfMethod(pMethod));

                    pEntry = m_pMemberDefHash->Add(iHash);
                    if (!pEntry)
                        IfFailGo(OutOfMemory());
                    pEntry->tok = TokenFromRid(GetMethodRid(ridStart), mdtMethodDef);
                    pEntry->tkParent = TokenFromRid(iType, mdtTypeDef);
                }

                // add all of the fields of this typedef into hash table
            	ridStart = getFieldListOfTypeDef(pRec);
		        ridEnd = getEndFieldListOfTypeDef(pRec);

                // Scan every entry already in the Method table, add it to the hash.
                for (ridStart; ridStart < ridEnd; ridStart++ )
                {
                    pField = getField(GetFieldRid(ridStart));

                    iHash = HashMemberDef(TokenFromRid(iType, mdtTypeDef), getNameOfField(pField));

                    pEntry = m_pMemberDefHash->Add(iHash);
                    IfNullGo( pEntry );
                    pEntry->tok = TokenFromRid(GetFieldRid(ridStart), mdtFieldDef);
                    pEntry->tkParent = TokenFromRid(iType, mdtTypeDef);
                }
            }
        }
    }
ErrExit:
    return (hr);
} //HRESULT CMiniMdRW::CreateMemberDefHash()

//*****************************************************************************
// If the hash is built, search for the item.
//*****************************************************************************
int CMiniMdRW::FindMemberDefFromHash(   // How did it work.
    mdToken     tkParent,               // Parent token.
    LPCUTF8     szName,                 // Name of item.
    PCCOR_SIGNATURE pvSigBlob,          // Signature.
    ULONG       cbSigBlob,              // Size of signature.
    mdToken     *ptkMember)             // Return if found. It can be MethodDef or FieldDef
{
    // check to see if we need to create hash table
    if (m_pMemberDefHash == NULL)
    {
        HRESULT     hr;
        hr = CreateMemberDefHash();

        // For whatever reason that we failed to build the hash, just delete the hash and keep going.
        if (FAILED(hr))
        {
            if (m_pMemberDefHash)
                delete m_pMemberDefHash;
            m_pMemberDefHash = NULL;
        }
    }

    // If the table is there, look for the item in the chain of items.
    if (m_pMemberDefHash)
    {
        MEMBERDEFHASHENTRY *pEntry;
        ULONG       iHash;
        int         pos;

        // Hash the data.
        iHash = HashMemberDef(tkParent, szName);

        // Go through every entry in the hash chain looking for ours.
        for (pEntry = m_pMemberDefHash->FindFirst(iHash, pos);
             pEntry;
             pEntry = m_pMemberDefHash->FindNext(pos))
        {
            if ((CompareMemberDefs(pEntry->tok, pEntry->tkParent, tkParent, szName, pvSigBlob, cbSigBlob) == S_OK)
				&& (pEntry->tok != *ptkMember))
            {
                *ptkMember = pEntry->tok;
                return (Found);
            }
        }

        return (NotFound);
    }
    else
        return (NoTable);
} // int CMiniMdRW::FindMemberDefFromHash()


//*****************************************************************************
// Check a given memberDef token to see if this one is a match.
//*****************************************************************************
HRESULT CMiniMdRW::CompareMemberDefs(   // S_OK match, S_FALSE no match.
    mdToken     tkMember,               // Token to check. It can be MethodDef or FieldDef
    mdToken     tkParent,               // Parent token recorded in the hash entry
    mdToken     tkPar,                  // Parent token.
    LPCUTF8     szNameUtf8,             // Name of item.
    PCCOR_SIGNATURE pvSigBlob,          // Signature.
    ULONG       cbSigBlob)              // Size of signature.
{
    MethodRec       *pMethod;
    FieldRec        *pField;
    LPCUTF8         szNameUtf8Tmp;
    PCCOR_SIGNATURE pvSigBlobTmp;
    ULONG           cbSigBlobTmp;
    bool            bPrivateScope;

    if (TypeFromToken(tkMember) == mdtMethodDef)
    {
        pMethod = getMethod(RidFromToken(tkMember));
        szNameUtf8Tmp = getNameOfMethod(pMethod);
        pvSigBlobTmp = getSignatureOfMethod(pMethod, &cbSigBlobTmp);
        bPrivateScope = IsMdPrivateScope(getFlagsOfMethod(pMethod));
    }
    else
    {
        _ASSERTE(TypeFromToken(tkMember) == mdtFieldDef);
        pField = getField(RidFromToken(tkMember));
        szNameUtf8Tmp = getNameOfField(pField);
        pvSigBlobTmp = getSignatureOfField(pField, &cbSigBlobTmp);
        bPrivateScope = IsFdPrivateScope(getFlagsOfField(pField));
    }
    if (bPrivateScope || tkPar != tkParent)
    {
        return (S_FALSE);
    }

    if ( strcmp(szNameUtf8Tmp, szNameUtf8) == 0 )
    {
        if ( pvSigBlob == NULL )
        {
            return (S_OK);
        }

        // Name matched. Now check the signature if caller suplies signature
        //
        if (cbSigBlob && pvSigBlob)
        {
            if ( cbSigBlobTmp == cbSigBlob && memcmp(pvSigBlob, pvSigBlobTmp, cbSigBlob) == 0 )
            {
                return (S_OK);
            }
        }
    }
    return (S_FALSE);
} // HRESULT CMiniMdRW::CompareMemberDefs()



//*************************************************************************
// If the hash is built, search for the item.
//*************************************************************************
int CMiniMdRW::FindCustomAttributeFromHash(// How did it work.
    mdToken     tkParent,               // Token that CA is associated with.
    mdToken     tkType,                 // Type of the CA.
    void        *pValue,                // the value of the CA
    ULONG       cbValue,                // count of bytes in the value
    mdCustomAttribute *pcv)
{
    CLookUpHash *pHashTable = m_pLookUpHashs[TBL_CustomAttribute];

    if (pHashTable == NULL)
    {
        HRESULT     hr;
        // Check to see if we need to build the hash table for CustomAttributes
        hr = GenericBuildHashTable(TBL_CustomAttribute, CustomAttributeRec::COL_Parent);
        if (FAILED(hr))
        {
            if (m_pLookUpHashs[TBL_CustomAttribute])
                delete m_pLookUpHashs[TBL_CustomAttribute];
            m_pLookUpHashs[TBL_CustomAttribute] = NULL;
        }
    }

    // If the table is there, look for the item in the chain of items.
    if (pHashTable)
    {
        TOKENHASHENTRY *p;
        ULONG       iHash;
        int         pos;
        mdToken     tkParentTmp;
        mdToken     tkTypeTmp;
        void        *pValueTmp;
        ULONG       cbTmp;

        // Hash the data.
        iHash = HashCustomAttribute(tkParent);

        // Go through every entry in the hash chain looking for ours.
        for (p = pHashTable->FindFirst(iHash, pos);
             p;
             p = pHashTable->FindNext(pos))
        {

            CustomAttributeRec *pCustomAttribute = getCustomAttribute(RidFromToken(p->tok));
            tkParentTmp = getParentOfCustomAttribute(pCustomAttribute);
            tkTypeTmp = getTypeOfCustomAttribute(pCustomAttribute);
            if (tkParentTmp == tkParent && tkType == tkTypeTmp)
            {
                // compare the blob value
                pValueTmp = (void *)getValueOfCustomAttribute(pCustomAttribute, &cbTmp);
                if (cbValue == cbTmp && memcmp(pValue, pValueTmp, cbValue) == 0)
                {
                    *pcv = p->tok;
                    return (Found);
                }
            }
        }

        return (NotFound);
    }
    else
        return (NoTable);
}


//*****************************************************************************
// Add a new NamedItem to the hash table.
//*****************************************************************************
HRESULT CMiniMdRW::AddNamedItemToHash(  // Return code.
    ULONG       ixTbl,                  // Table with the new item.
    mdToken     tk,                     // Token of new guy.
    LPCUTF8     szName,                 // Name of item.
    mdToken     tkParent)               // Token of parent, if any.
{
    HRESULT     hr = S_OK;
    void        *pNamedItem;            // A named item record.
    LPCUTF8     szItem;                 // Name of the item.
    mdToken     tkPar = 0;              // Parent token of the item.
    ULONG       iHash;                  // A named item's hash value.
    TOKENHASHENTRY *pEntry;             // New hash entry.

    // If the hash table hasn't been built it, see if it should get faulted in.
    if (!m_pNamedItemHash)
    {
        ULONG ridEnd = vGetCountRecs(ixTbl);
        if (ridEnd + 1 > INDEX_ROW_COUNT_THRESHOLD)
        {
            // OutputDebugStringA("Creating TypeRef hash\n");
            // Create a new hash.
            m_pNamedItemHash = new CMetaDataHashBase;
            if (!m_pNamedItemHash)
            {
                hr = OutOfMemory();
                goto ErrExit;
            }
            IfFailGo(m_pNamedItemHash->NewInit(g_HashSize[m_iSizeHint]));

            // Scan every entry already in the table, add it to the hash.
            for (ULONG index = 1; index <= ridEnd; index ++ )
            {
                pNamedItem = m_Table[ixTbl].GetRecord(index);
                szItem = getString(GetCol(ixTbl, g_TblIndex[ixTbl].m_iName, pNamedItem));
                if (g_TblIndex[ixTbl].m_iParent != -1)
                    tkPar = GetToken(ixTbl, g_TblIndex[ixTbl].m_iParent, pNamedItem);

                iHash = HashNamedItem(tkPar, szItem);

                pEntry = m_pNamedItemHash->Add(iHash);
                if (!pEntry)
                    IfFailGo(OutOfMemory());

                pEntry->tok = TokenFromRid(index, g_TblIndex[ixTbl].m_Token);
            }
        }
    }
    else
    {
        tk = RidFromToken(tk);
        pNamedItem = m_Table[ixTbl].GetRecord((ULONG)tk);
        szItem = getString(GetCol(ixTbl, g_TblIndex[ixTbl].m_iName, pNamedItem));
        if (g_TblIndex[ixTbl].m_iParent != -1)
            tkPar = GetToken(ixTbl, g_TblIndex[ixTbl].m_iParent, pNamedItem);

        iHash = HashNamedItem(tkPar, szItem);

        pEntry = m_pNamedItemHash->Add(iHash);
        if (!pEntry)
            IfFailGo(OutOfMemory());

        pEntry->tok = TokenFromRid(tk, g_TblIndex[ixTbl].m_Token);
    }

ErrExit:
    return (hr);
} // HRESULT CMiniMdRW::AddNamedItemToHash()

//*****************************************************************************
// If the hash is built, search for the item.
//*****************************************************************************
int CMiniMdRW::FindNamedItemFromHash(   // How did it work.
    ULONG       ixTbl,                  // Table with the item.
    LPCUTF8     szName,                 // Name of item.
    mdToken     tkParent,               // Token of parent, if any.
    mdToken     *ptk)                   // Return if found.
{
    // If the table is there, look for the item in the chain of items.
    if (m_pNamedItemHash)
    {
        TOKENHASHENTRY *p;              // Hash entry from chain.
        ULONG       iHash;              // Item's hash value.
        int         pos;                // Position in hash chain.
        mdToken     type;               // Type of the item being sought.

        type = g_TblIndex[ixTbl].m_Token;

        // Hash the data.
        iHash = HashNamedItem(tkParent, szName);

        // Go through every entry in the hash chain looking for ours.
        for (p = m_pNamedItemHash->FindFirst(iHash, pos);
             p;
             p = m_pNamedItemHash->FindNext(pos))
        {   // Check that the item is from the right table.
            if (TypeFromToken(p->tok) != (ULONG)type)
            {
                //@FUTURE: if using the named item hash for multiple tables, remove
                //  this check.  Until then, debugging aid.
                _ASSERTE(!"Table mismatch in hash chain");
                continue;
            }
            // Item is in the right table, do the deeper check.
            if (CompareNamedItems(ixTbl, p->tok, szName, tkParent) == S_OK)
            {
                *ptk = p->tok;
                return (Found);
            }
        }

        return (NotFound);
    }
    else
        return (NoTable);
} // int CMiniMdRW::FindNamedItemFromHash()

//*****************************************************************************
// Check a given mr token to see if this one is a match.
//*****************************************************************************
HRESULT CMiniMdRW::CompareNamedItems(   // S_OK match, S_FALSE no match.
    ULONG       ixTbl,                  // Table with the item.
    mdToken     tk,                     // Token to check.
    LPCUTF8     szName,                 // Name of item.
    mdToken     tkParent)               // Token of parent, if any.
{
    void        *pNamedItem;            // Item to check.
    LPCUTF8     szNameUtf8Tmp;          // Name of item to check.

    // Get the record.
    pNamedItem = m_Table[ixTbl].GetRecord(RidFromToken(tk));

    // Name is cheaper to get than coded token parent, and fails pretty quickly.
    szNameUtf8Tmp = getString(GetCol(ixTbl, g_TblIndex[ixTbl].m_iName, pNamedItem));
    if ( strcmp(szNameUtf8Tmp, szName) != 0 )
        return S_FALSE;

    // Name matched, try parent, if any.
    if (g_TblIndex[ixTbl].m_iParent != -1)
    {
        mdToken tkPar = GetToken(ixTbl, g_TblIndex[ixTbl].m_iParent, pNamedItem);
        if (tkPar != tkParent)
            return S_FALSE;
    }

    // Made it to here, so everything matched.
    return (S_OK);
} // HRESULT CMiniMdRW::CompareNamedItems()

//*****************************************************************************
// Add <md, td> entry to the MethodDef map look up table
//*****************************************************************************
HRESULT CMiniMdRW::AddMethodToLookUpTable(
    mdMethodDef md,
    mdTypeDef   td)
{
    HRESULT     hr = NOERROR;
    mdToken     *ptk;
    _ASSERTE( TypeFromToken(md) == mdtMethodDef && HasIndirectTable(TBL_Method) );

    if ( m_pMethodMap)
    {
        // Only add to the lookup table if it has been built already by demand.
        //
        // The first entry in the map is a dummy entry.
        // The i'th index entry of the map is the td for methoddef of i.
        // We do expect the methoddef tokens are all added when the map exist.
        //
        _ASSERTE( RidFromToken(md) == (ULONG) m_pMethodMap->Count() );
        ptk = m_pMethodMap->Append();
        IfNullGo( ptk );
        *ptk = td;
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddMethodToLookUpTable()

//*****************************************************************************
// Add <fd, td> entry to the FieldDef map look up table
//*****************************************************************************
HRESULT CMiniMdRW::AddFieldToLookUpTable(
    mdFieldDef  fd,
    mdTypeDef   td)
{
    HRESULT     hr = NOERROR;
    mdToken     *ptk;
    _ASSERTE( TypeFromToken(fd) == mdtFieldDef && HasIndirectTable(TBL_Field) );
    if ( m_pFieldMap )
    {
        // Only add to the lookup table if it has been built already by demand.
        //
        // The first entry in the map is a dummy entry.
        // The i'th index entry of the map is the td for fielddef of i.
        // We do expect the fielddef tokens are all added when the map exist.
        //
        _ASSERTE( RidFromToken(fd) == (ULONG) m_pFieldMap->Count() );
        ptk = m_pFieldMap->Append();
        IfNullGo( ptk );
        *ptk = td;
    }

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddFieldToLookUpTable()

//*****************************************************************************
// Add <pr, td> entry to the Property map look up table
//*****************************************************************************
HRESULT CMiniMdRW::AddPropertyToLookUpTable(
    mdProperty  pr,
    mdTypeDef   td)
{
    HRESULT     hr = NOERROR;
    mdToken     *ptk;
    _ASSERTE( TypeFromToken(pr) == mdtProperty && HasIndirectTable(TBL_Property) );

    if ( m_pPropertyMap )
    {
        // Only add to the lookup table if it has been built already by demand.
        //
        // The first entry in the map is a dummy entry.
        // The i'th index entry of the map is the td for property of i.
        // We do expect the property tokens are all added when the map exist.
        //
        _ASSERTE( RidFromToken(pr) == (ULONG) m_pPropertyMap->Count() );
        ptk = m_pPropertyMap->Append();
        IfNullGo( ptk );
        *ptk = td;
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddPropertyToLookUpTable()

//*****************************************************************************
// Add <ev, td> entry to the Event map look up table
//*****************************************************************************
HRESULT CMiniMdRW::AddEventToLookUpTable(
    mdEvent     ev,
    mdTypeDef   td)
{
    HRESULT     hr = NOERROR;
    mdToken     *ptk;
    _ASSERTE( TypeFromToken(ev) == mdtEvent && HasIndirectTable(TBL_Event) );

    if ( m_pEventMap )
    {
        // Only add to the lookup table if it has been built already by demand.
        //
        // now add to the EventMap table
        _ASSERTE( RidFromToken(ev) == (ULONG) m_pEventMap->Count() );
        ptk = m_pEventMap->Append();
        IfNullGo( ptk );
        *ptk = td;
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddEventToLookUpTable()

//*****************************************************************************
// Add <pd, md> entry to the Param map look up table
//*****************************************************************************
HRESULT CMiniMdRW::AddParamToLookUpTable(
    mdParamDef  pd,
    mdMethodDef md)
{
    HRESULT     hr = NOERROR;
    mdToken     *ptk;
    _ASSERTE( TypeFromToken(pd) == mdtParamDef && HasIndirectTable(TBL_Param) );

    if ( m_pParamMap )
    {
        // Only add to the lookup table if it has been built already by demand.
        //
        // now add to the EventMap table
        _ASSERTE( RidFromToken(pd) == (ULONG) m_pParamMap->Count() );
        ptk = m_pParamMap->Append();
        IfNullGo( ptk );
        *ptk = md;
    }
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::AddParamToLookUpTable()

//*****************************************************************************
// Find parent for a method token. This will use the lookup table if there is an
// intermediate table. Or it will use FindMethodOfParent helper
//*****************************************************************************
HRESULT CMiniMdRW::FindParentOfMethodHelper(
    mdMethodDef md,                     // [IN] the methoddef token
    mdTypeDef   *ptd)                   // [OUT] the parent token
{
    HRESULT     hr = NOERROR;
    if ( HasIndirectTable(TBL_Method) )
    {
        if (m_pMethodMap == NULL)
        {
            ULONG       indexTd;
            ULONG       indexMd;
            ULONG       ridStart, ridEnd;
            TypeDefRec  *pTypeDefRec;
            MethodPtrRec *pMethodPtrRec;

            // build the MethodMap table
            m_pMethodMap = new TOKENMAP;
            IfNullGo( m_pMethodMap );
            if ( m_pMethodMap->AllocateBlock(m_Schema.m_cRecs[TBL_Method] + 1) == 0 )
                IfFailGo( E_OUTOFMEMORY );
            for (indexTd = 1; indexTd<= m_Schema.m_cRecs[TBL_TypeDef]; indexTd++)
            {
                pTypeDefRec = getTypeDef(indexTd);
                ridStart = getMethodListOfTypeDef(pTypeDefRec);
                ridEnd = getEndMethodListOfTypeDef(pTypeDefRec);

                for (indexMd = ridStart; indexMd < ridEnd; indexMd++)
                {
                    pMethodPtrRec = getMethodPtr(indexMd);
                    *(m_pMethodMap->Get(getMethodOfMethodPtr(pMethodPtrRec))) = indexTd;
                }
            }
        }
        *ptd = *(m_pMethodMap->Get(RidFromToken(md)));
    }
    else
    {
        *ptd = FindParentOfMethod(RidFromToken(md));
    }
    RidToToken(*ptd, mdtTypeDef);
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FindParentOfMethodHelper()

//*****************************************************************************
// Find parent for a field token. This will use the lookup table if there is an
// intermediate table. Or it will use FindFieldOfParent helper
//*****************************************************************************
HRESULT CMiniMdRW::FindParentOfFieldHelper(
    mdFieldDef  fd,                     // [IN] fielddef token
    mdTypeDef   *ptd)                   // [OUT] parent token
{
    HRESULT     hr = NOERROR;
    if ( HasIndirectTable(TBL_Field) )
    {
        if (m_pFieldMap == NULL)
        {
            ULONG       indexTd;
            ULONG       indexFd;
            ULONG       ridStart, ridEnd;
            TypeDefRec  *pTypeDefRec;
            FieldPtrRec *pFieldPtrRec;

            // build the FieldMap table
            m_pFieldMap = new TOKENMAP;
            IfNullGo( m_pFieldMap );
            if ( m_pFieldMap->AllocateBlock(m_Schema.m_cRecs[TBL_Field] + 1) == 0 )
                IfFailGo( E_OUTOFMEMORY );
            for (indexTd = 1; indexTd<= m_Schema.m_cRecs[TBL_TypeDef]; indexTd++)
            {
                pTypeDefRec = getTypeDef(indexTd);
                ridStart = getFieldListOfTypeDef(pTypeDefRec);
                ridEnd = getEndFieldListOfTypeDef(pTypeDefRec);

                for (indexFd = ridStart; indexFd < ridEnd; indexFd++)
                {
                    pFieldPtrRec = getFieldPtr(indexFd);
                    *(m_pFieldMap->Get(getFieldOfFieldPtr(pFieldPtrRec))) = indexTd;
                }
            }
        }
        *ptd = *(m_pFieldMap->Get(RidFromToken(fd)));
    }
    else
    {
        *ptd = FindParentOfField(RidFromToken(fd));
    }
    RidToToken(*ptd, mdtTypeDef);
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FindParentOfFieldHelper()

//*****************************************************************************
// Find parent for a property token. This will use the lookup table if there is an
// intermediate table.
//*****************************************************************************
HRESULT CMiniMdRW::FindParentOfPropertyHelper(
    mdProperty  pr,
    mdTypeDef   *ptd)
{
    HRESULT     hr = NOERROR;
    if ( HasIndirectTable(TBL_Property) )
    {
        if (m_pPropertyMap == NULL)
        {
            ULONG       indexMap;
            ULONG       indexPr;
            ULONG       ridStart, ridEnd;
            PropertyMapRec  *pPropertyMapRec;
            PropertyPtrRec  *pPropertyPtrRec;

            // build the PropertyMap table
            m_pPropertyMap = new TOKENMAP;
            IfNullGo( m_pPropertyMap );
            if ( m_pPropertyMap->AllocateBlock(m_Schema.m_cRecs[TBL_Property] + 1) == 0 )
                IfFailGo( E_OUTOFMEMORY );
            for (indexMap = 1; indexMap<= m_Schema.m_cRecs[TBL_PropertyMap]; indexMap++)
            {
                pPropertyMapRec = getPropertyMap(indexMap);
                ridStart = getPropertyListOfPropertyMap(pPropertyMapRec);
                ridEnd = getEndPropertyListOfPropertyMap(pPropertyMapRec);

                for (indexPr = ridStart; indexPr < ridEnd; indexPr++)
                {
                    pPropertyPtrRec = getPropertyPtr(indexPr);
                    *(m_pPropertyMap->Get(getPropertyOfPropertyPtr(pPropertyPtrRec))) = getParentOfPropertyMap(pPropertyMapRec);
                }
            }
        }
        *ptd = *(m_pPropertyMap->Get(RidFromToken(pr)));
    }
    else
    {
        RID         ridPropertyMap;
        PropertyMapRec *pRec;

        ridPropertyMap = FindPropertyMapParentOfProperty( RidFromToken( pr ) );
        pRec = getPropertyMap( ridPropertyMap );
        *ptd = getParentOfPropertyMap( pRec );
    }
    RidToToken(*ptd, mdtTypeDef);
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FindParentOfPropertyHelper()

//*****************************************************************************
// Find parent for an Event token. This will use the lookup table if there is an
// intermediate table.
//*****************************************************************************
HRESULT CMiniMdRW::FindParentOfEventHelper(
    mdEvent     ev,
    mdTypeDef   *ptd)
{
    HRESULT     hr = NOERROR;
    if ( HasIndirectTable(TBL_Event) )
    {
        if (m_pEventMap == NULL)
        {
            ULONG       indexMap;
            ULONG       indexEv;
            ULONG       ridStart, ridEnd;
            EventMapRec *pEventMapRec;
            EventPtrRec  *pEventPtrRec;

            // build the EventMap table
            m_pEventMap = new TOKENMAP;
            IfNullGo( m_pEventMap );
            if ( m_pEventMap->AllocateBlock(m_Schema.m_cRecs[TBL_Event] + 1) == 0 )
                IfFailGo( E_OUTOFMEMORY );
            for (indexMap = 1; indexMap<= m_Schema.m_cRecs[TBL_EventMap]; indexMap++)
            {
                pEventMapRec = getEventMap(indexMap);
                ridStart = getEventListOfEventMap(pEventMapRec);
                ridEnd = getEndEventListOfEventMap(pEventMapRec);

                for (indexEv = ridStart; indexEv < ridEnd; indexEv++)
                {
                    pEventPtrRec = getEventPtr(indexEv);
                    *(m_pEventMap->Get(getEventOfEventPtr(pEventPtrRec))) = getParentOfEventMap(pEventMapRec);
                }
            }
        }
        *ptd = *(m_pEventMap->Get(RidFromToken(ev)));
    }
    else
    {
        RID         ridEventMap;
        EventMapRec *pRec;

        ridEventMap = FindEventMapParentOfEvent( RidFromToken( ev ) );
        pRec = getEventMap( ridEventMap );
        *ptd = getParentOfEventMap( pRec );
    }
    RidToToken(*ptd, mdtTypeDef);
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FindParentOfEventHelper()

//*****************************************************************************
// Find parent for a ParamDef token. This will use the lookup table if there is an
// intermediate table.
//*****************************************************************************
HRESULT CMiniMdRW::FindParentOfParamHelper(
    mdParamDef  pd,
    mdMethodDef *pmd)
{
    HRESULT     hr = NOERROR;
    if ( HasIndirectTable(TBL_Param) )
    {
        if (m_pParamMap == NULL)
        {
            ULONG       indexMd;
            ULONG       indexPd;
            ULONG       ridStart, ridEnd;
            MethodRec   *pMethodRec;
            ParamPtrRec *pParamPtrRec;

            // build the ParamMap table
            m_pParamMap = new TOKENMAP;
            IfNullGo( m_pParamMap );
            if ( m_pParamMap->AllocateBlock(m_Schema.m_cRecs[TBL_Param] + 1) == 0 )
                IfFailGo( E_OUTOFMEMORY );
            for (indexMd = 1; indexMd<= m_Schema.m_cRecs[TBL_Method]; indexMd++)
            {
                pMethodRec = getMethod(indexMd);
                ridStart = getParamListOfMethod(pMethodRec);
                ridEnd = getEndParamListOfMethod(pMethodRec);

                for (indexPd = ridStart; indexPd < ridEnd; indexPd++)
                {
                    pParamPtrRec = getParamPtr(indexPd);
                    *(m_pParamMap->Get(getParamOfParamPtr(pParamPtrRec))) = indexMd;
                }
            }
        }
        *pmd = *(m_pParamMap->Get(RidFromToken(pd)));
    }
    else
    {
        *pmd = FindParentOfParam(RidFromToken(pd));
    }
    RidToToken(*pmd, mdtMethodDef);
ErrExit:
    return hr;
} // HRESULT CMiniMdRW::FindParentOfParamHelper()


//******************************************************************************
// Add an entry in the ENC Log table.
//******************************************************************************
HRESULT CMiniMdRW::UpdateENCLogHelper(  // S_OK or error.
    mdToken     tk,                     // Token to be added to the ENCLog table.
    CMiniMdRW::eDeltaFuncs funccode)    // Specifies the optional function code..
{
    ENCLogRec   *pRecord;
    RID         iRecord;
    HRESULT     hr = S_OK;

    IfNullGo(pRecord = AddENCLogRecord(&iRecord));
    pRecord->m_Token = tk;
    pRecord->m_FuncCode = funccode;

ErrExit:
    return hr;
} // CMiniMdRW RegMeta::UpdateENCLogHelper()

HRESULT CMiniMdRW::UpdateENCLogHelper2( // S_OK or error.
    ULONG       ixTbl,                  // Table being updated.
    ULONG       iRid,                   // Record within table.
    CMiniMdRW::eDeltaFuncs funccode)    // Specifies the optional function code..
{
    ENCLogRec   *pRecord;
    RID         iRecord;
    HRESULT     hr = S_OK;

    IfNullGo(pRecord = AddENCLogRecord(&iRecord));
    pRecord->m_Token = RecIdFromRid(iRid, ixTbl);
    pRecord->m_FuncCode = funccode;

ErrExit:
    return hr;
} // HRESULT CMiniMdRW::UpdateENCLogHelper2()

//*****************************************************************************
//
// Sort the whole RID table
//
//*****************************************************************************
void VirtualSort::Sort()
{
    m_isMapValid = true;
    // Note that m_pMap stores an additional bogus element at count 0.  This is
    // just so we can align the index in m_pMap with the Rids which are 1 based.
    SortRange(1, m_pMap->Count() - 1);
} // void VirtualSort::Sort()

//*****************************************************************************
//
// Sort the range from iLeft to iRight
//
//*****************************************************************************
void VirtualSort::SortRange(
    int         iLeft,
    int         iRight)
{
    int         iLast;
    int         i;                      // loop variable.

    // if less than two elements you're done.
    if (iLeft >= iRight)
        return;

    // The mid-element is the pivot, move it to the left.
    Swap(iLeft, (iLeft+iRight)/2);
    iLast = iLeft;

    // move everything that is smaller than the pivot to the left.
    for(i = iLeft+1; i <= iRight; i++)
        if (Compare(i, iLeft) < 0)
            Swap(i, ++iLast);

    // Put the pivot to the point where it is in between smaller and larger elements.
    Swap(iLeft, iLast);

    // Sort the each partition.
    SortRange(iLeft, iLast-1);
    SortRange(iLast+1, iRight);
} // void VirtualSort::SortRange()

//*****************************************************************************
//
// Compare two RID base on the m_ixTbl's m_ixCol
//
//*****************************************************************************
int VirtualSort::Compare(               // -1, 0, or 1
    RID  iLeft,                     // First item to compare.
    RID  iRight)                    // Second item to compare.
{
    RID         ridLeft = *(m_pMap->Get(iLeft));
    RID         ridRight = *(m_pMap->Get(iRight));
    const void  *pRow;                  // Row from a table.
    ULONG       valRight, valLeft;      // Value from a row.

    pRow = m_pMiniMd->vGetRow(m_ixTbl, ridLeft);
    valLeft = m_pMiniMd->getIX(pRow, m_pMiniMd->m_TableDefs[m_ixTbl].m_pColDefs[m_ixCol]);
    pRow = m_pMiniMd->vGetRow(m_ixTbl, ridRight);
    valRight = m_pMiniMd->getIX(pRow, m_pMiniMd->m_TableDefs[m_ixTbl].m_pColDefs[m_ixCol]);

    if ( valLeft < valRight  )
        return -1;
    if ( valLeft > valRight )
        return 1;
    // Values are equal -- preserve existing ordering.
    if ( ridLeft < ridRight )
        return -1;
    if ( ridLeft > ridRight )
        return 1;
    // Comparing an item to itself?
    _ASSERTE(!"Comparing an item to itself in sort");
    return 0;
} // int VirtualSort::Compare()

//*****************************************************************************
//
// Initialization function
//
//*****************************************************************************
void VirtualSort::Init(                 //
    ULONG       ixTbl,                  // Table index.
    ULONG       ixCol,                  // Column index.
    CMiniMdRW *pMiniMd)                 // MiniMD with data.
{
    m_pMap = NULL;
    m_isMapValid = false;
    m_ixTbl = ixTbl;
    m_ixCol = ixCol;
    m_pMiniMd = pMiniMd;
}// VirtualSort::Init()


//*****************************************************************************
//
// Uninitialization function
//
//*****************************************************************************
void VirtualSort::Uninit()
{
    if ( m_pMap )
        delete m_pMap;
    m_pMap = NULL;
    m_isMapValid = false;
} // void VirtualSort::Uninit()


//*****************************************************************************
//
// Mark a token
//
//*****************************************************************************
HRESULT FilterTable::MarkToken(
    mdToken     tk,                         // token to be marked as to keep
    DWORD       bitToMark)                  // bit flag to set in the keep table
{
    HRESULT     hr = NOERROR;
    RID         rid = RidFromToken(tk);

    if ( (Count() == 0) || ((RID)(Count() -1)) < rid )
    {
        // grow table
        IfFailGo( AllocateBlock( rid + 1 - Count() ) );
    }

#if _DEBUG
    if ( (*Get(rid)) & bitToMark )
    {
        // global TypeDef could be marked more than once so don't assert if token is mdtTypeDef
        if (TypeFromToken(tk) != mdtTypeDef)
            _ASSERTE(!"Token has been Marked");
    }
#endif // _DEBUG

    // set the keep bit
    *Get(rid) = (*Get(rid)) | bitToMark;
ErrExit:
    return hr;
} // HRESULT FilterTable::MarkToken()


//*****************************************************************************
//
// Unmark a token
//
//*****************************************************************************
HRESULT FilterTable::UnmarkToken(
    mdToken     tk,                         // token to be unmarked as deleted.
    DWORD       bitToMark)                  // bit flag to unset in the keep table
{
    RID         rid = RidFromToken(tk);

    if ( (Count() == 0) || ((RID)(Count() -1)) < rid )
    {
        // unmarking should not have grown table. It currently only support dropping the transient CAs.
        _ASSERTE(!"BAD state!");
    }

#if _DEBUG
    if ( (*Get(rid)) & bitToMark )
    {
        // global TypeDef could be marked more than once so don't assert if token is mdtTypeDef
        if (TypeFromToken(tk) != mdtTypeDef)
            _ASSERTE(!"Token has been Marked");
    }
#endif // _DEBUG

    // unset the keep bit
    *Get(rid) = (*Get(rid)) & ~bitToMark;
    return NOERROR;
} // HRESULT FilterTable::MarkToken()


//*****************************************************************************
//
// Mark an UserString token
//
//*****************************************************************************
HRESULT FilterTable::MarkUserString(
    mdString        str)
{
    HRESULT         hr = NOERROR;
    int             high, low, mid;

    low = 0;
    high = m_daUserStringMarker->Count() - 1;
    while (low <= high)
    {
        mid = (high + low) / 2;
        if ((m_daUserStringMarker->Get(mid))->m_tkString > (DWORD) str)
        {
            high = mid - 1;
        }
        else if ((m_daUserStringMarker->Get(mid))->m_tkString < (DWORD) str)
        {
            low = mid + 1;
        }
        else
        {
            (m_daUserStringMarker->Get(mid))->m_fMarked = true;
            return NOERROR;
        }
    }
    _ASSERTE(!"Bad Token!");
    return NOERROR;
} // HRESULT FilterTable::MarkUserString()

//*****************************************************************************
//
// Unmarking from 1 to ulSize for all tokens.
//
//*****************************************************************************
HRESULT FilterTable::UnmarkAll(
    CMiniMdRW   *pMiniMd,
    ULONG       ulSize)
{
    HRESULT         hr;
    ULONG           ulOffset = 0;
    ULONG           ulNext;
    ULONG           cbBlob;
    FilterUserStringEntry *pItem;

    IfFailRet( AllocateBlock( ulSize + 1) );
    memset(Get(0), 0, (ulSize+1) *sizeof(DWORD));

    // unmark all of the user string
    m_daUserStringMarker = new CDynArray<FilterUserStringEntry>();
    IfNullGo(m_daUserStringMarker);
    while (ulOffset != -1)
    {
        pMiniMd->GetUserStringNext(ulOffset, &cbBlob, &ulNext);

        // Skip over padding.
        if (!cbBlob)
        {
            ulOffset = ulNext;
            continue;
        }
        pItem = m_daUserStringMarker->Append();
        pItem->m_tkString = TokenFromRid(ulOffset, mdtString);
        pItem->m_fMarked = false;
        ulOffset = ulNext;
    }


ErrExit:
    return hr;
} // HRESULT FilterTable::UnmarkAll()



//*****************************************************************************
//
// Marking from 1 to ulSize for all tokens.
//
//*****************************************************************************
HRESULT FilterTable::MarkAll(
    CMiniMdRW   *pMiniMd,
    ULONG       ulSize)
{
    HRESULT         hr;
    ULONG           ulOffset = 0;
    ULONG           ulNext;
    ULONG           cbBlob;
    FilterUserStringEntry *pItem;

    IfFailRet( AllocateBlock( ulSize + 1) );
    memset(Get(0), 0xFFFFFFFF, (ulSize+1) *sizeof(DWORD));

    // mark all of the user string
    m_daUserStringMarker = new CDynArray<FilterUserStringEntry>();
    IfNullGo(m_daUserStringMarker);
    while (ulOffset != -1)
    {
        pMiniMd->GetUserStringNext(ulOffset, &cbBlob, &ulNext);

        // Skip over padding.
        if (!cbBlob)
        {
            ulOffset = ulNext;
            continue;
        }
        pItem = m_daUserStringMarker->Append();
        pItem->m_tkString = TokenFromRid(ulOffset, mdtString);
        pItem->m_fMarked = true;
        ulOffset = ulNext;
    }


ErrExit:
    return hr;
} // HRESULT FilterTable::MarkAll()

//*****************************************************************************
//
// return true if a token is marked. Otherwise return false.
//
//*****************************************************************************
bool FilterTable::IsTokenMarked(
    mdToken     tk,                         // Token to inquiry
    DWORD       bitMarked)                  // bit flag to check in the deletion table
{
    RID     rid = RidFromToken(tk);

    // @FUTURE: inconsistency!!!
    // If caller unmarked everything while the module has 2 typedef and 10 methodef.
    // We will have 11 rows in the FilterTable. Then user add the 3 typedef, it is
    // considered unmarked unless we mark it when we do DefineTypeDef. However, if user
    // add another MethodDef, it will be considered marked unless we unmarked.....
    // Maybe the solution is not to support DefineXXXX if you use the filter interface??

    if ( (Count() == 0) || ((RID)(Count() - 1)) < rid )
    {
        // If UnmarkAll has never been called or tk is added after UnmarkAll,
        // tk is considered marked.
        //
        return true;
    }
    return ( (*Get(rid)) & bitMarked ? true : false);
}   // IsTokenMarked


//*****************************************************************************
//
// return true if a token is marked. Otherwise return false.
//
//*****************************************************************************
bool FilterTable::IsTokenMarked(
    mdToken     tk)                         // Token to inquiry
{

    switch ( TypeFromToken(tk) )
    {
    case mdtTypeRef:
        return IsTypeRefMarked(tk);
    case mdtTypeDef:
        return IsTypeDefMarked(tk);
    case mdtFieldDef:
        return IsFieldMarked(tk);
    case mdtMethodDef:
        return IsMethodMarked(tk);
    case mdtParamDef:
        return IsParamMarked(tk);
    case mdtMemberRef:
        return IsMemberRefMarked(tk);
    case mdtCustomAttribute:
        return IsCustomAttributeMarked(tk);
    case mdtPermission:
        return IsDeclSecurityMarked(tk);
    case mdtSignature:
        return IsSignatureMarked(tk);
    case mdtEvent:
        return IsEventMarked(tk);
    case mdtProperty:
        return IsPropertyMarked(tk);
    case mdtModuleRef:
        return IsModuleRefMarked(tk);
    case mdtTypeSpec:
        return IsTypeSpecMarked(tk);
    case mdtInterfaceImpl:
        return IsInterfaceImplMarked(tk);
    case mdtString:
        return IsUserStringMarked(tk);
    default:
        _ASSERTE(!"Bad token type!");
        break;
    }
    return false;
}   // IsTokenMarked


//*****************************************************************************
//
// return true if the associated property or event is marked.
//
//*****************************************************************************
bool FilterTable::IsMethodSemanticsMarked(
    CMiniMdRW   *pMiniMd,
    RID         rid)
{
    MethodSemanticsRec  *pRec;
    mdToken             tkAssoc;

    // InterfaceImpl is marked if the containing TypeDef is marked
    pRec = pMiniMd->getMethodSemantics( rid );
    tkAssoc = pMiniMd->getAssociationOfMethodSemantics( pRec );
    if ( TypeFromToken(tkAssoc) == mdtProperty )
        return IsPropertyMarked( tkAssoc );
    else
    {
        _ASSERTE( TypeFromToken(tkAssoc) == mdtEvent );
        return IsEventMarked(tkAssoc);
    }
}   // IsMethodSemanticsMarked


//*****************************************************************************
//
// return true if an UserString is marked.
//
//*****************************************************************************
bool FilterTable::IsUserStringMarked(mdString str)
{
    int         low, mid, high;

    // if m_daUserStringMarker is not created, UnmarkAll has never been called
    if (m_daUserStringMarker == NULL)
        return true;

    low = 0;
    high = m_daUserStringMarker->Count() - 1;
    while (low <= high)
    {
        mid = (high + low) / 2;
        if ((m_daUserStringMarker->Get(mid))->m_tkString > (DWORD) str)
        {
            high = mid - 1;
        }
        else if ((m_daUserStringMarker->Get(mid))->m_tkString < (DWORD) str)
        {
            low = mid + 1;
        }
        else
        {
            return (m_daUserStringMarker->Get(mid))->m_fMarked;
        }
    }
    _ASSERTE(!"Bad Token!");
    return false;
}   // FilterTable::IsUserStringMarked(CMiniMdRW *pMiniMd, mdString str)


//*****************************************************************************
//
// destructor
//
//*****************************************************************************
FilterTable::~FilterTable()
{
    if (m_daUserStringMarker)
        delete m_daUserStringMarker;
    Clear();
}   // FilterTable::~FilterTable()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\stdafx.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.h
//
// Precompiled headers.
//
//*****************************************************************************
#pragma once

#include <CrtWrap.h>
#include <WinWrap.h>
#include <utilcode.h>

#include <cor.h>
#include <corpriv.h>

#include "MDCommon.h"

#include "UTSem.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\rwutil.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// Util.cpp
//
// contains utility code to MD directory
//
//*****************************************************************************
#include "stdafx.h"
#include "MetaData.h"
#include "RWUtil.h"
#include "UTSem.h" 
#include "..\inc\mdlog.h"

//*****************************************************************************
// IMetaDataRegImport methods
//*****************************************************************************
LPUTF8 Unicode2UTF(
    LPCWSTR     pwszSrc,						// The string to convert.
    LPUTF8		pszDst)							// The QuickArray<WCHAR> to convert it into.
{
   int cchSrc = (int)wcslen(pwszSrc);
   int cchRet = WszWideCharToMultiByte(
	   CP_UTF8, 
	   0, 
	   pwszSrc, 
	   cchSrc + 1, 
	   pszDst, 
	   cchSrc * 3 + 1, 
	   NULL, 
	   NULL);

   _ASSERTE(cchRet && "converting uncode string to UTF8 string failed!");

   // Ensure buffer is nul terminated.
   pszDst[cchSrc*3] = '\0';

   return pszDst;
}	// Unicode2UTF


HRESULT HENUMInternal::CreateSimpleEnum(
	DWORD			tkKind,				// kind of token that we are iterating
	ULONG			ridStart,			// starting rid
	ULONG			ridEnd,				// end rid
	HENUMInternal	**ppEnum)			// return the created HENUMInternal
{
	HENUMInternal	*pEnum;
	HRESULT			hr = NOERROR;

	// Don't create an empty enum.
	if (ridStart == ridEnd)
	{
		*ppEnum = 0;
		goto ErrExit;
	}

	pEnum = new HENUMInternal;

	// check for out of memory error
	if (pEnum == NULL)
		IfFailGo( E_OUTOFMEMORY );

	memset(pEnum, 0, sizeof(HENUMInternal));
	pEnum->m_tkKind = tkKind;
	pEnum->m_EnumType = MDSimpleEnum;
	pEnum->m_ulStart = pEnum->m_ulCur = ridStart;
	pEnum->m_ulEnd = ridEnd;
	pEnum->m_ulCount = ridEnd - ridStart;

	*ppEnum = pEnum;
ErrExit:
	return hr;
	
}	// CreateSimpleEnum


//*****************************************************************************
// Helper function to destroy Enumerator 
//*****************************************************************************
void HENUMInternal::DestroyEnum(
	HENUMInternal	*pmdEnum)
{
	if (pmdEnum == NULL)
		return;

	if (pmdEnum->m_EnumType == MDDynamicArrayEnum)
	{
		TOKENLIST		*pdalist;
		pdalist = (TOKENLIST *) &(pmdEnum->m_cursor);

		// clear the embedded dynamic array before we delete the enum
		pdalist->Clear();
	}
	delete pmdEnum;
}	// DestroyEnum


//*****************************************************************************
// Helper function to destroy Enumerator if the enumerator is empty
//*****************************************************************************
void HENUMInternal::DestroyEnumIfEmpty(
	HENUMInternal	**ppEnum)			// reset the enumerator pointer to NULL if empty
{
	if (*ppEnum == NULL)
		return;
	if ((*ppEnum)->m_ulCount == 0)
	{
		HENUMInternal::DestroyEnum(*ppEnum);
		*ppEnum = NULL;
	}
}	// DestroyEnumIfEmpty


void HENUMInternal::ClearEnum(
	HENUMInternal	*pmdEnum)
{
	if (pmdEnum == NULL)
		return;

	if (pmdEnum->m_EnumType == MDDynamicArrayEnum)
	{
		TOKENLIST		*pdalist;
		pdalist = (TOKENLIST *) &(pmdEnum->m_cursor);

		// clear the embedded dynamic array before we delete the enum
		pdalist->Clear();
	}
}	// ClearEnum


//*****************************************
// Helper function to iterate the enum
//***************************************** 
bool HENUMInternal::EnumNext(
    HENUMInternal *phEnum,              // [IN] the enumerator to retrieve information  
    mdToken     *ptk)                   // [OUT] token to scope the search
{
    _ASSERTE(phEnum && ptk);
    if (phEnum->m_ulCur >= phEnum->m_ulEnd)
        return false;

    if ( phEnum->m_EnumType == MDSimpleEnum )
    {
        *ptk = phEnum->m_ulCur | phEnum->m_tkKind;
        phEnum->m_ulCur++;
    }
    else 
    {
        TOKENLIST       *pdalist = (TOKENLIST *)&(phEnum->m_cursor);

        _ASSERTE( phEnum->m_EnumType == MDDynamicArrayEnum );
        *ptk = *( pdalist->Get(phEnum->m_ulCur++) );
    }
    return true;
}   // EnumNext

//*****************************************************************************
// Helper function to fill output token buffers given an enumerator
//*****************************************************************************
HRESULT HENUMInternal::EnumWithCount(
	HENUMInternal	*pEnum,				// enumerator
	ULONG			cMax,				// max tokens that caller wants
	mdToken			rTokens[],			// output buffer to fill the tokens
	ULONG			*pcTokens)			// number of tokens fill to the buffer upon return
{
	ULONG			cTokens;
	HRESULT			hr = NOERROR;

	// Check for empty enum.
	if (pEnum == 0)
	{
		if (pcTokens)
			*pcTokens = 0;
		return S_FALSE;
	}

	// we can only fill the minimun of what caller asked for or what we have left
	cTokens = min ( (pEnum->m_ulEnd - pEnum->m_ulCur), cMax);

	if (pEnum->m_EnumType == MDSimpleEnum)
	{

		// now fill the output
		for (ULONG i = 0; i < cTokens; i ++, pEnum->m_ulCur++)
		{	
			rTokens[i] = TokenFromRid(pEnum->m_ulCur, pEnum->m_tkKind);
		}

	}
	else 
	{
		// cannot be any other kind!
		_ASSERTE( pEnum->m_EnumType == MDDynamicArrayEnum );

		// get the embedded dynamic array
		TOKENLIST		*pdalist = (TOKENLIST *)&(pEnum->m_cursor);

		for (ULONG i = 0; i < cTokens; i ++, pEnum->m_ulCur++)
		{	
			rTokens[i] = *( pdalist->Get(pEnum->m_ulCur) );
		}
	}

	if (pcTokens)
		*pcTokens = cTokens;
	
	if (cTokens == 0)
		hr = S_FALSE;
	return hr;
}	// EnumWithCount


//*****************************************************************************
// Helper function to fill output token buffers given an enumerator
// This is a variation that takes two output arrays.  The tokens in the
// enumerator are interleaved, one for each array.  This is currently used by
// EnumMethodImpl which needs to return two arrays.
//*****************************************************************************
HRESULT HENUMInternal::EnumWithCount(
	HENUMInternal	*pEnum,				// enumerator
	ULONG			cMax,				// max tokens that caller wants
	mdToken			rTokens1[],			// first output buffer to fill the tokens
	mdToken			rTokens2[],			// second output buffer to fill the tokens
	ULONG			*pcTokens)			// number of tokens fill to each buffer upon return
{
	ULONG			cTokens;
	HRESULT			hr = NOERROR;

    // cannot be any other kind!
	_ASSERTE( pEnum->m_EnumType == MDDynamicArrayEnum );

	// Check for empty enum.
	if (pEnum == 0)
	{
		if (pcTokens)
			*pcTokens = 0;
		return S_FALSE;
	}

    // Number of tokens must always be a multiple of 2.
    _ASSERTE(! ((pEnum->m_ulEnd - pEnum->m_ulCur) % 2) );

	// we can only fill the minimun of what caller asked for or what we have left
	cTokens = min ( (pEnum->m_ulEnd - pEnum->m_ulCur), cMax * 2);

	// get the embedded dynamic array
	TOKENLIST		*pdalist = (TOKENLIST *)&(pEnum->m_cursor);

    for (ULONG i = 0; i < (cTokens / 2); i++)
	{	
        rTokens1[i] = *( pdalist->Get(pEnum->m_ulCur++) );
        rTokens2[i] = *( pdalist->Get(pEnum->m_ulCur++) );
	}

    if (pcTokens)
		*pcTokens = cTokens / 2;
	
	if (cTokens == 0)
		hr = S_FALSE;
	return hr;
}	// EnumWithCount


//*****************************************************************************
// Helper function to create HENUMInternal
//*****************************************************************************
HRESULT HENUMInternal::CreateDynamicArrayEnum(
	DWORD			tkKind,				// kind of token that we are iterating
	HENUMInternal	**ppEnum)			// return the created HENUMInternal
{
	HENUMInternal	*pEnum;
	HRESULT			hr = NOERROR;
	TOKENLIST		*pdalist;

	pEnum = new HENUMInternal;

	// check for out of memory error
	if (pEnum == NULL)
		IfFailGo( E_OUTOFMEMORY );

	memset(pEnum, 0, sizeof(HENUMInternal));
	pEnum->m_tkKind = tkKind;
	pEnum->m_EnumType = MDDynamicArrayEnum;

	// run the constructor in place
	pdalist = (TOKENLIST *) &(pEnum->m_cursor);
	::new (pdalist) TOKENLIST;

	*ppEnum = pEnum;
ErrExit:
	return hr;
	
}	// _CreateDynamicArrayEnum



//*****************************************************************************
// Helper function to init HENUMInternal
//*****************************************************************************
void HENUMInternal::InitDynamicArrayEnum(
	HENUMInternal	*pEnum)				// HENUMInternal to be initialized
{
	TOKENLIST		*pdalist;

	memset(pEnum, 0, sizeof(HENUMInternal));
	pEnum->m_EnumType = MDDynamicArrayEnum;
	pEnum->m_tkKind = -1;

	// run the constructor in place
	pdalist = (TOKENLIST *) &(pEnum->m_cursor);
	::new (pdalist) TOKENLIST;	
}	// CreateDynamicArrayEnum


//*****************************************************************************
// Helper function to init HENUMInternal
//*****************************************************************************
void HENUMInternal::InitSimpleEnum(
	DWORD			tkKind,				// kind of token that we are iterating
	ULONG			ridStart,			// starting rid
	ULONG			ridEnd,				// end rid
	HENUMInternal	*pEnum)				// HENUMInternal to be initialized
{
	pEnum->m_EnumType = MDSimpleEnum;
	pEnum->m_tkKind = tkKind;
	pEnum->m_ulStart = pEnum->m_ulCur = ridStart;
	pEnum->m_ulEnd = ridEnd;
	pEnum->m_ulCount = ridEnd - ridStart;

}	// InitSimpleEnum




//*****************************************************************************
// Helper function to init HENUMInternal
//*****************************************************************************
HRESULT HENUMInternal::AddElementToEnum(
	HENUMInternal	*pEnum,				// return the created HENUMInternal
	mdToken			tk)					// token value to be stored
{
	HRESULT			hr = NOERROR;
	TOKENLIST		*pdalist;
	mdToken			*ptk;

	pdalist = (TOKENLIST *) &(pEnum->m_cursor);

	ptk = ((mdToken *)pdalist->Append());
	if (ptk == NULL)
		IfFailGo( E_OUTOFMEMORY );
	*ptk = tk;

	// increase the count
	pEnum->m_ulCount++;
	pEnum->m_ulEnd++;
ErrExit:
	return hr;
	
}	// _AddElementToEnum





//*****************************************************************************
// find a token in the tokenmap. 
//*****************************************************************************
MDTOKENMAP::~MDTOKENMAP()
{
	if (m_pMap)
		m_pMap->Release();
#if defined(_DEBUG)
    if (m_pImport)
        m_pImport->Release();
#endif    
} // MDTOKENMAP::~MDTOKENMAP()

HRESULT MDTOKENMAP::Init(
    IUnknown    *pImport)               // The import that this map is for.
{
    HRESULT     hr;                     // A result.
    IMetaDataTables *pITables=0;        // Table information.
    ULONG       cRows;                  // Count of rows in a table.
    ULONG       cTotal;                 // Running total of rows in db.
	TOKENREC	*pRec;                  // A TOKENREC record.
    mdToken     tkTable;                // Token kind for a table.
        
    hr = pImport->QueryInterface(IID_IMetaDataTables, (void**)&pITables);
    if (hr == S_OK)
    {
        // Determine the size of each table.
        cTotal = 0;
        for (ULONG ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
        {   
            // Where does this table's data start.
            m_TableOffset[ixTbl] = cTotal;
            // See if this table has tokens.
            tkTable = CMiniMdRW::GetTokenForTable(ixTbl);
            if (tkTable == -1)
            {   
                // It doesn't have tokens, so we won't see any tokens for the table.
            }
            else
            {   // It has tokens, so we may see a token for every row.
                pITables->GetTableInfo(ixTbl, 0, &cRows, 0,0,0);
                cTotal += cRows;
            }
        }
        m_TableOffset[TBL_COUNT] = cTotal;
        m_iCountIndexed = cTotal;
        // Attempt to allocate space for all of the possible remaps.
        if (!AllocateBlock(cTotal))
            IfFailGo(E_OUTOFMEMORY);
        // Note that no sorts are needed.        
        m_sortKind = SortKind::Indexed;
        // Initialize entries to "not found".
        for (ULONG i=0; i<cTotal; ++i)
        {
            pRec = Get(i);
            pRec->SetEmpty();
        }
    }
#if defined(_DEBUG)
    pImport->QueryInterface(IID_IMetaDataImport, (void**)&m_pImport);
#endif    
    
ErrExit:
    if (pITables)
        pITables->Release();
    return hr;
} // HRESULT MDTOKENMAP::Init()

//*****************************************************************************
// find a token in the tokenmap. 
//*****************************************************************************
bool MDTOKENMAP::Find(
	mdToken		tkFind,					// [IN] the token value to find
	TOKENREC	**ppRec)				// [OUT] point to the record found in the dynamic array
{
	int			lo,mid,hi;				// binary search indices.
	TOKENREC	*pRec;

    // If possible, validate the input.
    _ASSERTE(!m_pImport || m_pImport->IsValidToken(tkFind));
    
    if (m_sortKind == SortKind::Indexed && TypeFromToken(tkFind) != mdtString)
    {
        // Get the entry.
        ULONG ixTbl = CMiniMdRW::GetTableForToken(tkFind);
        _ASSERTE(ixTbl != -1);
        ULONG iRid = RidFromToken(tkFind);
        _ASSERTE((m_TableOffset[ixTbl] + iRid) <= m_TableOffset[ixTbl+1]);
        pRec = Get(m_TableOffset[ixTbl] + iRid - 1);
        // See if it has been set.
        if (pRec->IsEmpty())
            return false;
        // Verify that it is what we think it is.
        _ASSERTE(pRec->m_tkFrom == tkFind);
        *ppRec = pRec;
        return true;
    }
    else
    {   // Shouldn't be any unsorted records, and table must be sorted in proper ordering.
    	_ASSERTE( m_iCountTotal == m_iCountSorted && 
            (m_sortKind == SortKind::SortByFromToken || m_sortKind == SortKind::Indexed) );
    	_ASSERTE( (m_iCountIndexed + m_iCountTotal) == (ULONG)Count() );
    
    	// Start with entire table.
    	lo = m_iCountIndexed;
    	hi = Count() - 1;
    
    	// While there are rows in the range...
    	while (lo <= hi)
    	{   // Look at the one in the middle.
    		mid = (lo + hi) / 2;
    
    		pRec = Get(mid);
    
    		// If equal to the target, done.
    		if (tkFind == pRec->m_tkFrom)
    		{
    			*ppRec = Get(mid);
    			return true;
    		}
    
    		// If middle item is too small, search the top half.
    		if (pRec->m_tkFrom < tkFind)
    			lo = mid + 1;
    		else // but if middle is to big, search bottom half.
    			hi = mid - 1;
    	}
    }
    
	// Didn't find anything that matched.
	return false;
} // bool MDTOKENMAP::Find()



//*****************************************************************************
// remap the token 
//*****************************************************************************
HRESULT MDTOKENMAP::Remap(
	mdToken		tkFrom,
	mdToken		*ptkTo)
{
	HRESULT		hr = NOERROR;
	TOKENREC	*pRec;

	// Remap nil to same thing (helps because System.Object has no base class.)
	if (IsNilToken(tkFrom))
	{
		*ptkTo = tkFrom;
		return hr;
	}

	if ( Find(tkFrom, &pRec) )
	{
		*ptkTo = pRec->m_tkTo;
	}
	else
	{
		_ASSERTE( !" Bad lookup map!");
		hr = META_E_BADMETADATA;
	}
	return hr;
} // HRESULT MDTOKENMAP::Remap()



//*****************************************************************************
// find a token in the tokenmap. 
//*****************************************************************************
HRESULT MDTOKENMAP::InsertNotFound(
	mdToken		tkFind,
	bool		fDuplicate,
	mdToken		tkTo,
	TOKENREC	**ppRec)
{
	HRESULT		hr = NOERROR;
	int			lo, mid, hi;				// binary search indices.
	TOKENREC	*pRec;

    // If possible, validate the input.
    _ASSERTE(!m_pImport || m_pImport->IsValidToken(tkFind));
    
    if (m_sortKind == SortKind::Indexed && TypeFromToken(tkFind) != mdtString)
    {
        // Get the entry.
        ULONG ixTbl = CMiniMdRW::GetTableForToken(tkFind);
        _ASSERTE(ixTbl != -1);
        ULONG iRid = RidFromToken(tkFind);
        _ASSERTE((m_TableOffset[ixTbl] + iRid) <= m_TableOffset[ixTbl+1]);
        pRec = Get(m_TableOffset[ixTbl] + iRid - 1);
        // See if it has been set.
        if (!pRec->IsEmpty())
        {   // Verify that it is what we think it is.
            _ASSERTE(pRec->m_tkFrom == tkFind);
        }
        // Store the data.
        pRec->m_tkFrom = tkFind;
        pRec->m_isDuplicate = fDuplicate;
        pRec->m_tkTo = tkTo;
        pRec->m_isFoundInImport = false;
        // Return the result.
        *ppRec = pRec;
    }
    else
    {   // Shouldn't be any unsorted records, and table must be sorted in proper ordering.
    	_ASSERTE( m_iCountTotal == m_iCountSorted && 
            (m_sortKind == SortKind::SortByFromToken || m_sortKind == SortKind::Indexed) );
    
    	if ((Count() - m_iCountIndexed) > 0)
    	{
    		// Start with entire table.
    		lo = m_iCountIndexed;
    		hi = Count() - 1;
    
    		// While there are rows in the range...
    		while (lo < hi)
    		{   // Look at the one in the middle.
    			mid = (lo + hi) / 2;
    
    			pRec = Get(mid);
    
    			// If equal to the target, done.
    			if (tkFind == pRec->m_tkFrom)
    			{
    				*ppRec = Get(mid);
    				goto ErrExit;
    			}
    
    			// If middle item is too small, search the top half.
    			if (pRec->m_tkFrom < tkFind)
    				lo = mid + 1;
    			else // but if middle is to big, search bottom half.
    				hi = mid - 1;
    		}
    		_ASSERTE(hi <= lo);
    		pRec = Get(lo);
    
    		if (tkFind == pRec->m_tkFrom)
    		{
    			if (tkTo == pRec->m_tkTo && fDuplicate == pRec->m_isDuplicate)
    			{
    				*ppRec = pRec;
    			}
    			else
    			{
    				_ASSERTE(!"inconsistent token has been added to the table!");
    				IfFailGo( E_FAIL );
    			}
    		}
    
    		if (tkFind < pRec->m_tkFrom)
    		{
    			// insert before lo;
    			pRec = Insert(lo);
    		}
    		else
    		{
    			// insert after lo
    			pRec = Insert(lo + 1);
    		}
    	}
    	else
    	{
    		// table is empty
    		pRec = Insert(m_iCountIndexed);
    	}
    
    
    	// If pRec == NULL, return E_OUTOFMEMORY
    	IfNullGo(pRec);
    
    	m_iCountTotal++;
    	m_iCountSorted++;
    
    	*ppRec = pRec;
    
    	// initialize the record
    	pRec->m_tkFrom = tkFind;
    	pRec->m_isDuplicate = fDuplicate;
    	pRec->m_tkTo = tkTo;
    	pRec->m_isFoundInImport = false;
    }
    
ErrExit:
	return hr;
} // HRESULT MDTOKENMAP::InsertNotFound()


//*****************************************************************************
// find a "to" token in the tokenmap. Now that we are doing the ref to def optimization,
// we might have several from tokens map to the same to token. We need to return a range of index
// instead....
//*****************************************************************************
bool MDTOKENMAP::FindWithToToken(
	mdToken		tkFind,					// [IN] the token value to find
	int         *piPosition)			// [OUT] return the first from-token that has the matching to-token
{
	int			lo, mid, hi;			// binary search indices.
	TOKENREC	*pRec;
    TOKENREC    *pRec2;

    // This makes sure that no insertions take place between calls to FindWithToToken.
    // We want to avoid repeated sorting of the table.
	_ASSERTE(m_sortKind != SortKind::SortByToToken || m_iCountTotal == m_iCountSorted);

    // If the map is sorted with From tokens, change it to be sorted with To tokens.
    if (m_sortKind != SortKind::SortByToToken)
        SortTokensByToToken();

	// Start with entire table.
	lo = 0;
	hi = Count() - 1;

	// While there are rows in the range...
	while (lo <= hi)
	{   // Look at the one in the middle.
		mid = (lo + hi) / 2;

		pRec = Get(mid);

		// If equal to the target, done.
		if (tkFind == pRec->m_tkTo)
		{
            for (int i = mid-1; i >= 0; i--)
            {
        		pRec2 = Get(i);
                if (tkFind != pRec2->m_tkTo)
                {
                    *piPosition = i + 1;
                    return true;
                }
            }
            *piPosition = 0;
			return true;
		}

		// If middle item is too small, search the top half.
		if (pRec->m_tkTo < tkFind)
			lo = mid + 1;
		else // but if middle is to big, search bottom half.
			hi = mid - 1;
	}
	// Didn't find anything that matched.
	return false;
} // bool MDTOKENMAP::FindWithToToken()



//*****************************************************************************
// output a remapped token 
//*****************************************************************************
mdToken MDTOKENMAP::SafeRemap(
	mdToken		tkFrom)					// [IN] the token value to find
{
	TOKENREC	*pRec;

    // If possible, validate the input.
    _ASSERTE(!m_pImport || m_pImport->IsValidToken(tkFrom));

    SortTokensByFromToken();

    if ( Find(tkFrom, &pRec) )
	{
		return pRec->m_tkTo;
	}
	
    return tkFrom;
} // mdToken MDTOKENMAP::SafeRemap()


//*****************************************************************************
// Sorting
//*****************************************************************************
void MDTOKENMAP::SortTokensByToToken()
{
    // Only sort if there are unsorted records or the sort kind changed.
    if (m_iCountSorted < m_iCountTotal || m_sortKind != SortKind::SortByToToken)
    {
        // Sort the entire array.
        m_iCountTotal = Count();
        m_iCountIndexed = 0;
	    SortRangeToToken(0, m_iCountTotal - 1);
	    m_iCountSorted = m_iCountTotal;
        m_sortKind = SortKind::SortByToToken;
    }
} // void MDTOKENMAP::SortTokensByToToken()

void MDTOKENMAP::SortRangeFromToken(
	int         iLeft,
	int         iRight)
{
	int         iLast;
	int         i;                      // loop variable.

	// if less than two elements you're done.
	if (iLeft >= iRight)
		return;

	// The mid-element is the pivot, move it to the left.
	Swap(iLeft, (iLeft+iRight)/2);
	iLast = iLeft;

	// move everything that is smaller than the pivot to the left.
	for(i = iLeft+1; i <= iRight; i++)
		if (CompareFromToken(i, iLeft) < 0)
			Swap(i, ++iLast);

	// Put the pivot to the point where it is in between smaller and larger elements.
	Swap(iLeft, iLast);

	// Sort the each partition.
	SortRangeFromToken(iLeft, iLast-1);
	SortRangeFromToken(iLast+1, iRight);
} // void MDTOKENMAP::SortRangeFromToken()


//*****************************************************************************
// Sorting
//*****************************************************************************
void MDTOKENMAP::SortRangeToToken(
	int         iLeft,
	int         iRight)
{
	int         iLast;
	int         i;                      // loop variable.

	// if less than two elements you're done.
	if (iLeft >= iRight)
		return;

	// The mid-element is the pivot, move it to the left.
	Swap(iLeft, (iLeft+iRight)/2);
	iLast = iLeft;

	// move everything that is smaller than the pivot to the left.
	for(i = iLeft+1; i <= iRight; i++)
		if (CompareToToken(i, iLeft) < 0)
			Swap(i, ++iLast);

	// Put the pivot to the point where it is in between smaller and larger elements.
	Swap(iLeft, iLast);

	// Sort the each partition.
	SortRangeToToken(iLeft, iLast-1);
	SortRangeToToken(iLast+1, iRight);
} // void MDTOKENMAP::SortRangeToToken()


//*****************************************************************************
// find a token in the tokenmap. 
//*****************************************************************************
HRESULT MDTOKENMAP::AppendRecord(
	mdToken		tkFind,
	bool		fDuplicate,
	mdToken		tkTo,
	TOKENREC	**ppRec)
{
	HRESULT		hr = NOERROR;
	TOKENREC	*pRec;

    // If possible, validate the input.
    _ASSERTE(!m_pImport || m_pImport->IsValidToken(tkFind));
    
    // If the map is indexed, and this is a table token, update-in-place.
    if (m_sortKind == SortKind::Indexed && TypeFromToken(tkFind) != mdtString)
    {
        // Get the entry.
        ULONG ixTbl = CMiniMdRW::GetTableForToken(tkFind);
        _ASSERTE(ixTbl != -1);
        ULONG iRid = RidFromToken(tkFind);
        _ASSERTE((m_TableOffset[ixTbl] + iRid) <= m_TableOffset[ixTbl+1]);
        pRec = Get(m_TableOffset[ixTbl] + iRid - 1);
        // See if it has been set.
        if (!pRec->IsEmpty())
        {   // Verify that it is what we think it is.
            _ASSERTE(pRec->m_tkFrom == tkFind);
        }
    }
    else
    {
    	pRec = Append();
    	IfNullGo(pRec);
    
    	// number of entries increased but not the sorted entry
    	m_iCountTotal++;
    }
    
    // Store the data.
    pRec->m_tkFrom = tkFind;
    pRec->m_isDuplicate = fDuplicate;
    pRec->m_tkTo = tkTo;
    pRec->m_isFoundInImport = false;
    *ppRec = pRec;

ErrExit:
	return hr;
} // HRESULT MDTOKENMAP::AppendRecord()




//*********************************************************************
//
// Merge Token manager's constructor
//
//*********************************************************************
MergeTokenManager::MergeTokenManager(MDTOKENMAP *pTkMapList, IUnknown *pHandler)
{
	m_cRef = 1;
	m_pTkMapList = pTkMapList;
    m_pDefaultHostRemap = NULL;
    if (pHandler)
        pHandler->QueryInterface(IID_IMapToken, (void **) &m_pDefaultHostRemap);
} // TokenManager::TokenManager()



//*********************************************************************
//
// Merge Token manager's destructor
//
//*********************************************************************
MergeTokenManager::~MergeTokenManager()
{
    if (m_pDefaultHostRemap)
        m_pDefaultHostRemap->Release();
}	// TokenManager::~TokenManager()




ULONG MergeTokenManager::AddRef()
{
	return (InterlockedIncrement((long *) &m_cRef));
}	// TokenManager::AddRef()



ULONG MergeTokenManager::Release()
{
	ULONG	cRef = InterlockedDecrement((long *) &m_cRef);
	if (!cRef)
		delete this;
	return (cRef);
}	// TokenManager::Release()


HRESULT MergeTokenManager::QueryInterface(REFIID riid, void **ppUnk)
{
	*ppUnk = 0;

	if (riid == IID_IMapToken)
		*ppUnk = (IUnknown *) (IMapToken *) this;
	else
		return (E_NOINTERFACE);
	AddRef();
	return (S_OK);
}	// TokenManager::QueryInterface



//*********************************************************************
//
// Token manager keep tracks a list of tokenmaps. Each tokenmap corresponding
// to an imported scope. Note that with this, we do have problem in how to
// tell linker regarding the token movement when the token is added by Define
// rather than merge. This should be fixed with new merge implementation.
// The tkImp is the old tokens in the emit scope, tkEmit is the new token in the
// emit scope. We need to find the token from an import scope that is resolved
// to the tkImp. We then need to tell linker about this token movement.
// If we don't find any import scope which generates the tkImp token, that is 
// this tkImp is generated by calling DefinXXX directly on the final merged scope.
// Then we use the default host remap to send the notification.
//
//*********************************************************************
HRESULT	MergeTokenManager::Map(mdToken	tkImp, mdToken tkEmit)
{
	HRESULT		hr = NOERROR;
	MDTOKENMAP	*pTkMapList = m_pTkMapList;
    bool        fFoundInImport = false;
    int         iPosition;
    TOKENREC    *pRec;

	_ASSERTE(m_pTkMapList);
	while ( pTkMapList )
	{
        // FindWithToToken will return the first match with the To token.
        // pTkMapList is sorted with To token. It might contain several From tokens
        // that map to the To token due to ref to def optimiation. Make sure that
        // all notification is sent to all of these From tokens.
        //
		if ( pTkMapList->FindWithToToken(tkImp, &iPosition) )
		{
            // make sure that we don't walk over the last entry
            while (iPosition < pTkMapList->Count())
            {
                pRec = pTkMapList->Get(iPosition);
                if (pRec->m_tkTo != tkImp)
                {
                    // we are done!
                    break;
                }

                // more matching record...
                fFoundInImport = true;
			    if (pTkMapList->m_pMap)			
				    hr = pTkMapList->m_pMap->Map(pRec->m_tkFrom, tkEmit);
			    _ASSERTE(SUCCEEDED(hr));
			    IfFailGo( hr );
                iPosition++;
            }
		}
		pTkMapList = pTkMapList->m_pNextMap;
	}

	if (fFoundInImport == false && m_pDefaultHostRemap)
    {
        // use the default remap to send the notification
        IfFailGo( m_pDefaultHostRemap->Map(tkImp, tkEmit) );
    }
ErrExit:
	return hr;
}



//*********************************************************************
//
// CMapToken's constructor
//
//*********************************************************************
CMapToken::CMapToken()
{
	m_cRef = 1;
	m_pTKMap = NULL;
	m_isSorted = true;
} // TokenManager::TokenManager()



//*********************************************************************
//
// CMapToken's destructor
//
//*********************************************************************
CMapToken::~CMapToken()
{
	delete m_pTKMap;
}	// CMapToken::~CMapToken()


ULONG CMapToken::AddRef()
{
	return (InterlockedIncrement((long *) &m_cRef));
}	// CMapToken::AddRef()



ULONG CMapToken::Release()
{
	ULONG	cRef = InterlockedDecrement((long *) &m_cRef);
	if (!cRef)
		delete this;
	return (cRef);
}	// CMapToken::Release()


HRESULT CMapToken::QueryInterface(REFIID riid, void **ppUnk)
{
	*ppUnk = 0;

	if (riid == IID_IMapToken)
		*ppUnk = (IUnknown *) (IMapToken *) this;
	else
		return (E_NOINTERFACE);
	AddRef();
	return (S_OK);
}	// CMapToken::QueryInterface



//*********************************************************************
//
// Track the token mapping
//
//*********************************************************************
HRESULT	CMapToken::Map(
	mdToken		tkFrom, 
	mdToken		tkTo)
{
	HRESULT		hr = NOERROR;
	TOKENREC	*pTkRec;

	if (m_pTKMap == NULL)
		m_pTKMap = new MDTOKENMAP;

	IfNullGo( m_pTKMap );

	IfFailGo( m_pTKMap->AppendRecord(tkFrom, false, tkTo, &pTkRec) );
	_ASSERTE( pTkRec );

	m_isSorted = false;
ErrExit:
	return hr;
}


//*********************************************************************
//
// return what tkFrom is mapped to ptkTo. If there is no remap
// (ie the token from is filtered out by the filter mechanism, it will return false.
//
//*********************************************************************
bool	CMapToken::Find(
	mdToken		tkFrom, 
	TOKENREC    **pRecTo)
{
	TOKENREC	*pRec;
	bool		bRet;
	if ( m_isSorted == false )
	{
		// sort the map
		m_pTKMap->SortTokensByFromToken();
		m_isSorted = true;
	}

	bRet =  m_pTKMap->Find(tkFrom, &pRec) ;
	if (bRet)
	{
		_ASSERTE(pRecTo);
		*pRecTo = pRec;
	}
    else
    {
        pRec = NULL;
    }
	return bRet;
}


//*********************************************************************
//
// This function returns true if tkFrom is resolved to a def token. Otherwise, it returns
// false.
//
//*********************************************************************
bool TokenRemapManager::ResolveRefToDef(
	mdToken	tkRef,						// [IN] ref token
	mdToken	*ptkDef)					// [OUT] def token that it resolves to. If it does not resolve to a def
										// token, it will return the tkRef token here.
{
	HRESULT		hr = NOERROR;
	mdToken		tkTo;

	_ASSERTE(ptkDef);

	if (TypeFromToken(tkRef) == mdtTypeRef)
	{
		tkTo = m_TypeRefToTypeDefMap[RidFromToken(tkRef)];
	}
	else
	{
		_ASSERTE( TypeFromToken(tkRef) == mdtMemberRef );
		tkTo = m_MemberRefToMemberDefMap[RidFromToken(tkRef)];
	}
	if (RidFromToken(tkTo) == mdTokenNil)
	{
		*ptkDef = tkRef;
		return false;
	}
	*ptkDef = tkTo;
	return true;
}	// ResolveRefToDef



//*********************************************************************
//
// Destructor
//
//*********************************************************************
TokenRemapManager::~TokenRemapManager()
{
	m_TypeRefToTypeDefMap.Clear();
	m_MemberRefToMemberDefMap.Clear();
}	// ~TokenRemapManager


//*********************************************************************
//
// Initialize the size of Ref to Def optimization table. We will grow the tables in this function.
// We also initialize the table entries to zero.
//
//*********************************************************************
HRESULT TokenRemapManager::ClearAndEnsureCapacity(
	ULONG		cTypeRef, 
	ULONG		cMemberRef)
{
	HRESULT		hr = NOERROR;
    if ( ((ULONG) (m_TypeRefToTypeDefMap.Count())) < (cTypeRef + 1) )
    {
	    if ( m_TypeRefToTypeDefMap.AllocateBlock(cTypeRef + 1 - m_TypeRefToTypeDefMap.Count() ) == 0 )
		    IfFailGo( E_OUTOFMEMORY );
    }
    memset( m_TypeRefToTypeDefMap.Get(0), 0, (cTypeRef + 1) * sizeof(mdToken) );
    
    if ( ((ULONG) (m_MemberRefToMemberDefMap.Count())) < (cMemberRef + 1) )
    {
	    if ( m_MemberRefToMemberDefMap.AllocateBlock(cMemberRef + 1 - m_MemberRefToMemberDefMap.Count() ) == 0 )
		    IfFailGo( E_OUTOFMEMORY );
    }
    memset( m_MemberRefToMemberDefMap.Get(0), 0, (cMemberRef + 1) * sizeof(mdToken) );
    
ErrExit:
	return hr;
} // HRESULT TokenRemapManager::ClearAndEnsureCapacity()



//*********************************************************************
//
// Constructor
//
//*********************************************************************
CMDSemReadWrite::CMDSemReadWrite(
    bool        fLockedForRead,         // Initiated with ReadLock or WriteLock
    UTSemReadWrite *pSem)
{
    m_fLockedForRead = false;
    m_fLockedForWrite = false;
    if (pSem == NULL) {
        // no need to do anything
        m_pSem = NULL;
        return;
    }
    m_pSem = pSem;
    if (fLockedForRead)
    {
        LOG((LF_METADATA, LL_EVERYTHING, "LockRead called from CSemReadWrite::CSemReadWrite \n"));
        m_pSem->LockRead();
        m_fLockedForRead = true;
    }
    else
    {
        LOG((LF_METADATA, LL_EVERYTHING, "LockWrite called from CSemReadWrite::CSemReadWrite \n"));
        m_pSem->LockWrite();
        m_fLockedForWrite = true;
    }
}   // CMDSemReadWrite::CMDSemReadWrite(



//*********************************************************************
//
// Destructor
//
//*********************************************************************
CMDSemReadWrite::~CMDSemReadWrite()
{
    if (m_pSem == NULL) 
        return;
    _ASSERTE( !m_fLockedForRead || !m_fLockedForWrite);
    if (m_fLockedForRead)
    {
        LOG((LF_METADATA, LL_EVERYTHING, "UnlockRead called from CSemReadWrite::~CSemReadWrite \n"));
        m_pSem->UnlockRead();
    }
    if (m_fLockedForWrite)
    {
        LOG((LF_METADATA, LL_EVERYTHING, "UnlockWrite called from CSemReadWrite::~CSemReadWrite \n"));
        m_pSem->UnlockWrite();
    }
}   // CMDSemReadWrite::~CMDSemReadWrite


//*********************************************************************
//
// Convert a read lock to a write lock
//
//*********************************************************************
void CMDSemReadWrite::ConvertReadLockToWriteLock()
{
    _ASSERTE(!m_fLockedForWrite);

    if (m_pSem == NULL)
        return;
    if (m_fLockedForRead)
    {
        LOG((LF_METADATA, LL_EVERYTHING, "UnlockRead called from CSemReadWrite::ConvertReadLockToWriteLock \n"));
        m_pSem->UnlockRead();
        m_fLockedForRead = false;
    }
    LOG((LF_METADATA, LL_EVERYTHING, "LockWrite called from  CSemReadWrite::ConvertReadLockToWriteLock\n"));
    m_pSem->LockWrite();
    m_fLockedForWrite = true;
}   //CMDSemReadWrite::ConvertReadLockToWriteLock()


//*********************************************************************
//
// Unlocking for write
//
//*********************************************************************
void CMDSemReadWrite::UnlockWrite()
{
    _ASSERTE(!m_fLockedForRead);

    if (m_pSem == NULL)
        return;
    if (m_fLockedForWrite)
    {
        LOG((LF_METADATA, LL_EVERYTHING, "UnlockWrite called from CSemReadWrite::UnlockWrite \n"));
        m_pSem->UnlockWrite();
    }
    m_fLockedForWrite = false;
}   //CMDSemReadWrite::UnlockWrite()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\stgtiggerstream.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgTiggerStream.h
//
// TiggerStream is the companion to the TiggerStorage CoClass.  It handles the
// streams managed inside of the storage and does the direct file i/o.
//
//*****************************************************************************
#include "stdafx.h"
#include "StgTiggerStream.h"
#include "StgTiggerStorage.h"
#include "PostError.h"

//
//
// IStream
//
//


HRESULT STDMETHODCALLTYPE TiggerStream::Read( 
    void		*pv,
    ULONG		cb,
    ULONG		*pcbRead)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::Write( 
    const void	*pv,
    ULONG		cb,
    ULONG		*pcbWritten)
{
	return (m_pStorage->Write(m_rcStream, pv, cb, pcbWritten));
}


HRESULT STDMETHODCALLTYPE TiggerStream::Seek( 
    LARGE_INTEGER dlibMove,
    DWORD		dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::SetSize( 
    ULARGE_INTEGER libNewSize)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::CopyTo( 
    IStream		*pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::Commit( 
    DWORD		grfCommitFlags)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::Revert()
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::LockRegion( 
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD		dwLockType)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::UnlockRegion( 
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD		dwLockType)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::Stat( 
    STATSTG		*pstatstg,
    DWORD		grfStatFlag)
{
	return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStream::Clone( 
    IStream		**ppstm)
{
	return (E_NOTIMPL);
}






HRESULT TiggerStream::Init(				// Return code.
	TiggerStorage *pStorage,			// Parent storage.
	LPCSTR		szStream)				// Stream name.
{
	// Save off the parent data source object and stream name.
	m_pStorage = pStorage;
	strcpy(m_rcStream, szStream);
	return (S_OK);
}


ULONG TiggerStream::GetStreamSize()
{
	STORAGESTREAM *pStreamInfo;
	pStreamInfo = m_pStorage->FindStream(m_rcStream);
    if (!pStreamInfo) 
        return 0;
	return (pStreamInfo->iSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\stgtiggerstorage.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgTiggerStorage.cpp
//
// TiggerStorage is a stripped down version of compound doc files.  Doc files
// have some very useful and complex features to them, unfortunately nothing
// comes for free.  Given the incredibly tuned format of existing .tlb files,
// every single byte counts and 10% added by doc files is just too exspensive.
//
//*****************************************************************************
#include "stdafx.h"                     // Standard header.
#include "StgIO.h"                      // I/O subsystem.
#include "StgTiggerStorage.h"           // Our interface.
#include "StgTiggerStream.h"            // Stream interface.
#include "CorError.h"
#include "PostError.h"
#include "MDFileFormat.h"
#include "mscoree.h"


BYTE  TiggerStorage::m_Version[_MAX_PATH];
DWORD TiggerStorage::m_dwVersion = 0;
LPSTR TiggerStorage::m_szVersion = 0;
DWORD TiggerStorage::m_flock = 0;

TiggerStorage::TiggerStorage() :
    m_pStgIO(0),
    m_cRef(1),
    m_pStreamList(0),
    m_pbExtra(0)
{
    memset(&m_StgHdr, 0, sizeof(STORAGEHEADER));
}


TiggerStorage::~TiggerStorage()
{
    if (m_pStgIO)
    {
        m_pStgIO->Release();
        m_pStgIO = 0;
    }
}


//*****************************************************************************
// Init this storage object on top of the given storage unit.
//*****************************************************************************
HRESULT TiggerStorage::Init(        // Return code.
    StgIO       *pStgIO,            // The I/O subsystem.
    LPSTR       pVersion)           // 'Compiled for' CLR version
{
    STORAGESIGNATURE *pSig;         // Signature data for file.
    ULONG       cbData;             // Size of data.
    void        *ptr;               // Signature.
    HRESULT     hr = S_OK;

    // Make sure we always start at the beginning.
    // Weird!! We cannot check the error here. It appears that in linker's case, this is going to fail during the seek.
    pStgIO->Seek(0, FILE_BEGIN);

    // Save the storage unit.
    m_pStgIO = pStgIO;
    m_pStgIO->AddRef();

    // For cases where the data already exists, verify the signature.
    if ((pStgIO->GetFlags() & DBPROP_TMODEF_CREATE) == 0)
    {
        // Map the contents into memory for easy access.
        IfFailGo( pStgIO->MapFileToMem(ptr, &cbData) );

        // Get a pointer to the signature of the file, which is the first part.
        IfFailGo( pStgIO->GetPtrForMem(0, sizeof(STORAGESIGNATURE), ptr) );

        // Finally, we can check the signature.
        pSig = (STORAGESIGNATURE *) ptr;
        IfFailGo( MDFormat::VerifySignature(pSig, cbData) );

        // Read and verify the header.
        IfFailGo( ReadHeader() );
    }
    // For write case, dump the signature into the file up front.
    else
    {
        IfFailGo( WriteSignature() );
    }

    m_szVersion = pVersion;

ErrExit:
    if (FAILED(hr) && m_pStgIO)
    {
        m_pStgIO->Release();
        m_pStgIO = 0;
    }
    return (hr);
}


//*****************************************************************************
//  Get the size of the storage signature including the version of the runtime
//  used to emit the meta-data
//*****************************************************************************
DWORD TiggerStorage::SizeOfStorageSignature()
{
    if(m_dwVersion == 0) {
        EnterStorageLock();
        if(m_dwVersion == 0) {
			memset(m_Version,0,sizeof(m_Version));
            if (m_szVersion) {
                m_dwVersion = strlen(m_szVersion)+1; // m_dwVersion includes the 0 terminator
                memcpy(m_Version, m_szVersion, m_dwVersion);
            }
            else {
                WCHAR version[_MAX_PATH];
                DWORD dwVersion = 0;
                GetCORRequiredVersion(version, _MAX_PATH, &dwVersion);
                if(dwVersion > 0) {
                    m_dwVersion = WszWideCharToMultiByte(CP_UTF8, 0, version, -1, (LPSTR) m_Version, _MAX_PATH, NULL, NULL);
					if(m_dwVersion == 0)
					{
						_ASSERTE(!"WideCharToMultiByte conversion failed");
						*((DWORD*)m_Version)=0; // DWORD to make it 4 bytes
					}
                }
            }

            // Make sure max_path is 4 byte aligned so we never exceed it
            _ASSERTE((_MAX_PATH & 0x3) == 0);
            m_dwVersion = (m_dwVersion + 0x3) & ~0x3;         // Make the string length four byte aligned
        }
        LeaveStorageLock();
    }

    _ASSERTE(m_dwVersion);
    return sizeof(STORAGESIGNATURE) + m_dwVersion;
}


//*****************************************************************************
// Retrieves a the size and a pointer to the extra data that can optionally be
// written in the header of the storage system.  This data is not required to
// be in the file, in which case *pcbExtra will come back as 0 and pbData will
// be set to null.  You must have initialized the storage using Init() before
// calling this function.
//*****************************************************************************
HRESULT TiggerStorage::GetExtraData(    // S_OK if found, S_FALSE, or error.
    ULONG       *pcbExtra,              // Return size of extra data.
    BYTE        *&pbData)               // Return a pointer to extra data.
{
    // Assuming there is extra data, then return the size and a pointer to it.
    if (m_pbExtra)
    {
        if (!(m_StgHdr.fFlags & STGHDR_EXTRADATA))
	        return (PostError(CLDB_E_FILE_CORRUPT));
        *pcbExtra = *(ULONG *) m_pbExtra;
        pbData = (BYTE *) ((ULONG *) m_pbExtra + 1);
    }
    else
    {
        *pcbExtra = 0;
        pbData = 0;
        return (S_FALSE);
    }
    return (S_OK);
}


//*****************************************************************************
// Called when this stream is going away.
//*****************************************************************************
HRESULT TiggerStorage::WriteHeader(
    STORAGESTREAMLST *pList,            // List of streams.     
    ULONG       cbExtraData,            // Size of extra data, may be 0.
    BYTE        *pbExtraData)           // Pointer to extra data for header.
{
    ULONG       iLen;                   // For variable sized data.
    ULONG       cbWritten;              // Track write quantity.
    HRESULT     hr;
    SAVETRACE(ULONG cbDebugSize);       // Track debug size of header.

    SAVETRACE(DbgWriteEx(L"PSS:  Header:\n"));

    // Save the count and set flags.
    m_StgHdr.iStreams = pList->Count();
    if (cbExtraData)
        m_StgHdr.fFlags |= STGHDR_EXTRADATA;

    // Write out the header of the file.
    IfFailRet( m_pStgIO->Write(&m_StgHdr, sizeof(STORAGEHEADER), &cbWritten) );

    // Write out extra data if there is any.
    if (cbExtraData)
    {
        _ASSERTE(pbExtraData);
        _ASSERTE(cbExtraData % 4 == 0);

        // First write the length value.
        IfFailRet( m_pStgIO->Write(&cbExtraData, sizeof(ULONG), &cbWritten) );

        // And then the data.
        IfFailRet( m_pStgIO->Write(pbExtraData, cbExtraData, &cbWritten) );
        SAVETRACE(DbgWriteEx(L"PSS:    extra data size %d\n", m_pStgIO->GetCurrentOffset() - cbDebugSize);cbDebugSize=m_pStgIO->GetCurrentOffset());
    }
    
    // Save off each data stream.
    for (int i=0;  i<pList->Count();  i++)
    {
        STORAGESTREAM *pStream = pList->Get(i);

        // How big is the structure (aligned) for this struct.
        iLen = (ULONG)(sizeof(STORAGESTREAM) - MAXSTREAMNAME + strlen(pStream->rcName) + 1);

        // Write the header including the name to disk.  Does not include
        // full name buffer in struct, just string and null terminator.
        IfFailRet( m_pStgIO->Write(pStream, iLen, &cbWritten) );

        // Align the data out to 4 bytes.
        if (iLen != ALIGN4BYTE(iLen))
        {
            IfFailRet( m_pStgIO->Write(&hr, ALIGN4BYTE(iLen) - iLen, 0) );
        }
        SAVETRACE(DbgWriteEx(L"PSS:    Table %hs header size %d\n", pStream->rcName, m_pStgIO->GetCurrentOffset() - cbDebugSize);cbDebugSize=m_pStgIO->GetCurrentOffset());
    }
    SAVETRACE(DbgWriteEx(L"PSS:  Total size of header data %d\n", m_pStgIO->GetCurrentOffset()));
    // Make sure the whole thing is 4 byte aligned.
    _ASSERTE(m_pStgIO->GetCurrentOffset() % 4 == 0);
    return (S_OK);
}


//*****************************************************************************
// Called when all data has been written.  Forces cached data to be flushed
// and stream lists to be validated.
//*****************************************************************************
HRESULT TiggerStorage::WriteFinished(   // Return code.
    STORAGESTREAMLST *pList,            // List of streams.     
    ULONG       *pcbSaveSize)           // Return size of total data.
{
    STORAGESTREAM *pEntry;              // Loop control.
    HRESULT     hr;

    // If caller wants the total size of the file, we are there right now.
    if (pcbSaveSize)
        *pcbSaveSize = m_pStgIO->GetCurrentOffset();

    // Flush our internal write cache to disk.
    IfFailRet( m_pStgIO->FlushCache() );

    // Force user's data onto disk right now so that Commit() can be
    // more accurate (although not totally up to the D in ACID).
    hr = m_pStgIO->FlushFileBuffers();
    _ASSERTE(SUCCEEDED(hr));


    // Run through all of the streams and validate them against the expected
    // list we wrote out originally.

    // Robustness check: stream counts must match what was written.
    _ASSERTE(pList->Count() == m_Streams.Count());
    if (pList->Count() != m_Streams.Count())
    {
        _ASSERTE(0 && "Mismatch in streams, save would cause corruption.");
        return (PostError(CLDB_E_FILE_CORRUPT));
        
    }

    // Sanity check each saved stream data size and offset.
    for (int i=0;  i<pList->Count();  i++)
    {
        pEntry = pList->Get(i);
        _ASSERTE(pEntry->iOffset == m_Streams[i].iOffset);
        _ASSERTE(pEntry->iSize == m_Streams[i].iSize);
        _ASSERTE(strcmp(pEntry->rcName, m_Streams[i].rcName) == 0);

        // For robustness, check that everything matches expected value,
        // and if it does not, refuse to save the data and force a rollback.
        // The alternative is corruption of the data file.
        if (pEntry->iOffset != m_Streams[i].iOffset ||
            pEntry->iSize != m_Streams[i].iSize ||
            strcmp(pEntry->rcName, m_Streams[i].rcName) != 0)
        {
            _ASSERTE(0 && "Mismatch in streams, save would cause corruption.");
            hr = PostError(CLDB_E_FILE_CORRUPT);
            break;
        }

        //@future: 
        // if iOffset or iSize mismatches, it means a bug in GetSaveSize
        // which we can successfully detect right here.  In that case, we
        // could use the pStgIO and seek back to the header and correct the
        // mistmake.  This will break any client who lives on the GetSaveSize
        // value which came back originally, but would be more robust than
        // simply throwing back an error which will corrupt the file.
    }
    return (hr);
}


//*****************************************************************************
// Tells the storage that we intend to rewrite the contents of this file.  The
// entire file will be truncated and the next write will take place at the
// beginning of the file.
//*****************************************************************************
HRESULT TiggerStorage::Rewrite(         // Return code.
    LPWSTR      szBackup)               // If non-0, backup the file.
{
    HRESULT     hr;

    // Delegate to storage.
    IfFailRet( m_pStgIO->Rewrite(szBackup) );

    // None of the old streams make any sense any more.  Delete them.
    m_Streams.Clear();

    // Write the signature out.
    if (FAILED(hr = WriteSignature()))
    {
        VERIFY(Restore(szBackup, false) == S_OK);
        return (hr);
    }

    return (S_OK);
}


//*****************************************************************************
// Called after a successful rewrite of an existing file.  The in memory
// backing store is no longer valid because all new data is in memory and
// on disk.  This is essentially the same state as created, so free up some
// working set and remember this state.
//*****************************************************************************
HRESULT TiggerStorage::ResetBackingStore()  // Return code.
{
    return (m_pStgIO->ResetBackingStore());
}


//*****************************************************************************
// Called to restore the original file.  If this operation is successful, then
// the backup file is deleted as requested.  The restore of the file is done
// in write through mode to the disk help ensure the contents are not lost.
// This is not good enough to fulfill ACID props, but it ain't that bad.
//*****************************************************************************
HRESULT TiggerStorage::Restore(         // Return code.
    LPWSTR      szBackup,               // If non-0, backup the file.
    int         bDeleteOnSuccess)       // Delete backup file if successful.
{
    HRESULT     hr;

    // Ask file system to copy bytes from backup into master.
    IfFailRet( m_pStgIO->Restore(szBackup, bDeleteOnSuccess) );

    // Reset state.  The Init routine will re-read data as required.
    m_pStreamList = 0;
    m_StgHdr.iStreams = 0;

    // Re-init all data structures as though we just opened.
    return (Init(m_pStgIO, m_szVersion));
}


//*****************************************************************************
// Given the name of a stream that will be persisted into a stream in this
// storage type, figure out how big that stream would be including the user's
// stream data and the header overhead the file format incurs.  The name is
// stored in ANSI and the header struct is aligned to 4 bytes.
//*****************************************************************************
HRESULT TiggerStorage::GetStreamSaveSize( // Return code.
    LPCWSTR     szStreamName,           // Name of stream.
    ULONG       cbDataSize,             // Size of data to go into stream.
    ULONG       *pcbSaveSize)           // Return data size plus stream overhead.
{
    ULONG       cbTotalSize;            // Add up each element.
    
    // Find out how large the name will be.
    cbTotalSize = ::WszWideCharToMultiByte(CP_ACP, 0, szStreamName, -1, 0, 0, 0, 0);
    _ASSERTE(cbTotalSize);

    // Add the size of the stream header minus the static name array.
    cbTotalSize += sizeof(STORAGESTREAM) - MAXSTREAMNAME;

    // Finally align the header value.
    cbTotalSize = ALIGN4BYTE(cbTotalSize);

    // Return the size of the user data and the header data.
    *pcbSaveSize = cbTotalSize + cbDataSize;
    return (S_OK);
}


//*****************************************************************************
// Return the fixed size overhead for the storage implementation.  This includes
// the signature and fixed header overhead.  The overhead in the header for each
// stream is calculated as part of GetStreamSaveSize because these structs are
// variable sized on the name.
//*****************************************************************************
HRESULT TiggerStorage::GetStorageSaveSize( // Return code.
    ULONG       *pcbSaveSize,           // [in] current size, [out] plus overhead.
    ULONG       cbExtra)                // How much extra data to store in header.
{
    *pcbSaveSize += SizeOfStorageSignature() + sizeof(STORAGEHEADER);
    if (cbExtra)
        *pcbSaveSize += sizeof(ULONG) + cbExtra;
    return (S_OK);
}


//*****************************************************************************
// Adjust the offset in each known stream to match where it will wind up after
// a save operation.
//*****************************************************************************
HRESULT TiggerStorage::CalcOffsets(     // Return code.
    STORAGESTREAMLST *pStreamList,      // List of streams for header.
    ULONG       cbExtra)                // Size of variable extra data in header.
{
    STORAGESTREAM *pEntry;              // Each entry in the list.
    ULONG       cbOffset=0;             // Running offset for streams.
    int         i;                      // Loop control.

    // Prime offset up front.
    GetStorageSaveSize(&cbOffset, cbExtra);

    // Add on the size of each header entry.
    for (i=0;  i<pStreamList->Count();  i++)
    {
        VERIFY(pEntry = pStreamList->Get(i));
        cbOffset += sizeof(STORAGESTREAM) - MAXSTREAMNAME;
        cbOffset += (ULONG)(strlen(pEntry->rcName) + 1);
        cbOffset = ALIGN4BYTE(cbOffset);
    }

    // Go through each stream and reset its expected offset.
    for (i=0;  i<pStreamList->Count();  i++)
    {
        VERIFY(pEntry = pStreamList->Get(i));
        pEntry->iOffset = cbOffset;
        cbOffset += pEntry->iSize;
    }
    return (S_OK);
}   



HRESULT STDMETHODCALLTYPE TiggerStorage::CreateStream( 
    const OLECHAR *pwcsName,
    DWORD       grfMode,
    DWORD       reserved1,
    DWORD       reserved2,
    IStream     **ppstm)
{
    char        rcStream[MAXSTREAMNAME];// For converted name.
    VERIFY(Wsz_wcstombs(rcStream, pwcsName, sizeof(rcStream)));
    return (CreateStream(rcStream, grfMode, reserved1, reserved2, ppstm));
}


HRESULT STDMETHODCALLTYPE TiggerStorage::CreateStream( 
    LPCSTR      szName,
    DWORD       grfMode,
    DWORD       reserved1,
    DWORD       reserved2,
    IStream     **ppstm)
{
    STORAGESTREAM *pStream;             // For lookup.
    HRESULT     hr;

    _ASSERTE(szName && *szName);

    // Check for existing stream, which might be an error or more likely
    // a rewrite of a file.
    if ((pStream = FindStream(szName)) != 0)
    {
        if (pStream->iOffset != 0xffffffff && (grfMode & STGM_FAILIFTHERE))
            return (PostError(STG_E_FILEALREADYEXISTS));
    }
    // Add a control to track this stream.
    else if (!pStream && (pStream = m_Streams.Append()) == 0)
        return (PostError(OutOfMemory()));
    pStream->iOffset = 0xffffffff;
    pStream->iSize = 0;
    strcpy(pStream->rcName, szName);

    // Now create a stream object to allow reading and writing.
    TiggerStream *pNew = new TiggerStream;
    if (!pNew)
        return (PostError(OutOfMemory()));
    *ppstm = (IStream *) pNew;

    // Init the new object.
    if (FAILED(hr = pNew->Init(this, pStream->rcName)))
    {
        delete pNew;
        return (hr);
    }
    return (S_OK);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::OpenStream( 
    const OLECHAR *pwcsName,
    void        *reserved1,
    DWORD       grfMode,
    DWORD       reserved2,
    IStream     **ppstm)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::CreateStorage( 
    const OLECHAR *pwcsName,
    DWORD       grfMode,
    DWORD       dwStgFmt,
    DWORD       reserved2,
    IStorage    **ppstg)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::OpenStorage( 
    const OLECHAR *pwcsName,
    IStorage    *pstgPriority,
    DWORD       grfMode,
    SNB         snbExclude,
    DWORD       reserved,
    IStorage    **ppstg)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::CopyTo( 
    DWORD       ciidExclude,
    const IID   *rgiidExclude,
    SNB         snbExclude,
    IStorage    *pstgDest)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::MoveElementTo( 
    const OLECHAR *pwcsName,
    IStorage    *pstgDest,
    const OLECHAR *pwcsNewName,
    DWORD       grfFlags)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::Commit( 
    DWORD       grfCommitFlags)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::Revert()
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::EnumElements( 
    DWORD       reserved1,
    void        *reserved2,
    DWORD       reserved3,
    IEnumSTATSTG **ppenum)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::DestroyElement( 
    const OLECHAR *pwcsName)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::RenameElement( 
    const OLECHAR *pwcsOldName,
    const OLECHAR *pwcsNewName)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::SetElementTimes( 
    const OLECHAR *pwcsName,
    const FILETIME *pctime,
    const FILETIME *patime,
    const FILETIME *pmtime)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::SetClass( 
    REFCLSID    clsid)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::SetStateBits( 
    DWORD       grfStateBits,
    DWORD       grfMask)
{
    return (E_NOTIMPL);
}


HRESULT STDMETHODCALLTYPE TiggerStorage::Stat( 
    STATSTG     *pstatstg,
    DWORD       grfStatFlag)
{
    return (E_NOTIMPL);
}



HRESULT STDMETHODCALLTYPE TiggerStorage::OpenStream( 
    LPCWSTR     szStream,
    ULONG       *pcbData,
    void        **ppAddress)
{
    STORAGESTREAM *pStream;             // For lookup.
    char        rcName[MAXSTREAMNAME];  // For conversion.
    HRESULT     hr;

    // Convert the name for internal use.
    VERIFY(::WszWideCharToMultiByte(CP_ACP, 0, szStream, -1, rcName, sizeof(rcName), 0, 0));

    // Look for the stream which must be found for this to work.  Note that
    // this error is explcitly not posted as an error object since unfound streams
    // are a common occurence and do not warrant a resource file load.
    if ((pStream = FindStream(rcName)) == 0)
        IfFailRet(STG_E_FILENOTFOUND);

    // Get the memory for the stream.
    IfFailRet( m_pStgIO->GetPtrForMem(pStream->iOffset, pStream->iSize, *ppAddress) );
    *pcbData = pStream->iSize;
    return (S_OK);
}



//
// Protected.
//


//*****************************************************************************
// Called by the stream implementation to write data out to disk.
//*****************************************************************************
HRESULT TiggerStorage::Write(       // Return code.
    LPCSTR      szName,             // Name of stream we're writing.
    const void *pData,              // Data to write.
    ULONG       cbData,             // Size of data.
    ULONG       *pcbWritten)        // How much did we write.
{
    STORAGESTREAM *pStream;         // Update size data.
    ULONG       iOffset;            // Offset for write.
    ULONG       cbWritten;          // Handle null case.
    HRESULT     hr;

    // Get the stream descriptor.
    pStream = FindStream(szName);
    if (!pStream)
        return CLDB_E_FILE_BADWRITE;

    // If we need to know the offset, keep it now.
    if (pStream->iOffset == 0xffffffff)
    {
        iOffset = m_pStgIO->GetCurrentOffset();

        // Align the storage on a 4 byte boundary.
        if (iOffset % 4 != 0)
        {
            ULONG       cb;
            ULONG       pad = 0;
            HRESULT     hr;

            if (FAILED(hr = m_pStgIO->Write(&pad, ALIGN4BYTE(iOffset) - iOffset, &cb)))
                return (hr);
            iOffset = m_pStgIO->GetCurrentOffset();
            
            _ASSERTE(iOffset % 4 == 0);
        }
    }

    // Avoid confusion.
    if (pcbWritten == 0)
        pcbWritten = &cbWritten;
    *pcbWritten = 0;

    // Let OS do the write.
    if (SUCCEEDED(hr = m_pStgIO->Write(pData, cbData, pcbWritten)))
    {
        // On success, record the new data.
        if (pStream->iOffset == 0xffffffff)
            pStream->iOffset = iOffset;
        pStream->iSize += *pcbWritten;  
        return (S_OK);
    }
    else
        return (hr);
}


//
// Private
//

STORAGESTREAM *TiggerStorage::FindStream(LPCSTR szName)
{
    int         i;

    // In read mode, just walk the list and return one.
    if (m_pStreamList)
    {
        STORAGESTREAM *p;
        for (i=0, p=m_pStreamList;  i<m_StgHdr.iStreams;  i++)
        {
            if (!_stricmp(p->rcName, szName))
                return (p);
            p = p->NextStream();
        }
    }
    // In write mode, walk the array which is not on disk yet.
    else
    {
        for (int i=0;  i<m_Streams.Count();  i++)
        {
            if (!_stricmp(m_Streams[i].rcName, szName))
                return (&m_Streams[i]);
        }
    }
    return (0);
}


//*****************************************************************************
// Write the signature area of the file format to disk.  This includes the
// "magic" identifier and the version information.
//*****************************************************************************
HRESULT TiggerStorage::WriteSignature()
{
    STORAGESIGNATURE sSig;
    ULONG       cbWritten;
    HRESULT     hr;

    // Signature belongs at the start of the file.
    _ASSERTE(m_pStgIO->GetCurrentOffset() == 0);

    // SizeOfStorageSignature must be called before m_dwVersion is used.
    ULONG storageSize = SizeOfStorageSignature();

    sSig.lSignature = STORAGE_MAGIC_SIG;
    sSig.iMajorVer = FILE_VER_MAJOR;
    sSig.iMinorVer = FILE_VER_MINOR;
    sSig.iExtraData = 0; // We have no extra inforation

    sSig.iVersionString = m_dwVersion;  // We gain one character thus including the null terminator
    _ASSERTE(storageSize == sizeof(STORAGESIGNATURE) + m_dwVersion);
    IfFailRet(m_pStgIO->Write(&sSig, sizeof(STORAGESIGNATURE), &cbWritten));
    IfFailRet(m_pStgIO->Write(m_Version, m_dwVersion, &cbWritten));

    return hr;
}


//*****************************************************************************
// Read the header from disk.  This reads the header for the most recent version
// of the file format which has the header at the front of the data file.
//*****************************************************************************
HRESULT TiggerStorage::ReadHeader() // Return code.
{
    STORAGESTREAM *pAppend, *pStream;// For copy of array.
    void        *ptr;               // Working pointer.
    ULONG       iOffset;            // Offset of header data.
    ULONG       cbExtra;            // Size of extra data.
    ULONG       cbRead;             // For calc of read sizes.
    HRESULT     hr;

    // Read the signature
    if (FAILED(hr = m_pStgIO->GetPtrForMem(0, sizeof(STORAGESIGNATURE), ptr)))
        return hr;

    STORAGESIGNATURE* pStorage = (STORAGESIGNATURE*) ptr;

    // Make sure we have paged in enough data  // Bill do we need to do this????
    //  if (FAILED(hr = m_pStgIO->GetPtrForMem(sizeof(STORAGESIGNATURE), pStorage->iVersionString, ptr)))
    //      return hr;

    // Header data starts after signature.
    iOffset = sizeof(STORAGESIGNATURE) + pStorage->iVersionString;

    // Read the storage header which has the stream counts.  Throw in the extra
    // count which might not exist, but saves us down stream.
    if (FAILED(hr = m_pStgIO->GetPtrForMem(iOffset, sizeof(STORAGEHEADER) + sizeof(ULONG), ptr)))
        return (hr);
    if (!m_pStgIO->IsAlignedPtr((ULONG) ptr, 4))
        return (PostError(CLDB_E_FILE_CORRUPT));

    // Copy the header into memory and check it.
    memcpy(&m_StgHdr, ptr, sizeof(STORAGEHEADER));
    IfFailRet( VerifyHeader() );
    ptr = (void *) ((STORAGEHEADER *) ptr + 1);
    iOffset += sizeof(STORAGEHEADER);

    // Save off a pointer to the extra data.
    if (m_StgHdr.fFlags & STGHDR_EXTRADATA)
    {
        m_pbExtra = ptr;
        cbExtra = sizeof(ULONG) + *(ULONG *) ptr;

        // Force the extra data to get faulted in.
        IfFailRet( m_pStgIO->GetPtrForMem(iOffset, cbExtra, ptr) );
		if (!m_pStgIO->IsAlignedPtr((ULONG) ptr, 4))
			return (PostError(CLDB_E_FILE_CORRUPT));
    }
    else
    {
        m_pbExtra = 0;
        cbExtra = 0;
    }
    iOffset += cbExtra;

    // Force the worst case scenario of bytes to get faulted in for the
    // streams.  This makes the rest of this code very simple.
    cbRead = sizeof(STORAGESTREAM) * m_StgHdr.iStreams;
    if (cbRead)
    {
        cbRead = min(cbRead, m_pStgIO->GetDataSize() - iOffset);
        if (FAILED(hr = m_pStgIO->GetPtrForMem(iOffset, cbRead, ptr)))
            return (hr);
		if (!m_pStgIO->IsAlignedPtr((ULONG) ptr, 4))
			return (PostError(CLDB_E_FILE_CORRUPT));

        // For read only, just access the header data.
        if (m_pStgIO->IsReadOnly())
        {
            // Save a pointer to the current list of streams.
            m_pStreamList = (STORAGESTREAM *) ptr;
        }
        // For writeable, need a copy we can modify.
        else
        {
            pStream = (STORAGESTREAM *) ptr;

            // Copy each of the stream headers.
            for (int i=0;  i<m_StgHdr.iStreams;  i++)
            {
                if ((pAppend = m_Streams.Append()) == 0)
                    return (PostError(OutOfMemory()));
                // Validate that the stream header is not too big.
                ULONG sz = pStream->GetStreamSize();
                if (sz > sizeof(STORAGESTREAM))
					return (PostError(CLDB_E_FILE_CORRUPT));
                memcpy (pAppend, pStream, sz);
                pStream = pStream->NextStream();
                if (!m_pStgIO->IsAlignedPtr((ULONG) pStream, 4))
					return (PostError(CLDB_E_FILE_CORRUPT));
            }

            // All must be loaded and accounted for.
            _ASSERTE(m_StgHdr.iStreams == m_Streams.Count());
        }
    }
    return (S_OK);
}


//*****************************************************************************
// Verify the header is something this version of the code can support.
//*****************************************************************************
HRESULT TiggerStorage::VerifyHeader()
{

    //@FUTURE: add version check for format.
    return (S_OK);
}

//*****************************************************************************
// Print the sizes of the various streams.
//*****************************************************************************
#if defined(_DEBUG)
ULONG TiggerStorage::PrintSizeInfo(bool verbose)
{
    ULONG total = 0;

    printf("Storage Header:  %d\n",sizeof(STORAGEHEADER));
    if (m_pStreamList)
    {
        STORAGESTREAM *storStream = m_pStreamList;
        STORAGESTREAM *pNext;
        for (ULONG i = 0; i<m_StgHdr.iStreams; i++)
        {
            pNext = storStream->NextStream();
            printf("Stream #%d (%s) Header: %d, Data: %d\n",i,storStream->rcName, (BYTE*)pNext - (BYTE*)storStream, storStream->iSize);
            total += storStream->iSize; 
            storStream = pNext;
        }
    }
    else
    {
        //todo: Add support for the case where m_Streams exists and m_pStreamList does not
    }

    if (m_pbExtra)
    {
        printf("Extra bytes: %d\n",*(ULONG*)m_pbExtra);
        total += *(ULONG*)m_pbExtra;
    }
    return total;
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\assemblymdinternaldisp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// AssemblyMDInternalDispenser.h
//
// Contains utility code for MD directory
//
//*****************************************************************************
#ifndef __AssemblyMDInternalDispenser__h__
#define __AssemblyMDInternalDispenser__h__



#include "..\Runtime\MDInternalRO.h"
#include "fusionpriv.h"

//*****************************************************************************
// This class can support the IMetaDataAssemblyImport and some funcationalities 
// of IMetaDataImport on the internal import interface (IMDInternalImport).
//*****************************************************************************
class AssemblyMDInternalImport :  public IMetaDataAssemblyImport, public IMetaDataImport, public IAssemblySignature
{
public:
    AssemblyMDInternalImport(IMDInternalImport *pMDInternalImport);
    ~AssemblyMDInternalImport();

    // *** IUnknown methods ***
    STDMETHODIMP    QueryInterface(REFIID riid, void** ppUnk);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IMetaDataAssemblyImport methods ***
    STDMETHODIMP GetAssemblyProps (         // S_OK or error.
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
        ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        DWORD       *pdwAssemblyFlags);         // [OUT] Flags.

    STDMETHODIMP GetAssemblyRefProps (      // S_OK or error.
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
        ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        DWORD       *pdwAssemblyRefFlags);      // [OUT] Flags.

    STDMETHODIMP GetFileProps (             // S_OK or error.
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags);         // [OUT] Flags.

    STDMETHODIMP GetExportedTypeProps (          // S_OK or error.
        mdExportedType   mdct,                   // [IN] The ExportedType for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef or mdExportedType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        DWORD       *pdwExportedTypeFlags);      // [OUT] Flags.

    STDMETHODIMP GetManifestResourceProps ( // S_OK or error.
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPWSTR      szName,                 // [OUT] Buffer to fill with name.
        ULONG       cchName,                // [IN] Size of buffer in wide chars.
        ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ManifestResource.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        DWORD       *pdwResourceFlags);     // [OUT] Flags.

    STDMETHODIMP EnumAssemblyRefs (         // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
        ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumFiles (                // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdFile      rFiles[],               // [OUT] Put Files here.
        ULONG       cMax,                   // [IN] Max Files to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumExportedTypes (        // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdExportedType   rExportedTypes[],  // [OUT] Put ExportedTypes here.
        ULONG       cMax,                   // [IN] Max ExportedTypes to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP EnumManifestResources (    // S_OK or error
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
        mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
        ULONG       cMax,                   // [IN] Max Resources to put.
        ULONG       *pcTokens);             // [OUT] Put # put here.

    STDMETHODIMP GetAssemblyFromScope (     // S_OK or error
        mdAssembly  *ptkAssembly);          // [OUT] Put token here.

    STDMETHODIMP FindExportedTypeByName (   // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ExportedType.
        mdToken     mdtExportedType,        // [IN] ExportedType for the enclosing class.
        mdExportedType   *ptkExportedType);      // [OUT] Put the ExportedType token here.

    STDMETHODIMP FindManifestResourceByName (  // S_OK or error
        LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
        mdManifestResource *ptkManifestResource);       // [OUT] Put the ManifestResource token here.

    STDMETHOD_(void, CloseEnum)(
        HCORENUM hEnum);                    // Enum to be closed.

    STDMETHODIMP FindAssembliesByName (     // S_OK or error
        LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
        LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
        LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
        IUnknown *ppIUnk[],                 // [OUT] put IMetaDataAssemblyImport pointers here
        ULONG    cMax,                      // [IN] The max number to put
        ULONG    *pcAssemblies);            // [OUT] The number of assemblies returned.

    // *** IMetaDataImport methods ***
    STDMETHOD(CountEnum)(HCORENUM hEnum, ULONG *pulCount);
    STDMETHOD(ResetEnum)(HCORENUM hEnum, ULONG ulPos);     
    STDMETHOD(EnumTypeDefs)(HCORENUM *phEnum, mdTypeDef rTypeDefs[],
                            ULONG cMax, ULONG *pcTypeDefs);     
    STDMETHOD(EnumInterfaceImpls)(HCORENUM *phEnum, mdTypeDef td,
                            mdInterfaceImpl rImpls[], ULONG cMax,
                            ULONG* pcImpls);     
    STDMETHOD(EnumTypeRefs)(HCORENUM *phEnum, mdTypeRef rTypeRefs[],
                            ULONG cMax, ULONG* pcTypeRefs);     

    STDMETHOD(FindTypeDefByName)(           // S_OK or error.
        LPCWSTR     szTypeDef,              // [IN] Name of the Type.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef for Enclosing class.
        mdTypeDef   *ptd);                  // [OUT] Put the TypeDef token here.

    STDMETHOD(GetScopeProps)(               // S_OK or error.
        LPWSTR      szName,                 // [OUT] Put the name here.
        ULONG       cchName,                // [IN] Size of name buffer in wide chars.
        ULONG       *pchName,               // [OUT] Put size of name (wide chars) here.
        GUID        *pmvid);                // [OUT, OPTIONAL] Put MVID here.

    STDMETHOD(GetModuleFromScope)(          // S_OK.
        mdModule    *pmd);                  // [OUT] Put mdModule token here.

    STDMETHOD(GetTypeDefProps)(             // S_OK or error.
        mdTypeDef   td,                     // [IN] TypeDef token for inquiry.
        LPWSTR      szTypeDef,              // [OUT] Put name here.
        ULONG       cchTypeDef,             // [IN] size of name buffer in wide chars.
        ULONG       *pchTypeDef,            // [OUT] put size of name (wide chars) here.
        DWORD       *pdwTypeDefFlags,       // [OUT] Put flags here.
        mdToken     *ptkExtends);           // [OUT] Put base class TypeDef/TypeRef here.

    STDMETHOD(GetInterfaceImplProps)(       // S_OK or error.
        mdInterfaceImpl iiImpl,             // [IN] InterfaceImpl token.
        mdTypeDef   *pClass,                // [OUT] Put implementing class token here.
        mdToken     *ptkIface);             // [OUT] Put implemented interface token here.              

    STDMETHOD(GetTypeRefProps)(             // S_OK or error.
        mdTypeRef   tr,                     // [IN] TypeRef token.
        mdToken     *ptkResolutionScope,    // [OUT] Resolution scope, ModuleRef or AssemblyRef.
        LPWSTR      szName,                 // [OUT] Name of the TypeRef.
        ULONG       cchName,                // [IN] Size of buffer.
        ULONG       *pchName);              // [OUT] Size of Name.

    STDMETHOD(ResolveTypeRef)(mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd);     

    STDMETHOD(EnumMembers)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHOD(EnumMembersWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdToken     rMembers[],             // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHOD(EnumMethods)(                 // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.   
        ULONG       cMax,                   // [IN] Max MethodDefs to put.  
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHOD(EnumMethodsWithName)(         // S_OK, S_FALSE, or error.             
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdMethodDef rMethods[],             // [OU] Put MethodDefs here.    
        ULONG       cMax,                   // [IN] Max MethodDefs to put.              
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHOD(EnumFields)(                 // S_OK, S_FALSE, or error.  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        mdFieldDef  rFields[],              // [OUT] Put FieldDefs here.    
        ULONG       cMax,                   // [IN] Max FieldDefs to put.   
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHOD(EnumFieldsWithName)(         // S_OK, S_FALSE, or error.              
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
        mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
        LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
        mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.              
        ULONG       *pcTokens);             // [OUT] Put # put here.    


    STDMETHOD(EnumParams)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdParamDef  rParams[],              // [OUT] Put ParamDefs here.    
        ULONG       cMax,                   // [IN] Max ParamDefs to put.   
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHOD(EnumMemberRefs)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tkParent,               // [IN] Parent token to scope the enumeration.  
        mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.   
        ULONG       cMax,                   // [IN] Max MemberRefs to put.  
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHOD(EnumMethodImpls)(             // S_OK, S_FALSE, or error  
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdToken     rMethodBody[],          // [OUT] Put Method Body tokens here.   
        mdToken     rMethodDecl[],          // [OUT] Put Method Declaration tokens here.
        ULONG       cMax,                   // [IN] Max tokens to put.  
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHOD(EnumPermissionSets)(          // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.    
        DWORD       dwActions,              // [IN] if !0, return only these actions.   
        mdPermission rPermission[],         // [OUT] Put Permissions here.  
        ULONG       cMax,                   // [IN] Max Permissions to put. 
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHOD(FindMember)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdToken     *pmb);                  // [OUT] matching memberdef 

    STDMETHOD(FindMethod)(  
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMethodDef *pmb);                  // [OUT] matching memberdef 

    STDMETHOD(FindField)(   
        mdTypeDef   td,                     // [IN] given typedef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdFieldDef  *pmb);                  // [OUT] matching memberdef 

    STDMETHOD(FindMemberRef)(   
        mdTypeRef   td,                     // [IN] given typeRef   
        LPCWSTR     szName,                 // [IN] member name 
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
        mdMemberRef *pmr);                  // [OUT] matching memberref 

    STDMETHOD (GetMethodProps)( 
        mdMethodDef mb,                     // The method for which to get props.   
        mdTypeDef   *pClass,                // Put method's class here. 
        LPWSTR      szMethod,               // Put method's name here.  
        ULONG       cchMethod,              // Size of szMethod buffer in wide chars.   
        ULONG       *pchMethod,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags);         // [OUT] Impl. Flags    

    STDMETHOD(GetMemberRefProps)(           // S_OK or error.   
        mdMemberRef mr,                     // [IN] given memberref 
        mdToken     *ptk,                   // [OUT] Put classref or classdef here. 
        LPWSTR      szMember,               // [OUT] buffer to fill for member's name   
        ULONG       cchMember,              // [IN] the count of char of szMember   
        ULONG       *pchMember,             // [OUT] actual count of char in member name    
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value  
        ULONG       *pbSig);                // [OUT] actual size of signature blob  

    STDMETHOD(EnumProperties)(              // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdProperty  rProperties[],          // [OUT] Put Properties here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcProperties);         // [OUT] Put # put here.    

    STDMETHOD(EnumEvents)(                  // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
        mdEvent     rEvents[],              // [OUT] Put events here.   
        ULONG       cMax,                   // [IN] Max events to put.  
        ULONG       *pcEvents);             // [OUT] Put # put here.    

    STDMETHOD(GetEventProps)(               // S_OK, S_FALSE, or error. 
        mdEvent     ev,                     // [IN] event token 
        mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.    
        LPCWSTR     szEvent,                // [OUT] Event name 
        ULONG       cchEvent,               // [IN] the count of wchar of szEvent   
        ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name 
        DWORD       *pdwEventFlags,         // [OUT] Event flags.   
        mdToken     *ptkEventType,          // [OUT] EventType class    
        mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event  
        mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event   
        mdMethodDef *pmdFire,               // [OUT] Fire method of the event   
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event  
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod);        // [OUT] total number of other method of this event 

    STDMETHOD(EnumMethodSemantics)(         // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
        mdToken     rEventProp[],           // [OUT] Put Event/Property here.   
        ULONG       cMax,                   // [IN] Max properties to put.  
        ULONG       *pcEventProp);          // [OUT] Put # put here.    

    STDMETHOD(GetMethodSemantics)(          // S_OK, S_FALSE, or error. 
        mdMethodDef mb,                     // [IN] method token    
        mdToken     tkEventProp,            // [IN] event/property token.   
        DWORD       *pdwSemanticsFlags);      // [OUT] the role flags for the method/propevent pair 

    STDMETHOD(GetClassLayout) ( 
        mdTypeDef   td,                     // [IN] give typedef    
        DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16  
        COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array 
        ULONG       cMax,                   // [IN] size of the array   
        ULONG       *pcFieldOffset,         // [OUT] needed array size  
        ULONG       *pulClassSize);             // [OUT] the size of the class  

    STDMETHOD(GetFieldMarshal) (    
        mdToken     tk,                     // [IN] given a field's memberdef   
        PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field  
        ULONG       *pcbNativeType);        // [OUT] the count of bytes of *ppvNativeType   

    STDMETHOD(GetRVA)(                      // S_OK or error.   
        mdToken     tk,                     // Member for which to set offset   
        ULONG       *pulCodeRVA,            // The offset   
        DWORD       *pdwImplFlags);         // the implementation flags 

    STDMETHOD(GetPermissionSetProps) (  
        mdPermission pm,                    // [IN] the permission token.   
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.   
        void const  **ppvPermission,        // [OUT] permission blob.   
        ULONG       *pcbPermission);        // [OUT] count of bytes of pvPermission.    

    STDMETHOD(GetSigFromToken)(             // S_OK or error.   
        mdSignature mdSig,                  // [IN] Signature token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.   
        ULONG       *pcbSig);               // [OUT] return size of signature.  

    STDMETHOD(GetModuleRefProps)(           // S_OK or error.   
        mdModuleRef mur,                    // [IN] moduleref token.    
        LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.    
        ULONG       cchName,                // [IN] size of szName in wide characters.  
        ULONG       *pchName);              // [OUT] actual count of characters in the name.    

    STDMETHOD(EnumModuleRefs)(              // S_OK or error.   
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.   
        ULONG       cmax,                   // [IN] max memberrefs to put.  
        ULONG       *pcModuleRefs);         // [OUT] put # put here.    

    STDMETHOD(GetTypeSpecFromToken)(        // S_OK or error.   
        mdTypeSpec typespec,                // [IN] TypeSpec token.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to TypeSpec signature  
        ULONG       *pcbSig);               // [OUT] return size of signature.  

    STDMETHOD(GetNameFromToken)(            // Not Recommended! May be removed!
        mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
        MDUTF8CSTR  *pszUtf8NamePtr);       // [OUT] Return pointer to UTF8 name in heap.

    STDMETHOD(EnumUnresolvedMethods)(       // S_OK, S_FALSE, or error. 
        HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
        mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
        ULONG       cMax,                   // [IN] Max MemberDefs to put.  
        ULONG       *pcTokens);             // [OUT] Put # put here.    

    STDMETHOD(GetUserString)(               // S_OK or error.
        mdString    stk,                    // [IN] String token.
        LPWSTR      szString,               // [OUT] Copy of string.
        ULONG       cchString,              // [IN] Max chars of room in szString.
        ULONG       *pchString);            // [OUT] How many chars in actual string.

    STDMETHOD(GetPinvokeMap)(               // S_OK or error.
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
        LPWSTR      szImportName,           // [OUT] Import name.
        ULONG       cchImportName,          // [IN] Size of the name buffer.
        ULONG       *pchImportName,         // [OUT] Actual number of characters stored.
        mdModuleRef *pmrImportDLL);         // [OUT] ModuleRef token for the target DLL.

    STDMETHOD(EnumSignatures)(              // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdSignature rSignatures[],          // [OUT] put signatures here.   
        ULONG       cmax,                   // [IN] max signatures to put.  
        ULONG       *pcSignatures);         // [OUT] put # put here.

    STDMETHOD(EnumTypeSpecs)(               // S_OK or error.
        HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
        mdTypeSpec  rTypeSpecs[],           // [OUT] put TypeSpecs here.   
        ULONG       cmax,                   // [IN] max TypeSpecs to put.  
        ULONG       *pcTypeSpecs);          // [OUT] put # put here.

    STDMETHOD(EnumUserStrings)(             // S_OK or error.
        HCORENUM    *phEnum,                // [IN/OUT] pointer to the enum.
        mdString    rStrings[],             // [OUT] put Strings here.
        ULONG       cmax,                   // [IN] max Strings to put.
        ULONG       *pcStrings);            // [OUT] put # put here.

    STDMETHOD(GetParamForMethodIndex)(      // S_OK or error.
        mdMethodDef md,                     // [IN] Method token.
        ULONG       ulParamSeq,             // [IN] Parameter sequence.
        mdParamDef  *ppd);                  // [IN] Put Param token here.

    STDMETHOD(EnumCustomAttributes)(        // S_OK or error.
        HCORENUM    *phEnum,                // [IN, OUT] COR enumerator.
        mdToken     tk,                     // [IN] Token to scope the enumeration, 0 for all.
        mdToken     tkType,                 // [IN] Type of interest, 0 for all.
        mdCustomAttribute rCustomAttributes[], // [OUT] Put custom attribute tokens here.
        ULONG       cMax,                   // [IN] Size of rCustomAttributes.
        ULONG       *pcCustomAttributes);       // [OUT, OPTIONAL] Put count of token values here.

    STDMETHOD(GetCustomAttributeProps)(     // S_OK or error.
        mdCustomAttribute cv,               // [IN] CustomAttribute token.
        mdToken     *ptkObj,                // [OUT, OPTIONAL] Put object token here.
        mdToken     *ptkType,               // [OUT, OPTIONAL] Put AttrType token here.
        void const  **ppBlob,               // [OUT, OPTIONAL] Put pointer to data here.
        ULONG       *pcbSize);              // [OUT, OPTIONAL] Put size of date here.

    STDMETHOD(FindTypeRef)(   
        mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
        LPCWSTR     szName,                 // [IN] TypeRef Name.
        mdTypeRef   *ptr);                  // [OUT] matching TypeRef.

    STDMETHOD(GetMemberProps)(  
        mdToken     mb,                     // The member for which to get props.   
        mdTypeDef   *pClass,                // Put member's class here. 
        LPWSTR      szMember,               // Put member's name here.  
        ULONG       cchMember,              // Size of szMember buffer in wide chars.   
        ULONG       *pchMember,             // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        ULONG       *pulCodeRVA,            // [OUT] codeRVA    
        DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcchValue);            // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetFieldProps)(  
        mdFieldDef  mb,                     // The field for which to get props.    
        mdTypeDef   *pClass,                // Put field's class here.  
        LPWSTR      szField,                // Put field's name here.   
        ULONG       cchField,               // Size of szField buffer in wide chars.    
        ULONG       *pchField,              // Put actual size here 
        DWORD       *pdwAttr,               // Put flags here.  
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
        ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppValue,              // [OUT] constant value 
        ULONG       *pcchValue);            // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetPropertyProps)(            // S_OK, S_FALSE, or error. 
        mdProperty  prop,                   // [IN] property token  
        mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
        LPCWSTR     szProperty,             // [OUT] Property name  
        ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
        ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
        DWORD       *pdwPropFlags,          // [OUT] property flags.    
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
        ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
        DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
        void const  **ppDefaultValue,       // [OUT] constant value 
        ULONG       *pcchDefaultValue,      // [OUT] size of constant string in chars, 0 for non-strings.
        mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
        mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
        mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
        ULONG       cMax,                   // [IN] size of rmdOtherMethod  
        ULONG       *pcOtherMethod);        // [OUT] total number of other method of this property  

    STDMETHOD(GetParamProps)(               // S_OK or error.
        mdParamDef  tk,                     // [IN]The Parameter.
        mdMethodDef *pmd,                   // [OUT] Parent Method token.
        ULONG       *pulSequence,           // [OUT] Parameter sequence.
        LPWSTR      szName,                 // [OUT] Put name here.
        ULONG       cchName,                // [OUT] Size of name buffer.
        ULONG       *pchName,               // [OUT] Put actual size of name here.
        DWORD       *pdwAttr,               // [OUT] Put flags here.
        DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
        void const  **ppValue,              // [OUT] Constant value.
        ULONG       *pcchValue);            // [OUT] size of constant string in chars, 0 for non-strings.

    STDMETHOD(GetCustomAttributeByName)(    // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCWSTR     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData);              // [OUT] Put size of data here.

    STDMETHOD_(BOOL, IsValidToken)(         // True or False.
        mdToken     tk);                    // [IN] Given token.

    STDMETHOD(GetNestedClassProps)(         // S_OK or error.
        mdTypeDef   tdNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptdEnclosingClass);      // [OUT] EnclosingClass token.

    STDMETHOD(GetNativeCallConvFromSig)(    // S_OK or error.
        void const  *pvSig,                 // [IN] Pointer to signature.
        ULONG       cbSig,                  // [IN] Count of signature bytes.
        ULONG       *pCallConv);            // [OUT] Put calling conv here (see CorPinvokemap).                                                                                        

    STDMETHOD(IsGlobal)(                    // S_OK or error.
        mdToken     pd,                     // [IN] Type, Field, or Method token.
        int         *pbGlobal);             // [OUT] Put 1 if global, 0 otherwise.

    // *** IAssemblySignature methods ***
    STDMETHOD(GetAssemblySignature)(        // S_OK or error.
        BYTE        *pbSig,                 // [IN, OUT] Buffer to write signature
        DWORD       *pcbSig);               // [IN, OUT] Size of buffer, bytes written

    void SetHandle(HCORMODULE hHandle)
    {
        m_pHandle = hHandle;
    }

    void SetBase(LPVOID base)
    {
        m_pBase = base;
    }

private:
    ULONG                                   m_cRef;
    HCORMODULE                              m_pHandle;              // Handle to a cached PE image
    LPVOID                                  m_pBase;                // File mapping (if runtime is not init'd)
    IMDInternalImport                       *m_pMDInternalImport;
#ifdef _DEBUG
    IMetaDataAssemblyImport                 *m_pDebugMDImport;
#endif //_DEBUG
};

#endif // __AssemblyMDInternalDispenser__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\enc\stgio.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgIO.h
//
// This module handles disk/memory i/o for a generic set of storage solutions,
// including:
//	* File system handle (HFILE)
//	* IStream
//	* User supplied memory buffer (non-movable)
//
// The Read, Write, Seek, ... functions are all directed to the corresponding
// method for each type of file, allowing the consumer to use one set of api's.
//
// File system data can be paged fully into memory in two scenarios:
//	read:	Normal Win32 memory mapped file is created to manage paging.
//	write:	A custom paging system provides storage for pages as required.  This
//				data is invalidated when you call Rewrite on the file.
//
// Transactions and backups are handled in the existing file case only.  The
// Rewrite function can make a backup of the current contents, and the Restore
// function can be used to recover the data into the current scope.  The backup
// file is flushed to disk (which is slower but safer) after the copy.  The
// Restore also flushed the recovered changes to disk.  Worst case scenario you
// get a crash after calling Rewrite but before Restore, in which case you will
// have a foo.clb.txn file in the same directory as the source file, foo.clb in
// this example.
//
// @FUTURE: issues,
//	1.  For reading a .clb in an image, it would be great to memory map
//		only the portion of the file with the .clb in it.
//
//*****************************************************************************
#include "stdafx.h"						// Standard headers.
#include "StgIO.h"						// Our definitions.
#include "CorError.h"
#include "PostError.h"

//********** Types. ***********************************************************
#define SMALL_ALLOC_MAP_SIZE (64 * 1024) // 64 kb is the minimum size of virtual
										// memory you can allocate, so anything
										// less is a waste of VM resources.
#define MIN_WRITE_CACHE_BYTES (16 * 1024) // 16 kb for a write back cache


//********** Locals. **********************************************************
HRESULT MapFileError(DWORD error);
static void *AllocateMemory(int iSize);
static void FreeMemory(void *pbData);
inline HRESULT MapFileError(DWORD error)
{
	return (PostError(HRESULT_FROM_WIN32(error)));
}

// Static to class.
int	StgIO::m_iPageSize=0;				// Size of an OS page.
int	StgIO::m_iCacheSize=0;				// Size for the write cache.



//********** Code. ************************************************************
StgIO::StgIO(
	bool		bAutoMap) :				// Memory map for read on open?
	m_bAutoMap(bAutoMap)
{
	CtorInit();

	// If the system page size has not been queried, do so now.
	if (m_iPageSize == 0)
	{
		SYSTEM_INFO	sInfo;				// Some O/S information.

		// Query the system page size.
		GetSystemInfo(&sInfo);
		m_iPageSize = sInfo.dwPageSize;
		m_iCacheSize = ((MIN_WRITE_CACHE_BYTES - 1) & ~(m_iPageSize - 1)) + m_iPageSize;
	}
}


void StgIO::CtorInit()
{
	m_bWriteThrough = false;
	m_bRewrite = false;
	m_bFreeMem = false;
	m_hFile = INVALID_HANDLE_VALUE;
	m_hMapping = 0;
	m_pBaseData = 0;
	m_pData = 0;
	m_cbData = 0;
	m_fFlags = 0;
	m_iType = STGIO_NODATA;
	m_cbOffset = 0;
	m_rgBuff = 0;
	m_cbBuff = 0;
	m_rgPageMap = 0;
	*m_rcFile = '\0';
	*m_rcShared = '\0';
	m_cRef = 1;
}



StgIO::~StgIO()
{
	if (m_rgBuff)
	{
		FreeMemory(m_rgBuff);
		m_rgBuff = 0;
	}

	Close();
}


//*****************************************************************************
// Open the base file on top of: (a) file, (b) memory buffer, or (c) stream.
// If create flag is specified, then this will create a new file with the
// name supplied.  No data is read from an opened file.  You must call
// MapFileToMem before doing direct pointer access to the contents.
//*****************************************************************************
HRESULT StgIO::Open(					// Return code.
	LPCWSTR		szName,					// Name of the storage.
	long		fFlags,					// How to open the file.
	const void	*pbBuff,				// Optional buffer for memory.
	ULONG		cbBuff,					// Size of buffer.
	IStream		*pIStream,				// Stream for input.
	LPCWSTR		szSharedMem,			// Shared memory name.
	LPSECURITY_ATTRIBUTES pAttributes)	// Security token.
{
	DWORD		dwReadWrite = 0;		// Access mode.
	HRESULT		hr;

	// Check for shared mode open.
	if (szSharedMem)
	{
		// Must give a name if you use this option.
		_ASSERTE(szSharedMem);
		_ASSERTE(fFlags & (DBPROP_TMODEF_SMEMOPEN | DBPROP_TMODEF_SMEMCREATE));

		// Cannot allow write mode access to mapped view of file.
		_ASSERTE((fFlags & DBPROP_TMODEF_WRITE) == 0);

		// Save the name.
		_ASSERTE(_tcslen(szSharedMem) < MAXSHMEM);
		_tcsncpy(m_rcShared, szSharedMem, MAXSHMEM);
		m_rcShared[MAXSHMEM - 1] = 0;
	}

	// If we were given the storage memory to begin with, then use it.
	if (pbBuff && cbBuff)
	{
		_ASSERTE((fFlags & DBPROP_TMODEF_WRITE) == 0);

		// Save the memory address and size only.  No handles.
		m_pData = (void *) pbBuff;
		m_cbData = cbBuff;

		// All access to data will be by memory provided.
		m_iType = STGIO_MEM;
		goto ErrExit;
	}
	// Check for data backed by a stream pointer.
	else if (pIStream)
	{
		// If this is for the non-create case, get the size of existing data.
		if ((fFlags & DBPROP_TMODEF_CREATE) == 0)
		{
			LARGE_INTEGER	iMove = { 0, 0 };
			ULARGE_INTEGER	iSize;

			// Need the size of the data so we can map it into memory.
			if (FAILED(hr = pIStream->Seek(iMove, STREAM_SEEK_END, &iSize)))
				return (hr);
			m_cbData = iSize.LowPart;
		}
		// Else there is nothing.
		else
			m_cbData = 0;

		// Save an addref'd copy of the stream.
		m_pIStream = pIStream;

		// All access to data will be by memory provided.
		m_iType = STGIO_STREAM;
		goto ErrExit;
	}
	// Check for the open of a shared memory segment.
	else if (fFlags & DBPROP_TMODEF_SMEMOPEN)
	{
		// Save the size parameter given if open.
		if (!pbBuff && cbBuff && !m_cbData)
			m_cbData = cbBuff;

		// Treat this as a memory driven type.
		m_iType = STGIO_SHAREDMEM;
		m_fFlags = fFlags;

		// Try to do the map immediately.
		void		*ptr;
		ULONG		cb;
		
		if (FAILED(hr = MapFileToMem(ptr, &cb, pAttributes)))
		{
			// If we failed to open shared memory, and we're allowed to
			// create it, then proceed.
			if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) &&
				(fFlags & DBPROP_TMODEF_SMEMCREATE))
			{
				hr = S_OK;
				
				// Don't try any opens at this point.
				fFlags &= ~DBPROP_TMODEF_SMEMOPEN;
			}
			else
			{
				Close();
				return (hr);
			}
		}
		else
			goto ErrExit;
	}

	// If not on memory, we need a file to do a create/open.
	if (!szName || !*szName)
	{
		return (PostError(E_INVALIDARG));
	}
	// Check for create of a new file.
	else if (fFlags & DBPROP_TMODEF_CREATE)
	{
		// @future: This could chose to open the file in write through
		// mode, which would provide better Duribility (from ACID props),
		// but would be much slower.

		// Create the new file, overwriting only if caller allows it.
		if ((m_hFile = WszCreateFile(szName, GENERIC_READ | GENERIC_WRITE, 0, 0, 
				(fFlags & DBPROP_TMODEF_FAILIFTHERE) ? CREATE_NEW : CREATE_ALWAYS, 
				0, 0)) == INVALID_HANDLE_VALUE)
		{
			return (MapFileError(GetLastError()));
		}

		// Data will come from the file.
		m_iType = STGIO_HFILE;
	}
	// For open in read mode, need to open the file on disk.  If opening a shared
	// memory view, it has to be opened already, so no file open.
	else if ((fFlags & DBPROP_TMODEF_WRITE) == 0)
	{
		// Open the file for read.  Sharing is determined by caller, it can
		// allow other readers or be exclusive.
		if ((m_hFile = WszCreateFile(szName, GENERIC_READ, 
					(fFlags & DBPROP_TMODEF_EXCLUSIVE) ? 0 : FILE_SHARE_READ,
					0, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE)
			return (MapFileError(GetLastError()));

		// Get size of file.
		m_cbData = ::SetFilePointer(m_hFile, 0, 0, FILE_END);

		// Can't read anything from an empty file.
		if (m_cbData == 0)
			return (PostError(CLDB_E_NO_DATA));

		// Data will come from the file.
		m_iType = STGIO_HFILE;
	}
	// For write mode, we're going to read everything into memory and
	// eventually rewrite it, so open for both in exclusive share mode.
	else if ((fFlags & (DBPROP_TMODEF_SMEMOPEN | DBPROP_TMODEF_SMEMCREATE)) == 0)
	{
		if ((m_hFile = WszCreateFile(szName, GENERIC_WRITE | GENERIC_READ, 
					0, 0, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE)
			return (MapFileError(GetLastError()));

		// Get size of file.
		m_cbData = ::SetFilePointer(m_hFile, 0, 0, FILE_END);

		// Data will come from the file.
		m_iType = STGIO_HFILE;
	}

ErrExit:

	// If we will ever write, then we need the buffer cache.
	if (fFlags & DBPROP_TMODEF_WRITE)
	{
		// Allocate a cache buffer for writing.
		if ((m_rgBuff = (BYTE *) AllocateMemory(m_iCacheSize)) == 0)
		{
			Close();
			return (PostError(OutOfMemory()));
		}
		m_cbBuff = 0;
	}


	// Save flags for later.
	m_fFlags = fFlags;
	if (szName && *szName)
		wcscpy(m_rcFile, szName);

	// For auto map case, map the view of the file as part of open.
	if (m_bAutoMap && 
		(m_iType == STGIO_HFILE || m_iType == STGIO_STREAM || 
			(fFlags & (DBPROP_TMODEF_SMEMOPEN | DBPROP_TMODEF_SMEMCREATE))) &&
		!(fFlags & DBPROP_TMODEF_CREATE))
	{
		void		*ptr;
		ULONG		cb;
		
		if (FAILED(hr = MapFileToMem(ptr, &cb, pAttributes)))
		{
			Close();
			return (hr);
		}
	}
	return (S_OK);	
}


//*****************************************************************************
// Shut down the file handles and allocated objects.
//*****************************************************************************
void StgIO::Close()
{
	switch (m_iType)
	{
		// Free any allocated memory.
		case STGIO_MEM:
		case STGIO_SHAREDMEM:
		case STGIO_HFILEMEM:
		if (m_bFreeMem && m_pBaseData)
		{
			FreeMemory(m_pBaseData);
			m_pBaseData = m_pData = 0;
		}
		// Intentional fall through to file case, if we kept handle open.

		case STGIO_HFILE:
		{
			// Free the file handle.
			if (m_hFile != INVALID_HANDLE_VALUE)
				CloseHandle(m_hFile);

			// If we allocated space for in memory paging, then free it.
		}
		break;

		// Free the stream pointer.
		case STGIO_STREAM:
		m_pIStream = 0;
		break;

		// Weird to shut down what you didn't open, isn't it?  Allow for
		// error case where dtor shuts down as after thought.
		case STGIO_NODATA:
		default:
		return;
	}

	// Free any page map and base data.
	FreePageMap();

	// Reset state values so we don't get confused.
	CtorInit();
}


//*****************************************************************************
// Read data from the storage source.  This will handle all types of backing
// storage from mmf, streams, and file handles.  No read ahead or MRU
// caching is done.
//*****************************************************************************
HRESULT StgIO::Read(					// Return code.
	void		*pbBuff,				// Write buffer here.
	ULONG		cbBuff,					// How much to read.
	ULONG		*pcbRead)				// How much read.
{
	ULONG		cbCopy;					// For boundary checks.
	void		*pbData;				// Data buffer for mem read.
	HRESULT		hr = S_OK;

	// Validate arguments, don't call if you don't need to.
	_ASSERTE(pbBuff != 0);
	_ASSERTE(cbBuff > 0);

	// Get the data based on type.
	switch (m_iType)
	{
		// For data on file, there are two possiblities:
		// (1) We have an in memory backing store we should use, or
		// (2) We just need to read from the file.
		case STGIO_HFILE:
		{
			_ASSERTE(m_hFile != INVALID_HANDLE_VALUE);

			// Backing store does its own paging.
			if (IsBackingStore() || IsMemoryMapped())
			{
				// Force the data into memory.
				if (FAILED(hr = GetPtrForMem(GetCurrentOffset(), cbBuff, pbData)))
					goto ErrExit;

				// Copy it back for the user and save the size.
				memcpy(pbBuff, pbData, cbBuff);
				if (pcbRead)
					*pcbRead = cbBuff;				
			}
			// If there is no backing store, this is just a read operation.
			else
			{
				ULONG	cbTemp = 0;
				if (!pcbRead)
					pcbRead = &cbTemp;
				hr = ReadFromDisk(pbBuff, cbBuff, pcbRead);
				m_cbOffset += *pcbRead;
			}
		}
		break;

		// Data in a stream is always just read.
		case STGIO_STREAM:
		{
			_ASSERTE((IStream *) m_pIStream);
			if (!pcbRead)
				pcbRead = &cbCopy;
			hr = m_pIStream->Read(pbBuff, cbBuff, pcbRead);
			if (SUCCEEDED(hr))
				m_cbOffset += *pcbRead;
		}
		break;

		// Simply copy the data from our data.
		case STGIO_MEM:
		case STGIO_SHAREDMEM:
		case STGIO_HFILEMEM:
		{
			_ASSERTE(m_pData && m_cbData);

			// Check for read past end of buffer and adjust.
			if (GetCurrentOffset() + cbBuff > m_cbData)
				cbCopy = m_cbData - GetCurrentOffset();
			else
				cbCopy = cbBuff;
							
			// Copy the data into the callers buffer.
			memcpy(pbBuff, (void *) ((long) m_pData + GetCurrentOffset()), cbCopy);
			if (pcbRead)
				*pcbRead = cbCopy;
			
			// Save a logical offset.
			m_cbOffset += cbCopy;
		}
		break;
		 
		case STGIO_NODATA:
		default:
		_ASSERTE(0);
		break;
	}

ErrExit:
	return (hr);
}


//*****************************************************************************
// Write to disk.  This function will cache up to a page of data in a buffer
// and peridocially flush it on overflow and explicit request.  This makes it
// safe to do lots of small writes without too much performance overhead.
//*****************************************************************************
HRESULT StgIO::Write(					// true/false.
	const void	*pbBuff,				// Data to write.
	ULONG		cbWrite,				// How much data to write.
	ULONG		*pcbWritten)			// How much did get written.
{
	ULONG		cbWriteIn=cbWrite;		// Track amount written.
	ULONG		cbCopy;
	HRESULT		hr = S_OK;

	_ASSERTE(m_rgBuff != 0);
	_ASSERTE(cbWrite);

	while (cbWrite)
	{
		// In the case where the buffer is already huge, write the whole thing
		// and avoid the cache.
		if (m_cbBuff == 0 && cbWrite >= (ULONG) m_iPageSize)
		{
			if (SUCCEEDED(hr = WriteToDisk(pbBuff, cbWrite, pcbWritten)))
				m_cbOffset += cbWrite;
			break;
		}
		// Otherwise cache as much as we can and flush.
		else
		{
			// Determine how much data goes into the cache buffer.
			cbCopy = m_iPageSize - m_cbBuff;
			cbCopy = min(cbCopy, cbWrite);
			
			// Copy the data into the cache and adjust counts.
			memcpy(&m_rgBuff[m_cbBuff], pbBuff, cbCopy);
			pbBuff = (void *) ((long) pbBuff + cbCopy);
			m_cbBuff += cbCopy;
			m_cbOffset += cbCopy;
			cbWrite -= cbCopy;

			// If there is enough data, then flush it to disk and reset count.
			if (m_cbBuff >= (ULONG) m_iPageSize)
			{
				if (FAILED(hr = FlushCache()))
					break;
			}
		}
	}

	// Return value for caller.
	if (SUCCEEDED(hr) && pcbWritten)
		*pcbWritten = cbWriteIn;
	return (hr);
}


//*****************************************************************************
// Moves the file pointer to the new location.  This handles the different
// types of storage systems.
//*****************************************************************************
HRESULT StgIO::Seek(					// New offset.
	long		lVal,					// How much to move.
	ULONG		fMoveType)				// Direction, use Win32 FILE_xxxx.
{
	ULONG		cbRtn = 0;
	HRESULT		hr = NOERROR;

	_ASSERTE(fMoveType >= FILE_BEGIN && fMoveType <= FILE_END);

	// Action taken depends on type of storage.
	switch (m_iType)
	{
		case STGIO_HFILE:
		{
			// Use the file system's move.
			_ASSERTE(m_hFile != INVALID_HANDLE_VALUE);
			cbRtn = ::SetFilePointer(m_hFile, lVal, 0, fMoveType);
			
			// Save the location redundently.
			if (cbRtn != 0xffffffff)
            {
                // make sure that m_cbOffset will stay within range
                if (cbRtn > m_cbData || cbRtn < 0)
                {
                    IfFailGo(STG_E_INVALIDFUNCTION);
                }
				m_cbOffset = cbRtn;
            }
		}
		break;

		case STGIO_STREAM:
		{
			LARGE_INTEGER	iMove;
			ULARGE_INTEGER	iNewLoc;

			// Need a 64-bit int.
			iMove.QuadPart = lVal;

			// The move types are named differently, but have same value.
			if (FAILED(hr = m_pIStream->Seek(iMove, fMoveType, &iNewLoc)))
				return (hr);

            // make sure that m_cbOffset will stay within range
            if (iNewLoc.LowPart > m_cbData || iNewLoc.LowPart < 0)
                IfFailGo(STG_E_INVALIDFUNCTION);

            // Save off only out location.
			m_cbOffset = iNewLoc.LowPart;
		}
		break;

		case STGIO_MEM:
		case STGIO_SHAREDMEM:
		case STGIO_HFILEMEM:
		{
			// We own the offset, so change our value.
			switch (fMoveType)
			{
				case FILE_BEGIN:

                // make sure that m_cbOffset will stay within range
                if ((ULONG) lVal > m_cbData || lVal < 0)
                {
                    IfFailGo(STG_E_INVALIDFUNCTION);
                }
				m_cbOffset = lVal;
				break;

				case FILE_CURRENT:
                
                // make sure that m_cbOffset will stay within range
                if (m_cbOffset + lVal > m_cbData)
                {
                    IfFailGo(STG_E_INVALIDFUNCTION);
                }
				m_cbOffset = m_cbOffset + lVal;
				break;

				case FILE_END:
				_ASSERTE(lVal < (LONG) m_cbData);
                // make sure that m_cbOffset will stay within range
                if (m_cbData + lVal > m_cbData)
                {
                    IfFailGo(STG_E_INVALIDFUNCTION);
                }
				m_cbOffset = m_cbData + lVal;
				break;
			}

			cbRtn = m_cbOffset;
		}
		break;

		// Weird to seek with no data.
		case STGIO_NODATA:
		default:
		_ASSERTE(0);
		break;
	}

ErrExit:
    return hr;
}


//*****************************************************************************
// Retrieves the current offset for the storage being used.  This value is
// tracked based on Read, Write, and Seek operations.
//*****************************************************************************
ULONG StgIO::GetCurrentOffset()			// Current offset.
{
	return (m_cbOffset);
}


//*****************************************************************************
// Map the file contents to a memory mapped file and return a pointer to the 
// data.  For read/write with a backing store, map the file using an internal
// paging system.
//*****************************************************************************
HRESULT StgIO::MapFileToMem(			// Return code.
	void		*&ptr,					// Return pointer to file data.
	ULONG		*pcbSize,				// Return size of data.
	LPSECURITY_ATTRIBUTES pAttributes)	// Security token.
{
    char		rcShared[MAXSHMEM];		// ANSI version of shared name.
	HRESULT		hr = S_OK;

	// Don't penalize for multiple calls.  Also, allow calls for mem type so
	// callers don't need to do so much checking.
	if (IsBackingStore() || IsMemoryMapped() || 
			m_iType == STGIO_MEM || m_iType == STGIO_HFILEMEM)
	{
		ptr = m_pData;
		if (pcbSize)
			*pcbSize = m_cbData;
		return (S_OK);
	}

	// Check for a shared chunk of memory to create/open.
	if (m_fFlags & DBPROP_TMODEF_SMEMOPEN)
	{
		// Determine if there is a name for the shared memory to create/open.
		_ASSERTE(*m_rcShared);

		// Convert the name to ansi.
		Wsz_wcstombs(rcShared, m_rcShared, sizeof(rcShared));

		// First open the shared memory handle into this process.
		_ASSERTE(m_hMapping == 0);
		m_hMapping = OpenFileMappingA(FILE_MAP_READ, FALSE, rcShared);
		if (!m_hMapping)
		{
			hr = MapFileError(GetLastError());
			goto ErrExit;
		}

		// Now map the file into memory so we can read from pointer access.
		// Note: Added a check for IsBadReadPtr per the Services team which
		// indicates that under some conditions this API can give you back
		// a totally bogus pointer.
		void *pbData;
		pbData = MapViewOfFileEx(m_hMapping, FILE_MAP_READ, 0, 0, 0, m_pData);
		if (!pbData || IsBadReadPtr(pbData, m_iPageSize))
		{
			hr = MapFileError(GetLastError());
			if (!FAILED(hr))
				hr = PostError(CLDB_E_FILE_CORRUPT);
			goto ErrExit;
		}

		// Check for relocation.  This is the case where the caller has done
		// a light close of a memory mapped object but kept its pointer state.
		// They are now doing a light weight open but the memory could not
		// be mapped to the same location in the address state.  Their in-memory
		// state is now bogus and they need to know that.
		if (m_pData != 0 && pbData != m_pData)
		{
			VERIFY(UnmapViewOfFile(pbData));
			hr = CLDB_E_RELOCATED;
			goto ErrExit;
		}

		// Assume a file with unknown size is simply the rest of the process space.
		// This makes it easier on the caller who doesn't have to know the size
		// up front.
		if (m_cbData == 0)
			m_cbData = ((ULONG) -1) - (ULONG) pbData - 4096;

		// Assume a file with unknown size is simply the rest of the process space.
		// This makes it easier on the caller who doesn't have to know the size
		// up front.
		if (m_cbData == 0)
			m_cbData = ((ULONG) -1) - (ULONG) pbData - 4096;

		// Everything is ok for us to use.
		m_pBaseData = m_pData = pbData;
	}
	// Check the size of the data we want to map.  If it is small enough, then
	// simply allocate a chunk of memory from a finer grained heap.  This saves
	// virtual memory space, page table entries, and should reduce overall working set.
	// Note that any shared memory objects will require the handles to be in place
	// and are not elligible.  Also, open for read/write needs a full backing
	// store.
	else if (!*m_rcShared && m_cbData <= SMALL_ALLOC_MAP_SIZE)
	{
		DWORD cbRead = m_cbData;
		_ASSERTE(m_pData == 0);

		// Just malloc a chunk of data to use.
		m_pBaseData = m_pData = AllocateMemory(m_cbData);
		if (!m_pData)
		{
			hr = OutOfMemory();
			goto ErrExit;
		}

		// Read all of the file contents into this piece of memory.
		IfFailGo( Seek(0, FILE_BEGIN) );
		if (FAILED(hr = Read(m_pData, cbRead, &cbRead)))
		{
			FreeMemory(m_pData);
			m_pData = 0;
			goto ErrExit;
		}
		_ASSERTE(cbRead == m_cbData);

		// If the file isn't being opened for exclusive mode, then free it.
		// If it is for exclusive, then we need to keep the handle open so the
		// file is locked, preventing other readers.  Also leave it open if
		// in read/write mode so we can truncate and rewrite.
		if (m_hFile == INVALID_HANDLE_VALUE ||
			((m_fFlags & DBPROP_TMODEF_EXCLUSIVE) == 0 && (m_fFlags & DBPROP_TMODEF_WRITE) == 0))
		{
			// If there was a handle open, then free it.
			if (m_hFile != INVALID_HANDLE_VALUE)
			{
				VERIFY(CloseHandle(m_hFile));
				m_hFile = INVALID_HANDLE_VALUE;
			}
			// Free the stream pointer.
			else
				m_pIStream = 0;

			// Switch the type to memory only access.
			m_iType = STGIO_MEM;
		}
		else
			m_iType = STGIO_HFILEMEM;

		// Free the memory when we shut down.
		m_bFreeMem = true;
	}
	// Finally, a real mapping file must be created.
	else
	{
		// Now we will map, so better have it right.
		_ASSERTE(m_hFile != INVALID_HANDLE_VALUE || m_iType == STGIO_STREAM);
		_ASSERTE(m_rgPageMap == 0);

		// For read mode, use Windows memory mapped file since the size will never
		// change for the life of the handle.
		if ((m_fFlags & DBPROP_TMODEF_WRITE) == 0 && m_iType != STGIO_STREAM)
		{
			_ASSERTE(!*m_rcShared || (m_fFlags & (DBPROP_TMODEF_SMEMCREATE | DBPROP_TMODEF_SMEMOPEN)));

			// Create a mapping object for the file.
			_ASSERTE(m_hMapping == 0);
			if ((m_hMapping = WszCreateFileMapping(m_hFile, pAttributes, PAGE_READONLY,
					0, 0, *m_rcShared ? m_rcShared : 0)) == 0)
			{
				return (MapFileError(GetLastError()));
			}

			// Check to see if the memory already exists, in which case we have
			// no guarantees it is the right piece of data.
			if (GetLastError() == ERROR_ALREADY_EXISTS)
			{
				hr = PostError(CLDB_E_SMDUPLICATE, rcShared);
				goto ErrExit;
			}

			// Now map the file into memory so we can read from pointer access.
			// Note: Added a check for IsBadReadPtr per the Services team which
			// indicates that under some conditions this API can give you back
			// a totally bogus pointer.
			if ((m_pBaseData = m_pData = MapViewOfFile(m_hMapping, FILE_MAP_READ,
						0, 0, 0)) == 0 ||
				IsBadReadPtr(m_pData, m_iPageSize))
			{
				hr = MapFileError(GetLastError());
				if (!FAILED(hr))
					hr = PostError(CLDB_E_FILE_CORRUPT);
				
				// In case we got back a bogus pointer.
				m_pBaseData = m_pData = 0;
				goto ErrExit;
			}
		}
		// In write mode, we need the hybrid combination of being able to back up
		// the data in memory via cache, but then later rewrite the contents and
		// throw away our cached copy.  Memory mapped files are not good for this
		// case due to poor write characteristics.
		else
		{
			ULONG		iMaxSize;			// How much memory required for file.

			// Figure out how many pages we'll require, round up actual data
			// size to page size.
			iMaxSize = (((m_cbData - 1) & ~(m_iPageSize - 1)) + m_iPageSize);

			// Allocate a bit vector to track loaded pages.
			if ((m_rgPageMap = new BYTE[iMaxSize / m_iPageSize]) == 0)
				return (PostError(OutOfMemory()));
			memset(m_rgPageMap, 0, sizeof(BYTE) * (iMaxSize / m_iPageSize));

			// Allocate space for the file contents.
			if ((m_pBaseData = m_pData = ::VirtualAlloc(0, iMaxSize, MEM_RESERVE, PAGE_NOACCESS)) == 0)
			{
				hr = PostError(OutOfMemory());
				goto ErrExit;
			}
		}
	}

	// Reset any changes made by mapping.
	IfFailGo( Seek(0, FILE_BEGIN) );

ErrExit:

	// Check for errors and clean up.
	if (FAILED(hr))
	{
		if (m_hMapping)
			CloseHandle(m_hMapping);
		m_hMapping = 0;
		m_pBaseData = m_pData = 0;
		m_cbData = 0;
	}
	ptr = m_pData;
	if (pcbSize)
		*pcbSize = m_cbData;
	return (hr);
}


//*****************************************************************************
// Free the mapping object for shared memory but keep the rest of the internal
// state intact.
//*****************************************************************************
HRESULT StgIO::ReleaseMappingObject()	// Return code.
{
	// Check type first.
	if (m_iType != STGIO_SHAREDMEM)
	{
		_ASSERTE(0);
		return (S_OK);
	}

	// Must have an allocated handle.
	_ASSERTE(m_hMapping != 0);

	// Freeing the mapping object doesn't do any good if you still have the file.
	_ASSERTE(m_hFile == INVALID_HANDLE_VALUE);

	// Unmap the memory we allocated before freeing the handle.  But keep the
	// memory address in tact.
	if (m_pData)
		VERIFY(UnmapViewOfFile(m_pData));

	// Free the handle.
	if (m_hMapping != 0)
	{
		VERIFY(CloseHandle(m_hMapping));
		m_hMapping = 0;
	}
	return (S_OK);
}



//*****************************************************************************
// Resets the logical base address and size to the value given.  This is for
// cases like finding a section embedded in another format, like the .clb inside
// of an image.  GetPtrForMem, Read, and Seek will then behave as though only
// data from pbStart to cbSize is valid.
//*****************************************************************************
HRESULT StgIO::SetBaseRange(			// Return code.
	void		*pbStart,				// Start of file data.
	ULONG		cbSize)					// How big is the range.
{
	// The base range must be inside of the current range.
	_ASSERTE(m_iType != STGIO_SHAREDMEM || (m_pBaseData && m_cbData));
	_ASSERTE(m_iType != STGIO_SHAREDMEM || ((long) pbStart >= (long) m_pBaseData));
	_ASSERTE(m_iType != STGIO_SHAREDMEM || ((long) pbStart + cbSize <= (long) m_pBaseData + m_cbData));

	// Save the base range per user request.
	m_pData = pbStart;
	m_cbData = cbSize;
	return (S_OK);
}


//*****************************************************************************
// Caller wants a pointer to a chunk of the file.  This function will make sure
// that the memory for that chunk has been committed and will load from the
// file if required.  This algorithm attempts to load no more data from disk
// than is necessary.  It walks the required pages from lowest to highest,
// and for each block of unloaded pages, the memory is committed and the data
// is read from disk.  If all pages are unloaded, all of them are loaded at
// once to speed throughput from disk.
//*****************************************************************************
HRESULT StgIO::GetPtrForMem(			// Return code.
	ULONG		cbStart,				// Where to start getting memory.
	ULONG		cbSize,					// How much data.
	void		*&ptr)					// Return pointer to memory here.
{
	int			iFirst, iLast;			// First and last page required.
	ULONG		iOffset, iSize;			// For committing ranges of memory.
	int			i, j;					// Loop control.
	HRESULT		hr;

	// We need either memory (mmf or user supplied) or a backing store to
	// return a pointer.  Call Read if you don't have these.
	if (!IsBackingStore() && m_pData == 0)
		return (PostError(BadError(E_UNEXPECTED)));

	// Validate the caller isn't asking for a data value out of range.
	if (!(cbStart + cbSize <= m_cbData))
		return (PostError(E_INVALIDARG));

	// This code will check for pages that need to be paged from disk in
	// order for us to return a pointer to that memory.
	if (IsBackingStore())
	{
		// Backing store is bogus when in rewrite mode.
		if (m_bRewrite)
			return (PostError(BadError(E_UNEXPECTED)));

		// Must have the page map to continue.
		_ASSERTE(m_rgPageMap && m_iPageSize && m_pData);

		// Figure out the first and last page that are required for commit.
		iFirst = cbStart / m_iPageSize;
		iLast = (cbStart + cbSize - 1) / m_iPageSize;

		// Avoid confusion.
		ptr = 0;

		// Do a smart load of every page required.  Do not reload pages that have
		// already been brought in from disk.
		//@FUTURE: add an optimization so that when all pages have been faulted, we no
		// longer to a page by page search.
		for (i=iFirst;  i<=iLast;  )
		{
			// Find the first page that hasn't already been loaded.
			while (GetBit(m_rgPageMap, i) && i<=iLast)
				++i;
			if (i > iLast)
				break;

			// Offset for first thing to load.
			iOffset = i * m_iPageSize;
			iSize = 0;

			// See how many in a row have not been loaded.
			for (j=i;  i<=iLast && !GetBit(m_rgPageMap, i);  i++)
				iSize += m_iPageSize;

			// First commit the memory for this part of the file.
			if (::VirtualAlloc((void *) ((long) m_pData + iOffset), 
					iSize, MEM_COMMIT, PAGE_READWRITE) == 0)
				return (PostError(OutOfMemory()));

			// Now load that portion of the file from disk.
			if (FAILED(hr = Seek(iOffset, FILE_BEGIN)) ||
				FAILED(hr = ReadFromDisk((void *) ((long) m_pData + iOffset), iSize, 0)))
			{
				return (hr);
			}

			// Change the memory to read only to avoid any modifications.  Any faults
			// that occur indicate a bug whereby the engine is trying to write to
			// protected memory.
			_ASSERTE(::VirtualAlloc((void *) ((long) m_pData + iOffset), 
					iSize, MEM_COMMIT, PAGE_READONLY) != 0);
		
			// Record each new loaded page.
			for (;  j<i;  j++)
				SetBit(m_rgPageMap, j, true);
		}

		// Everything was brought into memory, so now return pointer to caller.
		ptr = (void *) ((long) m_pData + cbStart);
	}
	// Memory version or memory mapped file work the same way.
	else if (IsMemoryMapped() || m_iType == STGIO_MEM || 
			m_iType == STGIO_SHAREDMEM || m_iType == STGIO_HFILEMEM)
	{	
		if (!(cbStart < m_cbData))
			return (PostError(E_INVALIDARG));
		ptr = (void *) ((long) m_pData + cbStart);
	}
	// What's left?!  Add some defense.
	else
	{
		_ASSERTE(0);
		ptr = 0;
        return (PostError(BadError(E_UNEXPECTED)));
	}
	return (S_OK);
}


//*****************************************************************************
// For cached writes, flush the cache to the data store.
//*****************************************************************************
HRESULT StgIO::FlushCache()
{
	ULONG		cbWritten;
	HRESULT		hr;

	if (m_cbBuff)
	{
		if (FAILED(hr = WriteToDisk(m_rgBuff, m_cbBuff, &cbWritten)))
			return (hr);
		m_cbBuff = 0;
	}
	return (S_OK);
}

//*****************************************************************************
// Tells the Win32 file system to flush any cached data it may have.  This is
// expensive, but if successful guarantees you won't loose writes short of
// a disk failure.
//*****************************************************************************
HRESULT StgIO::FlushFileBuffers()
{
	_ASSERTE(!IsReadOnly());

	if (m_hFile != INVALID_HANDLE_VALUE)
	{
		if (::FlushFileBuffers(m_hFile))
			return (S_OK);
		else
			return (MapFileError(GetLastError()));
	}
	return (S_OK);
}


//*****************************************************************************
// Tells the storage that we intend to rewrite the contents of this file.  The
// entire file will be truncated and the next write will take place at the
// beginning of the file.
//*****************************************************************************
HRESULT StgIO::Rewrite(					// Return code.
	LPWSTR		szBackup)				// If non-0, backup the file.
{
    void		*ptr;					// Working pointer.
	HRESULT		hr;

	// @FUTURE: handle this case for stream.
	_ASSERTE(m_iType == STGIO_HFILE || m_hFile != INVALID_HANDLE_VALUE);
	if (m_hFile == INVALID_HANDLE_VALUE)
		return (BadError(E_UNEXPECTED));

	// Don't be calling this function for read only data.
	_ASSERTE(!IsReadOnly());

	// If there is still memory on disk, then it needs to be brought in because
	// we are about to truncate the file contents.  This state occurs when
	// data is partially faulted in, for example if there are 5 tables on disk
	// and you only opened 1 of them.  Also need to check for case where a save
	// was already done in this session.  In that case, there is no data on disk
	// that we care about and therefore we can't call GetPtrForMem.
	if (IsBackingStore())
	{
		if (FAILED(hr = GetPtrForMem(0, m_cbData, ptr)))
			return (hr);
	}

	// Caller wants a backup.  Create a temporary file copy of the user data,
	// and return the path to the caller.
	if (szBackup)
	{
		WCHAR		rcDir[_MAX_PATH];

		_ASSERTE(*m_rcFile);
		
		// Attempt to put the backup file in the user's directory so it is
		// easy for them to find on severe error.
		if (WszGetCurrentDirectory(_MAX_PATH, rcDir) &&
			(WszGetFileAttributes(rcDir) & FILE_ATTRIBUTE_READONLY) == 0)
		{
			WCHAR		rcDrive[_MAX_DRIVE];	// Volume name.
			WCHAR		rcDir2[_MAX_PATH];		// Directory.
			WCHAR		rcFile[_MAX_PATH];		// Name of file.

			SplitPath(m_rcFile, rcDrive, rcDir2, rcFile, 0);
			MakePath(szBackup, rcDrive, rcDir2, rcFile, L".clb.txn");
		}
		// Otherwise put the file in the temp directory.
		else
		{
			// Create a temporary path for backup.
			if( !WszGetTempPath(sizeof(rcDir)/sizeof(WCHAR), rcDir) )
                         return HRESULT_FROM_WIN32(GetLastError());
				
			VERIFY(WszGetTempFileName(rcDir, L"clb", 0, szBackup));
		}

		// Copy the file to the temporary path.
		if (FAILED(hr = CopyFileInternal(szBackup, false, m_bWriteThrough)))
			return (hr);
	}

	// Set mode to rewrite.  The backing store is rendered invalid at this point,
	// unless Restore is called.  If the rewrite is successful, this state will
	// stay in affect until shutdown.
	m_bRewrite = true;

	// Verify that we don't have any hanging data from previous work.
	_ASSERTE(m_cbBuff == 0);
	m_cbBuff = 0;
	m_cbOffset = 0;

	// Truncate the file.
	_ASSERTE(!IsReadOnly() && m_hFile != INVALID_HANDLE_VALUE);
	::SetFilePointer(m_hFile, 0, 0, FILE_BEGIN);
	VERIFY(::SetEndOfFile(m_hFile));
	return (S_OK);
}


//*****************************************************************************
// Called after a successful rewrite of an existing file.  The in memory
// backing store is no longer valid because all new data is in memory and
// on disk.  This is essentially the same state as created, so free up some
// working set and remember this state.
//*****************************************************************************
HRESULT StgIO::ResetBackingStore()		// Return code.
{
	// Don't be calling this function for read only data.
	_ASSERTE(!IsReadOnly());

	// Free up any backing store data we no longer need now that everything
	// is in memory.
	FreePageMap();
	return (S_OK);
}


//*****************************************************************************
// Called to restore the original file.  If this operation is successful, then
// the backup file is deleted as requested.  The restore of the file is done
// in write through mode to the disk help ensure the contents are not lost.
// This is not good enough to fulfill ACID props, but it ain't that bad.
//*****************************************************************************
HRESULT StgIO::Restore(					// Return code.
	LPWSTR		szBackup,				// If non-0, backup the file.
	int			bDeleteOnSuccess)		// Delete backup file if successful.
{
	BYTE		rcBuffer[4096];			// Buffer for copy.
	ULONG		cbBuff;					// Bytes read/write.
	ULONG		cbWrite;				// Check write byte count.
	HANDLE		hCopy;					// Handle for backup file.

	// Don't be calling this function for read only data.
	_ASSERTE(!IsReadOnly());

	// Open the backup file.
	if ((hCopy = ::WszCreateFile(szBackup, GENERIC_READ, 0,
				0, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE)
		return (MapFileError(GetLastError()));

	// Move to front of old file.
	VERIFY(::SetFilePointer(m_hFile, 0, 0, FILE_BEGIN) == 0);
	VERIFY(::SetEndOfFile(m_hFile));

	// Copy all data from the backup into our file.
	while (::ReadFile(hCopy, rcBuffer, sizeof(rcBuffer), &cbBuff, 0) && cbBuff)
		if (!::WriteFile(m_hFile, rcBuffer, cbBuff, &cbWrite, 0) || cbWrite != cbBuff)
		{
			::CloseHandle(hCopy);
			return (MapFileError(GetLastError()));
		}

	::CloseHandle(hCopy);

	// We were successful, so if caller desires, delete the backup file.
	if (::FlushFileBuffers(m_hFile) && 
			bDeleteOnSuccess
				&& REGUTIL::GetLong(L"AllowDeleteOnRevert", true)
			)
		VERIFY(::WszDeleteFile(szBackup));

	// Change mode back, after restore everything is back to open mode.
	m_bRewrite = false;
	return (S_OK);
}


//
// Private.
//



//*****************************************************************************
// This version will force the data in cache out to disk for real.  The code
// can handle the different types of storage we might be sitting on based on
// the open type.
//*****************************************************************************
HRESULT StgIO::WriteToDisk(				// Return code.
	const void	*pbBuff,				// Buffer to write.
	ULONG		cbWrite,				// How much.
	ULONG		*pcbWritten)			// Return how much written.
{
	ULONG		cbWritten;				// Buffer for write funcs.
	HRESULT		hr = S_OK;

	// Pretty obvious.
	_ASSERTE(!IsReadOnly());

	// Always need a buffer to write this data to.
	if (!pcbWritten)
		pcbWritten = &cbWritten;

	// Action taken depends on type of storage.
	switch (m_iType)
	{
		case STGIO_HFILE:
		case STGIO_HFILEMEM:
		{
			// Use the file system's move.
			_ASSERTE(m_hFile != INVALID_HANDLE_VALUE);

			// Do the write to disk.
			if (!::WriteFile(m_hFile, pbBuff, cbWrite, pcbWritten, 0))
				hr = MapFileError(GetLastError());
		}
		break;

		// Free the stream pointer.
		case STGIO_STREAM:
		{
			// Delegate write to stream code.
			hr = m_pIStream->Write(pbBuff, cbWrite, pcbWritten);
		}
		break;

		// We cannot write to fixed read/only memory.
		case STGIO_MEM:
		case STGIO_SHAREDMEM:
		_ASSERTE(0);
		hr = BadError(E_UNEXPECTED);
		break;

		// Weird to seek with no data.
		case STGIO_NODATA:
		default:
		_ASSERTE(0);
		break;
	}
	return (hr);
}


//*****************************************************************************
// This version only reads from disk.
//*****************************************************************************
HRESULT StgIO::ReadFromDisk(			// Return code.
	void		*pbBuff,				// Write buffer here.
	ULONG		cbBuff,					// How much to read.
	ULONG		*pcbRead)				// How much read.
{
	ULONG		cbRead;

	_ASSERTE(m_iType == STGIO_HFILE || m_iType == STGIO_STREAM);

	// Need to have a buffer.
	if (!pcbRead)
		pcbRead = &cbRead;

	// Read only from file to avoid recursive logic.
	if (m_iType == STGIO_HFILE || m_iType == STGIO_HFILEMEM)
	{
		if (::ReadFile(m_hFile, pbBuff, cbBuff, pcbRead, 0))
			return (S_OK);
		return (MapFileError(GetLastError()));
	}
	// Read directly from stream.
	else
	{
		return (m_pIStream->Read(pbBuff, cbBuff, pcbRead));
	}
}


//*****************************************************************************
// Copy the contents of the file for this storage to the target path.
//*****************************************************************************
HRESULT StgIO::CopyFileInternal(		// Return code.
	LPCWSTR		szTo,					// Target save path for file.
	int			bFailIfThere,			// true to fail if target exists.
	int			bWriteThrough)			// Should copy be written through OS cache.
{
	DWORD		iCurrent;				// Save original location.
	DWORD		cbRead;					// Byte count for buffer.
	DWORD		cbWrite;				// Check write of bytes.
	BYTE		rgBuff[4096];			// Buffer for copy.
	HANDLE		hFile;					// Target file.
	HRESULT		hr = S_OK;

	// Create target file.
	if ((hFile = ::WszCreateFile(szTo, GENERIC_WRITE, 0, 0, 
			(bFailIfThere) ? CREATE_NEW : CREATE_ALWAYS, 
			(bWriteThrough) ? FILE_FLAG_WRITE_THROUGH : 0, 
			0)) == INVALID_HANDLE_VALUE)
	{
		return (MapFileError(GetLastError()));
	}

	// Save current location and reset it later.
	iCurrent = ::SetFilePointer(m_hFile, 0, 0, FILE_CURRENT);
	::SetFilePointer(m_hFile, 0, 0, FILE_BEGIN);

	// Copy while there are bytes.
	while (::ReadFile(m_hFile, rgBuff, sizeof(rgBuff), &cbRead, 0) && cbRead)
	{
		if (!::WriteFile(hFile, rgBuff, cbRead, &cbWrite, 0) || cbWrite != cbRead)
		{
			hr = STG_E_WRITEFAULT;
			break;
		}
	}

	// Reset file offset.
	::SetFilePointer(m_hFile, iCurrent, 0, FILE_BEGIN);

	// Close target.
	if (!bWriteThrough)
		VERIFY(::FlushFileBuffers(hFile));
	::CloseHandle(hFile);
	return (hr);
}


//*****************************************************************************
// Free the data used for backing store from disk in read/write scenario.
//*****************************************************************************
void StgIO::FreePageMap()
{
	// If a small file was allocated, then free that memory.
	if (m_bFreeMem && m_pBaseData)
		FreeMemory(m_pBaseData);
	// For win32 mmf, close handles and free resources.
	else if (m_hMapping && m_pBaseData)
	{
		VERIFY(UnmapViewOfFile(m_pBaseData));
		VERIFY(CloseHandle(m_hMapping));
	}
	// For our own system, free memory.
	else if (m_rgPageMap && m_pBaseData)
	{
		delete [] m_rgPageMap;
		m_rgPageMap = 0;
		VERIFY(::VirtualFree(m_pBaseData, (((m_cbData - 1) & ~(m_iPageSize - 1)) + m_iPageSize), MEM_DECOMMIT));
		VERIFY(::VirtualFree(m_pBaseData, 0, MEM_RELEASE));
		m_pBaseData = 0;
		m_cbData = 0;	
	}

	m_pBaseData = 0;
	m_hMapping = 0;
	m_cbData = 0;
}


//*****************************************************************************
// Check the given pointer and ensure it is aligned correct.  Return true
// if it is aligned, false if it is not.
//*****************************************************************************
int StgIO::IsAlignedPtr(ULONG Value, int iAlignment)
{
    HRESULT     hr;
	void		*ptrStart;

	if (m_iType == STGIO_STREAM || m_iType == STGIO_MEM || 
				m_iType == STGIO_SHAREDMEM)
	{
		return ((Value - (ULONG) m_pData) % iAlignment == 0);
	}
	else
	{
		hr = GetPtrForMem(0, 1, ptrStart);
		_ASSERTE(hr == S_OK && "GetPtrForMem failed");
		_ASSERTE(Value > (ULONG) ptrStart);
		return (((Value - (ULONG) ptrStart) % iAlignment) == 0);	
	}
} // int StgIO::IsAlignedPtr()





//*****************************************************************************
// These helper functions are used to allocate fairly large pieces of memory,
// more than should be taken from the runtime heap, but less that would require
// virtual memory overhead.
//*****************************************************************************
// #define _TRACE_MEM_ 1

void *AllocateMemory(int iSize)
{
	void * ptr;
	ptr = HeapAlloc(GetProcessHeap(), 0, iSize);

#if defined(_DEBUG) && defined(_TRACE_MEM_)
	static int i=0;
	DbgWriteEx(L"AllocateMemory: (%d) 0x%08x, size %d\n", ++i, ptr, iSize);
#endif
	return (ptr);
}


void FreeMemory(void *pbData)
{
#if defined(_DEBUG) && defined(_TRACE_MEM_)
	static int i=0;
	DbgWriteEx(L"FreeMemory: (%d) 0x%08x\n", ++i, pbData);
#endif

	_ASSERTE(pbData);
	VERIFY(HeapFree(GetProcessHeap(), 0, pbData));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\imptlb.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// File: imptlb.h
// 
// TypeLib importer.
//*****************************************************************************
#ifndef __imptlb_h__
#define __imptlb_h__

extern "C"
HRESULT __stdcall ImportTypeLib(
    LPCWSTR     szLibrary,              // Name of library being imported.
    ITypeLib    *pitlb,                 // The type library to import from.
    REFIID      riid,                   // Interface to return.
    void        **ppObj);               // Return pointer to object here.


//#define TLB_STATS

#define MAX_TLB_VT                  VT_LPWSTR + 1
#define MAX_INIT_SIG                3
#define MAX_COM_GUID_SIG            6
#define MAX_COM_ADDLISTENER_SIG     8
#define MAX_COM_REMOVELISTENER_SIG  8
#define CB_MAX_ELEMENT_TYPE         4

// Forward declarations.
struct ITypeLibImporterNotifySink;
class Assembly;
class Module;
class CImportTlb;

//*****************************************************************************
// Class to perform memory management.  Memory is not moved as the heap is 
//  expanded, and all of the allocations are cleaned up in the destructor.
//*****************************************************************************
class CWCHARPool : public StgPool
{
public:
    CWCHARPool() : StgPool() { InitNew(); }

    // Allocate some bytes from the pool.
    WCHAR * Alloc(ULONG nChars)
    {   
        BYTE *pRslt;
        // Convert from characters to bytes.
        nChars *= sizeof(WCHAR);
        if (nChars > GetCbSegAvailable())
            if (!Grow(nChars))
                return 0;
        pRslt = GetNextLocation();
        SegAllocate(nChars);
        return (WCHAR*)pRslt;
    }
}; // class CDescPool : public StgPool


//*****************************************************************************
// This helper method is used to track an url to typeref token.  This makes
// defining new typerefs faster.
//*****************************************************************************
class CImpTlbTypeRef
{
public:
    CImpTlbTypeRef() { }
    ~CImpTlbTypeRef() { m_Map.Clear(); }

    //*****************************************************************************
    // Look for an existing typeref in the map and return if found.  If not found,
    // then create a new one and add it to the map for later.
    //*****************************************************************************
    HRESULT DefineTypeRef(                  // S_OK or error.
        IMetaDataEmit *pEmit,               // Emit interface.
        mdAssemblyRef ar,                   // Containing assembly.
        const LPCWSTR szURL,                // URL of the TypeDef, wide chars.
        mdTypeRef   *ptr);                  // Put mdTypeRef here

    class TokenOfTypeRefHashKey
    {
    public:
        mdToken     tkResolutionScope;      // TypeRef's resolution scope.
        LPCWSTR     szName;                 // TypeRef's name.
        mdTypeRef   tr;                     // The TypeRef's token.
    };

private:

    class CTokenOfTypeRefHash : public CClosedHash<class TokenOfTypeRefHashKey>
    {
    public:
        typedef CClosedHash<class TokenOfTypeRefHashKey> Super;
        typedef TokenOfTypeRefHashKey T;

        CTokenOfTypeRefHash() : CClosedHash<class TokenOfTypeRefHashKey>(101) {}
        ~CTokenOfTypeRefHash() { Clear(); }

        virtual void Clear();
        
        unsigned long Hash(const void *pData) {return Hash((const T*)pData);}
        unsigned long Hash(const T *pData);

        unsigned long Compare(const void *p1, BYTE *p2) {return Compare((const T*)p1, (T*)p2);}
        unsigned long Compare(const T *p1, T *p2);

        ELEMENTSTATUS Status(BYTE *p) {return Status((T*)p);}
        ELEMENTSTATUS Status(T *p);

        void SetStatus(BYTE *p, ELEMENTSTATUS s) {SetStatus((T*)p, s);}
        void SetStatus(T *p, ELEMENTSTATUS s);

        void* GetKey(BYTE *p) {return GetKey((T*)p);}
        void *GetKey(T *p);
        
        T* Add(const T *pData);
        
        CWCHARPool          m_Names;        // Heap of names.
    };

    CTokenOfTypeRefHash m_Map;          // Map of namespace to token.
};


//*****************************************************************************
// This helper class is used to track source interface ITypeInfo*'s to event 
// information.
//*****************************************************************************
class ImpTlbEventInfo
{
public:
    LPCWSTR     szSrcItfName;           // The source interface name (the key).
    mdTypeRef   trEventItf;             // The event interface typedef.
    LPCWSTR     szEventItfName;         // The event interface name.
    LPCWSTR     szEventProviderName;    // The event provider name.
    Assembly*   SrcItfAssembly;         // The assembly where source interface resides.
};

class CImpTlbEventInfoMap : protected CClosedHash<class ImpTlbEventInfo>
{
public:
    typedef CClosedHash<class ImpTlbEventInfo> Super;
    typedef ImpTlbEventInfo T;

    CImpTlbEventInfoMap() : CClosedHash<class ImpTlbEventInfo>(101) {}
    ~CImpTlbEventInfoMap() { Clear(); }

    HRESULT AddEventInfo(LPCWSTR szSrcItfName, mdTypeRef trEventItf, LPCWSTR szEventItfName, LPCWSTR szEventProviderName, Assembly* SrcItfAssembly);
    ImpTlbEventInfo *FindEventInfo(LPCWSTR szSrcItfName);

    HRESULT GetEventInfoList(CQuickArray<ImpTlbEventInfo*> &qbEvInfoList);

private:
    unsigned long Hash(const void *pData) {return Hash((const T*)pData);}
    unsigned long Hash(const T *pData);

    unsigned long Compare(const void *p1, BYTE *p2) {return Compare((const T*)p1, (T*)p2);}
    unsigned long Compare(const T *p1, T *p2);

    ELEMENTSTATUS Status(BYTE *p) {return Status((T*)p);}
    ELEMENTSTATUS Status(T *p);

    void SetStatus(BYTE *p, ELEMENTSTATUS s) {SetStatus((T*)p, s);}
    void SetStatus(T *p, ELEMENTSTATUS s);

    void* GetKey(BYTE *p) {return GetKey((T*)p);}
    void *GetKey(T *p);
    
    T* Add(const T *pData);
    
    CWCHARPool          m_Names;        // Heap of names.
};

class CImpTlbReservedNames
{
public:
    CImpTlbReservedNames() {}
    ~CImpTlbReservedNames() {/*m_StringMap.Clear();*/}

    HRESULT Init() {return m_StringMap.NewInit();}

    void AddReservedName(LPCWSTR szName) {BOOL flag = TRUE; m_StringMap.AddItem(szName, flag);}
    BOOL IsReservedName(LPCWSTR szName) {return m_StringMap.GetItem(szName) != 0;}

private:
    TStringMap<BOOL>    m_StringMap;
};


//*****************************************************************************
// Helper class to keep track of the mappings from default interfaces to 
// class interfaces.
//*****************************************************************************
class ImpTlbClassItfInfo
{
public:
    IID         ItfIID;                 // The IID of the interface.
    LPCWSTR     szClassItfName;         // The class interface name.
};

class CImpTlbDefItfToClassItfMap : protected CClosedHash<class ImpTlbClassItfInfo>
{
public:
    typedef CClosedHash<class ImpTlbClassItfInfo> Super;
    typedef ImpTlbClassItfInfo T;

    CImpTlbDefItfToClassItfMap();
    ~CImpTlbDefItfToClassItfMap();

    HRESULT Init(ITypeLib *pTlb, BSTR bstrNameSpace);

    LPCWSTR GetClassItfName(IID &rItfIID);

private:
    HRESULT AddCoClassInterfaces(ITypeInfo *pCoClassITI, TYPEATTR *pCoClassTypeAttr);

    unsigned long Hash(const void *pData) {return Hash((const T*)pData);}
    unsigned long Hash(const T *pData);

    unsigned long Compare(const void *p1, BYTE *p2) {return Compare((const T*)p1, (T*)p2);}
    unsigned long Compare(const T *p1, T *p2);

    ELEMENTSTATUS Status(BYTE *p) {return Status((T*)p);}
    ELEMENTSTATUS Status(T *p);

    void SetStatus(BYTE *p, ELEMENTSTATUS s) {SetStatus((T*)p, s);}
    void SetStatus(T *p, ELEMENTSTATUS s);

    void* GetKey(BYTE *p) {return GetKey((T*)p);}
    void *GetKey(T *p);
    
    T* Add(const T *pData);
    
    CWCHARPool          m_Names;            // Heap of names.
    BSTR                m_bstrNameSpace;    // Namespace of the typelib.
};


//*****************************************************************************
// Helper class to keep track of imported typelibs.  Typically, a typelib
//  imports only 2 or 3 other typelibs, so a simple array is used.
//*****************************************************************************
struct CTlbRef
{
    GUID            guid;               // GUID of referenced typelib.
    mdAssemblyRef   ar;                 // AssemblyRef for the module containing reference.
    BSTR            szNameSpace;        // The namespace of the types contained in the assembly.
    BSTR            szAsmName;          // The assembly name.
    Assembly*       Asm;                // The assembly;
    CImpTlbDefItfToClassItfMap *pDefItfToClassItfMap; // The default interface to class interface map.

    ~CTlbRef() 
    {
        SysFreeString(szNameSpace); 
        SysFreeString(szAsmName);
        delete pDefItfToClassItfMap;
    }
};

class CImpTlbLibRef : public CQuickArray<CTlbRef>
{
    typedef CQuickArray<CTlbRef> base;
public:
    CImpTlbLibRef() {base::ReSize(0);}
    ~CImpTlbLibRef();

    CImpTlbDefItfToClassItfMap *Add(ITypeLib *pITLB, CImportTlb  *pImporter, mdAssemblyRef ar, BSTR wzNamespace, BSTR wzAsmName, Assembly* assm);
    int Find(ITypeLib *pITLB, mdAssemblyRef *par, BSTR *pwzNamespace, BSTR *pwzAsmName, Assembly** assm, CImpTlbDefItfToClassItfMap **ppDefItfToClassItfMap);
};


class CImportTlb
{
public:
    static CImportTlb* CreateImporter(LPCWSTR szLibrary, ITypeLib *pitlb, BOOL bGenerateTCEAdapters, BOOL bUnsafeInterfaces, BOOL bSafeArrayAsSystemArray, BOOL bTransformDispRetVals);
    
    CImportTlb();
    CImportTlb(LPCWSTR szLibrary, ITypeLib *pitlb, BOOL bGenerateTCEAdapters, BOOL bUnsafeInterfaces, BOOL bSafeArrayAsSystemArray, BOOL bTransformDispRetVals);
    ~CImportTlb();

    HRESULT Import();
    HRESULT ImportTypeLib(ITypeLib *pITLB);
    HRESULT ImportTypeInfo(ITypeInfo *pITI, mdTypeDef *pCl);
    HRESULT GetInterface(REFIID riid, void ** pp);
    HRESULT SetNamespace(WCHAR const *pNamespace);
    WCHAR *GetNamespace() {return m_wzNamespace;}
    HRESULT SetNotification(ITypeLibImporterNotifySink *pINotify);
    HRESULT SetMetaData(IUnknown *pIUnk);
    void    SetAssembly(Assembly *pAssembly) {m_pAssembly = pAssembly;}
    void    SetModule(Module *pModule) {m_pModule = pModule;}
    HRESULT GetNamespaceOfRefTlb(ITypeLib *pITLB, BSTR *pwzNamespace, CImpTlbDefItfToClassItfMap **ppDefItfToClassItfMap);
    HRESULT GetEventInfoList(CQuickArray<ImpTlbEventInfo*> &qbEvInfoList) {return m_EventInfoMap.GetEventInfoList(qbEvInfoList);}

    static HRESULT GetDefaultInterface(ITypeInfo *pCoClassTI, ITypeInfo **pDefaultItfTI);

protected:
    
    struct MemberInfo
    {
        union 
        {
            FUNCDESC    *m_psFunc;      // Pointer to FuncDesc.
            VARDESC     *m_psVar;       // Pointer to VarDesc.
        };
        LPWSTR      m_pName;            // Function/Prop's name, possibly decorated.
        int         m_iMember;          // The index of the member in the ITypeInfo.
        union
        {
            LPWSTR      m_pName2;       // Prop's second name, if any.
            mdToken     m_mdFunc;       // Function's token & semantics, if not property.
            USHORT      m_msSemantics;  // Semantics only.
        };
        void SetFuncInfo(mdMethodDef mdFunc, USHORT msSemantics) {m_mdFunc = RidFromToken(mdFunc) | (msSemantics<<24);}
        void GetFuncInfo(mdMethodDef &mdFunc, USHORT &msSemantics) {mdFunc = m_mdFunc&0xffffff | mdtMethodDef; msSemantics = m_mdFunc>>24;}
    };

    
    HRESULT ConvertTypeLib();
    HRESULT ConvertTypeInfo();

    HRESULT ExplicitlyImplementsIEnumerable(ITypeInfo *pITI, TYPEATTR *psAttr, BOOL fLookupPartner = TRUE);

    HRESULT _NewLibraryObject();
    HRESULT ConvCoclass(ITypeInfo *pITI, TYPEATTR *psAttr);
    HRESULT ConvEnum(ITypeInfo *pITI, TYPEATTR *psAttr);
    HRESULT ConvRecord(ITypeInfo *pITI, TYPEATTR *psAttr, BOOL bUnion);
    HRESULT ConvIface(ITypeInfo *pITI, TYPEATTR *psAttr, BOOL bVtblGaps=true);
    HRESULT ConvDispatch(ITypeInfo *pITI, TYPEATTR *psAttr, BOOL bVtblGaps=true);
    HRESULT ConvModule(ITypeInfo *pITI, TYPEATTR *psAttr);

    HRESULT IsIUnknownDerived(ITypeInfo *pITI, TYPEATTR *psAttr);
    HRESULT IsIDispatchDerived(ITypeInfo *pITI, TYPEATTR *psAttr);
    HRESULT HasNewEnumMember(ITypeInfo *pItfTI);
    HRESULT FuncIsNewEnum(ITypeInfo *pITI, FUNCDESC *pFuncDesc, DWORD index);
    HRESULT PropertyIsNewEnum(ITypeInfo *pITI, VARDESC *pVarDesc, DWORD index);

    HRESULT HasObjectFields(ITypeInfo *pITI, TYPEATTR *psAttr);
    HRESULT IsObjectType(ITypeInfo *pITI, const TYPEDESC *pType);
    HRESULT CompareSigsIgnoringRetType(PCCOR_SIGNATURE pbSig1, ULONG cbSig1, PCCOR_SIGNATURE pbSig2, ULONG cbSig2);

    HRESULT FindMethod(mdTypeDef td, LPCWSTR szName, PCCOR_SIGNATURE pbSig, ULONG cbSig, mdMethodDef *pmb);
    HRESULT FindProperty(mdTypeDef td, LPCWSTR szName, PCCOR_SIGNATURE pSig, ULONG cbSig, mdProperty *pPr);
    HRESULT FindEvent(mdTypeDef td, LPCWSTR szName, mdProperty *pEv);   

    HRESULT ReportEvent(int ev, int hr, ...);
    
    HRESULT _DefineSysRefs();
    HRESULT _GetNamespaceName(ITypeLib *pITLB, BSTR *pwzNamespace);
    HRESULT _GetTokenForTypeInfo(ITypeInfo *pITI, BOOL bConvDefItfToClassItf, mdToken *pToken, LPWSTR pszTypeRef=0, int chTypeRef=0, int *pchTypeRef=0, BOOL bAsmQualifiedName = FALSE);

    HRESULT _FindFirstUserMethod(ITypeInfo *pITI, TYPEATTR *psAttr, int *pIx);
    HRESULT _ResolveTypeDescAliasTypeKind(ITypeInfo *pITIAlias, TYPEDESC *ptdesc, TYPEKIND *ptkind);
    HRESULT _ResolveTypeDescAlias(ITypeInfo *pITIAlias, const TYPEDESC *ptdesc, ITypeInfo **ppTIResolved, TYPEATTR **ppsAttrResolved, GUID *pGuid=0);

    HRESULT _SetHiddenCA(mdTypeDef token);
    HRESULT _ForceIEnumerableCVExists(ITypeInfo* pITI, BOOL* CVExists);
    HRESULT _SetDispIDCA(ITypeInfo* pITI, int iMember, long lDispId, mdToken func, BOOL fAlwaysAdd, long* lDispSet, BOOL bFunc);
    HRESULT _GetDispIDCA(ITypeInfo* pITI, int iMember, long* lDispSet, BOOL bFunc);
    HRESULT _CheckForPropertyCustomAttributes(ITypeInfo* pITI, int index, INVOKEKIND* ikind);

    HRESULT _ConvIfaceMembers(ITypeInfo *pITI, TYPEATTR *psAttr, BOOL bVtblGaps, BOOL bAddDispIds, BOOL bInheritsIEnum);
    HRESULT _ConvSrcIfaceMembers(ITypeInfo   *pITI, TYPEATTR* psAttr, BOOL fInheritsIEnum);
    HRESULT _ConvDispatchMembers(ITypeInfo *pITI, TYPEATTR *psAttr, BOOL fInheritsIEnum);
    HRESULT _GetFunctionPropertyInfo(FUNCDESC *psFunc, USHORT *pSemantics, FUNCDESC **ppSig, TYPEDESC **ppProperty, BOOL *pbRetval);
    HRESULT _ConvFunction(ITypeInfo *pITI, MemberInfo *pMember, int bVtblGapFuncs, BOOL bAddDispIds, BOOL bDelegateInvokeMeth, BOOL* bAllowIEnum);
    HRESULT _GenerateEvent(ITypeInfo *pITI, MemberInfo  *pMember, BOOL fInheritsIEnum);
    HRESULT _GenerateEventDelegate(ITypeInfo *pITI, MemberInfo  *pMember, mdTypeDef *ptd, BOOL fInheritsIEnum);
    HRESULT _AddSrcItfMembersToClass(mdTypeRef trSrcItf);

    HRESULT _ConvPropertiesForFunctions(ITypeInfo *pITI, TYPEATTR *psAttr);
    enum ParamOpts{ParamNormal=0, ParamOptional, ParamVarArg};
    HRESULT _ConvParam(ITypeInfo *pITI, mdMethodDef mbFunc, int iSequence, const ELEMDESC *pdesc, ParamOpts paramOpts, const WCHAR *pszName, BYTE *pbNative, ULONG cbNative);
    HRESULT _ConvConstant(ITypeInfo *pITI, VARDESC *psVar, BOOL bEnumMember=false);
    HRESULT _ConvField(ITypeInfo *pITI, VARDESC *psVar, mdFieldDef *pmdField, BOOL bUnion);
    HRESULT _ConvProperty(ITypeInfo *pITI, MemberInfo *pMember);
    HRESULT _ConvNewEnumProperty(ITypeInfo *pITI, VARDESC *psVar, MemberInfo *pMember);

    HRESULT _HandleAliasInfo(ITypeInfo *pITI, TYPEDESC *pTypeDesc, mdToken tk);

    HRESULT _AddTlbRef(ITypeLib *pITLB, mdAssemblyRef *par, BSTR *pwzNamespace, BSTR *pwzAsmName, CImpTlbDefItfToClassItfMap **ppDefItfToClassItfMap);

    HRESULT _AddGuidCa(mdToken tkObj, REFGUID guid);
    HRESULT _AddDefaultMemberCa(mdToken tkObj, LPCWSTR szName);

    HRESULT _AddStringCa(int attr, mdToken tk, LPCWSTR wzString);

    HRESULT GetKnownTypeToken(VARTYPE vt, mdTypeRef *ptr);

    HRESULT _GetTokenForEventItf(ITypeInfo *pSrcItfITI, mdTypeDef *ptr);
    HRESULT _CreateClassInterface(ITypeInfo *pCoClassITI, ITypeInfo *pDefItfITI, mdTypeRef trDefItf, mdTypeRef rtDefEvItf, mdToken *ptr);

    HRESULT GetManagedNameForCoClass(ITypeInfo *pITI, CQuickArray<WCHAR> &qbClassName);
    HRESULT GenerateUniqueTypeName(CQuickArray<WCHAR> &qbTypeName);
    HRESULT GenerateUniqueMemberName(CQuickArray<WCHAR> &qbMemberName, PCCOR_SIGNATURE pSig, ULONG SigSize, LPCWSTR szPrefix, mdToken type);
    HRESULT _IsAlias(ITypeInfo *pITI, TYPEDESC *pTypeDesc);

    HRESULT GetDefMemberName(ITypeInfo *pITI, BOOL bItfQualified, CQuickArray<WCHAR> &qbDefMemberName);

    enum SigFlags {
        // These match the typelib values
        SIG_IN          = 0x0001,           // Input param.
        SIG_OUT         = 0x0002,           // Output param.
        SIG_RET         = 0x0008,           // Retval.  Currently unused.
        SIG_OPT         = 0x0010,           // Optional param.  Currently unused.
        SIG_FLAGS_MASK  = 0x001b,           // Mask of flags from TypeLib PARAMFLAGs

        SIG_FUNC        = 0x0100,           // Convert signature for function.
        SIG_FIELD       = 0x0200,           // Convert signature for field.
        SIG_ELEM        = 0x0300,           // Convert signature for sub element (eg, array of X).
        SIG_TYPE_MASK   = 0x0300,

        SIG_USE_BYREF   = 0x1000,           // If set convert one ptr as E_T_BYREF.
        SIG_VARARG      = 0x4000,           // If set, this is a paramarray type.  Use szArray, not System.Array.

        SIG_FLAGS_NONE  = 0                 // '0' of this enum type.
    };    

    #define IsSigIn(flags)              ((flags & SIG_IN) == SIG_IN)
    #define IsSigOut(flags)             ((flags & SIG_OUT) == SIG_OUT)
    #define IsSigRet(flags)             ((flags & SIG_RET) == SIG_RET)
    #define IsSigOpt(flags)             ((flags & SIG_OPT) == SIG_OPT)
    #define IsSigOutRet(flags)          ((flags & (SIG_OUT|SIG_RET)) == (SIG_OUT|SIG_RET))

    #define IsSigFunc(flags)            ((flags & SIG_TYPE_MASK) == SIG_FUNC)
    #define IsSigField(flags)           ((flags & SIG_TYPE_MASK) == SIG_FIELD)
    #define IsSigElem(flags)            ((flags & SIG_TYPE_MASK) == SIG_ELEM)
    
    #define IsSigUseByref(flags)        ((flags & SIG_USE_BYREF) == SIG_USE_BYREF)
    #define IsSigVarArg(flags)          ((flags & SIG_VARARG) == SIG_VARARG)

    HRESULT _ConvSignature(ITypeInfo *pITI, const TYPEDESC *pType, ULONG Flags, CQuickBytes &qbSigBuf, ULONG cbSig, ULONG *pcbSig, CQuickArray<BYTE> &qbNativeTypeBuf, ULONG cbNativeType, ULONG *pcbNativeType, BOOL bNewEnumMember, int iByRef=0);

    // For handling out-of-order vtables.
    CQuickArray<MemberInfo> m_MemberList;
    CWCHARPool              *m_pMemberNames;
    int                     m_cMemberProps;       // Count of props in memberlist.
    HRESULT BuildMemberList(ITypeInfo *pITI, int iStart, int iEnd, BOOL bInheritsIEnum);
    HRESULT FreeMemberList(ITypeInfo *pITI);

    // List of predefined token types for custom attributes.
#define INTEROP_ATTRIBUTES()                            \
        INTEROP_ATTRIBUTE(DISPID)                       \
        INTEROP_ATTRIBUTE(CLASSINTERFACE)               \
        INTEROP_ATTRIBUTE(INTERFACETYPE)                \
        INTEROP_ATTRIBUTE(TYPELIBTYPE)                  \
        INTEROP_ATTRIBUTE(TYPELIBVAR)                   \
        INTEROP_ATTRIBUTE(TYPELIBFUNC)                  \
        INTEROP_ATTRIBUTE(COMSOURCEINTERFACES)          \
        INTEROP_ATTRIBUTE(COMCONVERSIONLOSS)            \
        INTEROP_ATTRIBUTE(GUID)                         \
        INTEROP_ATTRIBUTE(DEFAULTMEMBER)                \
        INTEROP_ATTRIBUTE(COMALIASNAME)                 \
        INTEROP_ATTRIBUTE(PARAMARRAY)                   \
        INTEROP_ATTRIBUTE(LCIDCONVERSION)               \
        INTEROP_ATTRIBUTE(DECIMALVALUE)                 \
        INTEROP_ATTRIBUTE(DATETIMEVALUE)                \
        INTEROP_ATTRIBUTE(IUNKNOWNVALUE)                \
        INTEROP_ATTRIBUTE(IDISPATCHVALUE)               \
        INTEROP_ATTRIBUTE(COMVISIBLE)                   \
        INTEROP_ATTRIBUTE_SPECIAL(COMEVENTINTERFACE)    \
        INTEROP_ATTRIBUTE_SPECIAL(COCLASS)              \

#define INTEROP_ATTRIBUTE(x) ATTR_##x,
#define INTEROP_ATTRIBUTE_SPECIAL(x) ATTR_##x,
    enum {INTEROP_ATTRIBUTES()
          // Last value gives array size.
          ATTR_COUNT};
#undef INTEROP_ATTRIBUTE
#undef INTEROP_ATTRIBUTE_SPECIAL

    mdToken             m_tkAttr[ATTR_COUNT];
    HRESULT GetAttrType(int attr, mdToken *ptk);

    // look up table for known type
    mdTypeRef           m_tkKnownTypes[MAX_TLB_VT];

    LPCWSTR             m_szLibrary;    // Name of typelib being imported.
    BOOL                m_bGenerateTCEAdapters;     // A flag indicating if the TCE adapters are being generated or not.
    BOOL                m_bUnsafeInterfaces;        // A flag indicating whether runtime security checks should be disabled on an interface
    BOOL                m_bSafeArrayAsSystemArray;  // A flag indicating whether to import SAFEARRAY's as System.Array's.
    BOOL                m_bTransformDispRetVals;     // A flag indicating if we should do [out,retval] transformation on disp only itfs.
    mdMemberRef         m_tkSuppressCheckAttr;      // Cached ctor for security check custom attribute
    ITypeLib            *m_pITLB;       // Typelib being imported.
    IMetaDataEmit       *m_pEmit;       // Emit API Interface pointer.
    IMetaDataImport     *m_pImport;     // Import API Interface pointer.

    BSTR                m_wzNamespace;  // Namespace of the created TypeDefs.
    mdTypeRef           m_trObject;     // Token of System.Object.
    mdTypeRef           m_trValueType;  // Token of System.ValueType.
    mdTypeRef           m_trEnum;       // Token of System.Enum.
    mdAssemblyRef       m_arSystem;     // AssemblyRef for classlib.

    ITypeInfo           *m_pITI;        // "Current" ITypeInfo being converted.
    TYPEATTR            *m_psAttr;      // "TYPEATTR" of current ITypeInfo.
    BSTR                m_szName;       // Name of current ITypeInfo.
    BSTR                m_szMember;     // Name of current Member (method or field).
    LPWSTR              m_szMngName;    // Full name of the managed type.
    
    ULONG               m_Slot;         // "Current" vtbl index within an interface.

    void                *m_psClass;     // "Current" class record. 
    mdTypeDef           m_tdTypeDef;    // Current TypeDef.
    mdTypeDef           m_tdHasDefault; // Most recent TypeDef with a default.
    enum {eImplIfaceNone, eImplIfaceDefault, eImplIface} m_ImplIface;
    mdToken             m_tkInterface;  // Interface being added to a coclass.
    BSTR                m_szInterface;  // Interface name for decoration.

    CImpTlbTypeRef      m_TRMap;        // Typeref map.
    CImpTlbLibRef       m_LibRefs;      // Referenced typelibs.
    CImpTlbDefItfToClassItfMap m_DefItfToClassItfMap; // The default interface to class interface map.
    
    CImpTlbReservedNames m_ReservedNames;    // Reserved names.
    CImpTlbEventInfoMap  m_EventInfoMap;     // Map of event info's.

    ITypeLibImporterNotifySink *m_Notify;    // Notification object.
    Assembly            *m_pAssembly;   // Containing assembly.
    Module              *m_pModule;     // Module we are emiting into.
    
#if defined(TLB_STATS)
    LARGE_INTEGER       m_freqVal;      // Frequency of perf counter.
    BOOL                m_bStats;       // If true, collect timings.
#endif // TLB_STATS
};



#endif

//-eof-************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\liteweightstgdb.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// LiteWeightStgdb.h
//
// This contains definition of class CLiteWeightStgDB. This is light weight
// read-only implementation for accessing compressed meta data format.
//
//*****************************************************************************
#ifndef __LiteWeightStgdb_h__
#define __LiteWeightStgdb_h__

#include "MetaModelRO.h"
#include "MetaModelRW.h"

#include "StgTiggerStorage.h"
class StgIO;
enum FILETYPE;
class TiggerStorage;

//*****************************************************************************
// This class provides common definitions for heap segments.  It is both the
//  base class for the heap, and the class for heap extensions (additional
//  memory that must be allocated to grow the heap).
//*****************************************************************************
template <class MiniMd>
class CLiteWeightStgdb
{
public:
	CLiteWeightStgdb() : m_pvMd(NULL), m_cbMd(0)
	{}

	~CLiteWeightStgdb() 
	{ Uninit(); }

	// open an in-memory metadata section for read.
	HRESULT InitOnMem(	
		ULONG cbData,
		LPCVOID pbData);

	void Uninit();

protected:
	MiniMd		m_MiniMd;				// embedded compress meta data schemas definition
	const void	*m_pvMd;				// Pointer to meta data.
	ULONG		m_cbMd;					// Size of the meta data.

	friend class CorMetaDataScope;
	friend class COR;
	friend class RegMeta;
	friend class MERGER;
    friend class NEWMERGER;
	friend class MDInternalRO;
	friend class MDInternalRW;
};

//*****************************************************************************
// Open an in-memory metadata section for read
//*****************************************************************************
template <class MiniMd>
void CLiteWeightStgdb<MiniMd>::Uninit()
{
	m_MiniMd.m_Strings.Uninit();
	m_MiniMd.m_USBlobs.Uninit();
	m_MiniMd.m_Guids.Uninit();
	m_MiniMd.m_Blobs.Uninit();
	m_pvMd = NULL;
	m_cbMd = 0;
}


class CLiteWeightStgdbRW : public CLiteWeightStgdb<CMiniMdRW>
{
	friend class CImportTlb;
    friend class RegMeta;
public:
	CLiteWeightStgdbRW() : m_pStgIO(NULL), m_pStreamList(0), m_cbSaveSize(0), m_pNextStgdb(NULL)
	{ *m_rcDatabase= 0; m_pImage = NULL; m_dwImageSize = 0; }
	~CLiteWeightStgdbRW();

	HRESULT InitNew();

	// open an in-memory metadata section for read.
	HRESULT InitOnMem(	
		ULONG cbData,
		LPCVOID pbData,
		int		bReadOnly);

	HRESULT GetSaveSize(
		CorSaveSize	fSize,
		ULONG		*pulSaveSize);

	HRESULT SaveToStream(
		IStream		*pIStream);				// Stream to which to write
	
	HRESULT Save(
		LPCWSTR		szFile, 
		DWORD		dwSaveFlags);

	// Open a metadata section for read/write
	HRESULT OpenForRead(
		LPCWSTR 	szDatabase, 			// Name of database.
		void		*pbData,				// Data to open on top of, 0 default.
		ULONG		cbData, 				// How big is the data.
		IStream 	*pIStream,				// Optional stream to use.
		LPCWSTR 	szSharedMem,			// Shared memory name for read.
		int			bReadOnly);

#if 0
	HRESULT Open(
		LPCWSTR     szDatabase,             // Name of database.
	    ULONG       fFlags,                 // Flags to use on init.
		void        *pbData,                // Data to open on top of, 0 default.
		ULONG       cbData,                 // How big is the data.
		IStream     *pIStream);             // Optional stream to use.

	HRESULT	InitClbFile(
		ULONG		fFlags,
		StgIO		*pStgIO);
#endif

	ULONG		m_cbSaveSize;				// Size of the saved streams.
	int			m_bSaveCompressed;			// If true, save as compressed stream (#-, not #~)
	VOID*		m_pImage;					// Set in OpenForRead, NULL for anything but PE files
    DWORD       m_dwImageSize;              // On-disk size of image
protected:

	HRESULT CLiteWeightStgdbRW::GetPoolSaveSize(
		LPCWSTR     szHeap,                 // Name of the heap stream.
		int			iPool,					// The pool whose size to get.
		ULONG       *pcbSaveSize);           // Add pool data to this value.
	HRESULT CLiteWeightStgdbRW::GetTablesSaveSize(
		CorSaveSize fSave,
		ULONG       *pcbSaveSize);          // Add pool data to this value.
	HRESULT CLiteWeightStgdbRW::AddStreamToList(
		ULONG		cbSize,					// Size of the stream data.
		LPCWSTR		szName);				// Name of the stream.

	HRESULT SaveToStorage(TiggerStorage *pStorage);
	HRESULT SavePool(LPCWSTR szName, TiggerStorage *pStorage, int iPool);

	STORAGESTREAMLST *m_pStreamList;
	
	HRESULT InitFileForRead(			
		StgIO       *pStgIO,			// For file i/o.
		int			bReadOnly=true);	// If read-only.

    CLiteWeightStgdbRW *m_pNextStgdb;

public:
	FORCEINLINE FILETYPE GetFileType() { return m_eFileType; }

private:
	FILETYPE	m_eFileType;
	WCHAR		m_rcDatabase[_MAX_PATH];// Name of this database.
    StgIO       *m_pStgIO;		        // For file i/o.
};

#endif // __LiteWeightStgdb_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\mdlog.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDLog.h - Meta data logging helper.
//
//*****************************************************************************
#ifndef __MDLog_h__
#define __MDLog_h__

#ifdef _DEBUG
#define LOGGING
#endif

#include <log.h>

#define LOGMD LF_METADATA, LL_INFO10000
#define LOG_MDCALL(func) LOG((LF_METADATA, LL_INFO10000, "MD: %s\n", #func))

#define MDSTR(str) ((str) ? str : L"<null>")
#define MDSTRA(str) ((str) ? str : "<null>")

#endif // __MDLog_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\mdfileformat.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDFileFormat.h
//
// This file contains a set of helpers to verify and read the file format.
// This code does not handle the paging of the data, or different types of
// I/O.  See the StgTiggerStorage and StgIO code for this level of support.
//
//*****************************************************************************
#ifndef __MDFileFormat_h__
#define __MDFileFormat_h__

//*****************************************************************************
// The signature ULONG is the first 4 bytes of the file format.  The second
// signature string starts the header containing the stream list.  It is used
// for an integrity check when reading the header in lieu of a more complicated
// system.
//*****************************************************************************
#define STORAGE_MAGIC_SIG   0x424A5342  // BSJB



//*****************************************************************************
// These values get written to the signature at the front of the file.  Changing
// these values should not be done lightly because all old files will no longer
// be supported.  In a future revision if a format change is required, a
// backwards compatible migration path must be provided.
//*****************************************************************************

#define FILE_VER_MAJOR  1
#define FILE_VER_MINOR  1

// These are the last legitimate 0.x version macros.  The file format has 
// sinced move up to 1.x (see macros above).  After COM+ 1.0/NT 5 RTM's, these
// macros should no longer be required or ever seen.
#define FILE_VER_MAJOR_v0   0

#ifdef COMPLUS98
#define FILE_VER_MINOR_v0   17
#else
#define FILE_VER_MINOR_v0   19
#endif


#define MAXSTREAMNAME   32

enum
{
    STGHDR_NORMAL           = 0x00,     // Normal default flags.
    STGHDR_EXTRADATA        = 0x01,     // Additional data exists after header.
};


//*****************************************************************************
// This is the formal signature area at the front of the file. This structure
// is not allowed to change, the shim depends on it staying the same size.
// Use the reserved pointer if it must extended.
//*****************************************************************************
struct STORAGESIGNATURE
{
    ULONG       lSignature;             // "Magic" signature.
    USHORT      iMajorVer;              // Major file version.
    USHORT      iMinorVer;              // Minor file version.
    ULONG       iExtraData;             // Offset to next structure of information 
    ULONG       iVersionString;         // Length of version string
    BYTE        pVersion[0];            // Version string
};


//*****************************************************************************
// The header of the storage format.
//*****************************************************************************
struct STORAGEHEADER
{
    BYTE        fFlags;                 // STGHDR_xxx flags.
    BYTE        pad;
    USHORT      iStreams;               // How many streams are there.
};


//*****************************************************************************
// Each stream is described by this struct, which includes the offset and size
// of the data.  The name is stored in ANSI null terminated.
//*****************************************************************************
struct STORAGESTREAM
{
    ULONG       iOffset;                // Offset in file for this stream.
    ULONG       iSize;                  // Size of the file.
    char        rcName[MAXSTREAMNAME];  // Start of name, null terminated.

    inline STORAGESTREAM *NextStream()
    {
        int         iLen = (int)(strlen(rcName) + 1);
        iLen = ALIGN4BYTE(iLen);
		return ((STORAGESTREAM *) ((size_t) this + (sizeof(ULONG) * 2) + iLen));
    }

    inline ULONG GetStreamSize()
    {
        return (ULONG)(strlen(rcName) + 1 + (sizeof(STORAGESTREAM) - sizeof(rcName)));
    }

    inline LPCWSTR GetName(LPWSTR szName, int iMaxSize)
    {
        VERIFY(::WszMultiByteToWideChar(CP_ACP, 0, rcName, -1, szName, iMaxSize));
        return (szName);
    }
};


class MDFormat
{
public:
//*****************************************************************************
// Verify the signature at the front of the file to see what type it is.
//*****************************************************************************
    static HRESULT VerifySignature(
        STORAGESIGNATURE *pSig,         // The signature to check.
        ULONG             cbData);      // Size of metadata.

//*****************************************************************************
// Skip over the header and find the actual stream data.
//*****************************************************************************
    static STORAGESTREAM *MDFormat::GetFirstStream(// Return pointer to the first stream.
        STORAGEHEADER *pHeader,             // Return copy of header struct.
        const void *pvMd);                  // Pointer to the full file.

};

#endif // __MDFileFormat_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\mdinternalrw.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDInternalRW.h
//
// Contains utility code for MD directory
//
//*****************************************************************************
#ifndef __MDInternalRW__h__
#define __MDInternalRW__h__

#include "..\inc\mdlog.h"

class UTSemReadWrite;

class MDInternalRW : public IMDInternalImportENC
{
public:


    MDInternalRW();
    ~MDInternalRW();
    HRESULT Init(LPVOID pData, ULONG cbData, int bReadOnly);
    HRESULT InitWithStgdb(IUnknown *pUnk, CLiteWeightStgdbRW *pStgdb);
    HRESULT InitWithRO(MDInternalRO *pRO, int bReadOnly);

    // *** IUnknown methods ***
    STDMETHODIMP    QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef(void); 
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP TranslateSigWithScope(
        IMDInternalImport *pAssemImport,    // [IN] import assembly scope.
        const void  *pbHashValue,           // [IN] hash value for the import assembly.
        ULONG       cbHashValue,            // [IN] count of bytes in the hash value.
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] assembly emit scope.
        IMetaDataEmit *emit,                // [IN] emit interface
        CQuickBytes *pqkSigEmit,            // [OUT] buffer to hold translated signature
        ULONG       *pcbSig);               // [OUT] count of bytes in the translated signature

    STDMETHODIMP_(IMetaModelCommon*) GetMetaModelCommon()
    {
        return static_cast<IMetaModelCommon*>(&m_pStgdb->m_MiniMd);
    }

    //*****************************************************************************
    // return the count of entries of a given kind in a scope 
    // For example, pass in mdtMethodDef will tell you how many MethodDef 
    // contained in a scope
    //*****************************************************************************
    STDMETHODIMP_(ULONG) GetCountWithTokenKind(// return hresult
        DWORD       tkKind);                // [IN] pass in the kind of token. 

    //*****************************************************************************
    // enumerator for typedef
    //*****************************************************************************
    STDMETHODIMP EnumTypeDefInit(           // return hresult
        HENUMInternal *phEnum);             // [OUT] buffer to fill for enumerator data

    STDMETHODIMP_(ULONG) EnumTypeDefGetCount(
        HENUMInternal *phEnum);             // [IN] the enumerator to retrieve information  

    STDMETHODIMP_(void) EnumTypeDefReset(
        HENUMInternal *phEnum);             // [IN] the enumerator to retrieve information  

    STDMETHODIMP_(bool) EnumTypeDefNext(    // return hresult
        HENUMInternal *phEnum,              // [IN] input enum
        mdTypeDef   *ptd);                  // [OUT] return token

    STDMETHODIMP_(void) EnumTypeDefClose(
        HENUMInternal *phEnum);             // [IN] the enumerator to retrieve information  

    //*****************************************************************************
    // enumerator for MethodImpl
    //*****************************************************************************
    STDMETHODIMP EnumMethodImplInit(        // return hresult
        mdTypeDef       td,                 // [IN] TypeDef over which to scope the enumeration.
        HENUMInternal   *phEnumBody,        // [OUT] buffer to fill for enumerator data for MethodBody tokens.
        HENUMInternal   *phEnumDecl);       // [OUT] buffer to fill for enumerator data for MethodDecl tokens.

    STDMETHODIMP_(ULONG) EnumMethodImplGetCount(
        HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.  
        HENUMInternal   *phEnumDecl);       // [IN] MethodDecl enumerator.

    STDMETHODIMP_(void) EnumMethodImplReset(
        HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.
        HENUMInternal   *phEnumDecl);       // [IN] MethodDecl enumerator.

    STDMETHODIMP_(bool) EnumMethodImplNext( // return hresult
        HENUMInternal   *phEnumBody,        // [IN] input enum for MethodBody
        HENUMInternal   *phEnumDecl,        // [IN] input enum for MethodDecl
        mdToken         *ptkBody,           // [OUT] return token for MethodBody
        mdToken         *ptkDecl);          // [OUT] return token for MethodDecl

    STDMETHODIMP_(void) EnumMethodImplClose(
        HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.
        HENUMInternal   *phEnumDecl);       // [IN] MethodDecl enumerator.

    //*****************************************
    // Enumerator helpers for memberdef, memberref, interfaceimp,
    // event, property, param, methodimpl
    //***************************************** 

    STDMETHODIMP EnumGlobalFunctionsInit(   // return hresult
        HENUMInternal   *phEnum);           // [OUT] buffer to fill for enumerator data

    STDMETHODIMP EnumGlobalFieldsInit(      // return hresult
        HENUMInternal   *phEnum);           // [OUT] buffer to fill for enumerator data


    STDMETHODIMP EnumInit(                  // return S_FALSE if record not found
        DWORD       tkKind,                 // [IN] which table to work on
        mdToken     tkParent,               // [IN] token to scope the search
        HENUMInternal *phEnum);             // [OUT] the enumerator to fill 

    STDMETHODIMP EnumAllInit(               // return S_FALSE if record not found
        DWORD       tkKind,                 // [IN] which table to work on
        HENUMInternal *phEnum);             // [OUT] the enumerator to fill 

    STDMETHODIMP_(bool) EnumNext(
        HENUMInternal *phEnum,              // [IN] the enumerator to retrieve information  
        mdToken     *ptk);                  // [OUT] token to scope the search

    STDMETHODIMP_(ULONG) EnumGetCount(
        HENUMInternal *phEnum);             // [IN] the enumerator to retrieve information  

    STDMETHODIMP_(void) EnumReset(
        HENUMInternal *phEnum);             // [IN] the enumerator to be reset  

    STDMETHODIMP_(void) EnumClose(
        HENUMInternal *phEnum);             // [IN] the enumerator to be closed

    STDMETHODIMP EnumPermissionSetsInit(    // return S_FALSE if record not found
        mdToken     tkParent,               // [IN] token to scope the search
        CorDeclSecurity Action,             // [IN] Action to scope the search
        HENUMInternal *phEnum);             // [OUT] the enumerator to fill 

    STDMETHODIMP EnumCustomAttributeByNameInit(// return S_FALSE if record not found
        mdToken     tkParent,               // [IN] token to scope the search
        LPCSTR      szName,                 // [IN] CustomAttribute's name to scope the search
        HENUMInternal *phEnum);             // [OUT] the enumerator to fill 

    STDMETHODIMP GetParentToken(
        mdToken     tkChild,                // [IN] given child token
        mdToken     *ptkParent);            // [OUT] returning parent

    STDMETHODIMP_(void) GetCustomAttributeProps(
        mdCustomAttribute at,               // The attribute.
        mdToken     *ptkType);              // Put attribute type here.

    STDMETHODIMP_(void) GetCustomAttributeAsBlob(
        mdCustomAttribute cv,               // [IN] given custom attribute token
        void const  **ppBlob,               // [OUT] return the pointer to internal blob
        ULONG       *pcbSize);              // [OUT] return the size of the blob

    STDMETHODIMP GetCustomAttributeByName(  // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData);              // [OUT] Put size of data here.

    STDMETHODIMP_(void) GetScopeProps(
        LPCSTR      *pszName,               // [OUT] scope name
        GUID        *pmvid);                // [OUT] version id

    // finding a particular method 
    STDMETHODIMP FindMethodDef(
        mdTypeDef   classdef,               // [IN] given typedef
        LPCSTR      szName,                 // [IN] member name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        mdMethodDef *pmd);                  // [OUT] matching memberdef

    // return a iSeq's param given a MethodDef
    STDMETHODIMP FindParamOfMethod(         // S_OK or error.
        mdMethodDef md,                     // [IN] The owning method of the param.
        ULONG       iSeq,                   // [IN} The sequence # of the param.
        mdParamDef  *pparamdef);            // [OUT] Put ParamDef token here.

    //*****************************************
    //
    // GetName* functions
    //
    //*****************************************

    // return the name and namespace of typedef
    STDMETHODIMP_(void) GetNameOfTypeDef(
        mdTypeDef   classdef,               // given classdef
        LPCSTR      *pszname,               // return class name(unqualified)
        LPCSTR      *psznamespace);         // return the name space name

    STDMETHODIMP GetIsDualOfTypeDef(
        mdTypeDef   classdef,               // [IN] given classdef.
        ULONG       *pDual);                // [OUT] return dual flag here.

    STDMETHODIMP GetIfaceTypeOfTypeDef(
        mdTypeDef   classdef,               // [IN] given classdef.
        ULONG       *pIface);               // [OUT] 0=dual, 1=vtable, 2=dispinterface

    // get the name of either methoddef
    STDMETHODIMP_(LPCSTR) GetNameOfMethodDef(   // return the name of the memberdef in UTF8
        mdMethodDef md);                    // given memberdef

    STDMETHODIMP_(LPCSTR) GetNameAndSigOfMethodDef(
        mdMethodDef methoddef,              // [IN] given memberdef
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
        ULONG       *pcbSigBlob);           // [OUT] count of bytes in the signature blob

    // return the name of a FieldDef
    STDMETHODIMP_(LPCSTR) GetNameOfFieldDef(
        mdFieldDef  fd);                    // given memberdef

    // return the name of typeref
    STDMETHODIMP_(void) GetNameOfTypeRef(
        mdTypeRef   classref,               // [IN] given typeref
        LPCSTR      *psznamespace,          // [OUT] return typeref name
        LPCSTR      *pszname);              // [OUT] return typeref namespace

    // return the resolutionscope of typeref
    STDMETHODIMP_(mdToken) GetResolutionScopeOfTypeRef(
        mdTypeRef   classref);              // given classref

    // return the typeref token given the name.
    STDMETHODIMP FindTypeRefByName(
        LPCSTR      szNamespace,            // [IN] Namespace for the TypeRef.
        LPCSTR      szName,                 // [IN] Name of the TypeRef.
        mdToken     tkResolutionScope,      // [IN] Resolution Scope fo the TypeRef.
        mdTypeRef   *ptk);                  // [OUT] TypeRef token returned.

    // return the TypeDef properties
    STDMETHODIMP_(void) GetTypeDefProps(    // return hresult
        mdTypeDef   classdef,               // given classdef
        DWORD       *pdwAttr,               // return flags on class, tdPublic, tdAbstract
        mdToken     *ptkExtends);           // [OUT] Put base class TypeDef/TypeRef here.

    // return the item's guid
    STDMETHODIMP GetItemGuid(               // return hresult
        mdToken     tkObj,                  // [IN] given item.
        CLSID       *pGuid);                // [OUT] Put guid here.

    // get enclosing class of NestedClass.
    STDMETHODIMP GetNestedClassProps(       // S_OK or error
        mdTypeDef   tkNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptkEnclosingClass);    // [OUT] EnclosingClass token.

    // Get count of Nested classes given the enclosing class.
    STDMETHODIMP_(ULONG)GetCountNestedClasses(  // return count of Nested classes.
        mdTypeDef   tkEnclosingClass);      // [IN]Enclosing class.

    // Return array of Nested classes given the enclosing class.
    STDMETHODIMP_(ULONG) GetNestedClasses(  // Return actual count.
        mdTypeDef   tkEnclosingClass,       // [IN] Enclosing class.
        mdTypeDef   *rNestedClasses,        // [OUT] Array of nested class tokens.
        ULONG       ulNestedClasses);       // [IN] Size of array.

    // return the ModuleRef properties
    STDMETHODIMP_(void) GetModuleRefProps(
        mdModuleRef mur,                    // [IN] moduleref token
        LPCSTR      *pszName);              // [OUT] buffer to fill with the moduleref name


    //*****************************************
    //
    // GetSig* functions
    //
    //*****************************************
    STDMETHODIMP_(PCCOR_SIGNATURE) GetSigOfMethodDef(
        mdMethodDef methoddef,              // [IN] given memberdef
        ULONG       *pcbSigBlob);           // [OUT] count of bytes in the signature blob

    STDMETHODIMP_(PCCOR_SIGNATURE) GetSigOfFieldDef(
        mdMethodDef methoddef,              // [IN] given memberdef
        ULONG       *pcbSigBlob);           // [OUT] count of bytes in the signature blob

    STDMETHODIMP_(PCCOR_SIGNATURE) GetSigFromToken(// return the signature
        mdSignature mdSig,                  // [IN] Signature token.
        ULONG       *pcbSig);               // [OUT] return size of signature.



    //*****************************************
    // get method property
    //*****************************************
    STDMETHODIMP_(DWORD) GetMethodDefProps(
        mdMethodDef md);                    // The method for which to get props.

    STDMETHODIMP_(ULONG) GetMethodDefSlot(
        mdMethodDef mb);                    // The method for which to get props.

    //*****************************************
    // return method implementation informaiton, like RVA and implflags
    //*****************************************
    STDMETHODIMP_(void) GetMethodImplProps(
        mdToken     tk,                     // [IN] MethodDef or MethodImpl
        DWORD       *pulCodeRVA,            // [OUT] CodeRVA
        DWORD       *pdwImplFlags);         // [OUT] Impl. Flags

    //*****************************************************************************
    // return the field RVA
    //*****************************************************************************
    STDMETHODIMP GetFieldRVA(   
        mdToken     fd,                     // [IN] FieldDef
        ULONG       *pulCodeRVA);           // [OUT] CodeRVA

    //*****************************************
    // get field property
    //*****************************************
    STDMETHODIMP_(DWORD) GetFieldDefProps(  // return fdPublic, fdPrive, etc flags
        mdFieldDef  fd);                    // [IN] given fielddef

    //*****************************************************************************
    // return default value of a token(could be paramdef, fielddef, or property
    //*****************************************************************************
    STDMETHODIMP GetDefaultValue(    
        mdToken     tk,                     // [IN] given FieldDef, ParamDef, or Property
        MDDefaultValue *pDefaultValue);     // [OUT] default value to fill

    
    //*****************************************
    // get dispid of a MethodDef or a FieldDef
    //*****************************************
    STDMETHODIMP GetDispIdOfMemberDef(      // return hresult
        mdToken     tk,                     // [IN] given methoddef or fielddef
        ULONG       *pDispid);              // [OUT] Put the dispid here.
    
    //*****************************************
    // return TypeRef/TypeDef given an InterfaceImpl token
    //*****************************************
    STDMETHODIMP_(mdToken) GetTypeOfInterfaceImpl( // return the TypeRef/typedef token for the interfaceimpl
        mdInterfaceImpl iiImpl);            // given a interfaceimpl

    //*****************************************
    // look up function for TypeDef
    //*****************************************
    STDMETHODIMP FindTypeDef(
        LPCSTR      szNamespace,            // [IN] Namespace for the TypeDef.
        LPCSTR      szName,                 // [IN] Name of the TypeDef.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef of enclosing class.
        mdTypeDef   *ptypedef);             // [OUT] return typedef

    STDMETHODIMP FindTypeDefByGUID(
        REFGUID     guid,                   // guid to look up
        mdTypeDef   *ptypedef);             // return typedef



    //*****************************************
    // return name and sig of a memberref
    //*****************************************
    STDMETHODIMP_(LPCSTR) GetNameAndSigOfMemberRef( // return name here
        mdMemberRef memberref,              // given memberref
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
        ULONG       *pcbSigBlob);           // [OUT] count of bytes in the signature blob

    //*****************************************************************************
    // Given memberref, return the parent. It can be TypeRef, ModuleRef, MethodDef
    //*****************************************************************************
    STDMETHODIMP_(mdToken) GetParentOfMemberRef( // return the parent token
        mdMemberRef memberref);              // given memberref

    
    STDMETHODIMP_(LPCSTR) GetParamDefProps( // return parameter name
        mdParamDef  paramdef,               // given a paramdef
        USHORT      *pusSequence,           // [OUT] slot number for this parameter
        DWORD       *pdwAttr);              // [OUT] flags

    //******************************************
    // property info for method.
    //******************************************
    STDMETHODIMP GetPropertyInfoForMethodDef(   // Result.
        mdMethodDef md,                     // [IN] memberdef
        mdProperty  *ppd,                   // [OUT] put property token here
        LPCSTR      *pName,                 // [OUT] put pointer to name here
        ULONG       *pSemantic);            // [OUT] put semantic here

    //*****************************************
    // class layout/sequence information
    //*****************************************
    STDMETHODIMP GetClassPackSize(          // [OUT] return error if a class doesn't have packsize info
        mdTypeDef   td,                     // [IN] give typedef
        ULONG       *pdwPackSize);          // [OUT] return the pack size of the class. 1, 2, 4, 8 or 16

    STDMETHODIMP GetClassTotalSize(         // [OUT] return error if a class doesn't have total size info
        mdTypeDef   td,                     // [IN] give typedef
        ULONG       *pdwClassSize);         // [OUT] return the total size of the class

    STDMETHODIMP GetClassLayoutInit(
        mdTypeDef   td,                     // [IN] give typedef
        MD_CLASS_LAYOUT *pLayout);          // [OUT] set up the status of query here

    STDMETHODIMP GetClassLayoutNext(
        MD_CLASS_LAYOUT *pLayout,           // [IN|OUT] set up the status of query here
        mdFieldDef  *pfd,                   // [OUT] return the fielddef
        ULONG       *pulOffset);            // [OUT] return the offset/ulSequence associate with it

    //*****************************************
    // marshal information of a field
    //*****************************************
    STDMETHODIMP GetFieldMarshal(           // return error if no native type associate with the token
        mdFieldDef  fd,                     // [IN] given fielddef
        PCCOR_SIGNATURE *pSigNativeType,    // [OUT] the native type signature
        ULONG       *pcbNativeType);        // [OUT] the count of bytes of *ppvNativeType


    //*****************************************
    // property APIs
    //*****************************************
    // find a property by name
    STDMETHODIMP FindProperty(
        mdTypeDef   td,                     // [IN] given a typdef
        LPCSTR      szPropName,             // [IN] property name
        mdProperty  *pProp);                // [OUT] return property token

    STDMETHODIMP_(void) GetPropertyProps(
        mdProperty  prop,                   // [IN] property token
        LPCSTR      *szProperty,            // [OUT] property name
        DWORD       *pdwPropFlags,          // [OUT] property flags.
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob
        ULONG       *pcbSig);               // [OUT] count of bytes in *ppvSig

    //**********************************
    // Event APIs
    //**********************************
    STDMETHODIMP FindEvent(
        mdTypeDef   td,                     // [IN] given a typdef
        LPCSTR      szEventName,            // [IN] event name
        mdEvent     *pEvent);               // [OUT] return event token

    STDMETHODIMP_(void) GetEventProps(           // S_OK, S_FALSE, or error.
        mdEvent     ev,                     // [IN] event token
        LPCSTR      *pszEvent,              // [OUT] Event name
        DWORD       *pdwEventFlags,         // [OUT] Event flags.
        mdToken     *ptkEventType);         // [OUT] EventType class


    //**********************************
    // find a particular associate of a property or an event
    //**********************************
    STDMETHODIMP FindAssociate(
        mdToken     evprop,                 // [IN] given a property or event token
        DWORD       associate,              // [IN] given a associate semantics(setter, getter, testdefault, reset, AddOn, RemoveOn, Fire)
        mdMethodDef *pmd);                  // [OUT] return method def token 

    STDMETHODIMP_(void) EnumAssociateInit(
        mdToken     evprop,                 // [IN] given a property or an event token
        HENUMInternal *phEnum);             // [OUT] cursor to hold the query result

    STDMETHODIMP_(void) GetAllAssociates(
        HENUMInternal *phEnum,              // [IN] query result form GetPropertyAssociateCounts
        ASSOCIATE_RECORD *pAssociateRec,    // [OUT] struct to fill for output
        ULONG       cAssociateRec);         // [IN] size of the buffer


    //**********************************
    // Get info about a PermissionSet.
    //**********************************
    STDMETHODIMP_(void) GetPermissionSetProps(
        mdPermission pm,                    // [IN] the permission token.
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.
        void const  **ppvPermission,        // [OUT] permission blob.
        ULONG       *pcbPermission);        // [OUT] count of bytes of pvPermission.

    //****************************************
    // Get the String given the String token.
    //****************************************
    STDMETHODIMP_(LPCWSTR) GetUserString(
        mdString    stk,                    // [IN] the string token.
        ULONG       *pchString,             // [OUT] count of characters in the string.
        BOOL        *pbIs80Plus);           // [OUT] specifies where there are extended characters >= 0x80.

    //*****************************************************************************
    // p-invoke APIs.
    //*****************************************************************************
    STDMETHODIMP GetPinvokeMap(
        mdToken     tk,                     // [IN] FieldDef or MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
        LPCSTR      *pszImportName,         // [OUT] Import name.
        mdModuleRef *pmrImportDLL);         // [OUT] ModuleRef token for the target DLL.

    //*****************************************************************************
    // Assembly MetaData APIs.
    //*****************************************************************************
    STDMETHODIMP_(void) GetAssemblyProps(
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbPublicKey,                 // [OUT] Pointer to the public key.
        ULONG       *pcbPublicKey,                  // [OUT] Count of bytes in the public key.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        AssemblyMetaDataInternal *pMetaData,// [OUT] Assembly MetaData.
        DWORD       *pdwAssemblyFlags);     // [OUT] Flags.

    STDMETHODIMP_(void) GetAssemblyRefProps(
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbPublicKeyOrToken,          // [OUT] Pointer to the public key or token.
        ULONG       *pcbPublicKeyOrToken,           // [OUT] Count of bytes in the public key or token.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        AssemblyMetaDataInternal *pMetaData,// [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        DWORD       *pdwAssemblyRefFlags);  // [OUT] Flags.

    STDMETHODIMP_(void) GetFileProps(
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags);         // [OUT] Flags.

    STDMETHODIMP_(void) GetExportedTypeProps(
        mdExportedType  mdct,                   // [IN] The ExportedType for which to get the properties.
        LPCSTR      *pszNamespace,          // [OUT] Buffer to fill with namespace.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        DWORD       *pdwExportedTypeFlags);     // [OUT] Flags.

    STDMETHODIMP_(void) GetManifestResourceProps(
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        DWORD       *pdwResourceFlags);     // [OUT] Flags.

    STDMETHODIMP FindExportedTypeByName(        // S_OK or error
        LPCSTR      szNamespace,            // [IN] Namespace of the ExportedType.   
        LPCSTR      szName,                 // [IN] Name of the ExportedType.   
        mdExportedType   tkEnclosingType,        // [IN] Token for the enclosing Type.
        mdExportedType  *pmct);                 // [OUT] Put ExportedType token here.

    STDMETHODIMP FindManifestResourceByName(// S_OK or error
        LPCSTR      szName,                 // [IN] Name of the resource.   
        mdManifestResource *pmmr);          // [OUT] Put ManifestResource token here.

    STDMETHODIMP GetAssemblyFromScope(      // S_OK or error
        mdAssembly  *ptkAssembly);          // [OUT] Put token here.
    
    //***************************************************************************
    // return properties regarding a TypeSpec
    //***************************************************************************
    STDMETHODIMP_(void) GetTypeSpecFromToken(// S_OK or error.
        mdTypeSpec  typespec,               // [IN] Signature token.
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.
        ULONG       *pcbSig);               // [OUT] return size of signature.

    //*****************************************************************************
    // helpers to convert a text signature to a com format
    //*****************************************************************************
    STDMETHODIMP ConvertTextSigToComSig(    // Return hresult.
        BOOL        fCreateTrIfNotFound,    // [IN] create typeref if not found
        LPCSTR      pSignature,             // [IN] class file format signature
        CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
        ULONG       *pcbCount);             // [OUT] the result size of signature

    STDMETHODIMP SetUserContextData(        // S_OK or E_NOTIMPL
        IUnknown    *pIUnk);                // The user context.

    STDMETHODIMP_(BOOL) IsValidToken(       // True or False.
        mdToken     tk);                    // [IN] Given token.

    STDMETHODIMP_(IUnknown *) GetCachedPublicInterface(BOOL fWithLock);       // return the cached public interface
    STDMETHODIMP SetCachedPublicInterface(IUnknown *pUnk);      // return hresult
    STDMETHODIMP_(UTSemReadWrite*) GetReaderWriterLock();       // return the reader writer lock
    STDMETHODIMP SetReaderWriterLock(UTSemReadWrite *pSem) { _ASSERTE(m_pSemReadWrite == NULL); m_pSemReadWrite = pSem; return NOERROR;}

    // *** IMDInternalImportENC methods ***
    STDMETHODIMP ApplyEditAndContinue(      // S_OK or error.
        MDInternalRW *pDelta);              // MD with the ENC delta.

    STDMETHODIMP EnumDeltaTokensInit(       // return hresult
        HENUMInternal   *phEnum);           // [OUT] buffer to fill for enumerator data

    STDMETHODIMP_(mdModule) GetModuleFromScope(void);

    // finding a particular method 
    STDMETHODIMP FindMethodDefUsingCompare(
        mdTypeDef   classdef,               // [IN] given typedef
        LPCSTR      szName,                 // [IN] member name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        PSIGCOMPARE pSignatureCompare,      // [IN] Routine to compare signatures
        void*       pSignatureArgs,         // [IN] Additional info to supply the compare function
        mdMethodDef *pmd);                  // [OUT] matching memberdef

    FORCEINLINE CLiteWeightStgdbRW* GetMiniStgdb() { return m_pStgdb; }
    FORCEINLINE UTSemReadWrite *getReaderWriterLock() { return m_pSemReadWrite; }


    CLiteWeightStgdbRW  *m_pStgdb;

private:
    mdTypeDef           m_tdModule;         // <Module> typedef value.
    ULONG               m_cRefs;            // Ref count.
    bool                m_fOwnStgdb;
    IUnknown            *m_pUnk;
    IUnknown            *m_pUserUnk;        // Release at shutdown.
    IMetaDataHelper     *m_pIMetaDataHelper;// pointer to cached public interface
    UTSemReadWrite      *m_pSemReadWrite;   // read write lock for multi-threading.
    bool                m_fOwnSem;          // Does MDInternalRW owns this read write lock object?
};



#endif // __MDInternalRW__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\metadatahash.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MetaDataHash.h -- Meta data hash data structures.
//
// Used by Emitters and by E&C.
//
//*****************************************************************************
#ifndef _MetaDataHash_h_
#define _MetaDataHash_h_

#if _MSC_VER >= 1100
 # pragma once
#endif

#include "Utilcode.h"


#define     REHASH_THREADSHOLD      3


//*****************************************************************************
// A hash entry list item.
//*****************************************************************************
struct TOKENHASHENTRY
{
	mdToken		tok;
    ULONG       ulHash;
	ULONG		iNext;
};

//*****************************************************************************
// The following is a hash class definition used for hashing MemberDef. The difference
// from the hash table above is because it is expansive to retrieve the parent for MemberDef.
//
//*****************************************************************************
struct MEMBERDEFHASHENTRY
{
	mdToken		tok;
    mdToken     tkParent;
    ULONG       ulHash;
	ULONG		iNext;
};


//*****************************************************************************
// This class is used to create transient indexes for meta data structures.
// This class is generic; one must override it to provide hashing and 
// accessor methods for your specific record type.  It can start out on top
// of malloc with a small memory footprint, and as you get larger, it must
// be capable of rehashing.
//*****************************************************************************
template <class Entry> class CMetaDataHashTemplate
{
public:
	CMetaDataHashTemplate()
    {
        m_rgBuckets = 0;
        m_cItems = 0;
        m_iBuckets = 0;
    }

	~CMetaDataHashTemplate()
    {
        // Free the bucket list.
        if (m_rgBuckets)
        {
	        delete [] m_rgBuckets;
	        m_rgBuckets = 0;
            m_cItems = 0;
	        m_iBuckets = 0;
        }
    }

//*****************************************************************************
// Called to allocate the hash table entries so that new data may be added.
//*****************************************************************************
	HRESULT NewInit(					// Return status.
		int			iBuckets=17)		// How many buckets you want.
    {
	    m_rgBuckets = new int[iBuckets];
	    if (!m_rgBuckets)
		    return (OutOfMemory());
	    m_iBuckets = iBuckets;
	    memset(m_rgBuckets, ~0, sizeof(int) * iBuckets);
	    return (S_OK);
    }

//*****************************************************************************
// Add new items to the hash list.
//*****************************************************************************
	Entry *Add( 		        		// Pointer to element to write to.
		ULONG		iHash)				// Hash value of entry to add.
    {
	    Entry       *p = 0;
        HRESULT     hr;

	    int iBucket = iHash % m_iBuckets;

        if (m_cItems > REHASH_THREADSHOLD * m_iBuckets)
        {
            hr = ReHash();
            if (FAILED(hr))
                return (0);
            iBucket = iHash % m_iBuckets;
        }

	    // Add a new item pointer.
	    p = m_Heap.Append();
	    if (!p)
		    return (0);

	    // Chain the new item to the front of the heap.
	    p->iNext = m_rgBuckets[iBucket];        
        p->ulHash = iHash;
        m_cItems++;
        m_rgBuckets[iBucket] = m_Heap.ItemIndex(p);
	    return (p);
    }


//*****************************************************************************
// Grow the hash table
//*****************************************************************************
	HRESULT ReHash()
    {
        int         *rgBuckets;
        int         iBuckets;
        int         iBucket;
        int         index;
        int         iCount;
	    Entry       *p = 0;

        iBuckets = m_iBuckets*2 -1;
	    rgBuckets = new int[iBuckets];
	    if (!rgBuckets)
		    return (OutOfMemory());
	    memset(rgBuckets, ~0, sizeof(int) * iBuckets);
        
        // loop through each of data and rehash them
        iCount = m_Heap.Count();
        for (index = 0; index < iCount; index++)
        {
            // get the hash value of the entry
            p = m_Heap.Get(index);

            // rehash the entry
            iBucket = p->ulHash % iBuckets;

	        // Chain the item to the front of the new heap.
	        p->iNext = rgBuckets[iBucket];        
            rgBuckets[iBucket] = index;
        }

        // swap the hash table
	    delete [] m_rgBuckets;
        m_rgBuckets = rgBuckets;
        m_iBuckets = iBuckets;
        return NOERROR;

    }

//*****************************************************************************
// Find first/find next node for a chain given the hash.
//*****************************************************************************
	Entry *FindFirst(			        // Return entry.
		ULONG		iHash,				// The hash value for the entry.
		int			&POS)				// Current position.
    {
	    int iBucket = iHash % m_iBuckets;
	    POS = m_rgBuckets[iBucket];
	    return (FindNext(POS));
    }

	Entry *FindNext(			        // Return entry or 0.
		int			&POS)				// Current location.
    {
	    Entry *p;
	    
	    if (POS == ~0)
		    return (0);

	    p = m_Heap.Get(POS);
	    POS = p->iNext;
	    return (p);
    }

private:
	CDynArray<Entry>  m_Heap;	        // First heap in the list.
	int			*m_rgBuckets;			// Bucket list.
	int			m_iBuckets;				// How many buckets.
    int         m_cItems;               // Number of items in the hash
};


class CMetaDataHashBase : public CMetaDataHashTemplate<TOKENHASHENTRY> 
{
};

class CMemberDefHash : public CMetaDataHashTemplate<MEMBERDEFHASHENTRY> 
{
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\metamodel.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MetaModel.h -- header file for compressed COM+ metadata.
//
//*****************************************************************************
#ifndef _METAMODEL_H_
#define _METAMODEL_H_

#if _MSC_VER >= 1100
 # pragma once
#endif

#include <cor.h>
#include <stgpool.h>

#include <MetaModelPub.h>
#include "MetaDataTracker.h"
//#include "Metadata.h"

#undef __unaligned

typedef enum RecordOpenFlags
{
    READ_ONLY,
    READ_WRITE,
    UPDATE_INPLACE
} RecordOpenFlags;

struct HENUMInternal;
extern const CCodedTokenDef     g_CodedTokens[CDTKN_COUNT];
extern const CMiniTableDefEx    g_Tables[TBL_COUNT];    // The table definitions.

struct TblCol
{
    ULONG       m_ixtbl;                // Table ID.
    ULONG       m_ixcol;                // Column ID.
};
extern TblCol g_PtrTableIxs[TBL_COUNT];

// This abstract defines the common functions that can be used for RW and RO internally
class IMetaModelCommon
{
public:
    virtual void CommonGetScopeProps(
        LPCUTF8     *pszName,
        GUID        **ppMvid) = 0;

    virtual void CommonGetTypeRefProps(
        mdTypeRef tr,
        LPCUTF8     *pszNamespace,
        LPCUTF8     *pszName,
        mdToken     *ptkResolution) = 0;

    virtual void CommonGetTypeDefProps(
        mdTypeDef td,
        LPCUTF8     *pszNameSpace,
        LPCUTF8     *pszName,
        DWORD       *pdwFlags) = 0;

    virtual void CommonGetTypeSpecProps(
        mdTypeSpec ts,
        PCCOR_SIGNATURE *ppvSig,
        ULONG       *pcbSig) = 0;

    virtual mdTypeDef CommonGetEnclosingClassOfTypeDef(
        mdTypeDef td) = 0;

    virtual void CommonGetAssemblyProps(
        USHORT      *pusMajorVersion,
        USHORT      *pusMinorVersion,
        USHORT      *pusBuildNumber,
        USHORT      *pusRevisionNumber,
        DWORD       *pdwFlags,
        const void  **ppbPublicKey,
        ULONG       *pcbPublicKey,
        LPCUTF8     *pszName,
        LPCUTF8     *pszLocale) = 0;

    virtual void CommonGetAssemblyRefProps(
        mdAssemblyRef tkAssemRef,
        USHORT      *pusMajorVersion,
        USHORT      *pusMinorVersion,
        USHORT      *pusBuildNumber,
        USHORT      *pusRevisionNumber,
        DWORD       *pdwFlags,
        const void  **ppbPublicKeyOrToken,
        ULONG       *pcbPublicKeyOrToken,
        LPCUTF8     *pszName,
        LPCUTF8     *pszLocale,
        const void  **ppbHashValue,
        ULONG       *pcbHashValue) = 0;

    virtual void CommonGetModuleRefProps(
        mdModuleRef tkModuleRef,
        LPCUTF8     *pszName) = 0;

    virtual HRESULT CommonFindExportedType(
        LPCUTF8     szNamespace,
        LPCUTF8     szName,
        mdToken     tkEnclosingType,
        mdExportedType   *ptkExportedType) = 0;

    virtual void CommonGetExportedTypeProps(
        mdToken     tkExportedType,
        LPCUTF8     *pszNamespace,
        LPCUTF8     *pszName,
        mdToken     *ptkImpl) = 0;

    virtual int CommonIsRo() = 0;

    virtual bool CompareCustomAttribute( 
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
        ULONG       rid) = 0;               // [IN] the rid of the custom attribute to compare to

    virtual HRESULT CommonEnumCustomAttributeByName( // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
        bool        fStopAtFirstFind,       // [IN] just find the first one
        HENUMInternal* phEnum) = 0;         // enumerator to fill up

    virtual HRESULT CommonGetCustomAttributeByName( // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData) = 0;          // [OUT] Put size of data here.

    virtual HRESULT FindParentOfMethodHelper(mdMethodDef md, mdTypeDef *ptd) = 0;

};


//*****************************************************************************
// The mini, hard-coded schema.  For each table, we persist the count of
//  records.  We also persist the size of string, blob, guid, and rid
//  columns.  From this information, we can calculate the record sizes, and
//  then the sizes of the tables.
//*****************************************************************************

class CMiniMdSchemaBase
{
public:
    ULONG       m_ulReserved;           // Reserved, must be zero.
    BYTE        m_major;                // Version numbers.
    BYTE        m_minor;
    BYTE        m_heaps;                // Bits for heap sizes.
    BYTE        m_rid;                  // log-base-2 of largest rid.

    // Bits for heap sizes.
    enum {
        HEAP_STRING_4   =   0x01,
        HEAP_GUID_4     =   0x02,
        HEAP_BLOB_4     =   0x04,

        PADDING_BIT     =   0x08,       // Tables can be created with an extra bit in columns, for growth.

        DELTA_ONLY      =   0x20,       // If set, only deltas were persisted.
        EXTRA_DATA      =   0x40,       // If set, schema persists an extra 4 bytes of data.
        HAS_DELETE      =   0x80,       // If set, this metadata can contain _Delete tokens.
    };

    unsigned __int64    m_maskvalid;            // Bit mask of present table counts.

    unsigned __int64    m_sorted;               // Bit mask of sorted tables.
    FORCEINLINE bool IsSorted(ULONG ixTbl)
        { return m_sorted & BIT(ixTbl) ? true : false; }
    void SetSorted(ULONG ixTbl, int bVal)
        { if (bVal) m_sorted |= BIT(ixTbl);
          else      m_sorted &= ~BIT(ixTbl); }

private:
    FORCEINLINE unsigned __int64 BIT(ULONG ixBit)
    {   _ASSERTE(ixBit < (sizeof(__int64)*CHAR_BIT));
        return 1UI64 << ixBit; }
};
class CMiniMdSchema : public CMiniMdSchemaBase
{
public:
    // These are not all persisted to disk.  See LoadFrom() for details.
    ULONG       m_cRecs[TBL_COUNT];     // Counts of various tables.

    ULONG       m_ulExtra;              // Extra data, only persisted if non-zero.  (m_heaps&EXTRA_DATA flags)

    ULONG LoadFrom(const void*);        // Load from a compressed version.  Return bytes consumed.
    ULONG SaveTo(void *);               // Store a compressed version.  Return bytes used in buffer.
    void InitNew();
};

//*****************************************************************************
// Helper macros and inline functions for navigating through the data.  Many
//  of the macros are used to define inline accessor functions.  Everything
//  is based on the naming conventions outlined at the top of the file.
//*****************************************************************************
#define _GETTER(tbl,fld) get##fld##Of##tbl##(##tbl##Rec *pRec)
#define _GETTER2(tbl,fld,x) get##fld##Of##tbl##(##tbl##Rec *pRec, x)
#define _GETTER3(tbl,fld,x,y) get##fld##Of##tbl##(##tbl##Rec *pRec, x, y)
#define _GETTER4(tbl,fld,x,y,z) get##fld##Of##tbl##(##tbl##Rec *pRec, x, y,z)
#define _VALIDP(tbl) _ASSERTE(isValidPtr(pRec,TBL_##tbl##))

// Direct getter for a field.  Defines an inline function like:
//    getSomeFieldOfXyz(XyzRec *pRec) { return pRec->m_SomeField;}
//  Note that the returned value declaration is NOT included.
#if METADATATRACKER_ENABLED
#define _GETFLD(tbl,fld) _GETTER(tbl,fld){  MetaDataTracker::NoteAccess((void *)&pRec->m_##fld##,sizeof(pRec->m_##fld##)); return pRec->m_##fld##;}
#else
#define _GETFLD(tbl,fld) _GETTER(tbl,fld){  return pRec->m_##fld##;}
#endif

// These functions call the helper function getIX to get a two or four byte value from a record,
//  and then use that value as an index into the appropriate pool.
//    getSomeFieldOfXyz(XyzRec *pRec) { return m_pStrings->GetString(getIX(pRec, _COLDEF(tbl,fld))); }
//  Note that the returned value declaration is NOT included.

// Column definition of a field:  Looks like:
//    m_XyzCol[XyzRec::COL_SomeField]
#define _COLDEF(tbl,fld) m_##tbl##Col[##tbl##Rec::COL_##fld##]
#define _COLPAIR(tbl,fld) _COLDEF(tbl,fld), tbl##Rec::COL_##fld
// Size of a record.
#define _CBREC(tbl) m_TableDefs[TBL_##tbl].m_cbRec
// Count of records in a table.
#define _TBLCNT(tbl) m_Schema.m_cRecs[TBL_##tbl##]

#define _GETSTRA(tbl,fld) _GETTER(tbl,fld) \
{   _VALIDP(tbl); return getString(getI4(pRec, _COLDEF(tbl,fld)) & m_iStringsMask); }

#define _GETSTRW(tbl,fld) _GETTER4(tbl,fld, LPWSTR szOut, ULONG cchBuffer, ULONG *pcchBuffer) \
{   _VALIDP(tbl); return getStringW(getI4(pRec, _COLDEF(tbl,fld)) & m_iStringsMask, szOut, cchBuffer, pcchBuffer); }

#define _GETSTR(tbl, fld) \
    _GETSTRA(tbl, fld); \
    HRESULT _GETSTRW(tbl, fld);


#define _GETGUID(tbl,fld) _GETTER(tbl,fld) \
{   _VALIDP(tbl); return getGuid(getI4(pRec, _COLDEF(tbl,fld)) & m_iGuidsMask); }

#define _GETBLOB(tbl,fld) _GETTER2(tbl,fld,ULONG *pcb) \
{   _VALIDP(tbl); return (const BYTE *)getBlob(getI4(pRec, _COLDEF(tbl,fld)) & m_iBlobsMask, pcb); }

#define _GETSIGBLOB(tbl,fld) _GETTER2(tbl,fld,ULONG *pcb) \
{   _VALIDP(tbl); return (PCCOR_SIGNATURE)getBlob(getI4(pRec, _COLDEF(tbl,fld)) & m_iBlobsMask, pcb); }

// Like the above functions, but just returns the RID, not a looked-up value.
#define _GETRID(tbl,fld) _GETTER(tbl,fld) \
{   _VALIDP(tbl); return getIX(pRec, _COLDEF(tbl,fld)); }

// Like a RID, but turn into an actual token.
#define _GETTKN(tbl,fld,tok)  _GETTER(tbl,fld) \
{   _VALIDP(tbl); return TokenFromRid(getIX(pRec, _COLDEF(tbl,fld)), tok); }

// Get a coded token.
#define _GETCDTKN(tbl,fld,toks)  _GETTER(tbl,fld) \
{   _VALIDP(tbl); return decodeToken(getIX(pRec, _COLDEF(tbl,fld)), toks, sizeof(toks)/sizeof(toks[0])); }

// Functions for the start and end of a list.
#define _GETLIST(tbl,fld,tbl2) \
    RID _GETRID(tbl,fld); \
    RID _GETTER(tbl,End##fld##) { _VALIDP(tbl); return getEndRidForColumn(pRec, TBL_##tbl##, _COLDEF(tbl,fld), TBL_##tbl2##); }


//*****************************************************************************
// Base class for the MiniMd.  This class provides the schema to derived
//  classes.  It defines some virtual functions for access to data, suitable
//  for use by functions where utmost performance is NOT a requirement.
//  Finally, it provides some searching functions, built on the virtual
//  data access functions (it is here assumed that if we are searching a table
//  for some value, the cost of a virtual function call is acceptable).
// Some static utility functions and associated static data, shared across
//  implementations, is provided here.
//*****************************************************************************
class CMiniMdBase : public IMetaModelCommon
{
public:
    CMiniMdBase();

    virtual void *vGetRow(ULONG ixTbl, ULONG rid) = 0;
    virtual LPCUTF8 vGetString(ULONG ix) = 0;
    virtual ULONG vGetCountRecs(ULONG ixTbl);

    // Search a table for the row containing the given key value.
    //  EG. Constant table has pointer back to Param or Field.
    virtual RID vSearchTable(           // RID of matching row, or 0.
        ULONG       ixTbl,              // Table to search.
        CMiniColDef sColumn,            // Sorted key column, containing search value.
        ULONG       ulTarget);          // Target for search.

    // Search a table for the highest-RID row containing a value that is less than
    //  or equal to the target value.  EG.  TypeDef points to first Field, but if
    //  a TypeDef has no fields, it points to first field of next TypeDef.
    virtual RID vSearchTableNotGreater( // RID of matching row, or 0.
        ULONG       ixTbl,              // Table to search.
        CMiniColDef sColumn,            // the column def containing search value
        ULONG       ulTarget);          // target for search

    // Search a table for multiple (adjacent) rows containing the given
    //  key value.  EG, InterfaceImpls all point back to the implementing class.
    RID SearchTableForMultipleRows(     // First RID found, or 0.
        ULONG       ixTbl,              // Table to search.
        CMiniColDef sColumn,            // Sorted key column, containing search value.
        ULONG       ulTarget,           // Target for search.
        RID         *pEnd);             // [OPTIONAL, OUT]

    // Search for a custom value with a given type.
    RID CMiniMdBase::FindCustomAttributeFor(// RID of custom value, or 0.
        RID         rid,                // The object's rid.
        mdToken     tkOjb,              // The object's type.
        mdToken     tkType);            // Type of custom value.


    // Return RID to EventMap table, given the rid to a TypeDef.
    RID FindEventMapFor(RID ridParent);

    // Return RID to PropertyMap table, given the rid to a TypeDef.
    RID FindPropertyMapFor(RID ridParent);


    // Pull two or four bytes out of a record.
    inline static ULONG getIX(const void *pRec, CMiniColDef &def)
    {
        if (def.m_cbColumn == 2)
        {
            METADATATRACKER_ONLY(MetaDataTracker::NoteAccess((void *)((BYTE *)pRec + def.m_oColumn), 2));
            ULONG ix = *(USHORT*)((BYTE*)pRec + def.m_oColumn);
            return ix;
        }
        _ASSERTE(def.m_cbColumn == 4);
        METADATATRACKER_ONLY(MetaDataTracker::NoteAccess((void *)((BYTE *)pRec + def.m_oColumn), 4));
        return *(UNALIGNED ULONG*)((BYTE*)pRec + def.m_oColumn);
    }

    // Pull four bytes out of a record.
    FORCEINLINE static ULONG getI1(const void *pRec, CMiniColDef &def)
    {
        METADATATRACKER_ONLY(MetaDataTracker::NoteAccess((void *)((BYTE *)pRec + def.m_oColumn), 1));
        return (*(BYTE*)((BYTE*)pRec + def.m_oColumn));
    }

    // Pull four bytes out of a record.
    FORCEINLINE static ULONG getI4(const void *pRec, CMiniColDef &def)
    {
        METADATATRACKER_ONLY(MetaDataTracker::NoteAccess((void *)((BYTE *)pRec + def.m_oColumn), 4));
        return (*(UNALIGNED ULONG*)((BYTE*)pRec + def.m_oColumn));
    }

    // Function to encode a token into fewer bits.  Looks up token type in array of types.
    ULONG static encodeToken(RID rid, mdToken typ, const mdToken rTokens[], ULONG32 cTokens);

    // Decode a token.
    inline static mdToken decodeToken(mdToken val, const mdToken rTokens[], ULONG32 cTokens)
    {
        //@FUTURE: make compile-time calculation
        ULONG32 ix = (ULONG32)(val & ~(-1 << m_cb[cTokens]));
        return TokenFromRid(val >> m_cb[cTokens], rTokens[ix]);
    }
    static const int m_cb[];

    // Given a token, what table does it live in?
    inline ULONG GetTblForToken(mdToken tk)
    {
        tk = TypeFromToken(tk);
        return (tk < mdtString) ? tk >> 24 : -1;
    }

    //*****************************************************************************
    // Some of the tables need coded tokens, not just rids (ie, the column can
    //  refer to more than one other table).  Code the tokens into as few bits
    //  as possible, by using 1, 2, 3, etc., bits to code the token type, then
    //  use that value to index into an array of token types.
    //*****************************************************************************
    static const mdToken mdtTypeDefOrRef[3];
    static const mdToken mdtHasConstant[3];
    static const mdToken mdtHasCustomAttribute[21];
    static const mdToken mdtHasFieldMarshal[2];
    static const mdToken mdtHasDeclSecurity[3];
    static const mdToken mdtMemberRefParent[5];
    static const mdToken mdtHasSemantic[2];
    static const mdToken mdtMethodDefOrRef[2];
    static const mdToken mdtMemberForwarded[2];
    static const mdToken mdtImplementation[3];
    static const mdToken mdtCustomAttributeType[5];
    static const mdToken mdtResolutionScope[4];

protected:
    CMiniMdSchema   m_Schema;           // data header.

    // Declare CMiniColDefs for every table.  Look like:
    //   CMiniColDef m_XyzCol[XyzRec::COL_COUNT];
    #undef MiniMdTable
    #define MiniMdTable(tbl) CMiniColDef    m_##tbl##Col[##tbl##Rec::COL_COUNT];
    MiniMdTables();
    CMiniTableDef   m_TableDefs[TBL_COUNT];

    ULONG       m_iStringsMask;
    ULONG       m_iGuidsMask;
    ULONG       m_iBlobsMask;

    ULONG SchemaPopulate();
    ULONG SchemaPopulate2(int bExtra=false);
    void InitColsForTable(CMiniMdSchema &Schema, int ixTbl, CMiniTableDef *pTable, int bExtra);
};

//*****************************************************************************
// This class defines the interface to the MiniMd.  The template parameter is
//  a derived class which provides implementations for a few primitives that
//  the interface is built upon.
// To use, declare a class:
//      class CMyMiniMd : public CMiniMdTemplate<CMyMiniMd> {...};
//  and provide implementations of the primitives.  Any non-trivial
//  implementation will also provide initialization, and probably serialization
//  functions as well.
//*****************************************************************************
template <class Impl> class CMiniMdTemplate : public CMiniMdBase
{
    // Primitives -- these must be implemented in the Impl class.
public:
    FORCEINLINE LPCUTF8 getString(ULONG ix)
    { return static_cast<Impl*>(this)->Impl_GetString(ix); }
    FORCEINLINE HRESULT getStringW(ULONG ix, LPWSTR szOut, ULONG cchBuffer, ULONG *pcchBuffer)
    { return static_cast<Impl*>(this)->Impl_GetStringW(ix, szOut, cchBuffer, pcchBuffer); }
    FORCEINLINE GUID *getGuid(ULONG ix)
    { return static_cast<Impl*>(this)->Impl_GetGuid(ix); }
    FORCEINLINE void *getBlob(ULONG ix, ULONG *pLen)
    { return static_cast<Impl*>(this)->Impl_GetBlob(ix, pLen); }
    FORCEINLINE void *getRow(ULONG ixTbl,ULONG rid)
    { return static_cast<Impl*>(this)->Impl_GetRow(ixTbl, rid); }
    FORCEINLINE RID getRidForRow(const void *pRow, ULONG ixTbl)
    { return static_cast<Impl*>(this)->Impl_GetRidForRow(pRow, ixTbl); }
    FORCEINLINE int isValidPtr(const void *pRow, int ixTbl)
    { return static_cast<Impl*>(this)->Impl_IsValidPtr(pRow, ixTbl); }
    FORCEINLINE int getEndRidForColumn(const void *pRec, int ixtbl, CMiniColDef &def, int ixtbl2)
    { return static_cast<Impl*>(this)->Impl_GetEndRidForColumn(pRec, ixtbl, def, ixtbl2); }
    FORCEINLINE RID doSearchTable(ULONG ixTbl, CMiniColDef sColumn, ULONG ixColumn, ULONG ulTarget)
    { return static_cast<Impl*>(this)->Impl_SearchTable(ixTbl, sColumn, ixColumn, ulTarget); }

    // IMetaModelCommon interface beging
    void CommonGetScopeProps(
        LPCUTF8     *pszName,
        GUID        **ppMvid)
    {
        ModuleRec   *pRec = getModule(1);
        if (pszName) *pszName = getNameOfModule(pRec);
        if (ppMvid) *ppMvid = getMvidOfModule(pRec);
    }

    void CommonGetTypeRefProps(
        mdTypeRef   tr,
        LPCUTF8     *pszNamespace,
        LPCUTF8     *pszName,
        mdToken     *ptkResolution)
    {
        TypeRefRec  *pRec = getTypeRef(RidFromToken(tr));
        if (pszNamespace) *pszNamespace = getNamespaceOfTypeRef(pRec);
        if (pszName) *pszName = getNameOfTypeRef(pRec);
        if (ptkResolution) *ptkResolution = getResolutionScopeOfTypeRef(pRec);
    }

    void CommonGetTypeDefProps(
        mdTypeDef   td,
        LPCUTF8     *pszNamespace,
        LPCUTF8     *pszName,
        DWORD       *pdwFlags)
    {
        TypeDefRec  *pRec = getTypeDef(RidFromToken(td));
        if (pszNamespace) *pszNamespace = getNamespaceOfTypeDef(pRec);
        if (pszName) *pszName = getNameOfTypeDef(pRec);
        if (pdwFlags) *pdwFlags = getFlagsOfTypeDef(pRec);
    }

    void CommonGetTypeSpecProps(
        mdTypeSpec  ts,
        PCCOR_SIGNATURE *ppvSig,
        ULONG       *pcbSig)
    {
        TypeSpecRec *pRec = getTypeSpec(RidFromToken(ts));
        ULONG       cb;
        *ppvSig = getSignatureOfTypeSpec(pRec, &cb);
        *pcbSig = cb;
    }

    mdTypeDef CommonGetEnclosingClassOfTypeDef(
        mdTypeDef   td)
    {
        NestedClassRec *pRec;
        RID         iRec;

        iRec = FindNestedClassFor(RidFromToken(td));
        if (!iRec)
            return mdTypeDefNil;

        pRec = getNestedClass(iRec);
        return getEnclosingClassOfNestedClass(pRec);
    }

    void CommonGetAssemblyProps(
        USHORT      *pusMajorVersion,
        USHORT      *pusMinorVersion,
        USHORT      *pusBuildNumber,
        USHORT      *pusRevisionNumber,
        DWORD       *pdwFlags,
        const void  **ppbPublicKey,
        ULONG       *pcbPublicKey,
        LPCUTF8     *pszName,
        LPCUTF8     *pszLocale)
    {
        AssemblyRec *pRec;

        pRec = getAssembly(1);

        if (pusMajorVersion) *pusMajorVersion = pRec->m_MajorVersion;
        if (pusMinorVersion) *pusMinorVersion = pRec->m_MinorVersion;
        if (pusBuildNumber) *pusBuildNumber = pRec->m_BuildNumber;
        if (pusRevisionNumber) *pusRevisionNumber = pRec->m_RevisionNumber;
        if (pdwFlags) *pdwFlags = pRec->m_Flags;

        // Turn on the afPublicKey if PublicKey blob is not empty
        if (pdwFlags)
        {
            DWORD cbPublicKey;
            getPublicKeyOfAssembly(pRec, &cbPublicKey);
            if (cbPublicKey)
                *pdwFlags |= afPublicKey;
        }
        if (ppbPublicKey) *ppbPublicKey = getPublicKeyOfAssembly(pRec, pcbPublicKey);
        if (pszName) *pszName = getNameOfAssembly(pRec);
        if (pszLocale) *pszLocale = getLocaleOfAssembly(pRec);
    }

   void CommonGetAssemblyRefProps(
        mdAssemblyRef tkAssemRef,
        USHORT      *pusMajorVersion,
        USHORT      *pusMinorVersion,
        USHORT      *pusBuildNumber,
        USHORT      *pusRevisionNumber,
        DWORD       *pdwFlags,
        const void  **ppbPublicKeyOrToken,
        ULONG       *pcbPublicKeyOrToken,
        LPCUTF8     *pszName,
        LPCUTF8     *pszLocale,
        const void  **ppbHashValue,
        ULONG       *pcbHashValue)
    {
        AssemblyRefRec  *pRec;

        pRec = getAssemblyRef(RidFromToken(tkAssemRef));

        if (pusMajorVersion) *pusMajorVersion = pRec->m_MajorVersion;
        if (pusMinorVersion) *pusMinorVersion = pRec->m_MinorVersion;
        if (pusBuildNumber) *pusBuildNumber = pRec->m_BuildNumber;
        if (pusRevisionNumber) *pusRevisionNumber = pRec->m_RevisionNumber;
        if (pdwFlags) *pdwFlags = pRec->m_Flags;
        if (ppbPublicKeyOrToken) *ppbPublicKeyOrToken = getPublicKeyOrTokenOfAssemblyRef(pRec, pcbPublicKeyOrToken);
        if (pszName) *pszName = getNameOfAssemblyRef(pRec);
        if (pszLocale) *pszLocale = getLocaleOfAssemblyRef(pRec);
        if (ppbHashValue) *ppbHashValue = getHashValueOfAssemblyRef(pRec, pcbHashValue);
    }

    void CommonGetModuleRefProps(
        mdModuleRef tkModuleRef,
        LPCUTF8     *pszName)
    {
        ModuleRefRec    *pRec;

        pRec = getModuleRef(RidFromToken(tkModuleRef));
        *pszName = getNameOfModuleRef(pRec);
    }

    HRESULT CommonFindExportedType(
        LPCUTF8     szNamespace,
        LPCUTF8     szName,
        mdToken     tkEnclosingType,
        mdExportedType   *ptkExportedType)
    {
        HRESULT     hr = S_OK;
        ExportedTypeRec  *pRec;
        ULONG       ulCount;
        LPCUTF8     szTmp;
        mdToken     tkImpl;

        _ASSERTE(szName && ptkExportedType);

        // Set NULL namespace to empty string.
        if (!szNamespace)
            szNamespace = "";

        // Set output to Nil.
        *ptkExportedType = mdTokenNil;

        ulCount = getCountExportedTypes();
        while (ulCount)
        {
            pRec = getExportedType(ulCount--);

            // Handle the case of nested vs. non-nested classes.
            tkImpl = getImplementationOfExportedType(pRec);
            if (TypeFromToken(tkImpl) == mdtExportedType && !IsNilToken(tkImpl))
            {
                // Current ExportedType being looked at is a nested type, so
                // comparing the implementation token.
                if (tkImpl != tkEnclosingType)
                    continue;
            }
            else if (TypeFromToken(tkEnclosingType) == mdtExportedType &&
                     !IsNilToken(tkEnclosingType))
            {
                // ExportedType passed in is nested but the current ExportedType is not.
                continue;
            }

            // Compare name and namespace.
            szTmp = getTypeNameOfExportedType(pRec);
            if (strcmp(szTmp, szName))
                continue;
            szTmp = getTypeNamespaceOfExportedType(pRec);
            if (!strcmp(szTmp, szNamespace))
            {
                *ptkExportedType = TokenFromRid(ulCount+1, mdtExportedType);
                return S_OK;
            }
        }
        return CLDB_E_RECORD_NOTFOUND;
    }

    void CommonGetExportedTypeProps(
        mdToken     tkExportedType,
        LPCUTF8     *pszNamespace,
        LPCUTF8     *pszName,
        mdToken     *ptkImpl)
    {
        ExportedTypeRec  *pRec;

        pRec = getExportedType(RidFromToken(tkExportedType));

        if (pszNamespace) *pszNamespace = getTypeNamespaceOfExportedType(pRec);
        if (pszName) *pszName = getTypeNameOfExportedType(pRec);
        if (ptkImpl) *ptkImpl = getImplementationOfExportedType(pRec);
    }

    int CommonIsRo()
    {
        return static_cast<Impl*>(this)->Impl_IsRo();
    }

    HRESULT FindParentOfMethodHelper(mdMethodDef md, mdTypeDef *ptd)
    {
        *ptd = FindParentOfMethod(RidFromToken(md));
        RidToToken(*ptd, mdtTypeDef);
        return NOERROR;
    }

    //*****************************************************************************
    // Helper function to lookup and retrieve a CustomAttribute.
    //*****************************************************************************
    bool CompareCustomAttribute( 
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
        ULONG       rid)                    // [IN] the rid of the custom attribute to compare to
    {
        CustomAttributeRec  *pRec;              // A CustomAttribute record.
        mdToken     tkTypeTmp;              // Type of some CustomAttribute.
        LPCUTF8     szNameTmp;              // Name of a CustomAttribute's type.
        int         iLen;                   // Length of a component name.
        RID         ridTmp;                 // Rid of some custom value.
        HRESULT     hr;
        bool        fMatch = false;

        // Get the row.
        pRec = getCustomAttribute(rid);

        // Check the parent.  In debug, always check.  In retail, only when scanning.
        mdToken tkParent;
        tkParent = getParentOfCustomAttribute(pRec);
        if (tkObj != tkParent)
        {
            goto ErrExit;
        }
        
        // Get the type.
        tkTypeTmp = getTypeOfCustomAttribute(pRec);
        ridTmp = RidFromToken(tkTypeTmp);

        // If the record is a MemberRef or a MethodDef, we will come back here to check
        //  the type of the parent.
    CheckParentType:
        // Get the name of the type.
        switch (TypeFromToken(tkTypeTmp))
        {
        case mdtTypeRef:
            {
                TypeRefRec *pTR = getTypeRef(ridTmp);
                // Check the namespace part of the name.
                szNameTmp = getNamespaceOfTypeRef(pTR);
                iLen = -1;
                if (*szNameTmp)
                {
                    iLen = (int)strlen(szNameTmp);
                    if (strncmp(szName, szNameTmp, iLen) != 0)
                        goto ErrExit;
                    // Namespace separator after the Namespace?
                    if (szName[iLen] != NAMESPACE_SEPARATOR_CHAR)
                        goto ErrExit;
                }
                // Check the type name after the separator.
                szNameTmp = getNameOfTypeRef(pTR);
                if (strcmp(szName+iLen+1, szNameTmp) != 0)
                    goto ErrExit;
            }
            break;
        case mdtTypeDef:
            {
                TypeDefRec *pTD = getTypeDef(ridTmp);
                // Check the namespace part of the name.
                szNameTmp = getNamespaceOfTypeDef(pTD);
                iLen = -1;
                if (*szNameTmp)
                {
                    iLen = (int)strlen(szNameTmp);
                    if (strncmp(szName, szNameTmp, iLen) != 0)
                        goto ErrExit;
                    // Namespace separator after the Namespace?
                    if (szName[iLen] != NAMESPACE_SEPARATOR_CHAR)
                        goto ErrExit;
                }
                // Check the type name after the separator.
                szNameTmp = getNameOfTypeDef(pTD);
                if (strcmp(szName+iLen+1, szNameTmp) != 0)
                    goto ErrExit;
            }
            break;
        case mdtMethodDef:
            {
                // Follow the parent.
                IfFailGo( FindParentOfMethodHelper(TokenFromRid(ridTmp, mdtMethodDef), &tkTypeTmp));
                ridTmp = RidFromToken(tkTypeTmp);
                goto CheckParentType;
            }
            break;
        case mdtMemberRef:
            {
                MemberRefRec *pMember = getMemberRef(ridTmp);
                // Follow the parent.
                tkTypeTmp = getClassOfMemberRef(pMember);
                ridTmp = RidFromToken(tkTypeTmp);
                goto CheckParentType;
            }
            break;
        case mdtString:
        default:
            _ASSERTE(!"Unexpected token type in FindCustomAttributeByName");
            goto ErrExit;
        } // switch (TypeFromToken(tkTypeTmp))

        fMatch = true;
    ErrExit:
        return fMatch;
    }   // CompareCustomAttribute

    // IMetaModelCommon interface end



public:
//  friend class CLiteWeightStgdb;

    virtual LPCUTF8 vGetString(ULONG ix) { return getString(ix); }
    virtual HRESULT vGetStringW(ULONG ix, LPWSTR szOut, ULONG cchBuffer, ULONG *pcchBuffer)
        {return getStringW(ix, szOut, cchBuffer, pcchBuffer); };

    virtual void *vGetRow(ULONG ixTbl, ULONG rid) { return getRow(ixTbl, rid); }

public:

    //*************************************************************************
    // This group of functions are table-level (one function per table).  Functions like
    //  getting a count of rows.

    // Functions to get the count of rows in a table.  Functions like:
    //   ULONG getCountXyzs() { return m_Schema.m_cRecs[TBL_Xyz];}
    #undef MiniMdTable
    #define MiniMdTable(tbl) ULONG getCount##tbl##s() { return _TBLCNT(tbl); }
    MiniMdTables();
    // macro mis-spells some names.
    ULONG getCountProperties() {return getCountPropertys();}
    ULONG getCountMethodSemantics() {return getCountMethodSemanticss();}

    // Functions for getting a row by rid.  Look like:
    //   XyzRec *getXyzRec(RID rid) {return (XyzRec*)&m_Xyz.m_pTable[(rid-1) * m_Xyz.m_cbRec];}
    #undef MiniMdTable
    #define MiniMdTable(tbl) tbl##Rec *get##tbl##(RID rid) { \
        return (##tbl##Rec*)getRow(TBL_##tbl##, rid); }
    MiniMdTables();

    //*************************************************************************
    // These are specialized searching functions.  Mostly generic (ie, find
    //  a custom value for any object).

    // Functions to search for a record relating to another record.
    // Return RID to Constant table.
    RID FindConstantFor(RID rid, mdToken typ)
    { return doSearchTable(TBL_Constant, _COLPAIR(Constant,Parent), encodeToken(rid,typ,mdtHasConstant,lengthof(mdtHasConstant))); }

    // Return RID to CustomAttribute table.  (Defined by base class; repeated here for documentation.)
    // RID FindCustomAttributeFor(RID rid, mdToken typ, LPCUTF8 szName);

    // Return RID to FieldMarshal table.
    RID FindFieldMarshalFor(RID rid, mdToken typ)
    { return doSearchTable(TBL_FieldMarshal, _COLPAIR(FieldMarshal,Parent), encodeToken(rid,typ,mdtHasFieldMarshal,lengthof(mdtHasFieldMarshal))); }

    // Return RID to ClassLayout table, given the rid to a TypeDef.
    RID FindClassLayoutFor(RID rid)
    { return doSearchTable(TBL_ClassLayout, _COLPAIR(ClassLayout,Parent), RidFromToken(rid)); }

    // given a rid to the Event table, find an entry in EventMap table that contains the back pointer
    // to its typedef parent
    RID FindEventMapParentOfEvent(RID rid)
    { return vSearchTableNotGreater(TBL_EventMap, _COLDEF(EventMap,EventList), rid); }
    // return the parent eventmap rid given a event rid
    RID FindParentOfEvent(RID rid)
    {vreturn vSearchTableNotGreater(TBL_EventMap, _COLDEF(EventMap,EventList), rid); }

    // given a rid to the Event table, find an entry in EventMap table that contains the back pointer
    // to its typedef parent
    RID FindPropertyMapParentOfProperty(RID rid)
    { return vSearchTableNotGreater(TBL_PropertyMap, _COLDEF(PropertyMap,PropertyList), rid); }
    // return the parent propertymap rid given a property rid
    RID FindParentOfProperty(RID rid)
    { return vSearchTableNotGreater(TBL_PropertyMap, _COLDEF(PropertyMap,PropertyList), rid); }

    // Return RID to MethodSemantics table, given the rid to a MethodDef.
    RID FindMethodSemanticsFor(RID rid)
    { return doSearchTable(TBL_MethodSemantics, _COLPAIR(MethodSemantics,Method), RidFromToken(rid)); }

    // return the parent typedef rid given a field def rid
    RID FindParentOfField(RID rid)
    {   return vSearchTableNotGreater(TBL_TypeDef, _COLDEF(TypeDef,FieldList), rid); }

    // return the parent typedef rid given a method def rid
    RID FindParentOfMethod(RID rid)
    {   return vSearchTableNotGreater(TBL_TypeDef, _COLDEF(TypeDef,MethodList), rid); }

    RID FindParentOfParam(RID rid)
    {   return vSearchTableNotGreater(TBL_Method, _COLDEF(Method,ParamList),    rid); }

    // Find a FieldLayout record given the corresponding Field.
    RID FindFieldLayoutFor(RID rid)
    {   return doSearchTable(TBL_FieldLayout, _COLPAIR(FieldLayout, Field), rid); }

    // Return RID to Constant table.
    RID FindImplMapFor(RID rid, mdToken typ)
    { return doSearchTable(TBL_ImplMap, _COLPAIR(ImplMap,MemberForwarded), encodeToken(rid,typ,mdtMemberForwarded,lengthof(mdtMemberForwarded))); }

    // Return RID to FieldRVA table.
    RID FindFieldRVAFor(RID rid)
    {   return doSearchTable(TBL_FieldRVA, _COLPAIR(FieldRVA, Field), rid); }

    // Find a NestedClass record given the corresponding Field.
    RID FindNestedClassFor(RID rid)
    {   return doSearchTable(TBL_NestedClass, _COLPAIR(NestedClass, NestedClass), rid); }

    //*************************************************************************
    // These are table-specific functions.

    // ModuleRec
    LPCUTF8 _GETSTR(Module,Name);
    GUID*   _GETGUID(Module,Mvid);
    GUID*   _GETGUID(Module,EncId);
    GUID*   _GETGUID(Module,EncBaseId);

    // TypeRefRec
    mdToken _GETCDTKN(TypeRef, ResolutionScope, mdtResolutionScope);
    LPCUTF8 _GETSTR(TypeRef, Name);
    LPCUTF8 _GETSTR(TypeRef, Namespace);

    // TypeDefRec
    ULONG _GETFLD(TypeDef,Flags);           // USHORT getFlagsOfTypeDef(TypeDefRec *pRec);
    LPCUTF8 _GETSTR(TypeDef,Name);
    LPCUTF8 _GETSTR(TypeDef,Namespace);

    _GETLIST(TypeDef,FieldList,Field);      // RID getFieldListOfTypeDef(TypeDefRec *pRec);
    _GETLIST(TypeDef,MethodList,Method);    // RID getMethodListOfTypeDef(TypeDefRec *pRec);
    mdToken _GETCDTKN(TypeDef,Extends,mdtTypeDefOrRef); // mdToken getExtendsOfTypeDef(TypeDefRec *pRec);

    RID getInterfaceImplsForTypeDef(RID rid, RID *pEnd=0)
    {
        return SearchTableForMultipleRows(TBL_InterfaceImpl,
                            _COLDEF(InterfaceImpl,Class),
                            rid,
                            pEnd);
    }
//  RID getInterfaceImplsForTypeDef(TypeDefRec *pRec, RID *pEnd=0) {return getInterfaceImplsForTypeDef(getRidForRow(pRec, TBL_TypeDef), pEnd);}

    // FieldPtr
    ULONG   _GETRID(FieldPtr,Field);

    // FieldRec
    USHORT  _GETFLD(Field,Flags);           // USHORT getFlagsOfField(FieldRec *pRec);
    LPCUTF8 _GETSTR(Field,Name);            // LPCUTF8 getNameOfField(FieldRec *pRec);
    PCCOR_SIGNATURE _GETSIGBLOB(Field,Signature);// PCCOR_SIGNATURE getSignatureOfField(FieldRec *pRec, ULONG *pcb);

    // MethodPtr
    ULONG   _GETRID(MethodPtr,Method);

    // MethodRec
    ULONG   _GETFLD(Method,RVA);
    USHORT  _GETFLD(Method,ImplFlags);
    USHORT  _GETFLD(Method,Flags);
    LPCUTF8 _GETSTR(Method,Name);           // LPCUTF8 getNameOfMethod(MethodRec *pRec);
    PCCOR_SIGNATURE _GETSIGBLOB(Method,Signature);  // PCCOR_SIGNATURE getSignatureOfMethod(MethodRec *pRec, ULONG *pcb);
    _GETLIST(Method,ParamList,Param);

    // ParamPtr
    ULONG   _GETRID(ParamPtr,Param);

    // ParamRec
    USHORT  _GETFLD(Param,Flags);
    USHORT  _GETFLD(Param,Sequence);
    LPCUTF8 _GETSTR(Param,Name);

    // InterfaceImplRec
    mdToken _GETTKN(InterfaceImpl,Class,mdtTypeDef);
    mdToken _GETCDTKN(InterfaceImpl,Interface,mdtTypeDefOrRef);

    // MemberRefRec
    mdToken _GETCDTKN(MemberRef,Class,mdtMemberRefParent);
    LPCUTF8 _GETSTR(MemberRef,Name);
    PCCOR_SIGNATURE _GETSIGBLOB(MemberRef,Signature);// PCCOR_SIGNATURE getSignatureOfMemberRef(MemberRefRec *pRec, ULONG *pcb);

    // ConstantRec
    BYTE    _GETFLD(Constant,Type);
    mdToken _GETCDTKN(Constant,Parent,mdtHasConstant);
    const BYTE* _GETBLOB(Constant,Value);

    // CustomAttributeRec
    RID getCustomAttributeForToken(mdToken  tk, RID *pEnd)
    {
        return SearchTableForMultipleRows(TBL_CustomAttribute,
                            _COLDEF(CustomAttribute,Parent),
                            encodeToken(RidFromToken(tk), TypeFromToken(tk), mdtHasCustomAttribute, lengthof(mdtHasCustomAttribute)),
                            pEnd);
    }

    mdToken _GETCDTKN(CustomAttribute,Parent,mdtHasCustomAttribute);
    mdToken _GETCDTKN(CustomAttribute,Type,mdtCustomAttributeType);
    const BYTE* _GETBLOB(CustomAttribute,Value);

    // FieldMarshalRec
    mdToken _GETCDTKN(FieldMarshal,Parent,mdtHasFieldMarshal);
    PCCOR_SIGNATURE _GETSIGBLOB(FieldMarshal,NativeType);

    // DeclSecurityRec
    RID getDeclSecurityForToken(mdToken tk, RID *pEnd)
    {
        return SearchTableForMultipleRows(TBL_DeclSecurity,
                            _COLDEF(DeclSecurity,Parent),
                            encodeToken(RidFromToken(tk), TypeFromToken(tk), mdtHasDeclSecurity, lengthof(mdtHasDeclSecurity)),
                            pEnd);
    }

    short _GETFLD(DeclSecurity,Action);
    mdToken _GETCDTKN(DeclSecurity,Parent,mdtHasDeclSecurity);
    const BYTE* _GETBLOB(DeclSecurity,PermissionSet);

    // ClassLayoutRec
    USHORT _GETFLD(ClassLayout,PackingSize);
    ULONG _GETFLD(ClassLayout,ClassSize);
    ULONG _GETTKN(ClassLayout,Parent, mdtTypeDef);
    ULONG _GETRID(ClassLayout,FieldLayout);

    // FieldLayout
    ULONG _GETFLD(FieldLayout,OffSet);
    ULONG _GETTKN(FieldLayout, Field, mdtFieldDef);

    // Event map.
    _GETLIST(EventMap,EventList,Event);
    ULONG _GETRID(EventMap, Parent);

    // EventPtr
    ULONG   _GETRID(EventPtr, Event);

    // Event.
    USHORT _GETFLD(Event,EventFlags);
    LPCUTF8 _GETSTR(Event,Name);
    mdToken _GETCDTKN(Event,EventType,mdtTypeDefOrRef);

    // Property map.
    _GETLIST(PropertyMap,PropertyList,Property);
    ULONG _GETRID(PropertyMap, Parent);

    // PropertyPtr
    ULONG   _GETRID(PropertyPtr, Property);

    // Property.
    USHORT _GETFLD(Property,PropFlags);
    LPCUTF8 _GETSTR(Property,Name);
    PCCOR_SIGNATURE _GETSIGBLOB(Property,Type);

    // MethodSemantics.
    // Given an event or a property token, return the beginning/ending
    // associates.
    //
    RID getAssociatesForToken(mdToken tk, RID *pEnd=0)
    {
        return SearchTableForMultipleRows(TBL_MethodSemantics,
                            _COLDEF(MethodSemantics,Association),
                            encodeToken(RidFromToken(tk), TypeFromToken(tk), mdtHasSemantic, lengthof(mdtHasSemantic)),
                            pEnd);
    }

    USHORT _GETFLD(MethodSemantics,Semantic);
    mdToken _GETTKN(MethodSemantics,Method,mdtMethodDef);
    mdToken _GETCDTKN(MethodSemantics,Association,mdtHasSemantic);

    // MethodImpl
    // Given a class token, return the beginning/ending MethodImpls.
    //
    RID getMethodImplsForClass(RID rid, RID *pEnd=0)
    {
        return SearchTableForMultipleRows(TBL_MethodImpl,
                            _COLDEF(MethodImpl, Class), rid, pEnd);
    }

    mdToken _GETTKN(MethodImpl,Class,mdtTypeDef);
    mdToken _GETCDTKN(MethodImpl,MethodBody, mdtMethodDefOrRef);
    mdToken _GETCDTKN(MethodImpl, MethodDeclaration, mdtMethodDefOrRef);

    // StandAloneSigRec
    PCCOR_SIGNATURE _GETSIGBLOB(StandAloneSig,Signature);   // const BYTE* getSignatureOfStandAloneSig(StandAloneSigRec *pRec, ULONG *pcb);

    // TypeSpecRec
    // const BYTE* getSignatureOfTypeSpec(TypeSpecRec *pRec, ULONG *pcb);
    PCCOR_SIGNATURE _GETSIGBLOB(TypeSpec,Signature);

    // ModuleRef
    LPCUTF8 _GETSTR(ModuleRef,Name);

    // ENCLog
    ULONG _GETFLD(ENCLog, FuncCode);                // ULONG getFuncCodeOfENCLog(ENCLogRec *pRec);
    mdToken _GETCDTKN(ENCLog, Token, mdtENCToken);  // mdToken getTokenOfENCLog(ENCLogRec *pRec);

    // ImplMap
    USHORT _GETFLD(ImplMap, MappingFlags);          // USHORT getMappingFlagsOfImplMap(ImplMapRec *pRec);
    mdToken _GETCDTKN(ImplMap, MemberForwarded, mdtMemberForwarded);    // mdToken getMemberForwardedOfImplMap(ImplMapRec *pRec);
    LPCUTF8 _GETSTR(ImplMap, ImportName);           // LPCUTF8 getImportNameOfImplMap(ImplMapRec *pRec);
    mdToken _GETTKN(ImplMap, ImportScope, mdtModuleRef);    // mdToken getImportScopeOfImplMap(ImplMapRec *pRec);

    // FieldRVA
    ULONG _GETFLD(FieldRVA, RVA);                   // ULONG getRVAOfFieldRVA(FieldRVARec *pRec);
    mdToken _GETTKN(FieldRVA, Field, mdtFieldDef);  // mdToken getFieldOfFieldRVA(FieldRVARec *pRec);

    // Assembly
    ULONG _GETFLD(Assembly, HashAlgId);
    USHORT _GETFLD(Assembly, MajorVersion);
    USHORT _GETFLD(Assembly, MinorVersion);
    USHORT _GETFLD(Assembly, BuildNumber);
    USHORT _GETFLD(Assembly, RevisionNumber);
    ULONG _GETFLD(Assembly, Flags);
    const BYTE *_GETBLOB(Assembly, PublicKey);
    LPCUTF8 _GETSTR(Assembly, Name);
    LPCUTF8 _GETSTR(Assembly, Locale);

    // AssemblyRef
    USHORT _GETFLD(AssemblyRef, MajorVersion);
    USHORT _GETFLD(AssemblyRef, MinorVersion);
    USHORT _GETFLD(AssemblyRef, BuildNumber);
    USHORT _GETFLD(AssemblyRef, RevisionNumber);
    ULONG _GETFLD(AssemblyRef, Flags);
    const BYTE *_GETBLOB(AssemblyRef, PublicKeyOrToken);
    LPCUTF8 _GETSTR(AssemblyRef, Name);
    LPCUTF8 _GETSTR(AssemblyRef, Locale);
    const BYTE *_GETBLOB(AssemblyRef, HashValue);

    // File
    ULONG _GETFLD(File, Flags);
    LPCUTF8 _GETSTR(File, Name);
    const BYTE *_GETBLOB(File, HashValue);

    // ExportedType
    ULONG _GETFLD(ExportedType, Flags);
    ULONG _GETFLD(ExportedType, TypeDefId);
    LPCUTF8 _GETSTR(ExportedType, TypeName);
    LPCUTF8 _GETSTR(ExportedType, TypeNamespace);
    mdToken _GETCDTKN(ExportedType, Implementation, mdtImplementation);

    // ManifestResource
    ULONG _GETFLD(ManifestResource, Offset);
    ULONG _GETFLD(ManifestResource, Flags);
    LPCUTF8 _GETSTR(ManifestResource, Name);
    mdToken _GETCDTKN(ManifestResource, Implementation, mdtImplementation);

    // NestedClass
    mdToken _GETTKN(NestedClass, NestedClass, mdtTypeDef);
    mdToken _GETTKN(NestedClass, EnclosingClass, mdtTypeDef);

    int GetSizeOfMethodNameColumn()
    {
        return _COLDEF(Method,Name).m_cbColumn;
    }

};



#undef SETP
#undef _GETCDTKN
#undef _GETTKN
#undef _GETRID
#undef _GETBLOB
#undef _GETGUID
#undef _GETSTR
#undef SCHEMA

#endif // _METAMODEL_H_
// eof ------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\metamodelrw.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MetaModelRW.h -- header file for Read/Write compressed COM+ metadata.
//
// Used by Emitters and by E&C.
//
//*****************************************************************************
#ifndef _METAMODELRW_H_
#define _METAMODELRW_H_

#if _MSC_VER >= 1100
 # pragma once
#endif

#include "MetaModel.h"					// Base classes for the MetaModel.
#include "RecordPool.h"
#include "TokenMapper.h"
#include "MetaDataHash.h"
#include "RWUtil.h"

struct HENUMInternal;

// ENUM for marking bit
enum 
{
	InvalidMarkedBit			= 0x00000000,
	ModuleMarkedBit				= 0x00000001,
	TypeRefMarkedBit			= 0x00000002,
	TypeDefMarkedBit			= 0x00000004,
	FieldMarkedBit				= 0x00000008,
	MethodMarkedBit				= 0x00000010,
	ParamMarkedBit				= 0x00000020,
	MemberRefMarkedBit			= 0x00000040,
	CustomAttributeMarkedBit	= 0x00000080,
	DeclSecurityMarkedBit		= 0x00000100,
	SignatureMarkedBit			= 0x00000200,
	EventMarkedBit				= 0x00000400,
	PropertyMarkedBit			= 0x00000800,
	MethodImplMarkedBit			= 0x00001000,
	ModuleRefMarkedBit			= 0x00002000,
	TypeSpecMarkedBit			= 0x00004000,
	InterfaceImplMarkedBit		= 0x00008000,
    AssemblyRefMarkedBit        = 0x00010000,

};

// entry for marking UserString
struct FilterUserStringEntry 
{
    DWORD       m_tkString;
    bool        m_fMarked;
};

class FilterTable : public CDynArray<DWORD> 
{
public:
    FilterTable() { m_daUserStringMarker = NULL; }
	~FilterTable();

	FORCEINLINE HRESULT MarkTypeRef(mdToken tk)	{ return MarkToken(tk, TypeRefMarkedBit); }
	FORCEINLINE HRESULT MarkTypeDef(mdToken tk) { return MarkToken(tk, TypeDefMarkedBit); }
	FORCEINLINE HRESULT MarkField(mdToken tk) { return MarkToken(tk, FieldMarkedBit); }
	FORCEINLINE HRESULT MarkMethod(mdToken tk) { return MarkToken(tk, MethodMarkedBit); }
	FORCEINLINE HRESULT MarkParam(mdToken tk) { return MarkToken(tk, ParamMarkedBit); }
	FORCEINLINE HRESULT MarkMemberRef(mdToken tk) { return MarkToken(tk, MemberRefMarkedBit); }
	FORCEINLINE HRESULT MarkCustomAttribute(mdToken tk) { return MarkToken(tk, CustomAttributeMarkedBit); }
	FORCEINLINE HRESULT MarkDeclSecurity(mdToken tk) { return MarkToken(tk, DeclSecurityMarkedBit); }
	FORCEINLINE HRESULT MarkSignature(mdToken tk) { return MarkToken(tk, SignatureMarkedBit); }
	FORCEINLINE HRESULT MarkEvent(mdToken tk) { return MarkToken(tk, EventMarkedBit); }
	FORCEINLINE HRESULT MarkProperty(mdToken tk) { return MarkToken(tk, PropertyMarkedBit); }
	FORCEINLINE HRESULT MarkMethodImpl(RID rid) 
    {
        return MarkToken(TokenFromRid(rid, TBL_MethodImpl << 24), MethodImplMarkedBit);
    }
	FORCEINLINE HRESULT MarkModuleRef(mdToken tk) { return MarkToken(tk, ModuleRefMarkedBit); }
	FORCEINLINE HRESULT MarkTypeSpec(mdToken tk) { return MarkToken(tk, TypeSpecMarkedBit); }
	FORCEINLINE HRESULT MarkInterfaceImpl(mdToken tk) { return MarkToken(tk, InterfaceImplMarkedBit); }
	FORCEINLINE HRESULT MarkAssemblyRef(mdToken tk) { return MarkToken(tk, AssemblyRefMarkedBit); }
	
	// It may look inconsistent but it is because taht UserString an offset to the heap.
	// We don't want to grow the FilterTable to the size of the UserString heap. 
	// So we use the heap's marking system instead...
	//
	HRESULT MarkUserString(mdString str);

	
	FORCEINLINE bool IsTypeRefMarked(mdToken tk)	{ return IsTokenMarked(tk, TypeRefMarkedBit); }
	FORCEINLINE bool IsTypeDefMarked(mdToken tk) { return IsTokenMarked(tk, TypeDefMarkedBit); }
	FORCEINLINE bool IsFieldMarked(mdToken tk) { return IsTokenMarked(tk, FieldMarkedBit); }
	FORCEINLINE bool IsMethodMarked(mdToken tk) { return IsTokenMarked(tk, MethodMarkedBit); }
	FORCEINLINE bool IsParamMarked(mdToken tk) { return IsTokenMarked(tk, ParamMarkedBit); }
	FORCEINLINE bool IsMemberRefMarked(mdToken tk) { return IsTokenMarked(tk, MemberRefMarkedBit); }
	FORCEINLINE bool IsCustomAttributeMarked(mdToken tk) { return IsTokenMarked(tk, CustomAttributeMarkedBit); }
	FORCEINLINE bool IsDeclSecurityMarked(mdToken tk) { return IsTokenMarked(tk, DeclSecurityMarkedBit); }
	FORCEINLINE bool IsSignatureMarked(mdToken tk) { return IsTokenMarked(tk, SignatureMarkedBit); }
	FORCEINLINE bool IsEventMarked(mdToken tk) { return IsTokenMarked(tk, EventMarkedBit); }
	FORCEINLINE bool IsPropertyMarked(mdToken tk) { return IsTokenMarked(tk, PropertyMarkedBit); }
	FORCEINLINE bool IsMethodImplMarked(RID rid) 
    {
        return IsTokenMarked(TokenFromRid(rid, TBL_MethodImpl << 24), MethodImplMarkedBit);
    }
	FORCEINLINE bool IsModuleRefMarked(mdToken tk) { return IsTokenMarked(tk, ModuleRefMarkedBit); }
	FORCEINLINE bool IsTypeSpecMarked(mdToken tk) { return IsTokenMarked(tk, TypeSpecMarkedBit); }
	FORCEINLINE bool IsInterfaceImplMarked(mdToken tk){ return IsTokenMarked(tk, InterfaceImplMarkedBit); }
	FORCEINLINE bool IsAssemblyRefMarked(mdToken tk){ return IsTokenMarked(tk, AssemblyRefMarkedBit); }
	bool IsMethodSemanticsMarked(CMiniMdRW	*pMiniMd, RID rid);

	bool IsUserStringMarked(mdString str);

	HRESULT	UnmarkAll(CMiniMdRW *pMiniMd, ULONG ulSize);
	HRESULT	MarkAll(CMiniMdRW *pMiniMd, ULONG ulSize);
    bool IsTokenMarked(mdToken);

	FORCEINLINE HRESULT UnmarkTypeDef(mdToken tk) { return UnmarkToken(tk, TypeDefMarkedBit); }
	FORCEINLINE HRESULT UnmarkField(mdToken tk) { return UnmarkToken(tk, FieldMarkedBit); }
	FORCEINLINE HRESULT UnmarkMethod(mdToken tk) { return UnmarkToken(tk, MethodMarkedBit); }
	FORCEINLINE HRESULT UnmarkCustomAttribute(mdToken tk) { return UnmarkToken(tk, CustomAttributeMarkedBit); }

private:
    CDynArray<FilterUserStringEntry> *m_daUserStringMarker;
	bool            IsTokenMarked(mdToken tk, DWORD bitMarked);
	HRESULT         MarkToken(mdToken tk, DWORD bit);
	HRESULT         UnmarkToken(mdToken tk, DWORD bit);
}; // class FilterTable : public CDynArray<DWORD> 

class CMiniMdRW;

enum MDPools {
	MDPoolStrings,						// Id for the string pool.
	MDPoolGuids,						// ...the GUID pool.
	MDPoolBlobs,						// ...the blob pool.
	MDPoolUSBlobs,						// ...the user string pool.

	MDPoolCount,						// Count of pools, for array sizing.
}; // enum MDPools 



//*****************************************************************************
// This class is used to keep a list of RID. This list of RID can be sorted
// base on the m_ixCol's value of the m_ixTbl table.
//*****************************************************************************
class VirtualSort
{
public:
	void Init(ULONG	ixTbl, ULONG ixCol, CMiniMdRW *pMiniMd);
	void Uninit();
	TOKENMAP	*m_pMap;				// RID for m_ixTbl table. Sorted by on the ixCol
	bool		m_isMapValid;
	ULONG		m_ixTbl;				// Table this is a sorter for.
	ULONG		m_ixCol;				// Key column in the table.
	CMiniMdRW	*m_pMiniMd;				// The MiniMd with the data.
	void Sort();
private:
	mdToken		m_tkBuf;
	void SortRange(int iLeft, int iRight);
	int Compare(						// -1, 0, or 1
		RID		iLeft,				// First item to compare.
		RID		iRight);			// Second item to compare.
	FORCEINLINE void Swap(
		RID         iFirst,
		RID         iSecond)
	{
		if ( iFirst == iSecond ) return;
		m_tkBuf = *(m_pMap->Get(iFirst));
		*(m_pMap->Get(iFirst)) = *(m_pMap->Get(iSecond));
		*(m_pMap->Get(iSecond)) = m_tkBuf;
	}


}; // class VirtualSort




typedef CMetaDataHashBase CMemberRefHash;
typedef CMetaDataHashBase CLookUpHash;

class MDTOKENMAP;
class MDInternalRW;

template <class MiniMd> class CLiteWeightStgdb;
//*****************************************************************************
// Read/Write MiniMd.
//*****************************************************************************
class CMiniMdRW : public CMiniMdTemplate<CMiniMdRW>
{
public:
	friend class CLiteWeightStgdb<CMiniMdRW>;
	friend class CLiteWeightStgdbRW;
	friend class CMiniMdTemplate<CMiniMdRW>;
	friend class CQuickSortMiniMdRW;
	friend class VirtualSort;
	friend class MDInternalRW;
	friend class RegMeta;
	friend class FilterTable;
	friend class ImportHelper;

	CMiniMdRW();
	~CMiniMdRW();

	HRESULT InitNew();
	HRESULT InitOnMem(const void *pBuf, ULONG ulBufLen, int bReadOnly);
    HRESULT PostInit(int iLevel);
	HRESULT InitPoolOnMem(int iPool, void *pbData, ULONG cbData, int bReadOnly);
	HRESULT InitOnRO(CMiniMd *pMd, int bReadOnly);
	HRESULT ConvertToRW();

	HRESULT GetSaveSize(CorSaveSize fSave, ULONG *pulSize, DWORD *pbCompressed);
	int IsPoolEmpty(int iPool);
	HRESULT GetPoolSaveSize(int iPool, ULONG *pulSize);

	HRESULT SaveTablesToStream(IStream *pIStream);
	HRESULT SavePoolToStream(int iPool, IStream *pIStream);
	HRESULT SaveDone();

	HRESULT SetHandler(IUnknown *pIUnk);
	HRESULT SetMapper(TokenMapper *pMapper);

	HRESULT SetOption(OptionValue *pOptionValue);
	HRESULT GetOption(OptionValue *pOptionValue);

	static ULONG GetTableForToken(mdToken tkn);
	static mdToken GetTokenForTable(ULONG ixTbl);

	FORCEINLINE static ULONG TblFromRecId(ULONG ul) { return (ul >> 24)&0x7f; }
	FORCEINLINE static ULONG RidFromRecId(ULONG ul) { return ul & 0xffffff; }
	FORCEINLINE static ULONG RecIdFromRid(ULONG rid, ULONG ixTbl) { return rid | ((ixTbl|0x80) << 24); }
	FORCEINLINE static int IsRecId(ULONG ul) { return (ul & 0x80000000) != 0;}

	// Place in every API function before doing any allocations.
	FORCEINLINE void PreUpdate()
	{	if (m_eGrow == eg_grow) ExpandTables(); }

	void *AddRecord(ULONG ixTbl, ULONG *pRid=0);

	FORCEINLINE HRESULT PutCol(ULONG ixTbl, ULONG ixCol, void *pRecord, ULONG uVal)
	{	_ASSERTE(ixTbl < TBL_COUNT); _ASSERTE(ixCol < g_Tables[ixTbl].m_Def.m_cCols);
		return PutCol(m_TableDefs[ixTbl].m_pColDefs[ixCol], pRecord, uVal);
	} // HRESULT CMiniMdRW::PutCol()
	HRESULT PutString(ULONG ixTbl, ULONG ixCol, void *pRecord, LPCSTR szString);
	HRESULT PutStringW(ULONG ixTbl, ULONG ixCol, void *pRecord, LPCWSTR szString);
	HRESULT PutGuid(ULONG ixTbl, ULONG ixCol, void *pRecord, REFGUID guid);
	HRESULT PutToken(ULONG ixTbl, ULONG ixCol, void *pRecord, mdToken tk);
	HRESULT PutBlob(ULONG ixTbl, ULONG ixCol, void *pRecord, const void *pvData, ULONG cbData);

	HRESULT PutUserString(const void *pvData, ULONG cbData, ULONG *piOffset)
	{ return m_USBlobs.AddBlob(cbData, pvData, piOffset); }

	ULONG GetCol(ULONG ixTbl, ULONG ixCol, void *pRecord);
	mdToken GetToken(ULONG ixTbl, ULONG ixCol, void *pRecord);

	// Add a record to a table, and return a typed XXXRec *.
//	#undef AddTblRecord
	#define AddTblRecord(tbl) \
		tbl##Rec *Add##tbl##Record(ULONG *pRid=0)	\
		{	return reinterpret_cast<tbl##Rec*>(AddRecord(TBL_##tbl, pRid)); }

	AddTblRecord(Module)
	AddTblRecord(TypeRef)
	TypeDefRec *AddTypeDefRecord(ULONG *pRid=0);	// Specialized implementation.
	AddTblRecord(Field)
	MethodRec *AddMethodRecord(ULONG *pRid=0);		// Specialized implementation.
	AddTblRecord(Param)
	AddTblRecord(InterfaceImpl)
	AddTblRecord(MemberRef)
	AddTblRecord(Constant)
	AddTblRecord(CustomAttribute)
	AddTblRecord(FieldMarshal)
	AddTblRecord(DeclSecurity)
	AddTblRecord(ClassLayout)
	AddTblRecord(FieldLayout)
	AddTblRecord(StandAloneSig)
	EventMapRec *AddEventMapRecord(ULONG *pRid=0);			// Specialized implementation.
	AddTblRecord(Event)
	PropertyMapRec *AddPropertyMapRecord(ULONG *pRid=0);	// Specialized implementation.
	AddTblRecord(Property)
	AddTblRecord(MethodSemantics)
	AddTblRecord(MethodImpl)
	AddTblRecord(ModuleRef)
	AddTblRecord(FieldPtr)
	AddTblRecord(MethodPtr)
	AddTblRecord(ParamPtr)
	AddTblRecord(PropertyPtr)
	AddTblRecord(EventPtr)

	AddTblRecord(ENCLog)
	AddTblRecord(TypeSpec)
	AddTblRecord(ImplMap)
	AddTblRecord(ENCMap)
	AddTblRecord(FieldRVA)

	// Assembly Tables.
	AddTblRecord(Assembly)
	AddTblRecord(AssemblyProcessor)
	AddTblRecord(AssemblyOS)
	AddTblRecord(AssemblyRef)
	AddTblRecord(AssemblyRefProcessor)
	AddTblRecord(AssemblyRefOS)
	AddTblRecord(File)
	AddTblRecord(ExportedType)
	AddTblRecord(ManifestResource)

    AddTblRecord(NestedClass)

	// Specialized AddXxxToYyy() functions.
	HRESULT AddMethodToTypeDef(RID td, RID md);
	HRESULT AddFieldToTypeDef(RID td, RID md);
	HRESULT	AddParamToMethod(RID md, RID pd);
	HRESULT	AddPropertyToPropertyMap(RID pmd, RID pd);
	HRESULT	AddEventToEventMap(ULONG emd, RID ed);

	// does the MiniMdRW has the indirect tables, such as FieldPtr, MethodPtr
	FORCEINLINE int HasIndirectTable(ULONG ix) 
	{ if (g_PtrTableIxs[ix].m_ixtbl < TBL_COUNT) return vGetCountRecs(g_PtrTableIxs[ix].m_ixtbl); return 0;}

	FORCEINLINE int IsVsMapValid(ULONG ixTbl)
	{ _ASSERTE(ixTbl<TBL_COUNT); return (m_pVS[ixTbl] && m_pVS[ixTbl]->m_isMapValid); }

	// translate index returned by getMethodListOfTypeDef to a rid into Method table
	FORCEINLINE ULONG GetMethodRid(ULONG index) { return (HasIndirectTable(TBL_Method) ? getMethodOfMethodPtr(getMethodPtr(index)) : index); };

	// translate index returned by getFieldListOfTypeDef to a rid into Field table
	FORCEINLINE ULONG GetFieldRid(ULONG index) { return (HasIndirectTable(TBL_Field) ? getFieldOfFieldPtr(getFieldPtr(index)) : index); };
	
	// translate index returned by getParamListOfMethod to a rid into Param table
	FORCEINLINE ULONG GetParamRid(ULONG index) { return (HasIndirectTable(TBL_Param) ? getParamOfParamPtr(getParamPtr(index)) : index); };
	
	// translate index returned by getEventListOfEventMap to a rid into Event table
	FORCEINLINE ULONG GetEventRid(ULONG index) { return (HasIndirectTable(TBL_Event) ? getEventOfEventPtr(getEventPtr(index)) : index); };
	
	// translate index returned by getPropertyListOfPropertyMap to a rid into Property table
	FORCEINLINE ULONG GetPropertyRid(ULONG index) { return (HasIndirectTable(TBL_Property) ? getPropertyOfPropertyPtr(getPropertyPtr(index)) : index); };

	// Convert a pseudo-RID from a Virtual Sort into a real RID.
	FORCEINLINE ULONG GetRidFromVirtualSort(ULONG ixTbl, ULONG index) 
	{ return IsVsMapValid(ixTbl) ? *(m_pVS[ixTbl]->m_pMap->Get(index)) : index; }

	// Index returned by GetInterfaceImplForTypeDef. It could be index to VirtualSort table
	// or directly to InterfaceImpl
	FORCEINLINE ULONG GetInterfaceImplRid(ULONG index) 
	{ return GetRidFromVirtualSort(TBL_InterfaceImpl, index); }

	// Index returned by GetDeclSecurityForToken. It could be index to VirtualSort table
	// or directly to DeclSecurity
	FORCEINLINE ULONG GetDeclSecurityRid(ULONG index) 
	{ return GetRidFromVirtualSort(TBL_DeclSecurity, index); }

	// Index returned by GetCustomAttributeForToken. It could be index to VirtualSort table
	// or directly to CustomAttribute
	FORCEINLINE ULONG GetCustomAttributeRid(ULONG index) 
	{ return GetRidFromVirtualSort(TBL_CustomAttribute, index); }

	// add method, field, property, event, param to the map table
	HRESULT AddMethodToLookUpTable(mdMethodDef md, mdTypeDef td);
	HRESULT AddFieldToLookUpTable(mdFieldDef fd, mdTypeDef td);
	HRESULT AddPropertyToLookUpTable(mdProperty pr, mdTypeDef td);
	HRESULT AddEventToLookUpTable(mdEvent ev, mdTypeDef td);
	HRESULT AddParamToLookUpTable(mdParamDef pd, mdMethodDef md);

	// look up the parent of method, field, property, event, or param
	HRESULT FindParentOfMethodHelper(mdMethodDef md, mdTypeDef *ptd);
	HRESULT FindParentOfFieldHelper(mdFieldDef fd, mdTypeDef *ptd);
	HRESULT FindParentOfPropertyHelper(mdProperty pr, mdTypeDef *ptd);
	HRESULT FindParentOfEventHelper(mdEvent ev, mdTypeDef *ptd);
	HRESULT FindParentOfParamHelper(mdParamDef pd, mdMethodDef *pmd);

    bool IsParentTableOfMethodValid() {if (HasIndirectTable(TBL_Method) && m_pMethodMap == NULL) return false; else return true;};
    bool IsParentTableOfFieldValid() {if (HasIndirectTable(TBL_Field) && m_pFieldMap == NULL) return false; else return true;};
    bool IsParentTableOfPropertyValid() {if (HasIndirectTable(TBL_Property) && m_pPropertyMap == NULL) return false; else return true;};
    bool IsParentTableOfEventValid() {if (HasIndirectTable(TBL_Event) && m_pEventMap == NULL) return false; else return true;};
    bool IsParentTableOfParamValid() {if (HasIndirectTable(TBL_Param) && m_pParamMap == NULL) return false; else return true;};

	// MemberRef hash table.
	typedef enum 
	{
		Found,								// Item was found.
		NotFound,							// Item not found.
		NoTable								// Table hasn't been built.
	} HashSrchRtn;

	//*************************************************************************
	// Add a new MemberRef to the hash table.
	//*************************************************************************
	HRESULT AddMemberRefToHash(				// Return code.
		mdMemberRef	mr);					// Token of new guy.

	//*************************************************************************
	// If the hash is built, search for the item.
	//*************************************************************************
	int FindMemberRefFromHash(				// How did it work.
		mdToken		tkParent,				// Parent token.
		LPCUTF8		szName,					// Name of item.
		PCCOR_SIGNATURE pvSigBlob,			// Signature.
		ULONG		cbSigBlob,				// Size of signature.
		mdMemberRef	*pmr);					// Return if found.

	//*************************************************************************
	// Check a given mr token to see if this one is a match.
	//*************************************************************************
	HRESULT CompareMemberRefs(				// S_OK match, S_FALSE no match.
		mdMemberRef mr,						// Token to check.
		mdToken		tkPar,					// Parent token.
		LPCUTF8		szNameUtf8,				// Name of item.
		PCCOR_SIGNATURE pvSigBlob,			// Signature.
		ULONG		cbSigBlob);				// Size of signature.

	//*************************************************************************
	// Add a new MemberDef to the hash table.
	//*************************************************************************
    HRESULT AddMemberDefToHash(             // Return code.
        mdToken     tkMember,               // Token of new guy. It can be MethodDef or FieldDef
        mdToken     tkParent);              // Parent token.

	//*************************************************************************
	// Create MemberDef Hash
	//*************************************************************************
    HRESULT CreateMemberDefHash();          // Return code.

    //*************************************************************************
	// If the hash is built, search for the item.
	//*************************************************************************
    int FindMemberDefFromHash(              // How did it work.
        mdToken     tkParent,               // Parent token.
        LPCUTF8     szName,                 // Name of item.
        PCCOR_SIGNATURE pvSigBlob,          // Signature.
        ULONG       cbSigBlob,              // Size of signature.
        mdToken     *ptkMember);            // Return if found. It can be MethodDef or FieldDef

    //*************************************************************************
	// Check a given Method/Field token to see if this one is a match.
	//*************************************************************************
    HRESULT CompareMemberDefs(              // S_OK match, S_FALSE no match.
        mdToken     tkMember,               // Token to check. It can be MethodDef or FieldDef
        mdToken     tkParent,               // Parent token recorded in the hash entry
        mdToken     tkPar,                  // Parent token.
        LPCUTF8     szNameUtf8,             // Name of item.
        PCCOR_SIGNATURE pvSigBlob,          // Signature.
        ULONG       cbSigBlob);             // Size of signature.

	//*************************************************************************
	// Add a new CustomAttributes to the hash table.
	//*************************************************************************
    HRESULT AddCustomAttributesToHash(      // Return code.
        mdCustomAttribute     cv)           // Token of new guy. 
    { return GenericAddToHash(TBL_CustomAttribute, CustomAttributeRec::COL_Parent, RidFromToken(cv)); }

    //*************************************************************************
	// If the hash is built, search for the item.
	//*************************************************************************
    int FindCustomAttributeFromHash(        // How did it work.
        mdToken     tkParent,               // Token that CA is associated with.
        mdToken     tkType,                 // Type of the CA.
        void        *pValue,                // the value of the CA
        ULONG       cbValue,                // count of bytes in the value
        mdCustomAttribute *pcv);

    
    inline ULONG HashMemberRef(mdToken tkPar, LPCUTF8 szName)
	{
		ULONG l = HashBytes((const BYTE *) &tkPar, sizeof(mdToken)) + HashStringA(szName);
		return (l);
	}

	inline ULONG HashMemberDef(mdToken tkPar, LPCUTF8 szName)
	{   
        return HashMemberRef(tkPar, szName);
	}

    // helper to calculate the hash value given a token
	inline ULONG HashCustomAttribute(mdToken tkObject)
	{
		return HashToken(tkObject);
	}

    CMemberRefHash *m_pMemberRefHash;

    // Hash table for Methods and Fields
	CMemberDefHash *m_pMemberDefHash;

    // helper to calculate the hash value given a pair of tokens
	inline ULONG HashToken(mdToken tkObject)
	{
		ULONG l = HashBytes((const BYTE *) &tkObject, sizeof(mdToken));
		return (l);
	}


	//*************************************************************************
	// Add a new FieldMarhsal Rid to the hash table.
	//*************************************************************************
	HRESULT AddFieldMarshalToHash(          // Return code.
		RID         rid)					// Token of new guy.
    { return GenericAddToHash(TBL_FieldMarshal, FieldMarshalRec::COL_Parent, rid); }

	//*************************************************************************
	// Add a new Constant Rid to the hash table.
	//*************************************************************************
	HRESULT AddConstantToHash(              // Return code.
		RID         rid)					// Token of new guy.
    { return GenericAddToHash(TBL_Constant, ConstantRec::COL_Parent, rid); }

	//*************************************************************************
	// Add a new MethodSemantics Rid to the hash table.
	//*************************************************************************
	HRESULT AddMethodSemanticsToHash(       // Return code.
		RID         rid)					// Token of new guy.
    { return GenericAddToHash(TBL_MethodSemantics, MethodSemanticsRec::COL_Association, rid); }

	//*************************************************************************
	// Add a new ClassLayout Rid to the hash table.
	//*************************************************************************
	HRESULT AddClassLayoutToHash(           // Return code.
		RID         rid)					// Token of new guy.
    { return GenericAddToHash(TBL_ClassLayout, ClassLayoutRec::COL_Parent, rid); }

	//*************************************************************************
	// Add a new FieldLayout Rid to the hash table.
	//*************************************************************************
	HRESULT AddFieldLayoutToHash(           // Return code.
		RID         rid)					// Token of new guy.
    { return GenericAddToHash(TBL_FieldLayout, FieldLayoutRec::COL_Field, rid); }

	//*************************************************************************
	// Add a new ImplMap Rid to the hash table.
	//*************************************************************************
	HRESULT AddImplMapToHash(               // Return code.
		RID         rid)					// Token of new guy.
    { return GenericAddToHash(TBL_ImplMap, ImplMapRec::COL_MemberForwarded, rid); }

	//*************************************************************************
	// Add a new FieldRVA Rid to the hash table.
	//*************************************************************************
	HRESULT AddFieldRVAToHash(              // Return code.
		RID         rid)					// Token of new guy.
    { return GenericAddToHash(TBL_FieldRVA, FieldRVARec::COL_Field, rid); }

	//*************************************************************************
	// Add a new nested class Rid to the hash table.
	//*************************************************************************
	HRESULT AddNestedClassToHash(           // Return code.
		RID         rid)					// Token of new guy.
    { return GenericAddToHash(TBL_NestedClass, NestedClassRec::COL_NestedClass, rid); }

	//*************************************************************************
	// Add a new MethodImpl Rid to the hash table.
	//*************************************************************************
	HRESULT AddMethodImplToHash(           // Return code.
		RID         rid)					// Token of new guy.
    { return GenericAddToHash(TBL_MethodImpl, MethodImplRec::COL_Class, rid); }


	//*************************************************************************
	// Build a hash table for the specified table if the size exceed the thresholds.
	//*************************************************************************
	HRESULT GenericBuildHashTable(          // Return code.
		ULONG		ixTbl,					// Table with hash
		ULONG		ixCol);					// col that we hash.

	//*************************************************************************
	// Add a rid from a table into a hash
	//*************************************************************************
	HRESULT GenericAddToHash(               // Return code.
		ULONG		ixTbl,					// Table with hash
		ULONG		ixCol,					// col that we hash.
		RID         rid);					// new row of the table.

	//*************************************************************************
	// Add a rid from a table into a hash
	//*************************************************************************
	RID GenericFindWithHash(                // Return code.
		ULONG		ixTbl,					// Table with hash
		ULONG		ixCol,					// col that we hash.
		mdToken     tkTarget);  			// token to be find in the hash

    
    // look up hash table for tokenless tables.
    // They are constant, FieldMarshal, MethodSemantics, ClassLayout, FieldLayout, ImplMap, FieldRVA, NestedClass, and MethodImpl
    CLookUpHash         *m_pLookUpHashs[TBL_COUNT];

    //*************************************************************************
	// Hash for named items.
	//*************************************************************************
	HRESULT AddNamedItemToHash(				// Return code.
		ULONG		ixTbl,					// Table with the new item.
		mdToken		tk,						// Token of new guy.
		LPCUTF8		szName,					// Name of item.
		mdToken		tkParent);				// Token of parent, if any.

	int FindNamedItemFromHash(				// How did it work.
		ULONG		ixTbl,					// Table with the item.
		LPCUTF8		szName,					// Name of item.
		mdToken		tkParent,				// Token of parent, if any.
		mdToken		*ptk);					// Return if found.

	HRESULT CompareNamedItems(				// S_OK match, S_FALSE no match.
		ULONG		ixTbl,					// Table with the item.
		mdToken		tk,						// Token to check.
		LPCUTF8		szName,					// Name of item.
		mdToken		tkParent);				// Token of parent, if any.

	FORCEINLINE ULONG HashNamedItem(mdToken tkPar, LPCUTF8 szName)
	{	return HashBytes((const BYTE *) &tkPar, sizeof(mdToken)) + HashStringA(szName);	}

	CMetaDataHashBase *m_pNamedItemHash;

	//*****************************************************************************
	// IMetaModelCommon - RW specific versions for some of the functions.
	//*****************************************************************************
    mdTypeDef CommonGetEnclosingClassOfTypeDef(mdTypeDef td)
    {
        NestedClassRec *pRec;
        RID         iRec;

        iRec = FindNestedClassHelper(td);
        if (!iRec)
            return mdTypeDefNil;

        pRec = getNestedClass(iRec);
        return getEnclosingClassOfNestedClass(pRec);
    }

    HRESULT CommonEnumCustomAttributeByName( // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
        bool        fStopAtFirstFind,       // [IN] just find the first one
        HENUMInternal* phEnum);             // enumerator to fill up

    HRESULT CommonGetCustomAttributeByName( // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
	    const void	**ppData,				// [OUT] Put pointer to data here.
	    ULONG		*pcbData);  			// [OUT] Put size of data here.

	//*****************************************************************************
	// Find helper for a constant. 
	//*****************************************************************************
	RID FindConstantHelper(					// return index to the constant table
		mdToken		tkParent);				// Parent token. Can be ParamDef, FieldDef, or Property.

	//*****************************************************************************
	// Find helper for a FieldMarshal. 
	//*****************************************************************************
	RID FindFieldMarshalHelper(				// return index to the field marshal table
		mdToken		tkParent);				// Parent token. Can be a FieldDef or ParamDef.

	//*****************************************************************************
	// Find helper for a method semantics. 
	//*****************************************************************************
	HRESULT FindMethodSemanticsHelper(	    // return HRESULT
        mdToken     tkAssociate,            // Event or property token
        HENUMInternal *phEnum);             // fill in the enum

    //*****************************************************************************
    // Find helper for a method semantics given a associate and semantics.
    // This will look up methodsemantics based on its status!
    // Return CLDB_E_RECORD_NOTFOUND if cannot find the matching one
    //*****************************************************************************
    HRESULT CMiniMdRW::FindAssociateHelper(// return HRESULT
        mdToken     tkAssociate,            // Event or property token
        DWORD       dwSemantics,            // [IN] given a associate semantics(setter, getter, testdefault, reset)
        RID         *pRid);                 // [OUT] return matching row index here

	//*****************************************************************************
	// Find helper for a MethodImpl. 
	//*****************************************************************************
    HRESULT CMiniMdRW::FindMethodImplHelper(// return HRESULT
        mdTypeDef   td,                     // TypeDef token for the Class.
        HENUMInternal *phEnum);             // fill in the enum

    //*****************************************************************************
	// Find helper for a ClassLayout. 
	//*****************************************************************************
	RID FindClassLayoutHelper(				// return index to the ClassLayout table
		mdTypeDef	tkParent);				// Parent token.

	//*****************************************************************************
	// Find helper for a FieldLayout. 
	//*****************************************************************************
	RID FindFieldLayoutHelper(				// return index to the FieldLayout table
		mdFieldDef	tkField);				// Token for the field.

	//*****************************************************************************
	// Find helper for a ImplMap. 
	//*****************************************************************************
	RID CMiniMdRW::FindImplMapHelper(		// return index to the constant table
		mdToken		tk);					// Member forwarded token.

	//*****************************************************************************
	// Find helper for a FieldRVA. 
	//*****************************************************************************
	RID FindFieldRVAHelper(					// return index to the FieldRVA table
		mdFieldDef    tkField);				// Token for the field.

	//*****************************************************************************
	// Find helper for a NestedClass. 
	//*****************************************************************************
	RID FindNestedClassHelper(				// return index to the NestedClass table
		mdTypeDef	tkClass);				// Token for the NestedClass.

	//*****************************************************************************
	// IMPORTANT!!!!!!!! Use these set of functions if you are dealing with RW rather 
	// getInterfaceImplsForTypeDef, getDeclSecurityForToken, etc.
	// The following functions can deal with these tables when they are not sorted and
	// build the VirtualSort tables for quick lookup.
	//*****************************************************************************
	HRESULT	GetInterfaceImplsForTypeDef(mdTypeDef td, RID *pRidStart, RID *pRidEnd = 0)
	{
		return LookUpTableByCol( RidFromToken(td), m_pVS[TBL_InterfaceImpl], pRidStart, pRidEnd);
	}

	HRESULT	GetDeclSecurityForToken(mdToken tk, RID *pRidStart, RID *pRidEnd = 0)
	{
		return LookUpTableByCol( 
			encodeToken(RidFromToken(tk), TypeFromToken(tk), mdtHasDeclSecurity, lengthof(mdtHasDeclSecurity)), 
			m_pVS[TBL_DeclSecurity], 
			pRidStart, 
			pRidEnd);
	}

	HRESULT	GetCustomAttributeForToken(mdToken tk, RID *pRidStart, RID *pRidEnd = 0)
	{
		return LookUpTableByCol( 
			encodeToken(RidFromToken(tk), TypeFromToken(tk), mdtHasCustomAttribute, lengthof(mdtHasCustomAttribute)),
			m_pVS[TBL_CustomAttribute], 
			pRidStart, 
			pRidEnd);
	}

	FORCEINLINE void *GetUserString(ULONG ix, ULONG *pLen)
	{ return m_USBlobs.GetBlob(ix, pLen); }
	FORCEINLINE void *GetUserStringNext(ULONG ix, ULONG *pLen, ULONG *piNext)
	{ return m_USBlobs.GetBlobNext(ix, pLen, piNext); }

	FORCEINLINE int IsSorted(ULONG ixTbl) { return m_Schema.IsSorted(ixTbl);}
	FORCEINLINE int IsSortable(ULONG ixTbl) { return m_bSortable[ixTbl];}
    FORCEINLINE bool HasDelete() { return ((m_Schema.m_heaps & CMiniMdSchema::HAS_DELETE) ? true : false); }
    FORCEINLINE int IsPreSaveDone() { return m_bPreSaveDone; }

protected:
	HRESULT PreSave();
	HRESULT PostSave();

	HRESULT PreSaveFull();
	HRESULT PreSaveEnc();
	HRESULT PreSaveExtension();

	HRESULT GetFullPoolSaveSize(int iPool, ULONG *pulSize);
	HRESULT GetENCPoolSaveSize(int iPool, ULONG *pulSize);
	HRESULT GetExtensionPoolSaveSize(int iPool, ULONG *pulSize);

	HRESULT SaveFullPoolToStream(int iPool, IStream *pIStream);
	HRESULT SaveENCPoolToStream(int iPool, IStream *pIStream);
	HRESULT SaveExtensionPoolToStream(int iPool, IStream *pIStream);

	HRESULT GetFullSaveSize(CorSaveSize fSave, ULONG *pulSize, DWORD *pbCompressed);
	HRESULT GetENCSaveSize(ULONG *pulSize);
	HRESULT GetExtensionSaveSize(ULONG *pulSize);

	HRESULT SaveFullTablesToStream(IStream *pIStream);
	HRESULT SaveENCTablesToStream(IStream *pIStream);
	HRESULT SaveExtensionTablesToStream(IStream *pIStream);

	HRESULT AddString(LPCSTR szString, ULONG *piOffset)
	{ return m_Strings.AddString(szString, piOffset); }
	HRESULT AddStringW(LPCWSTR szString, ULONG *piOffset)
	{ return m_Strings.AddStringW(szString, piOffset); }
	HRESULT AddGuid(REFGUID guid, ULONG *piOffset)
	{ return m_Guids.AddGuid(guid, piOffset); }
	HRESULT AddBlob(const void *pvData, ULONG cbData, ULONG *piOffset)
	{ return m_Blobs.AddBlob(cbData, pvData, piOffset); }

	// Allows putting into tables outside this MiniMd, specifically the temporary
	//  table used on save.
	HRESULT PutCol(CMiniColDef ColDef, void *pRecord, ULONG uVal);

	HRESULT ExpandTables();
	HRESULT ExpandTableColumns(CMiniMdSchema &Schema, ULONG ixTbl);

	void ComputeGrowLimits();			// Set max, lim, based on data.
	ULONG		m_maxRid;				// Highest RID so far allocated.
	ULONG		m_limRid;				// Limit on RID before growing.
	ULONG		m_maxIx;				// Highest pool index so far.
	ULONG		m_limIx;				// Limit on pool index before growing.
	enum		{eg_ok, eg_grow, eg_grown} m_eGrow;	// Is a grow required? done?
    #define AUTO_GROW_CODED_TOKEN_PADDING 5

	// fix up these tables after PreSave has move the tokens
	HRESULT FixUpTable(ULONG ixTbl);
	HRESULT FixUpMemberRefTable();
	HRESULT FixUpConstantTable();
	HRESULT FixUpFieldMarshalTable();
	HRESULT FixUpMethodImplTable();
	HRESULT FixUpDeclSecurityTable();
	HRESULT FixUpCustomAttributeTable();
	HRESULT FixUpMethodSemanticsTable();
	HRESULT FixUpImplMapTable();
	HRESULT FixUpFieldRVATable();
    HRESULT FixUpFieldLayoutTable();
    HRESULT FixUpRefToDef();

	// Table info.
	RecordPool	m_Table[TBL_COUNT];		// Record pools, one per table.
	VirtualSort	*m_pVS[TBL_COUNT];		// Virtual sorters, one per table, but sparse.
	
	//*****************************************************************************
	// look up a table by a col given col value is ulVal. 
	//*****************************************************************************
	HRESULT	LookUpTableByCol(
		ULONG		ulVal, 
		VirtualSort *pVSTable, 
		RID			*pRidStart, 
		RID			*pRidEnd);

	RID Impl_SearchTableRW(ULONG ixTbl, ULONG ixCol, ULONG ulTarget);
    virtual RID vSearchTable(ULONG ixTbl, CMiniColDef sColumn, ULONG ulTarget);
	virtual RID vSearchTableNotGreater(ULONG ixTbl, CMiniColDef sColumn, ULONG ulTarget);

	void SetSorted(ULONG ixTbl, int bSorted)
		{ m_Schema.SetSorted(ixTbl, bSorted); }

    void SetPreSaveDone(int bPreSaveDone)
        { m_bPreSaveDone = bPreSaveDone; }

	void SetTablePointers(BYTE *pBase);

	StgGuidPool		m_Guids;			// Heaps
	StgStringPool	m_Strings;			//  for
	StgBlobPool		m_Blobs;			//   this
	StgBlobPool		m_USBlobs;			//    MiniMd

	IMapToken		*m_pHandler;		// Remap handler.	
	HRESULT MapToken(RID from, RID to, mdToken type);

	ULONG		m_iSizeHint;			// Hint of size.  0 - normal, 1 - big.	

	ULONG		m_cbSaveSize;			// Estimate of save size.

	int			m_bReadOnly	: 1;		// Is this db read-only?
	int			m_bPreSaveDone : 1;		// Has save optimization been done?
	int			m_bSaveCompressed : 1;	// Can the data be saved as fully compressed?
	int			m_bPostGSSMod : 1;		// true if a change was made post GetSaveSize.


	//*************************************************************************
	// Overridables -- must be provided in derived classes.
	FORCEINLINE LPCUTF8 Impl_GetString(ULONG ix)
	{ return m_Strings.GetString(ix); }
	HRESULT Impl_GetStringW(ULONG ix, LPWSTR szOut, ULONG cchBuffer, ULONG *pcchBuffer);
	FORCEINLINE GUID *Impl_GetGuid(ULONG ix)
	{ return m_Guids.GetGuid(ix); }
	FORCEINLINE void *Impl_GetBlob(ULONG ix, ULONG *pLen)
	{ return m_Blobs.GetBlob(ix, pLen); }

	FORCEINLINE void *Impl_GetRow(ULONG ixTbl,ULONG rid) 
	{	// Want a valid RID here.  If this fires, check the calling code for an invalid token.
		_ASSERTE(rid >= 1 && rid <= m_Schema.m_cRecs[ixTbl] && "Caller error:  you passed an invalid token to the metadata!!");
		// Get the data from the record heap.
		return m_Table[ixTbl].GetRecord(rid);
	}
	RID Impl_GetRidForRow(const void *pRow, ULONG ixTbl);

	// Validation.
	int Impl_IsValidPtr(const void *pRow, int ixTbl)
	{ return m_Table[ixTbl].IsValidPointerForRecord(pRow); }

	// Count of rows in tbl2, pointed to by the column in tbl.
	int Impl_GetEndRidForColumn(const void *pRec, int ixtbl, CMiniColDef &def, int ixtbl2);
	
	FORCEINLINE RID Impl_SearchTable(ULONG ixTbl, CMiniColDef sColumn, ULONG ixCol, ULONG ulTarget)
	{ return Impl_SearchTableRW(ixTbl, ixCol, ulTarget); }
    
    FORCEINLINE int Impl_IsRo() 
    { return 0; }
	//*************************************************************************
	enum {END_OF_TABLE = 0};
	FORCEINLINE ULONG NewRecordPointerEndValue(ULONG ixTbl) 
	{ if (HasIndirectTable(ixTbl)) return m_Schema.m_cRecs[ixTbl]+1; else return END_OF_TABLE; }

	HRESULT ConvertMarkerToEndOfTable(ULONG tblParent, ULONG colParent, ULONG ridChild, RID ridParent);

	// Add a child row, adjust pointers in parent rows.
	void *AddChildRowIndirectForParent(ULONG tblParent, ULONG colParent, ULONG tblChild, RID ridParent);

	// Update pointers in the parent table to reflect the addition of a child, if required
	// create the indirect table in which case don't update pointers.
	HRESULT AddChildRowDirectForParent(ULONG tblParent, ULONG colParent, ULONG tblChild, RID ridParent);

	// Given a table id, create the corresponding indirect table.
	HRESULT CreateIndirectTable(ULONG ixtbl, BOOL bOneLess = true);

	// If the last param is not added in the right sequence, fix it up.
	void FixParamSequence(RID md);

	// these are the map tables to map a method, a field, a property, a event, or a param to its parent
	TOKENMAP	*m_pMethodMap;
	TOKENMAP	*m_pFieldMap;
	TOKENMAP	*m_pPropertyMap;
	TOKENMAP	*m_pEventMap;
	TOKENMAP	*m_pParamMap;

	// This table keep tracks tokens that are marked( or filtered)
	FilterTable *m_pFilterTable;
	IHostFilter *m_pHostFilter;

	// TOKENMAP	*m_pTypeRefToTypeDefMap;
	TokenRemapManager *m_pTokenRemapManager;

	OptionValue	m_OptionValue;

	CMiniMdSchema m_StartupSchema;		// Schema at start time.  Keep count of records.
	ULONG		m_cbStartupPool[MDPoolCount];	// Keep track of initial pool sizes.
	BYTE		m_bSortable[TBL_COUNT];	// Is a given table sortable?  (Can it be reorganized?)

public:

	FilterTable *GetFilterTable();
	HRESULT UnmarkAll();
	HRESULT MarkAll();

	FORCEINLINE IHostFilter *GetHostFilter() { return m_pHostFilter;}

	HRESULT CalculateTypeRefToTypeDefMap();

	FORCEINLINE TOKENMAP *GetTypeRefToTypeDefMap() 
	{ return m_pTokenRemapManager ? m_pTokenRemapManager->GetTypeRefToTypeDefMap() : NULL; };
	
	FORCEINLINE TOKENMAP *GetMemberRefToMemberDefMap() 
	{ return m_pTokenRemapManager ? m_pTokenRemapManager->GetMemberRefToMemberDefMap() : NULL; };
	
	FORCEINLINE MDTOKENMAP *GetTokenMovementMap() 
	{ return m_pTokenRemapManager ? m_pTokenRemapManager->GetTokenMovementMap() : NULL; };
	
	FORCEINLINE TokenRemapManager *GetTokenRemapManager() { return m_pTokenRemapManager; };
	
	HRESULT InitTokenRemapManager();

	virtual ULONG vGetCol(ULONG ixTbl, ULONG ixCol, void *pRecord)
	{ return GetCol(ixTbl, ixCol, pRecord);}

    //*************************************************************************
	// Extension MetaData functions.
public:
	HRESULT ApplyTablesExtension(const void *pBuf, int bReadOnly);
	HRESULT ApplyPoolExtension(int iPool, void *pvData, ULONG cbData, int bReadOnly);

	//*************************************************************************
	// Delta MetaData (EditAndContinue) functions.
public:
	enum eDeltaFuncs{
		eDeltaFuncDefault = 0,
		eDeltaMethodCreate,
		eDeltaFieldCreate,
		eDeltaParamCreate,
		eDeltaPropertyCreate,
		eDeltaEventCreate,
	};

	HRESULT ApplyDelta(CMiniMdRW &mdDelta);

public:
    // Functions for updating ENC log tables ENC log.
    FORCEINLINE BOOL IsENCOn()
    {
        return (m_OptionValue.m_UpdateMode & MDUpdateMask) == MDUpdateENC;
    }

    FORCEINLINE HRESULT UpdateENCLog(mdToken tk, CMiniMdRW::eDeltaFuncs funccode = CMiniMdRW::eDeltaFuncDefault)
    {
        if (IsENCOn())
            return UpdateENCLogHelper(tk, funccode);
        else
            return S_OK;
    }

    FORCEINLINE HRESULT UpdateENCLog2(ULONG ixTbl, ULONG iRid, CMiniMdRW::eDeltaFuncs funccode = CMiniMdRW::eDeltaFuncDefault)
    {
        if (IsENCOn())
            return UpdateENCLogHelper2(ixTbl, iRid, funccode);
        else
            return S_OK;
    }

protected:
    // Internal Helper functions for ENC log.
    HRESULT UpdateENCLogHelper(mdToken tk, CMiniMdRW::eDeltaFuncs funccode);
    HRESULT UpdateENCLogHelper2(ULONG ixTbl, ULONG iRid, CMiniMdRW::eDeltaFuncs funccode);

protected:
	static ULONG m_TruncatedEncTables[];
	static ULONG m_SuppressedDeltaColumns[TBL_COUNT];

	ULONGARRAY	*m_rENCRecs;	// Array of RIDs affected by ENC.

	HRESULT ApplyRecordDelta(CMiniMdRW &mdDelta, ULONG ixTbl, void *pDelta, void *pRecord);
	HRESULT ApplyTableDelta(CMiniMdRW &mdDelta, ULONG ixTbl, RID iRid, int fc);
	void *GetDeltaRecord(ULONG ixTbl, ULONG iRid);
	HRESULT ApplyHeapDeltas(CMiniMdRW &mdDelta);

	HRESULT StartENCMap();				// Call, on a delta MD, to prepare to access sparse rows.
	HRESULT EndENCMap();				// Call, on a delta MD, when done with sparse rows.

}; // class CMiniMdRW : public CMiniMdTemplate<CMiniMdRW>



#endif // _METAMODELRW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\metamodelro.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MetaModelRO.h -- header file for Read-Only compressed COM+ metadata.
//
// Used by the EE.
//
//*****************************************************************************
#ifndef _METAMODELRO_H_
#define _METAMODELRO_H_

#if _MSC_VER >= 1100
 # pragma once
#endif

#include "MetaModel.h"

//*****************************************************************************
// A read-only MiniMd.  This is the fastest and smallest possible MiniMd,
//  and as such, is the preferred EE metadata provider.
//*****************************************************************************
// Pointer to a table.
#define _TBLPTR(tbl) m_pTable[TBL_##tbl##]

template <class MiniMd> class CLiteWeightStgdb;
class CMiniMdRW;
class MDInternalRO;
class CMiniMd : public CMiniMdTemplate<CMiniMd>
{
public:
	friend class CLiteWeightStgdb<CMiniMd>;
	friend class CMiniMdTemplate<CMiniMd>;
	friend class CMiniMdRW;
    friend class MDInternalRO;

	HRESULT InitOnMem(void *pBuf, ULONG ulBufLen);
    HRESULT PostInit(int iLevel);  // higher number : more checking

	FORCEINLINE void *GetUserString(ULONG ix, ULONG *pLen)
	{ return m_USBlobs.GetBlob(ix, pLen); }
protected:
	// Table info.
	BYTE		*m_pTable[TBL_COUNT];
		void SetTablePointers(BYTE *pBase);

	StgPoolReadOnly	m_Guids;			// Heaps
	StgPoolReadOnly	m_Strings;			//  for
	StgBlobPoolReadOnly	m_Blobs;		//   this
	StgBlobPoolReadOnly m_USBlobs;		//    MiniMd

	//*************************************************************************
	// Overridables -- must be provided in derived classes.
	FORCEINLINE LPCUTF8 Impl_GetString(ULONG ix)
	{ return m_Strings.GetStringReadOnly(ix); }
	HRESULT Impl_GetStringW(ULONG ix, LPWSTR szOut, ULONG cchBuffer, ULONG *pcchBuffer);
	FORCEINLINE GUID *Impl_GetGuid(ULONG ix)
	{ return m_Guids.GetGuid(ix); }
	FORCEINLINE void *Impl_GetBlob(ULONG ix, ULONG *pLen)
	{ return m_Blobs.GetBlob(ix, pLen); }

	// Row from RID, RID from row.
	FORCEINLINE void *Impl_GetRow(ULONG ixTbl,ULONG rid) 
	{	// Want a valid RID here.  If this fires, check the calling code for an invalid token.
		_ASSERTE(rid >= 1 && rid <= m_Schema.m_cRecs[ixTbl] && "Caller error:  you passed an invalid token to the metadata!!");
		// Table pointer points before start of data.  Allows using RID as
		// an index, without adjustment.
		return m_pTable[ixTbl] + (rid * m_TableDefs[ixTbl].m_cbRec);
	}
	RID Impl_GetRidForRow(const void *pRow, ULONG ixTbl);

	// Validation.
	int Impl_IsValidPtr(const void *pRow, int ixTbl);

	// Count of rows in tbl2, pointed to by the column in tbl.
	int Impl_GetEndRidForColumn(const void *pRec, int ixtbl, CMiniColDef &def, int ixtbl2);

	FORCEINLINE RID Impl_SearchTable(ULONG ixTbl, CMiniColDef sColumn, ULONG ixCol, ULONG ulTarget)
	{ return vSearchTable(ixTbl, sColumn, ulTarget); }
    
    FORCEINLINE int Impl_IsRo() 
    { return 1; }
	//*************************************************************************

    HRESULT CommonEnumCustomAttributeByName( // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
        bool        fStopAtFirstFind,       // [IN] just find the first one
        HENUMInternal* phEnum);             // enumerator to fill up

    HRESULT CommonGetCustomAttributeByName( // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
	    const void	**ppData,				// [OUT] Put pointer to data here.
	    ULONG		*pcbData);  			// [OUT] Put size of data here.

};


#endif // _METAMODELRO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\recordpool.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// RecordPool.h -- header file for record heaps.
//
//*****************************************************************************
#ifndef _RECORDPOOL_H_
#define _RECORDPOOL_H_

#if _MSC_VER >= 1100
 # pragma once
#endif

#include <StgPool.h>

//*****************************************************************************
// This Record pool class collects user Records into a big consecutive heap.
// The list of Records is kept in memory while adding, and
// finally flushed to a stream at the caller's request.
//*****************************************************************************
class RecordPool : public StgPool
{
public:
	RecordPool() :
		StgPool(1024, 1)
	{ }

//*****************************************************************************
// Init the pool for use.  This is called for the create empty case.
//*****************************************************************************
    HRESULT InitNew(
		ULONG		cbRec,					// Record size.
		ULONG		cRecsInit);				// Initial guess of count of record.

//*****************************************************************************
// Load a Record heap from persisted memory.  If a copy of the data is made
// (so that it may be updated), then a new hash table is generated which can
// be used to elminate duplicates with new Records.
//*****************************************************************************
    HRESULT InitOnMem(	 	                // Return code.
		ULONG			cbRec,				// Record size.
		void			*pData,				// Predefined data.
		ULONG			iSize,				// Size of data.
        RecordOpenFlags bReadOnly);         // true if append is forbidden.

//*****************************************************************************
// Allocate memory if we don't have any, or grow what we have.  If successful,
// then at least iRequired bytes will be allocated.
//*****************************************************************************
	bool Grow(								// true if successful.
		ULONG		iRequired);				// Min required bytes to allocate.

//*****************************************************************************
// The Record will be added to the pool.  The index of the Record in the pool
// is returned in *piIndex.  If the Record is already in the pool, then the
// index will be to the existing copy of the Record.
//*****************************************************************************
	void * AddRecord(						// New record, or NULL.
		ULONG		*piIndex=0);			// [OUT, OPTIONAL] Return index of Record here.

//*****************************************************************************
// Insert a Record into the pool.  The index of the Record before which to
// insert is specified.  Shifts all records down.  Return a pointer to the
// new record.
//*****************************************************************************
	void * InsertRecord(					// New record, or NULL.
		ULONG		iLocation);				// [IN] Insert record before this.

//*****************************************************************************
// Return a pointer to a Record given an index previously handed out by
// AddRecord or FindRecord.
//*****************************************************************************
	virtual void *GetRecord(				// Pointer to Record in pool.
		ULONG		iIndex);				// 1-based index of Record in pool.

//*****************************************************************************
// Given a pointer to a record, determine the index corresponding to the
// record.
//*****************************************************************************
	virtual ULONG GetIndexForRecord(		// 1-based index of Record in pool.
		const void *pRecord);				// Pointer to Record in pool.

//*****************************************************************************
// Given a purported pointer to a record, determine if the pointer is valid.
//*****************************************************************************
	virtual int IsValidPointerForRecord(	// true or false.
		const void *pRecord);				// Pointer to Record in pool.

//*****************************************************************************
// How many objects are there in the pool?  If the count is 0, you don't need
// to persist anything at all to disk.
//*****************************************************************************
	int Count()
	{ return GetNextOffset() / m_cbRec; }

//*****************************************************************************
// Indicate if heap is empty.  This has to be based on the size of the data
// we are keeping.  If you open in r/o mode on memory, there is no hash
// table.
//*****************************************************************************
	virtual int IsEmpty()					// true if empty.
	{ return (GetNextOffset() == 0); }

//*****************************************************************************
// Is the index valid for the Record?
//*****************************************************************************
    virtual int IsValidCookie(ULONG ulCookie)
	{ return (ulCookie == 0 || IsValidOffset((ulCookie-1) * m_cbRec)); }

//*****************************************************************************
// Return the size of the heap.
//*****************************************************************************
    ULONG GetNextIndex()
    { return (GetNextOffset() / m_cbRec); }

//*****************************************************************************
// How big is an offset in this heap.
//*****************************************************************************
	int OffsetSize()
	{
		ULONG cbSaveSize;
		GetSaveSize(&cbSaveSize);
        ULONG iIndex = cbSaveSize / m_cbRec;
		if (iIndex < 0xffff)
			return (sizeof(short));
		else
			return (sizeof(long));
	}

//*****************************************************************************
// Replace the contents of this pool with those from another pool.  The other
//	pool loses ownership of the memory.
//*****************************************************************************
	HRESULT ReplaceContents(
		RecordPool *pOther);				// The other record pool.

//*****************************************************************************
// Return the first record in a pool, and set up a context for fast
//  iterating through the pool.  Note that this scheme does pretty minimal
//  error checking.
//*****************************************************************************
	void *GetFirstRecord(					// Pointer to Record in pool.
		void		**pContext);			// Store context here.

//*****************************************************************************
// Given a pointer to a record, return a pointer to the next record.
//  Note that this scheme does pretty minimal error checking. In particular,
//  this will let the caller walk off of the end of valid data in the last
//  segment.
//*****************************************************************************
	void *GetNextRecord(					// Pointer to Record in pool.
		void		*pRecord,				// Current record.
		void		**pContext);			// Stored context here.

#if defined(_TRACE_SIZE)
	// Prints out information (either verbosely or not, depending on argument) about
	// the contents of this pool.  Returns the total size of this pool.
	virtual ULONG PrintSizeInfo(bool verbose)
	{
		// for the moment, just return size of pool.  In the future, show us the
		// sizes of indiviudual items in this pool.
		ULONG size;
		StgPool::GetSaveSize(&size);
		PrintSize("Record Pool",size);
		return size;
	}
#endif

private:
	ULONG		m_cbRec;				// How large is each record?
};


#endif // _RECORDPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\rwutil.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// RWUtil.h
//
// Contains utility code for MD directory
//
//*****************************************************************************
#ifndef __RWUtil__h__
#define __RWUtil__h__

class UTSemReadWrite;

#define     UTF8STR(pwsz) \
    (pwsz ? Unicode2UTF( (pwsz), (char *) _alloca((wcslen(pwsz)*3) + 1)) : NULL) // *3 for the worst case

//*****************************************************************************
// IMetaDataRegImport methods
//*****************************************************************************
LPUTF8 Unicode2UTF(
    LPCWSTR     pwszSrc,                        // The string to convert.
    LPUTF8      pszDst);                        // The QuickArray<WCHAR> to convert it into.



//*********************************************************************
// The token remap record. 
//*********************************************************************
struct TOKENREC
{
    mdToken     m_tkFrom;                   // The imported token
    bool        m_isDuplicate;              // Is record duplicate? This information is recorded during merge
    bool        m_isDeleted;                // This information is recorded during RegMeta::ProcessFilter when we might have deleted a record
    bool        m_isFoundInImport;          // This information is also recorded during RegMeta::ProcessFilter                 
    mdToken     m_tkTo;                     // The new token in the merged scope

    void SetEmpty() {m_tkFrom = m_tkTo = -1;}
    BOOL IsEmpty() {return m_tkFrom == -1;}
};


//*********************************************************************
//
// This structure keeps track on token remap for an imported scope. This map is initially sorted by from
// tokens. It can then become sorted by To tokens. This usually happen during PreSave remap lookup. Thus
// we assert if we try to look up or sort by From token.
//
//*********************************************************************
class MDTOKENMAP : public CDynArray<TOKENREC> 
{
public:

    enum SortKind{
        Unsorted = 0,
        SortByFromToken = 1,
        SortByToToken = 2,
        Indexed = 3,                    // Indexed by table/rid.  Implies that strings are sorted by "From".
    };

    MDTOKENMAP() 
     :  m_pNextMap(NULL),
        m_pMap(NULL),
        m_iCountTotal(0),
        m_iCountSorted(0),
        m_sortKind(SortKind::SortByFromToken),
        m_iCountIndexed(0)
#if defined(_DEBUG)
       ,m_pImport(0)
#endif    
    { }
    ~MDTOKENMAP();

    HRESULT Init(IUnknown *pImport);
    
    // find a token in the tokenmap. 
    bool Find(mdToken tkFrom, TOKENREC **ppRec);

    // remap a token. We assert if we don't find the tkFind in the table
    HRESULT Remap(mdToken tkFrom, mdToken *ptkTo);

    // Insert a record. This function will keep the inserted record in a sorted sequence
    HRESULT InsertNotFound(mdToken tkFrom, bool fDuplicate, mdToken tkTo, TOKENREC **ppRec);

    // This function will just append the record to the end of the list
    HRESULT AppendRecord(
        mdToken     tkFrom,
        bool        fDuplicate,
        mdToken     tkTo,
        TOKENREC    **ppRec);

    // This is a safe remap. *tpkTo will be tkFind if we cannot find tkFind in the lookup table.
    mdToken SafeRemap(mdToken tkFrom);      // [IN] the token value to find

    bool FindWithToToken(
        mdToken     tkFind,                 // [IN] the token value to find
        int         *piPosition);           // [OUT] return the first from-token that has the matching to-token

    FORCEINLINE void SortTokensByFromToken()
    {
        _ASSERTE(m_sortKind == SortKind::SortByFromToken || m_sortKind == SortKind::Indexed);
        // Only sort if there are unsorted records.
        if (m_iCountSorted < m_iCountTotal)
        {
            SortRangeFromToken(m_iCountIndexed, m_iCountIndexed+m_iCountTotal - 1);
            m_iCountSorted = m_iCountTotal;
        }
    } // void MDTOKENMAP::SortTokensByFromToken()
    void SortTokensByToToken();

    MDTOKENMAP  *m_pNextMap;
    IMapToken   *m_pMap;

private:
    FORCEINLINE int CompareFromToken(       // -1, 0, or 1
        int         iLeft,                  // First item to compare.
        int         iRight)                 // Second item to compare.
    {
        if ( Get(iLeft)->m_tkFrom < Get(iRight)->m_tkFrom )
            return -1;
        if ( Get(iLeft)->m_tkFrom == Get(iRight)->m_tkFrom )
            return 0;
        return 1;
    }

    FORCEINLINE int CompareToToken(         // -1, 0, or 1
        int         iLeft,                  // First item to compare.
        int         iRight)                 // Second item to compare.
    {
        if ( Get(iLeft)->m_tkTo < Get(iRight)->m_tkTo )
            return -1;
        if ( Get(iLeft)->m_tkTo == Get(iRight)->m_tkTo )
            return 0;
        return 1;
    }

    FORCEINLINE void Swap(
        int         iFirst,
        int         iSecond)
    {
        if ( iFirst == iSecond ) return;
        memcpy( &m_buf, Get(iFirst), sizeof(TOKENREC) );
        memcpy( Get(iFirst), Get(iSecond),sizeof(TOKENREC) );
        memcpy( Get(iSecond), &m_buf, sizeof(TOKENREC) );
    }

    void SortRangeFromToken(int iLeft, int iRight);
    void SortRangeToToken(int iLeft, int iRight);

    TOKENREC    m_buf;
    ULONG       m_iCountTotal;              // total entry in the map
    ULONG       m_iCountSorted;             // number of entries that are sorted

    SortKind    m_sortKind;
    
    ULONG       m_TableOffset[TBL_COUNT+1]; // Start of each table in map.
    ULONG       m_iCountIndexed;            // number of entries that are indexed.
#if defined(_DEBUG)
    IMetaDataImport *m_pImport;             // For data validation.
#endif    
};



//*********************************************************************
//
// Merge Token manager. This class is created in GetSaveSize as an agent to 
// notify linker regarding token movements. It does not have the ability to
// keep track token movement.
//
//*********************************************************************
class MergeTokenManager : public IMapToken
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, PVOID *pp);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP Map(mdToken tkImp, mdToken tkEmit);
    MergeTokenManager(MDTOKENMAP *pTkMapList, IUnknown *pHandler);
    ~MergeTokenManager();
private:
    ULONG       m_cRef;
    MDTOKENMAP  *m_pTkMapList;
    IMapToken   *m_pDefaultHostRemap;
};



//*********************************************************************
//
// This CMapToken class implemented the IMapToken. It is used in RegMeta for
// filter process. This class can track all of the tokens are mapped. It also 
// supplies a Find function. 
//
//*********************************************************************
class CMapToken : public IMapToken
{
    friend class RegMeta;

public:
    STDMETHODIMP QueryInterface(REFIID riid, PVOID *pp);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP Map(mdToken tkImp, mdToken tkEmit);
    bool Find(mdToken tkFrom, TOKENREC **pRecTo);
    CMapToken();
    ~CMapToken();
    MDTOKENMAP  *m_pTKMap;
private:
    ULONG       m_cRef;
    bool        m_isSorted;
};


//*********************************************************************
//
// This class records all sorts of token movement during optimization phase.
// This including Ref to Def optimization. This also includes token movement
// due to sorting or eleminating the pointer tables.
//
//*********************************************************************
class TokenRemapManager
{
public:
    //*********************************************************************
    //
    // This function is called when a TypeRef is resolved to a TypeDef.
    //
    //*********************************************************************
    FORCEINLINE void RecordTypeRefToTypeDefOptimization(
        mdToken tkFrom,
        mdToken tkTo)
    {
        _ASSERTE( TypeFromToken(tkFrom) == mdtTypeRef );
        _ASSERTE( TypeFromToken(tkTo) == mdtTypeDef );

        m_TypeRefToTypeDefMap[RidFromToken(tkFrom)] = tkTo;
    }   // RecordTypeRefToTypeDefOptimization


    //*********************************************************************
    //
    // This function is called when a MemberRef is resolved to a MethodDef or FieldDef.
    //
    //*********************************************************************
    FORCEINLINE void RecordMemberRefToMemberDefOptimization(
        mdToken tkFrom,
        mdToken tkTo)
    {
        _ASSERTE( TypeFromToken(tkFrom) == mdtMemberRef );
        _ASSERTE( TypeFromToken(tkTo) == mdtMethodDef || TypeFromToken(tkTo) == mdtFieldDef);

        m_MemberRefToMemberDefMap[RidFromToken(tkFrom)] = tkTo;
    }   // RecordMemberRefToMemberDefOptimization

    //*********************************************************************
    //
    // This function is called when the token kind does not change but token 
    // is moved. For example, when we sort CustomAttribute table or when we optimize
    // away MethodPtr table. These operation will not change the token type. 
    //
    //*********************************************************************
    FORCEINLINE HRESULT RecordTokenMovement(
        mdToken tkFrom, 
        mdToken tkTo)
    {
        TOKENREC    *pTokenRec;

        _ASSERTE( TypeFromToken(tkFrom) == TypeFromToken(tkTo) );
        return m_TKMap.AppendRecord( tkFrom, false, tkTo, &pTokenRec );
    }   // RecordTokenMovement

    bool ResolveRefToDef(
        mdToken tkRef,                      // [IN] ref token
        mdToken *ptkDef);                   // [OUT] def token that it resolves to. If it does not resolve to a def

    FORCEINLINE TOKENMAP *GetTypeRefToTypeDefMap() { return &m_TypeRefToTypeDefMap; }
    FORCEINLINE TOKENMAP *GetMemberRefToMemberDefMap() { return &m_MemberRefToMemberDefMap; }
    FORCEINLINE MDTOKENMAP *GetTokenMovementMap() { return &m_TKMap; }

    ~TokenRemapManager();
    HRESULT ClearAndEnsureCapacity(ULONG cTypeRef, ULONG cMemberRef);
private:
    MDTOKENMAP  m_TKMap;
    TOKENMAP    m_TypeRefToTypeDefMap;
    TOKENMAP    m_MemberRefToMemberDefMap;
};


// value that can be set by SetOption APIs
struct OptionValue
{
    CorCheckDuplicatesFor       m_DupCheck;             // Bit Map for checking duplicates during emit.
    CorRefToDefCheck            m_RefToDefCheck;        // Bit Map for specifying whether to do a ref to def optimization.
    CorNotificationForTokenMovement m_NotifyRemap;  // Bit Map for token remap notification.
    ULONG                       m_UpdateMode;           // (CorSetENC) Specifies whether ENC or Extension mode is on.
    CorErrorIfEmitOutOfOrder    m_ErrorIfEmitOutOfOrder; // Do not generate pointer tables 
    CorThreadSafetyOptions      m_ThreadSafetyOptions;  // specify if thread safety is turn on or not.
    CorImportOptions            m_ImportOption;         // import options such as to skip over deleted items or not
    CorLinkerOptions            m_LinkerOption;         // Linker option. Currently only used in UnmarkAll
    BOOL                        m_GenerateTCEAdapters;  // Do not generate the TCE adapters for COM CPC.
    LPSTR                       m_RuntimeVersion;       // CLR Version stamp
};

#define MD_THREADSAFE       1

//*********************************************************************
//
// Helper class to ensure calling UTSemReadWrite correctly.
// The destructor will call the correct UnlockRead or UnlockWrite depends what lock it is holding.
// User should use macro defined in below instead of calling functions on this class directly.
// They are LOCKREAD(), LOCKWRITE(), and CONVERT_READ_TO_WRITE_LOCK.
//
//*********************************************************************
class CMDSemReadWrite
{
public:
    CMDSemReadWrite(bool fLockedForRead, UTSemReadWrite *pSem);
    ~CMDSemReadWrite();
    void UnlockWrite();
    void ConvertReadLockToWriteLock();
private:
    bool            m_fLockedForRead;
    bool            m_fLockedForWrite;
    UTSemReadWrite  *m_pSem;
};

#if MD_THREADSAFE
#define LOCKREAD()                  CMDSemReadWrite cSem(true, m_pSemReadWrite);
#define LOCKWRITE()                 CMDSemReadWrite cSem(false, m_pSemReadWrite);
#define UNLOCKWRITE()               cSem.UnlockWrite();
#define CONVERT_READ_TO_WRITE_LOCK() cSem.ConvertReadLockToWriteLock();
#else
#define LOCKREAD()    
#define LOCKWRITE()   
#define UNLOCKWRITE() 
#define CONVERT_READ_TO_WRITE_LOCK()  
#endif



#endif // __RWUtil__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\stgtiggerstream.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgTiggerStream.h
//
// TiggerStream is the companion to the TiggerStorage CoClass.  It handles the
// streams managed inside of the storage and does the direct file i/o.
//
//*****************************************************************************
#ifndef __StgTiggerStream_h__
#define __StgTiggerStream_h__



#include "StgTiggerStorage.h"			// Data definitions.

enum
{
	STREAM_DATA_NAME
};


class TiggerStorage;


class TiggerStream : 
	public IStream
{
public:
	TiggerStream() :
		m_pStorage(0),
		m_cRef(1)
	{}

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *pp)
	{ return (BadError(E_NOTIMPL)); }
	virtual ULONG STDMETHODCALLTYPE AddRef()
	{ return (InterlockedIncrement((long *) &m_cRef)); }
	virtual ULONG STDMETHODCALLTYPE Release()
	{
		ULONG	cRef;
		if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
			delete this;
		return (cRef);
	}

// IStream
    virtual HRESULT STDMETHODCALLTYPE Read( 
        void		*pv,
        ULONG		cb,
        ULONG		*pcbRead);
    
    virtual HRESULT STDMETHODCALLTYPE Write( 
        const void	*pv,
        ULONG		cb,
        ULONG		*pcbWritten);

    virtual HRESULT STDMETHODCALLTYPE Seek( 
        LARGE_INTEGER dlibMove,
        DWORD		dwOrigin,
        ULARGE_INTEGER *plibNewPosition);
    
    virtual HRESULT STDMETHODCALLTYPE SetSize( 
        ULARGE_INTEGER libNewSize);
    
    virtual HRESULT STDMETHODCALLTYPE CopyTo( 
        IStream		*pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten);
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        DWORD		grfCommitFlags);
    
    virtual HRESULT STDMETHODCALLTYPE Revert( void);
    
    virtual HRESULT STDMETHODCALLTYPE LockRegion( 
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD		dwLockType);
    
    virtual HRESULT STDMETHODCALLTYPE UnlockRegion( 
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD		dwLockType);
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        STATSTG		*pstatstg,
        DWORD		grfStatFlag);
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        IStream		**ppstm);


	HRESULT Init(							// Return code.
		TiggerStorage *pStorage,			// Parent storage.
		LPCSTR		szStream);				// Stream name.

	ULONG GetStreamSize();

private:
	TiggerStorage	*m_pStorage;		// Our parent storage.
	char			m_rcStream[MAXSTREAMNAME]; // Name of the stream.
	ULONG			m_cRef;				// Ref count.
};

#endif // __StgTiggerStream_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\tokenmapper.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// TokenMapper.h
//
// This helper class tracks mapped tokens from their old value to the new value
// which can happen when the data is optimized on save.
//
//*****************************************************************************
#ifndef __TokenMapper_h__
#define __TokenMapper_h__

#include "utilcode.h"

typedef CDynArray<mdToken> TOKENMAP;

class TokenMapper
{
public:

	enum
	{
		tkixMethodDef,
		tkixMemberRef,
		tkixFieldDef,

		MAX_TOKENMAP
	};

	static int IndexForType(mdToken tk);

//*****************************************************************************
// Called by the meta data engine when a token is remapped to a new location.
// This value is recorded in the m_rgMap array based on type and rid of the
// from token value.
//*****************************************************************************
	HRESULT Map(mdToken tkImp, mdToken tkEmit);

//*****************************************************************************
// Check the given token to see if it has moved to a new location.  If so,
// return true and give back the new token.
//*****************************************************************************
	int HasTokenMoved(mdToken tkFrom, mdToken &tkTo);

	int GetMaxMapSize() const
	{ return (MAX_TOKENMAP); }

	TOKENMAP *GetMapForType(mdToken tkType);

protected:
// m_rgMap is an array indexed by token type.  For each type, an array of
// tokens is kept, indexed by from rid.  To see if a token has been moved,
// do a lookup by type to get the right array, then use the from rid to
// find the to rid.
	TOKENMAP	m_rgMap[MAX_TOKENMAP];
};

#endif // __CeeGenTokenMapper_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\liteweightstgdb.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// LiteWeightStgdb.cpp
//
// This contains definition of class CLiteWeightStgDB. This is light weight
// read-only implementation for accessing compressed meta data format.
//
//*****************************************************************************
#include "stdafx.h" 					// Precompiled header.
#include "MDFileFormat.h"
#include "MetaModelRO.h"
#include "LiteWeightStgdb.h"
#include "MetadataTracker.h"

//*****************************************************************************
// Force generation of specialized versions.  While this may seem to defeat
//	the purpose of templates, it allows us to precisely control the 
//	specializations.  It also keeps the include file smaller.
//*****************************************************************************
void _null()
{
	CLiteWeightStgdb<CMiniMd> RO;
		RO.InitOnMem(0,0);
		RO.Uninit();
}


HRESULT _CallInitOnMemHelper(CLiteWeightStgdb<CMiniMd> *pStgdb, ULONG cbData, LPCVOID pData)
{
    return pStgdb->InitOnMem(cbData,pData);
}

//*****************************************************************************
// Open an in-memory metadata section for read
//*****************************************************************************
template <class MiniMd>
HRESULT CLiteWeightStgdb<MiniMd>::InitOnMem(
	ULONG		cbData,					// count of bytes in pData
	LPCVOID 	pData)					// points to meta data section in memory
{
	STORAGEHEADER sHdr;					// Header for the storage.
	STORAGESTREAM *pStream;				// Pointer to each stream.
	int			bFoundMd = false;		// true when compressed data found.
	int			i;						// Loop control.
	HRESULT		hr = S_OK;

	// Don't double open.
	_ASSERTE(m_pvMd == NULL && m_cbMd == 0);

	// Validate the signature of the format, or it isn't ours.
	if (FAILED(hr = MDFormat::VerifySignature((STORAGESIGNATURE *) pData, cbData)))
		goto ErrExit;

	// Get back the first stream.
	VERIFY(pStream = MDFormat::GetFirstStream(&sHdr, pData));

	// Loop through each stream and pick off the ones we need.
	for (i=0;  i<sHdr.iStreams;  i++)
	{        
		// Pick off the location and size of the data.
		void *pvCurrentData = (void *) ((BYTE *) pData + pStream->iOffset);
		ULONG cbCurrentData = pStream->iSize;


        // Get next stream 
        STORAGESTREAM *pNext = pStream->NextStream();


        // Range check
        if ((LPBYTE) pStream >= (LPBYTE) pData + cbData ||
            (LPBYTE) pNext   >  (LPBYTE) pData + cbData )
        {
            IfFailGo( CLDB_E_FILE_CORRUPT );
        }

        if ( (LPBYTE) pvCurrentData                 >= (LPBYTE) pData + cbData ||
             (LPBYTE) pvCurrentData + cbCurrentData >  (LPBYTE) pData + cbData )
        {
            IfFailGo( CLDB_E_FILE_CORRUPT );
        }

        
        // String pool.
        if (strcmp(pStream->rcName, STRING_POOL_STREAM_A) == 0)
        {
            METADATATRACKER_ONLY(MetaDataTracker::NoteSection(TBL_COUNT + 0, pvCurrentData, cbCurrentData));
            IfFailGo( m_MiniMd.m_Strings.InitOnMemReadOnly(pvCurrentData, cbCurrentData) );
        }

        // Literal String Blob pool.
        else if (strcmp(pStream->rcName, US_BLOB_POOL_STREAM_A) == 0)
        {
            METADATATRACKER_ONLY(MetaDataTracker::NoteSection(TBL_COUNT + 1, pvCurrentData, cbCurrentData));
            IfFailGo( m_MiniMd.m_USBlobs.InitOnMemReadOnly(pvCurrentData, cbCurrentData) );
        }

        // GUID pool.
        else if (strcmp(pStream->rcName, GUID_POOL_STREAM_A) == 0)
        {
            METADATATRACKER_ONLY(MetaDataTracker::NoteSection(TBL_COUNT + 2, pvCurrentData, cbCurrentData));
            IfFailGo( m_MiniMd.m_Guids.InitOnMemReadOnly(pvCurrentData, cbCurrentData) );
        }

        // Blob pool.
        else if (strcmp(pStream->rcName, BLOB_POOL_STREAM_A) == 0)
        {
            METADATATRACKER_ONLY(MetaDataTracker::NoteSection(TBL_COUNT + 3, pvCurrentData, cbCurrentData));
            IfFailGo( m_MiniMd.m_Blobs.InitOnMemReadOnly(pvCurrentData, cbCurrentData) );
        }

        // Found the compressed meta data stream.
        else if (strcmp(pStream->rcName, COMPRESSED_MODEL_STREAM_A) == 0)
        {
            IfFailGo( m_MiniMd.InitOnMem(pvCurrentData, cbCurrentData) );
            bFoundMd = true;
        }

		// Pick off the next stream if there is one.
		pStream = pNext;
	}

	// If the meta data wasn't found, we can't handle this file.
	if (!bFoundMd)
	{
		IfFailGo( CLDB_E_FILE_CORRUPT );
	}
    else
    {   // Validate sensible heaps.
        IfFailGo( m_MiniMd.PostInit(0) );
    }

	// Save off the location.
	m_pvMd = pData;
	m_cbMd = cbData;

ErrExit:
	return (hr);
}


// eof ------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\mdfileformat.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDFileFormat.cpp
//
// This file contains a set of helpers to verify and read the file format.
// This code does not handle the paging of the data, or different types of
// I/O.  See the StgTiggerStorage and StgIO code for this level of support.
//
//*****************************************************************************
#include "StdAfx.h"                     // Standard header file.
#include "MDFileFormat.h"               // The format helpers.
#include "PostError.h"                  // Error handling code.


//*****************************************************************************
// Verify the signature at the front of the file to see what type it is.
//*****************************************************************************
#define STORAGE_MAGIC_OLD_SIG   0x2B4D4F43  // BSJB
HRESULT MDFormat::VerifySignature(
    STORAGESIGNATURE *pSig,             // The signature to check.
    ULONG             cbData)
{
    HRESULT     hr = S_OK;

    // If signature didn't match, you shouldn't be here.
	if (pSig->lSignature == STORAGE_MAGIC_OLD_SIG)
        return (PostError(CLDB_E_FILE_OLDVER, 1, 0));
    if (pSig->lSignature != STORAGE_MAGIC_SIG)
        return (PostError(CLDB_E_FILE_CORRUPT));

    // Check for overflow
    ULONG sum = sizeof(STORAGESIGNATURE) + pSig->iVersionString;
    if (sum < sizeof(STORAGESIGNATURE) || sum < pSig->iVersionString)
        return (PostError(CLDB_E_FILE_CORRUPT));

    // Check for invalid version string size
    if ((sizeof(STORAGESIGNATURE) + pSig->iVersionString) > cbData)
        return (PostError(CLDB_E_FILE_CORRUPT));

    // Check that the version string is null terminated. This string
    // is ANSI, so no double-null checks need to be made.
    {
        BYTE *pStart = &pSig->pVersion[0];
        BYTE *pEnd = pStart + pSig->iVersionString + 1; // Account for terminating NULL

        for (BYTE *pCur = pStart; pCur < pEnd; pCur++)
        {
            if (*pCur == NULL)
                break;
        }

        // If we got to the end without hitting a NULL, we have a bad version string
        if (pCur == pEnd)
            return (PostError(CLDB_E_FILE_CORRUPT));
    }

    // Only a specific version of the 0.x format is supported by this code
    // in order to support the NT 5 beta clients which used this format.
    if (pSig->iMajorVer == FILE_VER_MAJOR_v0)
    { 
        if (pSig->iMinorVer < FILE_VER_MINOR_v0)
            hr = CLDB_E_FILE_OLDVER;
    }
    // There is currently no code to migrate an old format of the 1.x.  This
    // would be added only under special circumstances.
    else if (pSig->iMajorVer != FILE_VER_MAJOR || pSig->iMinorVer != FILE_VER_MINOR)
        hr = CLDB_E_FILE_OLDVER;

    if (FAILED(hr))
        hr = PostError(hr, (int) pSig->iMajorVer, (int) pSig->iMinorVer);
    return (hr);
}

//*****************************************************************************
// Skip over the header and find the actual stream data.
//*****************************************************************************
STORAGESTREAM *MDFormat::GetFirstStream(// Return pointer to the first stream.
    STORAGEHEADER *pHeader,             // Return copy of header struct.
    const void *pvMd)                   // Pointer to the full file.
{
    const BYTE  *pbMd;              // Working pointer.

    // Header data starts after signature.
    pbMd = (const BYTE *) pvMd;
    pbMd += sizeof(STORAGESIGNATURE);
    pbMd += ((STORAGESIGNATURE*)pvMd)->iVersionString;
    STORAGEHEADER *pHdr = (STORAGEHEADER *) pbMd;
    *pHeader = *pHdr;
    pbMd += sizeof(STORAGEHEADER);

    // If there is extra data, skip over it.
    if (pHdr->fFlags & STGHDR_EXTRADATA)
        pbMd = pbMd + sizeof(ULONG) + *(ULONG *) pbMd;

    // The pointer is now at the first stream in the list.
    return ((STORAGESTREAM *) pbMd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\stgtiggerstorage.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgTiggerStorage.h
//
// TiggerStorage is a stripped down version of compound doc files.  Doc files
// have some very useful and complex features to them, unfortunately nothing
// comes for free.  Given the incredibly tuned format of existing .tlb files,
// every single byte counts and 10% added by doc files is just too exspensive.
//
// The storage itself is made up of a bunch of streams (each aligned to a 4 byte
// value), followed at the end of the file with the header.  The header is
// put at the end so that you can continue to write as many streams as you
// like without thrashing the disk.
//  +-------------------+
//  | Signature         |
//  +-------------------+
//  | Stream 1, 2, []   |
//  +-------------------+
//  | STORAGEHEADER     |
//  |   Extra data      |
//  |   STORAGESTREAM[] |
//  +-------------------+
//  | offset            |
//  +-------------------+
//
// The STORAGEHEADER contains flags describing the rest of the file, including
// the ability to have extra data stored in the header.  If there is extra
// data, then immediately after the STORAGEHEADER struct is a 4 byte size of
// that data, followed immediately by the extra data.  The length must be
// 4 byte aligned so that the first STORAGESTREAM starts on an aligned
// boundary.  The contents of the extra data is caller defined.
//
// This code handles the signature at the start of the file, and the list of
// streams at the end (kept in the header).  The data in each stream is, of
// course, caller specific.
//
// This code requires the StgIO code to handle the input and output from the
// backing storage, whatever scheme that may be.  There are no consistency
// checks on the data (for example crc's) due to the expense in computation
// required.  There is a signature at the front of the file and in the header.
//
//*****************************************************************************
#ifndef __StgTiggerStorage_h__
#define __StgTiggerStorage_h__

#pragma once

#include "UtilCode.h"                   // Helpers.

#include "MDFileFormat.h"

typedef CDynArray<STORAGESTREAM> STORAGESTREAMLST;


// Forwards.
class TiggerStream;
class StgIO;



class TiggerStorage : 
    public IStorage
{
friend TiggerStream;
public:
    TiggerStorage();
    ~TiggerStorage();

// IUnknown so you can ref count this thing.
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, PVOID *pp)
    { return (BadError(E_NOTIMPL)); }
    virtual ULONG STDMETHODCALLTYPE AddRef()
    { return (InterlockedIncrement((long *) &m_cRef)); }
    virtual ULONG STDMETHODCALLTYPE Release()
    {
        ULONG   cRef;
        if ((cRef = InterlockedDecrement((long *) &m_cRef)) == 0)
            delete this;
        return (cRef);
    }


//*****************************************************************************
// Init this storage object on top of the given storage unit.
//*****************************************************************************
    HRESULT Init(                           // Return code.
        StgIO       *pStgIO,                // The I/O subsystem.
        LPSTR       pVersion);              // Compiler-supplied CLR version

//*****************************************************************************
// Retrieves a the size and a pointer to the extra data that can optionally be
// written in the header of the storage system.  This data is not required to
// be in the file, in which case *pcbExtra will come back as 0 and pbData will
// be set to null.  You must have initialized the storage using Init() before
// calling this function.
//*****************************************************************************
    HRESULT GetExtraData(                   // Return code.
        ULONG       *pcbExtra,              // Return size of extra data.
        BYTE        *&pbData);              // Return a pointer to extra data.

//*****************************************************************************
// Flushes the header to disk.
//*****************************************************************************
    HRESULT WriteHeader(                    // Return code.
        STORAGESTREAMLST *pList,            // List of streams.     
        ULONG       cbExtraData,            // Size of extra data, may be 0.
        BYTE        *pbExtraData);          // Pointer to extra data for header.

//*****************************************************************************
// Called when all data has been written.  Forces cached data to be flushed
// and stream lists to be validated.
//*****************************************************************************
    HRESULT WriteFinished(                  // Return code.
        STORAGESTREAMLST *pList,            // List of streams.     
        ULONG       *pcbSaveSize);          // Return size of total data.

//*****************************************************************************
// Tells the storage that we intend to rewrite the contents of this file.  The
// entire file will be truncated and the next write will take place at the
// beginning of the file.
//*****************************************************************************
    HRESULT Rewrite(                        // Return code.
        LPWSTR      szBackup);              // If non-0, backup the file.

//*****************************************************************************
// Called after a successful rewrite of an existing file.  The in memory
// backing store is no longer valid because all new data is in memory and
// on disk.  This is essentially the same state as created, so free up some
// working set and remember this state.
//*****************************************************************************
    HRESULT ResetBackingStore();        // Return code.

//*****************************************************************************
// Called to restore the original file.  If this operation is successful, then
// the backup file is deleted as requested.  The restore of the file is done
// in write through mode to the disk help ensure the contents are not lost.
// This is not good enough to fulfill ACID props, but it ain't that bad.
//*****************************************************************************
    HRESULT Restore(                        // Return code.
        LPWSTR      szBackup,               // If non-0, backup the file.
        int         bDeleteOnSuccess);      // Delete backup file if successful.

//*****************************************************************************
// Given the name of a stream that will be persisted into a stream in this
// storage type, figure out how big that stream would be including the user's
// stream data and the header overhead the file format incurs.  The name is
// stored in ANSI and the header struct is aligned to 4 bytes.
//*****************************************************************************
    static HRESULT GetStreamSaveSize(       // Return code.
        LPCWSTR     szStreamName,           // Name of stream.
        ULONG       cbDataSize,             // Size of data to go into stream.
        ULONG       *pcbSaveSize);          // Return data size plus stream overhead.

//*****************************************************************************
// Return the fixed size overhead for the storage implementation.  This includes
// the signature and fixed header overhead.  The overhead in the header for each
// stream is calculated as part of GetStreamSaveSize because these structs are
// variable sized on the name.
//*****************************************************************************
    static HRESULT GetStorageSaveSize(      // Return code.
        ULONG       *pcbSaveSize,           // [in] current size, [out] plus overhead.
        ULONG       cbExtra);               // How much extra data to store in header.

//*****************************************************************************
// Adjust the offset in each known stream to match where it will wind up after
// a save operation.
//*****************************************************************************
    static HRESULT CalcOffsets(             // Return code.
        STORAGESTREAMLST *pStreamList,      // List of streams for header.
        ULONG       cbExtra);               // Size of variable extra data in header.


//*****************************************************************************
// Returns the size of the signature plus the verion information
//*****************************************************************************
    static DWORD SizeOfStorageSignature();

    
//*****************************************************************************
// Spin lock used to obtain the version information from the EE
//*****************************************************************************
    static void EnterStorageLock()
    {
        while(1) {
            if(::InterlockedExchange ((long*)&m_flock, 1) == 1) 
                Sleep(10);
            else
                return;
        }
    }
    
    static void LeaveStorageLock () { InterlockedExchange ((LPLONG)&m_flock, 0); }

// IStorage
    virtual HRESULT STDMETHODCALLTYPE CreateStream( 
        const OLECHAR *pwcsName,
        DWORD       grfMode,
        DWORD       reserved1,
        DWORD       reserved2,
        IStream     **ppstm);

    virtual HRESULT STDMETHODCALLTYPE CreateStream( 
        LPCSTR      szName,
        DWORD       grfMode,
        DWORD       reserved1,
        DWORD       reserved2,
        IStream     **ppstm);
    
    virtual HRESULT STDMETHODCALLTYPE OpenStream( 
        const OLECHAR *pwcsName,
        void        *reserved1,
        DWORD       grfMode,
        DWORD       reserved2,
        IStream     **ppstm);
    
    virtual HRESULT STDMETHODCALLTYPE CreateStorage( 
        const OLECHAR *pwcsName,
        DWORD       grfMode,
        DWORD       dwStgFmt,
        DWORD       reserved2,
        IStorage    **ppstg);
    
    virtual HRESULT STDMETHODCALLTYPE OpenStorage( 
        const OLECHAR *pwcsName,
        IStorage    *pstgPriority,
        DWORD       grfMode,
        SNB         snbExclude,
        DWORD       reserved,
        IStorage    **ppstg);
    
    virtual HRESULT STDMETHODCALLTYPE CopyTo( 
        DWORD       ciidExclude,
        const IID   *rgiidExclude,
        SNB         snbExclude,
        IStorage    *pstgDest);
    
    virtual HRESULT STDMETHODCALLTYPE MoveElementTo( 
        const OLECHAR *pwcsName,
        IStorage    *pstgDest,
        const OLECHAR *pwcsNewName,
        DWORD       grfFlags);
    
    virtual HRESULT STDMETHODCALLTYPE Commit( 
        DWORD       grfCommitFlags);
    
    virtual HRESULT STDMETHODCALLTYPE Revert();
    
    virtual HRESULT STDMETHODCALLTYPE EnumElements( 
        DWORD       reserved1,
        void        *reserved2,
        DWORD       reserved3,
        IEnumSTATSTG **ppenum);
    
    virtual HRESULT STDMETHODCALLTYPE DestroyElement( 
        const OLECHAR *pwcsName);
    
    virtual HRESULT STDMETHODCALLTYPE RenameElement( 
        const OLECHAR *pwcsOldName,
        const OLECHAR *pwcsNewName);
    
    virtual HRESULT STDMETHODCALLTYPE SetElementTimes( 
        const OLECHAR *pwcsName,
        const FILETIME *pctime,
        const FILETIME *patime,
        const FILETIME *pmtime);
    
    virtual HRESULT STDMETHODCALLTYPE SetClass( 
        REFCLSID    clsid);
    
    virtual HRESULT STDMETHODCALLTYPE SetStateBits( 
        DWORD       grfStateBits,
        DWORD       grfMask);
    
    virtual HRESULT STDMETHODCALLTYPE Stat( 
        STATSTG     *pstatstg,
        DWORD       grfStatFlag);

    virtual HRESULT STDMETHODCALLTYPE OpenStream( 
        LPCWSTR     szStream,
        ULONG       *pcbData,
        void        **ppAddress);

    // Access storage object.
    StgIO *GetStgIO()
    { return (m_pStgIO); }

#if defined(_DEBUG)
    ULONG PrintSizeInfo(                // Size of streams.
        bool verbose);                  // Be verbose?
#endif

protected:
    HRESULT Write(                      // Return code.
        LPCSTR      szName,             // Name of stream we're writing.
        const void *pData,              // Data to write.
        ULONG       cbData,             // Size of data.
        ULONG       *pcbWritten);       // How much did we write.

private:
    STORAGESTREAM *FindStream(LPCSTR szName);
    HRESULT WriteSignature();
    HRESULT VerifySignature(STORAGESIGNATURE *pSig);
    HRESULT ReadHeader();
    HRESULT VerifyHeader();

private:
    // State data.
    StgIO       *m_pStgIO;              // Storage subsystem.
    ULONG       m_cRef;                 // Ref count for COM.

    static BYTE        m_Version[_MAX_PATH];
    static DWORD       m_dwVersion;
    static LPSTR       m_szVersion;
    static DWORD       m_flock;

    // Header data.
    STORAGEHEADER m_StgHdr;             // Header for storage.
    STORAGESTREAMLST m_Streams;         // List of streams in the storage.
    STORAGESTREAM *m_pStreamList;       // For read mode.
    void        *m_pbExtra;             // Pointer to extra data if on disk.
};


//*****************************************************************************
// Debugging helpers.  #define __SAVESIZE_TRACE__ to enable.
//*****************************************************************************

// #define __SAVESIZE_TRACE__
#ifdef __SAVESIZE_TRACE__
#define SAVETRACE(func) DEBUG_STMT(func)
#else
#define SAVETRACE(func)
#endif // __SAVESIZE_TRACE__

#endif // StgTiggerStorage



// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\inc\stgio.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// StgIO.h
//
// This module handles disk/memory i/o for a generic set of storage solutions,
// including:
//	* File system handle (HFILE)
//	* IStream
//	* User supplied memory buffer (non-movable)
//
// The Read, Write, Seek, ... functions are all directed to the corresponding
// method for each type of file, allowing the consumer to use one set of api's.
//
// File system data can be paged fully into memory in two scenarios:
//	read:	Normal Win32 memory mapped file is created to manage paging.
//	write:	A custom paging system provides storage for pages as required.  This
//				data is invalidated when you call Rewrite on the file.
//
// Transactions and backups are handled in the existing file case only.  The
// Rewrite function can make a backup of the current contents, and the Restore
// function can be used to recover the data into the current scope.  The backup
// file is flushed to disk (which is slower but safer) after the copy.  The
// Restore also flushed the recovered changes to disk.  Worst case scenario you
// get a crash after calling Rewrite but before Restore, in which case you will
// have a foo.clb.txn file in the same directory as the source file, foo.clb in
// this example.
//
// @FUTURE: issues,
//	1.  For reading a .clb in an image, it would be great to memory map
//		only the portion of the file with the .clb in it.
//
//*****************************************************************************
#pragma once

#define MAXSHMEM					32

#define	STGIO_READ					0x1
#define	STGIO_WRITE					0x2

enum DBPROPMODE
    {	DBPROP_TMODEF_READ	= 0x1,
	DBPROP_TMODEF_WRITE	= 0x2,
	DBPROP_TMODEF_EXCLUSIVE	= 0x4,
	DBPROP_TMODEF_CREATE	= 0x10,
	DBPROP_TMODEF_FAILIFTHERE	= 0x20,
	DBPROP_TMODEF_SLOWSAVE	= 0x100,
	DBPROP_TMODEF_NOTXNBACKUPFILE	= 0x200,
	DBPROP_TMODEF_COMPLUS	= 0x1000,
	DBPROP_TMODEF_SMEMCREATE	= 0x2000,
	DBPROP_TMODEF_SMEMOPEN	= 0x4000,
	DBPROP_TMODEF_RESERVED	= 0x80000000,
	DBPROP_TMODEF_DFTWRITEMASK	= 0x113,
	DBPROP_TMODEF_DFTREADWRITEMASK	= 0x103,
	DBPROP_TMODEF_ALIGNBLOBS	= 0x10000
    };


// Types of IO we can handle.
enum STGIOTYPE
{
	STGIO_NODATA,							// Currently not open.
	STGIO_HFILE,							// File handle contains data.
	STGIO_STREAM,							// Stream pointer has data.
	STGIO_MEM,								// In memory pointer has data.
	STGIO_SHAREDMEM,						// Shared memory handle.
	STGIO_HFILEMEM							// Handle open, but memory allocated.
};


class StgIO
{
public:
	StgIO(
		bool		bAutoMap=true);			// Memory map for read on open?

	~StgIO();

//*****************************************************************************
// Open the base file on top of: (a) file, (b) memory buffer, or (c) stream.
// If create flag is specified, then this will create a new file with the
// name supplied.  No data is read from an opened file.  You must call
// MapFileToMem before doing direct pointer access to the contents.
//*****************************************************************************
	HRESULT Open(							// Return code.
		LPCWSTR		szName,					// Name of the storage.
		long		fFlags,					// How to open the file.
		const void	*pbBuff=0,				// Optional buffer for memory.
		ULONG		cbBuff=0,				// Size of buffer.
		IStream		*pIStream=0,			// Stream for input.
		LPCWSTR		szSharedMem=0,			// Shared memory name.
		LPSECURITY_ATTRIBUTES pAttributes=0); // Security token.

//*****************************************************************************
// Shut down the file handles and allocated objects.
//*****************************************************************************
	void Close();

//*****************************************************************************
// Read data from the storage source.  This will handle all types of backing
// storage from mmf, streams, and file handles.  No read ahead or MRU
// caching is done.
//*****************************************************************************
	HRESULT Read(							// Return code.
		void		*pbBuff,				// Write buffer here.
		ULONG		cbBuff,					// How much to read.
		ULONG		*pcbRead);				// How much read.

//*****************************************************************************
// Write to disk.  This function will cache up to a page of data in a buffer
// and peridocially flush it on overflow and explicit request.  This makes it
// safe to do lots of small writes without too much performance overhead.
//*****************************************************************************
	HRESULT Write(							// Return code.
		const void	*pbBuff,				// Buffer to write.
		ULONG		cbWrite,				// How much.
		ULONG		*pcbWritten);			// Return how much written.

//*****************************************************************************
// Moves the file pointer to the new location.  This handles the different
// types of storage systems.
//*****************************************************************************
	HRESULT Seek(							// New offset.
		long		lVal,					// How much to move.
		ULONG		fMoveType);				// Direction, use Win32 FILE_xxxx.

//*****************************************************************************
// Retrieves the current offset for the storage being used.  This value is
// tracked based on Read, Write, and Seek operations.
//*****************************************************************************
	ULONG GetCurrentOffset();				// Current offset.

//*****************************************************************************
// Map the file contents to a memory mapped file and return a pointer to the 
// data.  For read/write with a backing store, map the file using an internal
// paging system.
//*****************************************************************************
	HRESULT MapFileToMem(					// Return code.
		void		*&ptr,					// Return pointer to file data.
		ULONG		*pcbSize,				// Return size of data.
		LPSECURITY_ATTRIBUTES pAttributes=0); // Security token.

//*****************************************************************************
// Free the mapping object for shared memory but keep the rest of the internal
// state intact.
//*****************************************************************************
	HRESULT ReleaseMappingObject();			// Return code.

//*****************************************************************************
// Resets the logical base address and size to the value given.  This is for
// cases like finding a section embedded in another format, like the .clb inside
// of an image.  GetPtrForMem, Read, and Seek will then behave as though only
// data from pbStart to cbSize is valid.
//*****************************************************************************
	HRESULT SetBaseRange(					// Return code.
		void		*pbStart,				// Start of file data.
		ULONG		cbSize);				// How big is the range.

//*****************************************************************************
// For read/write case, get a pointer to a chunk of the file at cbStart for
// size cbSize.  Return the pointer.  This will page in parts of the file from
// disk if not already loaded.
//*****************************************************************************
	HRESULT GetPtrForMem(					// Return code.
		ULONG		cbStart,				// Offset from beginning to load.
		ULONG		cbSize,					// How much, rounded to page.
		void		*&ptr);					// Return pointer on success.

//*****************************************************************************
// For cached writes, flush the cache to the data store.
//*****************************************************************************
	HRESULT FlushCache();

//*****************************************************************************
// Tells the Win32 file system to flush any cached data it may have.  This is
// expensive, but if successful guarantees you won't loose writes short of
// a disk failure.
//*****************************************************************************
	HRESULT FlushFileBuffers();

//*****************************************************************************
// Tells the storage that we intend to rewrite the contents of this file.  The
// entire file will be truncated and the next write will take place at the
// beginning of the file.
//*****************************************************************************
	HRESULT Rewrite(						// Return code.
		LPWSTR		szBackup);				// If non-0, backup the file.

//*****************************************************************************
// Called after a successful rewrite of an existing file.  The in memory
// backing store is no longer valid because all new data is in memory and
// on disk.  This is essentially the same state as created, so free up some
// working set and remember this state.
//*****************************************************************************
	HRESULT ResetBackingStore();			// Return code.

//*****************************************************************************
// Called to restore the original file.  If this operation is successful, then
// the backup file is deleted as requested.  The restore of the file is done
// in write through mode to the disk help ensure the contents are not lost.
// This is not good enough to fulfill ACID props, but it ain't that bad.
//*****************************************************************************
	HRESULT Restore(						// Return code.
		LPWSTR		szBackup,				// If non-0, backup the file.
		int			bDeleteOnSuccess);		// Delete backup file if successful.

	LPCWSTR GetFileName()
	{ return (m_rcFile); }

	int IsReadOnly()
	{ return ((m_fFlags & STGIO_WRITE) == 0); }

	ULONG GetFlags()
	{ return (m_fFlags); }

	ULONG SetFlags(ULONG fFlags)
	{ m_fFlags = fFlags;
		return (m_fFlags); }

	ULONG GetDataSize()
	{ return (m_cbData); }

	long AddRef()
	{
		return (++m_cRef);
	}

	long Release()
	{
		long cRef = --m_cRef;
		if (cRef == 0)
			delete this;
		return (cRef);
	}

	int IsAlignedPtr(ULONG Value, int iAlignment);

private:
	int IsBackingStore()
	{ return (m_rgPageMap != 0); }
	int IsMemoryMapped()
	{ return (m_hMapping != 0); }

	void CtorInit();
	HRESULT WriteToDisk(const void *pbBuff, ULONG cbWrite, ULONG *pcbWritten);
	HRESULT ReadFromDisk(void *pbBuff, ULONG cbBuff, ULONG *pcbRead);
	HRESULT CopyFileInternal(LPCWSTR szTo, int bFailIfThere, int bWriteThrough);
	void FreePageMap();

private:
	// Flags and state data.
	WCHAR		m_rcFile[_MAX_PATH];	// Path of the file we manage.
	WCHAR		m_rcShared[MAXSHMEM];	// Name of shared memory segment.
	long		m_cRef;					// Ref count on this object.
	bool		m_bWriteThrough : 1;	// true for write through mode.
	bool		m_bRewrite : 1;			// State check for rewrite mode.
	bool		m_bAutoMap : 1;			// true to automatically memory map file.
	bool		m_bFreeMem : 1;			// true to free allocated memory.

	// Handles.
	CComPtr<IStream> m_pIStream;		// For save to stream instead of file.
	HANDLE		m_hFile;				// The actual file with contents.
	HANDLE		m_hMapping;				// Mapping handle.
	void		*m_pBaseData;			// Base address for memory mapped file.
	void		*m_pData;				// For memory mapped file read.
	ULONG		m_cbData;				// Size of in memory data.
	long		m_fFlags;				// Flags for open/create mode.
	STGIOTYPE	m_iType;				// Where is the data.

	// File cache information.
	BYTE		*m_rgBuff;				// Cache buffer for writing.
	ULONG		m_cbBuff;				// Current cache size.
	ULONG		m_cbOffset;				// Current offset in file.

	// Buffer read management.
	static int	m_iPageSize;			// Size of an OS page.
	static int	m_iCacheSize;			// How big a write back cache to use.
	BYTE		*m_rgPageMap;			// Track loaded pages on read/write.
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\mdinternaldisp.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
//  File: MDInternalDisp.CPP
//  Notes:
//      
//
// ===========================================================================
#include "stdafx.h"
#include "MDInternalDisp.h"
#include "MDInternalRO.h"
#include "posterror.h"
#include "corpriv.h"
#include "AssemblyMDInternalDisp.h"
#include "fusionsink.h"

// forward declaration
HRESULT GetInternalWithRWFormat(
    LPVOID      pData, 
    ULONG       cbData, 
    DWORD       flags,                  // [IN] MDInternal_OpenForRead or MDInternal_OpenForENC
    REFIID      riid,                   // [in] The interface desired.
    void        **ppIUnk);              // [out] Return interface on success.

//*****************************************************************************
// CheckFileFormat
// This function will determine if the in-memory image is a readonly, readwrite,
// or ICR format.
//*****************************************************************************
HRESULT CheckFileFormat(
    LPVOID      pData, 
    ULONG       cbData, 
    MDFileFormat *pFormat)                  // [OUT] the file format
{
    HRESULT     hr = NOERROR;
    STORAGEHEADER sHdr;                 // Header for the storage.
    STORAGESTREAM *pStream;             // Pointer to each stream.
    int         bFoundMd = false;       // true when compressed data found.
    int         i;                      // Loop control.

    _ASSERTE( pFormat );

    *pFormat = MDFormat_Invalid;

    // Validate the signature of the format, or it isn't ours.
    if (FAILED(hr = MDFormat::VerifySignature((STORAGESIGNATURE *) pData, cbData)))
        goto ErrExit;

    // Get back the first stream.
    VERIFY(pStream = MDFormat::GetFirstStream(&sHdr, pData));

    // Loop through each stream and pick off the ones we need.
    for (i=0;  i<sHdr.iStreams;  i++)
    {
        STORAGESTREAM *pNext = pStream->NextStream();

        // Check that stream header is within the buffer.
        if ((LPBYTE) pStream >= (LPBYTE) pData + cbData ||
            (LPBYTE) pNext   >  (LPBYTE) pData + cbData )
        {
            hr = CLDB_E_FILE_CORRUPT;
            goto ErrExit;
        }

        // Check that the stream data starts and fits within the buffer.
        //  need two checks on size because of wraparound.
        if (pStream->iOffset > cbData   ||
            pStream->iSize > cbData     ||
            (pStream->iSize + pStream->iOffset) > cbData)
        {
            hr = CLDB_E_FILE_CORRUPT;
            goto ErrExit;
        }


        // Pick off the location and size of the data.
        
        if (strcmp(pStream->rcName, COMPRESSED_MODEL_STREAM_A) == 0)
        {
            // Validate that only one of compressed/uncompressed is present.
            if (*pFormat != MDFormat_Invalid)
            {   // Already found a good stream.    
                hr = CLDB_E_FILE_CORRUPT;            
                goto ErrExit;
            }
            // Found the compressed meta data stream.
            *pFormat = MDFormat_ReadOnly;
        }
        else if (strcmp(pStream->rcName, ENC_MODEL_STREAM_A) == 0)
        {
            // Validate that only one of compressed/uncompressed is present.
            if (*pFormat != MDFormat_Invalid)
            {   // Already found a good stream.    
                hr = CLDB_E_FILE_CORRUPT;            
                goto ErrExit;
            }
            // Found the ENC meta data stream.
            *pFormat = MDFormat_ReadWrite;
        }
        else if (strcmp(pStream->rcName, SCHEMA_STREAM_A) == 0)
        {
            // Found the uncompressed format
            *pFormat = MDFormat_ICR;

            // keep going. We may find the compressed format later. 
            // If so, we want to use the compressed format.
        }

        // Pick off the next stream if there is one.
        pStream = pNext;
    }
    

    if (*pFormat == MDFormat_Invalid)
    {   // Didn't find a good stream.    
        hr = CLDB_E_FILE_CORRUPT;            
    }

ErrExit:
    return hr;
}   // CheckFileFormat



//*****************************************************************************
// GetMDInternalInterface.
// This function will check the metadata section and determine if it should
// return an interface which implements ReadOnly or ReadWrite.
//*****************************************************************************
STDAPI GetMDInternalInterface(
    LPVOID      pData, 
    ULONG       cbData, 
    DWORD       flags,                  // [IN] ofRead or ofWrite.
    REFIID      riid,                   // [in] The interface desired.
    void        **ppIUnk)               // [out] Return interface on success.
{
    HRESULT     hr = NOERROR;
    MDInternalRO *pInternalRO = NULL;
    MDFileFormat format;

    if (ppIUnk == NULL)
        IfFailGo(E_INVALIDARG);

    // Technically this isn't required by the meta data code, but there turn out
    // to be a bunch of tools that don't init themselves properly.  Rather than
    // adding this to n clients, there is one here that calls pretty much up front.
    // The cost is basically the call instruction and one test in the target, so
    // we're not burning much space/time here.
    //
    OnUnicodeSystem();

    // Determine the file format we're trying to read.
    IfFailGo( CheckFileFormat(pData, cbData, &format) );

    // Found a fully-compressed, read-only format.
    if ( format == MDFormat_ReadOnly )
    {
        pInternalRO = new MDInternalRO;
        IfNullGo( pInternalRO );

        IfFailGo( pInternalRO->Init(const_cast<void*>(pData), cbData) );
        IfFailGo( pInternalRO->QueryInterface(riid, ppIUnk) );
    }
    else
    {
        // Found a not-fully-compressed, ENC format.
        _ASSERTE( format == MDFormat_ReadWrite );
        IfFailGo( GetInternalWithRWFormat( pData, cbData, flags, riid, ppIUnk ) );
    }

ErrExit:

    // clean up
    if ( pInternalRO )
        pInternalRO->Release();
    return hr;
}   // GetMDInternalInterface

inline HRESULT MapFileError(DWORD error)
{
    return (PostError(HRESULT_FROM_WIN32(error)));
}

extern "C" 
{
HRESULT FindImageMetaData(PVOID pImage, PVOID *ppMetaData, long *pcbMetaData, DWORD dwFileLength);
}

//*****************************************************************************
// GetAssemblyMDInternalImport.
// Instantiating an instance of AssemblyMDInternalImport.
// This class can support the IMetaDataAssemblyImport and some funcationalities 
// of IMetaDataImport on the internal import interface (IMDInternalImport).
//*****************************************************************************
STDAPI GetAssemblyMDInternalImport(            // Return code.
    LPCWSTR     szFileName,             // [in] The scope to open.
    REFIID      riid,                   // [in] The interface desired.
    IUnknown    **ppIUnk)               // [out] Return interface on success.
{
    HRESULT     hr;
    LONG cbData;
    LPVOID pData;
    HCORMODULE hModule;
    LPVOID base = NULL;
    BOOL fSetBase = FALSE;

    // Validate that there is some sort of file name.
    if (!szFileName || !szFileName[0] || !ppIUnk)
        return E_INVALIDARG;
    
    // Sanity check the name.
    if (lstrlenW(szFileName) >= _MAX_PATH)
        return E_INVALIDARG;
    
    if (memcmp(szFileName, L"file:", 10) == 0)
        szFileName = &szFileName[5];
    
    CorLoadFlags imageType;
    DWORD dwFileLength;
    if (SUCCEEDED(hr = RuntimeOpenImageInternal(szFileName, &hModule, &dwFileLength))) 
    {
        imageType = RuntimeImageType(hModule);
        IfFailGo(RuntimeOSHandle(hModule, (HMODULE*) &base));
    }
    else
        return hr;

    switch(imageType) 
    {
    case CorLoadDataMap:
    case CorLoadOSMap:
        IfFailGo(FindImageMetaData(base, &pData, &cbData, dwFileLength));
        break;
    case CorLoadImageMap:
    case CorLoadOSImage:
    case CorReLoadOSMap:
        {
            IMAGE_DOS_HEADER* pDOS;
            IMAGE_NT_HEADERS* pNT;
            IMAGE_COR20_HEADER* pCorHeader;

            IfFailGo(RuntimeReadHeaders((PBYTE) base, &pDOS, &pNT, &pCorHeader, FALSE, 0));

            pData = pCorHeader->MetaData.VirtualAddress + (PBYTE) base;
            cbData = pCorHeader->MetaData.Size;
            break; 
        }
    default:
        IfFailGo(HRESULT_FROM_WIN32(ERROR_BAD_FORMAT));
    }

    IMDInternalImport *pMDInternalImport;
    IfFailGo(GetMDInternalInterface (pData, cbData, 0, IID_IMDInternalImport, (void **)&pMDInternalImport));

    AssemblyMDInternalImport *pAssemblyMDInternalImport = new AssemblyMDInternalImport (pMDInternalImport);
    IfFailGo(pAssemblyMDInternalImport->QueryInterface (riid, (void**)ppIUnk));

    pAssemblyMDInternalImport->SetHandle(hModule);

    if (fSetBase)
        pAssemblyMDInternalImport->SetBase(base);
    
ErrExit:

    // Check for errors and clean up.
    if (FAILED(hr)) 
    {
        if (fSetBase) 
        {
            UnmapViewOfFile(base);
            CloseHandle(hModule);
        }
        else if(hModule) 
            RuntimeReleaseHandle(hModule);
    }
    return (hr);
}

AssemblyMDInternalImport::AssemblyMDInternalImport (IMDInternalImport *pMDInternalImport)
: m_pMDInternalImport(pMDInternalImport), 
    m_cRef(0), 
    m_pHandle(0),
    m_pBase(NULL)
{
} // AssemblyMDInternalImport

AssemblyMDInternalImport::~AssemblyMDInternalImport () 
{
    m_pMDInternalImport->Release();

    if (m_pBase) 
    {
        UnmapViewOfFile(m_pBase);
        m_pBase = NULL;
        CloseHandle(m_pHandle);
    }
    else if(m_pHandle) 
    {
        HRESULT hr = RuntimeReleaseHandle(m_pHandle);
        _ASSERTE(SUCCEEDED(hr));
    }

    m_pHandle = NULL;
}

ULONG AssemblyMDInternalImport::AddRef()
{
    return (InterlockedIncrement((long *) &m_cRef));
} // ULONG AssemblyMDInternalImport::AddRef()

ULONG AssemblyMDInternalImport::Release()
{
    ULONG   cRef = InterlockedDecrement((long *) &m_cRef);
    if (!cRef)
        delete this;
    return (cRef);
} // ULONG AssemblyMDInternalImport::Release()

HRESULT AssemblyMDInternalImport::QueryInterface(REFIID riid, void **ppUnk)
{ 
    *ppUnk = 0;

    if (riid == IID_IUnknown)
        *ppUnk = (IUnknown *) (IMetaDataAssemblyImport *) this;
    else if (riid == IID_IMetaDataAssemblyImport)
        *ppUnk = (IMetaDataAssemblyImport *) this;
    else if (riid ==     IID_IMetaDataImport)
        *ppUnk = (IMetaDataImport *) this;
    else if (riid == IID_IAssemblySignature)
        *ppUnk = (IAssemblySignature *) this;
    else
        return (E_NOINTERFACE);
    AddRef();
    return (S_OK);
}


STDAPI AssemblyMDInternalImport::GetAssemblyProps (      // S_OK or error.
    mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
    const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
    ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
    ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
    LPWSTR      szName,                 // [OUT] Buffer to fill with name.
    ULONG       cchName,                // [IN] Size of buffer in wide chars.
    ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
    ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
    DWORD       *pdwAssemblyFlags)      // [OUT] Flags.
{
    LPCSTR      _szName;
    AssemblyMetaDataInternal _AssemblyMetaData;
    
    _AssemblyMetaData.ulProcessor = 0;
    _AssemblyMetaData.ulOS = 0;

    m_pMDInternalImport->GetAssemblyProps (
        mda,                            // [IN] The Assembly for which to get the properties.
        ppbPublicKey,                   // [OUT] Pointer to the public key.
        pcbPublicKey,                   // [OUT] Count of bytes in the public key.
        pulHashAlgId,                   // [OUT] Hash Algorithm.
        &_szName,                       // [OUT] Buffer to fill with name.
        &_AssemblyMetaData,             // [OUT] Assembly MetaData.
        pdwAssemblyFlags);              // [OUT] Flags.

    if (pchName)
    {
        *pchName = WszMultiByteToWideChar(CP_UTF8, 0, _szName, -1, szName, cchName);
        if (*pchName == 0)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    pMetaData->usMajorVersion = _AssemblyMetaData.usMajorVersion;
    pMetaData->usMinorVersion = _AssemblyMetaData.usMinorVersion;
    pMetaData->usBuildNumber = _AssemblyMetaData.usBuildNumber;
    pMetaData->usRevisionNumber = _AssemblyMetaData.usRevisionNumber;
    pMetaData->ulProcessor = 0;
    pMetaData->ulOS = 0;

    pMetaData->cbLocale = WszMultiByteToWideChar(CP_UTF8, 0, _AssemblyMetaData.szLocale, -1, pMetaData->szLocale, pMetaData->cbLocale);
    if (pMetaData->cbLocale == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    
    return S_OK;
}

STDAPI AssemblyMDInternalImport::GetAssemblyRefProps (   // S_OK or error.
    mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
    const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
    ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
    LPWSTR      szName,                 // [OUT] Buffer to fill with name.
    ULONG       cchName,                // [IN] Size of buffer in wide chars.
    ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
    ASSEMBLYMETADATA *pMetaData,        // [OUT] Assembly MetaData.
    const void  **ppbHashValue,         // [OUT] Hash blob.
    ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
    DWORD       *pdwAssemblyRefFlags)   // [OUT] Flags.
{
    LPCSTR      _szName;
    AssemblyMetaDataInternal _AssemblyMetaData;
    
    _AssemblyMetaData.ulProcessor = 0;
    _AssemblyMetaData.ulOS = 0;

    m_pMDInternalImport->GetAssemblyRefProps (
        mdar,                           // [IN] The Assembly for which to get the properties.
        ppbPublicKeyOrToken,            // [OUT] Pointer to the public key or token.
        pcbPublicKeyOrToken,            // [OUT] Count of bytes in the public key or token.
        &_szName,                       // [OUT] Buffer to fill with name.
        &_AssemblyMetaData,             // [OUT] Assembly MetaData.
        ppbHashValue,                   // [OUT] Hash blob.
        pcbHashValue,                   // [OUT] Count of bytes in the hash blob.
        pdwAssemblyRefFlags);           // [OUT] Flags.

    if (pchName)
    {
        *pchName = WszMultiByteToWideChar(CP_UTF8, 0, _szName, -1, szName, cchName);
        if (*pchName == 0)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    pMetaData->usMajorVersion = _AssemblyMetaData.usMajorVersion;
    pMetaData->usMinorVersion = _AssemblyMetaData.usMinorVersion;
    pMetaData->usBuildNumber = _AssemblyMetaData.usBuildNumber;
    pMetaData->usRevisionNumber = _AssemblyMetaData.usRevisionNumber;
    pMetaData->ulProcessor = 0;
    pMetaData->ulOS = 0;

    pMetaData->cbLocale = WszMultiByteToWideChar(CP_UTF8, 0, _AssemblyMetaData.szLocale, -1, pMetaData->szLocale, pMetaData->cbLocale);
    if (pMetaData->cbLocale == 0)
        return HRESULT_FROM_WIN32(GetLastError());
    
    return S_OK;
}

STDAPI AssemblyMDInternalImport::GetFileProps (          // S_OK or error.
    mdFile      mdf,                    // [IN] The File for which to get the properties.
    LPWSTR      szName,                 // [OUT] Buffer to fill with name.
    ULONG       cchName,                // [IN] Size of buffer in wide chars.
    ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
    const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
    ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
    DWORD       *pdwFileFlags)          // [OUT] Flags.
{
    LPCSTR      _szName;
    m_pMDInternalImport->GetFileProps (
        mdf,
        &_szName,
        ppbHashValue,
        pcbHashValue,
        pdwFileFlags);

    if (pchName)
    {
        *pchName = WszMultiByteToWideChar(CP_UTF8, 0, _szName, -1, szName, cchName);
        if (*pchName == 0)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}

STDAPI AssemblyMDInternalImport::GetExportedTypeProps (  // S_OK or error.
    mdExportedType   mdct,              // [IN] The ExportedType for which to get the properties.
    LPWSTR      szName,                 // [OUT] Buffer to fill with name.
    ULONG       cchName,                // [IN] Size of buffer in wide chars.
    ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
    mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef or mdExportedType.
    mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
    DWORD       *pdwExportedTypeFlags)       // [OUT] Flags.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetManifestResourceProps (    // S_OK or error.
    mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
    LPWSTR      szName,                 // [OUT] Buffer to fill with name.
    ULONG       cchName,                // [IN] Size of buffer in wide chars.
    ULONG       *pchName,               // [OUT] Actual # of wide chars in name.
    mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ManifestResource.
    DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
    DWORD       *pdwResourceFlags)      // [OUT] Flags.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumAssemblyRefs (      // S_OK or error
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdAssemblyRef rAssemblyRefs[],      // [OUT] Put AssemblyRefs here.
    ULONG       cMax,                   // [IN] Max AssemblyRefs to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    HENUMInternal       *pEnum;

    if (*ppmdEnum == 0)
    {
        // create the enumerator.
        IfFailGo(HENUMInternal::CreateSimpleEnum(
            mdtAssemblyRef,
            0,
            1,
            &pEnum) );

        m_pMDInternalImport->EnumInit(mdtAssemblyRef, 0, pEnum);

        // set the output parameter.
        *ppmdEnum = pEnum;
    }
    else
        pEnum = *ppmdEnum;

    // we can only fill the minimum of what the caller asked for or what we have left.
    IfFailGo(HENUMInternal::EnumWithCount(pEnum, cMax, rAssemblyRefs, pcTokens));
ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);
    
    return hr;
}

STDAPI AssemblyMDInternalImport::EnumFiles (             // S_OK or error
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdFile      rFiles[],               // [OUT] Put Files here.
    ULONG       cMax,                   // [IN] Max Files to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    HENUMInternal       **ppmdEnum = reinterpret_cast<HENUMInternal **> (phEnum);
    HRESULT             hr = NOERROR;
    HENUMInternal       *pEnum;

    if (*ppmdEnum == 0)
    {
        // create the enumerator.
        IfFailGo(HENUMInternal::CreateSimpleEnum(
            mdtFile,
            0,
            1,
            &pEnum) );

        m_pMDInternalImport->EnumInit(mdtFile, 0, pEnum);

        // set the output parameter.
        *ppmdEnum = pEnum;
    }
    else
        pEnum = *ppmdEnum;

    // we can only fill the minimum of what the caller asked for or what we have left.
    IfFailGo(HENUMInternal::EnumWithCount(pEnum, cMax, rFiles, pcTokens));

ErrExit:
    HENUMInternal::DestroyEnumIfEmpty(ppmdEnum);    
    return hr;
}

STDAPI AssemblyMDInternalImport::EnumExportedTypes (     // S_OK or error
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdExportedType   rExportedTypes[],  // [OUT] Put ExportedTypes here.
    ULONG       cMax,                   // [IN] Max ExportedTypes to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumManifestResources ( // S_OK or error
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.
    mdManifestResource  rManifestResources[],   // [OUT] Put ManifestResources here.
    ULONG       cMax,                   // [IN] Max Resources to put.
    ULONG       *pcTokens)              // [OUT] Put # put here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetAssemblyFromScope (  // S_OK or error
    mdAssembly  *ptkAssembly)           // [OUT] Put token here.
{
    return m_pMDInternalImport->GetAssemblyFromScope (ptkAssembly);
}

STDAPI AssemblyMDInternalImport::FindExportedTypeByName (// S_OK or error
    LPCWSTR     szName,                 // [IN] Name of the ExportedType.
    mdToken     mdtExportedType,        // [IN] ExportedType for the enclosing class.
    mdExportedType   *ptkExportedType)       // [OUT] Put the ExportedType token here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::FindManifestResourceByName (  // S_OK or error
    LPCWSTR     szName,                 // [IN] Name of the ManifestResource.
    mdManifestResource *ptkManifestResource)        // [OUT] Put the ManifestResource token here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

void AssemblyMDInternalImport::CloseEnum (
    HCORENUM hEnum)                     // Enum to be closed.
{
    HENUMInternal   *pmdEnum = reinterpret_cast<HENUMInternal *> (hEnum);

    if (pmdEnum == NULL)
        return;

    HENUMInternal::DestroyEnum(pmdEnum);
}

STDAPI AssemblyMDInternalImport::FindAssembliesByName (  // S_OK or error
    LPCWSTR  szAppBase,                 // [IN] optional - can be NULL
    LPCWSTR  szPrivateBin,              // [IN] optional - can be NULL
    LPCWSTR  szAssemblyName,            // [IN] required - this is the assembly you are requesting
    IUnknown *ppIUnk[],                 // [OUT] put IMetaDataAssemblyImport pointers here
    ULONG    cMax,                      // [IN] The max number to put
    ULONG    *pcAssemblies)             // [OUT] The number of assemblies returned.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::CountEnum (HCORENUM hEnum, ULONG *pulCount) 
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::ResetEnum (HCORENUM hEnum, ULONG ulPos)      
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumTypeDefs (HCORENUM *phEnum, mdTypeDef rTypeDefs[],
                        ULONG cMax, ULONG *pcTypeDefs)      
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumInterfaceImpls (HCORENUM *phEnum, mdTypeDef td,
                        mdInterfaceImpl rImpls[], ULONG cMax,
                        ULONG* pcImpls)      
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumTypeRefs (HCORENUM *phEnum, mdTypeRef rTypeRefs[],
                        ULONG cMax, ULONG* pcTypeRefs)      
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::FindTypeDefByName (           // S_OK or error.
    LPCWSTR     szTypeDef,              // [IN] Name of the Type.
    mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef for Enclosing class.
    mdTypeDef   *ptd)                   // [OUT] Put the TypeDef token here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetScopeProps (               // S_OK or error.
    LPWSTR      szName,                 // [OUT] Put the name here.
    ULONG       cchName,                // [IN] Size of name buffer in wide chars.
    ULONG       *pchName,               // [OUT] Put size of name (wide chars) here.
    GUID        *pmvid)                 // [OUT, OPTIONAL] Put MVID here.
{
    LPCSTR      _szName;
    
    if (!m_pMDInternalImport->IsValidToken(m_pMDInternalImport->GetModuleFromScope()))
        return COR_E_BADIMAGEFORMAT;

    m_pMDInternalImport->GetScopeProps(&_szName, pmvid);

    if (pchName)
    {
        *pchName = WszMultiByteToWideChar(CP_UTF8, 0, _szName, -1, szName, cchName);
        if (*pchName == 0)
            return HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;

}

STDAPI AssemblyMDInternalImport::GetModuleFromScope (          // S_OK.
    mdModule    *pmd)                   // [OUT] Put mdModule token here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetTypeDefProps (             // S_OK or error.
    mdTypeDef   td,                     // [IN] TypeDef token for inquiry.
    LPWSTR      szTypeDef,              // [OUT] Put name here.
    ULONG       cchTypeDef,             // [IN] size of name buffer in wide chars.
    ULONG       *pchTypeDef,            // [OUT] put size of name (wide chars) here.
    DWORD       *pdwTypeDefFlags,       // [OUT] Put flags here.
    mdToken     *ptkExtends)            // [OUT] Put base class TypeDef/TypeRef here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetInterfaceImplProps (       // S_OK or error.
    mdInterfaceImpl iiImpl,             // [IN] InterfaceImpl token.
    mdTypeDef   *pClass,                // [OUT] Put implementing class token here.
    mdToken     *ptkIface)              // [OUT] Put implemented interface token here.              
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetTypeRefProps (             // S_OK or error.
    mdTypeRef   tr,                     // [IN] TypeRef token.
    mdToken     *ptkResolutionScope,    // [OUT] Resolution scope, ModuleRef or AssemblyRef.
    LPWSTR      szName,                 // [OUT] Name of the TypeRef.
    ULONG       cchName,                // [IN] Size of buffer.
    ULONG       *pchName)               // [OUT] Size of Name.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::ResolveTypeRef (mdTypeRef tr, REFIID riid, IUnknown **ppIScope, mdTypeDef *ptd)      
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumMembers (                 // S_OK, S_FALSE, or error. 
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
    mdToken     rMembers[],             // [OUT] Put MemberDefs here.   
    ULONG       cMax,                   // [IN] Max MemberDefs to put.  
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumMembersWithName (         // S_OK, S_FALSE, or error.             
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
    mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
    LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
    mdToken     rMembers[],             // [OUT] Put MemberDefs here.                   
    ULONG       cMax,                   // [IN] Max MemberDefs to put.              
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumMethods (                 // S_OK, S_FALSE, or error. 
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
    mdMethodDef rMethods[],             // [OUT] Put MethodDefs here.   
    ULONG       cMax,                   // [IN] Max MethodDefs to put.  
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumMethodsWithName (         // S_OK, S_FALSE, or error.             
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
    mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
    LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
    mdMethodDef rMethods[],             // [OU] Put MethodDefs here.    
    ULONG       cMax,                   // [IN] Max MethodDefs to put.              
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumFields (                 // S_OK, S_FALSE, or error.  
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
    mdFieldDef  rFields[],              // [OUT] Put FieldDefs here.    
    ULONG       cMax,                   // [IN] Max FieldDefs to put.   
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumFieldsWithName (         // S_OK, S_FALSE, or error.              
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.                
    mdTypeDef   cl,                     // [IN] TypeDef to scope the enumeration.   
    LPCWSTR     szName,                 // [IN] Limit results to those with this name.              
    mdFieldDef  rFields[],              // [OUT] Put MemberDefs here.                   
    ULONG       cMax,                   // [IN] Max MemberDefs to put.              
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}


STDAPI AssemblyMDInternalImport::EnumParams (                  // S_OK, S_FALSE, or error. 
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
    mdParamDef  rParams[],              // [OUT] Put ParamDefs here.    
    ULONG       cMax,                   // [IN] Max ParamDefs to put.   
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumMemberRefs (              // S_OK, S_FALSE, or error. 
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdToken     tkParent,               // [IN] Parent token to scope the enumeration.  
    mdMemberRef rMemberRefs[],          // [OUT] Put MemberRefs here.   
    ULONG       cMax,                   // [IN] Max MemberRefs to put.  
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumMethodImpls (             // S_OK, S_FALSE, or error  
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
    mdToken     rMethodBody[],          // [OUT] Put Method Body tokens here.   
    mdToken     rMethodDecl[],          // [OUT] Put Method Declaration tokens here.
    ULONG       cMax,                   // [IN] Max tokens to put.  
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumPermissionSets (          // S_OK, S_FALSE, or error. 
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdToken     tk,                     // [IN] if !NIL, token to scope the enumeration.    
    DWORD       dwActions,              // [IN] if !0, return only these actions.   
    mdPermission rPermission[],         // [OUT] Put Permissions here.  
    ULONG       cMax,                   // [IN] Max Permissions to put. 
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::FindMember (  
    mdTypeDef   td,                     // [IN] given typedef   
    LPCWSTR     szName,                 // [IN] member name 
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
    mdToken     *pmb)                   // [OUT] matching memberdef 
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::FindMethod (  
    mdTypeDef   td,                     // [IN] given typedef   
    LPCWSTR     szName,                 // [IN] member name 
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
    mdMethodDef *pmb)                   // [OUT] matching memberdef 
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::FindField (   
    mdTypeDef   td,                     // [IN] given typedef   
    LPCWSTR     szName,                 // [IN] member name 
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
    mdFieldDef  *pmb)                   // [OUT] matching memberdef 
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::FindMemberRef (   
    mdTypeRef   td,                     // [IN] given typeRef   
    LPCWSTR     szName,                 // [IN] member name 
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature 
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob    
    mdMemberRef *pmr)                   // [OUT] matching memberref 
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetMethodProps ( 
    mdMethodDef mb,                     // The method for which to get props.   
    mdTypeDef   *pClass,                // Put method's class here. 
    LPWSTR      szMethod,               // Put method's name here.  
    ULONG       cchMethod,              // Size of szMethod buffer in wide chars.   
    ULONG       *pchMethod,             // Put actual size here 
    DWORD       *pdwAttr,               // Put flags here.  
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
    ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
    ULONG       *pulCodeRVA,            // [OUT] codeRVA    
    DWORD       *pdwImplFlags)          // [OUT] Impl. Flags    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetMemberRefProps (           // S_OK or error.   
    mdMemberRef mr,                     // [IN] given memberref 
    mdToken     *ptk,                   // [OUT] Put classref or classdef here. 
    LPWSTR      szMember,               // [OUT] buffer to fill for member's name   
    ULONG       cchMember,              // [IN] the count of char of szMember   
    ULONG       *pchMember,             // [OUT] actual count of char in member name    
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to meta data blob value  
    ULONG       *pbSig)                 // [OUT] actual size of signature blob  
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumProperties (              // S_OK, S_FALSE, or error. 
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
    mdProperty  rProperties[],          // [OUT] Put Properties here.   
    ULONG       cMax,                   // [IN] Max properties to put.  
    ULONG       *pcProperties)          // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumEvents (                  // S_OK, S_FALSE, or error. 
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdTypeDef   td,                     // [IN] TypeDef to scope the enumeration.   
    mdEvent     rEvents[],              // [OUT] Put events here.   
    ULONG       cMax,                   // [IN] Max events to put.  
    ULONG       *pcEvents)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetEventProps (               // S_OK, S_FALSE, or error. 
    mdEvent     ev,                     // [IN] event token 
    mdTypeDef   *pClass,                // [OUT] typedef containing the event declarion.    
    LPCWSTR     szEvent,                // [OUT] Event name 
    ULONG       cchEvent,               // [IN] the count of wchar of szEvent   
    ULONG       *pchEvent,              // [OUT] actual count of wchar for event's name 
    DWORD       *pdwEventFlags,         // [OUT] Event flags.   
    mdToken     *ptkEventType,          // [OUT] EventType class    
    mdMethodDef *pmdAddOn,              // [OUT] AddOn method of the event  
    mdMethodDef *pmdRemoveOn,           // [OUT] RemoveOn method of the event   
    mdMethodDef *pmdFire,               // [OUT] Fire method of the event   
    mdMethodDef rmdOtherMethod[],       // [OUT] other method of the event  
    ULONG       cMax,                   // [IN] size of rmdOtherMethod  
    ULONG       *pcOtherMethod)         // [OUT] total number of other method of this event 
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumMethodSemantics (         // S_OK, S_FALSE, or error. 
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdMethodDef mb,                     // [IN] MethodDef to scope the enumeration. 
    mdToken     rEventProp[],           // [OUT] Put Event/Property here.   
    ULONG       cMax,                   // [IN] Max properties to put.  
    ULONG       *pcEventProp)           // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetMethodSemantics (          // S_OK, S_FALSE, or error. 
    mdMethodDef mb,                     // [IN] method token    
    mdToken     tkEventProp,            // [IN] event/property token.   
    DWORD       *pdwSemanticsFlags)       // [OUT] the role flags for the method/propevent pair 
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetClassLayout ( 
    mdTypeDef   td,                     // [IN] give typedef    
    DWORD       *pdwPackSize,           // [OUT] 1, 2, 4, 8, or 16  
    COR_FIELD_OFFSET rFieldOffset[],    // [OUT] field offset array 
    ULONG       cMax,                   // [IN] size of the array   
    ULONG       *pcFieldOffset,         // [OUT] needed array size  
    ULONG       *pulClassSize)              // [OUT] the size of the class  
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetFieldMarshal (    
    mdToken     tk,                     // [IN] given a field's memberdef   
    PCCOR_SIGNATURE *ppvNativeType,     // [OUT] native type of this field  
    ULONG       *pcbNativeType)         // [OUT] the count of bytes of *ppvNativeType   
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetRVA (                      // S_OK or error.   
    mdToken     tk,                     // Member for which to set offset   
    ULONG       *pulCodeRVA,            // The offset   
    DWORD       *pdwImplFlags)          // the implementation flags 
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetPermissionSetProps (  
    mdPermission pm,                    // [IN] the permission token.   
    DWORD       *pdwAction,             // [OUT] CorDeclSecurity.   
    void const  **ppvPermission,        // [OUT] permission blob.   
    ULONG       *pcbPermission)         // [OUT] count of bytes of pvPermission.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetSigFromToken (             // S_OK or error.   
    mdSignature mdSig,                  // [IN] Signature token.    
    PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.   
    ULONG       *pcbSig)                // [OUT] return size of signature.  
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetModuleRefProps (           // S_OK or error.   
    mdModuleRef mur,                    // [IN] moduleref token.    
    LPWSTR      szName,                 // [OUT] buffer to fill with the moduleref name.    
    ULONG       cchName,                // [IN] size of szName in wide characters.  
    ULONG       *pchName)               // [OUT] actual count of characters in the name.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumModuleRefs (              // S_OK or error.   
    HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
    mdModuleRef rModuleRefs[],          // [OUT] put modulerefs here.   
    ULONG       cmax,                   // [IN] max memberrefs to put.  
    ULONG       *pcModuleRefs)          // [OUT] put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetTypeSpecFromToken (        // S_OK or error.   
    mdTypeSpec typespec,                // [IN] TypeSpec token.    
    PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to TypeSpec signature  
    ULONG       *pcbSig)                // [OUT] return size of signature.  
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetNameFromToken (            // Not Recommended! May be removed!
    mdToken     tk,                     // [IN] Token to get name from.  Must have a name.
    MDUTF8CSTR  *pszUtf8NamePtr)        // [OUT] Return pointer to UTF8 name in heap.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumUnresolvedMethods (       // S_OK, S_FALSE, or error. 
    HCORENUM    *phEnum,                // [IN|OUT] Pointer to the enum.    
    mdToken     rMethods[],             // [OUT] Put MemberDefs here.   
    ULONG       cMax,                   // [IN] Max MemberDefs to put.  
    ULONG       *pcTokens)              // [OUT] Put # put here.    
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetUserString (               // S_OK or error.
    mdString    stk,                    // [IN] String token.
    LPWSTR      szString,               // [OUT] Copy of string.
    ULONG       cchString,              // [IN] Max chars of room in szString.
    ULONG       *pchString)             // [OUT] How many chars in actual string.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetPinvokeMap (               // S_OK or error.
    mdToken     tk,                     // [IN] FieldDef or MethodDef.
    DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
    LPWSTR      szImportName,           // [OUT] Import name.
    ULONG       cchImportName,          // [IN] Size of the name buffer.
    ULONG       *pchImportName,         // [OUT] Actual number of characters stored.
    mdModuleRef *pmrImportDLL)          // [OUT] ModuleRef token for the target DLL.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumSignatures (              // S_OK or error.
    HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
    mdSignature rSignatures[],          // [OUT] put signatures here.   
    ULONG       cmax,                   // [IN] max signatures to put.  
    ULONG       *pcSignatures)          // [OUT] put # put here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumTypeSpecs (               // S_OK or error.
    HCORENUM    *phEnum,                // [IN|OUT] pointer to the enum.    
    mdTypeSpec  rTypeSpecs[],           // [OUT] put TypeSpecs here.   
    ULONG       cmax,                   // [IN] max TypeSpecs to put.  
    ULONG       *pcTypeSpecs)           // [OUT] put # put here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumUserStrings (             // S_OK or error.
    HCORENUM    *phEnum,                // [IN/OUT] pointer to the enum.
    mdString    rStrings[],             // [OUT] put Strings here.
    ULONG       cmax,                   // [IN] max Strings to put.
    ULONG       *pcStrings)             // [OUT] put # put here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetParamForMethodIndex (      // S_OK or error.
    mdMethodDef md,                     // [IN] Method token.
    ULONG       ulParamSeq,             // [IN] Parameter sequence.
    mdParamDef  *ppd)                   // [IN] Put Param token here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::EnumCustomAttributes (        // S_OK or error.
    HCORENUM    *phEnum,                // [IN, OUT] COR enumerator.
    mdToken     tk,                     // [IN] Token to scope the enumeration, 0 for all.
    mdToken     tkType,                 // [IN] Type of interest, 0 for all.
    mdCustomAttribute rCustomAttributes[], // [OUT] Put custom attribute tokens here.
    ULONG       cMax,                   // [IN] Size of rCustomAttributes.
    ULONG       *pcCustomAttributes)        // [OUT, OPTIONAL] Put count of token values here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetCustomAttributeProps (     // S_OK or error.
    mdCustomAttribute cv,               // [IN] CustomAttribute token.
    mdToken     *ptkObj,                // [OUT, OPTIONAL] Put object token here.
    mdToken     *ptkType,               // [OUT, OPTIONAL] Put AttrType token here.
    void const  **ppBlob,               // [OUT, OPTIONAL] Put pointer to data here.
    ULONG       *pcbSize)               // [OUT, OPTIONAL] Put size of date here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::FindTypeRef (   
    mdToken     tkResolutionScope,      // [IN] ModuleRef, AssemblyRef or TypeRef.
    LPCWSTR     szName,                 // [IN] TypeRef Name.
    mdTypeRef   *ptr)                   // [OUT] matching TypeRef.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetMemberProps (  
    mdToken     mb,                     // The member for which to get props.   
    mdTypeDef   *pClass,                // Put member's class here. 
    LPWSTR      szMember,               // Put member's name here.  
    ULONG       cchMember,              // Size of szMember buffer in wide chars.   
    ULONG       *pchMember,             // Put actual size here 
    DWORD       *pdwAttr,               // Put flags here.  
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
    ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
    ULONG       *pulCodeRVA,            // [OUT] codeRVA    
    DWORD       *pdwImplFlags,          // [OUT] Impl. Flags    
    DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
    void const  **ppValue,              // [OUT] constant value 
    ULONG       *pcchValue)             // [OUT] size of constant string in chars, 0 for non-strings.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetFieldProps (  
    mdFieldDef  mb,                     // The field for which to get props.    
    mdTypeDef   *pClass,                // Put field's class here.  
    LPWSTR      szField,                // Put field's name here.   
    ULONG       cchField,               // Size of szField buffer in wide chars.    
    ULONG       *pchField,              // Put actual size here 
    DWORD       *pdwAttr,               // Put flags here.  
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to the blob value of meta data   
    ULONG       *pcbSigBlob,            // [OUT] actual size of signature blob  
    DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
    void const  **ppValue,              // [OUT] constant value 
    ULONG       *pcchValue)             // [OUT] size of constant string in chars, 0 for non-strings.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetPropertyProps (            // S_OK, S_FALSE, or error. 
    mdProperty  prop,                   // [IN] property token  
    mdTypeDef   *pClass,                // [OUT] typedef containing the property declarion. 
    LPCWSTR     szProperty,             // [OUT] Property name  
    ULONG       cchProperty,            // [IN] the count of wchar of szProperty    
    ULONG       *pchProperty,           // [OUT] actual count of wchar for property name    
    DWORD       *pdwPropFlags,          // [OUT] property flags.    
    PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob 
    ULONG       *pbSig,                 // [OUT] count of bytes in *ppvSig  
    DWORD       *pdwCPlusTypeFlag,      // [OUT] flag for value type. selected ELEMENT_TYPE_*   
    void const  **ppDefaultValue,       // [OUT] constant value 
    ULONG       *pcchDefaultValue,      // [OUT] size of constant string in chars, 0 for non-strings.
    mdMethodDef *pmdSetter,             // [OUT] setter method of the property  
    mdMethodDef *pmdGetter,             // [OUT] getter method of the property  
    mdMethodDef rmdOtherMethod[],       // [OUT] other method of the property   
    ULONG       cMax,                   // [IN] size of rmdOtherMethod  
    ULONG       *pcOtherMethod)         // [OUT] total number of other method of this property  
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetParamProps (               // S_OK or error.
    mdParamDef  tk,                     // [IN]The Parameter.
    mdMethodDef *pmd,                   // [OUT] Parent Method token.
    ULONG       *pulSequence,           // [OUT] Parameter sequence.
    LPWSTR      szName,                 // [OUT] Put name here.
    ULONG       cchName,                // [OUT] Size of name buffer.
    ULONG       *pchName,               // [OUT] Put actual size of name here.
    DWORD       *pdwAttr,               // [OUT] Put flags here.
    DWORD       *pdwCPlusTypeFlag,      // [OUT] Flag for value type. selected ELEMENT_TYPE_*.
    void const  **ppValue,              // [OUT] Constant value.
    ULONG       *pcchValue)             // [OUT] size of constant string in chars, 0 for non-strings.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetCustomAttributeByName (    // S_OK or error.
    mdToken     tkObj,                  // [IN] Object with Custom Attribute.
    LPCWSTR     szName,                 // [IN] Name of desired Custom Attribute.
    const void  **ppData,               // [OUT] Put pointer to data here.
    ULONG       *pcbData)               // [OUT] Put size of data here.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

BOOL AssemblyMDInternalImport::IsValidToken (         // True or False.
    mdToken     tk)                     // [IN] Given token.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetNestedClassProps (         // S_OK or error.
    mdTypeDef   tdNestedClass,          // [IN] NestedClass token.
    mdTypeDef   *ptdEnclosingClass)       // [OUT] EnclosingClass token.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::GetNativeCallConvFromSig (    // S_OK or error.
    void const  *pvSig,                 // [IN] Pointer to signature.
    ULONG       cbSig,                  // [IN] Count of signature bytes.
    ULONG       *pCallConv)             // [OUT] Put calling conv here (see CorPinvokemap).                                                                                        
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

STDAPI AssemblyMDInternalImport::IsGlobal (                    // S_OK or error.
    mdToken     pd,                     // [IN] Type, Field, or Method token.
    int         *pbGlobal)              // [OUT] Put 1 if global, 0 otherwise.
{
    _ASSERTE(!"NYI");
    return E_NOTIMPL;
}

// *** IAssemblySignature methods ***
STDAPI AssemblyMDInternalImport::GetAssemblySignature(        // S_OK - should not fail
    BYTE        *pbSig,                 // [IN, OUT] Buffer to write signature
    DWORD       *pcbSig)                // [IN, OUT] Size of buffer, bytes written
{
    HRESULT hr = RuntimeGetAssemblyStrongNameHashForModule(m_pHandle, pbSig, pcbSig);

    // In this limited scenario, this means that this assembly is delay signed and
    // so we'll use the assembly MVID as the hash and leave assembly verification
    // up to the loader to determine if delay signed assemblys are allowed.
    // This allows us to fix the perf degrade observed with the hashing code and
    // detailed in BUG 126760

    // We do this here rather than in RuntimeGetAssemblyStrongNameHashForModule
    // because here we have the metadata interface.

    if (hr == CORSEC_E_INVALID_STRONGNAME)
    {
        if (pcbSig)
        {
            if (pbSig)
            {
                // @TODO:HACK: This is a hack because fusion is expecting at least 20 bytes of data.
                if (max(sizeof(GUID), 20) <= *pcbSig)
                {
                    memset(pbSig, 0, *pcbSig);
                    hr = GetScopeProps(NULL, 0, NULL, (GUID *) pbSig);
                }
                else
                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }
            *pcbSig = max(sizeof(GUID), 20);
        }
    }

    _ASSERTE(SUCCEEDED(hr) || hr == CORSEC_E_MISSING_STRONGNAME);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\mdinternalro.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDInternalRO.h
//
// Contains utility code for MD directory
//
//*****************************************************************************
#ifndef __MDInternalRO__h__
#define __MDInternalRO__h__

#define REMOVE_THIS     1


class MDInternalRO : public IMDInternalImport
{
public:

    MDInternalRO();
    ~MDInternalRO();
    HRESULT Init(LPVOID pData, ULONG cbData);

    // *** IUnknown methods ***
    STDMETHODIMP    QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef(void); 
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP TranslateSigWithScope(
        IMDInternalImport *pAssemImport,    // [IN] import assembly scope.
        const void  *pbHashValue,           // [IN] hash value for the import assembly.
        ULONG       cbHashValue,            // [IN] count of bytes in the hash value.
        PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
        ULONG       cbSigBlob,              // [IN] count of bytes of signature
        IMetaDataAssemblyEmit *pAssemEmit,  // [IN] assembly emit scope.
        IMetaDataEmit *emit,                // [IN] emit interface
        CQuickBytes *pqkSigEmit,            // [OUT] buffer to hold translated signature
        ULONG       *pcbSig);               // [OUT] count of bytes in the translated signature

    STDMETHODIMP_(IMetaModelCommon*) GetMetaModelCommon()
    {
        return static_cast<IMetaModelCommon*>(&m_LiteWeightStgdb.m_MiniMd);
    }

    //*****************************************************************************
    // return the count of entries of a given kind in a scope 
    // For example, pass in mdtMethodDef will tell you how many MethodDef 
    // contained in a scope
    //*****************************************************************************
    STDMETHODIMP_(ULONG) GetCountWithTokenKind(// return hresult
        DWORD       tkKind);                // [IN] pass in the kind of token. 

    //*****************************************************************************
    // enumerator for typedef
    //*****************************************************************************
    STDMETHODIMP EnumTypeDefInit(           // return hresult
        HENUMInternal *phEnum);             // [OUT] buffer to fill for enumerator data

    STDMETHODIMP_(ULONG) EnumTypeDefGetCount(
        HENUMInternal *phEnum);             // [IN] the enumerator to retrieve information  

    STDMETHODIMP_(void) EnumTypeDefReset(
        HENUMInternal *phEnum);             // [IN] the enumerator to retrieve information  

    STDMETHODIMP_(bool) EnumTypeDefNext(    // return hresult
        HENUMInternal *phEnum,              // [IN] input enum
        mdTypeDef   *ptd);                  // [OUT] return token

    STDMETHODIMP_(void) EnumTypeDefClose(
        HENUMInternal *phEnum);             // [IN] the enumerator to retrieve information  

    //*****************************************************************************
    // enumerator for MethodImpl
    //*****************************************************************************
    STDMETHODIMP EnumMethodImplInit(        // return hresult
        mdTypeDef       td,                 // [IN] TypeDef over which to scope the enumeration.
        HENUMInternal   *phEnumBody,        // [OUT] buffer to fill for enumerator data for MethodBody tokens.
        HENUMInternal   *phEnumDecl);       // [OUT] buffer to fill for enumerator data for MethodDecl tokens.

    STDMETHODIMP_(ULONG) EnumMethodImplGetCount(
        HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.  
        HENUMInternal   *phEnumDecl);       // [IN] MethodDecl enumerator.

    STDMETHODIMP_(void) EnumMethodImplReset(
        HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.
        HENUMInternal   *phEnumDecl);       // [IN] MethodDecl enumerator.

    STDMETHODIMP_(bool) EnumMethodImplNext( // return hresult
        HENUMInternal   *phEnumBody,        // [IN] input enum for MethodBody
        HENUMInternal   *phEnumDecl,        // [IN] input enum for MethodDecl
        mdToken         *ptkBody,           // [OUT] return token for MethodBody
        mdToken         *ptkDecl);          // [OUT] return token for MethodDecl

    STDMETHODIMP_(void) EnumMethodImplClose(
        HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.
        HENUMInternal   *phEnumDecl);       // [IN] MethodDecl enumerator.

    //*****************************************
    // Enumerator helpers for memberdef, memberref, interfaceimp,
    // event, property, param, methodimpl
    //***************************************** 

    STDMETHODIMP EnumGlobalFunctionsInit(   // return hresult
        HENUMInternal   *phEnum);           // [OUT] buffer to fill for enumerator data

    STDMETHODIMP EnumGlobalFieldsInit(      // return hresult
        HENUMInternal   *phEnum);           // [OUT] buffer to fill for enumerator data

    STDMETHODIMP EnumInit(                  // return S_FALSE if record not found
        DWORD       tkKind,                 // [IN] which table to work on
        mdToken     tkParent,               // [IN] token to scope the search
        HENUMInternal *phEnum);             // [OUT] the enumerator to fill 

    STDMETHODIMP EnumAllInit(               // return S_FALSE if record not found
        DWORD       tkKind,                 // [IN] which table to work on
        HENUMInternal *phEnum);             // [OUT] the enumerator to fill 

    STDMETHODIMP_(bool) EnumNext(
        HENUMInternal *phEnum,              // [IN] the enumerator to retrieve information  
        mdToken     *ptk);                  // [OUT] token to scope the search

    STDMETHODIMP_(ULONG) EnumGetCount(
        HENUMInternal *phEnum);             // [IN] the enumerator to retrieve information  

    STDMETHODIMP_(void) EnumReset(
        HENUMInternal *phEnum);             // [IN] the enumerator to be reset  

    STDMETHODIMP_(void) EnumClose(
        HENUMInternal *phEnum);             // [IN] the enumerator to be closed

    STDMETHODIMP EnumPermissionSetsInit(    // return S_FALSE if record not found
        mdToken     tkParent,               // [IN] token to scope the search
        CorDeclSecurity Action,             // [IN] Action to scope the search
        HENUMInternal *phEnum);             // [OUT] the enumerator to fill 

    STDMETHODIMP EnumCustomAttributeByNameInit(// return S_FALSE if record not found
        mdToken     tkParent,               // [IN] token to scope the search
        LPCSTR      szName,                 // [IN] CustomAttribute's name to scope the search
        HENUMInternal *phEnum);             // [OUT] the enumerator to fill 

    STDMETHODIMP GetParentToken(
        mdToken     tkChild,                // [IN] given child token
        mdToken     *ptkParent);            // [OUT] returning parent

    STDMETHODIMP_(void) GetCustomAttributeProps(
        mdCustomAttribute at,               // [IN] The attribute.
        mdToken     *ptkType);              // [OUT] Put attribute type here.

    STDMETHODIMP_(void) GetCustomAttributeAsBlob(
        mdCustomAttribute cv,               // [IN] given custom attribute token
        void const  **ppBlob,               // [OUT] return the pointer to internal blob
        ULONG       *pcbSize);              // [OUT] return the size of the blob

    STDMETHODIMP GetCustomAttributeByName(  // S_OK or error.
        mdToken     tkObj,                  // [IN] Object with Custom Attribute.
        LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
        const void  **ppData,               // [OUT] Put pointer to data here.
        ULONG       *pcbData);              // [OUT] Put size of data here.

    STDMETHODIMP_(void) GetScopeProps(
        LPCSTR      *pszName,               // [OUT] scope name
        GUID        *pmvid);                // [OUT] version id

    // finding a particular method 
    STDMETHODIMP FindMethodDef(
        mdTypeDef   classdef,               // [IN] given typedef
        LPCSTR      szName,                 // [IN] member name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        mdMethodDef *pmd);                  // [OUT] matching memberdef

    // return a iSeq's param given a MethodDef
    STDMETHODIMP FindParamOfMethod(         // S_OK or error.
        mdMethodDef md,                     // [IN] The owning method of the param.
        ULONG       iSeq,                   // [IN] The sequence # of the param.
        mdParamDef  *pparamdef);            // [OUT] Put ParamDef token here.

    //*****************************************
    //
    // GetName* functions
    //
    //*****************************************

    // return the name and namespace of typedef
    STDMETHODIMP_(void) GetNameOfTypeDef(
        mdTypeDef   classdef,               // given classdef
        LPCSTR      *pszname,               // return class name(unqualified)
        LPCSTR      *psznamespace);         // return the name space name

    STDMETHODIMP GetIsDualOfTypeDef(
        mdTypeDef   classdef,               // [IN] given classdef.
        ULONG       *pDual);                // [OUT] return dual flag here.

    STDMETHODIMP GetIfaceTypeOfTypeDef(
        mdTypeDef   classdef,               // [IN] given classdef.
        ULONG       *pIface);               // [OUT] 0=dual, 1=vtable, 2=dispinterface

    // get the name of either methoddef
    STDMETHODIMP_(LPCSTR) GetNameOfMethodDef(   // return the name of the memberdef in UTF8
        mdMethodDef md);                    // given memberdef

    STDMETHODIMP_(LPCSTR) GetNameAndSigOfMethodDef(
        mdMethodDef methoddef,              // [IN] given memberdef
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
        ULONG       *pcbSigBlob);           // [OUT] count of bytes in the signature blob

    // return the name of a FieldDef
    STDMETHODIMP_(LPCSTR) GetNameOfFieldDef(
        mdFieldDef  fd);                    // given memberdef

    // return the name of typeref
    STDMETHODIMP_(void) GetNameOfTypeRef(
        mdTypeRef   classref,               // [IN] given typeref
        LPCSTR      *psznamespace,          // [OUT] return typeref name
        LPCSTR      *pszname);              // [OUT] return typeref namespace

    // return the resolutionscope of typeref
    STDMETHODIMP_(mdToken) GetResolutionScopeOfTypeRef(
        mdTypeRef   classref);              // given classref

    // return the typeref token given the name.
    STDMETHODIMP FindTypeRefByName(
        LPCSTR      szNamespace,            // [IN] Namespace for the TypeRef.
        LPCSTR      szName,                 // [IN] Name of the TypeRef.
        mdToken     tkResolutionScope,      // [IN] Resolution Scope fo the TypeRef.
        mdTypeRef   *ptk);                  // [OUT] TypeRef token returned.

    // return the TypeDef properties
    STDMETHODIMP_(void) GetTypeDefProps(    // return hresult
        mdTypeDef   classdef,               // given classdef
        DWORD       *pdwAttr,               // return flags on class, tdPublic, tdAbstract
        mdToken     *ptkExtends);           // [OUT] Put base class TypeDef/TypeRef here.

    // return the item's guid
    STDMETHODIMP GetItemGuid(               // return hresult
        mdToken     tkObj,                  // [IN] given item.
        CLSID       *pGuid);                // [OUT] Put guid here.

    // get enclosing class of NestedClass.
    STDMETHODIMP GetNestedClassProps(       // S_OK or error
        mdTypeDef   tkNestedClass,          // [IN] NestedClass token.
        mdTypeDef   *ptkEnclosingClass);    // [OUT] EnclosingClass token.

    // Get count of Nested classes given the enclosing class.
    STDMETHODIMP_(ULONG)GetCountNestedClasses(  // return count of Nested classes.
        mdTypeDef   tkEnclosingClass);      // [IN]Enclosing class.

    // Return array of Nested classes given the enclosing class.
    STDMETHODIMP_(ULONG) GetNestedClasses(  // Return actual count.
        mdTypeDef   tkEnclosingClass,       // [IN] Enclosing class.
        mdTypeDef   *rNestedClasses,        // [OUT] Array of nested class tokens.
        ULONG       ulNestedClasses);       // [IN] Size of array.

    // return the ModuleRef properties
    STDMETHODIMP_(void) GetModuleRefProps(
        mdModuleRef mur,                    // [IN] moduleref token
        LPCSTR      *pszName);              // [OUT] buffer to fill with the moduleref name

    //*****************************************
    //
    // GetSig* functions
    //
    //*****************************************
    STDMETHODIMP_(PCCOR_SIGNATURE) GetSigOfMethodDef(
        mdMethodDef methoddef,              // [IN] given memberdef
        ULONG       *pcbSigBlob);           // [OUT] count of bytes in the signature blob

    STDMETHODIMP_(PCCOR_SIGNATURE) GetSigOfFieldDef(
        mdMethodDef methoddef,              // [IN] given memberdef
        ULONG       *pcbSigBlob);           // [OUT] count of bytes in the signature blob

    STDMETHODIMP_(PCCOR_SIGNATURE) GetSigFromToken(// return the signature
        mdSignature mdSig,                  // [IN] Signature token.
        ULONG       *pcbSig);               // [OUT] return size of signature.



    //*****************************************
    // get method property
    //*****************************************
    STDMETHODIMP_(DWORD) GetMethodDefProps(
        mdMethodDef md);                    // The method for which to get props.

    STDMETHODIMP_(ULONG) GetMethodDefSlot(
        mdMethodDef mb);                    // The method for which to get props.

    //*****************************************
    // return method implementation informaiton, like RVA and implflags
    //*****************************************
    STDMETHODIMP_(void) GetMethodImplProps(
        mdMethodDef tk,                     // [IN] MethodDef
        ULONG       *pulCodeRVA,            // [OUT] CodeRVA
        DWORD       *pdwImplFlags);         // [OUT] Impl. Flags

    //*****************************************************************************
    // return the field RVA
    //*****************************************************************************
    STDMETHODIMP GetFieldRVA(   
        mdToken     fd,                     // [IN] FieldDef
        ULONG       *pulCodeRVA);           // [OUT] CodeRVA

    //*****************************************
    // get field property
    //*****************************************
    STDMETHODIMP_(DWORD) GetFieldDefProps(  // return fdPublic, fdPrive, etc flags
        mdFieldDef  fd);                    // [IN] given fielddef

    //*****************************************************************************
    // return default value of a token(could be paramdef, fielddef, or property
    //*****************************************************************************
    STDMETHODIMP GetDefaultValue(    
        mdToken     tk,                     // [IN] given FieldDef, ParamDef, or Property
        MDDefaultValue *pDefaultValue);     // [OUT] default value to fill

    
    //*****************************************
    // get dispid of a MethodDef or a FieldDef
    //*****************************************
    STDMETHODIMP GetDispIdOfMemberDef(      // return hresult
        mdToken     tk,                     // [IN] given methoddef or fielddef
        ULONG       *pDispid);              // [OUT] Put the dispid here.
    
    //*****************************************
    // return TypeRef/TypeDef given an InterfaceImpl token
    //*****************************************
    STDMETHODIMP_(mdToken) GetTypeOfInterfaceImpl( // return the TypeRef/typedef token for the interfaceimpl
        mdInterfaceImpl iiImpl);            // given a interfaceimpl

    //*****************************************
    // look up function for TypeDef
    //*****************************************
    STDMETHODIMP FindTypeDef(
        LPCSTR      szNamespace,            // [IN] Namespace for the TypeDef.
        LPCSTR      szName,                 // [IN] Name of the TypeDef.
        mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef of enclosing class.
        mdTypeDef   *ptypedef);             // [OUT] return typedef

    STDMETHODIMP FindTypeDefByGUID(
        REFGUID     guid,                   // guid to look up
        mdTypeDef   *ptypedef);             // return typedef



    //*****************************************
    // return name and sig of a memberref
    //*****************************************
    STDMETHODIMP_(LPCSTR) GetNameAndSigOfMemberRef( // return name here
        mdMemberRef memberref,              // given memberref
        PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
        ULONG       *pcbSigBlob);           // [OUT] count of bytes in the signature blob

    //*****************************************************************************
    // Given memberref, return the parent. It can be TypeRef, ModuleRef, MethodDef
    //*****************************************************************************
    STDMETHODIMP_(mdToken) GetParentOfMemberRef( // return the parent token
        mdMemberRef memberref);              // given memberref

    
    STDMETHODIMP_(LPCSTR) GetParamDefProps( // return parameter name
        mdParamDef  paramdef,               // given a paramdef
        USHORT      *pusSequence,           // [OUT] slot number for this parameter
        DWORD       *pdwAttr);              // [OUT] flags

    //******************************************
    // property info for method.
    //******************************************
    STDMETHODIMP GetPropertyInfoForMethodDef(   // Result.
        mdMethodDef md,                     // [IN] memberdef
        mdProperty  *ppd,                   // [OUT] put property token here
        LPCSTR      *pName,                 // [OUT] put pointer to name here
        ULONG       *pSemantic);            // [OUT] put semantic here

    //*****************************************
    // class layout/sequence information
    //*****************************************
    STDMETHODIMP GetClassPackSize(          // [OUT] return error if a class doesn't have packsize info
        mdTypeDef   td,                     // [IN] give typedef
        ULONG       *pdwPackSize);          // [OUT] return the pack size of the class. 1, 2, 4, 8 or 16

    STDMETHODIMP GetClassTotalSize(         // [OUT] return error if a class doesn't have total size info
        mdTypeDef   td,                     // [IN] give typedef
        ULONG       *pdwClassSize);         // [OUT] return the total size of the class

    STDMETHODIMP GetClassLayoutInit(
        mdTypeDef   td,                     // [IN] give typedef
        MD_CLASS_LAYOUT *pLayout);          // [OUT] set up the status of query here

    STDMETHODIMP GetClassLayoutNext(
        MD_CLASS_LAYOUT *pLayout,           // [IN|OUT] set up the status of query here
        mdFieldDef  *pfd,                   // [OUT] return the fielddef
        ULONG       *pulOffset);            // [OUT] return the offset/ulSequence associate with it

    //*****************************************
    // marshal information of a field
    //*****************************************
    STDMETHODIMP GetFieldMarshal(           // return error if no native type associate with the token
        mdFieldDef  fd,                     // [IN] given fielddef
        PCCOR_SIGNATURE *pSigNativeType,    // [OUT] the native type signature
        ULONG       *pcbNativeType);        // [OUT] the count of bytes of *ppvNativeType


    //*****************************************
    // property APIs
    //*****************************************
    // find a property by name
    STDMETHODIMP FindProperty(
        mdTypeDef   td,                     // [IN] given a typdef
        LPCSTR      szPropName,             // [IN] property name
        mdProperty  *pProp);                // [OUT] return property token

    STDMETHODIMP_(void) GetPropertyProps(
        mdProperty  prop,                   // [IN] property token
        LPCSTR      *szProperty,            // [OUT] property name
        DWORD       *pdwPropFlags,          // [OUT] property flags.
        PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob
        ULONG       *pcbSig);               // [OUT] count of bytes in *ppvSig

    //**********************************
    // Event APIs
    //**********************************
    STDMETHODIMP FindEvent(
        mdTypeDef   td,                     // [IN] given a typdef
        LPCSTR      szEventName,            // [IN] event name
        mdEvent     *pEvent);               // [OUT] return event token

    STDMETHODIMP_(void) GetEventProps(           // S_OK, S_FALSE, or error.
        mdEvent     ev,                     // [IN] event token
        LPCSTR      *pszEvent,              // [OUT] Event name
        DWORD       *pdwEventFlags,         // [OUT] Event flags.
        mdToken     *ptkEventType);         // [OUT] EventType class


    //**********************************
    // find a particular associate of a property or an event
    //**********************************
    STDMETHODIMP FindAssociate(
        mdToken     evprop,                 // [IN] given a property or event token
        DWORD       associate,              // [IN] given a associate semantics(setter, getter, testdefault, reset, AddOn, RemoveOn, Fire)
        mdMethodDef *pmd);                  // [OUT] return method def token 

    STDMETHODIMP_(void) EnumAssociateInit(
        mdToken     evprop,                 // [IN] given a property or an event token
        HENUMInternal *phEnum);             // [OUT] cursor to hold the query result

    STDMETHODIMP_(void) GetAllAssociates(
        HENUMInternal *phEnum,              // [IN] query result form GetPropertyAssociateCounts
        ASSOCIATE_RECORD *pAssociateRec,    // [OUT] struct to fill for output
        ULONG       cAssociateRec);         // [IN] size of the buffer


    //**********************************
    // Get info about a PermissionSet.
    //**********************************
    STDMETHODIMP_(void) GetPermissionSetProps(
        mdPermission pm,                    // [IN] the permission token.
        DWORD       *pdwAction,             // [OUT] CorDeclSecurity.
        void const  **ppvPermission,        // [OUT] permission blob.
        ULONG       *pcbPermission);        // [OUT] count of bytes of pvPermission.

    //****************************************
    // Get the String given the String token.
    //****************************************
    STDMETHODIMP_(LPCWSTR) GetUserString(
        mdString    stk,                    // [IN] the string token.
        ULONG       *pchString,             // [OUT] count of characters in the string.
        BOOL        *pbIs80Plus);           // [OUT] specifies where there are extended characters >= 0x80.

    //*****************************************************************************
    // p-invoke APIs.
    //*****************************************************************************
    STDMETHODIMP GetPinvokeMap(
        mdMethodDef tk,                     // [IN] FieldDef or MethodDef.
        DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
        LPCSTR      *pszImportName,         // [OUT] Import name.
        mdModuleRef *pmrImportDLL);         // [OUT] ModuleRef token for the target DLL.

    //*****************************************************************************
    // Assembly MetaData APIs.
    //*****************************************************************************
    STDMETHODIMP_(void) GetAssemblyProps(
        mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
        const void  **ppbPublicKey,                 // [OUT] Pointer to the public key.
        ULONG       *pcbPublicKey,                  // [OUT] Count of bytes in the public key.
        ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        AssemblyMetaDataInternal *pMetaData,// [OUT] Assembly MetaData.
        DWORD       *pdwAssemblyFlags);     // [OUT] Flags.

    STDMETHODIMP_(void) GetAssemblyRefProps(
        mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
        const void  **ppbPublicKeyOrToken,                  // [OUT] Pointer to the public key or token.
        ULONG       *pcbPublicKeyOrToken,           // [OUT] Count of bytes in the public key or token.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        AssemblyMetaDataInternal *pMetaData,// [OUT] Assembly MetaData.
        const void  **ppbHashValue,         // [OUT] Hash blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
        DWORD       *pdwAssemblyRefFlags);  // [OUT] Flags.

    STDMETHODIMP_(void) GetFileProps(
        mdFile      mdf,                    // [IN] The File for which to get the properties.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
        ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
        DWORD       *pdwFileFlags);         // [OUT] Flags.

    STDMETHODIMP_(void) GetExportedTypeProps(
        mdExportedType  mdct,               // [IN] The ExportedType for which to get the properties.
        LPCSTR      *pszNamespace,          // [OUT] Buffer to fill with namespace.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
        mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
        DWORD       *pdwExportedTypeFlags); // [OUT] Flags.

    STDMETHODIMP_(void) GetManifestResourceProps(
        mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
        LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
        mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
        DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
        DWORD       *pdwResourceFlags);     // [OUT] Flags.

    STDMETHODIMP FindExportedTypeByName(        // S_OK or error
        LPCSTR      szNamespace,            // [IN] Namespace of the ExportedType.   
        LPCSTR      szName,                 // [IN] Name of the ExportedType.   
        mdExportedType   tkEnclosingType,        // [IN] Enclosing ExportedType.
        mdExportedType  *pmct);                 // [OUT] Put ExportedType token here.

    STDMETHODIMP FindManifestResourceByName(// S_OK or error
        LPCSTR      szName,                 // [IN] Name of the resource.   
        mdManifestResource *pmmr);          // [OUT] Put ManifestResource token here.

    STDMETHODIMP GetAssemblyFromScope(      // S_OK or error
        mdAssembly  *ptkAssembly);          // [OUT] Put token here.
    
    //***************************************************************************
    // return properties regarding a TypeSpec
    //***************************************************************************
    STDMETHODIMP_(void) GetTypeSpecFromToken(// S_OK or error.
        mdTypeSpec  typespec,               // [IN] Signature token.
        PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.
        ULONG       *pcbSig);               // [OUT] return size of signature.

    //*****************************************************************************
    // helpers to convert a text signature to a com format
    //*****************************************************************************
    STDMETHODIMP ConvertTextSigToComSig(    // Return hresult.
        BOOL        fCreateTrIfNotFound,    // [IN] create typeref if not found
        LPCSTR      pSignature,             // [IN] class file format signature
        CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
        ULONG       *pcbCount);             // [OUT] the result size of signature

    STDMETHODIMP SetUserContextData(        // S_OK or E_NOTIMPL
        IUnknown    *pIUnk)                 // The user context.
    { return E_NOTIMPL; }

    STDMETHODIMP_(BOOL) IsValidToken(       // True or False.
        mdToken     tk);                    // [IN] Given token.

    STDMETHODIMP_(IUnknown *) GetCachedPublicInterface(BOOL fWithLock) { return NULL;}  // return the cached public interface
    STDMETHODIMP SetCachedPublicInterface(IUnknown *pUnk) { return E_FAIL;} ;// return hresult
    STDMETHODIMP_(UTSemReadWrite*) GetReaderWriterLock() {return NULL;}   // return the reader writer lock
    STDMETHODIMP SetReaderWriterLock(UTSemReadWrite *pSem) {return NOERROR;}
    STDMETHODIMP_(mdModule) GetModuleFromScope(void);

    // Find a paticular method and pass in the signature comparison routine. Very
    // helpful when the passed in signature does not come from the same scope.
    STDMETHODIMP FindMethodDefUsingCompare(
        mdTypeDef   classdef,               // [IN] given typedef
        LPCSTR      szName,                 // [IN] member name
        PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
        ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
        PSIGCOMPARE pSignatureCompare,      // [IN] Routine to compare signatures
        void*       pSignatureArgs,         // [IN] Additional info to supply the compare function
        mdMethodDef *pmd);                  // [OUT] matching memberdef


    CLiteWeightStgdb<CMiniMd>   m_LiteWeightStgdb;

private:

    struct CMethodSemanticsMap 
    {
        mdToken         m_mdMethod;         // Method token.
        RID             m_ridSemantics;     // RID of semantics record.
    };
    CMethodSemanticsMap *m_pMethodSemanticsMap; // Possible array of method semantics pointers, ordered by method token.
    class CMethodSemanticsMapSorter : public CQuickSort<CMethodSemanticsMap>
    {
    public:
         CMethodSemanticsMapSorter(CMethodSemanticsMap *pBase, int iCount) : CQuickSort<CMethodSemanticsMap>(pBase, iCount) {}
         virtual int Compare(CMethodSemanticsMap *psFirst, CMethodSemanticsMap *psSecond);
    };
    class CMethodSemanticsMapSearcher : public CBinarySearch<CMethodSemanticsMap>
    {
    public:
        CMethodSemanticsMapSearcher(const CMethodSemanticsMap *pBase, int iCount) : CBinarySearch<CMethodSemanticsMap>(pBase, iCount) {}
        virtual int Compare(const CMethodSemanticsMap *psFirst, const CMethodSemanticsMap *psSecond);
    };

    static BOOL CompareSignatures(PCCOR_SIGNATURE pvFirstSigBlob, DWORD cbFirstSigBlob,
                                  PCCOR_SIGNATURE pvSecondSigBlob, DWORD cbSecondSigBlob,
                                  void* SigARguments);

    mdTypeDef           m_tdModule;         // <Module> typedef value.
    ULONG               m_cRefs;            // Ref count.
};



#endif // __MDInternalRO__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\mdinternalro.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
// ===========================================================================
//  File: MDInternalRO.CPP
//  Notes:
//      
//
// ===========================================================================
#include "stdafx.h"
#include "MDInternalRO.h"
#include "MetaModelRO.h"
#include "LiteWeightStgdb.h"
#include "sighelper.h"
#include "corhlpr.h"
#include "..\compiler\regmeta.h"

HRESULT _FillMDDefaultValue(
    BYTE        bType,
    void const *pValue,
    MDDefaultValue  *pMDDefaultValue);

HRESULT TranslateSigHelper(             // S_OK or error.
    CMiniMdRW   *pMiniMdAssemEmit,      // [IN] Assembly emit scope.
    CMiniMdRW   *pMiniMdEmit,           // [IN] The emit scope.
    IMetaModelCommon *pAssemCommon,     // [IN] Assembly import scope.
    const void  *pbHashValue,           // [IN] Hash value.
    ULONG       cbHashValue,            // [IN] Size in bytes.
    IMetaModelCommon *pCommon,          // [IN] The scope to merge into the emit scope.
    PCCOR_SIGNATURE pbSigImp,           // [IN] signature from the imported scope
    MDTOKENMAP  *ptkMap,                // [IN] Internal OID mapping structure.
    CQuickBytes *pqkSigEmit,            // [OUT] translated signature
    ULONG       cbStartEmit,            // [IN] start point of buffer to write to
    ULONG       *pcbImp,                // [OUT] total number of bytes consumed from pbSigImp
    ULONG       *pcbEmit);               // [OUT] total number of bytes write to pqkSigEmit

//*****************************************************************************
// Constructor
//*****************************************************************************
MDInternalRO::MDInternalRO()
 :  m_cRefs(1),
    m_pMethodSemanticsMap(0)
{
} // MDInternalRO::MDInternalRO()



//*****************************************************************************
// Destructor
//*****************************************************************************
MDInternalRO::~MDInternalRO()
{
    m_LiteWeightStgdb.Uninit();
    if (m_pMethodSemanticsMap)
        delete[] m_pMethodSemanticsMap;
    m_pMethodSemanticsMap = 0;
} // MDInternalRO::~MDInternalRO()
//*****************************************************************************
// IUnknown
//*****************************************************************************
ULONG MDInternalRO::AddRef()
{
    return (InterlockedIncrement((long *) &m_cRefs));
} // ULONG MDInternalRO::AddRef()

ULONG MDInternalRO::Release()
{
    ULONG   cRef = InterlockedDecrement((long *) &m_cRefs);
    if (!cRef)
        delete this;
    return (cRef);
} // ULONG MDInternalRO::Release()

HRESULT MDInternalRO::QueryInterface(REFIID riid, void **ppUnk)
{
    *ppUnk = 0;

    if (riid == IID_IUnknown)
        *ppUnk = (IUnknown *) (IMDInternalImport *) this;
    else if (riid == IID_IMDInternalImport)
        *ppUnk = (IMDInternalImport *) this;
    else
        return (E_NOINTERFACE);
    AddRef();
    return (S_OK);
} // HRESULT MDInternalRO::QueryInterface()


//*****************************************************************************
// Initialize 
//*****************************************************************************
HRESULT MDInternalRO::Init(
    LPVOID      pData,                  // points to meta data section in memory
    ULONG       cbData)                 // count of bytes in pData
{
    m_tdModule = COR_GLOBAL_PARENT_TOKEN;
    
    extern HRESULT _CallInitOnMemHelper(CLiteWeightStgdb<CMiniMd> *pStgdb, ULONG cbData, LPCVOID pData);

    return _CallInitOnMemHelper(&m_LiteWeightStgdb, cbData, (BYTE*) pData);    
} // HRESULT MDInternalRO::Init()


//*****************************************************************************
// Given a scope, determine whether imported from a typelib.
//*****************************************************************************
HRESULT MDInternalRO::TranslateSigWithScope(
    IMDInternalImport *pAssemImport,    // [IN] import assembly scope.
    const void  *pbHashValue,           // [IN] hash value for the import assembly.
    ULONG       cbHashValue,            // [IN] count of bytes in the hash value.
    PCCOR_SIGNATURE pbSigBlob,          // [IN] signature in the importing scope
    ULONG       cbSigBlob,              // [IN] count of bytes of signature
    IMetaDataAssemblyEmit *pAssemEmit,  // [IN] assembly emit scope.
    IMetaDataEmit *emit,                // [IN] emit interface
    CQuickBytes *pqkSigEmit,            // [OUT] buffer to hold translated signature
    ULONG       *pcbSig)                // [OUT] count of bytes in the translated signature
{
    HRESULT     hr = NOERROR;
    ULONG       cbEmit;
    IMetaModelCommon *pCommon = GetMetaModelCommon();
    RegMeta     *pEmitRM = static_cast<RegMeta*>(emit);
    RegMeta     *pAssemEmitRM = static_cast<RegMeta*>(pAssemEmit);

    IfFailGo( TranslateSigHelper(                   // S_OK or error.
            pAssemEmitRM ? &pAssemEmitRM->m_pStgdb->m_MiniMd : 0, // The assembly emit scope.
            &pEmitRM->m_pStgdb->m_MiniMd,           // The emit scope.
            pAssemImport ? pAssemImport->GetMetaModelCommon() : 0, // Assembly scope where the signature is from.
            pbHashValue,                            // Hash value for the import scope.
            cbHashValue,                            // Size in bytes.
            pCommon,                                // The scope where signature is from.
            pbSigBlob,                              // signature from the imported scope
            NULL,                                   // Internal OID mapping structure.
            pqkSigEmit,                             // [OUT] translated signature
            0,                                      // start from first byte of the signature
            0,                                      // don't care how many bytes consumed
            &cbEmit));                              // [OUT] total number of bytes write to pqkSigEmit
    *pcbSig = cbEmit;
ErrExit:    
    return hr;
} // HRESULT MDInternalRO::TranslateSigWithScope()


//*****************************************************************************
// Given a scope, return the number of tokens in a given table 
//*****************************************************************************
ULONG MDInternalRO::GetCountWithTokenKind(     // return hresult
    DWORD       tkKind)                 // [IN] pass in the kind of token. 
{
    ULONG       ulCount = 0;    

    switch (tkKind)
    {
    case mdtTypeDef: 
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountTypeDefs() - 1;
        break;
    case mdtTypeRef: 
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountTypeRefs();
        break;
    case mdtMethodDef:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountMethods();
        break;
    case mdtFieldDef:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountFields();
        break;
    case mdtMemberRef:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountMemberRefs();
        break;
    case mdtInterfaceImpl:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountInterfaceImpls();
        break;
    case mdtParamDef:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountParams();
        break;
    case mdtFile:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountFiles();
        break;
    case mdtAssemblyRef:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountAssemblyRefs();
        break;
    case mdtAssembly:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountAssemblys();
        break;
    case mdtCustomAttribute:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountCustomAttributes();
        break;
    case mdtModule:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountModules();
        break;
    case mdtPermission:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountDeclSecuritys();
        break;
    case mdtSignature:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountStandAloneSigs();
        break;
    case mdtEvent:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountEvents();
        break;
    case mdtProperty:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountPropertys();
        break;
    case mdtModuleRef:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountModuleRefs();
        break;
    case mdtTypeSpec:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountTypeSpecs();
        break;
    case mdtExportedType:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountExportedTypes();
        break;
    case mdtManifestResource:
        ulCount = m_LiteWeightStgdb.m_MiniMd.getCountManifestResources();
        break;
    default:
        _ASSERTE(!"not implemented!");
        break;
    }
    return ulCount;
} // ULONG MDInternalRO::GetCountWithTokenKind()



//*******************************************************************************
// Enumerator helpers
//*******************************************************************************   


//*****************************************************************************
// enumerator init for typedef
//*****************************************************************************
HRESULT MDInternalRO::EnumTypeDefInit( // return hresult
    HENUMInternal *phEnum)              // [OUT] buffer to fill for enumerator data
{
    HRESULT     hr = NOERROR;

    _ASSERTE(phEnum);

    memset(phEnum, 0, sizeof(HENUMInternal));
    phEnum->m_tkKind = mdtTypeDef;
    phEnum->m_EnumType = MDSimpleEnum;
    phEnum->m_ulCount = m_LiteWeightStgdb.m_MiniMd.getCountTypeDefs();

    // Skip over the global model typedef
    //
    // phEnum->m_ulCur : the current rid that is not yet enumerated
    // phEnum->m_ulStart : the first rid that will be returned by enumerator
    // phEnum->m_ulEnd : the last rid that will be returned by enumerator
    phEnum->m_ulStart = phEnum->m_ulCur = 2;
    phEnum->m_ulEnd = phEnum->m_ulCount + 1;
    phEnum->m_ulCount --;
    return hr;
} // HRESULT MDInternalRO::EnumTypeDefInit()


//*****************************************************************************
// get the number of typedef in a scope
//*****************************************************************************
ULONG MDInternalRO::EnumTypeDefGetCount(
    HENUMInternal *phEnum)              // [IN] the enumerator to retrieve information  
{
    _ASSERTE(phEnum->m_tkKind == mdtTypeDef);
    return phEnum->m_ulCount;
} // ULONG MDInternalRO::EnumTypeDefGetCount()


//*****************************************************************************
// enumerator for typedef
//*****************************************************************************
bool MDInternalRO::EnumTypeDefNext( // return hresult
    HENUMInternal *phEnum,              // [IN] input enum
    mdTypeDef   *ptd)                   // [OUT] return token
{
    _ASSERTE(phEnum && ptd);

    if (phEnum->m_ulCur >= phEnum->m_ulEnd)
        return false;

    *ptd = phEnum->m_ulCur++;
    RidToToken(*ptd, mdtTypeDef);
    return true;
} // bool MDInternalRO::EnumTypeDefNext()


//*****************************************
// Reset the enumerator to the beginning.
//***************************************** 
void MDInternalRO::EnumTypeDefReset(
    HENUMInternal *phEnum)              // [IN] the enumerator to be reset  
{
    _ASSERTE(phEnum);
    _ASSERTE( phEnum->m_EnumType == MDSimpleEnum );

    // not using CRCURSOR 
    phEnum->m_ulCur = phEnum->m_ulStart;
} // void MDInternalRO::EnumTypeDefReset()


//*****************************************
// Close the enumerator. Only for read/write mode that we need to close the cursor.
// Hopefully with readonly mode, it will be a no-op
//***************************************** 
void MDInternalRO::EnumTypeDefClose(
    HENUMInternal *phEnum)              // [IN] the enumerator to be closed
{
    _ASSERTE( phEnum->m_EnumType == MDSimpleEnum );
} // void MDInternalRO::EnumTypeDefClose()


//*****************************************************************************
// Enumerator init for MethodImpl.  The second HENUMInternal* parameter is
// only used for the R/W version of the MetaData.
//*****************************************************************************
HRESULT MDInternalRO::EnumMethodImplInit( // return hresult
    mdTypeDef       td,                   // [IN] TypeDef over which to scope the enumeration.
    HENUMInternal   *phEnumBody,          // [OUT] buffer to fill for enumerator data for MethodBody tokens.
    HENUMInternal   *phEnumDecl)          // [OUT] buffer to fill for enumerator data for MethodDecl tokens.
{
    return EnumInit(TBL_MethodImpl << 24, td, phEnumBody);
} // HRESULT MDInternalRO::EnumMethodImplInit()

//*****************************************************************************
// get the number of MethodImpls in a scope
//*****************************************************************************
ULONG MDInternalRO::EnumMethodImplGetCount(
    HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.  
    HENUMInternal   *phEnumDecl)        // [IN] MethodDecl enumerator.
{
    _ASSERTE(phEnumBody && ((phEnumBody->m_tkKind >> 24) == TBL_MethodImpl));
    return phEnumBody->m_ulCount;
} // ULONG MDInternalRO::EnumMethodImplGetCount()


//*****************************************************************************
// enumerator for MethodImpl.
//*****************************************************************************
bool MDInternalRO::EnumMethodImplNext(  // return hresult
    HENUMInternal   *phEnumBody,        // [IN] input enum for MethodBody
    HENUMInternal   *phEnumDecl,        // [IN] input enum for MethodDecl
    mdToken         *ptkBody,           // [OUT] return token for MethodBody
    mdToken         *ptkDecl)           // [OUT] return token for MethodDecl
{
    MethodImplRec   *pRecord;

    _ASSERTE(phEnumBody && ((phEnumBody->m_tkKind >> 24) == TBL_MethodImpl));
    _ASSERTE(ptkBody && ptkDecl);

    if (phEnumBody->m_ulCur >= phEnumBody->m_ulEnd)
        return false;

    pRecord = m_LiteWeightStgdb.m_MiniMd.getMethodImpl(phEnumBody->m_ulCur);
    *ptkBody = m_LiteWeightStgdb.m_MiniMd.getMethodBodyOfMethodImpl(pRecord);
    *ptkDecl = m_LiteWeightStgdb.m_MiniMd.getMethodDeclarationOfMethodImpl(pRecord);
    phEnumBody->m_ulCur++;

    return true;
} // bool MDInternalRO::EnumMethodImplNext()


//*****************************************
// Reset the enumerator to the beginning.
//***************************************** 
void MDInternalRO::EnumMethodImplReset(
    HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.
    HENUMInternal   *phEnumDecl)        // [IN] MethodDecl enumerator.
{
    _ASSERTE(phEnumBody && ((phEnumBody->m_tkKind >> 24) == TBL_MethodImpl));
    _ASSERTE(phEnumBody->m_EnumType == MDSimpleEnum);

    phEnumBody->m_ulCur = phEnumBody->m_ulStart;
} // void MDInternalRO::EnumMethodImplReset()


//*****************************************
// Close the enumerator.
//***************************************** 
void MDInternalRO::EnumMethodImplClose(
    HENUMInternal   *phEnumBody,        // [IN] MethodBody enumerator.
    HENUMInternal   *phEnumDecl)        // [IN] MethodDecl enumerator.
{
    _ASSERTE(phEnumBody && ((phEnumBody->m_tkKind >> 24) == TBL_MethodImpl));
    _ASSERTE(phEnumBody->m_EnumType == MDSimpleEnum);
} // void MDInternalRW::EnumMethodImplClose()


//******************************************************************************
// enumerator for global functions
//******************************************************************************
HRESULT MDInternalRO::EnumGlobalFunctionsInit(  // return hresult
    HENUMInternal   *phEnum)            // [OUT] buffer to fill for enumerator data
{
    return EnumInit(mdtMethodDef, m_tdModule, phEnum);
}


//******************************************************************************
// enumerator for global Fields
//******************************************************************************
HRESULT MDInternalRO::EnumGlobalFieldsInit(  // return hresult
    HENUMInternal   *phEnum)            // [OUT] buffer to fill for enumerator data
{
    return EnumInit(mdtFieldDef, m_tdModule, phEnum);
}


//*****************************************
// Enumerator initializer
//***************************************** 
HRESULT MDInternalRO::EnumInit(     // return S_FALSE if record not found
    DWORD       tkKind,                 // [IN] which table to work on
    mdToken     tkParent,               // [IN] token to scope the search
    HENUMInternal *phEnum)              // [OUT] the enumerator to fill 
{
    HRESULT     hr = S_OK;

    // Vars for query.
    _ASSERTE(phEnum);
    memset(phEnum, 0, sizeof(HENUMInternal));

    // cache the tkKind and the scope
    phEnum->m_tkKind = TypeFromToken(tkKind);

    TypeDefRec  *pRec;

    phEnum->m_EnumType = MDSimpleEnum;

    switch (TypeFromToken(tkKind))
    {
    case mdtFieldDef:
        pRec = m_LiteWeightStgdb.m_MiniMd.getTypeDef(RidFromToken(tkParent));
        phEnum->m_ulStart = m_LiteWeightStgdb.m_MiniMd.getFieldListOfTypeDef(pRec);
        phEnum->m_ulEnd = m_LiteWeightStgdb.m_MiniMd.getEndFieldListOfTypeDef(pRec);
        break;

    case mdtMethodDef:      
        pRec = m_LiteWeightStgdb.m_MiniMd.getTypeDef(RidFromToken(tkParent));
        phEnum->m_ulStart = m_LiteWeightStgdb.m_MiniMd.getMethodListOfTypeDef(pRec);
        phEnum->m_ulEnd = m_LiteWeightStgdb.m_MiniMd.getEndMethodListOfTypeDef(pRec);
        break;
    
    case mdtInterfaceImpl:
        phEnum->m_ulStart = m_LiteWeightStgdb.m_MiniMd.getInterfaceImplsForTypeDef(RidFromToken(tkParent), &phEnum->m_ulEnd);
        break;

    case mdtProperty:
        RID         ridPropertyMap;
        PropertyMapRec *pPropertyMapRec;

        // get the starting/ending rid of properties of this typedef
        ridPropertyMap = m_LiteWeightStgdb.m_MiniMd.FindPropertyMapFor(RidFromToken(tkParent));
        if (!InvalidRid(ridPropertyMap))
        {
            pPropertyMapRec = m_LiteWeightStgdb.m_MiniMd.getPropertyMap(ridPropertyMap);
            phEnum->m_ulStart = m_LiteWeightStgdb.m_MiniMd.getPropertyListOfPropertyMap(pPropertyMapRec);
            phEnum->m_ulEnd = m_LiteWeightStgdb.m_MiniMd.getEndPropertyListOfPropertyMap(pPropertyMapRec);
        }
        break;

    case mdtEvent:
        RID         ridEventMap;
        EventMapRec *pEventMapRec;

        // get the starting/ending rid of events of this typedef
        ridEventMap = m_LiteWeightStgdb.m_MiniMd.FindEventMapFor(RidFromToken(tkParent));
        if (!InvalidRid(ridEventMap))
        {
            pEventMapRec = m_LiteWeightStgdb.m_MiniMd.getEventMap(ridEventMap);
            phEnum->m_ulStart = m_LiteWeightStgdb.m_MiniMd.getEventListOfEventMap(pEventMapRec);
            phEnum->m_ulEnd = m_LiteWeightStgdb.m_MiniMd.getEndEventListOfEventMap(pEventMapRec);
        }
        break;

    case mdtParamDef:
        _ASSERTE(TypeFromToken(tkParent) == mdtMethodDef);

        MethodRec *pMethodRec;
        pMethodRec = m_LiteWeightStgdb.m_MiniMd.getMethod(RidFromToken(tkParent));

        // figure out the start rid and end rid of the parameter list of this methoddef
        phEnum->m_ulStart = m_LiteWeightStgdb.m_MiniMd.getParamListOfMethod(pMethodRec);
        phEnum->m_ulEnd = m_LiteWeightStgdb.m_MiniMd.getEndParamListOfMethod(pMethodRec);
        break;
    case mdtCustomAttribute:
        phEnum->m_ulStart = m_LiteWeightStgdb.m_MiniMd.getCustomAttributeForToken(tkParent, &phEnum->m_ulEnd);
        break;
    case mdtAssemblyRef:
        _ASSERTE(IsNilToken(tkParent));
        phEnum->m_ulStart = 1;
        phEnum->m_ulEnd = m_LiteWeightStgdb.m_MiniMd.getCountAssemblyRefs() + 1;
        break;
    case mdtFile:
        _ASSERTE(IsNilToken(tkParent));
        phEnum->m_ulStart = 1;
        phEnum->m_ulEnd = m_LiteWeightStgdb.m_MiniMd.getCountFiles() + 1;
        break;
    case mdtExportedType:
        _ASSERTE(IsNilToken(tkParent));
        phEnum->m_ulStart = 1;
        phEnum->m_ulEnd = m_LiteWeightStgdb.m_MiniMd.getCountExportedTypes() + 1;
        break;
    case mdtManifestResource:
        _ASSERTE(IsNilToken(tkParent));
        phEnum->m_ulStart = 1;
        phEnum->m_ulEnd = m_LiteWeightStgdb.m_MiniMd.getCountManifestResources() + 1;
        break;
    case (TBL_MethodImpl << 24):
        _ASSERTE(! IsNilToken(tkParent));
        phEnum->m_ulStart = m_LiteWeightStgdb.m_MiniMd.getMethodImplsForClass(
                                        RidFromToken(tkParent), &phEnum->m_ulEnd);
        break;
    default:
        _ASSERTE(!"ENUM INIT not implemented for the compressed format!");
        IfFailGo(E_NOTIMPL);
        break;
    }
    phEnum->m_ulCount = phEnum->m_ulEnd - phEnum->m_ulStart;
    phEnum->m_ulCur = phEnum->m_ulStart;

ErrExit:
    // we are done
    return (hr);
}


//*****************************************
// Enumerator initializer
//***************************************** 
HRESULT MDInternalRO::EnumAllInit(      // return S_FALSE if record not found
    DWORD       tkKind,                 // [IN] which table to work on
    HENUMInternal *phEnum)              // [OUT] the enumerator to fill 
{
    HRESULT     hr = S_OK;

    // Vars for query.
    _ASSERTE(phEnum);
    memset(phEnum, 0, sizeof(HENUMInternal));

    // cache the tkKind and the scope
    phEnum->m_tkKind = TypeFromToken(tkKind);
    phEnum->m_EnumType = MDSimpleEnum;

    switch (TypeFromToken(tkKind))
    {
    case mdtTypeRef:
        phEnum->m_ulCount = m_LiteWeightStgdb.m_MiniMd.getCountTypeRefs();
        break;

    case mdtMemberRef:      
        phEnum->m_ulCount = m_LiteWeightStgdb.m_MiniMd.getCountMemberRefs();
        break;

    case mdtSignature:
        phEnum->m_ulCount = m_LiteWeightStgdb.m_MiniMd.getCountStandAloneSigs();
        break;

    case mdtMethodDef:
        phEnum->m_ulCount = m_LiteWeightStgdb.m_MiniMd.getCountMethods();
        break;

    default:
        _ASSERTE(!"Bad token kind!");
        break;
    }
    phEnum->m_ulStart = phEnum->m_ulCur = 1;
    phEnum->m_ulEnd = phEnum->m_ulCount + 1;

    // we are done
    return (hr);
} // HRESULT MDInternalRO::EnumAllInit()


//*****************************************
// get the count
//***************************************** 
ULONG MDInternalRO::EnumGetCount(
    HENUMInternal *phEnum)              // [IN] the enumerator to retrieve information  
{
    _ASSERTE(phEnum);
    return phEnum->m_ulCount;
}

//*****************************************
// Get next value contained in the enumerator
//***************************************** 
bool MDInternalRO::EnumNext(
    HENUMInternal *phEnum,              // [IN] the enumerator to retrieve information  
    mdToken     *ptk)                   // [OUT] token to scope the search
{
    _ASSERTE(phEnum && ptk);
    _ASSERTE( phEnum->m_EnumType == MDSimpleEnum );

    // not using CRCURSOR 
    if (phEnum->m_ulCur >= phEnum->m_ulEnd)
        return false;
    *ptk = phEnum->m_ulCur | phEnum->m_tkKind;
    phEnum->m_ulCur++;
    return true;
} // bool MDInternalRO::EnumNext()


//*****************************************
// Reset the enumerator to the beginning.
//***************************************** 
void MDInternalRO::EnumReset(
    HENUMInternal *phEnum)              // [IN] the enumerator to be reset  
{
    _ASSERTE(phEnum);
    _ASSERTE( phEnum->m_EnumType == MDSimpleEnum );

    // not using CRCURSOR 
    phEnum->m_ulCur = phEnum->m_ulStart;
} // void MDInternalRO::EnumReset()


//*****************************************
// Close the enumerator. Only for read/write mode that we need to close the cursor.
// Hopefully with readonly mode, it will be a no-op
//***************************************** 
void MDInternalRO::EnumClose(
    HENUMInternal *phEnum)              // [IN] the enumerator to be closed
{
    _ASSERTE( phEnum->m_EnumType == MDSimpleEnum );
} // void MDInternalRO::EnumClose()


//*****************************************
// Enumerator initializer for PermissionSets
//***************************************** 
HRESULT MDInternalRO::EnumPermissionSetsInit(// return S_FALSE if record not found
    mdToken     tkParent,               // [IN] token to scope the search
    CorDeclSecurity Action,             // [IN] Action to scope the search
    HENUMInternal *phEnum)              // [OUT] the enumerator to fill 
{
    HRESULT     hr = NOERROR;

    _ASSERTE(phEnum);
    memset(phEnum, 0, sizeof(HENUMInternal));

    // cache the tkKind
    phEnum->m_tkKind = mdtPermission;

    _ASSERTE(!IsNilToken(tkParent));

    DeclSecurityRec *pDecl;
    RID         ridCur;
    RID         ridEnd;

    phEnum->m_EnumType = MDSimpleEnum;

    ridCur = m_LiteWeightStgdb.m_MiniMd.getDeclSecurityForToken(tkParent, &ridEnd);
    if (Action != dclActionNil)
    {
        for (; ridCur < ridEnd; ridCur++)
        {
            pDecl = m_LiteWeightStgdb.m_MiniMd.getDeclSecurity(ridCur);
            if (Action == m_LiteWeightStgdb.m_MiniMd.getActionOfDeclSecurity(pDecl))
            {
                // found a match
                phEnum->m_ulStart = phEnum->m_ulCur = ridCur;
                phEnum->m_ulEnd = ridCur + 1;
                phEnum->m_ulCount = 1;
                goto ErrExit;
            }
        }
        hr = CLDB_E_RECORD_NOTFOUND;
    }
    else
    {
        phEnum->m_ulStart = phEnum->m_ulCur = ridCur;
        phEnum->m_ulEnd = ridEnd;
        phEnum->m_ulCount = ridEnd - ridCur;
    }
ErrExit:
    return (hr);
} // HRESULT MDInternalRO::EnumPermissionSetInit()


//*****************************************
// Enumerator initializer for CustomAttributes
//***************************************** 
HRESULT MDInternalRO::EnumCustomAttributeByNameInit(// return S_FALSE if record not found
    mdToken     tkParent,               // [IN] token to scope the search
    LPCSTR      szName,                 // [IN] CustomAttribute's name to scope the search
    HENUMInternal *phEnum)              // [OUT] the enumerator to fill 
{
    return m_LiteWeightStgdb.m_MiniMd.CommonEnumCustomAttributeByName(tkParent, szName, false, phEnum);
}   // HRESULT MDInternalRO::EnumCustomAttributeByNameInit


//*****************************************
// Nagivator helper to navigate back to the parent token given a token.
// For example, given a memberdef token, it will return the containing typedef.
//
// the mapping is as following:
//  ---given child type---------parent type
//  mdMethodDef                 mdTypeDef
//  mdFieldDef                  mdTypeDef
//  mdInterfaceImpl             mdTypeDef
//  mdParam                     mdMethodDef
//  mdProperty                  mdTypeDef
//  mdEvent                     mdTypeDef
//
//***************************************** 
HRESULT MDInternalRO::GetParentToken(
    mdToken     tkChild,                // [IN] given child token
    mdToken     *ptkParent)             // [OUT] returning parent
{
    HRESULT     hr = NOERROR;

    _ASSERTE(ptkParent);

    switch (TypeFromToken(tkChild))
    {
    case mdtMethodDef:
        *ptkParent = m_LiteWeightStgdb.m_MiniMd.FindParentOfMethod(RidFromToken(tkChild));
        RidToToken(*ptkParent, mdtTypeDef);
        break;

    case mdtFieldDef:
        *ptkParent = m_LiteWeightStgdb.m_MiniMd.FindParentOfField(RidFromToken(tkChild));
        RidToToken(*ptkParent, mdtTypeDef);
        break;

    case mdtParamDef:
        *ptkParent = m_LiteWeightStgdb.m_MiniMd.FindParentOfParam(RidFromToken(tkChild));
        RidToToken(*ptkParent, mdtParamDef);
        break;

    case mdtMemberRef:
        {
            MemberRefRec    *pRec;
            pRec = m_LiteWeightStgdb.m_MiniMd.getMemberRef(RidFromToken(tkChild));
            *ptkParent = m_LiteWeightStgdb.m_MiniMd.getClassOfMemberRef(pRec);
            break;
        }

    case mdtCustomAttribute:
        {
            CustomAttributeRec    *pRec;
            pRec = m_LiteWeightStgdb.m_MiniMd.getCustomAttribute(RidFromToken(tkChild));
            *ptkParent = m_LiteWeightStgdb.m_MiniMd.getParentOfCustomAttribute(pRec);
            break;
        }

    case mdtEvent:
    case mdtProperty:
    default:
        _ASSERTE(!"NYI: for compressed format!");
        break;
    }
    return hr;
}



//*****************************************************************************
// Get information about a CustomAttribute.
//*****************************************************************************
void MDInternalRO::GetCustomAttributeProps(  // S_OK or error.
    mdCustomAttribute at,               // The attribute.
    mdToken     *ptkType)               // Put attribute type here.
{
    _ASSERTE(TypeFromToken(at) == mdtCustomAttribute);

    // Do a linear search on compressed version as we do not want to
    // depends on ICR.
    //
    CustomAttributeRec *pCustomAttributeRec;

    pCustomAttributeRec = m_LiteWeightStgdb.m_MiniMd.getCustomAttribute(RidFromToken(at));
    *ptkType = m_LiteWeightStgdb.m_MiniMd.getTypeOfCustomAttribute(pCustomAttributeRec);
}



//*****************************************************************************
// return custom value
//*****************************************************************************
void MDInternalRO::GetCustomAttributeAsBlob(
    mdCustomAttribute cv,               // [IN] given custom attribute token
    void const  **ppBlob,               // [OUT] return the pointer to internal blob
    ULONG       *pcbSize)               // [OUT] return the size of the blob
{

    _ASSERTE(ppBlob && pcbSize && TypeFromToken(cv) == mdtCustomAttribute);

    CustomAttributeRec *pCustomAttributeRec;

    pCustomAttributeRec = m_LiteWeightStgdb.m_MiniMd.getCustomAttribute(RidFromToken(cv));

    *ppBlob = m_LiteWeightStgdb.m_MiniMd.getValueOfCustomAttribute(pCustomAttributeRec, pcbSize);
}


//*****************************************************************************
// Helper function to lookup and retrieve a CustomAttribute.
//*****************************************************************************
HRESULT MDInternalRO::GetCustomAttributeByName( // S_OK or error.
    mdToken     tkObj,                  // [IN] Object with Custom Attribute.
    LPCUTF8     szName,                 // [IN] Name of desired Custom Attribute.
    const void  **ppData,               // [OUT] Put pointer to data here.
    ULONG       *pcbData)               // [OUT] Put size of data here.
{
    return m_LiteWeightStgdb.m_MiniMd.CommonGetCustomAttributeByName(tkObj, szName, ppData, pcbData);
} // HRESULT MDInternalRO::GetCustomAttributeByName()

//*****************************************************************************
// return scope properties
//*****************************************************************************
void MDInternalRO::GetScopeProps(
    LPCSTR      *pszName,               // [OUT] scope name
    GUID        *pmvid)                 // [OUT] version id
{
    _ASSERTE(pszName || pmvid);

    ModuleRec *pModuleRec;

    // there is only one module record
    pModuleRec = m_LiteWeightStgdb.m_MiniMd.getModule(1);

    if (pmvid)          
        *pmvid = *(m_LiteWeightStgdb.m_MiniMd.getMvidOfModule(pModuleRec));
    if (pszName)
        *pszName = m_LiteWeightStgdb.m_MiniMd.getNameOfModule(pModuleRec);
}


//*****************************************************************************
// Compare two signatures from the same scope. Varags signatures need to be
// preprocessed so they only contain the fixed part.
//*****************************************************************************
BOOL  MDInternalRO::CompareSignatures(PCCOR_SIGNATURE           pvFirstSigBlob,       // First signature
                                      DWORD                     cbFirstSigBlob,       // 
                                      PCCOR_SIGNATURE           pvSecondSigBlob,      // Second signature
                                      DWORD                     cbSecondSigBlob,      // 
                                      void *                    SigArguments)         // No additional arguments required
{
    if (cbFirstSigBlob != cbSecondSigBlob || memcmp(pvFirstSigBlob, pvSecondSigBlob, cbSecondSigBlob))
        return FALSE;
    else
        return TRUE;
}

//*****************************************************************************
// Find a given member in a TypeDef (typically a class).
//*****************************************************************************
HRESULT MDInternalRO::FindMethodDef(    // S_OK or error.
    mdTypeDef   classdef,               // The owning class of the member.
    LPCSTR      szName,                 // Name of the member in utf8.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
    mdMethodDef *pmethoddef)            // Put MemberDef token here.
{

    return FindMethodDefUsingCompare(classdef,
                                     szName,
                                     pvSigBlob,
                                     cbSigBlob,
                                     CompareSignatures,
                                     NULL,
                                     pmethoddef);
}

//*****************************************************************************
// Find a given member in a TypeDef (typically a class).
//*****************************************************************************
HRESULT MDInternalRO::FindMethodDefUsingCompare(    // S_OK or error.
    mdTypeDef   classdef,               // The owning class of the member.
    LPCSTR      szName,                 // Name of the member in utf8.
    PCCOR_SIGNATURE pvSigBlob,          // [IN] point to a blob value of COM+ signature
    ULONG       cbSigBlob,              // [IN] count of bytes in the signature blob
    PSIGCOMPARE SigCompare,            // [IN] Signature comparison routine
    void*       pSigArgs,               // [IN] Additional arguments passed to signature compare
    mdMethodDef *pmethoddef)            // Put MemberDef token here.
{
    HRESULT     hr = NOERROR;
    PCCOR_SIGNATURE pvSigTemp = pvSigBlob;
    CQuickBytes qbSig;

    _ASSERTE(szName && pmethoddef);

    // initialize the output parameter
    *pmethoddef = mdMethodDefNil;

    // check to see if this is a vararg signature
    if ( isCallConv(CorSigUncompressCallingConv(pvSigTemp), IMAGE_CEE_CS_CALLCONV_VARARG) )
    {
        // Get the fix part of VARARG signature
        IfFailGo( _GetFixedSigOfVarArg(pvSigBlob, cbSigBlob, &qbSig, &cbSigBlob) );
        pvSigBlob = (PCCOR_SIGNATURE) qbSig.Ptr();
    }

    // Do a linear search on compressed version 
    //
    RID         ridMax;
    MethodRec   *pMethodRec;
    LPCUTF8     szCurMethodName;
    void const  *pvCurMethodSig;
    ULONG       cbSig;
    TypeDefRec  *pRec;
    RID         ridStart;

    // get the typedef record
    pRec = m_LiteWeightStgdb.m_MiniMd.getTypeDef(RidFromToken(classdef));

    // get the range of methoddef rids given the classdef
    ridStart = m_LiteWeightStgdb.m_MiniMd.getMethodListOfTypeDef(pRec);
    ridMax = m_LiteWeightStgdb.m_MiniMd.getEndMethodListOfTypeDef(pRec);

    // loop through each methoddef
    for (; ridStart < ridMax; ridStart++)
    {
        pMethodRec = m_LiteWeightStgdb.m_MiniMd.getMethod(ridStart);
        szCurMethodName = m_LiteWeightStgdb.m_MiniMd.getNameOfMethod(pMethodRec);
        if (strcmp(szCurMethodName, szName) == 0)
        {
            // name match, now check the signature if specified.
            if (cbSigBlob && SigCompare)
            {
                pvCurMethodSig = m_LiteWeightStgdb.m_MiniMd.getSignatureOfMethod(pMethodRec, &cbSig);
                // Signature comparison is required
                // Note that if pvSigBlob is vararg, we already preprocess it so that
                // it only contains the fix part. Therefore, it still should be an exact
                // match!!!.
                //
                if(SigCompare((PCCOR_SIGNATURE) pvCurMethodSig, cbSig, pvSigBlob, cbSigBlob, pSigArgs) == FALSE)
                    continue;
            }
            // Ignore PrivateScope methods.
            if (IsMdPrivateScope(m_LiteWeightStgdb.m_MiniMd.getFlagsOfMethod(pMethodRec)))
               continue;
                    // found the match
                    *pmethoddef = TokenFromRid(ridStart, mdtMethodDef);
                    goto ErrExit;
                }
            }
    hr = CLDB_E_RECORD_NOTFOUND;

ErrExit:
    return hr;
}

//*****************************************************************************
// Find a given param of a Method.
//*****************************************************************************
HRESULT MDInternalRO::FindParamOfMethod(// S_OK or error.
    mdMethodDef md,                     // [IN] The owning method of the param.
    ULONG       iSeq,                   // [IN] The sequence # of the param.
    mdParamDef  *pparamdef)             // [OUT] Put ParamDef token here.
{
    ParamRec    *pParamRec;
    RID         ridStart, ridEnd;

    _ASSERTE(TypeFromToken(md) == mdtMethodDef && pparamdef);

    // get the methoddef record
    MethodRec *pMethodRec = m_LiteWeightStgdb.m_MiniMd.getMethod(RidFromToken(md));

    // figure out the start rid and end rid of the parameter list of this methoddef
    ridStart = m_LiteWeightStgdb.m_MiniMd.getParamListOfMethod(pMethodRec);
    ridEnd = m_LiteWeightStgdb.m_MiniMd.getEndParamListOfMethod(pMethodRec);

    // loop through each param
    // @consider: parameters are sorted by sequence. Maybe a binary search?
    //
    for (; ridStart < ridEnd; ridStart++)
    {
        pParamRec = m_LiteWeightStgdb.m_MiniMd.getParam(ridStart);
        if (iSeq == m_LiteWeightStgdb.m_MiniMd.getSequenceOfParam(pParamRec))
        {
            // parameter has the sequence number matches what we are looking for
            *pparamdef = TokenFromRid(ridStart, mdtParamDef);
            return S_OK;
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
}   



//*****************************************************************************
// return a pointer which points to meta data's internal string 
// return the the type name in utf8
//*****************************************************************************
void MDInternalRO::GetNameOfTypeDef(// return hresult
    mdTypeDef   classdef,               // given typedef
    LPCSTR*     pszname,                // pointer to an internal UTF8 string
    LPCSTR*     psznamespace)           // pointer to the namespace.
{
    if(pszname && psznamespace && TypeFromToken(classdef) == mdtTypeDef)
	{
		TypeDefRec *pTypeDefRec = m_LiteWeightStgdb.m_MiniMd.getTypeDef(RidFromToken(classdef));
		*pszname = m_LiteWeightStgdb.m_MiniMd.getNameOfTypeDef(pTypeDefRec);
		*psznamespace = m_LiteWeightStgdb.m_MiniMd.getNamespaceOfTypeDef(pTypeDefRec);
	}
	else
		_ASSERTE(!"Invalid argument(s) of GetNameOfTypeDef");
    //_ASSERTE(!pszname || !*pszname || !strchr(*pszname, '/'));
    //_ASSERTE(!psznamespace || !*psznamespace || !strchr(*psznamespace, '/'));
} // void MDInternalRO::GetNameOfTypeDef()


HRESULT MDInternalRO::GetIsDualOfTypeDef(// return hresult
    mdTypeDef   classdef,               // given classdef
    ULONG       *pDual)                 // [OUT] return dual flag here.
{
    ULONG       iFace=0;                // Iface type.
    HRESULT     hr;                     // A result.

    hr = GetIfaceTypeOfTypeDef(classdef, &iFace);
    if (hr == S_OK)
        *pDual = (iFace == ifDual);
    else
        *pDual = 1;

    return (hr);
} // HRESULT MDInternalRO::GetIsDualOfTypeDef()

HRESULT MDInternalRO::GetIfaceTypeOfTypeDef(
    mdTypeDef   classdef,               // [IN] given classdef.
    ULONG       *pIface)                // [OUT] 0=dual, 1=vtable, 2=dispinterface
{
    HRESULT     hr;                     // A result.
    const BYTE  *pVal;                  // The custom value.
    ULONG       cbVal;                  // Size of the custom value.
    ULONG       ItfType = DEFAULT_COM_INTERFACE_TYPE;    // Set the interface type to the default.

    // If the value is not present, the class is assumed dual.
    hr = GetCustomAttributeByName(classdef, INTEROP_INTERFACETYPE_TYPE, (const void**)&pVal, &cbVal);
    if (hr == S_OK)
    {
        _ASSERTE("The ComInterfaceType custom attribute is invalid" && cbVal);
        _ASSERTE("ComInterfaceType custom attribute does not have the right format" && (*pVal == 0x01) && (*(pVal + 1) == 0x00));
        ItfType = *(pVal + 2);
        if (ItfType >= ifLast)
            ItfType = DEFAULT_COM_INTERFACE_TYPE;
    }

    // Set the return value.
    *pIface = ItfType;

    return (hr);
} // HRESULT MDInternalRO::GetIfaceTypeOfTypeDef()

//*****************************************************************************
// Given a methoddef, return a pointer to methoddef's name
//*****************************************************************************
LPCSTR MDInternalRO::GetNameOfMethodDef(
    mdMethodDef     md)
{
    MethodRec *pMethodRec = m_LiteWeightStgdb.m_MiniMd.getMethod(RidFromToken(md));
    return (m_LiteWeightStgdb.m_MiniMd.getNameOfMethod(pMethodRec));
} // LPCSTR MDInternalRO::GetNameOfMethodDef()

//*****************************************************************************
// Given a methoddef, return a pointer to methoddef's signature and methoddef's name
//*****************************************************************************
LPCSTR MDInternalRO::GetNameAndSigOfMethodDef(
    mdMethodDef methoddef,              // [IN] given memberdef
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{
    // Output parameter should not be NULL
    _ASSERTE(ppvSigBlob && pcbSigBlob);
    _ASSERTE(TypeFromToken(methoddef) == mdtMethodDef);

    MethodRec *pMethodRec = m_LiteWeightStgdb.m_MiniMd.getMethod(RidFromToken(methoddef));
    *ppvSigBlob = m_LiteWeightStgdb.m_MiniMd.getSignatureOfMethod(pMethodRec, pcbSigBlob);

    return GetNameOfMethodDef(methoddef);
} // LPCSTR MDInternalRO::GetNameAndSigOfMethodDef()

//*****************************************************************************
// Given a FieldDef, return a pointer to FieldDef's name in UTF8
//*****************************************************************************
LPCSTR MDInternalRO::GetNameOfFieldDef(// return hresult
    mdFieldDef  fd)                     // given field 
{
    FieldRec *pFieldRec = m_LiteWeightStgdb.m_MiniMd.getField(RidFromToken(fd));
    return m_LiteWeightStgdb.m_MiniMd.getNameOfField(pFieldRec);
}


//*****************************************************************************
// Given a classdef, return the name and namespace of the typeref
//*****************************************************************************
void MDInternalRO::GetNameOfTypeRef(  // return TypeDef's name
    mdTypeRef   classref,               // [IN] given typeref
    LPCSTR      *psznamespace,          // [OUT] return typeref name
    LPCSTR      *pszname)               // [OUT] return typeref namespace

{
    _ASSERTE(TypeFromToken(classref) == mdtTypeRef);

    TypeRefRec *pTypeRefRec = m_LiteWeightStgdb.m_MiniMd.getTypeRef(RidFromToken(classref));
    *psznamespace = m_LiteWeightStgdb.m_MiniMd.getNamespaceOfTypeRef(pTypeRefRec);
    *pszname = m_LiteWeightStgdb.m_MiniMd.getNameOfTypeRef(pTypeRefRec);
}

//*****************************************************************************
// return the resolutionscope of typeref
//*****************************************************************************
mdToken MDInternalRO::GetResolutionScopeOfTypeRef(
    mdTypeRef   classref)               // given classref
{
    _ASSERTE(TypeFromToken(classref) == mdtTypeRef && RidFromToken(classref));

    TypeRefRec *pTypeRefRec = m_LiteWeightStgdb.m_MiniMd.getTypeRef(RidFromToken(classref));
    return m_LiteWeightStgdb.m_MiniMd.getResolutionScopeOfTypeRef(pTypeRefRec);
}

//*****************************************************************************
// Given a name, find the corresponding TypeRef.
//*****************************************************************************
HRESULT MDInternalRO::FindTypeRefByName(  // S_OK or error.
        LPCSTR      szNamespace,            // [IN] Namespace for the TypeRef.
        LPCSTR      szName,                 // [IN] Name of the TypeRef.
        mdToken     tkResolutionScope,      // [IN] Resolution Scope fo the TypeRef.
        mdTypeRef   *ptk)                   // [OUT] TypeRef token returned.
{
    HRESULT     hr = NOERROR;

    _ASSERTE(ptk);

    // initialize the output parameter
    *ptk = mdTypeRefNil;
    
    // Treat no namespace as empty string.
    if (!szNamespace)
        szNamespace = "";

    // Do a linear search on compressed version as we do not want to
    // depends on ICR.
    //
    ULONG       cTypeRefRecs = m_LiteWeightStgdb.m_MiniMd.getCountTypeRefs();
    TypeRefRec *pTypeRefRec;
    LPCUTF8     szNamespaceTmp;
    LPCUTF8     szNameTmp;
    mdToken     tkRes;

    for (ULONG i = 1; i <= cTypeRefRecs; i++)
    {
        pTypeRefRec = m_LiteWeightStgdb.m_MiniMd.getTypeRef(i);
        tkRes = m_LiteWeightStgdb.m_MiniMd.getResolutionScopeOfTypeRef(pTypeRefRec);

        if (IsNilToken(tkRes))
        {
            if (!IsNilToken(tkResolutionScope))
                continue;
        }
        else if (tkRes != tkResolutionScope)
            continue;

        szNamespaceTmp = m_LiteWeightStgdb.m_MiniMd.getNamespaceOfTypeRef(pTypeRefRec);
        if (strcmp(szNamespace, szNamespaceTmp))
            continue;

        szNameTmp = m_LiteWeightStgdb.m_MiniMd.getNameOfTypeRef(pTypeRefRec);
        if (!strcmp(szNameTmp, szName))
        {
            *ptk = TokenFromRid(i, mdtTypeRef);
            goto ErrExit;
        }
    }

    // cannot find the typedef
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    return (hr);
}

//*****************************************************************************
// return flags for a given class
//*****************************************************************************
void MDInternalRO::GetTypeDefProps(
    mdTypeDef   td,                     // given classdef
    DWORD       *pdwAttr,               // return flags on class
    mdToken     *ptkExtends)            // [OUT] Put base class TypeDef/TypeRef here.
{
    TypeDefRec *pTypeDefRec = m_LiteWeightStgdb.m_MiniMd.getTypeDef(RidFromToken(td));

    if (ptkExtends)
    {
        *ptkExtends = m_LiteWeightStgdb.m_MiniMd.getExtendsOfTypeDef(pTypeDefRec);
    }
    if (pdwAttr)
    {
        *pdwAttr = m_LiteWeightStgdb.m_MiniMd.getFlagsOfTypeDef(pTypeDefRec);
    }
}


//*****************************************************************************
// return guid pointer to MetaData internal guid pool given a given class
//*****************************************************************************
HRESULT MDInternalRO::GetItemGuid(      // return hresult
    mdToken     tkObj,                  // given item
    CLSID       *pGuid)
{

    HRESULT     hr;                     // A result.
    const BYTE  *pBlob;                 // Blob with dispid.
    ULONG       cbBlob;                 // Length of blob.
    int         ix;                     // Loop control.

    // Get the GUID, if any.
    hr = GetCustomAttributeByName(tkObj, INTEROP_GUID_TYPE, (const void**)&pBlob, &cbBlob);
    if (hr != S_FALSE)
    {
        // Should be in format.  Total length == 41
        // <0x0001><0x24>01234567-0123-0123-0123-001122334455<0x0000>
        if ((cbBlob != 41) || (*(USHORT*)pBlob != 1))
            IfFailGo(E_INVALIDARG);

        WCHAR wzBlob[40];             // Wide char format of guid.
        for (ix=1; ix<=36; ++ix)
            wzBlob[ix] = pBlob[ix+2];
        wzBlob[0] = '{';
        wzBlob[37] = '}';
        wzBlob[38] = 0;
        hr = IIDFromString(wzBlob, pGuid);
    }
    else
        *pGuid = GUID_NULL;
    
ErrExit:
    return hr;
} // HRESULT MDInternalRO::GetItemGuid()


//*****************************************************************************
// // get enclosing class of NestedClass
//***************************************************************************** 
HRESULT MDInternalRO::GetNestedClassProps(  // S_OK or error
    mdTypeDef   tkNestedClass,      // [IN] NestedClass token.
    mdTypeDef   *ptkEnclosingClass) // [OUT] EnclosingClass token.
{
    _ASSERTE(TypeFromToken(tkNestedClass) == mdtTypeDef && ptkEnclosingClass);

    RID rid = m_LiteWeightStgdb.m_MiniMd.FindNestedClassFor(RidFromToken(tkNestedClass));

    if (InvalidRid(rid))
        return CLDB_E_RECORD_NOTFOUND;
    else
    {
        NestedClassRec *pRecord = m_LiteWeightStgdb.m_MiniMd.getNestedClass(rid);
        *ptkEnclosingClass = m_LiteWeightStgdb.m_MiniMd.getEnclosingClassOfNestedClass(pRecord);
        return S_OK;
    }
}

//*******************************************************************************
// Get count of Nested classes given the enclosing class.
//*******************************************************************************
ULONG MDInternalRO::GetCountNestedClasses(  // return count of Nested classes.
    mdTypeDef   tkEnclosingClass)       // [IN]Enclosing class.
{
    ULONG       ulCount;
    ULONG       ulRetCount = 0;
    NestedClassRec *pRecord;

    _ASSERTE(TypeFromToken(tkEnclosingClass) == mdtTypeDef && !IsNilToken(tkEnclosingClass));

    ulCount = m_LiteWeightStgdb.m_MiniMd.getCountNestedClasss();

    for (ULONG i = 1; i <= ulCount; i++)
    {
        pRecord = m_LiteWeightStgdb.m_MiniMd.getNestedClass(i);
        if (tkEnclosingClass == m_LiteWeightStgdb.m_MiniMd.getEnclosingClassOfNestedClass(pRecord))
            ulRetCount++;
    }
    return ulRetCount;
}

//*******************************************************************************
// Return array of Nested classes given the enclosing class.
//*******************************************************************************
ULONG MDInternalRO::GetNestedClasses(   // Return actual count.
    mdTypeDef   tkEnclosingClass,       // [IN] Enclosing class.
    mdTypeDef   *rNestedClasses,        // [OUT] Array of nested class tokens.
    ULONG       ulNestedClasses)        // [IN] Size of array.
{
    ULONG       ulCount;
    ULONG       ulRetCount = 0;
    NestedClassRec *pRecord;

    _ASSERTE(TypeFromToken(tkEnclosingClass) == mdtTypeDef &&
             !IsNilToken(tkEnclosingClass));

    ulCount = m_LiteWeightStgdb.m_MiniMd.getCountNestedClasss();

    for (ULONG i = 1; i <= ulCount; i++)
    {
        pRecord = m_LiteWeightStgdb.m_MiniMd.getNestedClass(i);
        if (tkEnclosingClass == m_LiteWeightStgdb.m_MiniMd.getEnclosingClassOfNestedClass(pRecord))
        {
            if ((ulRetCount+1) <= ulNestedClasses)  // ulRetCount is 0 based.
                rNestedClasses[ulRetCount] = m_LiteWeightStgdb.m_MiniMd.getNestedClassOfNestedClass(pRecord);
            ulRetCount++;
        }
    }
    return ulRetCount;
}

//*******************************************************************************
// return the ModuleRef properties
//*******************************************************************************
void MDInternalRO::GetModuleRefProps(   // return hresult
    mdModuleRef mur,                    // [IN] moduleref token
    LPCSTR      *pszName)               // [OUT] buffer to fill with the moduleref name
{
    _ASSERTE(TypeFromToken(mur) == mdtModuleRef);
    _ASSERTE(pszName);
    
    ModuleRefRec *pModuleRefRec = m_LiteWeightStgdb.m_MiniMd.getModuleRef(RidFromToken(mur));
    *pszName = m_LiteWeightStgdb.m_MiniMd.getNameOfModuleRef(pModuleRefRec);
}



//*****************************************************************************
// Given a scope and a methoddef, return a pointer to methoddef's signature
//*****************************************************************************
PCCOR_SIGNATURE MDInternalRO::GetSigOfMethodDef(
    mdMethodDef methoddef,              // given a methoddef 
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{
    // Output parameter should not be NULL
    _ASSERTE(pcbSigBlob);
    _ASSERTE(TypeFromToken(methoddef) == mdtMethodDef);

    MethodRec *pMethodRec = m_LiteWeightStgdb.m_MiniMd.getMethod(RidFromToken(methoddef));
    return m_LiteWeightStgdb.m_MiniMd.getSignatureOfMethod(pMethodRec, pcbSigBlob);
}


//*****************************************************************************
// Given a scope and a fielddef, return a pointer to fielddef's signature
//*****************************************************************************
PCCOR_SIGNATURE MDInternalRO::GetSigOfFieldDef(
    mdFieldDef  fielddef,               // given a methoddef 
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{

    _ASSERTE(pcbSigBlob);
    _ASSERTE(TypeFromToken(fielddef) == mdtFieldDef);

    FieldRec *pFieldRec = m_LiteWeightStgdb.m_MiniMd.getField(RidFromToken(fielddef));
    return m_LiteWeightStgdb.m_MiniMd.getSignatureOfField(pFieldRec, pcbSigBlob);
} // PCCOR_SIGNATURE MDInternalRO::GetSigOfFieldDef()

//*****************************************************************************
// Turn a signature token into a pointer to the real signature data.
//
//@FUTURE: for short term we have a problem where there is no way to get a 
// fixed up address for a blob and do Merge at the same time.  So we've created
// this dummy table called StandAloneSig which you hand out a rid for.  This
// makes finding the sig an extra indirection that is not required.  The 
// Model Compression save code needs to map the token into a byte offset in
// the heap.  Perhaps we can have another mdt* type to switch on the difference.
// But ultimately it has to simply be "pBlobHeapBase + RidFromToken(mdSig)".
//*****************************************************************************
PCCOR_SIGNATURE MDInternalRO::GetSigFromToken(// S_OK or error.
    mdSignature mdSig,                  // [IN] Signature token.
    ULONG       *pcbSig)                // [OUT] return size of signature.
{
    switch (TypeFromToken(mdSig))
    {
    case mdtSignature:
        {
        StandAloneSigRec *pRec;
        pRec = m_LiteWeightStgdb.m_MiniMd.getStandAloneSig(RidFromToken(mdSig));
        return m_LiteWeightStgdb.m_MiniMd.getSignatureOfStandAloneSig(pRec, pcbSig);
        }
    case mdtTypeSpec:
        {
        TypeSpecRec *pRec;
        pRec = m_LiteWeightStgdb.m_MiniMd.getTypeSpec(RidFromToken(mdSig));
        return m_LiteWeightStgdb.m_MiniMd.getSignatureOfTypeSpec(pRec, pcbSig);
        }
    case mdtMethodDef:
        return GetSigOfMethodDef(mdSig, pcbSig);
    case mdtFieldDef:
        return GetSigOfFieldDef(mdSig, pcbSig);
    }

    // not a known token type.
    _ASSERTE(!"Unexpected token type");
    *pcbSig = 0;
    return NULL;
} // PCCOR_SIGNATURE MDInternalRO::GetSigFromToken()


//*****************************************************************************
// Given methoddef, return the flags
//*****************************************************************************
DWORD MDInternalRO::GetMethodDefProps(  // return mdPublic, mdAbstract, etc
    mdMethodDef md)
{
    MethodRec *pMethodRec = m_LiteWeightStgdb.m_MiniMd.getMethod(RidFromToken(md));
    return m_LiteWeightStgdb.m_MiniMd.getFlagsOfMethod(pMethodRec);
} // DWORD MDInternalRO::GetMethodDefProps()


//*****************************************************************************
// Given a scope and a methoddef/methodimpl, return RVA and impl flags
//*****************************************************************************
void MDInternalRO::GetMethodImplProps(  
    mdMethodDef tk,                     // [IN] MethodDef
    ULONG       *pulCodeRVA,            // [OUT] CodeRVA
    DWORD       *pdwImplFlags)          // [OUT] Impl. Flags
{
    _ASSERTE(TypeFromToken(tk) == mdtMethodDef);

    MethodRec *pMethodRec = m_LiteWeightStgdb.m_MiniMd.getMethod(RidFromToken(tk));

    if (pulCodeRVA)
    {
        *pulCodeRVA = m_LiteWeightStgdb.m_MiniMd.getRVAOfMethod(pMethodRec);
    }

    if (pdwImplFlags)
    {
        *pdwImplFlags = m_LiteWeightStgdb.m_MiniMd.getImplFlagsOfMethod(pMethodRec);
    }
} // void MDInternalRO::GetMethodImplProps()


//*****************************************************************************
// return the field RVA
//*****************************************************************************
HRESULT MDInternalRO::GetFieldRVA(  
    mdToken     fd,                     // [IN] FieldDef
    ULONG       *pulCodeRVA)            // [OUT] CodeRVA
{
    _ASSERTE(TypeFromToken(fd) == mdtFieldDef);
    _ASSERTE(pulCodeRVA);

    ULONG   iRecord = m_LiteWeightStgdb.m_MiniMd.FindFieldRVAFor(RidFromToken(fd));

    if (InvalidRid(iRecord))
    {
        if (pulCodeRVA)
            *pulCodeRVA = 0;
        return CLDB_E_RECORD_NOTFOUND;
    }

    FieldRVARec *pFieldRVARec = m_LiteWeightStgdb.m_MiniMd.getFieldRVA(iRecord);

    *pulCodeRVA = m_LiteWeightStgdb.m_MiniMd.getRVAOfFieldRVA(pFieldRVARec);
    return NOERROR;
}

//*****************************************************************************
// Given a fielddef, return the flags. Such as fdPublic, fdStatic, etc
//*****************************************************************************
DWORD MDInternalRO::GetFieldDefProps(      
    mdFieldDef  fd)                     // given memberdef
{
    _ASSERTE(TypeFromToken(fd) == mdtFieldDef);

    FieldRec *pFieldRec = m_LiteWeightStgdb.m_MiniMd.getField(RidFromToken(fd));
    return m_LiteWeightStgdb.m_MiniMd.getFlagsOfField(pFieldRec);
} // DWORD MDInternalRO::GetFieldDefProps()

    

//*****************************************************************************
// return default value of a token(could be paramdef, fielddef, or property)
//*****************************************************************************
HRESULT MDInternalRO::GetDefaultValue(   // return hresult
    mdToken     tk,                     // [IN] given FieldDef, ParamDef, or Property
    MDDefaultValue  *pMDDefaultValue)   // [OUT] default value
{
    _ASSERTE(pMDDefaultValue);

    HRESULT     hr;
    BYTE        bType;
    const VOID  *pValue;
    ULONG       cbValue;
    RID         rid = m_LiteWeightStgdb.m_MiniMd.FindConstantFor(RidFromToken(tk), TypeFromToken(tk));
    if (InvalidRid(rid))
    {
        pMDDefaultValue->m_bType = ELEMENT_TYPE_VOID;
        return S_OK;
    }
    ConstantRec *pConstantRec = m_LiteWeightStgdb.m_MiniMd.getConstant(rid);

    // get the type of constant value
    bType = m_LiteWeightStgdb.m_MiniMd.getTypeOfConstant(pConstantRec);

    // get the value blob
    pValue = m_LiteWeightStgdb.m_MiniMd.getValueOfConstant(pConstantRec, &cbValue);

    // convert it to our internal default value representation
    hr = _FillMDDefaultValue(bType, pValue, pMDDefaultValue);
    pMDDefaultValue->m_cbSize = cbValue;
    return hr;
} // HRESULT MDInternalRO::GetDefaultValue()


//*****************************************************************************
// Given a scope and a methoddef/fielddef, return the dispid
//*****************************************************************************
HRESULT MDInternalRO::GetDispIdOfMemberDef(     // return hresult
    mdToken     tk,                     // given methoddef or fielddef
    ULONG       *pDispid)               // Put the dispid here.
{
    HRESULT     hr;                     // A result.
    const BYTE  *pBlob;                 // Blob with dispid.
    ULONG       cbBlob;                 // Length of blob.

    // Get the DISPID, if any.
    _ASSERTE(pDispid);

    *pDispid = DISPID_UNKNOWN;
    hr = GetCustomAttributeByName(tk, INTEROP_DISPID_TYPE, (const void**)&pBlob, &cbBlob);
    if (hr != S_FALSE)
    {
        // Check that this might be a dispid.
        if (cbBlob >= (sizeof(*pDispid)+2))
            *pDispid = *reinterpret_cast<UNALIGNED const ULONG *>(pBlob+2);
        else
            IfFailGo(E_INVALIDARG);
    }
    
ErrExit:
    return hr;
} // HRESULT MDInternalRO::GetDispIdOfMemberDef()


//*****************************************************************************
// Given interfaceimpl, return the TypeRef/TypeDef and flags
//*****************************************************************************
mdToken MDInternalRO::GetTypeOfInterfaceImpl( // return hresult
    mdInterfaceImpl iiImpl)             // given a interfaceimpl
{
    _ASSERTE(TypeFromToken(iiImpl) == mdtInterfaceImpl);

    InterfaceImplRec *pIIRec = m_LiteWeightStgdb.m_MiniMd.getInterfaceImpl(RidFromToken(iiImpl));
    return m_LiteWeightStgdb.m_MiniMd.getInterfaceOfInterfaceImpl(pIIRec);      
} // mdToken MDInternalRO::GetTypeOfInterfaceImpl()

//*****************************************************************************
// Given a classname, return the typedef
//*****************************************************************************
HRESULT MDInternalRO::FindTypeDef(      // return hresult
    LPCSTR      szNamespace,            // [IN] Namespace for the TypeDef.
    LPCSTR      szName,                 // [IN] Name of the TypeDef.
    mdToken     tkEnclosingClass,       // [IN] TypeDef/TypeRef of enclosing class.
    mdTypeDef   *ptypedef)              // [OUT] return typedef
{
    HRESULT     hr = NOERROR;

    _ASSERTE(ptypedef);
    _ASSERTE(TypeFromToken(tkEnclosingClass) == mdtTypeRef ||
             TypeFromToken(tkEnclosingClass) == mdtTypeDef ||
             IsNilToken(tkEnclosingClass));

    // initialize the output parameter
    *ptypedef = mdTypeDefNil;

    // Treat no namespace as empty string.
    if (!szNamespace)
        szNamespace = "";

    // Do a linear search
    //
    ULONG       cTypeDefRecs = m_LiteWeightStgdb.m_MiniMd.getCountTypeDefs();
    TypeDefRec *pTypeDefRec;
    LPCUTF8     pszname;
    LPCUTF8     psznamespace;
    DWORD       dwFlags;

    // Search for the TypeDef
    for (ULONG i = 1; i <= cTypeDefRecs; i++)
    {
        pTypeDefRec = m_LiteWeightStgdb.m_MiniMd.getTypeDef(i);

        dwFlags = m_LiteWeightStgdb.m_MiniMd.getFlagsOfTypeDef(pTypeDefRec);

        if (!IsTdNested(dwFlags) && !IsNilToken(tkEnclosingClass))
        {
            // If the class is not Nested and EnclosingClass passed in is not nil
            continue;
        }
        else if (IsTdNested(dwFlags) && IsNilToken(tkEnclosingClass))
        {
            // If the class is nested and EnclosingClass passed is nil
            continue;
        }
        else if (!IsNilToken(tkEnclosingClass))
        {
            // If the EnclosingClass passed in is not nil
            if (TypeFromToken(tkEnclosingClass) == mdtTypeRef)
            {
                TypeRefRec  *pTypeRefRec;
                mdToken     tkResolutionScope;
                mdTypeDef   td;

                pTypeRefRec = m_LiteWeightStgdb.m_MiniMd.getTypeRef(RidFromToken(tkEnclosingClass));
                tkResolutionScope = m_LiteWeightStgdb.m_MiniMd.getResolutionScopeOfTypeRef(pTypeRefRec);
                psznamespace = m_LiteWeightStgdb.m_MiniMd.getNamespaceOfTypeRef(pTypeRefRec);
                pszname = m_LiteWeightStgdb.m_MiniMd.getNameOfTypeRef(pTypeRefRec);

                hr = FindTypeDef(psznamespace,
                                   pszname,
                                   (TypeFromToken(tkResolutionScope) == mdtTypeRef) ? tkResolutionScope : mdTokenNil,
                                   &td);
                if (hr == S_OK)
                {
                    if (td != tkEnclosingClass)
                        continue;
                }
                else if (hr == CLDB_E_RECORD_NOTFOUND)
                {
                    continue;
                }
                else
                    return hr;
            }
            else    // TypeFromToken(tkEnclosingClass) == mdtTypeDef
            {
                RID         iNestedClassRec;
                NestedClassRec *pNestedClassRec;
                mdTypeDef   tkEnclosingClassTmp;

                iNestedClassRec = m_LiteWeightStgdb.m_MiniMd.FindNestedClassFor(i);
                if (InvalidRid(iNestedClassRec))
                    continue;
                pNestedClassRec = m_LiteWeightStgdb.m_MiniMd.getNestedClass(iNestedClassRec);
                tkEnclosingClassTmp = m_LiteWeightStgdb.m_MiniMd.getEnclosingClassOfNestedClass(pNestedClassRec);
                if (tkEnclosingClass != tkEnclosingClassTmp)
                    continue;
            }
        }

        pszname = m_LiteWeightStgdb.m_MiniMd.getNameOfTypeDef(pTypeDefRec);
        if ( strcmp(szName, pszname) == 0)
        {
            psznamespace = m_LiteWeightStgdb.m_MiniMd.getNamespaceOfTypeDef(pTypeDefRec);
            if (strcmp(szNamespace, psznamespace) == 0)
            {
                *ptypedef = TokenFromRid(i, mdtTypeDef);
                return S_OK;
            }
        }
    }    // cannot find the typedef
    return CLDB_E_RECORD_NOTFOUND;
} // HRESULT MDInternalRO::FindTypeDef()

//*****************************************************************************
// Given a memberref, return a pointer to memberref's name and signature
//*****************************************************************************
LPCSTR MDInternalRO::GetNameAndSigOfMemberRef(  // meberref's name
    mdMemberRef memberref,              // given a memberref 
    PCCOR_SIGNATURE *ppvSigBlob,        // [OUT] point to a blob value of COM+ signature
    ULONG       *pcbSigBlob)            // [OUT] count of bytes in the signature blob
{
    _ASSERTE(TypeFromToken(memberref) == mdtMemberRef);

    MemberRefRec *pMemberRefRec = m_LiteWeightStgdb.m_MiniMd.getMemberRef(RidFromToken(memberref));
    if (ppvSigBlob)
    {
        _ASSERTE(pcbSigBlob);
        *ppvSigBlob = m_LiteWeightStgdb.m_MiniMd.getSignatureOfMemberRef(pMemberRefRec, pcbSigBlob);
    }
    return m_LiteWeightStgdb.m_MiniMd.getNameOfMemberRef(pMemberRefRec);
} // LPCSTR MDInternalRO::GetNameAndSigOfMemberRef()

//*****************************************************************************
// Given a memberref, return parent token. It can be a TypeRef, ModuleRef, or a MethodDef
//*****************************************************************************
mdToken MDInternalRO::GetParentOfMemberRef(   // return parent token
    mdMemberRef memberref)              // given a typedef
{
    _ASSERTE(TypeFromToken(memberref) == mdtMemberRef);

    MemberRefRec *pMemberRefRec = m_LiteWeightStgdb.m_MiniMd.getMemberRef(RidFromToken(memberref));
    return m_LiteWeightStgdb.m_MiniMd.getClassOfMemberRef(pMemberRefRec);
} // mdToken MDInternalRO::GetParentOfMemberRef()



//*****************************************************************************
// return properties of a paramdef
//*****************************************************************************/
LPCSTR MDInternalRO::GetParamDefProps (
    mdParamDef  paramdef,               // given a paramdef
    USHORT      *pusSequence,           // [OUT] slot number for this parameter
    DWORD       *pdwAttr)               // [OUT] flags
{
    _ASSERTE(TypeFromToken(paramdef) == mdtParamDef);
    ParamRec *pParamRec = m_LiteWeightStgdb.m_MiniMd.getParam(RidFromToken(paramdef));
    if (pdwAttr)
    {
        *pdwAttr = m_LiteWeightStgdb.m_MiniMd.getFlagsOfParam(pParamRec);
    }
    if (pusSequence)
    {
        *pusSequence = m_LiteWeightStgdb.m_MiniMd.getSequenceOfParam(pParamRec);
    }
    return m_LiteWeightStgdb.m_MiniMd.getNameOfParam(pParamRec);
} // LPCSTR MDInternalRO::GetParamDefProps ()


//*****************************************************************************
// Get property info for the method.
//*****************************************************************************
int MDInternalRO::CMethodSemanticsMapSearcher::Compare(
    const CMethodSemanticsMap *psFirst, 
    const CMethodSemanticsMap *psSecond)
{
    if (psFirst->m_mdMethod < psSecond->m_mdMethod)
        return -1;
    if (psFirst->m_mdMethod > psSecond->m_mdMethod)
        return 1;
    return 0;
} // int MDInternalRO::CMethodSemanticsMapSearcher::Compare()
int MDInternalRO::CMethodSemanticsMapSorter::Compare(
    CMethodSemanticsMap *psFirst, 
    CMethodSemanticsMap *psSecond)
{
    if (psFirst->m_mdMethod < psSecond->m_mdMethod)
        return -1;
    if (psFirst->m_mdMethod > psSecond->m_mdMethod)
        return 1;
    return 0;
} // int MDInternalRO::CMethodSemanticsMapSorter::Compare()

HRESULT MDInternalRO::GetPropertyInfoForMethodDef(  // Result.
    mdMethodDef md,                     // [IN] memberdef
    mdProperty  *ppd,                   // [OUT] put property token here
    LPCSTR      *pName,                 // [OUT] put pointer to name here
    ULONG       *pSemantic)             // [OUT] put semantic here
{
    MethodSemanticsRec *pSemantics;     // A MethodSemantics record.
    MethodSemanticsRec *pFound=0;       // A MethodSemantics record that is a property for the desired function.
    RID         ridCur;                 // loop control.
    RID         ridMax;                 // Count of entries in table.
    USHORT      usSemantics;            // A method's semantics.
    mdToken     tk;                     // A method def.

    ridMax = m_LiteWeightStgdb.m_MiniMd.getCountMethodSemantics();

    // Lazy initialization of m_pMethodSemanticsMap
    if (ridMax > 10 && m_pMethodSemanticsMap == 0)
    {
        m_pMethodSemanticsMap = new CMethodSemanticsMap[ridMax];
        if (m_pMethodSemanticsMap != 0)
        {
            // Fill the table in MethodSemantics order.
            for (ridCur = 1; ridCur <= ridMax; ridCur++)
            {
                pSemantics = m_LiteWeightStgdb.m_MiniMd.getMethodSemantics(ridCur);
                tk = m_LiteWeightStgdb.m_MiniMd.getMethodOfMethodSemantics(pSemantics);
                m_pMethodSemanticsMap[ridCur-1].m_mdMethod = tk;
                m_pMethodSemanticsMap[ridCur-1].m_ridSemantics = ridCur;
            }
            // Sort to MethodDef order.
            CMethodSemanticsMapSorter sorter(m_pMethodSemanticsMap, ridMax);
            sorter.Sort();
        }
    }

    // Use m_pMethodSemanticsMap if it has been built.
    if (m_pMethodSemanticsMap != 0)
    {
        CMethodSemanticsMapSearcher searcher(m_pMethodSemanticsMap, ridMax);
        CMethodSemanticsMap target;
        const CMethodSemanticsMap *pMatchedMethod;
        target.m_mdMethod = md;
        pMatchedMethod = searcher.Find(&target);

        // Was there at least one match?
        if (pMatchedMethod)
        {
            _ASSERTE(pMatchedMethod >= m_pMethodSemanticsMap); 
            _ASSERTE(pMatchedMethod < m_pMethodSemanticsMap+ridMax); 
            _ASSERTE(pMatchedMethod->m_mdMethod == md); 

            ridCur = pMatchedMethod->m_ridSemantics;
            pSemantics = m_LiteWeightStgdb.m_MiniMd.getMethodSemantics(ridCur);
            usSemantics = m_LiteWeightStgdb.m_MiniMd.getSemanticOfMethodSemantics(pSemantics);

            // If the semantics record is a getter or setter for the method, that's what we want.
            if (usSemantics == msGetter || usSemantics == msSetter)
                pFound = pSemantics;
            else
            {   // The semantics record was neither getter or setter.  Because there can be 
                //  multiple semantics records for a given method, look for other semantics 
                //  records that match this record.
                const CMethodSemanticsMap *pScan;
                const CMethodSemanticsMap *pLo=m_pMethodSemanticsMap;
                const CMethodSemanticsMap *pHi=pLo+ridMax-1;
                for (pScan = pMatchedMethod-1; pScan >= pLo; --pScan)
                {
                    if (pScan->m_mdMethod == md)
                    {
                        ridCur = pScan->m_ridSemantics;
                        pSemantics = m_LiteWeightStgdb.m_MiniMd.getMethodSemantics(ridCur);
                        usSemantics = m_LiteWeightStgdb.m_MiniMd.getSemanticOfMethodSemantics(pSemantics);

                        if (usSemantics == msGetter || usSemantics == msSetter)
                        {
                            pFound = pSemantics;
                            break;
                        }
                    }
                    else
                        break;
                }

                if (pFound == 0)
                {   // Not found looking down, try looking up.
                    for (pScan = pMatchedMethod+1; pScan <= pHi; ++pScan)
                    {
                        if (pScan->m_mdMethod == md)
                        {
                            ridCur = pScan->m_ridSemantics;
                            pSemantics = m_LiteWeightStgdb.m_MiniMd.getMethodSemantics(ridCur);
                            usSemantics = m_LiteWeightStgdb.m_MiniMd.getSemanticOfMethodSemantics(pSemantics);

                            if (usSemantics == msGetter || usSemantics == msSetter)
                            {
                                pFound = pSemantics;
                                break;
                            }
                        }
                        else
                            break;
                    }

                }
            }
        }
    }
    else
    {   // Scan entire table.
        for (ridCur = 1; ridCur <= ridMax; ridCur++)
        {   
            pSemantics = m_LiteWeightStgdb.m_MiniMd.getMethodSemantics(ridCur);
            if (md == m_LiteWeightStgdb.m_MiniMd.getMethodOfMethodSemantics(pSemantics))
            {   // The method matched, is this a property?
                usSemantics = m_LiteWeightStgdb.m_MiniMd.getSemanticOfMethodSemantics(pSemantics);
                if (usSemantics == msGetter || usSemantics == msSetter)
                {   // found a match. 
                    pFound = pSemantics;
                    break;
                }
            }
        }
    }
    
    // Did the search find anything?
    if (pFound)
    {   // found a match. Fill out the output parameters
        PropertyRec     *pProperty;
        mdProperty      prop;
        prop = m_LiteWeightStgdb.m_MiniMd.getAssociationOfMethodSemantics(pFound);

        if (ppd)
            *ppd = prop;
        pProperty = m_LiteWeightStgdb.m_MiniMd.getProperty(RidFromToken(prop));

        if (pName)
            *pName = m_LiteWeightStgdb.m_MiniMd.getNameOfProperty(pProperty);

        if (pSemantic)
            *pSemantic =  usSemantics;
        return S_OK;
    }
    return S_FALSE;
} // HRESULT MDInternalRO::GetPropertyInfoForMethodDef()


//*****************************************************************************
// return the pack size of a class
//*****************************************************************************
HRESULT  MDInternalRO::GetClassPackSize(
    mdTypeDef   td,                     // [IN] give typedef
    DWORD       *pdwPackSize)           // [OUT] 
{
    HRESULT     hr = NOERROR;

    _ASSERTE(TypeFromToken(td) == mdtTypeDef && pdwPackSize);

    ClassLayoutRec *pRec;
    RID         ridClassLayout = m_LiteWeightStgdb.m_MiniMd.FindClassLayoutFor(RidFromToken(td));

    if (InvalidRid(ridClassLayout))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }

    pRec = m_LiteWeightStgdb.m_MiniMd.getClassLayout(RidFromToken(ridClassLayout));
    *pdwPackSize = m_LiteWeightStgdb.m_MiniMd.getPackingSizeOfClassLayout(pRec);
ErrExit:
    return hr;
} // HRESULT  MDInternalRO::GetClassPackSize()


//*****************************************************************************
// return the total size of a value class
//*****************************************************************************
HRESULT MDInternalRO::GetClassTotalSize( // return error if a class does not have total size info
    mdTypeDef   td,                     // [IN] give typedef
    ULONG       *pulClassSize)          // [OUT] return the total size of the class
{
    _ASSERTE(TypeFromToken(td) == mdtTypeDef && pulClassSize);

    ClassLayoutRec *pRec;
    HRESULT     hr = NOERROR;
    RID         ridClassLayout = m_LiteWeightStgdb.m_MiniMd.FindClassLayoutFor(RidFromToken(td));

    if (InvalidRid(ridClassLayout))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }

    pRec = m_LiteWeightStgdb.m_MiniMd.getClassLayout(RidFromToken(ridClassLayout));
    *pulClassSize = m_LiteWeightStgdb.m_MiniMd.getClassSizeOfClassLayout(pRec);
ErrExit:
    return hr;
} // HRESULT MDInternalRO::GetClassTotalSize()


//*****************************************************************************
// init the layout enumerator of a class
//*****************************************************************************
HRESULT  MDInternalRO::GetClassLayoutInit(
    mdTypeDef   td,                     // [IN] give typedef
    MD_CLASS_LAYOUT *pmdLayout)         // [OUT] set up the status of query here
{
    HRESULT     hr = NOERROR;
    _ASSERTE(TypeFromToken(td) == mdtTypeDef);
    
    // initialize the output parameter
    _ASSERTE(pmdLayout);
    memset(pmdLayout, 0, sizeof(MD_CLASS_LAYOUT));

    TypeDefRec  *pTypeDefRec;

    // record for this typedef in TypeDef Table
    pTypeDefRec = m_LiteWeightStgdb.m_MiniMd.getTypeDef(RidFromToken(td));

    // find the starting and end field for this typedef
    pmdLayout->m_ridFieldCur = m_LiteWeightStgdb.m_MiniMd.getFieldListOfTypeDef(pTypeDefRec);
    pmdLayout->m_ridFieldEnd = m_LiteWeightStgdb.m_MiniMd.getEndFieldListOfTypeDef(pTypeDefRec);
    return hr;
} // HRESULT  MDInternalRO::GetClassLayoutInit()

//*****************************************************************************
// enum the next the field layout 
//*****************************************************************************
HRESULT MDInternalRO::GetClassLayoutNext(
    MD_CLASS_LAYOUT *pLayout,           // [IN|OUT] set up the status of query here
    mdFieldDef  *pfd,                   // [OUT] field def
    ULONG       *pulOffset)             // [OUT] field offset or sequence
{
    HRESULT     hr = S_OK;

    _ASSERTE(pfd && pulOffset && pLayout);

    RID     iLayout2;
    FieldLayoutRec *pRec;

    // Make sure no one is messing with pLayout->m_ridFieldLayoutCur, since this doesn't
    // mean anything if we are using FieldLayout table.
    while (pLayout->m_ridFieldCur < pLayout->m_ridFieldEnd)
    {
        iLayout2 = m_LiteWeightStgdb.m_MiniMd.FindFieldLayoutFor(pLayout->m_ridFieldCur);
        pLayout->m_ridFieldCur++;
        if (!InvalidRid(iLayout2))
        {
            pRec = m_LiteWeightStgdb.m_MiniMd.getFieldLayout(iLayout2);
            *pulOffset = m_LiteWeightStgdb.m_MiniMd.getOffSetOfFieldLayout(pRec);
            _ASSERTE(*pulOffset != ULONG_MAX);
            *pfd = TokenFromRid(pLayout->m_ridFieldCur - 1, mdtFieldDef);
            goto ErrExit;
        }
    }

    *pfd = mdFieldDefNil;
    hr = S_FALSE;

    // fall through

ErrExit:
    return hr;
} // HRESULT MDInternalRO::GetClassLayoutNext()


//*****************************************************************************
// return the field's native type signature
//*****************************************************************************
HRESULT MDInternalRO::GetFieldMarshal(  // return error if no native type associate with the token
    mdToken     tk,                     // [IN] given fielddef or paramdef
    PCCOR_SIGNATURE *pSigNativeType,    // [OUT] the native type signature
    ULONG       *pcbNativeType)         // [OUT] the count of bytes of *ppvNativeType
{
    // output parameters have to be supplied
    _ASSERTE(pcbNativeType);

    RID         rid;
    FieldMarshalRec *pFieldMarshalRec;
    HRESULT     hr = NOERROR;

    // find the row containing the marshal definition for tk
    rid = m_LiteWeightStgdb.m_MiniMd.FindFieldMarshalFor(RidFromToken(tk), TypeFromToken(tk));
    if (InvalidRid(rid))
    {
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    pFieldMarshalRec = m_LiteWeightStgdb.m_MiniMd.getFieldMarshal(rid);

    // get the native type 
    *pSigNativeType = m_LiteWeightStgdb.m_MiniMd.getNativeTypeOfFieldMarshal(pFieldMarshalRec, pcbNativeType);
ErrExit:
    return hr;
} // HRESULT MDInternalRO::GetFieldMarshal()



//*****************************************
// property APIs
//*****************************************

//*****************************************************************************
// Find property by name
//*****************************************************************************
HRESULT  MDInternalRO::FindProperty(
    mdTypeDef   td,                     // [IN] given a typdef
    LPCSTR      szPropName,             // [IN] property name
    mdProperty  *pProp)                 // [OUT] return property token
{
    HRESULT     hr = NOERROR;

    // output parameters have to be supplied
    _ASSERTE(TypeFromToken(td) == mdtTypeDef && pProp);

    PropertyMapRec *pRec;
    PropertyRec *pProperty;
    RID         ridPropertyMap;
    RID         ridCur;
    RID         ridEnd;
    LPCUTF8     szName;

    ridPropertyMap = m_LiteWeightStgdb.m_MiniMd.FindPropertyMapFor(RidFromToken(td));
    if (InvalidRid(ridPropertyMap))
    {
        // not found!
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }

    pRec = m_LiteWeightStgdb.m_MiniMd.getPropertyMap(ridPropertyMap);

    // get the starting/ending rid of properties of this typedef
    ridCur = m_LiteWeightStgdb.m_MiniMd.getPropertyListOfPropertyMap(pRec);
    ridEnd = m_LiteWeightStgdb.m_MiniMd.getEndPropertyListOfPropertyMap(pRec);

    for (; ridCur < ridEnd; ridCur ++)
    {
        pProperty = m_LiteWeightStgdb.m_MiniMd.getProperty(ridCur);
        szName = m_LiteWeightStgdb.m_MiniMd.getNameOfProperty(pProperty);
        if (strcmp(szName, szPropName) ==0)
        {
            // Found the match. Set the output parameter and we are done.
            *pProp = TokenFromRid(ridCur, mdtProperty);
            goto ErrExit;
        }
    }

    // not found
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    return (hr);

} // HRESULT  MDInternalRO::FindProperty()



//*****************************************************************************
// return the properties of a property
//*****************************************************************************
void  MDInternalRO::GetPropertyProps(
    mdProperty  prop,                   // [IN] property token
    LPCSTR      *pszProperty,           // [OUT] property name
    DWORD       *pdwPropFlags,          // [OUT] property flags.
    PCCOR_SIGNATURE *ppvSig,            // [OUT] property type. pointing to meta data internal blob
    ULONG       *pcbSig)                // [OUT] count of bytes in *ppvSig
{
    HRESULT     hr = NOERROR;

    // output parameters have to be supplied
    _ASSERTE(TypeFromToken(prop) == mdtProperty);

    PropertyRec     *pProperty;
    ULONG           cbSig;

    pProperty = m_LiteWeightStgdb.m_MiniMd.getProperty(RidFromToken(prop));

    // get name of the property
    if (pszProperty)
        *pszProperty = m_LiteWeightStgdb.m_MiniMd.getNameOfProperty(pProperty);

    // get the flags of property
    if (pdwPropFlags)
        *pdwPropFlags = m_LiteWeightStgdb.m_MiniMd.getPropFlagsOfProperty(pProperty);

    // get the type of the property
    if (ppvSig)
    {
        *ppvSig = m_LiteWeightStgdb.m_MiniMd.getTypeOfProperty(pProperty, &cbSig);
        if (pcbSig) 
        {
            *pcbSig = cbSig;
        }
    }

} // void  MDInternalRO::GetPropertyProps()


//**********************************
//
// Event APIs
//
//**********************************

//*****************************************************************************
// return an event by given the name
//*****************************************************************************
HRESULT  MDInternalRO::FindEvent(
    mdTypeDef   td,                     // [IN] given a typdef
    LPCSTR      szEventName,            // [IN] event name
    mdEvent     *pEvent)                // [OUT] return event token
{
    HRESULT     hr = NOERROR;

    // output parameters have to be supplied
    _ASSERTE(TypeFromToken(td) == mdtTypeDef && pEvent);

    EventMapRec *pRec;
    EventRec    *pEventRec;
    RID         ridEventMap;
    RID         ridCur;
    RID         ridEnd;
    LPCUTF8     szName;

    ridEventMap = m_LiteWeightStgdb.m_MiniMd.FindEventMapFor(RidFromToken(td));
    if (InvalidRid(ridEventMap))
    {
        // not found!
        hr = CLDB_E_RECORD_NOTFOUND;
        goto ErrExit;
    }
    pRec = m_LiteWeightStgdb.m_MiniMd.getEventMap(ridEventMap);

    // get the starting/ending rid of properties of this typedef
    ridCur = m_LiteWeightStgdb.m_MiniMd.getEventListOfEventMap(pRec);
    ridEnd = m_LiteWeightStgdb.m_MiniMd.getEndEventListOfEventMap(pRec);

    for (; ridCur < ridEnd; ridCur ++)
    {
        pEventRec = m_LiteWeightStgdb.m_MiniMd.getEvent(ridCur);
        szName = m_LiteWeightStgdb.m_MiniMd.getNameOfEvent(pEventRec);
        if (strcmp(szName, szEventName) ==0)
        {
            // Found the match. Set the output parameter and we are done.
            *pEvent = TokenFromRid(ridCur, mdtEvent);
            goto ErrExit;
        }
    }

    // not found
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    return (hr);
} // HRESULT  MDInternalRO::FindEvent()


//*****************************************************************************
// return the properties of an event
//*****************************************************************************
void  MDInternalRO::GetEventProps(           // S_OK, S_FALSE, or error.
    mdEvent     ev,                     // [IN] event token
    LPCSTR      *pszEvent,                // [OUT] Event name
    DWORD       *pdwEventFlags,         // [OUT] Event flags.
    mdToken     *ptkEventType)         // [OUT] EventType class
{
    // output parameters have to be supplied
    _ASSERTE(TypeFromToken(ev) == mdtEvent);

    EventRec        *pEvent;

    pEvent = m_LiteWeightStgdb.m_MiniMd.getEvent(RidFromToken(ev));
    if (pszEvent)
        *pszEvent = m_LiteWeightStgdb.m_MiniMd.getNameOfEvent(pEvent);
    if (pdwEventFlags)
        *pdwEventFlags = m_LiteWeightStgdb.m_MiniMd.getEventFlagsOfEvent(pEvent);
    if (ptkEventType)
        *ptkEventType = m_LiteWeightStgdb.m_MiniMd.getEventTypeOfEvent(pEvent);
} // void  MDInternalRO::GetEventProps()


//*****************************************************************************
// Find methoddef of a particular associate with a property or an event
//*****************************************************************************
HRESULT  MDInternalRO::FindAssociate(
    mdToken     evprop,                 // [IN] given a property or event token
    DWORD       dwSemantics,            // [IN] given a associate semantics(setter, getter, testdefault, reset)
    mdMethodDef *pmd)                   // [OUT] return method def token 
{
    HRESULT     hr = NOERROR;

    // output parameters have to be supplied
    _ASSERTE(pmd);
    _ASSERTE(TypeFromToken(evprop) == mdtEvent || TypeFromToken(evprop) == mdtProperty);

    MethodSemanticsRec *pSemantics;
    RID         ridCur;
    RID         ridEnd;

    ridCur = m_LiteWeightStgdb.m_MiniMd.getAssociatesForToken(evprop, &ridEnd);
    for (; ridCur < ridEnd; ridCur++)
    {
        pSemantics = m_LiteWeightStgdb.m_MiniMd.getMethodSemantics(ridCur);
        if (dwSemantics == m_LiteWeightStgdb.m_MiniMd.getSemanticOfMethodSemantics(pSemantics))
        {
            // found a match
            *pmd = m_LiteWeightStgdb.m_MiniMd.getMethodOfMethodSemantics(pSemantics);
            goto ErrExit;
        }
    }

    // not found
    hr = CLDB_E_RECORD_NOTFOUND;
ErrExit:
    return hr;
} // HRESULT  MDInternalRO::FindAssociate()


//*****************************************************************************
// get counts of methodsemantics associated with a particular property/event
//*****************************************************************************
void MDInternalRO::EnumAssociateInit(
    mdToken     evprop,                 // [IN] given a property or an event token
    HENUMInternal *phEnum)              // [OUT] cursor to hold the query result
{

    _ASSERTE(phEnum);

    memset(phEnum, 0, sizeof(HENUMInternal));

    // There is no token kind!!!
    phEnum->m_tkKind = ULONG_MAX;

    // output parameters have to be supplied
    _ASSERTE(TypeFromToken(evprop) == mdtEvent || TypeFromToken(evprop) == mdtProperty);

    phEnum->m_EnumType = MDSimpleEnum;
    phEnum->m_ulCur = phEnum->m_ulStart = m_LiteWeightStgdb.m_MiniMd.getAssociatesForToken(evprop, &phEnum->m_ulEnd);
    phEnum->m_ulCount = phEnum->m_ulEnd - phEnum->m_ulStart;
} // void MDInternalRO::EnumAssociateInit()


//*****************************************************************************
// get all methodsemantics associated with a particular property/event
//*****************************************************************************
void MDInternalRO::GetAllAssociates(
    HENUMInternal *phEnum,              // [OUT] cursor to hold the query result
    ASSOCIATE_RECORD *pAssociateRec,    // [OUT] struct to fill for output
    ULONG       cAssociateRec)          // [IN] size of the buffer
{
    _ASSERTE(phEnum && pAssociateRec);

    MethodSemanticsRec *pSemantics;
    RID         ridCur;
    _ASSERTE(cAssociateRec == phEnum->m_ulCount);

    // Convert from row pointers to RIDs.
    for (ridCur = phEnum->m_ulStart; ridCur < phEnum->m_ulEnd; ++ridCur)
    {
        pSemantics = m_LiteWeightStgdb.m_MiniMd.getMethodSemantics(ridCur);

        pAssociateRec[ridCur-phEnum->m_ulStart].m_memberdef = m_LiteWeightStgdb.m_MiniMd.getMethodOfMethodSemantics(pSemantics);
        pAssociateRec[ridCur-phEnum->m_ulStart].m_dwSemantics = m_LiteWeightStgdb.m_MiniMd.getSemanticOfMethodSemantics(pSemantics);
    }
} // void MDInternalRO::GetAllAssociates()


//*****************************************************************************
// Get the Action and Permissions blob for a given PermissionSet.
//*****************************************************************************
void MDInternalRO::GetPermissionSetProps(
    mdPermission pm,                    // [IN] the permission token.
    DWORD       *pdwAction,             // [OUT] CorDeclSecurity.
    void const  **ppvPermission,        // [OUT] permission blob.
    ULONG       *pcbPermission)         // [OUT] count of bytes of pvPermission.
{
    _ASSERTE(TypeFromToken(pm) == mdtPermission);
    _ASSERTE(pdwAction && ppvPermission && pcbPermission);

    DeclSecurityRec *pPerm;

    pPerm = m_LiteWeightStgdb.m_MiniMd.getDeclSecurity(RidFromToken(pm));
    *pdwAction = m_LiteWeightStgdb.m_MiniMd.getActionOfDeclSecurity(pPerm);
    *ppvPermission = m_LiteWeightStgdb.m_MiniMd.getPermissionSetOfDeclSecurity(pPerm, pcbPermission);
} // void MDInternalRO::GetPermissionSetProps()

//*****************************************************************************
// Get the String given the String token.
//*****************************************************************************
LPCWSTR MDInternalRO::GetUserString(    // Offset into the string blob heap.
    mdString    stk,                    // [IN] the string token.
    ULONG       *pchString,             // [OUT] count of characters in the string.
    BOOL        *pbIs80Plus)            // [OUT] specifies where there are extended characters >= 0x80.
{
    LPWSTR wszTmp;

    _ASSERTE(pchString);
    wszTmp = (LPWSTR) (m_LiteWeightStgdb.m_MiniMd.GetUserString(RidFromToken(stk), pchString));
    _ASSERTE((*pchString % sizeof(WCHAR)) == 1);
    *pchString /= sizeof(WCHAR);
    if (pbIs80Plus)
        *pbIs80Plus = *(reinterpret_cast<PBYTE>(wszTmp + *pchString));
    return wszTmp;
} // LPCWSTR MDInternalRO::GetUserString()

//*****************************************************************************
// Return contents of Pinvoke given the forwarded member token.
//***************************************************************************** 
HRESULT MDInternalRO::GetPinvokeMap(
    mdToken     tk,                     // [IN] FieldDef or MethodDef.
    DWORD       *pdwMappingFlags,       // [OUT] Flags used for mapping.
    LPCSTR      *pszImportName,         // [OUT] Import name.
    mdModuleRef *pmrImportDLL)          // [OUT] ModuleRef token for the target DLL.
{
    ImplMapRec  *pRecord;
    ULONG       iRecord;

    iRecord = m_LiteWeightStgdb.m_MiniMd.FindImplMapFor(RidFromToken(tk), TypeFromToken(tk));
    if (InvalidRid(iRecord))
        return CLDB_E_RECORD_NOTFOUND;
    else
        pRecord = m_LiteWeightStgdb.m_MiniMd.getImplMap(iRecord);

    if (pdwMappingFlags)
        *pdwMappingFlags = m_LiteWeightStgdb.m_MiniMd.getMappingFlagsOfImplMap(pRecord);
    if (pszImportName)
        *pszImportName = m_LiteWeightStgdb.m_MiniMd.getImportNameOfImplMap(pRecord);
    if (pmrImportDLL)
        *pmrImportDLL = m_LiteWeightStgdb.m_MiniMd.getImportScopeOfImplMap(pRecord);

    return S_OK;
} // HRESULT MDInternalRO::GetPinvokeMap()

//*****************************************************************************
// Get the properties for the given Assembly token.
//*****************************************************************************
void MDInternalRO::GetAssemblyProps(
    mdAssembly  mda,                    // [IN] The Assembly for which to get the properties.
    const void  **ppbPublicKey,         // [OUT] Pointer to the public key.
    ULONG       *pcbPublicKey,          // [OUT] Count of bytes in the public key.
    ULONG       *pulHashAlgId,          // [OUT] Hash Algorithm.
    LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
    AssemblyMetaDataInternal *pMetaData,// [OUT] Assembly MetaData.
    DWORD       *pdwAssemblyFlags)      // [OUT] Flags.
{
    AssemblyRec *pRecord;

    _ASSERTE(TypeFromToken(mda) == mdtAssembly && RidFromToken(mda));
    pRecord = m_LiteWeightStgdb.m_MiniMd.getAssembly(RidFromToken(mda));

    if (ppbPublicKey)
        *ppbPublicKey = m_LiteWeightStgdb.m_MiniMd.getPublicKeyOfAssembly(pRecord, pcbPublicKey);
    if (pulHashAlgId)
        *pulHashAlgId = m_LiteWeightStgdb.m_MiniMd.getHashAlgIdOfAssembly(pRecord);
    if (pszName)
        *pszName = m_LiteWeightStgdb.m_MiniMd.getNameOfAssembly(pRecord);
    if (pMetaData)
    {
        pMetaData->usMajorVersion = m_LiteWeightStgdb.m_MiniMd.getMajorVersionOfAssembly(pRecord);
        pMetaData->usMinorVersion = m_LiteWeightStgdb.m_MiniMd.getMinorVersionOfAssembly(pRecord);
        pMetaData->usBuildNumber = m_LiteWeightStgdb.m_MiniMd.getBuildNumberOfAssembly(pRecord);
        pMetaData->usRevisionNumber = m_LiteWeightStgdb.m_MiniMd.getRevisionNumberOfAssembly(pRecord);
        pMetaData->szLocale = m_LiteWeightStgdb.m_MiniMd.getLocaleOfAssembly(pRecord);
        pMetaData->ulProcessor = 0;
        pMetaData->ulOS = 0;
    }
    if (pdwAssemblyFlags)
    {
        *pdwAssemblyFlags = m_LiteWeightStgdb.m_MiniMd.getFlagsOfAssembly(pRecord);

        // Turn on the afPublicKey if PublicKey blob is not empty
        DWORD cbPublicKey;
        m_LiteWeightStgdb.m_MiniMd.getPublicKeyOfAssembly(pRecord, &cbPublicKey);
        if (cbPublicKey)
            *pdwAssemblyFlags |= afPublicKey;
    }
} // void MDInternalRO::GetAssemblyProps()

//*****************************************************************************
// Get the properties for the given AssemblyRef token.
//*****************************************************************************
void MDInternalRO::GetAssemblyRefProps(
    mdAssemblyRef mdar,                 // [IN] The AssemblyRef for which to get the properties.
    const void  **ppbPublicKeyOrToken,  // [OUT] Pointer to the public key or token.
    ULONG       *pcbPublicKeyOrToken,   // [OUT] Count of bytes in the public key or token.
    LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
    AssemblyMetaDataInternal *pMetaData,// [OUT] Assembly MetaData.
    const void  **ppbHashValue,         // [OUT] Hash blob.
    ULONG       *pcbHashValue,          // [OUT] Count of bytes in the hash blob.
    DWORD       *pdwAssemblyRefFlags)   // [OUT] Flags.
{
    AssemblyRefRec  *pRecord;

    _ASSERTE(TypeFromToken(mdar) == mdtAssemblyRef && RidFromToken(mdar));
    pRecord = m_LiteWeightStgdb.m_MiniMd.getAssemblyRef(RidFromToken(mdar));

    if (ppbPublicKeyOrToken)
        *ppbPublicKeyOrToken = m_LiteWeightStgdb.m_MiniMd.getPublicKeyOrTokenOfAssemblyRef(pRecord, pcbPublicKeyOrToken);
    if (pszName)
        *pszName = m_LiteWeightStgdb.m_MiniMd.getNameOfAssemblyRef(pRecord);
    if (pMetaData)
    {
        pMetaData->usMajorVersion = m_LiteWeightStgdb.m_MiniMd.getMajorVersionOfAssemblyRef(pRecord);
        pMetaData->usMinorVersion = m_LiteWeightStgdb.m_MiniMd.getMinorVersionOfAssemblyRef(pRecord);
        pMetaData->usBuildNumber = m_LiteWeightStgdb.m_MiniMd.getBuildNumberOfAssemblyRef(pRecord);
        pMetaData->usRevisionNumber = m_LiteWeightStgdb.m_MiniMd.getRevisionNumberOfAssemblyRef(pRecord);
        pMetaData->szLocale = m_LiteWeightStgdb.m_MiniMd.getLocaleOfAssemblyRef(pRecord);
        pMetaData->ulProcessor = 0;
        pMetaData->ulOS = 0;
    }
    if (ppbHashValue)
        *ppbHashValue = m_LiteWeightStgdb.m_MiniMd.getHashValueOfAssemblyRef(pRecord, pcbHashValue);
    if (pdwAssemblyRefFlags)
        *pdwAssemblyRefFlags = m_LiteWeightStgdb.m_MiniMd.getFlagsOfAssemblyRef(pRecord);
} // void MDInternalRO::GetAssemblyRefProps()

//*****************************************************************************
// Get the properties for the given File token.
//*****************************************************************************
void MDInternalRO::GetFileProps(
    mdFile      mdf,                    // [IN] The File for which to get the properties.
    LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
    const void  **ppbHashValue,         // [OUT] Pointer to the Hash Value Blob.
    ULONG       *pcbHashValue,          // [OUT] Count of bytes in the Hash Value Blob.
    DWORD       *pdwFileFlags)          // [OUT] Flags.
{
    FileRec     *pRecord;

    _ASSERTE(TypeFromToken(mdf) == mdtFile && RidFromToken(mdf));
    pRecord = m_LiteWeightStgdb.m_MiniMd.getFile(RidFromToken(mdf));

    if (pszName)
        *pszName = m_LiteWeightStgdb.m_MiniMd.getNameOfFile(pRecord);
    if (ppbHashValue)
        *ppbHashValue = m_LiteWeightStgdb.m_MiniMd.getHashValueOfFile(pRecord, pcbHashValue);
    if (pdwFileFlags)
        *pdwFileFlags = m_LiteWeightStgdb.m_MiniMd.getFlagsOfFile(pRecord);
} // void MDInternalRO::GetFileProps()

//*****************************************************************************
// Get the properties for the given ExportedType token.
//*****************************************************************************
void MDInternalRO::GetExportedTypeProps(
    mdExportedType   mdct,                   // [IN] The ExportedType for which to get the properties.
    LPCSTR      *pszNamespace,          // [OUT] Buffer to fill with namespace.
    LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
    mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
    mdTypeDef   *ptkTypeDef,            // [OUT] TypeDef token within the file.
    DWORD       *pdwExportedTypeFlags)       // [OUT] Flags.
{
    ExportedTypeRec  *pRecord;

    _ASSERTE(TypeFromToken(mdct) == mdtExportedType && RidFromToken(mdct));
    pRecord = m_LiteWeightStgdb.m_MiniMd.getExportedType(RidFromToken(mdct));

    if (pszNamespace)
        *pszNamespace = m_LiteWeightStgdb.m_MiniMd.getTypeNamespaceOfExportedType(pRecord);
    if (pszName)
        *pszName = m_LiteWeightStgdb.m_MiniMd.getTypeNameOfExportedType(pRecord);
    if (ptkImplementation)
        *ptkImplementation = m_LiteWeightStgdb.m_MiniMd.getImplementationOfExportedType(pRecord);
    if (ptkTypeDef)
        *ptkTypeDef = m_LiteWeightStgdb.m_MiniMd.getTypeDefIdOfExportedType(pRecord);
    if (pdwExportedTypeFlags)
        *pdwExportedTypeFlags = m_LiteWeightStgdb.m_MiniMd.getFlagsOfExportedType(pRecord);
} // void MDInternalRO::GetExportedTypeProps()

//*****************************************************************************
// Get the properties for the given Resource token.
//*****************************************************************************
void MDInternalRO::GetManifestResourceProps(
    mdManifestResource  mdmr,           // [IN] The ManifestResource for which to get the properties.
    LPCSTR      *pszName,               // [OUT] Buffer to fill with name.
    mdToken     *ptkImplementation,     // [OUT] mdFile or mdAssemblyRef that provides the ExportedType.
    DWORD       *pdwOffset,             // [OUT] Offset to the beginning of the resource within the file.
    DWORD       *pdwResourceFlags)      // [OUT] Flags.
{
    ManifestResourceRec *pRecord;

    _ASSERTE(TypeFromToken(mdmr) == mdtManifestResource && RidFromToken(mdmr));
    pRecord = m_LiteWeightStgdb.m_MiniMd.getManifestResource(RidFromToken(mdmr));

    if (pszName)
        *pszName = m_LiteWeightStgdb.m_MiniMd.getNameOfManifestResource(pRecord);
    if (ptkImplementation)
        *ptkImplementation = m_LiteWeightStgdb.m_MiniMd.getImplementationOfManifestResource(pRecord);
    if (pdwOffset)
        *pdwOffset = m_LiteWeightStgdb.m_MiniMd.getOffsetOfManifestResource(pRecord);
    if (pdwResourceFlags)
        *pdwResourceFlags = m_LiteWeightStgdb.m_MiniMd.getFlagsOfManifestResource(pRecord);
} // void MDInternalRO::GetManifestResourceProps()

//*****************************************************************************
// Find the ExportedType given the name.
//*****************************************************************************
STDMETHODIMP MDInternalRO::FindExportedTypeByName( // S_OK or error
    LPCSTR      szNamespace,            // [IN] Namespace of the ExportedType.   
    LPCSTR      szName,                 // [IN] Name of the ExportedType.   
    mdExportedType   tkEnclosingType,        // [IN] Token for the Enclosing Type.
    mdExportedType   *pmct)                  // [OUT] Put ExportedType token here.
{
    IMetaModelCommon *pCommon = static_cast<IMetaModelCommon*>(&m_LiteWeightStgdb.m_MiniMd);
    return pCommon->CommonFindExportedType(szNamespace, szName, tkEnclosingType, pmct);
} // STDMETHODIMP MDInternalRO::FindExportedTypeByName()

//*****************************************************************************
// Find the ManifestResource given the name.
//*****************************************************************************
STDMETHODIMP MDInternalRO::FindManifestResourceByName(  // S_OK or error
    LPCSTR      szName,                 // [IN] Name of the resource.   
    mdManifestResource *pmmr)           // [OUT] Put ManifestResource token here.
{
    _ASSERTE(szName && pmmr);

    ManifestResourceRec *pRecord;
    ULONG       cRecords;               // Count of records.
    LPCUTF8     szNameTmp = 0;          // Name obtained from the database.
    ULONG       i;

    cRecords = m_LiteWeightStgdb.m_MiniMd.getCountManifestResources();

    // Search for the ExportedType.
    for (i = 1; i <= cRecords; i++)
    {
        pRecord = m_LiteWeightStgdb.m_MiniMd.getManifestResource(i);
        szNameTmp = m_LiteWeightStgdb.m_MiniMd.getNameOfManifestResource(pRecord);
        if (! strcmp(szName, szNameTmp))
        {
            *pmmr = TokenFromRid(i, mdtManifestResource);
            return S_OK;
        }
    }
    return CLDB_E_RECORD_NOTFOUND;
} // STDMETHODIMP MDInternalRO::FindManifestResourceByName()
    
//*****************************************************************************
// Get the Assembly token from the given scope.
//*****************************************************************************
HRESULT MDInternalRO::GetAssemblyFromScope( // S_OK or error
    mdAssembly  *ptkAssembly)           // [OUT] Put token here.
{
    _ASSERTE(ptkAssembly);

    if (m_LiteWeightStgdb.m_MiniMd.getCountAssemblys())
    {
        *ptkAssembly = TokenFromRid(1, mdtAssembly);
        return S_OK;
    }
    else
        return CLDB_E_RECORD_NOTFOUND;
} // HRESULT MDInternalRO::GetAssemblyFromScope()

//*******************************************************************************
// return properties regarding a TypeSpec
//*******************************************************************************
void MDInternalRO::GetTypeSpecFromToken(   // S_OK or error.
    mdTypeSpec typespec,                // [IN] Signature token.
    PCCOR_SIGNATURE *ppvSig,            // [OUT] return pointer to token.
    ULONG      *pcbSig)                 // [OUT] return size of signature.
{    
    _ASSERTE(TypeFromToken(typespec) == mdtTypeSpec);
    _ASSERTE(ppvSig && pcbSig);

    TypeSpecRec *pRec = m_LiteWeightStgdb.m_MiniMd.getTypeSpec( RidFromToken(typespec) );
    *ppvSig = m_LiteWeightStgdb.m_MiniMd.getSignatureOfTypeSpec( pRec, pcbSig );
} // void MDInternalRO::GetTypeSpecFromToken()

// forward declaration.
    
HRESULT _ConvertTextSigToComSig(        // Return hresult.
    IMDInternalImport *pImport,
    BOOL        fCreateTrIfNotFound,    // create typeref if not found or not
    LPCSTR      pSignature,             // class file format signature
    CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
    ULONG       *pcbCount);              // [OUT] the result size of signature

//*****************************************************************************
// convert a text signature to com format
//*****************************************************************************
HRESULT MDInternalRO::ConvertTextSigToComSig(// Return hresult.
    BOOL        fCreateTrIfNotFound,    // create typeref if not found or not
    LPCSTR      pSignature,             // class file format signature
    CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
    ULONG       *pcbCount)              // [OUT] the result size of signature
{
    return _ConvertTextSigToComSig( this, fCreateTrIfNotFound, pSignature, pqbNewSig, pcbCount);
} // HRESULT _ConvertTextSigToComSig()


//*****************************************************************************
// determine if a token is valid or not
//*****************************************************************************
BOOL MDInternalRO::IsValidToken(        // True or False.
    mdToken     tk)                     // [IN] Given token.
{
    bool        bRet = false;           // default to invalid token
    RID         rid = RidFromToken(tk);
    
    if(rid)
    {
        switch (TypeFromToken(tk))
        {
        case mdtModule:
            // can have only one module record
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountModules());
            break;
        case mdtTypeRef:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountTypeRefs());
            break;
        case mdtTypeDef:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountTypeDefs());
            break;
        case mdtFieldDef:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountFields());
            break;
        case mdtMethodDef:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountMethods());
            break;
        case mdtParamDef:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountParams());
            break;
        case mdtInterfaceImpl:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountInterfaceImpls());
            break;
        case mdtMemberRef:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountMemberRefs());
            break;
        case mdtCustomAttribute:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountCustomAttributes());
            break;
        case mdtPermission:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountDeclSecuritys());
            break;
        case mdtSignature:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountStandAloneSigs());
            break;
        case mdtEvent:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountEvents());
            break;
        case mdtProperty:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountPropertys());
            break;
        case mdtModuleRef:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountModuleRefs());
            break;
        case mdtTypeSpec:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountTypeSpecs());
            break;
        case mdtAssembly:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountAssemblys());
            break;
        case mdtAssemblyRef:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountAssemblyRefs());
            break;
        case mdtFile:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountFiles());
            break;
        case mdtExportedType:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountExportedTypes());
            break;
        case mdtManifestResource:
            bRet = (rid <= m_LiteWeightStgdb.m_MiniMd.getCountManifestResources());
            break;
        case mdtString:
            // need to check the user string heap
            if (m_LiteWeightStgdb.m_MiniMd.m_USBlobs.IsValidCookie(rid))
                bRet = true;
            break;
        default:
/* Don't  Assert here, this will break verifier tests.
            _ASSERTE(!"Unknown token kind!");
*/
            break;
        }
    }
    return bRet;
} // BOOL MDInternalRO::IsValidToken()

mdModule MDInternalRO::GetModuleFromScope(void)
{
    return TokenFromRid(1, mdtModule);
} // mdModule MDInternalRO::GetModuleFromScope()

//*****************************************************************************
// Helper : convert a text field signature to a com format
//*****************************************************************************
HRESULT _ConvertTextElementTypeToComSigHelper(// Return hresult.
    IMDInternalImport *pImport,         
    BOOL        fCreateTrIfNotFound,    // [IN] create typeref if not found or fail out?
    LPCSTR      *ppOneArgSig,           // [IN|OUT] class file format signature. On exit, it will be next arg starting point
    CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
    ULONG       cbStart,                // [IN] bytes that are already in pqbNewSig
    ULONG       *pcbCount)              // [OUT] count of bytes put into the QuickBytes buffer
{   
    _ASSERTE(ppOneArgSig && pqbNewSig && pcbCount);


    HRESULT     hr = NOERROR;
    BYTE        *prgData = (BYTE *)pqbNewSig->Ptr();
    ULONG       cDim, cDimTmp;          // number of '[' in signature
    CorSimpleETypeStruct eType; 
    LPCUTF8     pOneArgSig = *ppOneArgSig;
    ULONG       cb, cbTotal = 0, cbBaseElement;
    
    _ASSERTE(fCreateTrIfNotFound == false);

    // given "[[LSystem.Object;I)V"
    if (ResolveTextSigToSimpleEType(&pOneArgSig, &eType, &cDim, true) == false)
    {
        _ASSERTE(!"not a valid signature!");
        return META_E_BAD_SIGNATURE;
    }

    // If we have a reference to an array (e.g. "&[B"), we need to process
    // the reference now, otherwise the code below will generate the array
    // sig bytes before dealing with the underlying element type and will
    // end up generating a signature equivalent to "[&B" (which is not
    // legal).
    if (cDim && (eType.dwFlags & CorSigElementTypeByRef))
    {
        cb = CorSigCompressElementType(ELEMENT_TYPE_BYREF, &prgData[cbStart + cbTotal]);
        cbTotal += cb;
        eType.dwFlags &= ~CorSigElementTypeByRef;
    }

    // pOneArgSig now points to "System.Object;I)V"
    // resolve the rid if exists
    if (eType.corEType == ELEMENT_TYPE_VALUETYPE || eType.corEType == ELEMENT_TYPE_CLASS)
    {
        CQuickBytes     qbClassName;
        LPCSTR          szNameSpace;
        LPCSTR          szTypeName;

        if (ExtractClassNameFromTextSig(&pOneArgSig, &qbClassName, &cb) == FALSE)
        {   
            _ASSERTE(!"corrupted text signature!");
            return E_FAIL;
        }

        // now pOneArgSig will pointing to the starting of next parameter "I)V"
        // cb is the number of bytes for the class name excluding ";" but including NULL terminating char

        // parse the full qual name to get namespace and type name separately
        ns::SplitInline((LPUTF8) qbClassName.Ptr(), szNameSpace, szTypeName);

        if (strcmp(szTypeName, "Object") == 0 && strcmp(szNameSpace, "System") == 0)
        {
            eType.corEType = ELEMENT_TYPE_OBJECT;
        }
        else if (strcmp(szTypeName, "String") == 0 && strcmp(szNameSpace, "System") == 0)
        {
            eType.corEType = ELEMENT_TYPE_STRING;
        }
        else
        {
            hr = pImport->FindTypeRefByName(
                szNameSpace,
                szTypeName,
                mdTokenNil,
                &eType.typeref);
            if (FAILED(hr))
            {
                LPCSTR          szNameSpaceTemp;
                LPCSTR          szTypeNameTemp;
                HENUMInternal   hEnum;
                mdTypeDef       td;
                bool            fFoundMatch = false;
    
                // @consider: I don't really want to introduce FindTypeDefByName to the internal interface
                // because it is not needed. So I will just use the Enum to get all of the TypeDefs to resolve
                // the name
                IfFailGo( pImport->EnumTypeDefInit(&hEnum) );
                while (pImport->EnumTypeDefNext(&hEnum, &td))
                {
                    pImport->GetNameOfTypeDef(td, &szTypeNameTemp, &szNameSpaceTemp);
                    if (strcmp(szTypeNameTemp, szTypeName) == 0 && strcmp(szNameSpaceTemp, szNameSpace) == 0)
                    {
                        // found the match
                        eType.typeref = td;
                        fFoundMatch = true;
                        break;
                    }
                }
                pImport->EnumTypeDefClose(&hEnum);
                if (!fFoundMatch)
                {
                    IfFailGo(CLDB_E_RECORD_NOTFOUND);
                }
            }
        }
    }

    // how many bytes the base type needs
    IfFailGo( CorSigGetSimpleETypeCbSize(&eType, &cbBaseElement) );

    // jagged array "[[I" will be represented as SZARRAY SZARRAY I 
    cb = (2 * CB_ELEMENT_TYPE_MAX) * cDim + cbBaseElement;

    // ensure buffer is big enough
    IfFailGo(pqbNewSig->ReSize(cbStart + cbTotal + cb));
    prgData = (BYTE *)pqbNewSig->Ptr();

    for (cDimTmp = 0; cDimTmp < cDim; cDimTmp++)
    {

        // jagged array, put cDim numbers of ELEMENT_TYPE_SZARRAY first 
        cb = CorSigCompressElementType(ELEMENT_TYPE_SZARRAY, &prgData[cbStart + cbTotal]);
        cbTotal += cb;
    }

    // now put the element type of jagged array or just put the type
    IfFailGo(CorSigPutSimpleEType(&eType, &prgData[cbStart + cbTotal], &cb));
    cbTotal += cb;

    *pcbCount = cbTotal;
    *ppOneArgSig = pOneArgSig;
    _ASSERTE(*pcbCount);
ErrExit:
    IfFailRet(hr);
    return hr;
} // HRESULT _ConvertTextElementTypeToComSigHelper()

HRESULT _ConvertTextSigToComSig(        // Return hresult.
    IMDInternalImport *pImport,
    BOOL        fCreateTrIfNotFound,    // create typeref if not found or not
    LPCSTR      pSignature,             // class file format signature
    CQuickBytes *pqbNewSig,             // [OUT] place holder for COM+ signature
    ULONG       *pcbCount)              // [OUT] the result size of signature
{
    BYTE        *prgData = (BYTE *)pqbNewSig->Ptr();
    CQuickBytes qbNewSigForOneArg;      // temporary buffer to hold one arg or ret type in new signature format
    ULONG       cbTotal = 0;            // total number of bytes for the whole signature
    ULONG       cbOneArg;               // count of bytes for one arg/ret type
    ULONG       cb;                     // count of bytes
    DWORD       cArgs;
    LPCUTF8     szRet;
    HRESULT     hr = NOERROR;

    _ASSERTE(pSignature && pqbNewSig && pcbCount);

    if (*pSignature == '(')
    {
        // get the argument count from the signature
        cArgs = CountArgsInTextSignature(pSignature);

        // put calling convention
        // @FUTURE: We only support the default calling convention for text sig at this moment.
        // We need to add a parameter for this function if we decide to support other calling
        // convention for the text sig.
        //
        cbTotal = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_DEFAULT, &prgData[cbTotal]);

        // put the count of arguments
        cb = CorSigCompressData((ULONG)cArgs, &prgData[cbTotal]);
        cbTotal += cb;

        // get the return type
        szRet = strrchr(pSignature, ')');
        if (szRet == NULL)
        {
            _ASSERTE(!"Not a valid TEXT member signature!");
            return E_FAIL;
        }

        // skip over ')'
        szRet++;

        IfFailGo(_ConvertTextElementTypeToComSigHelper(
            pImport,
            fCreateTrIfNotFound,
            &szRet,                         // point to where return type starts    
            pqbNewSig,                      // quick byte buffer for the return type
            cbTotal,
            &cbOneArg));                    // count of bytes that write to quick bytes buffer

        cbTotal += cbOneArg;

        // skip over "("
        pSignature++;
        while (cArgs)
        {
            IfFailGo(_ConvertTextElementTypeToComSigHelper(
                pImport,
                fCreateTrIfNotFound,
                &pSignature,                // point to where an parameter starts   
                pqbNewSig,                  // quick byte buffer for the return type
                cbTotal,
                &cbOneArg));                // count of bytes that write to quick bytes buffer

            cbTotal += cbOneArg;
            cArgs--;
        }
        *pcbCount = cbTotal;
    }
    else
    {
        // field
        IfFailGo(pqbNewSig->ReSize(CB_ELEMENT_TYPE_MAX));

        // put the calling convention first of all 
        cb = CorSigCompressData((ULONG)IMAGE_CEE_CS_CALLCONV_FIELD, pqbNewSig->Ptr());

        // now convert the Text signature
        IfFailGo(_ConvertTextElementTypeToComSigHelper(
            pImport,
            fCreateTrIfNotFound,
            &pSignature,
            pqbNewSig,
            cb,
            &cbOneArg));
        *pcbCount = cb + cbOneArg;
    }
    
ErrExit:    
    IfFailRet(hr);
    return hr;
} // HRESULT _ConvertTextSigToComSig()




//*****************************************************************************
// Fill a variant given a MDDefaultValue
// This routine will create a bstr if the ELEMENT_TYPE of default value is STRING
//*****************************************************************************
HRESULT _FillVariant(
    MDDefaultValue  *pMDDefaultValue,
    VARIANT     *pvar) 
{
    HRESULT     hr = NOERROR;

    _ASSERTE(pMDDefaultValue);

    switch (pMDDefaultValue->m_bType)
    {
    case ELEMENT_TYPE_BOOLEAN:
        pvar->vt = VT_BOOL;
        pvar->boolVal = pMDDefaultValue->m_bValue;
        break;
    case ELEMENT_TYPE_I1:
        pvar->vt = VT_I1;
        pvar->cVal = pMDDefaultValue->m_cValue;
        break;  
    case ELEMENT_TYPE_U1:
        pvar->vt = VT_UI1;
        pvar->bVal = pMDDefaultValue->m_byteValue;
        break;  
    case ELEMENT_TYPE_I2:
        pvar->vt = VT_I2;
        pvar->iVal = pMDDefaultValue->m_sValue;
        break;  
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:             // char is stored as UI2 internally
        pvar->vt = VT_UI2;
        pvar->uiVal = pMDDefaultValue->m_usValue;
        break;  
    case ELEMENT_TYPE_I4:
        pvar->vt = VT_I4;
        pvar->lVal = pMDDefaultValue->m_lValue;
        break;  
    case ELEMENT_TYPE_U4:
        pvar->vt = VT_UI4;
        pvar->ulVal = pMDDefaultValue->m_ulValue;
        break;  
    case ELEMENT_TYPE_R4:
        pvar->vt = VT_R4;
        pvar->fltVal = pMDDefaultValue->m_fltValue;
        break;  
    case ELEMENT_TYPE_R8:
        pvar->vt = VT_R8;
        pvar->dblVal = pMDDefaultValue->m_dblValue;
        break;  
    case ELEMENT_TYPE_STRING:
        pvar->vt = VT_BSTR;

        // allocated bstr here
        pvar->bstrVal = ::SysAllocStringLen(pMDDefaultValue->m_wzValue, pMDDefaultValue->m_cbSize / sizeof(WCHAR));
        if (pvar->bstrVal == NULL)
            hr = E_OUTOFMEMORY;
        break;  
    case ELEMENT_TYPE_CLASS:
        pvar->punkVal = pMDDefaultValue->m_unkValue;
        pvar->vt = VT_UNKNOWN;
        break;  
    case ELEMENT_TYPE_I8:
        pvar->vt = VT_I8;
        pvar->cyVal.int64 = pMDDefaultValue->m_llValue;
        break;
    case ELEMENT_TYPE_U8:
        pvar->vt = VT_UI8;
        pvar->cyVal.int64 = pMDDefaultValue->m_ullValue;
        break;
    case ELEMENT_TYPE_VOID:
        pvar->vt = VT_EMPTY;
        break;
    default:
        _ASSERTE(!"bad constant value type!");
    }

    return hr;
} // HRESULT _FillVariant()


//*****************************************************************************
// Fill a variant given a MDDefaultValue
// This routine will create a bstr if the ELEMENT_TYPE of default value is STRING
//*****************************************************************************
HRESULT _FillMDDefaultValue(
    BYTE        bType,
    void const *pValue,
    MDDefaultValue  *pMDDefaultValue)
{
    HRESULT     hr = NOERROR;

    if (bType != ELEMENT_TYPE_VOID && pValue == 0)
    {
        pMDDefaultValue->m_bType = ELEMENT_TYPE_VOID;
        return CLDB_E_FILE_CORRUPT;
    }

    pMDDefaultValue->m_bType = bType;
    switch (bType)
    {
    case ELEMENT_TYPE_BOOLEAN:
        pMDDefaultValue->m_bValue = *((BYTE *) pValue);
        break;
    case ELEMENT_TYPE_I1:
        pMDDefaultValue->m_cValue = *((CHAR *) pValue);
        break;  
    case ELEMENT_TYPE_U1:
        pMDDefaultValue->m_byteValue = *((BYTE *) pValue);
        break;  
    case ELEMENT_TYPE_I2:
        pMDDefaultValue->m_sValue = *((SHORT *) pValue);
        break;  
    case ELEMENT_TYPE_U2:
    case ELEMENT_TYPE_CHAR:
        pMDDefaultValue->m_usValue = *((USHORT *) pValue);
        break;  
    case ELEMENT_TYPE_I4:
        pMDDefaultValue->m_lValue =*((LONG *) pValue);
        break;  
    case ELEMENT_TYPE_U4:
        pMDDefaultValue->m_ulValue = *((ULONG *) pValue);
        break;  
    case ELEMENT_TYPE_R4:
        pMDDefaultValue->m_fltValue = *((FLOAT *) pValue);
        break;  
    case ELEMENT_TYPE_R8:
        pMDDefaultValue->m_dblValue = *((DOUBLE *) pValue);
        break;  
    case ELEMENT_TYPE_STRING:
        pMDDefaultValue->m_wzValue = (LPCWSTR) pValue;
        break;  
    case ELEMENT_TYPE_CLASS:
        pMDDefaultValue->m_unkValue = *((IUnknown **) pValue);
        break;  
    case ELEMENT_TYPE_I8:
        pMDDefaultValue->m_llValue = *((LONGLONG *) pValue);
        break;
    case ELEMENT_TYPE_U8:
        pMDDefaultValue->m_ullValue = *((ULONGLONG *) pValue);
        break;
    case ELEMENT_TYPE_VOID:
        break;
    default:
        _ASSERTE(!"BAD TYPE!");
        break;
    }

    return hr;
} // void _FillMDDefaultValue()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\stdafx.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// stdafx.cpp
//
// Precompiled headers.
//
//*****************************************************************************
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\mdinternaldisp.h ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MDInternalDispenser.h
//
// Contains utility code for MD directory
//
//*****************************************************************************
#ifndef __MDInternalDispenser__h__
#define __MDInternalDispenser__h__



#include "MDInternalRO.h"


enum MDFileFormat
{
	MDFormat_ReadOnly = 0,
	MDFormat_ReadWrite = 1,
	MDFormat_ICR = 2,
	MDFormat_Invalid = 3
};


HRESULT	CheckFileFormat(LPVOID pData, ULONG cbData, MDFileFormat *pFormat);
STDAPI GetMDInternalInterface(
    LPVOID      pData,					// [IN] Buffer with the metadata.
    ULONG       cbData, 				// [IN] Size of the data in the buffer.
	DWORD		flags,					// [IN] MDInternal_OpenForRead or MDInternal_OpenForENC
	REFIID		riid,					// [in] The interface desired.
	void		**ppIUnk);				// [out] Return interface on success.


#endif // __MDInternalDispenser__h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\clr\md\runtime\metamodelro.cpp ===
// ==++==
// 
//   Copyright (c) Microsoft Corporation.  All rights reserved.
// 
// ==--==
//*****************************************************************************
// MetaModelRO.cpp -- Read-only implementation of compressed COM+ metadata.
//
//*****************************************************************************
#include "stdafx.h"

#include "MetaModelRO.h"
#include <PostError.h>
#include <CorError.h>
#include "MetadataTracker.h"

//*****************************************************************************
// Set the pointers to consecutive areas of a large buffer.
//*****************************************************************************
void CMiniMd::SetTablePointers(
	BYTE		*pBase)
{
	ULONG		ulOffset = 0;			// Offset so far in the table.
	int			i;						// Loop control.

	for (i=0; i<TBL_COUNT; ++i)
	{
        METADATATRACKER_ONLY(MetaDataTracker::NoteSection(i, pBase + ulOffset, m_TableDefs[i].m_cbRec * m_Schema.m_cRecs[i]));
        // Table pointer points before start of data.  Allows using RID as
        //  an index, without adjustment.
        m_pTable[i] = pBase + ulOffset - m_TableDefs[i].m_cbRec;
        ulOffset += m_TableDefs[i].m_cbRec * m_Schema.m_cRecs[i];
    }
} // void CMiniMd::SetTablePointers()

//*****************************************************************************
// Given a buffer that contains a MiniMd, init to read it.
//*****************************************************************************
HRESULT CMiniMd::InitOnMem(
	void		*pvBuf,
	ULONG		ulBufLen)					// The memory.
{
	ULONG cbData, ulTotalSize;
	BYTE *pBuf = reinterpret_cast<BYTE*>(pvBuf);
	// Uncompress the schema from the buffer into our structures.
	cbData = m_Schema.LoadFrom(pvBuf);

	// Do we know how to read this?
	if (m_Schema.m_major != METAMODEL_MAJOR_VER || m_Schema.m_minor != METAMODEL_MINOR_VER)
		return PostError(CLDB_E_FILE_OLDVER, m_Schema.m_major,m_Schema.m_minor);

	// There shouldn't be any pointer tables.
	if (m_Schema.m_cRecs[TBL_MethodPtr] || m_Schema.m_cRecs[TBL_FieldPtr])
	{
		_ASSERTE( !"Trying to open Read/Write format as ReadOnly!");
		return PostError(CLDB_E_FILE_CORRUPT);
	}

	// Populate the schema and initialize the pointers to the rest of the data.
	ulTotalSize = SchemaPopulate2();
	if(ulTotalSize > ulBufLen) return PostError(CLDB_E_FILE_CORRUPT);
	SetTablePointers(pBuf + Align4(cbData));
	return S_OK;
} // HRESULT CMiniMd::InitOnMem()

//*****************************************************************************
// Validate cross-stream consistency.
//*****************************************************************************
HRESULT CMiniMd::PostInit(
    int         iLevel)
{
    HRESULT     hr = S_OK;
    ULONG       cbStrings;              // Size of strings.
    ULONG       cbBlobs;                // Size of blobs.

    cbStrings =  m_Strings.GetPoolSize();
    cbBlobs = m_Blobs.GetPoolSize();

    // Last valid byte of string pool better be nul.
    if (cbStrings > 0 && *m_Strings.GetString(cbStrings-1) != '\0')
        IfFailGo(CLDB_E_FILE_CORRUPT);

    // if iLevel > 0, consider chaining through the blob heap.

#if 0 // this catches **some** corruptions.  Don't catch just some.
    // If no blobs or no strings:  that's very rare, so verify that
    //  there really shouldn't be.  Any valid db with no strings and
    //  no blobs must be pretty small.
    if (cbStrings == 0 || cbBlobs == 0)
    {
        // Look at every table...
        for (ULONG ixTbl=0; ixTbl<TBL_COUNT; ++ixTbl)
        {
            // Look at every row...
            for (RID rid=1; rid<=m_Schema.m_cRecs[ixTbl]; ++rid)
            {
                void *pRow = getRow(ixTbl, rid);
                ULONG iVal;
                // Look at every column...
                for (ULONG ixCol=0; ixCol<m_TableDefs[ixTbl].m_cCols; ++ixCol)
                {   // Validate strings and blobs.
                    switch (m_TableDefs[ixTbl].m_pColDefs[ixCol].m_Type)
                    {
                    case iSTRING:
                        iVal = getIX(pRow, m_TableDefs[ixTbl].m_pColDefs[ixCol]);
                        if (iVal && iVal >= cbStrings)
                            IfFailGo(CLDB_E_FILE_CORRUPT);
                        break;
                    case iBLOB:
						iVal = getIX(pRow, m_TableDefs[ixTbl].m_pColDefs[ixCol]);
                        if (iVal && iVal >= cbBlobs)
                            IfFailGo(CLDB_E_FILE_CORRUPT);
                        break;
                    default:
                         break;
                    }
                } // for (ixCol...
            } // for (rid...
        } // for (ixTbl...
    }
#endif // this catches **some** corruptions.  Don't catch just some.

ErrExit:
    return hr;
} // HRESULT CMiniMd::PostInit()

//*****************************************************************************
// Given a pointer to a row, what is the RID of the row?
//*****************************************************************************
RID CMiniMd::Impl_GetRidForRow(			// RID corresponding to the row pointer.
	const void	*pvRow,					// Pointer to the row.
	ULONG		ixTbl)					// Which table.
{
	_ASSERTE(isValidPtr(pvRow, ixTbl));

	const BYTE *pRow = reinterpret_cast<const BYTE*>(pvRow);

	// Offset in the table.
	size_t cbDiff = pRow - m_pTable[ixTbl];

	// Index of row.  Table pointer points before start of data, so RID can
	//  be used/generated directly as an index.
	return (RID)(cbDiff / m_TableDefs[ixTbl].m_cbRec);
} // RID CMiniMd::Impl_GetRidForRow()


//*****************************************************************************
// Test that a pointer points to the start of a record in a given table.
//*****************************************************************************
int CMiniMd::Impl_IsValidPtr(				// True if pointer is valid for table.
	const void	*pvRow,					// Pointer to test.
	int			ixTbl)					// Table pointer should be in.
{
	const BYTE *pRow = reinterpret_cast<const BYTE*>(pvRow);
	// Should point within the table.
	if (pRow <= m_pTable[ixTbl])
		return false;
	if (pRow > (m_pTable[ixTbl] + (m_TableDefs[ixTbl].m_cbRec * m_Schema.m_cRecs[ixTbl])) )
		return false;

	size_t cbDiff = pRow - m_pTable[ixTbl];
	// Should point directly at a row.
	if ((cbDiff % m_TableDefs[ixTbl].m_cbRec) != 0)
		return false;

	return true;
} // int CMiniMd::Impl_IsValidPtr()


//*****************************************************************************
// converting a ANSI heap string to unicode