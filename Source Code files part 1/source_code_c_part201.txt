wFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.pszHeaderTitle = NULL;
    psp.pszHeaderSubTitle = NULL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_SELECTDEVICE);
    psp.pfnDlgProc = HdwSelectDeviceDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_ANALYZEDEV);
    psp.pszHeaderSubTitle = NULL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_ANALYZEDEV);
    psp.pfnDlgProc = HdwAnalyzeDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_ADDDEVICE_INSTALLDEV);
    psp.pszHeaderSubTitle = NULL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_INSTALLDEV);
    psp.pfnDlgProc = HdwInstallDevDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    //
    // Finish page
    //
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_ADDDEVICE_FINISH);
    psp.pfnDlgProc = HdwAddDeviceFinishDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    //
    // check for failure on CreatePropertySheetPage.
    //
    Index = PropSheetHeader->nPages;
    while (Index--) {
    
       if (!PropSheetHeader->phpage[Index]) {
       
           break;
       }
    }

    if (Index >= 0) {
    
        Index = PropSheetHeader->nPages;
        while (Index--) {
        
            if (PropSheetHeader->phpage[Index]) {
           
                DestroyPropertySheetPage(PropSheetHeader->phpage[Index]);
            }
        }

        LocalFree(HdwPropertySheet);
        return NULL;
    }

    HardwareWiz->PrevPage = 0;

    LoadString(hHdwWiz,
               IDS_UNKNOWN,
               (PTCHAR)szUnknown,
               SIZECHARS(szUnknown)
               );

    LoadString(hHdwWiz,
               IDS_UNKNOWNDEVICE,
               (PTCHAR)szUnknownDevice,
               SIZECHARS(szUnknownDevice)
               );

    //
    // Get the Class Icon Image Lists.
    //
    HardwareWiz->ClassImageList.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);
    if (SetupDiGetClassImageList(&HardwareWiz->ClassImageList)) {

        HICON hIcon;

        //
        // Add the blank icon for "None of the following devices"
        //
        if ((hIcon = LoadIcon(hHdwWiz, MAKEINTRESOURCE(IDI_BLANK))) != NULL) {

            g_BlankIconIndex = ImageList_AddIcon(HardwareWiz->ClassImageList.ImageList, hIcon);
        }
    
    } else {
    
        HardwareWiz->ClassImageList.cbSize = 0;
    }

    //
    // Load the cursors that the wizard will need
    //
    HardwareWiz->CurrCursor     = NULL;
    HardwareWiz->IdcWait        = LoadCursor(NULL, IDC_WAIT);
    HardwareWiz->IdcAppStarting = LoadCursor(NULL, IDC_APPSTARTING);
    HardwareWiz->IdcArrow       = LoadCursor(NULL, IDC_ARROW);

    return HdwPropertySheet;
}

BOOL
WINAPI
InstallNewDevice(
   IN     HWND   hwndParent,
   IN     LPGUID ClassGuid,
   IN OUT PDWORD pReboot    OPTIONAL
   )
/*++

Routine Description:

   Exported Entry point from hdwwiz.cpl. Installs a new device. A new Devnode is
   created and the user is prompted to select the device. If the class guid
   is not specified then then the user begins at class selection.

Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   LPGUID ClassGuid - Optional class of the new device to install.
                      If ClassGuid is NULL we start at detection choice page.
                      If ClassGuid == GUID_NULL or GUID_DEVCLASS_UNKNOWN
                         we start at class selection page.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/
{
    HARDWAREWIZ HardwareWiz;
    PHDWPROPERTYSHEET HdwPropertySheet;
    int PropSheetResult;
    SEARCHTHREAD SearchThread;
    BOOL StartDetect;

    //
    // Check to see if this process has administrator credentials, if not then
    // display a warning to the user and fail.
    //
    if (NoPrivilegeWarning(hwndParent)) {

        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    //
    // Check to make sure another Device install is underway.
    // This entry point is primarily for manual legacy installs.
    // While Base PNP has queued found new hdw installs, we don't
    // allow the user to install anything manually, since we may get
    // duplicate entries.
    //
    if (CMP_WaitNoPendingInstallEvents(5000) == WAIT_TIMEOUT) {

        HdwMessageBox(hwndParent, 
                      MAKEINTRESOURCE(IDS_HDW_RUNNING_MSG), 
                      MAKEINTRESOURCE(IDS_HDW_RUNNING_TITLE), 
                      MB_OK | MB_ICONINFORMATION
                      );
        return FALSE;
    }

    memset(&HardwareWiz, 0, sizeof(HardwareWiz));

    HardwareWiz.PromptForReboot = pReboot == NULL;

    StartDetect = (ClassGuid == NULL);

    //
    // Create a DeviceInfoList, using the classers Class guid if any.
    //
    if (ClassGuid &&
        (IsEqualGUID(ClassGuid, &GUID_NULL) ||
        IsEqualGUID(ClassGuid, &GUID_DEVCLASS_UNKNOWN))) {

        ClassGuid = NULL;
    }

    HardwareWiz.hDeviceInfo = SetupDiCreateDeviceInfoList(ClassGuid, hwndParent);
    if (HardwareWiz.hDeviceInfo == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    try {
        //
        // If the caller specified a ClassGuid, retrieve the class information
        // and create a DeviceInfo for it.
        //
        if (ClassGuid) {

            HardwareWiz.ClassGuidSelected = ClassGuid;

            //
            // Add a new element to the DeviceInfo from the GUID and class name
            //
            HardwareWiz.DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

            if (!SetupDiGetClassDescription(HardwareWiz.ClassGuidSelected,
                                            HardwareWiz.ClassDescription,
                                            SIZECHARS(HardwareWiz.ClassDescription),
                                            NULL
                                            ) 
                ||
                !SetupDiClassNameFromGuid(HardwareWiz.ClassGuidSelected,
                                          HardwareWiz.ClassName,
                                          SIZECHARS(HardwareWiz.ClassName),
                                          NULL
                                          ))
            {
                HardwareWiz.LastError = GetLastError();
                goto INDLeaveExcept;
            }
        
            if (!SetupDiCreateDeviceInfo(HardwareWiz.hDeviceInfo,
                                         HardwareWiz.ClassName,
                                         ClassGuid,
                                         NULL,
                                         hwndParent,
                                         DICD_GENERATE_ID,
                                         &HardwareWiz.DeviceInfoData
                                         )
                ||
                !SetupDiSetSelectedDevice(HardwareWiz.hDeviceInfo,
                                          &HardwareWiz.DeviceInfoData
                                          ))
            {
                HardwareWiz.LastError = GetLastError();
                goto INDLeaveExcept;
            }
        }

        memset(&SearchThread, 0, sizeof(SearchThread));
        HardwareWiz.SearchThread = &SearchThread;
        
        HardwareWiz.LastError = CreateSearchThread(&HardwareWiz);

        if (HardwareWiz.LastError != ERROR_SUCCESS) {

            goto INDLeaveExcept;
        }

        //
        // Load the libraries that we will need.
        //
        hDevMgr = LoadLibrary(TEXT("devmgr.dll"));
        hNewDev = LoadLibrary(TEXT("newdev.dll"));

        //
        // Create the property sheet
        //
        HdwPropertySheet = HdwWizard(hwndParent,
                                    &HardwareWiz,
                                    StartDetect ? IDD_ADDDEVICE_PNPENUM : IDD_INSTALLNEWDEVICE
                                    );

        if (HdwPropertySheet) {

            PropSheetResult = (int)PropertySheet(&HdwPropertySheet->PropSheetHeader);
            LocalFree(HdwPropertySheet);
        }
        
        //
        // See if we need to run a troubleshooter
        //
        if (HardwareWiz.RunTroubleShooter) {

           TCHAR DeviceID[MAX_DEVICE_ID_LEN];

           if (CM_Get_Device_ID(HardwareWiz.ProblemDevInst,
                                DeviceID,
                                SIZECHARS(DeviceID),
                                0
                                ) == CR_SUCCESS)
           {
                PDEVICEPROBLEMWIZARD pDeviceProblemWizard = NULL;

                pDeviceProblemWizard = (PDEVICEPROBLEMWIZARD)GetProcAddress(hDevMgr, "DeviceProblemWizardW");

                if (pDeviceProblemWizard) {
                    (pDeviceProblemWizard)(hwndParent,
                                           NULL,
                                           DeviceID
                                           );
                }
            }
        }

        //
        // Final cleanup of DeviceInfoData and DeviceInfoList.
        //
        if (HardwareWiz.ClassGuidList) {

            LocalFree(HardwareWiz.ClassGuidList);
            HardwareWiz.ClassGuidList = NULL;
            HardwareWiz.ClassGuidSize = HardwareWiz.ClassGuidNum = 0;
        }

        if (HardwareWiz.ClassImageList.cbSize) {

            SetupDiDestroyClassImageList(&HardwareWiz.ClassImageList);
            HardwareWiz.ClassImageList.cbSize = 0;
        }

        if (HardwareWiz.Cancelled ||
            (HardwareWiz.Registered && !HardwareWiz.Installed)) {

            HdwRemoveDevice(&HardwareWiz);
            HardwareWiz.Reboot = 0;
        }

        SetupDiDestroyDeviceInfoList(HardwareWiz.hDeviceInfo);
        HardwareWiz.hDeviceInfo = NULL;

INDLeaveExcept:;

    } except(HdwUnhandledExceptionFilter(GetExceptionInformation())) {

        HardwareWiz.LastError = RtlNtStatusToDosError(GetExceptionCode());
    }

    
    if (HardwareWiz.hDeviceInfo && HardwareWiz.hDeviceInfo != INVALID_HANDLE_VALUE) {

        SetupDiDestroyDeviceInfoList(HardwareWiz.hDeviceInfo);
        HardwareWiz.hDeviceInfo = NULL;
    }

    if (HardwareWiz.SearchThread) {

        DestroySearchThread(&SearchThread);
    }

    if (hDevMgr) {

        FreeLibrary(hDevMgr);
    }

    if (hNewDev) {

        FreeLibrary(hNewDev);
    }

    //
    // Copy out the reboot flags for the caller
    // or put up the restart dialog if caller didn't ask for the reboot flag
    //
    if (pReboot) {

        *pReboot = HardwareWiz.Reboot;

    } else if (HardwareWiz.Reboot) {

         RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
    }

    //
    // See if we need to shutdown the machine.
    //
    if (HardwareWiz.Shutdown) {
        ShutdownMachine(hwndParent);
    }

    SetLastError(HardwareWiz.LastError);
    return HardwareWiz.LastError == ERROR_SUCCESS;
}

void
AddHardwareWizard(
   HWND hwnd,
   PTCHAR Reserved
   )
/*++

Routine Description:


Arguments:

    hwnd - Window handle of the top-level window to use for any UI related
           to installing the device.

    Reserved - must be NULL                   

Return Value:

--*/
{

    HARDWAREWIZ HardwareWiz;
    PHDWPROPERTYSHEET HdwPropertySheet;
    int PropSheetResult;
    SEARCHTHREAD SearchThread;

    if (Reserved != NULL) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return;
    }

    //
    // Check to see if this process has administrator credentials, if not then
    // display a warning to the user and fail.
    //
    if (NoPrivilegeWarning(hwnd)) {

        SetLastError(ERROR_ACCESS_DENIED);
        return;
    }

    //
    // Check to make sure another Device install is underway.
    // This entry point is primarily for manual legacy installs.
    // While Base PNP has queued found new hdw installs, we don't
    // allow the user to install anything manually, since we may get
    // duplicate entries.
    //
    if (CMP_WaitNoPendingInstallEvents(5000) == WAIT_TIMEOUT) {

        HdwMessageBox(hwnd, 
                      MAKEINTRESOURCE(IDS_HDW_RUNNING_MSG), 
                      MAKEINTRESOURCE(IDS_HDW_RUNNING_TITLE), 
                      MB_OK | MB_ICONINFORMATION
                      );
        return;
    }

    memset(&HardwareWiz, 0, sizeof(HardwareWiz));

    //
    // Create a DeviceInfoList
    //
    HardwareWiz.hDeviceInfo = SetupDiCreateDeviceInfoList(NULL, hwnd);
    if (HardwareWiz.hDeviceInfo == INVALID_HANDLE_VALUE) {

        return;
    }

    //
    // Create the Search thread to look for compatible drivers.
    // This thread will sit around waiting for requests until
    // told to go away.
    //
    memset(&SearchThread, 0, sizeof(SearchThread));
    HardwareWiz.SearchThread = &SearchThread;

    if (CreateSearchThread(&HardwareWiz) != ERROR_SUCCESS) {

        SetupDiDestroyDeviceInfoList(HardwareWiz.hDeviceInfo);
        return;
    }

    //
    // Load the libraries that we will need
    //
    hDevMgr = LoadLibrary(TEXT("devmgr.dll"));
    hNewDev = LoadLibrary(TEXT("newdev.dll"));

    HdwPropertySheet = HdwWizard(hwnd, &HardwareWiz, 0);
    if (HdwPropertySheet) {
    
        PropSheetResult = (int)PropertySheet(&HdwPropertySheet->PropSheetHeader);
        LocalFree(HdwPropertySheet);
    }

    //
    // See if we need to run a troubleshooter
    //
    if (HardwareWiz.RunTroubleShooter) {

        TCHAR DeviceID[MAX_DEVICE_ID_LEN];

        if (CM_Get_Device_ID(HardwareWiz.ProblemDevInst,
                             DeviceID,
                             SIZECHARS(DeviceID),
                             0
                             ) == CR_SUCCESS)
        {
            PDEVICEPROBLEMWIZARD pDeviceProblemWizard = NULL;

            pDeviceProblemWizard = (PDEVICEPROBLEMWIZARD)GetProcAddress(hDevMgr, "DeviceProblemWizardW");
    
            if (pDeviceProblemWizard) {
                (pDeviceProblemWizard)(hwnd,
                                      NULL,
                                      DeviceID
                                      );
            }
        }
    }

    //
    // Final cleanup of DeviceInfoData and DeviceInfoList
    //
    if (HardwareWiz.ClassGuidList) {

        LocalFree(HardwareWiz.ClassGuidList);
        HardwareWiz.ClassGuidList = NULL;
        HardwareWiz.ClassGuidSize = HardwareWiz.ClassGuidNum = 0;
    }

    if (HardwareWiz.ClassImageList.cbSize) {

        SetupDiDestroyClassImageList(&HardwareWiz.ClassImageList);
        HardwareWiz.ClassImageList.cbSize = 0;
    }

    if (HardwareWiz.Cancelled || 
        (HardwareWiz.Registered && !HardwareWiz.Installed)) {

        HdwRemoveDevice(&HardwareWiz);
        HardwareWiz.Reboot = 0;
    }

    SetupDiDestroyDeviceInfoList(HardwareWiz.hDeviceInfo);
    HardwareWiz.hDeviceInfo = NULL;

    if (HardwareWiz.SearchThread) {

        DestroySearchThread(HardwareWiz.SearchThread);
    }

    if (hDevMgr) {

        FreeLibrary(hDevMgr);
    }

    if (hNewDev) {

        FreeLibrary(hNewDev);
    }

    //
    // Do we need to reboot?
    //
    if (HardwareWiz.Reboot) {

        RestartDialogEx(hwnd, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
    }

    //
    // Do we need to shutdown?
    //
    if (HardwareWiz.Shutdown) {
        
        ShutdownMachine(hwnd);
    }

    return;
}

LONG
CPlApplet(
    HWND  hWnd,
    WORD  uMsg,
    DWORD_PTR lParam1,
    LPARAM lParam2
    )
{
    LPNEWCPLINFO lpCPlInfo;
    LPCPLINFO lpOldCPlInfo;

    UNREFERENCED_PARAMETER(lParam1);

    switch (uMsg) {
       case CPL_INIT:
           return TRUE;

       case CPL_GETCOUNT:
           return 1;

       case CPL_INQUIRE:
           lpOldCPlInfo = (LPCPLINFO)(LPARAM)lParam2;
           lpOldCPlInfo->lData = 0L;
           lpOldCPlInfo->idIcon = IDI_HDWWIZICON;
           lpOldCPlInfo->idName = IDS_HDWWIZ;
           lpOldCPlInfo->idInfo = IDS_HDWWIZINFO;
           return TRUE;

       case CPL_NEWINQUIRE:
           lpCPlInfo = (LPNEWCPLINFO)(LPARAM)lParam2;
           lpCPlInfo->hIcon = LoadIcon(hHdwWiz, MAKEINTRESOURCE(IDI_HDWWIZICON));
           LoadString(hHdwWiz, IDS_HDWWIZ, (LPWSTR)lpCPlInfo->szName, SIZECHARS(lpCPlInfo->szName));
           LoadString(hHdwWiz, IDS_HDWWIZINFO, (LPWSTR)lpCPlInfo->szInfo, SIZECHARS(lpCPlInfo->szInfo));
           lpCPlInfo->dwHelpContext = IDH_HDWWIZAPPLET;
           lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
           lpCPlInfo->lData = 0;
           lpCPlInfo->szHelpFile[0] = '\0';
           return TRUE;

       case CPL_DBLCLK:
           AddHardwareWizard(hWnd, NULL);
           break;

       default:
           break;
       }

    return 0L;
}

BOOL DllInitialize(
    IN PVOID hmod,
    IN ULONG ulReason,
    IN PCONTEXT pctx OPTIONAL
    )
{
    hHdwWiz = hmod;

    UNREFERENCED_PARAMETER(pctx);

    if (ulReason == DLL_PROCESS_ATTACH) {
        DisableThreadLibraryCalls(hmod);

        SHFusionInitializeFromModule(hmod);
    
    } else if (ulReason == DLL_PROCESS_DETACH) {
        SHFusionUninitialize();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\getdev.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       getdev.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"
#include <htmlhelp.h>

HMODULE hDevMgr=NULL;
PDEVICEPROBLEMTEXT pDeviceProblemText = NULL;

PTCHAR
DeviceProblemText(
                 DEVNODE DevNode,
                 ULONG Status,
                 ULONG ProblemNumber
                 )
{
    UINT LenChars, ReqLenChars;
    PTCHAR Buffer=NULL;
    PTCHAR p=NULL;
    TCHAR TempBuffer[MAX_PATH];

    if (hDevMgr) {

        if (!pDeviceProblemText) {

            pDeviceProblemText = (PDEVICEPROBLEMTEXT)GetProcAddress(hDevMgr, "DeviceProblemTextW");
        }
    }

    if (pDeviceProblemText) {

        LenChars = (pDeviceProblemText)(NULL,
                                        DevNode,
                                        ProblemNumber,
                                        Buffer,
                                        0
                                       );

        if (!LenChars) {

            goto DPTExitCleanup;
        }

        LenChars++;  // one extra for terminating NULL

        Buffer = LocalAlloc(LPTR, LenChars*sizeof(TCHAR));

        if (!Buffer) {

            goto DPTExitCleanup;
        }

        ReqLenChars = (pDeviceProblemText)(NULL,
                                           DevNode,
                                           ProblemNumber,
                                           Buffer,
                                           LenChars
                                          );

        if (!ReqLenChars || ReqLenChars >= LenChars) {

            LocalFree(Buffer);
            Buffer = NULL;
        }

        if (Buffer && (Status != 0)) {
            if (Status & DN_WILL_BE_REMOVED) {
                if (LoadString(hHdwWiz, 
                               IDS_WILL_BE_REMOVED, 
                               TempBuffer, 
                               SIZECHARS(TempBuffer)
                               )) {
                    LenChars += lstrlen(TempBuffer) + 1;
                    p = LocalAlloc(LPTR, LenChars*sizeof(TCHAR));

                    if (p) {
                        StringCchCopy(p, LenChars, Buffer);
                        StringCchCat(p, LenChars, TempBuffer);
                        LocalFree(Buffer);
                        Buffer = p;
                    }
                }
            }

            if (Status & DN_NEED_RESTART) {
                if (LoadString(hHdwWiz, 
                               IDS_NEED_RESTART, 
                               TempBuffer, 
                               SIZECHARS(TempBuffer)
                               )) {
                    LenChars += lstrlen(TempBuffer) + 1;
                    p = LocalAlloc(LPTR, LenChars*sizeof(TCHAR));

                    if (p) {
                        StringCchCopy(p, LenChars, Buffer);
                        StringCchCat(p, LenChars, TempBuffer);
                        LocalFree(Buffer);
                        Buffer = p;
                    }
                }
            }
        }
    }

    DPTExitCleanup:

    return Buffer;
}

int CALLBACK
DeviceListCompare(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    TCHAR ClassName1[MAX_CLASS_NAME_LEN];
    TCHAR ClassName2[MAX_CLASS_NAME_LEN];
    TCHAR Buffer[MAX_PATH];
    GUID  ClassGuid1, ClassGuid2;
    BOOL  bSpecialClass1 = FALSE, bSpecialClass2 = FALSE;
    ULONG ulLength;
    ULONG Status, Problem1, Problem2;

    UNREFERENCED_PARAMETER(lParamSort);

    //
    // Return
    // -1 if the first item should precede the second
    // +1 if the first item should follow the second
    // 0 if they are the same
    //

    //
    // First check if lParam1 or lParam2 are 0. A 0 lParam means that this
    // is the special 'Add a new hardware device' that goes at the bottom
    // of the list.
    //
    if (lParam1 == 0) {
        return 1;
    }

    if (lParam2 == 0) {
        return -1;
    }

    if (CM_Get_DevNode_Status(&Status, &Problem1, (DEVINST)lParam1, 0) != CR_SUCCESS) {
        Problem1 = 0;
    }
    
    if (CM_Get_DevNode_Status(&Status, &Problem2, (DEVINST)lParam2, 0) != CR_SUCCESS) {
        Problem2 = 0;
    }

    //
    // Devices with problems always go at the top of the list.  If both devices
    // have problems then we sort by class name.
    //
    if (Problem1 && !Problem2) {
        return -1;
    } else if (!Problem1 && Problem2) {
        return 1;
    }
    
    //
    // The next check is to put the special device classes above non-special 
    // device classes.
    //
    ulLength = sizeof(Buffer);
    if ((CM_Get_DevNode_Registry_Property((DEVINST)lParam1,
                                          CM_DRP_CLASSGUID,
                                          NULL,
                                          Buffer,
                                          &ulLength,
                                          0) == CR_SUCCESS) &&
        (ulLength != 0)) {

        pSetupGuidFromString(Buffer, &ClassGuid1);

        if (IsEqualGUID(&ClassGuid1, &GUID_DEVCLASS_DISPLAY) ||
            IsEqualGUID(&ClassGuid1, &GUID_DEVCLASS_MEDIA)) {
            //
            // Device 1 is one of the special classes that go at the top of the list.
            //
            bSpecialClass1 = TRUE;
        }
    } 

    ulLength = sizeof(Buffer);
    if ((CM_Get_DevNode_Registry_Property((DEVINST)lParam2,
                                          CM_DRP_CLASSGUID,
                                          NULL,
                                          Buffer,
                                          &ulLength,
                                          0) == CR_SUCCESS) &&
        (ulLength != 0)) {
    
        pSetupGuidFromString(Buffer, &ClassGuid2);

        if (IsEqualGUID(&ClassGuid2, &GUID_DEVCLASS_DISPLAY) ||
            IsEqualGUID(&ClassGuid2, &GUID_DEVCLASS_MEDIA)) {
            //
            // Device 2 is one of the special classes that go at the top of the list.
            //
            bSpecialClass2 = TRUE;
        }
    }

    if (bSpecialClass1 && !bSpecialClass2) {
        return -1;
    } else if (!bSpecialClass1 && bSpecialClass2) {
        return 1;
    }

    //
    // The final check is to sort the items by classes
    //
    ulLength = sizeof(ClassName1);
    if ((CM_Get_DevNode_Registry_Property((DEVINST)lParam1,
                                          CM_DRP_CLASS,
                                          NULL,
                                          ClassName1,
                                          &ulLength,
                                          0) != CR_SUCCESS) ||
        (ulLength == 0)) {
        //
        // If we could not get a class name then set it to all Z's so it will
        // get put at the bottom of the list.
        //
        StringCchCopy(ClassName1, SIZECHARS(ClassName1), TEXT("ZZZZZZZZZZ"));;
    }

    ulLength = sizeof(ClassName2);
    if ((CM_Get_DevNode_Registry_Property((DEVINST)lParam2,
                                          CM_DRP_CLASS,
                                          NULL,
                                          ClassName2,
                                          &ulLength,
                                          0) != CR_SUCCESS) ||
        (ulLength == 0)) {
        //
        // If we could not get a class name then set it to all Z's so it will
        // get put at the bottom of the list.
        //
        StringCchCopy(ClassName2, SIZECHARS(ClassName2), TEXT("ZZZZZZZZZZ"));;
    }

    return lstrcmpi(ClassName1, ClassName2);
}

void
InsertNoneOfTheseDevices(
                        HWND hwndList
                        )
{
    LV_ITEM lviItem;
    TCHAR String[MAX_PATH];

    LoadString(hHdwWiz, IDS_HDW_NONEDEVICES, String, SIZECHARS(String));

    lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    lviItem.iSubItem = 0;
    lviItem.lParam = (LPARAM)0;
    lviItem.iItem = 0;
    lviItem.iImage = g_BlankIconIndex;
    lviItem.pszText = String;

    ListView_InsertItem(hwndList, &lviItem);
}

BOOL
ProblemDeviceListFilter(
                       PHARDWAREWIZ HardwareWiz,
                       PSP_DEVINFO_DATA DeviceInfoData
                       )
/*++

Routine Description:
    
    This function is a callback for the BuildDeviceListView API.  It will get called
    for every device and can filter which devices end up getting displayed.  If it
    returns FALSE then the given device won't be displayed.  If it returns TRUE then
    the device will be displayed.
    
    Currently we will filter out all system devices from the problem devices list since
    they cluter up the list view and it would be very rare that a user would come to
    Add Hardware to add a system device.
    
--*/
{
    UNREFERENCED_PARAMETER(HardwareWiz);    
    
    //
    // If this is a system class device then filter it out of the list by
    // returning FALSE.
    //
    if (IsEqualGUID(&DeviceInfoData->ClassGuid, &GUID_DEVCLASS_SYSTEM)) {

        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
HdwProbListDlgProc(
                  HWND   hDlg,
                  UINT   message,
                  WPARAM wParam,
                  LPARAM lParam
                  )
/*++

Routine Description:


Arguments:

   standard stuff.



Return Value:

   INT_PTR

--*/

{
    PHARDWAREWIZ HardwareWiz;

    if (message == WM_INITDIALOG) {

        LV_COLUMN lvcCol;
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ) lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        HardwareWiz->hwndProbList = GetDlgItem(hDlg, IDC_HDWPROBLIST);

        //
        // Insert columns for listview.
        // 0 == device name
        //

        lvcCol.mask = LVCF_WIDTH | LVCF_SUBITEM;

        lvcCol.iSubItem = 0;
        ListView_InsertColumn(HardwareWiz->hwndProbList, 0, &lvcCol);

        SendMessage(HardwareWiz->hwndProbList,
                    LVM_SETEXTENDEDLISTVIEWSTYLE,
                    LVS_EX_FULLROWSELECT,
                    LVS_EX_FULLROWSELECT
                   );

        ListView_SetExtendedListViewStyle(HardwareWiz->hwndProbList, LVS_EX_FULLROWSELECT | LVS_EX_LABELTIP);

        return TRUE;
    }

    //
    // retrieve private data from window long (stored there during WM_INITDIALOG)
    //
    HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message) {
    
    case WM_DESTROY:
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY: {

            NMHDR FAR *pnmhdr = (NMHDR FAR *)lParam;

            switch (pnmhdr->code) {
            
            case PSN_SETACTIVE: {

                    DWORD DevicesDetected;
                    HWND hwndProbList;
                    HWND hwndParentDlg;
                    LVITEM lvItem;

                    hwndParentDlg = GetParent(hDlg);

                    HardwareWiz->PrevPage = IDD_ADDDEVICE_PROBLIST;

                    //
                    // initialize the list view, we do this on each setactive
                    // since a new class may have been installed or the problem
                    // device list may change as we go back and forth between pages.
                    //
                    hwndProbList = HardwareWiz->hwndProbList;

                    SendMessage(hwndProbList, WM_SETREDRAW, FALSE, 0L);
                    ListView_DeleteAllItems(hwndProbList);

                    if (HardwareWiz->ClassImageList.cbSize) {

                        ListView_SetImageList(hwndProbList,
                                              HardwareWiz->ClassImageList.ImageList,
                                              LVSIL_SMALL
                                             );
                    }

                    //
                    // Next put all of the devices into the list
                    //
                    DevicesDetected = 0;
                    BuildDeviceListView(HardwareWiz,
                                        HardwareWiz->hwndProbList,
                                        FALSE,
                                        HardwareWiz->ProblemDevInst,
                                        &DevicesDetected,
                                        ProblemDeviceListFilter
                                       );

                    InsertNoneOfTheseDevices(HardwareWiz->hwndProbList);

                    //
                    // Sort the list
                    //
                    ListView_SortItems(HardwareWiz->hwndProbList,
                                       (PFNLVCOMPARE)DeviceListCompare,
                                       NULL
                                       );

                    lvItem.mask = LVIF_PARAM;
                    lvItem.iSubItem = 0;
                    lvItem.iItem = ListView_GetNextItem(HardwareWiz->hwndProbList, -1, LVNI_SELECTED);

                    //
                    // select the first item in the list if nothing else was selected
                    //
                    if (lvItem.iItem == -1) {

                        ListView_SetItemState(hwndProbList,
                                              0,
                                              LVIS_FOCUSED,
                                              LVIS_FOCUSED
                                             );

                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);

                    } else {

                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    }

                    ListView_EnsureVisible(hwndProbList, lvItem.iItem, FALSE);
                    ListView_SetColumnWidth(hwndProbList, 0, LVSCW_AUTOSIZE_USEHEADER);

                    SendMessage(hwndProbList, WM_SETREDRAW, TRUE, 0L);

                }
                break;

            case PSN_WIZNEXT: {

                    LVITEM lvItem;

                    lvItem.mask = LVIF_PARAM;
                    lvItem.iSubItem = 0;
                    lvItem.iItem = ListView_GetNextItem(HardwareWiz->hwndProbList, -1, LVNI_SELECTED);

                    if (lvItem.iItem != -1) {

                        ListView_GetItem(HardwareWiz->hwndProbList, &lvItem);

                        HardwareWiz->ProblemDevInst = (DEVNODE)lvItem.lParam;

                    } else {

                        HardwareWiz->ProblemDevInst = 0;
                    }

                    //
                    // If the HardwareWiz->ProblemDevInst is 0 then the user selected none of the items
                    // so we will move on to detection
                    //
                    if (HardwareWiz->ProblemDevInst == 0) {

                        SetDlgMsgResult(hDlg, WM_NOTIFY, IDD_ADDDEVICE_ASKDETECT);

                    } else {

                        SetDlgMsgResult(hDlg, WM_NOTIFY, IDD_ADDDEVICE_PROBLIST_FINISH);
                    }
                }
                break;

            case PSN_WIZFINISH:
                break;


            case PSN_WIZBACK:
                SetDlgMsgResult(hDlg, WM_NOTIFY, IDD_ADDDEVICE_CONNECTED);
                break;

            case NM_DBLCLK:
                PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
                break;

            case LVN_ITEMCHANGED:
                if (ListView_GetSelectedCount(HardwareWiz->hwndProbList) == 0) {

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                } else {

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                }
            }

        }
        break;

    case WM_SYSCOLORCHANGE:
        HdwWizPropagateMessage(hDlg, message, wParam, lParam);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
HdwProbListFinishDlgProc(
                        HWND   hDlg,
                        UINT   wMsg,
                        WPARAM wParam,
                        LPARAM lParam
                        )
/*++

Routine Description:


Arguments:


Return Value:

   INT_PTR

--*/

{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wParam);

    if (wMsg == WM_INITDIALOG) {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);
        return TRUE;
    }

    switch (wMsg) {
    case WM_DESTROY:
        break;

    case WM_COMMAND:
        break;

    case WM_NOTIFY: {
            NMHDR FAR *pnmhdr = (NMHDR FAR *)lParam;

            switch (pnmhdr->code) {
            case PSN_SETACTIVE: 
                {
                    PTCHAR FriendlyName;
                    PTCHAR ProblemText;
                    ULONG Status, Problem;

                    FriendlyName = BuildFriendlyName(HardwareWiz->ProblemDevInst);
                    if (FriendlyName) {

                        SetDlgItemText(hDlg, IDC_HDW_DESCRIPTION, FriendlyName);
                        LocalFree(FriendlyName);
                    }

                    Status = Problem = 0;
                    CM_Get_DevNode_Status(&Status,
                                          &Problem,
                                          HardwareWiz->ProblemDevInst,
                                          0
                                          );

                    ProblemText = DeviceProblemText(HardwareWiz->ProblemDevInst,
                                                    Status,
                                                    Problem
                                                   );

                    if (ProblemText) {
                        SetDlgItemText(hDlg, IDC_PROBLEM_DESC, ProblemText);
                        LocalFree(ProblemText);
                    }

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
                }
                break;

            case PSN_WIZFINISH:
                HardwareWiz->RunTroubleShooter = TRUE;
                break;

            case PSN_WIZBACK:
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_PROBLIST);
                break;

            }

        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\install.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       install.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"


typedef
UINT
(*PINSTALLDEVINST)(
    HWND hwndParent,
    LPCWSTR DeviceInstanceId,
    BOOL UpdateDriver,
    PDWORD pReboot
    );

HMODULE hNewDev = NULL;
PINSTALLDEVINST pInstallDevInst = NULL;



void
InstallSilentChilds(
   HWND hwdnParent,
   PHARDWAREWIZ HardwareWiz
   );
   
void
InstallSilentChildSiblings(
   HWND hwndParent,
   PHARDWAREWIZ HardwareWiz,
   DEVINST DeviceInstance,
   BOOL ReinstallAll
   )
{
    CONFIGRET ConfigRet;
    DEVINST ChildDeviceInstance;
    ULONG Ulong, ulValue;
    BOOL NeedsInstall, IsSilent;

    do {
        //
        // If this device instance needs installing and is silent then install it,
        // and its children.
        //
        IsSilent = FALSE;
        if (!ReinstallAll) {

            Ulong = sizeof(ulValue);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                            CM_DRP_CAPABILITIES,
                                                            NULL,
                                                            (PVOID)&ulValue,
                                                            &Ulong,
                                                            0,
                                                            NULL
                                                            );

            if (ConfigRet == CR_SUCCESS && (ulValue & CM_DEVCAP_SILENTINSTALL)) {

                IsSilent = TRUE;
            }
        }

        if (IsSilent || ReinstallAll) {

            Ulong = sizeof(ulValue);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                            CM_DRP_CONFIGFLAGS,
                                                            NULL,
                                                            (PVOID)&ulValue,
                                                            &Ulong,
                                                            0,
                                                            NULL
                                                            );

            if (ConfigRet == CR_SUCCESS && (ulValue & CONFIGFLAG_FINISH_INSTALL)) {

                NeedsInstall = TRUE;

            } else {

                ConfigRet = CM_Get_DevNode_Status(&Ulong,
                                                  &ulValue,
                                                  DeviceInstance,
                                                  0
                                                  );

                NeedsInstall = ConfigRet == CR_SUCCESS &&
                               (ulValue == CM_PROB_REINSTALL ||
                                ulValue == CM_PROB_NOT_CONFIGURED
                                );
            }


            if (NeedsInstall) {

                TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];

                ConfigRet = CM_Get_Device_ID(DeviceInstance,
                                            DeviceInstanceId,
                                            SIZECHARS(DeviceInstanceId),
                                            0
                                            );

                if (ConfigRet == CR_SUCCESS) {

                    if (hNewDev) {

                        if (!pInstallDevInst) {

                            pInstallDevInst = (PINSTALLDEVINST)GetProcAddress(hNewDev, "InstallDevInst");
                        }
                    }

                    if (pInstallDevInst) {

                        if (pInstallDevInst(hwndParent,
                                            DeviceInstanceId,
                                            FALSE,   // only for found new.
                                            &Ulong
                                            )) {

                           HardwareWiz->Reboot |= Ulong;
                        }
                    }


                    //
                    // If this devinst has children, then recurse to install them as well.
                    //
                    ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance,
                                                DeviceInstance,
                                                0,
                                                NULL
                                                );

                    if (ConfigRet == CR_SUCCESS) {

                        InstallSilentChildSiblings(hwndParent, HardwareWiz, ChildDeviceInstance, ReinstallAll);
                    }

                }
            }
        }


        //
        // Next sibling ...
        //
        ConfigRet = CM_Get_Sibling_Ex(&DeviceInstance,
                                      DeviceInstance,
                                      0,
                                      NULL
                                      );

    } while (ConfigRet == CR_SUCCESS);
}

void
InstallSilentChilds(
   HWND hwndParent,
   PHARDWAREWIZ HardwareWiz
   )
{
    CONFIGRET ConfigRet;
    DEVINST ChildDeviceInstance;

    ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance,
                                HardwareWiz->DeviceInfoData.DevInst,
                                0,
                                NULL
                                );

    if (ConfigRet == CR_SUCCESS) {

        InstallSilentChildSiblings(hwndParent, HardwareWiz, ChildDeviceInstance, FALSE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\pnpenum.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       pnpenum.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"


INT_PTR CALLBACK HdwAskDetectDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg)  {
        case WM_INITDIALOG: {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

            break;
        }

        case WM_COMMAND:
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR *)lParam)->code) {
                case PSN_SETACTIVE:

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                    HardwareWiz->PrevPage = IDD_ADDDEVICE_ASKDETECT;

                    //
                    // Set the Initial radio button state.
                    // default to do autodetection.
                    //
                    CheckRadioButton(hDlg,
                                     IDC_ADDDEVICE_ASKDETECT_AUTO,
                                     IDC_ADDDEVICE_ASKDETECT_SPECIFIC,
                                     IDC_ADDDEVICE_ASKDETECT_AUTO
                                     );

                    break;


                case PSN_WIZBACK:
                    //
                    // If we are going back then this is effectively a Cancel
                    //
                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_PROBLIST);
                    break;

                case PSN_WIZNEXT:
                    if (IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_ASKDETECT_AUTO)) {

                        SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_DETECTION);

                    } else {

                        SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTCLASS);
                    }
                    break;

                case PSN_RESET:
                    HardwareWiz->Cancelled = TRUE;
                    break;
                }

            break;

        default:
            return(FALSE);
        }

    return(TRUE);
}

DWORD
PNPEnumerate(
    PHARDWAREWIZ HardwareWiz
    )
{
    CONFIGRET ConfigRet;
    DEVINST RootDevInst, ChildDevInst;

    if (HardwareWiz->ExitDetect) {

        return 0;
    }

    //
    // reenumerate from the root of the devnode tree
    //
    ConfigRet = CM_Locate_DevNode_Ex(&RootDevInst,
                                     NULL,
                                     CM_LOCATE_DEVNODE_NORMAL,
                                     NULL
                                     );


    if (ConfigRet != CR_SUCCESS) {

        return 0;
    }


    //
    // Force install of ALL devices which still need installing.
    // save reboot flags to pass back to main thread.
    //
    ConfigRet = CM_Get_Child_Ex(&ChildDevInst,
                                RootDevInst,
                                0,
                                NULL
                                );

    if (ConfigRet == CR_SUCCESS) {

        InstallSilentChildSiblings(NULL, HardwareWiz, ChildDevInst, TRUE);
    }


    if (HardwareWiz->Reboot) {

        return 0;
    }

    Sleep(100); // give a chance for new devices to be noticed by PNP

    //
    // Ask PNP to look for newly arrived devices.
    //
    CM_Reenumerate_DevNode_Ex(
        RootDevInst,
        CM_REENUMERATE_SYNCHRONOUS | CM_REENUMERATE_RETRY_INSTALLATION,
        NULL
        );

    Sleep(5000); // give a chance for new devices to be noticed by PNP

    do {

        if (HardwareWiz->ExitDetect) {

            return 0;
        }

    } while (CMP_WaitNoPendingInstallEvents(1000) == WAIT_TIMEOUT);


    return 0;
}

int
InsertDeviceNodeListView(
    HWND hwndList,
    PHARDWAREWIZ HardwareWiz,
    PSP_DEVINFO_DATA DeviceInfoData
    )
{
    INT lvIndex;
    LV_ITEM lviItem;
    PTCHAR DeviceName;
    ULONG Status = 0, Problem = 0;

    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iItem = -1;
    lviItem.iSubItem = 0;

    if (SetupDiGetClassImageIndex(&HardwareWiz->ClassImageList,
                                  &DeviceInfoData->ClassGuid,
                                  &lviItem.iImage
                                  )) {

        lviItem.mask |= LVIF_IMAGE;
    }

    DeviceName = BuildFriendlyName(DeviceInfoData->DevInst);

    if (DeviceName) {

        lviItem.pszText = DeviceName;

    } else {

        lviItem.pszText = szUnknown;
    }

    lviItem.mask |= LVIF_STATE;

    if (CM_Get_DevNode_Status(&Status, &Problem, DeviceInfoData->DevInst, 0) == CR_SUCCESS) {
        if (Problem) {
            //
            // Add the yellow ! or red X overlay to the devnode if it has a 
            // problem.
            //
            lviItem.state = (Problem == CM_PROB_DISABLED) ?
                            INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1) :
                            INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
    
        } else {
            lviItem.state = INDEXTOOVERLAYMASK(0);
        }

        lviItem.stateMask = LVIS_OVERLAYMASK;
    }


    lviItem.lParam = (LPARAM)DeviceInfoData->DevInst;
    lvIndex = ListView_InsertItem(hwndList, &lviItem);

    if (DeviceName) {

        LocalFree(DeviceName);
    }

    return lvIndex;
}

BOOL
AnyNewPnPDevicesFound(
    HWND hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{
    HDEVINFO NewDeviceInfo, OldDeviceInfo;
    BOOL NewDevicesFound;
    BOOL NewDevice;
    INT iNew, iOld;
    SP_DEVINFO_DATA NewDeviceInfoData, OldDeviceInfoData;

    OldDeviceInfo = HardwareWiz->PNPEnumDeviceInfo;
    NewDeviceInfo = SetupDiGetClassDevs(NULL,
                                     NULL,
                                     GetParent(hDlg),
                                     DIGCF_ALLCLASSES
                                     );

    if (!OldDeviceInfo || NewDeviceInfo == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    NewDevicesFound = FALSE;
    iNew = 0;
    NewDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    while (SetupDiEnumDeviceInfo(NewDeviceInfo, iNew++, &NewDeviceInfoData)) {

        NewDevice = TRUE;
        iOld = 0;
        OldDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        while (SetupDiEnumDeviceInfo(OldDeviceInfo, iOld++, &OldDeviceInfoData)) {

            if (NewDeviceInfoData.DevInst == OldDeviceInfoData.DevInst) {

                //
                // If this DevInst exists in the Old DeviceInfo list then it is
                // not a new device.
                //
                NewDevice = FALSE;
                break;
            }
        }

        //
        // If we did not find this device in the original list then it is a new
        // PnP device.  Set the NewDevicesFound BOOL and break out of the loop.
        //
        if (NewDevice) {

            NewDevicesFound = TRUE;
            break;
        }
    }

    SetupDiDestroyDeviceInfoList(NewDeviceInfo);

    return NewDevicesFound;
}

INT_PTR CALLBACK
HdwPnpEnumDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wParam);

    if (wMsg == WM_INITDIALOG) {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        return TRUE;
    }


    switch (wMsg)  {

    case WM_COMMAND:
        break;

    case WM_DESTROY:
        if (HardwareWiz->PNPEnumDeviceInfo) {

            SetupDiDestroyDeviceInfoList(HardwareWiz->PNPEnumDeviceInfo);
            HardwareWiz->PNPEnumDeviceInfo = NULL;
        }
        break;


    case WUM_PNPENUMERATE:
        HardwareWiz->InstallPending = FALSE;
        HardwareWiz->CurrCursor = NULL;
        SetCursor(HardwareWiz->IdcArrow);
        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));

        if (HardwareWiz->ExitDetect) {

            break;
        }

        HardwareWiz->FoundPnPDevices = AnyNewPnPDevicesFound(hDlg, HardwareWiz);
        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

            case PSN_SETACTIVE: {
                int PrevPage;

                PrevPage = HardwareWiz->PrevPage;
                HardwareWiz->PrevPage = IDD_ADDDEVICE_PNPENUM;
                HardwareWiz->ExitDetect = FALSE;


                //
                // If moving forwards, kick off enumeration.
                //
                if (PrevPage != IDD_ADDDEVICE_ASKDETECT) {
                    EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), FALSE);
                    PropSheet_SetWizButtons(GetParent(hDlg), 0);
                    SetDlgText(hDlg, IDC_HDW_TEXT, IDS_ADDDEVICE_PNPENUMERATE, IDS_ADDDEVICE_PNPENUMERATE);

                    Animate_Open(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), MAKEINTRESOURCE(IDA_SEARCHING));
                    Animate_Play(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), 0, -1, -1);

                    //
                    // Create a list of all of the installed devices, which
                    // will be used after enumeration to build the list of
                    // newly installed.
                    //
                    HardwareWiz->PNPEnumDeviceInfo = SetupDiGetClassDevs(
                                                        NULL,
                                                        NULL,
                                                        GetParent(hDlg),
                                                        DIGCF_ALLCLASSES
                                                        );

                    if (HardwareWiz->PNPEnumDeviceInfo == INVALID_HANDLE_VALUE) {

                        HardwareWiz->PNPEnumDeviceInfo = NULL;
                    }


                    HardwareWiz->InstallPending = TRUE;

                    HardwareWiz->CurrCursor = HardwareWiz->IdcAppStarting;
                    SetCursor(HardwareWiz->CurrCursor);

                    if (!SearchThreadRequest(HardwareWiz->SearchThread,
                                        hDlg,
                                        SEARCH_PNPENUM,
                                        0
                                        )) {

                        EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
                        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK| PSWIZB_NEXT);
                        SetDlgText(hDlg, IDC_HDW_TEXT, IDS_ADDDEVICE_PNPENUMERROR, IDS_ADDDEVICE_PNPENUMERROR);
                        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
                    }
                }
            }
            break;

            case PSN_QUERYCANCEL:
                if (HardwareWiz->InstallPending) {

                    if (HardwareWiz->ExitDetect) {

                        SetDlgMsgResult(hDlg, wMsg, TRUE);
                        break;
                    }

                    HardwareWiz->ExitDetect = TRUE;
                    HardwareWiz->CurrCursor = HardwareWiz->IdcWait;
                    SetCursor(HardwareWiz->CurrCursor);
                    CancelSearchRequest(HardwareWiz);
                    HardwareWiz->CurrCursor = NULL;
                }

                SetDlgMsgResult(hDlg, wMsg, FALSE);
                break;

            case PSN_RESET:
               HardwareWiz->Cancelled = TRUE;
               Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
               break;

            case PSN_WIZBACK:
               SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_WELCOME);
               break;

            case PSN_WIZNEXT:
                if (HardwareWiz->FoundPnPDevices) {

                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_PNPFINISH);

                } else {

                    EnableWindow(GetDlgItem(GetParent(hDlg),  IDCANCEL), TRUE);
                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_CONNECTED);
                }
                break;

        }
        break;

    case WM_SETCURSOR:
        if (HardwareWiz->CurrCursor) {

            SetCursor(HardwareWiz->CurrCursor);
            break;
        }

        // fall thru to return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

BOOL
FillInstalledDevicesList(
    HWND hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{
    HDEVINFO NewDeviceInfo, OldDeviceInfo;
    BOOL Installed;
    BOOL NewDevice;
    INT iNew, iOld;
    SP_DEVINFO_DATA NewDeviceInfoData, OldDeviceInfoData;
    HWND hwndList;

    hwndList = GetDlgItem(hDlg, IDC_FOUNDPNP_LIST);
    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);
    ListView_DeleteAllItems(hwndList);

    OldDeviceInfo = HardwareWiz->PNPEnumDeviceInfo;
    NewDeviceInfo = SetupDiGetClassDevs(NULL,
                                     NULL,
                                     GetParent(hDlg),
                                     DIGCF_ALLCLASSES
                                     );

    if (!OldDeviceInfo || NewDeviceInfo == INVALID_HANDLE_VALUE) {

        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);
        return FALSE;
    }

    //
    // For each element in the new list check to see if its in the old list.
    // If its not then it is a newly installed devnode so add it to the list box.
    //
    Installed = FALSE;
    iNew = 0;
    NewDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

    while (SetupDiEnumDeviceInfo(NewDeviceInfo, iNew++, &NewDeviceInfoData)) {

        NewDevice = TRUE;
        iOld = 0;
        OldDeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        while (SetupDiEnumDeviceInfo(OldDeviceInfo, iOld++, &OldDeviceInfoData)) {

            if (NewDeviceInfoData.DevInst == OldDeviceInfoData.DevInst) {
                //
                // If this DevInst exists in the Old DeviceInfo list then it is
                // not a new device.
                //
                NewDevice = FALSE;
                break;
            }
        }

        //
        // If this is a new device then add it to the list view and set
        // the Installed boolean to TRUE.
        //
        if (NewDevice) {

            InsertDeviceNodeListView(hwndList, HardwareWiz, &NewDeviceInfoData);
            Installed = TRUE;
        }
    }

    SetupDiDestroyDeviceInfoList(NewDeviceInfo);

    if (!Installed) {

        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);
        SetupDiDestroyDeviceInfoList(HardwareWiz->PNPEnumDeviceInfo);
        HardwareWiz->PNPEnumDeviceInfo = NULL;
        return FALSE;
    }


    ListView_SetItemState(hwndList,
                          0,
                          LVIS_SELECTED|LVIS_FOCUSED,
                          LVIS_SELECTED|LVIS_FOCUSED
                          );

    //
    // scroll the selected item into view.
    //
    ListView_EnsureVisible(hwndList, 0, FALSE);
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);

    return Installed;
}

BOOL
InitPnpFinishDlgProc(
    HWND hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{
    HWND hwndList;
    LV_COLUMN lvcCol;
    TCHAR Buffer[64];

    //
    // Insert columns for listview.
    // 0 == device name
    //
    hwndList = GetDlgItem(hDlg, IDC_FOUNDPNP_LIST);

    lvcCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvcCol.fmt = LVCFMT_LEFT;
    lvcCol.pszText = Buffer;

    lvcCol.iSubItem = 0;
    LoadString(hHdwWiz, IDS_DEVINSTALLED, Buffer, SIZECHARS(Buffer));
    ListView_InsertColumn(hwndList, 0, &lvcCol);

    SendMessage(hwndList,
                LVM_SETEXTENDEDLISTVIEWSTYLE,
                LVS_EX_FULLROWSELECT,
                LVS_EX_FULLROWSELECT
                );

    if (HardwareWiz->ClassImageList.cbSize) {

        ListView_SetImageList(hwndList,
                              HardwareWiz->ClassImageList.ImageList,
                              LVSIL_SMALL
                              );
    }

    return TRUE;
}

INT_PTR CALLBACK
HdwPnpFinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HWND hwndParentDlg=GetParent(hDlg);

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg)  {
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);

        if (!InitPnpFinishDlgProc(hDlg, HardwareWiz)) {
            return FALSE;
        }

        break;
        }

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((LPNMHDR)lParam)->code) {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_FINISH);
            EnableWindow(GetDlgItem(hwndParentDlg, IDCANCEL), FALSE);
            FillInstalledDevicesList(hDlg, HardwareWiz);
            break;

        case PSN_WIZFINISH:
            break;

        case NM_DBLCLK:
            if ((((LPNMHDR)lParam)->idFrom) == IDC_FOUNDPNP_LIST) {
                LVITEM lvItem;

                lvItem.mask = LVIF_PARAM;
                lvItem.iSubItem = 0;
                lvItem.iItem = ListView_GetNextItem(GetDlgItem(hDlg, IDC_FOUNDPNP_LIST),
                                                    -1, 
                                                    LVNI_SELECTED);

                if ((lvItem.iItem != -1) &&
                    ListView_GetItem(GetDlgItem(hDlg, IDC_FOUNDPNP_LIST), &lvItem) &&
                    (lvItem.lParam)) {
                    //
                    // Launch the properties for this device.
                    //
                    DeviceProperties(hDlg,
                                     (DEVNODE)lvItem.lParam,
                                     0
                                     );
                }
            }
        }
        break;


    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
HdwConnectedDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);


    if (wMsg == WM_INITDIALOG) {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        return TRUE;
    }


    switch (wMsg)  {

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDC_ADDDEVICE_CONNECTED_YES:
        case IDC_ADDDEVICE_CONNECTED_NO:
            //
            // Only show the next button if one of the radio buttons are
            // selected.
            //
            if (IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_CONNECTED_YES) ||
                IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_CONNECTED_NO)) {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            } else {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
            }
            break;
        }
        break;

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

            case PSN_SETACTIVE:
                HardwareWiz->PrevPage = IDD_ADDDEVICE_CONNECTED;
                
                //
                // Only show the next button if one of the radio buttons are
                // selected.
                //
                if (IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_CONNECTED_YES) ||
                    IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_CONNECTED_NO)) {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
                } else {
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                }
                break;

            case PSN_WIZBACK:
                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_WELCOME);
                break;

            case PSN_WIZNEXT:
                if (IsDlgButtonChecked(hDlg, IDC_ADDDEVICE_CONNECTED_YES)) {

                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_PROBLIST);

                } else {

                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_CONNECTED_FINISH);
                }
                break;

        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
HdwConnectedFinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wParam);

    if (wMsg == WM_INITDIALOG) {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        SetWindowFont(GetDlgItem(hDlg, IDC_HDWNAME), HardwareWiz->hfontTextBigBold, TRUE);
        return TRUE;
    }


    switch (wMsg)  {

    case WM_COMMAND:
        break;

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
            break;

        case PSN_WIZBACK:
            SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_CONNECTED);
            break;

        case PSN_WIZFINISH:
            if (IsDlgButtonChecked(hDlg, IDC_NEED_SHUTDOWN)) {
                //
                // Rember that we need to shutdown.
                //
                HardwareWiz->Shutdown = TRUE;    
            }
            break;

        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\selclass.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       selclass.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"


int CALLBACK
ClassListCompare(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    TCHAR ClassDescription1[LINE_LEN];
    TCHAR ClassDescription2[LINE_LEN];

    UNREFERENCED_PARAMETER(lParamSort);

    //
    // Check if the 1st item is GUID_DEVCLASS_UNKNOWN
    //
    if (IsEqualGUID((LPGUID)lParam1, &GUID_DEVCLASS_UNKNOWN)) {
        return -1;
    }

    //
    // Check if the 2nd item is GUID_DEVCLASS_UNKNOWN
    //
    if (IsEqualGUID((LPGUID)lParam2, &GUID_DEVCLASS_UNKNOWN)) {
        return 1;
    }

    if (SetupDiGetClassDescription((LPGUID)lParam1,
                                   ClassDescription1,
                                   LINE_LEN,
                                   NULL
                                   ) &&
        SetupDiGetClassDescription((LPGUID)lParam2,
                                   ClassDescription2,
                                   LINE_LEN,
                                   NULL
                                   )) {
    
        return (lstrcmpi(ClassDescription1, ClassDescription2));
    }

    return 0;
}

void InitHDW_PickClassDlg(
    HWND hwndClassList,
    PHARDWAREWIZ HardwareWiz
    )
{
    LPGUID ClassGuid, lpClassGuidSelected;
    GUID ClassGuidSelected;
    int    lvIndex;
    DWORD  ClassGuidNum;
    LV_ITEM lviItem;
    TCHAR ClassDescription[LINE_LEN];

    SendMessage(hwndClassList, WM_SETREDRAW, FALSE, 0L);

    // Clear the Class List
    ListView_DeleteAllItems(hwndClassList);

    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iItem = -1;
    lviItem.iSubItem = 0;

    ClassGuid = HardwareWiz->ClassGuidList;
    ClassGuidNum = HardwareWiz->ClassGuidNum;

    // keep track of previosuly selected item
    if (IsEqualGUID(&HardwareWiz->lvClassGuidSelected, &GUID_NULL)) {
    
        lpClassGuidSelected = NULL;

    } else {
    
        ClassGuidSelected = HardwareWiz->lvClassGuidSelected;
        HardwareWiz->lvClassGuidSelected = GUID_NULL;
        lpClassGuidSelected = &ClassGuidSelected;
    }

    while (ClassGuidNum--) {
    
        if (SetupDiGetClassDescription(ClassGuid,
                                       ClassDescription,
                                       LINE_LEN,
                                       NULL
                                       )) {
                                       
            if (IsEqualGUID(ClassGuid, &GUID_DEVCLASS_UNKNOWN)) {
                //
                // We need to special case the UNKNOWN class and to give it a 
                // special icon (blank) and special text (Show All Devices).
                //
                LoadString(hHdwWiz, 
                           IDS_SHOWALLDEVICES, 
                           ClassDescription, 
                           SIZECHARS(ClassDescription)
                           );
                lviItem.iImage = g_BlankIconIndex;                
                lviItem.mask |= LVIF_IMAGE;

            } else if (SetupDiGetClassImageIndex(&HardwareWiz->ClassImageList,
                                                 ClassGuid,
                                                 &lviItem.iImage
                                                 )) {
                                           
                lviItem.mask |= LVIF_IMAGE;

            } else {
            
                lviItem.mask &= ~LVIF_IMAGE;

            }

            lviItem.pszText = ClassDescription;
            lviItem.lParam = (LPARAM) ClassGuid;
            lvIndex = ListView_InsertItem(hwndClassList, &lviItem);

            //
            // check for previous selection
            //
            if (lpClassGuidSelected &&
                IsEqualGUID(lpClassGuidSelected, ClassGuid)) {
                
                ListView_SetItemState(hwndClassList,
                                      lvIndex,
                                      LVIS_SELECTED|LVIS_FOCUSED,
                                      LVIS_SELECTED|LVIS_FOCUSED
                                      );

                lpClassGuidSelected = NULL;
            }
        }

        ClassGuid++;
    }

    //
    // Sort the list
    //
    ListView_SortItems(hwndClassList, (PFNLVCOMPARE)ClassListCompare, NULL);

    //
    // if previous selection wasn't found select first in list.
    //
    if (IsEqualGUID(&HardwareWiz->lvClassGuidSelected, &GUID_NULL)) {

        lvIndex = 0;
        ListView_SetItemState(hwndClassList,
                              lvIndex,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED
                              );
    }

    //
    // previous selection was found, fetch its current index
    //
    else {

        lvIndex = ListView_GetNextItem(hwndClassList,
                                       -1,
                                       LVNI_SELECTED
                                       );
    }

    //
    // scroll the selected item into view.
    //
    ListView_EnsureVisible(hwndClassList, lvIndex, FALSE);
    ListView_SetColumnWidth(hwndClassList, 0, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndClassList, WM_SETREDRAW, TRUE, 0L);
}

INT_PTR CALLBACK
HdwPickClassDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndClassList = GetDlgItem(hDlg, IDC_HDW_PICKCLASS_CLASSLIST);
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);



    switch (wMsg) {
    
        case WM_INITDIALOG: {
       
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            LV_COLUMN lvcCol;

            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);

            //
            // Get the Class Icon Image Lists.  We do this only the first
            // time this dialog is initialized.
            //
            if (HardwareWiz->ClassImageList.cbSize) {

                ListView_SetImageList(hwndClassList,
                                      HardwareWiz->ClassImageList.ImageList,
                                      LVSIL_SMALL
                                      );
            }

            // Insert a column for the class list
            lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
            lvcCol.fmt = LVCFMT_LEFT;
            lvcCol.iSubItem = 0;
            ListView_InsertColumn(hwndClassList, 0, (LV_COLUMN FAR *)&lvcCol);

            //
            // Save the class before the user chooses one. This will be restored
            // in the event the install is cancelled.
            //

            HardwareWiz->SavedClassGuid = HardwareWiz->DeviceInfoData.ClassGuid;


           break;
        }


        case WM_DESTROY:
            break;

        case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

            //
            // This dialog is being activated.  Each time we are activated
            // we free up the current DeviceInfo and create a new one. Although
            // inefficient, its necessary to reenumerate the class list.
            //

            case PSN_SETACTIVE:

                PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);
                HardwareWiz->PrevPage = IDD_ADDDEVICE_SELECTCLASS;

                //
                // If we have DeviceInfo from going forward delete it.
                //

                if (HardwareWiz->ClassGuidSelected) {

                    SetupDiDeleteDeviceInfo(HardwareWiz->hDeviceInfo, &HardwareWiz->DeviceInfoData);
                    memset(&HardwareWiz->DeviceInfoData, 0, sizeof(SP_DEVINFO_DATA));
                }

                HardwareWiz->ClassGuidSelected = NULL;

                HdwBuildClassInfoList(HardwareWiz, 
                                      DIBCI_NOINSTALLCLASS
                                      );
                                     
                InitHDW_PickClassDlg(hwndClassList, HardwareWiz);
                break;

            case PSN_RESET:
                break;

            case PSN_WIZBACK:
                HardwareWiz->PrevPage = IDD_ADDDEVICE_SELECTCLASS;

                if (HardwareWiz->EnterInto == IDD_ADDDEVICE_SELECTCLASS) {
                
                    SetDlgMsgResult(hDlg, wMsg, HardwareWiz->EnterFrom);

                } else {
                
                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_ASKDETECT);
                }

               break;

            case PSN_WIZNEXT: {
           
                LPGUID  ClassGuidSelected;

                SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTDEVICE);

                if (IsEqualGUID(&HardwareWiz->lvClassGuidSelected, &GUID_NULL)) {
                
                    HardwareWiz->ClassGuidSelected = NULL;
                    break;
                }

                ClassGuidSelected = &HardwareWiz->lvClassGuidSelected;
                HardwareWiz->ClassGuidSelected = ClassGuidSelected;

                //
                // Add a new element to the DeviceInfo from the GUID and class name
                //
                HardwareWiz->DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

                if (!SetupDiGetClassDescription(HardwareWiz->ClassGuidSelected,
                                                HardwareWiz->ClassDescription,
                                                SIZECHARS(HardwareWiz->ClassDescription),
                                                NULL
                                                )
                    ||
                    !SetupDiClassNameFromGuid(HardwareWiz->ClassGuidSelected,
                                              HardwareWiz->ClassName,
                                              SIZECHARS(HardwareWiz->ClassName),
                                              NULL
                                              ))
                {
                    // unhandled error!
                    HardwareWiz->ClassGuidSelected = NULL;
                    break;
                }

                if (IsEqualGUID(HardwareWiz->ClassGuidSelected, &GUID_DEVCLASS_UNKNOWN)) {
                
                    ClassGuidSelected = (LPGUID)&GUID_NULL;
                }

                if (!SetupDiCreateDeviceInfo(HardwareWiz->hDeviceInfo,
                                             HardwareWiz->ClassName,
                                             ClassGuidSelected,
                                             NULL,
                                             hwndParentDlg,
                                             DICD_GENERATE_ID,
                                             &HardwareWiz->DeviceInfoData
                                             )
                    ||
                    !SetupDiSetSelectedDevice(HardwareWiz->hDeviceInfo,
                                              &HardwareWiz->DeviceInfoData
                                              ))
                {
                    HardwareWiz->ClassGuidSelected = NULL;
                    break;
                }
                
                break;
            }

            case NM_DBLCLK:
                PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);
                break;

            case LVN_ITEMCHANGED: {
            
                LPNM_LISTVIEW   lpnmlv = (LPNM_LISTVIEW)lParam;

                if ((lpnmlv->uChanged & LVIF_STATE)) {
                
                    if (lpnmlv->uNewState & LVIS_SELECTED) {
                    
                        HardwareWiz->lvClassGuidSelected = *((LPGUID)lpnmlv->lParam);

                    } else if (IsEqualGUID((LPGUID)lpnmlv->lParam, &HardwareWiz->lvClassGuidSelected)) {
                    
                        HardwareWiz->lvClassGuidSelected = GUID_NULL;
                    }
                }

                break;
            }
        }
        break;


       case WM_SYSCOLORCHANGE:
           _OnSysColorChange(hDlg, wParam, lParam);

           // Update the ImageList Background color
           ImageList_SetBkColor((HIMAGELIST)SendMessage(GetDlgItem(hDlg, IDC_HDW_PICKCLASS_CLASSLIST), LVM_GETIMAGELIST, (WPARAM)(LVSIL_SMALL), 0L),
                                   GetSysColor(COLOR_WINDOW));

           break;

       default:
           return(FALSE);
       }

    return(TRUE);
}

void
DestroyDynamicWizard(
    HWND hwndParentDlg,
    PHARDWAREWIZ HardwareWiz,
    BOOL WmDestroy
    )
{
    DWORD Pages;
    PSP_INSTALLWIZARD_DATA InstallWizard = &HardwareWiz->InstallDynaWiz;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;


    Pages = InstallWizard->NumDynamicPages;
    InstallWizard->NumDynamicPages = 0;

    if (InstallWizard->DynamicPageFlags & DYNAWIZ_FLAG_PAGESADDED) {

        if (!WmDestroy) {
        
            while (Pages--) {
            
                PropSheet_RemovePage(hwndParentDlg,
                                     (WPARAM)-1,
                                     InstallWizard->DynamicPages[Pages]
                                     );

                InstallWizard->DynamicPages[Pages] = NULL;
            }
        }


        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {
            DeviceInstallParams.Flags |= DI_CLASSINSTALLPARAMS;
            SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                          &HardwareWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }


        InstallWizard->DynamicPageFlags &= ~DYNAWIZ_FLAG_PAGESADDED;
        InstallWizard->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
        InstallWizard->ClassInstallHeader.InstallFunction = DIF_DESTROYWIZARDDATA;
        InstallWizard->hwndWizardDlg = hwndParentDlg;

        if (SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                         &HardwareWiz->DeviceInfoData,
                                         &InstallWizard->ClassInstallHeader,
                                         sizeof(SP_INSTALLWIZARD_DATA)
                                         ))
        {
            SetupDiCallClassInstaller(DIF_DESTROYWIZARDDATA,
                                      HardwareWiz->hDeviceInfo,
                                      &HardwareWiz->DeviceInfoData
                                      );
        }
    }

    if (!WmDestroy) {
    
    }
}



//
// The real select device page is in either setupapi or the class installer
// for dyanwiz. this page is a blank page which never shows its face
// to have a consistent place to jump to when the class is known.
//

INT_PTR CALLBACK
HdwSelectDeviceDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
       
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
        break;
    }

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE: {
            int PrevPage, BackUpPage;

            PrevPage = HardwareWiz->PrevPage;
            HardwareWiz->PrevPage = IDD_ADDDEVICE_SELECTDEVICE;
            BackUpPage = HardwareWiz->EnterInto == IDD_ADDDEVICE_SELECTDEVICE
                         ? HardwareWiz->EnterFrom : IDD_ADDDEVICE_SELECTCLASS;

            //
            // If we are coming from select class, driver update or Install NewDevice
            // then we are going forward.
            //
            if (!HardwareWiz->ClassGuidSelected || PrevPage == IDD_WIZARDEXT_PRESELECT) {
                //
                // going backwards, cleanup and backup
                //
                SetupDiSetSelectedDriver(HardwareWiz->hDeviceInfo,
                                         &HardwareWiz->DeviceInfoData,
                                         NULL
                                         );

                SetupDiDestroyDriverInfoList(HardwareWiz->hDeviceInfo,
                                             &HardwareWiz->DeviceInfoData,
                                             SPDIT_COMPATDRIVER
                                             );

                SetupDiDestroyDriverInfoList(HardwareWiz->hDeviceInfo,
                                             &HardwareWiz->DeviceInfoData,
                                             SPDIT_CLASSDRIVER
                                             );

                //
                // Cleanup the WizExtPreSelect Page
                //
                if (HardwareWiz->WizExtPreSelect.hPropSheet) {
                    PropSheet_RemovePage(GetParent(hDlg),
                                         (WPARAM)-1,
                                         HardwareWiz->WizExtPreSelect.hPropSheet
                                         );
                }

                SetDlgMsgResult(hDlg, wMsg, BackUpPage);
                break;
            }


            // Set the Cursor to an Hourglass
            SetCursor(LoadCursor(NULL, IDC_WAIT));

            HardwareWiz->WizExtPreSelect.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_PRESELECT,
                                                                       WizExtPreSelectDlgProc,
                                                                       HardwareWiz
                                                                       );

            if (HardwareWiz->WizExtPreSelect.hPropSheet) {
                PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtPreSelect.hPropSheet);
                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
            }
            else {
                SetDlgMsgResult(hDlg, wMsg, BackUpPage);
            }

            break;
        }
    }
    break;

    default:
       return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtPreSelectDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
    
        case WM_INITDIALOG: {
        
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
            break;
        }

        case WM_DESTROY:
            break;


        case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {
       
            case PSN_SETACTIVE:

                PrevPageId = HardwareWiz->PrevPage;
                HardwareWiz->PrevPage = IDD_WIZARDEXT_PRESELECT;

                if (PrevPageId == IDD_ADDDEVICE_SELECTDEVICE) {
              
                    //
                    // Moving forward on first page
                    //


                    //
                    // Set the Cursor to an Hourglass
                    //
                    SetCursor(LoadCursor(NULL, IDC_WAIT));

                    //
                    // Add ClassWizard Extension pages
                    //
                    AddClassWizExtPages(hwndParentDlg,
                                        HardwareWiz,
                                        &HardwareWiz->WizExtPreSelect.DeviceWizardData,
                                        DIF_NEWDEVICEWIZARD_PRESELECT
                                        );


                    //
                    // Add the end page, which is first of the select page set
                    //
                    HardwareWiz->WizExtSelect.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_SELECT,
                                                                            WizExtSelectDlgProc,
                                                                            HardwareWiz
                                                                            );

                    if (HardwareWiz->WizExtSelect.hPropSheet) {
                  
                        PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtSelect.hPropSheet);
                    }

                    PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

                } else {

                    //
                    // Moving backwards on first page
                    //

                    //
                    // Clean up proppages added.
                    //
                    if (HardwareWiz->WizExtSelect.hPropSheet) {
                    
                        PropSheet_RemovePage(hwndParentDlg,
                                             (WPARAM)-1,
                                             HardwareWiz->WizExtSelect.hPropSheet
                                             );
                                             
                        HardwareWiz->WizExtSelect.hPropSheet = NULL;
                    }

                    RemoveClassWizExtPages(hwndParentDlg,
                                           &HardwareWiz->WizExtPreSelect.DeviceWizardData
                                           );

                    //
                    // Jump back
                    //
                    SetDlgMsgResult(hDlg, wMsg, IDD_ADDDEVICE_SELECTDEVICE);
                }

                break;

            case PSN_WIZNEXT:
                SetDlgMsgResult(hDlg, wMsg, 0);
                break;
        }
        break;

        default:
            return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtSelectDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;
    PSP_INSTALLWIZARD_DATA  InstallWizard;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
    
        case WM_INITDIALOG: {

            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            HardwareWiz = (PHARDWAREWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)HardwareWiz);
            break;
        }

        case WM_DESTROY:
            DestroyDynamicWizard(hwndParentDlg, HardwareWiz, TRUE);
            break;

        case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
       
            case PSN_SETACTIVE:

                PrevPageId = HardwareWiz->PrevPage;
                HardwareWiz->PrevPage = IDD_WIZARDEXT_SELECT;

                if (PrevPageId == IDD_WIZARDEXT_PRESELECT) {
                
                    SP_DEVINSTALL_PARAMS  DeviceInstallParams;

                    //
                    // Moving forward on first page
                    //



                    //
                    // Prepare to call the class installer, for class install wizard pages.
                    // and Add in setup's SelectDevice wizard page.
                    //
                    InstallWizard = &HardwareWiz->InstallDynaWiz;
                    memset(InstallWizard, 0, sizeof(SP_INSTALLWIZARD_DATA));
                    InstallWizard->ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
                    InstallWizard->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
                    InstallWizard->hwndWizardDlg = GetParent(hDlg);

                    if (!SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                                      &HardwareWiz->DeviceInfoData,
                                                      &InstallWizard->ClassInstallHeader,
                                                      sizeof(SP_INSTALLWIZARD_DATA)
                                                      ))
                    {
                        SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                        break;
                    }


                    //
                    // Get current DeviceInstall parameters, and then set the fields
                    // we wanted changed from default
                    //
                    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                    if (!SetupDiGetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                                       &HardwareWiz->DeviceInfoData,
                                                       &DeviceInstallParams
                                                       ))
                    {
                        SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                        break;
                    }

                    DeviceInstallParams.Flags |= DI_SHOWCLASS | DI_SHOWOEM | DI_CLASSINSTALLPARAMS;

                    if (IsEqualGUID(HardwareWiz->ClassGuidSelected, &GUID_DEVCLASS_UNKNOWN)) {
                    
                        DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_FILTERCLASSES;

                   } else {
                   
                        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_FILTERCLASSES;
                   }

                    DeviceInstallParams.hwndParent = hwndParentDlg;

                    if (!SetupDiSetDeviceInstallParams(HardwareWiz->hDeviceInfo,
                                                      &HardwareWiz->DeviceInfoData,
                                                      &DeviceInstallParams
                                                      ))
                    {
                        SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                        break;
                    }


                    //
                    // Call the class installer for installwizard
                    // If no class install wizard pages default to run the standard
                    // setup wizard select device page.
                    //
                    if (SetupDiCallClassInstaller(DIF_INSTALLWIZARD,
                                                  HardwareWiz->hDeviceInfo,
                                                  &HardwareWiz->DeviceInfoData
                                                  )
                        &&
                        SetupDiGetClassInstallParams(HardwareWiz->hDeviceInfo,
                                                     &HardwareWiz->DeviceInfoData,
                                                     &InstallWizard->ClassInstallHeader,
                                                     sizeof(SP_INSTALLWIZARD_DATA),
                                                     NULL
                                                     )
                        &&
                        InstallWizard->NumDynamicPages)
                    {
                        DWORD   Pages;

                        InstallWizard->DynamicPageFlags |= DYNAWIZ_FLAG_PAGESADDED;
                        
                        for (Pages = 0; Pages < InstallWizard->NumDynamicPages; ++Pages ) {
                        
                            PropSheet_AddPage(hwndParentDlg, InstallWizard->DynamicPages[Pages]);
                        }

                        HardwareWiz->SelectDevicePage = SetupDiGetWizardPage(HardwareWiz->hDeviceInfo,
                                                                             &HardwareWiz->DeviceInfoData,
                                                                             InstallWizard,
                                                                             SPWPT_SELECTDEVICE,
                                                                             SPWP_USE_DEVINFO_DATA
                                                                             );

                        PropSheet_AddPage(hwndParentDlg, HardwareWiz->SelectDevicePage);

                    } else {

                        InstallWizard->DynamicPageFlags = 0;
                        HardwareWiz->SelectDevicePage = NULL;

                        if (!AddClassWizExtPages(hwndParentDlg,
                                                 HardwareWiz,
                                                 &HardwareWiz->WizExtSelect.DeviceWizardData,
                                                 DIF_NEWDEVICEWIZARD_SELECT
                                                 ))
                        {
                            HardwareWiz->SelectDevicePage = SetupDiGetWizardPage(HardwareWiz->hDeviceInfo,
                                                                                 &HardwareWiz->DeviceInfoData,
                                                                                 InstallWizard,
                                                                                 SPWPT_SELECTDEVICE,
                                                                                 SPWP_USE_DEVINFO_DATA
                                                                                 );

                            PropSheet_AddPage(hwndParentDlg, HardwareWiz->SelectDevicePage);
                        }
                    }

                    //
                    // Clear the class install parameters.
                    //
                    SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                                 &HardwareWiz->DeviceInfoData,
                                                 NULL,
                                                 0
                                                 );

                    //
                    // Add the end page, which is the preanalyze page.
                    //
                    HardwareWiz->WizExtPreAnalyze.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_PREANALYZE,
                                                                                WizExtPreAnalyzeDlgProc,
                                                                                HardwareWiz
                                                                                );

                    PropSheet_AddPage(hwndParentDlg, HardwareWiz->WizExtPreAnalyze.hPropSheet);

                    PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

                } else {
                
                    //
                    // Moving backwards on first page
                    //


                    //
                    // Clean up proppages added.
                    //
                    DestroyDynamicWizard(hwndParentDlg, HardwareWiz, FALSE);

                    if (HardwareWiz->SelectDevicePage) {
                    
                        PropSheet_RemovePage(hwndParentDlg,
                                             (WPARAM)-1,
                                             HardwareWiz->SelectDevicePage
                                             );
                                             
                        HardwareWiz->SelectDevicePage = NULL;
                    }


                    if (HardwareWiz->WizExtPreAnalyze.hPropSheet) {
                    
                        PropSheet_RemovePage(hwndParentDlg,
                                             (WPARAM)-1,
                                             HardwareWiz->WizExtPreAnalyze.hPropSheet
                                             );
                                             
                        HardwareWiz->WizExtPreAnalyze.hPropSheet = NULL;
                    }



                    RemoveClassWizExtPages(hwndParentDlg,
                                           &HardwareWiz->WizExtSelect.DeviceWizardData
                                           );


                    //
                    // Jump back
                    //
                    SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_PRESELECT);
                }

             break;

            case PSN_WIZNEXT:
                SetDlgMsgResult(hDlg, wMsg, 0);
                break;

        }
        break;

        default:
            return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDI_HDWWIZICON                  100
#define IDI_BLANK                       101
#define IDI_WARN                        102
#define IDH_HDWWIZAPPLET                104
#define IDA_SEARCHING                   105
#define IDB_WATERMARK                   106
#define IDB_BANNER                      107

#define IDD_ADDDEVICE_WELCOME           200
#define IDD_ADDDEVICE_PNPENUM           204
#define IDD_ADDDEVICE_PNPFINISH         205
#define IDD_ADDDEVICE_CONNECTED         206
#define IDD_ADDDEVICE_CONNECTED_FINISH  207
#define IDD_ADDDEVICE_PROBLIST          208
#define IDD_ADDDEVICE_PROBLIST_FINISH   209
#define IDD_ADDDEVICE_ASKDETECT         210
#define IDD_ADDDEVICE_DETECTION         211
#define IDD_ADDDEVICE_DETECTINSTALL     212
#define IDD_ADDDEVICE_DETECTREBOOT      213
#define IDD_ADDDEVICE_SELECTCLASS       214
#define IDD_ADDDEVICE_SELECTDEVICE      215
#define IDD_ADDDEVICE_ANALYZEDEV        216
#define IDD_ADDDEVICE_INSTALLDEV        217
#define IDD_ADDDEVICE_FINISH            218

#define IDD_WIZARDEXT_PRESELECT         250
#define IDD_WIZARDEXT_SELECT            IDD_DYNAWIZ_SELECTCLASS_PAGE
                   // setupapi contains IDD_DYNAWIZ_SELECTDEV_PAGE
#define IDD_WIZARDEXT_PREANALYZE        IDD_DYNAWIZ_ANALYZEDEV_PAGE
#define IDD_WIZARDEXT_PREANALYZE_END    251
#define IDD_WIZARDEXT_POSTANALYZE       252
#define IDD_WIZARDEXT_POSTANALYZE_END   253
#define IDD_WIZARDEXT_FINISHINSTALL     254
#define IDD_WIZARDEXT_FINISHINSTALL_END 255

#define IDD_INSTALLNEWDEVICE            258


#define IDC_HDWNAME                         300
#define IDC_HDWPROBLIST                     302
#define IDC_HDW_TEXT                        312
#define IDC_FOUNDPNP_LIST                   314
#define IDC_ADDDEVICE_ASKDETECT_AUTO        316
#define IDC_ADDDEVICE_ASKDETECT_SPECIFIC    317
#define IDC_HDW_DETWARN_PROGRESSTEXT        318
#define IDC_HDW_DETWARN_PROGRESSBAR         319
#define IDC_HDW_DETWARN_TOTALPROGRESSTEXT   320
#define IDC_HDW_DETWARN_TOTALPROGRESSBAR    321
#define IDC_HDW_INSTALLDET_LISTTITLE        322
#define IDC_HDW_INSTALLDET_LIST             323
#define IDC_HDW_PICKCLASS_HWTYPES           324
#define IDC_HDW_PICKCLASS_CLASSLIST         325
#define IDC_HDW_DESCRIPTION                 326
#define IDC_CLASSICON                       327
#define IDC_HDW_DISPLAYRESOURCE             328
#define IDC_PROBLEM_DESC                    436
#define IDC_ANIMATE_SEARCH                  438
#define IDC_BULLET_1                        500
#define IDC_BULLET_2                        501
#define IDC_WARNING_ICON                    502
#define IDC_CD_TEXT                         503
#define IDC_ADDDEVICE_CONNECTED_YES         504
#define IDC_ADDDEVICE_CONNECTED_NO          505
#define IDC_NEED_SHUTDOWN                   506

#define IDS_HDWWIZ                          1000
#define IDS_HDWWIZNAME                      1001
#define IDS_HDWWIZINFO                      1002
#define IDS_ADDDEVICE_PROBLIST              1005
#define IDS_UNKNOWN                         1012
#define IDS_UNKNOWNDEVICE                   1016
#define IDS_HDWUNINSTALL_NOPRIVILEGE        1017
#define IDS_DEVINSTALLED                    1019
#define IDS_ADDDEVICE_PNPENUMERATE          1020
#define IDS_ADDDEVICE_PNPENUM               1025
#define IDS_ADDDEVICE_ASKDETECT             1027
#define IDS_ADDDEVICE_DETECTION             1029
#define IDS_ADDDEVICE_DETECTINSTALL         1031
#define IDS_ADDDEVICE_DETECTINSTALL_NONE    1032
#define IDS_DETECTPROGRESS                  1035
#define IDS_DETECTCLASS                     1036
#define IDS_HDW_REBOOTDET                   1039
#define IDS_HDW_NOREBOOTDET                 1040
#define IDS_INSTALL_LEGACY_DEVICE           1041
#define IDS_UNINSTALL_LEGACY_DEVICE         1042
#define IDS_HDW_NONEDET1                    1043
#define IDS_HDW_INSTALLDET1                 1045
#define IDS_HDW_DUPLICATE1                  1048
#define IDS_HDW_ANALYZEERR1                 1053
#define IDS_HDW_STDCFG                      1056
#define IDS_ADDNEWDEVICE                    1058
#define IDS_HDW_ERRORFIN1                   1059
#define IDS_HDW_ERRORFIN2                   1060
#define IDS_ADDDEVICE_SELECTCLASS           1061
#define IDS_ADDDEVICE_ANALYZEDEV            1065
#define IDS_HDW_RUNNING_TITLE               1067
#define IDS_HDW_RUNNING_MSG                 1068
#define IDS_HDW_NORMAL_LEGACY_FINISH1       1071
#define IDS_HDW_NORMALFINISH1               1073
#define IDS_INSTALL_PROBLEM                 1074
#define IDS_NEEDREBOOT                      1076
#define IDS_ADDDEVICE_INSTALLDEV            1077
#define IDS_HDW_NONEDEVICES                 1081
#define IDS_ADDDEVICE_PNPENUMERROR          1098
#define IDS_INSTALLNEWDEVICE                1100
#define IDS_NEED_FORCED_CONFIG              1102
#define IDS_SHOWALLDEVICES                  1103
#define IDC_ANALYZE_INSTALL_TEXT            1104
#define IDC_ANALYZE_EXIT_TEXT               1105
#define IDS_NEW_SETRESTOREPOINT             1110
#define IDS_WILL_BE_REMOVED                 1111
#define IDS_NEED_RESTART                    1112
#define IDS_ADDDEVICE_CONNECTED             1113
#define IDS_NO_PERMISSION_SHUTDOWN          1114
#define IDS_SHUTDOWN                        1115

#define IDC_STATIC                          -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\sthread.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       sthread.c
//
//--------------------------------------------------------------------------

#include "hdwwiz.h"

DWORD
SearchDriversThread(
    PVOID pvHardwareWiz
    )
{
    PHARDWAREWIZ HardwareWiz = (PHARDWAREWIZ) pvHardwareWiz;
    PSEARCHTHREAD SearchThread;
    DWORD Error = ERROR_SUCCESS;
    DWORD WaitResult;
    UINT Msg = 0;
    WPARAM wParam = 0;
    LPARAM lParam = 0;
    DWORD Delay;

    try {

        if (!HardwareWiz || !HardwareWiz->SearchThread) {
        
            return ERROR_INVALID_PARAMETER;
        }
        
        SearchThread = HardwareWiz->SearchThread;

        for (;;) {

            SetEvent(SearchThread->ReadyEvent);

waitloop:            

            if ((WaitResult = WaitForSingleObject(SearchThread->RequestEvent, 5000)) == WAIT_FAILED) {

                Error = GetLastError();
                break;
            }

            else if (WaitResult == WAIT_TIMEOUT) {

                goto waitloop;
            }


            if (SearchThread->Function == SEARCH_NULL) {
            
                Msg = 0;
                Delay = 0;
            }
            
            else if (SearchThread->Function == SEARCH_EXIT) {
            
                break;
            }
            
            else if (SearchThread->Function == SEARCH_DELAY) {
            
                Delay = SearchThread->Param;
                Msg = WUM_DELAYTIMER;
                wParam = TRUE;
                lParam = ERROR_SUCCESS;
            }
            
            else if (SearchThread->Function == SEARCH_DETECT) {
            
                Delay = 0;
                Msg = WUM_DETECT;
                wParam = TRUE;
                lParam = ERROR_SUCCESS;

                try {
                
                   BuildDeviceDetection(SearchThread->hDlg, HardwareWiz);
                }
                
                except (EXCEPTION_EXECUTE_HANDLER) {
                
                   lParam = GetExceptionCode();
                }
            }

            else if (SearchThread->Function == SEARCH_PNPENUM) {
            
                Delay = 0;
                Msg = WUM_PNPENUMERATE;
                wParam = TRUE;
                lParam = ERROR_SUCCESS;

                try {
                
                   Delay = PNPEnumerate(HardwareWiz);
                }

                except (EXCEPTION_EXECUTE_HANDLER) {
                
                   lParam = GetExceptionCode();
                }
            }

            else {
        
                Error = ERROR_INVALID_FUNCTION;
                break;
            }

            SearchThread->Function = SEARCH_NULL;

            WaitForSingleObject(SearchThread->CancelEvent, Delay);

            if (Msg && SearchThread->hDlg) {
        
                PostMessage(SearchThread->hDlg, Msg, wParam, lParam);
            }
        }
    }
   
    except(HdwUnhandledExceptionFilter(GetExceptionInformation())) {

        Error = RtlNtStatusToDosError(GetExceptionCode());
    }

    return Error;
}

BOOL
SearchThreadRequest(
   PSEARCHTHREAD SearchThread,
   HWND    hDlg,
   UCHAR   Function,
   ULONG   Param
   )
{
    MSG Msg;
    DWORD WaitReturn;

    while ((WaitReturn = MsgWaitForMultipleObjects(1,
                                                   &SearchThread->ReadyEvent,
                                                   FALSE,
                                                   INFINITE,
                                                   QS_ALLEVENTS
                                                   ))
            == WAIT_OBJECT_0 + 1)
    {

        while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE)) {
      
            if (!IsDialogMessage(hDlg,&Msg)) {
           
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
            }
        }
    }


    if (WaitReturn == WAIT_OBJECT_0) {
    
        ResetEvent(SearchThread->CancelEvent);
        SearchThread->CancelRequest = FALSE;
        SearchThread->hDlg = hDlg;
        SearchThread->Function = Function;
        SearchThread->Param = Param;

        SetEvent(SearchThread->RequestEvent);
        return TRUE;
    }

    return FALSE;
}



VOID
CancelSearchRequest(
    PHARDWAREWIZ HardwareWiz
    )
{
    PSEARCHTHREAD SearchThread;

    SearchThread = HardwareWiz->SearchThread;

    if (SearchThread->hDlg) {

        //
        // Cancel drivers search, and then request a NULL operation
        // to get in sync with the search thread.
        //
        if (SearchThread->Function == SEARCH_DRIVERS) {

            SetupDiCancelDriverInfoSearch(HardwareWiz->hDeviceInfo);
        }

        SearchThread->CancelRequest = TRUE;
        SetEvent(SearchThread->CancelEvent);
        SearchThreadRequest(SearchThread,
                            NULL,
                            SEARCH_NULL,
                            0
                            );
        }
}

LONG
CreateSearchThread(
   PHARDWAREWIZ HardwareWiz
   )
{
    PSEARCHTHREAD SearchThread = HardwareWiz->SearchThread;
    DWORD  ThreadId;

    SearchThread->hDlg      = NULL;
    SearchThread->Function  = 0;

    if (((SearchThread->RequestEvent = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL) ||
        ((SearchThread->ReadyEvent   = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL) ||
        ((SearchThread->CancelEvent  = CreateEvent(NULL, FALSE, FALSE, NULL)) == NULL) ||
        ((SearchThread->hThread      = CreateThread(NULL,
                                                    0,
                                                    SearchDriversThread,
                                                    HardwareWiz,
                                                    0,
                                                    &ThreadId
                                                    )) == NULL))
    {

        if (SearchThread->RequestEvent) {
        
            CloseHandle(SearchThread->RequestEvent);
        }

        if (SearchThread->ReadyEvent) {
        
            CloseHandle(SearchThread->ReadyEvent);
        }

        if (SearchThread->CancelEvent) {
        
            CloseHandle(SearchThread->CancelEvent);
        }

        return GetLastError();
    }

    return ERROR_SUCCESS;
}

void
DestroySearchThread(
   PSEARCHTHREAD SearchThread
   )
{
    //
    // Signal search thread to exit,
    //
    if (SearchThread->hThread) {
    
        DWORD ExitCode;

        if (GetExitCodeThread(SearchThread->hThread, &ExitCode) &&
            ExitCode == STILL_ACTIVE) {
            
            SearchThreadRequest(SearchThread, NULL, SEARCH_EXIT, 0);
        }

        WaitForSingleObject(SearchThread->hThread, INFINITE);
        CloseHandle(SearchThread->hThread);
        SearchThread->hThread = NULL;
    }


    if (SearchThread->ReadyEvent) {
    
        CloseHandle(SearchThread->ReadyEvent);
        SearchThread->ReadyEvent = NULL;
    }

    if (SearchThread->RequestEvent) {
    
        CloseHandle(SearchThread->RequestEvent);
        SearchThread->RequestEvent = NULL;
    }

    if (SearchThread->CancelEvent) {
    
        CloseHandle(SearchThread->CancelEvent);
        SearchThread->CancelEvent = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hdwwiz\miscutil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       miscutil.c
//
//--------------------------------------------------------------------------

#include "HdwWiz.h"


/* ----------------------------------------------------------------------
 * SetDlgText - Set Dialog Text Field
 *
 * Concatenates a number of string resources and does a SetWindowText()
 * for a dialog text control.
 *
 * Parameters:
 *
 *  hDlg         - Dialog handle
 *  iControl     - Dialog control ID to receive text
 *  nStartString - ID of first string resource to concatenate
 *  nEndString   - ID of last string resource to concatenate
 *
 *  Note: the string IDs must be consecutive.
 */

void
SetDlgText(HWND hDlg, int iControl, int nStartString, int nEndString)
{
    int     iX;
    TCHAR   szText[MAX_PATH*4];

    szText[0] = '\0';
    for (iX = nStartString; iX<= nEndString; iX++) {

         LoadString(hHdwWiz,
                    iX,
                    szText + lstrlen(szText),
                    SIZECHARS(szText) - lstrlen(szText)
                    );
    }

    if (iControl) {

        SetDlgItemText(hDlg, iControl, szText);

    } else {

        SetWindowText(hDlg, szText);
    }
}

VOID
HdwWizPropagateMessage(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    while ((hWnd = GetWindow(hWnd, GW_CHILD)) != NULL) {

        SendMessage(hWnd, uMessage, wParam, lParam);
    }
}

LONG
HdwBuildClassInfoList(
    PHARDWAREWIZ HardwareWiz,
    DWORD ClassListFlags
    )
{
    LONG Error;

    while (!SetupDiBuildClassInfoListEx(ClassListFlags,
                                        HardwareWiz->ClassGuidList,
                                        HardwareWiz->ClassGuidSize,
                                        &HardwareWiz->ClassGuidNum,
                                        NULL,
                                        NULL
                                        )) {

        Error = GetLastError();

        if (HardwareWiz->ClassGuidList) {

            LocalFree(HardwareWiz->ClassGuidList);
            HardwareWiz->ClassGuidList = NULL;
        }

        if (Error == ERROR_INSUFFICIENT_BUFFER &&
            HardwareWiz->ClassGuidNum > HardwareWiz->ClassGuidSize) {

            HardwareWiz->ClassGuidList = LocalAlloc(LPTR, HardwareWiz->ClassGuidNum*sizeof(GUID));

            if (!HardwareWiz->ClassGuidList) {

                HardwareWiz->ClassGuidSize = 0;
                HardwareWiz->ClassGuidNum = 0;
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            HardwareWiz->ClassGuidSize = HardwareWiz->ClassGuidNum;

        } else {

            if (HardwareWiz->ClassGuidList) {

                LocalFree(HardwareWiz->ClassGuidList);
            }

            HardwareWiz->ClassGuidSize = 0;
            HardwareWiz->ClassGuidNum = 0;
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

int
HdwMessageBox(
   HWND hWnd,
   LPTSTR szIdText,
   LPTSTR szIdCaption,
   UINT Type
   )
{
    TCHAR szText[MAX_PATH];
    TCHAR szCaption[MAX_PATH];

    if (!HIWORD(szIdText)) {
        *szText = TEXT('\0');
        LoadString(hHdwWiz, LOWORD(szIdText), szText, MAX_PATH);
        szIdText = szText;
    }

    if (!HIWORD(szIdCaption)) {
        *szCaption = TEXT('\0');
        LoadString(hHdwWiz, LOWORD(szIdCaption), szCaption, MAX_PATH);
        szIdCaption = szCaption;
    }

    return MessageBox(hWnd, szIdText, szIdCaption, Type);
}

LONG
HdwUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionPointers
    )
{
    LONG lRet;
    BOOL BeingDebugged;

    lRet = UnhandledExceptionFilter(ExceptionPointers);

    BeingDebugged = IsDebuggerPresent();

    //
    // Normal code path is to handle the exception.
    // However, if a debugger is present, and the system's unhandled
    // exception filter returns continue search, we let it go
    // thru to allow the debugger a chance at it.
    //
    if (lRet == EXCEPTION_CONTINUE_SEARCH && !BeingDebugged) {
        lRet = EXCEPTION_EXECUTE_HANDLER;
    }

    return lRet;
}

BOOL
NoPrivilegeWarning(
   HWND hWnd
   )
/*++

    This function checks to see if the user is an Adminstrator
    
    If the user is NOT an Administrator then a warning is displayed telling
    them that they have insufficient privileges to install hardware on
    this machine.                                            
                                            
    NOTE: In order for a user to install a driver then have to have the
    SE_LOAD_DRIVER_NAME privilege, as well as privilege to write to the registry
    and copy files into the system32\drivers directory
    
Arguments

    hWnd - Parent window handle

Return Value:
    TRUE if the user is NOT an adminstrator on this machine and
    FALSE if the user is an administrator on this machine.

--*/
{
    TCHAR szMsg[MAX_PATH];
    TCHAR szCaption[MAX_PATH];

    if (!pSetupIsUserAdmin()) {

        if (LoadString(hHdwWiz,
                       IDS_HDWUNINSTALL_NOPRIVILEGE,
                       szMsg,
                       SIZECHARS(szMsg)) &&
            LoadString(hHdwWiz,
                       IDS_HDWWIZNAME,
                       szCaption,
                       SIZECHARS(szCaption)))
        {
            MessageBox(hWnd, szMsg, szCaption, MB_OK | MB_ICONEXCLAMATION);
        }

        return TRUE;
    }

    return FALSE;
}

VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hChildWnd;

    hChildWnd = GetWindow(hWnd, GW_CHILD);
    while (hChildWnd != NULL) {
        SendMessage(hChildWnd, WM_SYSCOLORCHANGE, wParam, lParam);
        hChildWnd = GetWindow(hChildWnd, GW_HWNDNEXT);
    }
}

void
LoadText(
    PTCHAR szText,
    int SizeText,
    int nStartString,
    int nEndString
    )
{
    int     iX;

    for (iX = nStartString; iX<= nEndString; iX++) {

        LoadString(hHdwWiz,
                   iX,
                   szText + lstrlen(szText),
                   SizeText - lstrlen(szText)
                   );
    }

    return;
}


/*  InstallFailedWarning
 *
 *  Displays device install failed warning in a message box.  For use
 *  when device registration fails.
 *
 */
void
InstallFailedWarning(
    HWND    hDlg,
    PHARDWAREWIZ HardwareWiz
    )
{
    int len;
    TCHAR szMsg[MAX_MESSAGE_STRING];
    TCHAR szTitle[MAX_MESSAGE_TITLE];
    PTCHAR ErrorMsg;

    LoadString(hHdwWiz,
               IDS_ADDNEWDEVICE,
               szTitle,
               SIZECHARS(szTitle)
               );

    if ((len = LoadString(hHdwWiz, IDS_HDW_ERRORFIN1, szMsg, SIZECHARS(szMsg))) != 0) {

        LoadString(hHdwWiz, IDS_HDW_ERRORFIN2, szMsg+len, SIZECHARS(szMsg)-len);
    }

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                      NULL,
                      HRESULT_FROM_SETUPAPI(HardwareWiz->LastError),
                      0,
                      (LPTSTR)&ErrorMsg,
                      0,
                      NULL
                      ))
    {
        StringCchCat(szMsg, SIZECHARS(szMsg), TEXT("\n\n"));

        if ((lstrlen(szMsg) + lstrlen(ErrorMsg)) < SIZECHARS(szMsg)) {

            StringCchCat(szMsg, SIZECHARS(szMsg), ErrorMsg);
        }

        LocalFree(ErrorMsg);
    }

    MessageBox(hDlg, szMsg, szTitle, MB_OK | MB_TASKMODAL | MB_ICONEXCLAMATION);
}


void
SetDriverDescription(
    HWND hDlg,
    int iControl,
    PHARDWAREWIZ HardwareWiz
    )
{
    PTCHAR FriendlyName;
    SP_DRVINFO_DATA DriverInfoData;

    //
    // If there is a selected driver use its driver description,
    // since this is what the user is going to install.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(HardwareWiz->hDeviceInfo,
                                 &HardwareWiz->DeviceInfoData,
                                 &DriverInfoData
                                 )
        &&
        *DriverInfoData.Description) {

        StringCchCopy(HardwareWiz->DriverDescription, 
                      SIZECHARS(HardwareWiz->DriverDescription), 
                      DriverInfoData.Description);

        SetDlgItemText(hDlg, iControl, HardwareWiz->DriverDescription);
        return;
    }


    FriendlyName = BuildFriendlyName(HardwareWiz->DeviceInfoData.DevInst);
    if (FriendlyName) {

        SetDlgItemText(hDlg, iControl, FriendlyName);
        LocalFree(FriendlyName);
        return;
    }

    SetDlgItemText(hDlg, iControl, szUnknown);

    return;
}

HPROPSHEETPAGE
CreateWizExtPage(
   int PageResourceId,
   DLGPROC pfnDlgProc,
   PHARDWAREWIZ HardwareWiz
   )
{
    PROPSHEETPAGE    psp;

    memset(&psp, 0, sizeof(psp));
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = hHdwWiz;
    psp.lParam = (LPARAM)HardwareWiz;
    psp.pszTemplate = MAKEINTRESOURCE(PageResourceId);
    psp.pfnDlgProc = pfnDlgProc;

    return CreatePropertySheetPage(&psp);
}

BOOL
AddClassWizExtPages(
   HWND hwndParentDlg,
   PHARDWAREWIZ HardwareWiz,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData,
   DI_FUNCTION InstallFunction
   )
{
    DWORD NumPages;
    BOOL bRet = FALSE;

    memset(DeviceWizardData, 0, sizeof(SP_NEWDEVICEWIZARD_DATA));
    DeviceWizardData->ClassInstallHeader.InstallFunction = InstallFunction;
    DeviceWizardData->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    DeviceWizardData->hwndWizardDlg = hwndParentDlg;

    if (SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                     &HardwareWiz->DeviceInfoData,
                                     &DeviceWizardData->ClassInstallHeader,
                                     sizeof(SP_NEWDEVICEWIZARD_DATA)
                                     )
        &&

        (SetupDiCallClassInstaller(InstallFunction,
                                  HardwareWiz->hDeviceInfo,
                                  &HardwareWiz->DeviceInfoData
                                  )

            ||

            (ERROR_DI_DO_DEFAULT == GetLastError()))

        &&
        SetupDiGetClassInstallParams(HardwareWiz->hDeviceInfo,
                                     &HardwareWiz->DeviceInfoData,
                                     &DeviceWizardData->ClassInstallHeader,
                                     sizeof(SP_NEWDEVICEWIZARD_DATA),
                                     NULL
                                     )
        &&
        DeviceWizardData->NumDynamicPages)
    {
        NumPages = 0;
        while (NumPages < DeviceWizardData->NumDynamicPages) {

           PropSheet_AddPage(hwndParentDlg, DeviceWizardData->DynamicPages[NumPages++]);
        }

        bRet = TRUE;
    }

    //
    // Clear the class install parameters.
    //
    SetupDiSetClassInstallParams(HardwareWiz->hDeviceInfo,
                                 &HardwareWiz->DeviceInfoData,
                                 NULL,
                                 0
                                 );

    return bRet;
}

void
RemoveClassWizExtPages(
   HWND hwndParentDlg,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData
   )
{
    DWORD NumPages;

    NumPages = DeviceWizardData->NumDynamicPages;
    while (NumPages--) {

       PropSheet_RemovePage(hwndParentDlg,
                            (WPARAM)-1,
                            DeviceWizardData->DynamicPages[NumPages]
                            );
    }

    memset(DeviceWizardData, 0, sizeof(SP_NEWDEVICEWIZARD_DATA));

    return;
}

BOOL
IsDeviceHidden(
    PSP_DEVINFO_DATA DeviceInfoData
    )
{
    BOOL bHidden = FALSE;
    ULONG DevNodeStatus, DevNodeProblem;
    HKEY hKeyClass;

    //
    // If the DN_NO_SHOW_IN_DM status bit is set
    // then we should hide this device.
    //
    if ((CM_Get_DevNode_Status(&DevNodeStatus,
                              &DevNodeProblem,
                              DeviceInfoData->DevInst,
                              0) == CR_SUCCESS) &&
        (DevNodeStatus & DN_NO_SHOW_IN_DM)) {

        bHidden = TRUE;
        goto HiddenDone;
    }

    //
    // If the devices class has the NoDisplayClass value then
    // don't display this device.
    //
    hKeyClass = SetupDiOpenClassRegKeyEx(&DeviceInfoData->ClassGuid,
                                         KEY_READ,
                                         DIOCR_INSTALLER,
                                         NULL,
                                         NULL);

    if (hKeyClass != INVALID_HANDLE_VALUE) {

        if (RegQueryValueEx(hKeyClass, REGSTR_VAL_NODISPLAYCLASS, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

            bHidden = TRUE;
        }

        RegCloseKey(hKeyClass);
    }

HiddenDone:
    return bHidden;
}

DWORD 
SetPrivilegeAttribute(
    LPCTSTR PrivilegeName, 
    DWORD NewPrivilegeAttribute, 
    DWORD *OldPrivilegeAttribute
    )
/*++

    sets the security attributes for a given privilege.

Arguments:

    PrivilegeName - Name of the privilege we are manipulating.

    NewPrivilegeAttribute - The new attribute value to use.

    OldPrivilegeAttribute - Pointer to receive the old privilege value. OPTIONAL

Return value:

    NO_ERROR or WIN32 error.

--*/
{
    LUID             PrivilegeValue;
    TOKEN_PRIVILEGES TokenPrivileges, OldTokenPrivileges;
    DWORD            ReturnLength;
    HANDLE           TokenHandle;

    //
    // First, find out the LUID Value of the privilege
    //
    if (!LookupPrivilegeValue(NULL, PrivilegeName, &PrivilegeValue)) 
    {
        return GetLastError();
    }

    //
    // Get the token handle
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &TokenHandle)) 
    {
        return GetLastError();
    }

    //
    // Set up the privilege set we will need
    //
    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = PrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = NewPrivilegeAttribute;

    ReturnLength = sizeof( TOKEN_PRIVILEGES );
    if (!AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                &OldTokenPrivileges,
                &ReturnLength
                )) 
    {
        CloseHandle(TokenHandle);
        return GetLastError();
    }
    else 
    {
        if (OldPrivilegeAttribute != NULL) 
        {
            *OldPrivilegeAttribute = OldTokenPrivileges.Privileges[0].Attributes;
        }
        CloseHandle(TokenHandle);
        return NO_ERROR;
    }
}

BOOL
ShutdownMachine(
    HWND hWnd
    )
{
    BOOL fOk;
    DWORD dwExitWinCode = EWX_SHUTDOWN;
    DWORD OldState;
    DWORD dwError;

    if (IsPwrShutdownAllowed()) {
        dwExitWinCode |= EWX_POWEROFF;
    }

    dwError = SetPrivilegeAttribute(SE_SHUTDOWN_NAME, SE_PRIVILEGE_ENABLED, &OldState);

    if (GetKeyState(VK_CONTROL) < 0) {
        dwExitWinCode |= EWX_FORCE;
    }

    fOk = ExitWindowsEx(dwExitWinCode, REASON_PLANNED_FLAG | REASON_HWINSTALL);

    //
    // If we were able to set the privilege, then reset it.
    //
    if (dwError == ERROR_SUCCESS) {
        SetPrivilegeAttribute(SE_SHUTDOWN_NAME, OldState, NULL);
    }
    else
    {
        //
        // Otherwise, if we failed, then it must have been some
        // security stuff.
        //
        if (!fOk)
        {
            TCHAR Title[MAX_PATH], Message[MAX_PATH];

            if (LoadString(hHdwWiz, IDS_NO_PERMISSION_SHUTDOWN, Message, SIZECHARS(Message)) &&
                LoadString(hHdwWiz, IDS_SHUTDOWN, Title, SIZECHARS(Title))) {

                MessageBox(hWnd, Message, Title, MB_OK | MB_ICONSTOP);
            }
        }
    }

    return fOk;
}

int
DeviceProperties(
                 HWND hWnd,
                 DEVNODE DevNode,
                 ULONG Flags
                 )
{
    TCHAR DeviceID[MAX_DEVICE_ID_LEN];
    PDEVICEPROPERTIESEX pDevicePropertiesEx = NULL;    
    int iRet = 0;

    if (!hDevMgr) {
        return 0;
    }

    pDevicePropertiesEx = (PDEVICEPROPERTIESEX)GetProcAddress(hDevMgr, "DevicePropertiesExW");

    if (!pDevicePropertiesEx) {
        return 0;
    }

    if (CM_Get_Device_ID(DevNode,
                         DeviceID,
                         SIZECHARS(DeviceID),
                         0
                         ) == CR_SUCCESS) {
        
        iRet = pDevicePropertiesEx(hWnd,            
                                   NULL,
                                   (LPCSTR)DeviceID,
                                   Flags,
                                   FALSE);
    }

    return iRet;
}

#if DBG
//
// Debugging aids
//
void
Trace(
    LPCTSTR format,
    ...
    )
{
    // according to wsprintf specification, the max buffer size is
    // 1024
    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    StringCchVPrintf(Buffer, SIZECHARS(Buffer), format, arglist);
    va_end(arglist);
    OutputDebugString(TEXT("HDWWIZ: "));
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\blkdrv.cpp ===
// blkdrv.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for blkdrv.idl by adding the following 
//      files to the Outputs.
//          blkdrv_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f blkdrvps.mk in the project directory.
#include "stdafx.h"
#include <commctrl.h>
#include "resource.h"
#include <initguid.h>
#include "blkdrv.h"
#include "dlldatax.h"

#include "blkdrv_i.c"
#include "Driver.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_BlockedDrivers, CBlockedDrivers)
END_OBJECT_MAP()

HMODULE hHotPlug;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;

    hHotPlug = hInstance;

#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        InitCommonControls();
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\devicecol.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File: devicecol.cpp
//
//  Description: This file handles device collections for the hotplug applet.
//
//--------------------------------------------------------------------------

#include "hotplug.h"

BOOL
DeviceCollectionPrepImageList(
    IN  PDEVICE_COLLECTION  DeviceCollection
    );

VOID
DeviceCollectionSwapFakeDockForRealDock(
    IN      PDEVICE_COLLECTION  DeviceCollection,
    IN      PTSTR               InstancePath,
    IN OUT  DEVNODE            *DeviceNode
    );

BOOL
DeviceCollectionBuildFromPipe(
    IN  HANDLE                  ReadPipe,
    IN  COLLECTION_TYPE         CollectionType,
    OUT PDEVICE_COLLECTION      DeviceCollection
    )
{
    PTSTR deviceIds;
    PTSTR instancePath;
    BOOL bDockDeviceInList;
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    DEVNODE deviceNode;
    DWORD capabilities, configFlags, cbSize;
    ULONG bytesReadFromPipe;
    ULONG numDevices, deviceIdsLength;
    BOOL success;
    CONFIGRET configRet;
    TCHAR classGuidString[MAX_GUID_STRING_LEN];
    GUID classGuid;

    //
    // Preinit.
    //
    success = FALSE;
    deviceIds = NULL;
    deviceIdsLength = 0;
    bDockDeviceInList = FALSE;
    numDevices = 0;

    DeviceCollection->NumDevices = 0;
    DeviceCollection->DockInList = FALSE;
    DeviceCollection->ClassImageList.cbSize = 0;
    InitializeListHead(&DeviceCollection->DeviceListHead);

    //
    // Our callers shouldn't have to handle an internal failure in any of this.
    //
    __try {

        //
        // Read the first ULONG from the pipe, this is the length of all the
        // Device Ids.
        //
        if (!ReadFile(ReadPipe,
                      (LPVOID)&deviceIdsLength,
                      sizeof(ULONG),
                      &bytesReadFromPipe,
                      NULL) ||
            (deviceIdsLength == 0)) {

            goto clean0;
        }

        //
        // Allocate space to hold the DeviceIds
        //
        deviceIds = (PTSTR)LocalAlloc(LPTR, deviceIdsLength);

        if (!deviceIds) {

            goto clean0;
        }

        //
        // Read all of the DeviceIds from the pipe at once
        //
        if (!ReadFile(ReadPipe,
                      (LPVOID)deviceIds,
                      deviceIdsLength,
                      &bytesReadFromPipe,
                      NULL)) {

            goto clean0;
        }

        //
        // Enumerate through the multi-sz list of Device Ids.
        //
        for (instancePath = deviceIds;
             *instancePath;
             instancePath += lstrlen(instancePath) + 1) {

            deviceEntry = (PDEVICE_COLLECTION_ENTRY)LocalAlloc(
                LPTR,
                sizeof(DEVICE_COLLECTION_ENTRY)
                );

            if (!deviceEntry) {
                goto clean0;
            }

            //
            // If we are building a blocked driver list, just put the driver
            // GUID in the DeviceInstanceId field and continue to the next.
            //
            if (CollectionType == CT_BLOCKED_DRIVER_NOTIFICATION) {
                numDevices++;
                if (SUCCEEDED(StringCchCopy(deviceEntry->DeviceInstanceId,
                                            SIZECHARS(deviceEntry->DeviceInstanceId),
                                            instancePath)) &&
                    (pSetupGuidFromString(instancePath, &(deviceEntry->ClassGuid)) == ERROR_SUCCESS)) {
                
                    InsertTailList(
                        &DeviceCollection->DeviceListHead,
                        &deviceEntry->Link
                        );
                } else {
                    //
                    // Something went wrong, so free the DEVICE_COLLECTION_ENTRY
                    // node.
                    //
                    LocalFree(deviceEntry);
                    deviceEntry = NULL;
                }
            
            } else {
    
                capabilities = 0;
                classGuid = GUID_NULL;
                if (CM_Locate_DevNode(&deviceNode,
                                      instancePath,
                                      (CollectionType == CT_CHILD_WITH_INVALID_ID_NOTIFICATION)
                                      ? 0
                                      : CM_LOCATE_DEVNODE_PHANTOM) == CR_SUCCESS) {
    
                    cbSize = sizeof(DWORD);
    
                    configRet = CM_Get_DevNode_Registry_Property_Ex(
                        deviceNode,
                        CM_DRP_CAPABILITIES,
                        NULL,
                        (PVOID)&capabilities,
                        &cbSize,
                        0,
                        NULL
                        );
    
                    if ((configRet == CR_SUCCESS) &&
                        (capabilities & CM_DEVCAP_DOCKDEVICE)) {
    
                        DeviceCollectionSwapFakeDockForRealDock(
                            DeviceCollection,
                            instancePath,
                            &deviceNode
                            );
    
                        bDockDeviceInList = TRUE;
                    }
    
                    if (CollectionType == CT_SURPRISE_REMOVAL_WARNING) {
    
                        //
                        // For surprise removal, we are careful to ignore any devices
                        // with the Suppress-Surprise flag set.
                        //
                        cbSize = sizeof(DWORD);
                        configRet = CM_Get_DevNode_Registry_Property_Ex(
                            deviceNode,
                            CM_DRP_CONFIGFLAGS,
                            NULL,
                            (PVOID)&configFlags,
                            &cbSize,
                            0,
                            NULL
                            );
    
                        if ((configRet == CR_SUCCESS) &&
                            (configFlags & CONFIGFLAG_SUPPRESS_SURPRISE)) {
    
                            continue;
                        }
                    }
    
                    //
                    // Get the class GUID string for the device
                    //
                    cbSize = sizeof(classGuidString);
    
                    if ((CM_Get_DevNode_Registry_Property(deviceNode,
                                                          CM_DRP_CLASSGUID,
                                                          NULL,
                                                          (PVOID)classGuidString,
                                                          &cbSize,
                                                          0) != CR_SUCCESS) ||
                        (pSetupGuidFromString(classGuidString, &classGuid) != ERROR_SUCCESS)) {

                        classGuid = GUID_NULL;
                    }
                }
    
                numDevices++;
                StringCchCopy(deviceEntry->DeviceInstanceId,
                              SIZECHARS(deviceEntry->DeviceInstanceId),
                              instancePath);
    
                deviceEntry->DeviceFriendlyName = BuildFriendlyName(deviceNode);
                deviceEntry->Capabilities = capabilities;
                deviceEntry->ClassGuid = classGuid;
    
                InsertTailList(
                    &DeviceCollection->DeviceListHead,
                    &deviceEntry->Link
                    );
            }
        }

        DeviceCollection->NumDevices = numDevices;
        DeviceCollection->DockInList = bDockDeviceInList;
        DeviceCollectionPrepImageList(DeviceCollection);
        success = TRUE;

clean0:
        ;

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        ASSERT(success == FALSE);
        ASSERT(0);
    }

    if (deviceIds) {

        LocalFree(deviceIds);
    }

    if (!success) {

        DeviceCollectionDestroy(DeviceCollection);
    }

    return success;
}


VOID
DeviceCollectionDestroy(
    IN  PDEVICE_COLLECTION  DeviceCollection
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PLIST_ENTRY listEntry;

    while(!IsListEmpty(&DeviceCollection->DeviceListHead)) {

        listEntry = RemoveHeadList(&DeviceCollection->DeviceListHead);

        deviceEntry = CONTAINING_RECORD(listEntry,
                                        DEVICE_COLLECTION_ENTRY,
                                        Link);

        if (deviceEntry->DeviceFriendlyName) {

            LocalFree(deviceEntry->DeviceFriendlyName);
        }

        LocalFree(deviceEntry);
    }

    if (DeviceCollection->ClassImageList.cbSize) {

        SetupDiDestroyClassImageList(&DeviceCollection->ClassImageList);
        DeviceCollection->ClassImageList.cbSize = 0;
    }

    DeviceCollection->NumDevices = 0;
}

BOOL
DeviceCollectionPrepImageList(
    IN  PDEVICE_COLLECTION  DeviceCollection
    )
{
    if (DeviceCollection->ClassImageList.cbSize != 0) {

        //
        // We already have an image list, no need to reacquire.
        //
        return TRUE;
    }

    DeviceCollection->ClassImageList.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);
    if (SetupDiGetClassImageList(&DeviceCollection->ClassImageList)) {

        //
        // Got it.
        //
        return TRUE;
    }

    //
    // Error path, put size back so we don't accidentally free garbage.
    //
    DeviceCollection->ClassImageList.cbSize = 0;
    return FALSE;
}


VOID
DeviceCollectionPopulateListView(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  HWND                ListHandle
    )
{
    LV_ITEM lviItem;
    LV_COLUMN lvcCol;
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PLIST_ENTRY listEntry;
    ULONG lvIndex;
    BOOL haveImageList = FALSE;

    //
    // Select in the correct image list.
    //
    if (DeviceCollectionPrepImageList(DeviceCollection)) {

        ListView_SetImageList(
            ListHandle,
            DeviceCollection->ClassImageList.ImageList,
            LVSIL_SMALL
            );

        haveImageList = TRUE;
    }

    //
    // Insert a column for the class list
    //
    lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
    lvcCol.fmt = LVCFMT_LEFT;
    lvcCol.iSubItem = 0;
    ListView_InsertColumn(ListHandle, 0, (LV_COLUMN FAR *)&lvcCol);

    //
    // Walk the devinst list and add each of them to the listbox.
    //
    lvIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        deviceEntry = CONTAINING_RECORD(listEntry,
                                        DEVICE_COLLECTION_ENTRY,
                                        Link);

        lviItem.mask = LVIF_TEXT;
        lviItem.iItem = lvIndex;
        lviItem.iSubItem = 0;

        //
        // In the worst possible scenario, we will give the user the instance
        // path. This is by design because we put other things into the list
        // sometimes.
        //
        lviItem.pszText = deviceEntry->DeviceInstanceId;
        if (deviceEntry->DeviceFriendlyName) {

            lviItem.pszText = deviceEntry->DeviceFriendlyName;
        }

        if (haveImageList) {

            if (SetupDiGetClassImageIndex(
                &DeviceCollection->ClassImageList,
                &deviceEntry->ClassGuid,
                &lviItem.iImage)
                ) {

                lviItem.mask |= LVIF_IMAGE;
            }
        }

        lvIndex = ListView_InsertItem(ListHandle, &lviItem);

        lvIndex++;
    }
}


BOOL
DeviceCollectionGetDockDeviceIndex(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    OUT ULONG              *DockDeviceIndex
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PLIST_ENTRY listEntry;
    ULONG index;

    index = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        deviceEntry = CONTAINING_RECORD(listEntry,
                                        DEVICE_COLLECTION_ENTRY,
                                        Link);

        if (!(deviceEntry->Capabilities & CM_DEVCAP_DOCKDEVICE)) {

            index++;
            continue;
        }

        *DockDeviceIndex = index;
        return TRUE;
    }

    *DockDeviceIndex = 0;
    return FALSE;
}


BOOL
DeviceCollectionFormatDeviceText(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index,
    IN  PTSTR               FormatString,
    IN  ULONG               BufferCharSize,
    OUT PTSTR               BufferText
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PTCHAR friendlyName;
    ULONG curIndex;
    PLIST_ENTRY listEntry;

    curIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        if (curIndex == Index) {

            break;
        }

        curIndex++;
    }

    if (listEntry == &DeviceCollection->DeviceListHead) {

        //
        // We walked the entire list and didn't locate our device. Fail now.
        //
        if (BufferCharSize) {

            *BufferText = TEXT('\0');
        }
        return FALSE;
    }

    deviceEntry = CONTAINING_RECORD(listEntry,
                                    DEVICE_COLLECTION_ENTRY,
                                    Link);

    //
    // In the worst possible scenario, we will give the user the instance
    // path. This is by design because we put other things into the list
    // sometimes.
    //
    friendlyName = deviceEntry->DeviceInstanceId;
    if (deviceEntry->DeviceFriendlyName) {

        friendlyName = deviceEntry->DeviceFriendlyName;
    }

    StringCchPrintf(BufferText, BufferCharSize, FormatString, friendlyName);
    return TRUE;
}

BOOL
DeviceCollectionFormatServiceText(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index,
    IN  PTSTR               FormatString,
    IN  ULONG               BufferCharSize,
    OUT PTSTR               BufferText
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PTCHAR serviceName;
    TCHAR  szFriendlyName[MAX_SERVICE_NAME_LEN];
    SC_HANDLE hSCManager;
    DWORD dwSize;
    ULONG curIndex;
    PLIST_ENTRY listEntry;

    //
    // Walk the list to the entry specified by the index.
    //
    curIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        if (curIndex == Index) {

            break;
        }

        curIndex++;
    }

    if (listEntry == &DeviceCollection->DeviceListHead) {
        //
        // We walked the entire list and didn't locate our service. Fail now.
        //
        if (BufferCharSize) {
            *BufferText = TEXT('\0');
        }
        return FALSE;
    }

    deviceEntry = CONTAINING_RECORD(listEntry,
                                    DEVICE_COLLECTION_ENTRY,
                                    Link);

    //
    // Our caller knows this collection entry is really a service (either a
    // windows service, or a kernel driver), so the DeviceInstanceId is really
    // the Service name.  Query the SCM for its friendlier DisplayName property.
    //

    serviceName = deviceEntry->DeviceInstanceId;

    *szFriendlyName = TEXT('\0');

    if (serviceName) {

        //
        // Open the Service Control Manager
        //
        hSCManager = OpenSCManager(
            NULL,                     // local machine
            SERVICES_ACTIVE_DATABASE, // SCM database name
            GENERIC_READ              // access type
            );

        if (hSCManager) {

            //
            // Query the SCM for this service's DisplayName.  Note we use a
            // constant buffer of MAX_SERVICE_NAME_LENGTH chars, which should
            // always be large enough because that's what the SCM limits
            // DisplayNames to.  If GetServiceDisplayName fails, we will receive
            // an empty string, which we'll handle below.
            //

            dwSize = MAX_SERVICE_NAME_LEN;

            GetServiceDisplayName(
                hSCManager,           // handle to SCM database
                serviceName,          // service name
                szFriendlyName,       // display name
                &dwSize               // size of display name buffer (in chars)
                );

            CloseServiceHandle(hSCManager);
        }

        //
        // We couldn't retrieve a friendly name for the service, so just use the
        // name we were given.
        //
        if (!*szFriendlyName) {
            StringCchCopy(szFriendlyName,
                          SIZECHARS(szFriendlyName),
                          serviceName);
        }
    }

    StringCchPrintf(BufferText, BufferCharSize, FormatString, szFriendlyName);
    return TRUE;
}

PTSTR
DeviceCollectionGetDeviceInstancePath(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    ULONG curIndex;
    PLIST_ENTRY listEntry;

    curIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        if (curIndex == Index) {
            break;
        }

        curIndex++;
    }

    if (listEntry == &DeviceCollection->DeviceListHead) {
        //
        // We walked the entire list and didn't locate our device. Fail now.
        //
        return NULL;
    }

    deviceEntry = CONTAINING_RECORD(listEntry,
                                    DEVICE_COLLECTION_ENTRY,
                                    Link);

    return deviceEntry->DeviceInstanceId;
}

PTSTR
DeviceCollectionGetDeviceFriendlyName(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    ULONG curIndex;
    PLIST_ENTRY listEntry;

    curIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        if (curIndex == Index) {
            break;
        }

        curIndex++;
    }

    if (listEntry == &DeviceCollection->DeviceListHead) {
        //
        // We walked the entire list and didn't locate our device. Fail now.
        //
        return NULL;
    }

    deviceEntry = CONTAINING_RECORD(listEntry,
                                    DEVICE_COLLECTION_ENTRY,
                                    Link);

    return deviceEntry->DeviceFriendlyName;
}

BOOL
DeviceCollectionGetGuid(
    IN     PDEVICE_COLLECTION  DeviceCollection,
    IN OUT LPGUID              Guid,
    IN     ULONG               Index
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    ULONG curIndex;
    PLIST_ENTRY listEntry;

    curIndex = 0;
    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        if (curIndex == Index) {
            break;
        }

        curIndex++;
    }

    if (listEntry == &DeviceCollection->DeviceListHead) {
        //
        // We walked the entire list and didn't locate our device. Fail now.
        //
        return FALSE;
    }

    deviceEntry = CONTAINING_RECORD(listEntry,
                                    DEVICE_COLLECTION_ENTRY,
                                    Link);

    memcpy(Guid, &(deviceEntry->ClassGuid), sizeof(GUID));
    return TRUE;
}

VOID
DeviceCollectionSwapFakeDockForRealDock(
    IN      PDEVICE_COLLECTION  DeviceCollection,
    IN      PTSTR               InstancePath,
    IN OUT  DEVNODE            *DeviceNode
    )
{
    DEVNODE fakeDock, realDock;
    ULONG cchSize;
    CONFIGRET configRet;
    PTSTR deviceIdRelations, realDockId, nextEjectionId, hardwareIds, curEntry;

    //
    // Preinit
    //
    fakeDock = *DeviceNode;
    deviceIdRelations = NULL;
    hardwareIds = NULL;

    cchSize = 0;
    configRet = CM_Get_Device_ID_List_Size_Ex(
        &cchSize,
        InstancePath,
        CM_GETIDLIST_FILTER_EJECTRELATIONS,
        NULL
        );

    if ((configRet != CR_SUCCESS) || (!cchSize)) {

        goto Exit;
    }

    deviceIdRelations = (PTSTR)LocalAlloc(LPTR, cchSize*sizeof(TCHAR));

    if (!deviceIdRelations) {

        goto Exit;
    }

    *deviceIdRelations = TEXT('\0');

    configRet = CM_Get_Device_ID_List_Ex(
        InstancePath,
        deviceIdRelations,
        cchSize,
        CM_GETIDLIST_FILTER_EJECTRELATIONS,
        NULL
        );

    if (configRet != CR_SUCCESS) {

        goto Exit;
    }

    if (!(*deviceIdRelations)) {

        //
        // No ejection relations, bail.
        //
        goto Exit;
    }

    //
    // The last relation should be the real dock. Get it.
    //
    nextEjectionId = deviceIdRelations;

    do {

        realDockId = nextEjectionId;
        nextEjectionId += lstrlen(nextEjectionId)+1;

    } while ( *nextEjectionId );

    configRet = CM_Locate_DevNode(
        &realDock,
        realDockId,
        CM_LOCATE_DEVNODE_PHANTOM
        );

    if (configRet != CR_SUCCESS) {

        goto Exit;
    }

    LocalFree(deviceIdRelations);
    deviceIdRelations = NULL;

    //
    // One last check - we need to check the hardware ID's and compatible ID's.
    // We will only do this if we spot a *PNP0C15 amongst them.
    //
    cchSize = 0;
    configRet = CM_Get_DevNode_Registry_Property_Ex(
        realDock,
        CM_DRP_HARDWAREID,
        NULL,
        NULL,
        &cchSize,
        0,
        NULL
        );

    if (configRet != CR_SUCCESS) {

        goto Exit;
    }

    hardwareIds = (PTSTR)LocalAlloc(LPTR, cchSize*sizeof(TCHAR));

    if (!hardwareIds) {

        goto Exit;
    }

    configRet = CM_Get_DevNode_Registry_Property_Ex(
        realDock,
        CM_DRP_HARDWAREID,
        NULL,
        hardwareIds,
        &cchSize,
        0,
        NULL
        );

    if (configRet == CR_SUCCESS) {

        for(curEntry = hardwareIds;
            *curEntry;
            curEntry += lstrlen(curEntry)+1) {

            if (!_wcsicmp(curEntry, TEXT("*PNP0C15"))) {

                //
                // We found an entry - we can successful "rebrand" this dock
                // for the user.
                //
                *DeviceNode = realDock;
                LocalFree(hardwareIds);
                return;
            }
        }
    }

    LocalFree(hardwareIds);
    hardwareIds = NULL;

    //
    // Now try the compatible ID's. This is where we really expect to find the
    // real dock.
    //
    cchSize = 0;
    configRet = CM_Get_DevNode_Registry_Property_Ex(
        realDock,
        CM_DRP_COMPATIBLEIDS,
        NULL,
        NULL,
        &cchSize,
        0,
        NULL
        );

    if (configRet != CR_SUCCESS) {

        goto Exit;
    }

    hardwareIds = (PTSTR)LocalAlloc(LPTR, cchSize*sizeof(TCHAR));

    if (!hardwareIds) {

        goto Exit;
    }

    configRet = CM_Get_DevNode_Registry_Property_Ex(
        realDock,
        CM_DRP_COMPATIBLEIDS,
        NULL,
        hardwareIds,
        &cchSize,
        0,
        NULL
        );

    if (configRet == CR_SUCCESS) {

        for(curEntry = hardwareIds;
            *curEntry;
            curEntry += lstrlen(curEntry)+1) {

            if (!_wcsicmp(curEntry, TEXT("*PNP0C15"))) {

                //
                // We found an entry - we can successful "rebrand" this dock
                // for the user.
                //
                *DeviceNode = realDock;
                LocalFree(hardwareIds);
                return;
            }
        }
    }


Exit:
    if (deviceIdRelations) {

        LocalFree(deviceIdRelations);
    }

    if (hardwareIds) {

        LocalFree(hardwareIds);
    }
}

BOOL
DeviceCollectionCheckIfAllRemoved(
    IN  PDEVICE_COLLECTION  DeviceCollection
    )
{
    PDEVICE_COLLECTION_ENTRY deviceEntry;
    PLIST_ENTRY listEntry;
    DEVNODE deviceNode;

    for(listEntry = DeviceCollection->DeviceListHead.Flink;
        listEntry != &DeviceCollection->DeviceListHead;
        listEntry = listEntry->Flink) {

        deviceEntry = CONTAINING_RECORD(listEntry,
                                        DEVICE_COLLECTION_ENTRY,
                                        Link);
        //
        // If we can locate this device normally then it is a 'live'
        // device, so return FALSE.
        //
        if (CM_Locate_DevNode(&deviceNode,
                              deviceEntry->DeviceInstanceId,
                              0) == CR_SUCCESS) {
            return FALSE;
        }
    }

    //
    // We were able to locate all the devices in this device collection.
    //
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\devtree.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       devtree.cpp
//
//--------------------------------------------------------------------------

#include "HotPlug.h"

//
// Define and initialize all device class GUIDs.
// (This must only be done once per module!)
//
#include <initguid.h>
#include <devguid.h>

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);


PDEVINST
BuildDeviceRelationsList(
   PTCHAR   DeviceId,
   ULONG    FilterFlag,
   PUSHORT  pNumDevinst
   )
{
    ULONG cchSize, cbSize, MaxDevinst;
    USHORT NumDevInst;
    CONFIGRET ConfigRet;
    PTCHAR DeviceIdRelations = NULL, CurrDevId;
    PDEVINST DevinstRelations = NULL;

    DevinstRelations = NULL;
    DeviceIdRelations = NULL;
    NumDevInst = 0;

    cchSize = 0;
    ConfigRet = CM_Get_Device_ID_List_Size_Ex(&cchSize,
                                              DeviceId,
                                              FilterFlag,
                                              NULL
                                              );

    if ((ConfigRet != CR_SUCCESS) || !cchSize) {
        
        goto BDEarlyExit;
    }

    DeviceIdRelations = (PTCHAR)LocalAlloc(LPTR, cchSize*sizeof(TCHAR));
    
    if (!DeviceIdRelations) {

        goto BDEarlyExit;
    }
    
    *DeviceIdRelations = TEXT('\0');

    if (DeviceIdRelations) {

        ConfigRet = CM_Get_Device_ID_List_Ex(DeviceId,
                                             DeviceIdRelations,
                                             cchSize,
                                             FilterFlag,
                                             NULL
                                             );



        if (ConfigRet != CR_SUCCESS || !*DeviceIdRelations) {

            goto BDEarlyExit;
        }
    }

    //
    // Count up the number of Device Instance Ids in the list so we know how
    // big to make our array of devnodes.
    //
    MaxDevinst = 0;
    for (CurrDevId = DeviceIdRelations; *CurrDevId; CurrDevId += lstrlen(CurrDevId) + 1) {
        MaxDevinst++;
    }

    if (MaxDevinst == 0) {
        goto BDEarlyExit;
    }
    
    DevinstRelations = (PDEVINST)LocalAlloc(LPTR, MaxDevinst * sizeof(DEVNODE));

    if (!DevinstRelations) {

        goto BDEarlyExit;
    }

    for (CurrDevId = DeviceIdRelations; *CurrDevId; CurrDevId += lstrlen(CurrDevId) + 1) {
        
        ConfigRet = CM_Locate_DevNode_Ex(&DevinstRelations[NumDevInst],
                                         CurrDevId,
                                         CM_LOCATE_DEVNODE_NORMAL,
                                         NULL
                                         );

        if (ConfigRet == CR_SUCCESS) {

            ++NumDevInst;
        }
    }

BDEarlyExit:

    if (DeviceIdRelations) {

        LocalFree(DeviceIdRelations);
    }

    if (DevinstRelations) {

        if (NumDevInst == 0) {
            //
            // If we coundn't get any devnodes then return NULL
            //
            LocalFree(DevinstRelations);
            DevinstRelations = NULL;
        }
    }

    *pNumDevinst = NumDevInst;
    return DevinstRelations;
}

LONG
AddChildSiblings(
    PDEVICETREE  DeviceTree,
    PDEVTREENODE ParentNode,
    DEVINST      DeviceInstance,
    int          TreeDepth,
    BOOL         Recurse
    )
{
    DWORD        cbSize;
    CONFIGRET    ConfigRet;
    DEVINST      ChildDeviceInstance;
    PDEVTREENODE DeviceTreeNode;
    PLIST_ENTRY  ChildSiblingList;
    TCHAR        Buffer[MAX_PATH];
    DWORD        NumRelations;
    PDEVINST     pDevInst;

    ChildSiblingList = ParentNode ? &ParentNode->ChildSiblingList
                                  : &DeviceTree->ChildSiblingList;

    if (!ParentNode) {
    
        InitializeListHead(ChildSiblingList);
    }

    if (TreeDepth > DeviceTree->TreeDepth) {

        DeviceTree->TreeDepth = TreeDepth;
    }

    do {
        DeviceTreeNode = (PDEVTREENODE)LocalAlloc(LPTR, sizeof(DEVTREENODE));

        if (!DeviceTreeNode) {
            
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        ZeroMemory(DeviceTreeNode, sizeof(DEVTREENODE));
        InsertTailList(ChildSiblingList, &(DeviceTreeNode->SiblingEntry));

        DeviceTreeNode->ParentNode = ParentNode;

        //
        // fill in info about this device instance.
        //
        InitializeListHead(&(DeviceTreeNode->ChildSiblingList));
        DeviceTreeNode->DevInst = DeviceInstance;
        DeviceTreeNode->TreeDepth = TreeDepth;

        //
        // Get ClassGUID, and class name.
        //
        cbSize = sizeof(Buffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                        CM_DRP_CLASSGUID,
                                                        NULL,
                                                        Buffer,
                                                        &cbSize,
                                                        0,
                                                        NULL
                                                        );


        if (ConfigRet == CR_SUCCESS) {

            pSetupGuidFromString(Buffer, &DeviceTreeNode->ClassGuid);
        }

        //
        // Drive list
        //
        DeviceTreeNode->DriveList = DevNodeToDriveLetter(DeviceInstance);

        //
        // FriendlyName
        //
        *Buffer = TEXT('\0');
        cbSize = sizeof(Buffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                        CM_DRP_FRIENDLYNAME,
                                                        NULL,
                                                        Buffer,
                                                        &cbSize,
                                                        0,
                                                        NULL
                                                        );
        if (ConfigRet == CR_SUCCESS && *Buffer) {

            if (DeviceTreeNode->DriveList) {

                cbSize += lstrlen(DeviceTreeNode->DriveList) * sizeof(TCHAR);
            }

            DeviceTreeNode->FriendlyName = (PTCHAR)LocalAlloc(LPTR, cbSize);

            if (DeviceTreeNode->FriendlyName) {

                StringCbCopy(DeviceTreeNode->FriendlyName, 
                              cbSize, 
                              Buffer);
            
                if (DeviceTreeNode->DriveList) {

                    StringCbCat(DeviceTreeNode->FriendlyName, 
                                 cbSize, 
                                 DeviceTreeNode->DriveList);
                }
            }
        }

        else {

            DeviceTreeNode->FriendlyName = NULL;
        }


        //
        // DeviceDesc
        //
        *Buffer = TEXT('\0');
        cbSize = sizeof(Buffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(
                                        DeviceInstance,
                                        CM_DRP_DEVICEDESC,
                                        NULL,
                                        (PVOID)Buffer,
                                        &cbSize,
                                        0,
                                        NULL
                                        );

        if (ConfigRet == CR_SUCCESS && *Buffer) {

            if (DeviceTreeNode->DriveList) {

                cbSize += lstrlen(DeviceTreeNode->DriveList) * sizeof(TCHAR);
            }

            DeviceTreeNode->DeviceDesc = (PTCHAR)LocalAlloc(LPTR, cbSize);

            if (DeviceTreeNode->DeviceDesc) {

                StringCbCopy(DeviceTreeNode->DeviceDesc, 
                              cbSize, 
                              Buffer);
            
                if (DeviceTreeNode->DriveList) {

                    StringCbCat(DeviceTreeNode->DeviceDesc, 
                                 cbSize, 
                                 DeviceTreeNode->DriveList);
                }
            }
        }

        else {

            DeviceTreeNode->DeviceDesc = NULL;
        }

        //
        // Device capabilities
        //
        cbSize = sizeof(DeviceTreeNode->Capabilities);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(
                                        DeviceInstance,
                                        CM_DRP_CAPABILITIES,
                                        NULL,
                                        (PVOID)&DeviceTreeNode->Capabilities,
                                        &cbSize,
                                        0,
                                        NULL
                                        );

        if (ConfigRet != CR_SUCCESS) {

            DeviceTreeNode->Capabilities = 0;
        }

        //
        // Status and Problem number
        //
        ConfigRet = CM_Get_DevNode_Status_Ex(&DeviceTreeNode->DevNodeStatus,
                                             &DeviceTreeNode->Problem,
                                             DeviceInstance,
                                             0,
                                             NULL
                                             );

        if (ConfigRet != CR_SUCCESS) {

            DeviceTreeNode->DevNodeStatus = 0;
            DeviceTreeNode->Problem = 0;
        }

        //
        // We need to do the following special case. If a device is not started and
        // it doesn't have a problem and it is a RAW device then give it a problem
        // CM_PROB_FAILED_START.
        //
        if (!(DeviceTreeNode->DevNodeStatus & DN_STARTED) &&
            !(DeviceTreeNode->DevNodeStatus & DN_HAS_PROBLEM) &&
            (DeviceTreeNode->Capabilities & CM_DEVCAP_RAWDEVICEOK)) {

            DeviceTreeNode->Problem = CM_PROB_FAILED_START;
        }

        //
        // LocationInformation
        //
        DeviceTreeNode->Location = BuildLocationInformation(DeviceInstance);


        //
        // Get InstanceId
        //
        *Buffer = TEXT('\0');
        ConfigRet = CM_Get_Device_ID_ExW(DeviceInstance,
                                         Buffer,
                                         SIZECHARS(Buffer),
                                         0,
                                         NULL
                                         );

        if (ConfigRet == CR_SUCCESS && *Buffer) {

            cbSize = lstrlen(Buffer) * sizeof(TCHAR) + sizeof(TCHAR);
            DeviceTreeNode->InstanceId = (PTCHAR)LocalAlloc(LPTR, cbSize);

            if (DeviceTreeNode->InstanceId) {

                StringCbCopy(DeviceTreeNode->InstanceId, cbSize, Buffer);
            }
        }

        else {

            DeviceTreeNode->InstanceId = NULL;
        }


        //
        // Fetch removal and eject relations
        //
        if (ConfigRet == CR_SUCCESS) {

            DeviceTreeNode->EjectRelations = BuildDeviceRelationsList(
                                                 Buffer,
                                                 CM_GETIDLIST_FILTER_EJECTRELATIONS,
                                                 &DeviceTreeNode->NumEjectRelations
                                                 );

            DeviceTreeNode->RemovalRelations = BuildDeviceRelationsList(
                                                 Buffer,
                                                 CM_GETIDLIST_FILTER_REMOVALRELATIONS,
                                                 &DeviceTreeNode->NumRemovalRelations
                                                 );
        }
            
        //
        // Only get children and siblings if the Recurse value was TRUE
        // otherwise we will just build a DeviceTreeNode structure for 
        // the individual devnode that was passed in.
        //
        // Also, only add rejection and removal relations when Recurse is TRUE,
        // otherwise we get messed up if two devices have removal or ejection
        // relations to each other.
        //
        if (Recurse) {
            
            LPTSTR tempDriveList;

            DeviceTreeNode->bCopy = FALSE;
            
            //
            // Add Ejection relation drive letters
            //
            NumRelations = DeviceTreeNode->NumEjectRelations;
            pDevInst = DeviceTreeNode->EjectRelations;

            while (NumRelations--) {

                if ((tempDriveList = DevNodeToDriveLetter(*pDevInst)) != NULL) {

                    AddChildSiblings(DeviceTree,
                                     DeviceTreeNode,
                                     *pDevInst,
                                     TreeDepth+1,
                                     FALSE
                                     );

                    LocalFree(tempDriveList);
                }
            
                pDevInst++;
            }

            //
            // Add Removal relation drive letters
            //
            NumRelations = DeviceTreeNode->NumRemovalRelations;
            pDevInst = DeviceTreeNode->RemovalRelations;

            while (NumRelations--) {

                if ((tempDriveList = DevNodeToDriveLetter(*pDevInst)) != NULL) {

                    AddChildSiblings(DeviceTree,
                                     DeviceTreeNode,
                                     *pDevInst,
                                     TreeDepth+1,
                                     FALSE
                                     );

                    LocalFree(tempDriveList);
                }
            
                pDevInst++;
            }
        
            //
            // If this devinst has children, then recurse to fill in its
            // child sibling list.
            //
            ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance,
                                        DeviceInstance,
                                        0,
                                        NULL
                                        );
    
            if (ConfigRet == CR_SUCCESS) {
    
    
                AddChildSiblings(DeviceTree,
                                 DeviceTreeNode,
                                 ChildDeviceInstance,
                                 TreeDepth+1,
                                 TRUE
                                 );
    
            }
    
            //
            // Next sibling ...
            //
    
            ConfigRet = CM_Get_Sibling_Ex(&DeviceInstance,
                                          DeviceInstance,
                                          0,
                                          NULL
                                          );
        } else {

            //
            // If Recurse is FALSE then we are making a Copy of an already existing DeviceTreeNode.
            // We do this when a HotPlug Device has a relation that will get removed when it gets
            // removed.  We need to set the bCopy flag because in certain cases the HotPlug device's 
            // relation is also a HotPlug device.  If we don't mark that it is a copy then it will
            // get added to the list of removeable devices twice.
            //
            DeviceTreeNode->bCopy = TRUE;
        }

    } while (Recurse && (ConfigRet == CR_SUCCESS));


    return ERROR_SUCCESS;
}

void
RemoveChildSiblings(
    PDEVICETREE  DeviceTree,
    PLIST_ENTRY  ChildSiblingList
    )
{
    PLIST_ENTRY Next;
    PDEVTREENODE DeviceTreeNode;

    Next = ChildSiblingList->Flink;
    while (Next != ChildSiblingList) {

        DeviceTreeNode = CONTAINING_RECORD(Next, DEVTREENODE, SiblingEntry);


        //
        // recurse to free this nodes ChildSiblingList
        //
        if (!IsListEmpty(&DeviceTreeNode->ChildSiblingList)) {

            RemoveChildSiblings(DeviceTree,
                                &DeviceTreeNode->ChildSiblingList
                                );
        }

        //
        // free up this node and move on to the next sibling.
        //
        Next = Next->Flink;
        RemoveEntryList(&DeviceTreeNode->SiblingEntry);

        if (DeviceTreeNode->FriendlyName) {

            LocalFree(DeviceTreeNode->FriendlyName);
        }

        if (DeviceTreeNode->DeviceDesc) {

            LocalFree(DeviceTreeNode->DeviceDesc);
        }

        if (DeviceTreeNode->DriveList) {

            LocalFree(DeviceTreeNode->DriveList);
        }

        if (DeviceTreeNode->Location) {

            LocalFree(DeviceTreeNode->Location);
        }

        if (DeviceTreeNode->InstanceId) {

            LocalFree(DeviceTreeNode->InstanceId);
        }

        if (DeviceTreeNode->EjectRelations) {

            LocalFree(DeviceTreeNode->EjectRelations);
        }

        if (DeviceTreeNode->RemovalRelations) {

            LocalFree(DeviceTreeNode->RemovalRelations);
        }

        if (DeviceTree->SelectedTreeNode == DeviceTreeNode) {

            DeviceTree->SelectedTreeNode = NULL;
        }

        ZeroMemory(DeviceTreeNode, sizeof(DEVTREENODE));
        LocalFree(DeviceTreeNode);
    }

    return;
}

PTCHAR
FetchDeviceName(
     PDEVTREENODE DeviceTreeNode
     )
{
    if (DeviceTreeNode->FriendlyName) {

        return DeviceTreeNode->FriendlyName;
    }

    if (DeviceTreeNode->DeviceDesc) {

        return DeviceTreeNode->DeviceDesc;
    }

    return NULL;
}

BOOL
DisplayChildSiblings(
    PDEVICETREE DeviceTree,
    PLIST_ENTRY ChildSiblingList,
    HTREEITEM   hParentTreeItem,
    BOOL        HotPlugParent
    )
{
    PLIST_ENTRY Next;
    PDEVTREENODE DeviceTreeNode;
    TV_INSERTSTRUCT tvi;
    BOOL ChildDisplayed = FALSE;

    Next = ChildSiblingList->Flink;
    while (Next != ChildSiblingList) {

        DeviceTreeNode = CONTAINING_RECORD(Next, DEVTREENODE, SiblingEntry);

        //
        // - If this device has a hotplug parent and we are in the complex view then
        //   add this device to the tree.
        // - If this device is a hotplug device and it is not a bCopy then add this device
        //   to the tree.  A bCopy device is one where we create another DeviceTreeNode structure
        //   for a device that is a relation of a hotplug device.  The problem is that this relation
        //   itself could be a hotplug device and we don't want to show to copies of it in the UI.
        //
        if (!DeviceTree->HotPlugTree ||
            (HotPlugParent && DeviceTree->ComplexView) ||
            (!DeviceTreeNode->bCopy && IsHotPlugDevice(DeviceTreeNode->DevInst)))
        {
            tvi.item.mask = TVIF_TEXT | TVIF_PARAM | TVIF_STATE ;

            if (SetupDiGetClassImageIndex(&DeviceTree->ClassImageList,
                                         &DeviceTreeNode->ClassGuid,
                                         &tvi.item.iImage
                                         ))
            {
                tvi.item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;
            }

            tvi.hParent = hParentTreeItem;
            tvi.hInsertAfter = TVI_LAST;
            tvi.item.iSelectedImage = tvi.item.iImage;
            tvi.item.pszText = FetchDeviceName(DeviceTreeNode);

            if (!tvi.item.pszText) {

                tvi.item.pszText = szUnknown;
            }

            tvi.item.lParam = (LPARAM)DeviceTreeNode;
            tvi.item.stateMask = TVIS_OVERLAYMASK;

            if (DeviceTreeNode->Problem == CM_PROB_DISABLED) {

                tvi.item.state = INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
            
            } else if (DeviceTreeNode->Problem) {

                tvi.item.state = INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);
            
            } else {

                tvi.item.state = INDEXTOOVERLAYMASK(0);
            }

            DeviceTreeNode->hTreeItem = TreeView_InsertItem(DeviceTree->hwndTree, &tvi);
            ChildDisplayed = TRUE;
        
        } else {

            DeviceTreeNode->hTreeItem = NULL;
        }

        //
        // recurse to display this nodes ChildSiblingList
        //
        if (!IsListEmpty(&DeviceTreeNode->ChildSiblingList)) {

            if (DisplayChildSiblings(DeviceTree,
                                     &DeviceTreeNode->ChildSiblingList,
                                     DeviceTree->ComplexView ? DeviceTreeNode->hTreeItem
                                                             : hParentTreeItem,
                                     DeviceTreeNode->hTreeItem != NULL
                                     ))
            {
                ChildDisplayed = TRUE;

                //
                // if we are at the root expand the list of child items.
                //
                if (DeviceTreeNode->hTreeItem && DeviceTree->ComplexView) {

                    TreeView_Expand(DeviceTree->hwndTree,
                                    DeviceTreeNode->hTreeItem,
                                    TVE_EXPAND
                                    );
                }
            }
        }

        //
        // and on to the next sibling.
        //
        Next = Next->Flink;

    }

    return ChildDisplayed;
}

void
AddChildRemoval(
    PDEVICETREE DeviceTree,
    PLIST_ENTRY ChildSiblingList
    )
{
    PLIST_ENTRY Next;
    PDEVTREENODE DeviceTreeNode;
    PDEVTREENODE FirstDeviceTreeNode;

    if (IsListEmpty(ChildSiblingList)) {

        return;
    }

    FirstDeviceTreeNode = DeviceTree->ChildRemovalList;

    Next = ChildSiblingList->Flink;
    while (Next != ChildSiblingList) {

        DeviceTreeNode = CONTAINING_RECORD(Next, DEVTREENODE, SiblingEntry);

        DeviceTreeNode->NextChildRemoval = FirstDeviceTreeNode->NextChildRemoval;
        FirstDeviceTreeNode->NextChildRemoval = DeviceTreeNode;

        InvalidateTreeItemRect(DeviceTree->hwndTree, DeviceTreeNode->hTreeItem);

        //
        // recurse to Add this node's Childs
        //
        AddChildRemoval(DeviceTree, &DeviceTreeNode->ChildSiblingList);

        //
        // and on to the next sibling.
        //
        Next = Next->Flink;
    }

    return;
}

void
ClearRemovalList(
    PDEVICETREE  DeviceTree

    )
{
    PDEVTREENODE Next;
    PDEVTREENODE DeviceTreeNode;

    DeviceTreeNode = DeviceTree->ChildRemovalList;

    if (!DeviceTreeNode) {

        return;
    }

    do {

        Next = DeviceTreeNode->NextChildRemoval;
        DeviceTreeNode->NextChildRemoval = NULL;

        //
        // force redraw of this item to reset the colors
        //
        InvalidateTreeItemRect(DeviceTree->hwndTree, DeviceTreeNode->hTreeItem);

        DeviceTreeNode = Next;

    } while (DeviceTreeNode != DeviceTree->ChildRemovalList);


    DeviceTree->ChildRemovalList = NULL;
}

PDEVTREENODE
DevTreeNodeByInstanceId(
    PTCHAR InstanceId,
    PLIST_ENTRY ChildSiblingList
    )
{
    PLIST_ENTRY Next;
    PDEVTREENODE DeviceTreeNode;

    if (!InstanceId) {
        return NULL;
    }

    Next = ChildSiblingList->Flink;
    while (Next != ChildSiblingList) {

        DeviceTreeNode = CONTAINING_RECORD(Next, DEVTREENODE, SiblingEntry);

        if (DeviceTreeNode->InstanceId &&
            !lstrcmp(DeviceTreeNode->InstanceId, InstanceId))
        {
            return DeviceTreeNode;
        }

        //
        // recurse to display this nodes ChildSiblingList
        //
        if (!IsListEmpty(&DeviceTreeNode->ChildSiblingList)) {

            DeviceTreeNode = DevTreeNodeByInstanceId(InstanceId,
                                                     &DeviceTreeNode->ChildSiblingList
                                                     );
            if (DeviceTreeNode) {

                return DeviceTreeNode;
            }
        }

        //
        // and on to the next sibling.
        //
        Next = Next->Flink;
    }

    return NULL;
}

PDEVTREENODE
DevTreeNodeByDevInst(
    DEVINST DevInst,
    PLIST_ENTRY ChildSiblingList
    )
{
    PLIST_ENTRY Next;
    PDEVTREENODE DeviceTreeNode;

    if (!DevInst) {

        return NULL;
    }

    Next = ChildSiblingList->Flink;
    while (Next != ChildSiblingList) {

        DeviceTreeNode = CONTAINING_RECORD(Next, DEVTREENODE, SiblingEntry);

        //
        // We currently assume that we can compare DEVINST from separate
        // "CM_Locate_Devnode" invocations, since a DEVINST is not a real
        // handle, but a pointer to a globalstring table.
        //
        if (DevInst == DeviceTreeNode->DevInst) {

            return DeviceTreeNode;
        }

        //
        // recurse to display this nodes ChildSiblingList
        //
        if (!IsListEmpty(&DeviceTreeNode->ChildSiblingList)) {

            DeviceTreeNode = DevTreeNodeByDevInst(DevInst,
                                                  &DeviceTreeNode->ChildSiblingList
                                                  );
            if (DeviceTreeNode) {

                return DeviceTreeNode;
            }
        }

        //
        // and on to the next sibling.
        //
        Next = Next->Flink;
    }

    return NULL;
}

PDEVTREENODE
TopLevelRemovalNode(
    PDEVICETREE DeviceTree,
    PDEVTREENODE DeviceTreeNode
    )
{
    PDEVTREENODE ParentNode = DeviceTreeNode;

    while (ParentNode) {

        DeviceTreeNode = ParentNode;

        if (IsHotPlugDevice(ParentNode->DevInst)) {
        
            return ParentNode;
        }

        ParentNode = ParentNode->ParentNode;
    }

    return DeviceTreeNode;
}

void
AddEjectToRemoval(
    PDEVICETREE DeviceTree
    )
{
    PDEVTREENODE RelationTreeNode;
    PDEVTREENODE DeviceTreeNode;
    PDEVINST pDevInst;
    USHORT   NumRelations;


    //
    // For each DeviceTreeNode in the removal list
    //   If it has ejection or removal relations, add it to the removal list.
    //
    DeviceTreeNode = DeviceTree->ChildRemovalList;
    if (!DeviceTreeNode) {

        return;
    }


    do {

        //
        // Ejection Relations
        //
        NumRelations = DeviceTreeNode->NumEjectRelations;
        pDevInst = DeviceTreeNode->EjectRelations;

        while (NumRelations--) {

            RelationTreeNode = DevTreeNodeByDevInst(*pDevInst++,
                                                 &DeviceTree->ChildSiblingList
                                                 );

            //
            // If we can't get a DeviceTreeNode for this device, or it is already
            // in the list of devices that will be removed (it's NextChildRemoval)
            // is non-NULL then we won't add this device to the list that will be removed.
            //
            // If this is a drive letter devnode then we have also already added it to 
            // the list so we can skip it.
            //
            if (!RelationTreeNode || 
                RelationTreeNode->NextChildRemoval ||
                RelationTreeNode->DriveList) {

                continue;
            }


            //
            // Insert the new devtreenode
            //
            RelationTreeNode->NextChildRemoval = DeviceTreeNode->NextChildRemoval;
            DeviceTreeNode->NextChildRemoval = RelationTreeNode;
        }

        //
        // Removal Relations
        //
        NumRelations = DeviceTreeNode->NumRemovalRelations;
        pDevInst = DeviceTreeNode->RemovalRelations;

        while (NumRelations--) {

            RelationTreeNode = DevTreeNodeByDevInst(*pDevInst++,
                                                 &DeviceTree->ChildSiblingList
                                                 );

            //
            // If we can't get a DeviceTreeNode for this device, or it is already
            // in the list of devices that will be removed (it's NextChildRemoval)
            // is non-NULL then we won't add this device to the list that will be removed.
            //
            // If this is a drive letter devnode then we have also already added it to 
            // the list so we can skip it.
            //
            if (!RelationTreeNode || 
                RelationTreeNode->NextChildRemoval || 
                RelationTreeNode->DriveList) {

                continue;
            }


            //
            // Insert the new devtreenode
            //
            RelationTreeNode->NextChildRemoval = DeviceTreeNode->NextChildRemoval;
            DeviceTreeNode->NextChildRemoval = RelationTreeNode;
        }


        //
        // And on to the next node.
        //

        DeviceTreeNode = DeviceTreeNode->NextChildRemoval;

    } while (DeviceTreeNode != DeviceTree->ChildRemovalList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__5658ACC5_147F_4E3F_8D69_213F30620FE0__INCLUDED_)
#define AFX_DLLDATAX_H__5658ACC5_147F_4E3F_8D69_213F30620FE0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__5658ACC5_147F_4E3F_8D69_213F30620FE0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\devicecol.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File: devicecol.h
//
//  Description: This header exposes support for device collections.
//
//--------------------------------------------------------------------------

typedef enum {

    CT_SAFE_REMOVAL_NOTIFICATION,
    CT_VETOED_REMOVAL_NOTIFICATION,
    CT_SURPRISE_REMOVAL_WARNING,
    CT_BLOCKED_DRIVER_NOTIFICATION,
    CT_CHILD_WITH_INVALID_ID_NOTIFICATION

} COLLECTION_TYPE, *PCOLLECTION_TYPE;

typedef struct {

    LIST_ENTRY  Link;
    TCHAR       DeviceInstanceId[MAX_DEVICE_ID_LEN+1];
    PTSTR       DeviceFriendlyName;
    ULONG       Capabilities;
    GUID        ClassGuid;

} DEVICE_COLLECTION_ENTRY, *PDEVICE_COLLECTION_ENTRY;

typedef struct {

    LIST_ENTRY              DeviceListHead;
    INT                     NumDevices;
    BOOL                    DockInList;
    SP_CLASSIMAGELIST_DATA  ClassImageList;

} DEVICE_COLLECTION, *PDEVICE_COLLECTION;


typedef enum {

    VETOED_EJECT = 1,
    VETOED_REMOVAL,
    VETOED_UNDOCK,
    VETOED_STANDBY,
    VETOED_HIBERNATE,
    VETOED_WARM_EJECT,
    VETOED_WARM_UNDOCK

} VETOED_OPERATION;

typedef struct {

    DEVICE_COLLECTION   dc;
    PNP_VETO_TYPE       VetoType;
    VETOED_OPERATION    VetoedOperation;

} VETO_DEVICE_COLLECTION, *PVETO_DEVICE_COLLECTION;

typedef struct {

    DEVICE_COLLECTION   dc;
    BOOL                SuppressSurprise;
    ULONG               DialogTicker;
    ULONG               MaxWaitForDock;

} SURPRISE_WARN_COLLECTION, *PSURPRISE_WARN_COLLECTION;


BOOL
DeviceCollectionBuildFromPipe(
    IN  HANDLE              ReadPipe,
    IN  COLLECTION_TYPE     CollectionType,
    OUT PDEVICE_COLLECTION  DeviceCollection
    );

VOID
DeviceCollectionDestroy(
    IN  PDEVICE_COLLECTION  DeviceCollection
    );

VOID
DeviceCollectionPopulateListView(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  HWND                ListHandle
    );

BOOL
DeviceCollectionGetDockDeviceIndex(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    OUT ULONG              *DockDeviceIndex
    );

BOOL
DeviceCollectionFormatDeviceText(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index,
    IN  PTSTR               FormatString,
    IN  ULONG               BufferCharSize,
    OUT PTSTR               BufferText
    );

BOOL
DeviceCollectionFormatServiceText(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index,
    IN  PTSTR               FormatString,
    IN  ULONG               BufferCharSize,
    OUT PTSTR               BufferText
    );

PTSTR
DeviceCollectionGetDeviceInstancePath(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index
    );

PTSTR
DeviceCollectionGetDeviceFriendlyName(
    IN  PDEVICE_COLLECTION  DeviceCollection,
    IN  ULONG               Index
    );

BOOL
DeviceCollectionGetGuid(
    IN     PDEVICE_COLLECTION  DeviceCollection,
    IN OUT LPGUID              Guid,
    IN     ULONG               Index
    );

BOOL
DeviceCollectionCheckIfAllRemoved(
    IN  PDEVICE_COLLECTION  DeviceCollection
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\driver.h ===
extern "C" {                   
#include <shimdb.h>
}


#ifndef __BLOCKEDDRIVERS_H_
#define __BLOCKEDDRIVERS_H_

#include "resource.h"

/////////////////////////////////////////////////////////////////////////////
// CBlockedDrivers
class ATL_NO_VTABLE CBlockedDrivers : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CBlockedDrivers, &CLSID_BlockedDrivers>,
	public IDispatchImpl<IBlockedDrivers, &IID_IBlockedDrivers, &LIBID_BLOCKDRIVERLib>
{
protected:
    LPGUID m_guidIDs;


public:
    CBlockedDrivers()
	{
        m_guidIDs = NULL;
	}
    ~CBlockedDrivers()
    {
        if (m_guidIDs) {
            delete m_guidIDs;
        }
    }

DECLARE_REGISTRY_RESOURCEID(IDR_BLKDRV)
DECLARE_NOT_AGGREGATABLE(CBlockedDrivers)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CBlockedDrivers)
	COM_INTERFACE_ENTRY(IBlockedDrivers)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IBlockedDrivers
public:
	STDMETHOD(BlockedDrivers)(/*[out,retval]*/ LPDISPATCH * pCollection);
};

#endif //__BLOCKEDDRIVERS_H_


#ifndef __DRIVER_H_
#define __DRIVER_H_

/////////////////////////////////////////////////////////////////////////////
// CDriver
class ATL_NO_VTABLE CDriver : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDriver, &IID_IDriver, &LIBID_BLOCKDRIVERLib>
{
protected:
    HAPPHELPINFOCONTEXT m_hAppHelpInfoContext;
	BSTR m_Name;
	BSTR m_Description;
	BSTR m_Manufacturer;
	BSTR m_HelpFile;
public:
	CDriver()
	{
        m_hAppHelpInfoContext = NULL;
		m_Name = NULL;
		m_Description = NULL;
		m_Manufacturer = NULL;
		m_HelpFile = NULL;
	}
	~CDriver();

DECLARE_NOT_AGGREGATABLE(CDriver)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDriver)
	COM_INTERFACE_ENTRY(IDriver)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDriver
public:
	BOOL Init(GUID *pguidDB, GUID *pguidID);
    BSTR GetValueFromDatabase(APPHELPINFORMATIONCLASS InfoClass);
	STDMETHOD(get_Name)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Manufacturer)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_HelpFile)(/*[out, retval]*/ BSTR *pVal);
};

#endif //__DRIVER_H_


#ifndef __DRIVERS_H_
#define __DRIVERS_H_

/////////////////////////////////////////////////////////////////////////////
// CDrivers
class CDriver;

class ATL_NO_VTABLE CDrivers : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public IDispatchImpl<IDrivers, &IID_IDrivers, &LIBID_BLOCKDRIVERLib>
{
protected:
	CDriver ** pDrivers;
	long Count;

public:
	BOOL SetDriver(long index,CDriver *pDriver);
	BOOL InitDriverList(long NewCount);

	CDrivers()
	{
		pDrivers = NULL;
		Count = 0;
	}
	~CDrivers();

DECLARE_NOT_AGGREGATABLE(CDrivers)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDrivers)
	COM_INTERFACE_ENTRY(IDrivers)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IDrivers
public:
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IUnknown** ppUnk);
	STDMETHOD(Item)(/*[in]*/ long Index,/*[out, retval]*/ LPDISPATCH * ppVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);

};

#endif //__DRIVERS_H_


#ifndef __DRIVERSENUM_H_
#define __DRIVERSENUM_H_

/////////////////////////////////////////////////////////////////////////////
// CDriversEnum
class CDriver;

class ATL_NO_VTABLE CDriversEnum : 
	public IDriversEnum,
	public CComObjectRootEx<CComSingleThreadModel>
{
protected:
	CDriver ** pDrivers;
	long Count;
	long Position;

public:
	BOOL InternalCopyDrivers(CDriver **pArray,long Count);

	CDriversEnum()
	{
		pDrivers = NULL;
		Count = 0;
		Position = 0;
	}

	~CDriversEnum();



DECLARE_NOT_AGGREGATABLE(CDriversEnum)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDriversEnum)
	COM_INTERFACE_ENTRY(IDriversEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()

// IEnumVARIANT
public:
    STDMETHOD(Next)(
                /*[in]*/ ULONG celt,
                /*[out, size_is(celt), length_is(*pCeltFetched)]*/ VARIANT * rgVar,
                /*[out]*/ ULONG * pCeltFetched
            );
    STDMETHOD(Skip)(
                /*[in]*/ ULONG celt
            );

    STDMETHOD(Reset)(
            );

    STDMETHOD(Clone)(
                /*[out]*/ IEnumVARIANT ** ppEnum
            );
};

#endif //__DRIVERSENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\hotplug.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       hotplug.h
//
//--------------------------------------------------------------------------

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <stdio.h>
#include <cpl.h>
#include <commctrl.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <devguid.h>
#include <dbt.h>
#include <help.h>
#include <systrayp.h>
#include <shobjidl.h>

extern "C" {
#include <setupapi.h>
#include <spapip.h>
#include <cfgmgr32.h>
#include <shimdb.h>
#include <regstr.h>
}

#include <strsafe.h>

#pragma warning( default : 4201 )

#include "resource.h"
#include "devicecol.h"

#define STWM_NOTIFYHOTPLUG  STWM_NOTIFYPCMCIA
#define STSERVICE_HOTPLUG   STSERVICE_PCMCIA
#define HOTPLUG_REGFLAG_NOWARN PCMCIA_REGFLAG_NOWARN
#define HOTPLUG_REGFLAG_VIEWALL (PCMCIA_REGFLAG_NOWARN << 1)

#define TIMERID_DEVICECHANGE 4321

#define ARRAYLEN(array)     (sizeof(array) / sizeof(array[0]))


INT_PTR CALLBACK
DevTreeDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
RemoveConfirmDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

INT_PTR CALLBACK
SurpriseWarnDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   );

LRESULT CALLBACK
SafeRemovalBalloonProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

LRESULT CALLBACK
DockSafeRemovalBalloonProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


extern HMODULE hHotPlug;


typedef struct _DeviceTreeNode {
  LIST_ENTRY SiblingEntry;
  LIST_ENTRY ChildSiblingList;
  PTCHAR     InstanceId;
  PTCHAR     FriendlyName;
  PTCHAR     DeviceDesc;
  PTCHAR     DriveList;
  PTCHAR     Location;
  struct _DeviceTreeNode *ParentNode;
  struct _DeviceTreeNode *NextChildRemoval;
  HTREEITEM  hTreeItem;
  DEVINST    DevInst;
  GUID       ClassGuid;
  DWORD      Capabilities;
  int        TreeDepth;
  PDEVINST   EjectRelations;
  USHORT     NumEjectRelations;
  PDEVINST   RemovalRelations;
  USHORT     NumRemovalRelations;
  ULONG      Problem;
  ULONG      DevNodeStatus;
  BOOL       bCopy;
} DEVTREENODE, *PDEVTREENODE;


typedef struct _DeviceTreeData {
   DWORD Size;
   HWND hwndTree;
   HWND hDlg;
   HWND hwndRemove;
   int  TreeDepth;
   PDEVTREENODE SelectedTreeNode;
   PDEVTREENODE ChildRemovalList;
   LIST_ENTRY ChildSiblingList;
   DEVINST    DevInst;
   PTCHAR     EjectDeviceInstanceId;
   SP_CLASSIMAGELIST_DATA ClassImageList;
   BOOLEAN    ComplexView;
   BOOLEAN    HotPlugTree;
   BOOLEAN    AllowRefresh;
   BOOLEAN    RedrawWait;
   BOOLEAN    RefreshEvent;
} DEVICETREE, *PDEVICETREE;

#define SIZECHARS(x) (sizeof((x))/sizeof(TCHAR))


void
OnContextHelp(
  LPHELPINFO HelpInfo,
  PDWORD ContextHelpIDs
  );

//
// from init.c
//
DWORD
WINAPI
HandleVetoedOperation(
    LPWSTR              szCmd,
    VETOED_OPERATION    RemovalVetoType
    );

//
// from devtree.c
//

LONG
AddChildSiblings(
    PDEVICETREE  DeviceTree,
    PDEVTREENODE ParentNode,
    DEVINST      DeviceInstance,
    int          TreeDepth,
    BOOL         Recurse
    );

void
RemoveChildSiblings(
    PDEVICETREE  DeviceTree,
    PLIST_ENTRY  ChildSiblingList
    );

PTCHAR
FetchDeviceName(
     PDEVTREENODE DeviceTreeNode
     );

BOOL
DisplayChildSiblings(
    PDEVICETREE  DeviceTree,
    PLIST_ENTRY  ChildSiblingList,
    HTREEITEM    hParentTreeItem,
    BOOL         RemovableParent
    );


void
AddChildRemoval(
    PDEVICETREE DeviceTree,
    PLIST_ENTRY ChildSiblingList
    );


void
ClearRemovalList(
    PDEVICETREE  DeviceTree
    );


PDEVTREENODE
DevTreeNodeByInstanceId(
    PTCHAR InstanceId,
    PLIST_ENTRY ChildSiblingList
    );

PDEVTREENODE
DevTreeNodeByDevInst(
    DEVINST DevInst,
    PLIST_ENTRY ChildSiblingList
    );


PDEVTREENODE
TopLevelRemovalNode(
    PDEVICETREE DeviceTree,
    PDEVTREENODE DeviceTreeNode
    );

void
AddEjectToRemoval(
    PDEVICETREE DeviceTree
    );

extern TCHAR szUnknown[64];
extern TCHAR szHotPlugFlags[];




//
// notify.c
//
void
OnTimerDeviceChange(
   PDEVICETREE DeviceTree
   );


BOOL
RefreshTree(
   PDEVICETREE DeviceTree
   );



//
// miscutil.c
//
VOID
HotPlugPropagateMessage(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    );

void
InvalidateTreeItemRect(
   HWND hwndTree,
   HTREEITEM  hTreeItem
   );

DWORD
GetHotPlugFlags(
   PHKEY phKey
   );

PTCHAR
BuildFriendlyName(
   DEVINST DevInst
   );

PTCHAR
BuildLocationInformation(
   DEVINST DevInst
   );

LPTSTR
DevNodeToDriveLetter(
    DEVINST DevInst
    );

BOOL
IsHotPlugDevice(
    DEVINST DevInst
    );

BOOL
OpenPipeAndEventHandles(
    LPWSTR szCmd,
    LPHANDLE lphHotPlugPipe,
    LPHANDLE lphHotPlugEvent
    );

BOOL
VetoedRemovalUI(
    IN  PVETO_DEVICE_COLLECTION VetoedRemovalCollection
    );

void
DisplayDriverBlockBalloon(
    IN  PDEVICE_COLLECTION blockedDriverCollection
    );

void
DisplayChildWithInvalidIdBalloon(
    IN  PDEVICE_COLLECTION childWithInvalidIdCollection
    );


#define WUM_EJECTDEVINST  (WM_USER+279)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\hotplug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       hotplug.cpp
//
//--------------------------------------------------------------------------

#include "HotPlug.h"

TCHAR szUnknown[64];

TCHAR szHotPlugFlags[]=TEXT("HotPlugFlags");
TCHAR HOTPLUG_NOTIFY_CLASS_NAME[] = TEXT("HotPlugNotifyClass");


typedef int
(*PDEVICEPROPERTIES)(
                    HWND hwndParent,
                    LPTSTR MachineName,
                    LPTSTR DeviceID,
                    BOOL ShowDeviceTree
                    );


//
// colors used to highlight removal relationships for selected device
//
COLORREF RemovalImageBkColor;
COLORREF NormalImageBkColor;
COLORREF RemovalTextColor;

HWND g_hwndNotify = NULL;
HMODULE hDevMgr=NULL;
PDEVICEPROPERTIES pDeviceProperties = NULL;

#define IDH_DISABLEHELP         ((DWORD)(-1))
#define IDH_hwwizard_devices_list       15301   //  (SysTreeView32)
#define idh_hwwizard_stop               15305   // "&Stop" (Button)
#define idh_hwwizard_display_components 15307   //  "&Display device components" (Button)
#define idh_hwwizard_properties         15311   //  "&Properties" (Button)
#define idh_hwwizard_close              15309   //  "&Close" (Button)

DWORD UnplugtHelpIDs[] = {
    IDC_STOPDEVICE,    idh_hwwizard_stop,               // "&Stop" (Button)
    IDC_PROPERTIES,    idh_hwwizard_properties,         //  "&Properties" (Button)
    IDC_VIEWOPTION,    idh_hwwizard_display_components, //  "&Display device components" (Button)
    IDC_DEVICETREE,    IDH_hwwizard_devices_list,       // "" (SysTreeView32)
    IDCLOSE,           idh_hwwizard_close,
    IDC_HDWDEVICES,    NO_HELP,
    IDC_NOHELP1,       NO_HELP,
    IDC_NOHELP2,       NO_HELP,
    IDC_NOHELP3,       NO_HELP,
    IDC_DEVICEDESC,    NO_HELP,
    0,0
};

void
OnRemoveDevice(
              HWND hDlg,
              PDEVICETREE DeviceTree
              )
{
    PDEVTREENODE DeviceTreeNode;

    DeviceTreeNode = DeviceTree->ChildRemovalList;

    if (!DeviceTreeNode) {

        return;
    }

    //
    // Confirm with the user that they really want
    // to remove this device and all of its attached devices.
    // The dialog returns standard IDOK, IDCANCEL etc. for results.
    // if anything besides IDOK  don't do anything.
    //
    DialogBoxParam(hHotPlug,
                   MAKEINTRESOURCE(DLG_CONFIRMREMOVE),
                   hDlg,
                   RemoveConfirmDlgProc,
                   (LPARAM)DeviceTree
                  );

    return;
}

void
OnTvnSelChanged(
               PDEVICETREE DeviceTree,
               NM_TREEVIEW *nmTreeView
               )
{
    PDEVTREENODE DeviceTreeNode = (PDEVTREENODE)(nmTreeView->itemNew.lParam);
    PTCHAR DeviceName;
    ULONG DevNodeStatus, Problem;
    CONFIGRET ConfigRet;
    TCHAR Buffer[MAX_PATH*2];

    if (DeviceTree->RedrawWait) {

        return;
    }


    //
    // Clear Removal list for previously selected Node
    //
    ClearRemovalList(DeviceTree);


    //
    // Save the selected treenode.
    //
    DeviceTree->SelectedTreeNode = DeviceTreeNode;

    //
    // No device is selected
    //
    if (!DeviceTreeNode) {

        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_STOPDEVICE), FALSE);
        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_PROPERTIES), FALSE);
        SetDlgItemText(DeviceTree->hDlg, IDC_DEVICEDESC, TEXT(""));
        return;
    }

    //
    // reset the text for the selected item
    //
    DeviceName = FetchDeviceName(DeviceTreeNode);

    if (!DeviceName) {

        DeviceName = szUnknown;
    }

    StringCchPrintf(Buffer,
                    SIZECHARS(Buffer),
                    TEXT("%s %s"),
                    DeviceName,
                    DeviceTreeNode->Location  ? DeviceTreeNode->Location : TEXT("")
                    );

    SetDlgItemText(DeviceTree->hDlg, IDC_DEVICEDESC, Buffer);

    //
    // Turn on the stop\eject button, and set text accordingly.
    //
    ConfigRet = CM_Get_DevNode_Status_Ex(&DevNodeStatus,
                                         &Problem,
                                         DeviceTreeNode->DevInst,
                                         0,
                                         NULL
                                        );
    if (ConfigRet != CR_SUCCESS) {

        DevNodeStatus = 0;
        Problem = 0;
    }

    //
    // Any removable (but not surprise removable) device is OK, except
    // if the user already removed it.
    //
    if (Problem != CM_PROB_HELD_FOR_EJECT) {

        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_STOPDEVICE), TRUE);

    } else {

        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_STOPDEVICE), FALSE);
    }

    EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_PROPERTIES), TRUE);

    //
    // reset the overlay icons if device state has changed
    //
    if (DeviceTreeNode->Problem != Problem || DeviceTreeNode->DevNodeStatus != DevNodeStatus) {

        TV_ITEM tv;

        tv.mask = TVIF_STATE;
        tv.stateMask = TVIS_OVERLAYMASK;
        tv.hItem = DeviceTreeNode->hTreeItem;

        if (DeviceTreeNode->Problem == CM_PROB_DISABLED) {

            tv.state = INDEXTOOVERLAYMASK(IDI_DISABLED_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);

        } else if (DeviceTreeNode->Problem) {

            tv.state = INDEXTOOVERLAYMASK(IDI_PROBLEM_OVL - IDI_CLASSICON_OVERLAYFIRST + 1);

        } else {

            tv.state = INDEXTOOVERLAYMASK(0);
        }

        TreeView_SetItem(DeviceTree->hwndTree, &tv);
    }


    //
    // Starting from the TopLevel removal node, build up the removal lists
    //
    DeviceTreeNode = TopLevelRemovalNode(DeviceTree, DeviceTreeNode);

    //
    // Add devices to ChildRemoval list
    //
    DeviceTree->ChildRemovalList = DeviceTreeNode;
    DeviceTreeNode->NextChildRemoval = DeviceTreeNode;
    InvalidateTreeItemRect(DeviceTree->hwndTree, DeviceTreeNode->hTreeItem);
    AddChildRemoval(DeviceTree, &DeviceTreeNode->ChildSiblingList);

    //
    // Add eject amd removal relations
    //
    AddEjectToRemoval(DeviceTree);
}

int
OnCustomDraw(
            HWND hDlg,
            PDEVICETREE DeviceTree,
            LPNMTVCUSTOMDRAW nmtvCustomDraw
            )
{
    PDEVTREENODE DeviceTreeNode = (PDEVTREENODE)(nmtvCustomDraw->nmcd.lItemlParam);

    UNREFERENCED_PARAMETER(hDlg);

    if (nmtvCustomDraw->nmcd.dwDrawStage == CDDS_PREPAINT) {
        return CDRF_NOTIFYITEMDRAW;
    }

    //
    // If this node is in the Removal list, then do special
    // highlighting.
    //
    if (DeviceTreeNode->NextChildRemoval) {

        //
        // set text color if its not the selected item
        //

        if (DeviceTree->SelectedTreeNode != DeviceTreeNode) {
            nmtvCustomDraw->clrText = RemovalTextColor;
        }

        //
        // Highlight the image-icon background
        //
        ImageList_SetBkColor(DeviceTree->ClassImageList.ImageList,
                             RemovalImageBkColor
                            );
    } else {

        //
        // Normal image-icon background
        //
        ImageList_SetBkColor(DeviceTree->ClassImageList.ImageList,
                             NormalImageBkColor
                            );
    }

    return CDRF_DODEFAULT;
}

void
OnSysColorChange(
                HWND hDlg,
                PDEVICETREE DeviceTree
                )
{
    COLORREF ColorWindow, ColorHighlight;
    BYTE Red, Green, Blue;

    UNREFERENCED_PARAMETER(hDlg);

    //
    // Fetch the colors used for removal highlighting
    //
    ColorWindow = GetSysColor(COLOR_WINDOW);
    ColorHighlight = GetSysColor(COLOR_HIGHLIGHT);

    Red = (BYTE)(((WORD)GetRValue(ColorWindow) + (WORD)GetRValue(ColorHighlight)) >> 1);
    Green = (BYTE)(((WORD)GetGValue(ColorWindow) + (WORD)GetGValue(ColorHighlight)) >> 1);
    Blue = (BYTE)(((WORD)GetBValue(ColorWindow) + (WORD)GetBValue(ColorHighlight)) >> 1);

    RemovalImageBkColor = RGB(Red, Green, Blue);
    RemovalTextColor = ColorHighlight;
    NormalImageBkColor = ColorWindow;

    //
    // Update the ImageList Background color
    //
    if (DeviceTree->ClassImageList.cbSize) {
        ImageList_SetBkColor(DeviceTree->ClassImageList.ImageList,
                             ColorWindow
                            );
    }
}

void
OnTvnItemExpanding(
                  HWND hDlg,
                  NM_TREEVIEW *nmTreeView
                  )
{
    PDEVTREENODE DeviceTreeNode = (PDEVTREENODE)(nmTreeView->itemNew.lParam);

    //
    // don't allow collapse of root items with children
    //
    if (!DeviceTreeNode->ParentNode &&
        (nmTreeView->action == TVE_COLLAPSE ||
         nmTreeView->action == TVE_COLLAPSERESET ||
         (nmTreeView->action == TVE_TOGGLE &&
          (nmTreeView->itemNew.state & TVIS_EXPANDED))) ) {
        SetDlgMsgResult(hDlg, WM_NOTIFY, TRUE);
    } else {
        SetDlgMsgResult(hDlg, WM_NOTIFY, FALSE);
    }
}

void
OnContextMenu(
             HWND hDlg,
             PDEVICETREE DeviceTree
             )
{
    int IdCmd;
    POINT ptPopup;
    RECT rect;
    HMENU hMenu;
    PDEVTREENODE DeviceTreeNode;
    TCHAR Buffer[MAX_PATH];

    DeviceTreeNode = DeviceTree->SelectedTreeNode;
    if (!DeviceTreeNode) {
        return;
    }

    TreeView_GetItemRect(DeviceTree->hwndTree,
                         DeviceTreeNode->hTreeItem,
                         &rect,
                         TRUE
                        );

    ptPopup.x = (rect.left+rect.right)/2;
    ptPopup.y = (rect.top+rect.bottom)/2;
    ClientToScreen(DeviceTree->hwndTree, &ptPopup);

    hMenu = CreatePopupMenu();
    if (!hMenu) {
        return;
    }

    //
    // if device is running add stop item
    //
    if (DeviceTreeNode->DevNodeStatus & DN_STARTED) {

        LoadString(hHotPlug,
                   IDS_STOP,
                   Buffer,
                   SIZECHARS(Buffer)
                  );

        AppendMenu(hMenu, MF_STRING, IDC_STOPDEVICE, Buffer);
    }

    //
    // add Properties item (link to device mgr).
    //
    LoadString(hHotPlug,
               IDS_PROPERTIES,
               Buffer,
               SIZECHARS(Buffer)
              );

    AppendMenu(hMenu, MF_STRING, IDC_PROPERTIES, Buffer);

    IdCmd = TrackPopupMenu(hMenu,
                           TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_NONOTIFY,
                           ptPopup.x,
                           ptPopup.y,
                           0,
                           hDlg,
                           NULL
                          );

    DestroyMenu(hMenu);

    if (!IdCmd) {

        return;
    }

    switch (IdCmd) {
    case IDC_STOPDEVICE:
        OnRemoveDevice(hDlg, DeviceTree);
        break;

    case IDC_PROPERTIES: {
            if (pDeviceProperties) {
                (*pDeviceProperties)(
                                    hDlg,
                                    NULL,
                                    DeviceTreeNode->InstanceId,
                                    FALSE
                                    );
            }
        }
        break;
    }

    return;
}

void
OnRightClick(
            HWND hDlg,
            PDEVICETREE DeviceTree,
            NMHDR * nmhdr
            )
{
    DWORD dwPos;
    TV_ITEM tvi;
    TV_HITTESTINFO tvht;
    PDEVTREENODE DeviceTreeNode;

    UNREFERENCED_PARAMETER(hDlg);

    if (nmhdr->hwndFrom != DeviceTree->hwndTree) {
        return;
    }

    dwPos = GetMessagePos();

    tvht.pt.x = LOWORD(dwPos);
    tvht.pt.y = HIWORD(dwPos);

    ScreenToClient(DeviceTree->hwndTree, &tvht.pt);
    tvi.hItem = TreeView_HitTest(DeviceTree->hwndTree, &tvht);
    if (!tvi.hItem) {
        return;
    }

    tvi.mask = TVIF_PARAM;
    if (!TreeView_GetItem(DeviceTree->hwndTree, &tvi)) {
        return;
    }

    DeviceTreeNode = (PDEVTREENODE)tvi.lParam;
    if (!DeviceTreeNode) {
        return;
    }

    //
    // Make the current right click item, the selected item
    //
    if (DeviceTreeNode != DeviceTree->SelectedTreeNode) {
        TreeView_SelectItem(DeviceTree->hwndTree, DeviceTreeNode->hTreeItem);
    }
}

void
OnViewOptionClicked(
                   HWND hDlg,
                   PDEVICETREE DeviceTree
                   )
{
    BOOL bChecked;
    DWORD HotPlugFlags, NewFlags;
    HKEY hKey = NULL;

    //
    // checked means "show complex view"
    //
    bChecked = IsDlgButtonChecked(hDlg, IDC_VIEWOPTION);


    //
    // Update HotPlugs registry if needed.
    //
    NewFlags = HotPlugFlags = GetHotPlugFlags(&hKey);

    if (hKey) {

        if (bChecked) {

            NewFlags |= HOTPLUG_REGFLAG_VIEWALL;
        } else {

            NewFlags &= ~HOTPLUG_REGFLAG_VIEWALL;
        }

        if (NewFlags != HotPlugFlags) {

            RegSetValueEx(hKey,
                          szHotPlugFlags,
                          0,
                          REG_DWORD,
                          (LPBYTE)&NewFlags,
                          sizeof(NewFlags)
                         );
        }

        if (hKey) {

            RegCloseKey(hKey);
        }
    }

    if (!DeviceTree->ComplexView && bChecked) {

        DeviceTree->ComplexView = TRUE;
    } else if (DeviceTree->ComplexView && !bChecked) {

        DeviceTree->ComplexView = FALSE;
    } else {

        // we are in the correct state, nothing to do.
        return;
    }

    //
    // redraw the entire tree.
    //
    RefreshTree(DeviceTree);

    return;
}

LRESULT
hotplugNotifyWndProc(
                    HWND hWnd,
                    UINT uMsg,
                    WPARAM wParam,
                    LPARAM lParam
                    )
{
    HWND hMainWnd;
    hMainWnd = (HWND)GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch (uMsg) {
    case WM_CREATE:
        hMainWnd =  (HWND)((CREATESTRUCT*)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR)hMainWnd);
        break;

    case WM_DEVICECHANGE:
        if (DBT_DEVNODES_CHANGED == wParam) {
            //
            // While we are in WM_DEVICECHANGE context,
            // no CM apis can be called because it would
            // deadlock. Here, we schedule a timer so that
            // we can handle the message later on.
            //
            SetTimer(hMainWnd, TIMERID_DEVICECHANGE, 1000, NULL);
        }
        break;

    default:
        break;
    }

    return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

BOOL
CreateNotifyWindow(
                  HWND hWnd
                  )
{
    WNDCLASS wndClass;

    if (!GetClassInfo(hHotPlug, HOTPLUG_NOTIFY_CLASS_NAME, &wndClass)) {

        ZeroMemory(&wndClass, sizeof(wndClass));
        wndClass.lpfnWndProc = hotplugNotifyWndProc;
        wndClass.hInstance = hHotPlug;
        wndClass.lpszClassName = HOTPLUG_NOTIFY_CLASS_NAME;

        if (!RegisterClass(&wndClass)) {

            return FALSE;
        }
    }

    g_hwndNotify = CreateWindowEx(WS_EX_TOOLWINDOW,
                                  HOTPLUG_NOTIFY_CLASS_NAME,
                                  TEXT(""),
                                  WS_DLGFRAME | WS_BORDER | WS_DISABLED,
                                  CW_USEDEFAULT,
                                  CW_USEDEFAULT,
                                  0,
                                  0,
                                  NULL,
                                  NULL,
                                  hHotPlug,
                                  (void *)hWnd
                                 );

    return(NULL != g_hwndNotify);
}

BOOL
InitDevTreeDlgProc(
                  HWND hDlg,
                  PDEVICETREE DeviceTree
                  )
{
    CONFIGRET ConfigRet;
    HWND hwndTree;
    DWORD HotPlugFlags;
    HICON hIcon;
    HWND hwndParent;

    DeviceTree->AllowRefresh = TRUE;

    CreateNotifyWindow(hDlg);

    hDevMgr = LoadLibrary(TEXT("devmgr.dll"));

    if (hDevMgr) {

        pDeviceProperties = (PDEVICEPROPERTIES)GetProcAddress(hDevMgr, "DevicePropertiesW");
    }

    hIcon = LoadIcon(hHotPlug,MAKEINTRESOURCE(IDI_HOTPLUGICON));
    if (hIcon) {

        SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        SendMessage(hDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
    }

    hwndParent = GetParent(hDlg);

    if (hwndParent) {

        SendMessage(hwndParent, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        SendMessage(hwndParent, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
    }

    DeviceTree->hDlg     = hDlg;
    DeviceTree->hwndTree = hwndTree = GetDlgItem(hDlg, IDC_DEVICETREE);

    LoadString(hHotPlug,
               IDS_UNKNOWN,
               (PTCHAR)szUnknown,
               SIZECHARS(szUnknown)
              );

    //
    // Disable the Stop button, until an item is selected.
    //
    EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_STOPDEVICE), FALSE);

    EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_PROPERTIES), FALSE);

    //
    // Get the Class Icon Image Lists
    //
    DeviceTree->ClassImageList.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);
    if (SetupDiGetClassImageList(&DeviceTree->ClassImageList)) {

        TreeView_SetImageList(hwndTree, DeviceTree->ClassImageList.ImageList, TVSIL_NORMAL);

    } else {

        DeviceTree->ClassImageList.cbSize = 0;
    }

    OnSysColorChange(hDlg, DeviceTree);

    HotPlugFlags = GetHotPlugFlags(NULL);
    if (HotPlugFlags & HOTPLUG_REGFLAG_VIEWALL) {

        DeviceTree->ComplexView = TRUE;
        CheckDlgButton(hDlg, IDC_VIEWOPTION, BST_CHECKED);

    } else {

        DeviceTree->ComplexView = FALSE;
        CheckDlgButton(hDlg, IDC_VIEWOPTION, BST_UNCHECKED);
    }

    //
    // Get the root devnode.
    //
    ConfigRet = CM_Locate_DevNode_Ex(&DeviceTree->DevInst,
                                     NULL,
                                     CM_LOCATE_DEVNODE_NORMAL,
                                     NULL
                                    );

    if (ConfigRet != CR_SUCCESS) {

        return FALSE;
    }

    RefreshTree(DeviceTree);


    if (DeviceTree->EjectDeviceInstanceId) {

        DEVINST EjectDevInst;
        PDEVTREENODE DeviceTreeNode;

        //
        // we are removing a specific device, find it
        // and post a message to trigger device removal.
        //
        ConfigRet = CM_Locate_DevNode_Ex(&EjectDevInst,
                                         DeviceTree->EjectDeviceInstanceId,
                                         CM_LOCATE_DEVNODE_NORMAL,
                                         NULL
                                        );


        if (ConfigRet != CR_SUCCESS) {

            return FALSE;
        }

        DeviceTreeNode = DevTreeNodeByDevInst(EjectDevInst,
                                              &DeviceTree->ChildSiblingList
                                             );

        if (!DeviceTreeNode) {

            return FALSE;
        }

        TreeView_SelectItem(hwndTree, DeviceTreeNode->hTreeItem);
        PostMessage(hDlg, WUM_EJECTDEVINST, 0, 0);

    } else {

        ShowWindow(hDlg, SW_SHOW);
    }

    return TRUE;
}

void
OnContextHelp(
             LPHELPINFO HelpInfo,
             PDWORD ContextHelpIDs
             )
{
    //
    // Define an array of dword pairs,
    // where the first of each pair is the control ID,
    // and the second is the context ID for a help topic,
    // which is used in the help file.
    //
    if (HelpInfo->iContextType == HELPINFO_WINDOW) {  // must be for a control

        WinHelp((HWND)HelpInfo->hItemHandle,
                TEXT("hardware.hlp"),
                HELP_WM_HELP,
                (DWORD_PTR)(void *)ContextHelpIDs
               );
    }

}

INT_PTR CALLBACK DevTreeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    PDEVICETREE DeviceTree = NULL;

    if (message == WM_INITDIALOG) {
        DeviceTree = (PDEVICETREE)lParam;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)DeviceTree);

        if (DeviceTree) {
            InitDevTreeDlgProc(hDlg, DeviceTree);
        }
        return TRUE;
    }

    DeviceTree = (PDEVICETREE)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message) {
    case WM_DESTROY:
        //
        // Destroy the Notification Window
        //
        if (g_hwndNotify && IsWindow(g_hwndNotify)) {
            DestroyWindow(g_hwndNotify);
            g_hwndNotify = NULL;
        }

        //
        // Clear the DeviceTree
        //
        TreeView_DeleteAllItems(DeviceTree->hwndTree);

        //
        // Clean up the class image list.
        //
        if (DeviceTree->ClassImageList.cbSize) {
            SetupDiDestroyClassImageList(&DeviceTree->ClassImageList);
            DeviceTree->ClassImageList.cbSize = 0;
        }

        //
        // Clean up the device tree
        //
        ClearRemovalList(DeviceTree);
        RemoveChildSiblings(DeviceTree, &DeviceTree->ChildSiblingList);

        if (hDevMgr) {
            FreeLibrary(hDevMgr);
            hDevMgr = NULL;
            pDeviceProperties = NULL;
        }
        break;

    case WM_CLOSE:
        SendMessage(hDlg, WM_COMMAND, IDCANCEL, 0L);
        break;

    case WM_COMMAND:
        {
            UINT Control = GET_WM_COMMAND_ID(wParam, lParam);
            UINT Cmd = GET_WM_COMMAND_CMD(wParam, lParam);

            switch (Control) {
            case IDC_VIEWOPTION:
                if (Cmd == BN_CLICKED) {
                    OnViewOptionClicked(hDlg, DeviceTree);
                }
                break;

            case IDC_STOPDEVICE:
                OnRemoveDevice(hDlg, DeviceTree);
                break;

            case IDOK:  // enter -> default  to expand\collapse the selected tree node
                if (DeviceTree->SelectedTreeNode) {
                    TreeView_Expand(DeviceTree->hwndTree,
                                    DeviceTree->SelectedTreeNode->hTreeItem, TVE_TOGGLE);
                }

                break;

            case IDC_PROPERTIES:
                if (DeviceTree->SelectedTreeNode && pDeviceProperties) {
                    (*pDeviceProperties)(hDlg,
                                         NULL,
                                         DeviceTree->SelectedTreeNode->InstanceId, FALSE);
                }
                break;

            case IDCLOSE:
            case IDCANCEL:
                EndDialog(hDlg, IDCANCEL);
                break;
            }

        }
        break;

        // Listen for Tree notifications
    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        case TVN_SELCHANGED:
            OnTvnSelChanged(DeviceTree, (NM_TREEVIEW *)lParam);
            break;

        case TVN_ITEMEXPANDING:
            OnTvnItemExpanding(hDlg, (NM_TREEVIEW *)lParam);
            break;

        case TVN_KEYDOWN:
            {
                TV_KEYDOWN *tvKeyDown = (TV_KEYDOWN *)lParam;

                if (tvKeyDown->wVKey == VK_DELETE) {
                    OnRemoveDevice(hDlg, DeviceTree);
                }
            }
            break;

        case NM_CUSTOMDRAW:
            if (IDC_DEVICETREE == ((NMHDR *)lParam)->idFrom) {
                SetDlgMsgResult(hDlg, WM_NOTIFY, OnCustomDraw(hDlg, DeviceTree, (NMTVCUSTOMDRAW *)lParam));
            }
            break;

        case NM_RETURN:
            // we don't get this in a dialog, see IDOK
            break;

        case NM_DBLCLK:
            OnRemoveDevice(hDlg, DeviceTree);
            SetDlgMsgResult(hDlg, WM_NOTIFY, TRUE);
            break;

        case NM_RCLICK:
            OnRightClick(hDlg, DeviceTree, (NMHDR *)lParam);
            break;

        default:
            return FALSE;
        }
        break;

    case WUM_EJECTDEVINST:
        OnRemoveDevice(hDlg, DeviceTree);
        EndDialog(hDlg, IDCANCEL);
        break;

    case WM_SYSCOLORCHANGE:
        HotPlugPropagateMessage(hDlg, message, wParam, lParam);
        OnSysColorChange(hDlg,DeviceTree);
        break;

    case WM_TIMER:
        if (TIMERID_DEVICECHANGE == wParam) {
            KillTimer(hDlg, TIMERID_DEVICECHANGE);
            DeviceTree->RefreshEvent = TRUE;

            if (DeviceTree->AllowRefresh) {
                OnTimerDeviceChange(DeviceTree);
            }
        }
        break;

    case WM_SETCURSOR:
        if (DeviceTree->RedrawWait || DeviceTree->RefreshEvent) {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 1);
            break;
        }
        return FALSE;

    case WM_CONTEXTMENU:
        //
        // handle kbd- shift-F10, mouse rclick is invoked from NM_RCLICK
        //
        if ((HWND)wParam == DeviceTree->hwndTree) {
            OnContextMenu(hDlg, DeviceTree);
            break;
        } else {
            WinHelp((HWND)wParam, TEXT("hardware.hlp"), HELP_CONTEXTMENU,
                    (DWORD_PTR)(void *)(PDWORD)UnplugtHelpIDs);
        }
        return FALSE;

    case WM_HELP:
        OnContextHelp((LPHELPINFO)lParam, (PDWORD)UnplugtHelpIDs);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\hardware.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       hardware.h
//
//--------------------------------------------------------------------------

#define IDH_hwwizard_devices_list       15301   //  (SysTreeView32)
#define idh_hwwizard_stop               15305   // "&Stop" (Button)
#define idh_hwwizard_display_components 15307   //  "&Display device components" (Button)
#define idh_hwwizard_show_icon          15308   // "Show &icon on taskbar" (Button)
#define idh_hwwizard_properties         15311   //  "&Properties" (Button)
#define idh_hwwizard_close              15309   //  "&Close" (Button)
#define idh_hwwizard_tshoot             15313   //Troubleshoot button

// "Stop a Hardware device" Dialog Box
#define idh_hwwizard_confirm_stop_list  15321   // "" (SysListView32)


// "Unsafe Removal of Device" Dialog Box
#define idh_hwwizard_unsafe_remove_list 15330  // "" (SysListView32)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\driver.cpp ===
// Driver.cpp : Implementation of CDriver
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include "stdafx.h"
#include "blkdrv.h"
#include "Driver.h"

extern "C" {
#include <cfgmgr32.h>
#include "cfgmgrp.h"
}


/////////////////////////////////////////////////////////////////////////////
// CBlockedDrivers


STDMETHODIMP CBlockedDrivers::BlockedDrivers(LPDISPATCH *pCollection)
{
	HRESULT hr;
	CComObject<CDrivers> *pDriversCollection = NULL;
	CComObject<CDriver> *pDriver = NULL;
	GUID guidDB;
    long Count = 0;

    hr = CComObject<CDrivers>::CreateInstance(&pDriversCollection);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pDriversCollection) {
		return E_OUTOFMEMORY;
	}
	pDriversCollection->AddRef();

    CONFIGRET cr;
    ULONG ulLength = 0;

    cr = CMP_GetBlockedDriverInfo(NULL, &ulLength, 0, NULL);

    if ((cr == CR_SUCCESS) && (ulLength == 0)) {
        //
        // No blocked drivers so set Count to zero to create an empty
        // collection.
        //
        Count = 0;

    } else if ((cr == CR_BUFFER_SMALL) && (ulLength > 0)) {
        //
        // Allocate some memory to hold the list of GUIDs
        //
        Count = ulLength/sizeof(GUID);
        m_guidIDs = new GUID[Count];

        if (m_guidIDs == NULL) {
            return E_OUTOFMEMORY;
        }

        cr = CMP_GetBlockedDriverInfo((LPBYTE)m_guidIDs, &ulLength, 0, NULL);

        if (cr != CR_SUCCESS) {
            return E_OUTOFMEMORY;
        }

        //
        // Open a handle to the database so we can get the database GUID.
        //
        if (!SdbGetStandardDatabaseGUID(SDB_DATABASE_MAIN_DRIVERS, &guidDB)) {
            return E_OUTOFMEMORY;
        }
    } else {
        //
        // We encountered an error.
        //
        return E_OUTOFMEMORY;
    }

    if(!pDriversCollection->InitDriverList(Count)) {
        pDriversCollection->Release();
        return E_OUTOFMEMORY;
    }

    for (long i=0; i<Count; i++) {
    	
    	hr = CComObject<CDriver>::CreateInstance(&pDriver);

    	if(FAILED(hr)) {
    		pDriversCollection->Release();
    		return hr;
    	}

    	pDriver->AddRef();

    	if(!pDriver->Init(&guidDB, &(m_guidIDs[i]))) {
            pDriver->Release();
            pDriversCollection->Release();
            return E_OUTOFMEMORY;
        }

        //
        // Add the driver to the list.
        //
        if(!pDriversCollection->SetDriver(i,pDriver)) {
            pDriver->Release();
            pDriversCollection->Release();
            return E_OUTOFMEMORY;
        }

    	pDriver->Release();
    }

    *pCollection = pDriversCollection;

	return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// CDriver

CDriver::~CDriver()
{
	if(m_Name) {
		SysFreeString(m_Name);
	}

	if(m_Description) {
		SysFreeString(m_Description);
	}

	if (m_Manufacturer) {
		SysFreeString(m_Manufacturer);
	}

	if (m_HelpFile) {
		SysFreeString(m_HelpFile);
	}

    if (m_hAppHelpInfoContext) {
        SdbCloseApphelpInformation(m_hAppHelpInfoContext);
    }
}

STDMETHODIMP CDriver::get_Name(BSTR *pVal)
{
	*pVal = SysAllocStringLen(m_Name,SysStringLen(m_Name));
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


STDMETHODIMP CDriver::get_Description(BSTR *pVal)
{
	*pVal = SysAllocStringLen(m_Description,SysStringLen(m_Description));
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


STDMETHODIMP CDriver::get_Manufacturer(BSTR *pVal)
{
	*pVal = SysAllocStringLen(m_Manufacturer,SysStringLen(m_Manufacturer));
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


STDMETHODIMP CDriver::get_HelpFile(BSTR *pVal)
{
	*pVal = SysAllocStringLen(m_HelpFile,SysStringLen(m_HelpFile));
	if(!*pVal) {
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

BSTR CDriver::GetValueFromDatabase(
    APPHELPINFORMATIONCLASS InfoClass
    )
{
    DWORD cbSize = 0;

    //
    // Query for the size
    //
    cbSize = SdbQueryApphelpInformation(m_hAppHelpInfoContext,
                                        InfoClass,
                                        NULL,
                                        0
                                        );

    if (cbSize == 0) {
        //
        // value must not exist.
        //
        return NULL;
    }

    PBYTE pBuffer = new BYTE[cbSize];

    if (pBuffer == NULL) {
        return NULL;
    }

    ZeroMemory(pBuffer, cbSize);

    cbSize = SdbQueryApphelpInformation(m_hAppHelpInfoContext,
                                        InfoClass,
                                        (LPVOID)pBuffer,
                                        cbSize
                                        );

    if (cbSize == 0) {
        return NULL;
    }

    BSTR bValue = SysAllocString((const OLECHAR *)pBuffer);

    delete [] pBuffer;

    return bValue;
}

BOOL CDriver::Init(GUID *pguidDB, GUID *pguidID)
{
	if(!pguidDB || !pguidID) {
		return FALSE;
	}

    m_hAppHelpInfoContext = SdbOpenApphelpInformation(pguidDB, pguidID);

    if (!m_hAppHelpInfoContext) {
        return FALSE;
    }

    m_Name = GetValueFromDatabase(ApphelpExeName);
	m_Description = GetValueFromDatabase(ApphelpAppName);
	m_Manufacturer = GetValueFromDatabase(ApphelpVendorName);
    m_HelpFile = GetValueFromDatabase(ApphelpHelpCenterURL);

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CDrivers

CDrivers::~CDrivers()
{
	long c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			if(pDrivers[c]) {
				pDrivers[c]->Release();
			}
		}
		delete [] pDrivers;
	}
}

STDMETHODIMP CDrivers::get_Count(long *pVal)
{
	*pVal = Count;
	return S_OK;
}

STDMETHODIMP CDrivers::Item(long Index, LPDISPATCH *ppVal)
{
	*ppVal = NULL;
	if(Index<1 || Index > Count) {
		return E_INVALIDARG;
	}
	Index--;
	pDrivers[Index]->AddRef();
	*ppVal = pDrivers[Index];

	return S_OK;
}

STDMETHODIMP CDrivers::get__NewEnum(IUnknown **ppUnk)
{
	*ppUnk = NULL;
	HRESULT hr;
	CComObject<CDriversEnum> *pEnum = NULL;
	hr = CComObject<CDriversEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	pEnum->AddRef();
	if(!pEnum->InternalCopyDrivers(pDrivers,Count)) {
		pEnum->Release();
		return E_OUTOFMEMORY;
	}

	*ppUnk = pEnum;

	return S_OK;
}

BOOL CDrivers::InitDriverList(long NewCount)
{
	long c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			if(pDrivers[c]) {
				pDrivers[c]->Release();
			}
		}
		delete [] pDrivers;
	}
	Count = 0;
	pDrivers = new CDriver*[NewCount];
	if(!pDrivers) {
		return NULL;
	}
	for(c=0;c<NewCount;c++) {
		pDrivers[c] = NULL;
	}
	Count = NewCount;
	return TRUE;
}

BOOL CDrivers::SetDriver(long index, CDriver *pDriver)
{
	if((index<0) || (index>=Count)) {
		return FALSE;
	}
	pDriver->AddRef();
	pDrivers[index] = pDriver;
	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CDriversEnum

CDriversEnum::~CDriversEnum()
{
	long c;
	if(pDrivers) {
		for(c=0;c<Count;c++) {
			pDrivers[c]->Release();
		}
		delete [] pDrivers;
	}
}


HRESULT CDriversEnum::Next(
                ULONG celt,
                VARIANT * rgVar,
                ULONG * pCeltFetched
            )
{
	ULONG fetched;
	CDriver *pDev;
	if(pCeltFetched) {
		*pCeltFetched = 0;
	}
	for(fetched = 0; fetched<celt && Position<Count ; fetched++,Position++) {
		VariantInit(&rgVar[fetched]);

		pDev = pDrivers[Position];
		pDev->AddRef();
		V_VT(&rgVar[fetched]) = VT_DISPATCH;
		V_DISPATCH(&rgVar[fetched]) = pDev;
	}
	if(pCeltFetched) {
		*pCeltFetched = fetched;
	}
	return (fetched<celt) ? S_FALSE : S_OK;
}

HRESULT CDriversEnum::Skip(
                ULONG celt
            )
{
	long remaining = Count-Position;
	if(remaining<(long)celt) {
		Position = Count;
		return S_FALSE;
	} else {
		Position += (long)celt;
		return S_OK;
	}
}

HRESULT CDriversEnum::Reset(
            )
{
	Position = 0;
	return S_OK;
}

HRESULT CDriversEnum::Clone(
                IEnumVARIANT ** ppEnum
            )
{
	*ppEnum = NULL;
	HRESULT hr;
	CComObject<CDriversEnum> *pEnum = NULL;
	hr = CComObject<CDriversEnum>::CreateInstance(&pEnum);
	if(FAILED(hr)) {
		return hr;
	}
	if(!pEnum) {
		return E_OUTOFMEMORY;
	}
	if(!pEnum->InternalCopyDrivers(pDrivers,Count)) {
		delete pEnum;
		return E_OUTOFMEMORY;
	}
	pEnum->Position = Position;

	pEnum->AddRef();
	*ppEnum = pEnum;

	return S_OK;
}


BOOL CDriversEnum::InternalCopyDrivers(CDriver **pArray, long NewCount)
{
	long c;

	if(pDrivers) {
		delete [] pDrivers;
		pDrivers = NULL;
	}

	Count = 0;
	Position = 0;
	pDrivers = new CDriver*[NewCount];
	if(!pDrivers) {
		return FALSE;
	}

	for(c=0;c<NewCount;c++) {
		pArray[c]->AddRef();
		pDrivers[c] = pArray[c];
		if(!pDrivers[c]) {
			Count = c;
			return FALSE;
		}
	}

	Count = NewCount;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\init.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       init.cpp
//
//--------------------------------------------------------------------------

#include "hotplug.h"

#define HOTPLUG_CLASS_NAME      TEXT("HotPlugClass")

VOID
HotPlugDeviceTree(
   HWND hwndParent,
   BOOLEAN HotPlugTree
   )
{
    CONFIGRET ConfigRet;
    DEVICETREE DeviceTree;

    ZeroMemory(&DeviceTree, sizeof(DeviceTree));

    DeviceTree.HotPlugTree = HotPlugTree;
    InitializeListHead(&DeviceTree.ChildSiblingList);

    DialogBoxParam(hHotPlug,
                   MAKEINTRESOURCE(DLG_DEVTREE),
                   hwndParent,
                   DevTreeDlgProc,
                   (LPARAM)&DeviceTree
                   );

    return;
}

DWORD
WINAPI
HotPlugRemovalVetoedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);
    
    return HandleVetoedOperation(szCmd, VETOED_REMOVAL);
}

DWORD
WINAPI
HotPlugEjectVetoedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);
    
    return HandleVetoedOperation(szCmd, VETOED_EJECT);
}

DWORD
WINAPI
HotPlugStandbyVetoedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);
    
    return HandleVetoedOperation(szCmd, VETOED_STANDBY);
}

DWORD
WINAPI
HotPlugHibernateVetoedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);
    
    return HandleVetoedOperation(szCmd, VETOED_HIBERNATE);
}

DWORD
WINAPI
HotPlugWarmEjectVetoedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);
    
    return HandleVetoedOperation(szCmd, VETOED_WARM_EJECT);
}

DWORD
WINAPI
HandleVetoedOperation(
    LPWSTR              szCmd,
    VETOED_OPERATION    VetoedOperation
    )
{
    HANDLE hPipeRead;
    HANDLE hEvent;
    PNP_VETO_TYPE vetoType;
    DWORD bytesRead;
    VETO_DEVICE_COLLECTION removalVetoCollection;

    //
    // Open the specified name pipe and event.
    //
    if (!OpenPipeAndEventHandles(szCmd,
                                 &hPipeRead,
                                 &hEvent)) {
        return 1;
    }

    ASSERT((hEvent != NULL) && (hEvent != INVALID_HANDLE_VALUE));
    ASSERT((hPipeRead != NULL) && (hPipeRead != INVALID_HANDLE_VALUE));

    //
    // The first DWORD is the VetoType
    //
    if (!ReadFile(hPipeRead,
                  (LPVOID)&vetoType,
                  sizeof(PNP_VETO_TYPE),
                  &bytesRead,
                  NULL)) {

        CloseHandle(hPipeRead);
        SetEvent(hEvent);
        CloseHandle(hEvent);
        return 1;
    }

    //
    // Now drain all the removal strings. Note that some of them will be
    // device instance paths (definitely the first)
    //
    DeviceCollectionBuildFromPipe(
        hPipeRead,
        CT_VETOED_REMOVAL_NOTIFICATION,
        (PDEVICE_COLLECTION) &removalVetoCollection
        );

    //
    // We are finished reading from the pipe, so close the handle and tell
    // umpnpmgr that it can continue.
    //
    CloseHandle(hPipeRead);
    SetEvent(hEvent);
    CloseHandle(hEvent);

    //
    // There should always be one device as that is the device who's removal
    // was vetoed.
    //
    ASSERT(removalVetoCollection.dc.NumDevices);

    //
    // Invent the VetoedOperation "VETOED_UNDOCK" from an eject containing
    // another dock.
    //
    if (removalVetoCollection.dc.DockInList) {

        if (VetoedOperation == VETOED_EJECT) {

            VetoedOperation = VETOED_UNDOCK;

        } else if (VetoedOperation == VETOED_WARM_EJECT) {

            VetoedOperation = VETOED_WARM_UNDOCK;
        }
    }

    removalVetoCollection.VetoType = vetoType;
    removalVetoCollection.VetoedOperation = VetoedOperation;

    VetoedRemovalUI(&removalVetoCollection);

    DeviceCollectionDestroy(
        (PDEVICE_COLLECTION) &removalVetoCollection
        );

    return 1;
}

DWORD
WINAPI
HotPlugSafeRemovalNotificationW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    HANDLE hPipeRead, hEvent;
    DEVICE_COLLECTION safeRemovalCollection;
    MSG Msg;
    WNDCLASS wndClass;
    HWND hSafeRemovalWnd;
    HANDLE hHotplugIconEvent;

    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);

    //
    // Open the specified name pipe and event.
    //
    if (!OpenPipeAndEventHandles(szCmd,
                                 &hPipeRead,
                                 &hEvent)) {

        return 1;
    }

    ASSERT((hEvent != NULL) && (hEvent != INVALID_HANDLE_VALUE));
    ASSERT((hPipeRead != NULL) && (hPipeRead != INVALID_HANDLE_VALUE));

    //
    // Read out the device ID list from the Pipe
    //
    DeviceCollectionBuildFromPipe(
        hPipeRead,
        CT_SAFE_REMOVAL_NOTIFICATION,
        &safeRemovalCollection
        );

    //
    // On success or error, we are finished reading from the pipe, so close the
    // handle and tell umpnpmgr it can continue.
    //
    CloseHandle(hPipeRead);
    SetEvent(hEvent);
    CloseHandle(hEvent);

    //
    // If we have any devices then bring up the safe removal dialog
    //
    if (safeRemovalCollection.NumDevices) {

        if (!GetClassInfo(hHotPlug, HOTPLUG_CLASS_NAME, &wndClass)) {

            ZeroMemory(&wndClass, sizeof(wndClass));
            wndClass.lpfnWndProc = (safeRemovalCollection.DockInList)
                                     ? DockSafeRemovalBalloonProc
                                     : SafeRemovalBalloonProc;
            wndClass.hInstance = hHotPlug;
            wndClass.lpszClassName = HOTPLUG_CLASS_NAME;

            if (!RegisterClass(&wndClass)) {
                goto clean0;
            }
        }

        //
        // In order to prevent multiple similar icons on the tray, we will
        // create a named event that will be used to serialize the UI.
        //
        // Note that if we can't create the event for some reason then we will just
        // display the UI.  This might cause multiple icons, but it is better
        // than not displaying any UI at all.
        //
        hHotplugIconEvent = CreateEvent(NULL,
                                        FALSE,
                                        TRUE,
                                        safeRemovalCollection.DockInList
                                            ? TEXT("Local\\Dock_TaskBarIcon_Event")
                                            : TEXT("Local\\HotPlug_TaskBarIcon_Event")
                                        );

        if (hHotplugIconEvent) {

            WaitForSingleObject(hHotplugIconEvent, INFINITE);
        }

        if (!safeRemovalCollection.DockInList) {
            //
            // First disable the hotplug service so that the icon will go away from
            // the taskbar.  We do this just in case there are any other hotplug devices
            // in the machine since we don't want multiple hotplug icons
            // showing up in the taskbar.
            //
            // NOTE: We don't need to do this for the safe to undock case since
            // the docking icon is different.
            //
            SysTray_EnableService(STSERVICE_HOTPLUG, FALSE);
        }

        hSafeRemovalWnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                                         HOTPLUG_CLASS_NAME,
                                         TEXT(""),
                                         WS_DLGFRAME | WS_BORDER | WS_DISABLED,
                                         CW_USEDEFAULT,
                                         CW_USEDEFAULT,
                                         0,
                                         0,
                                         NULL,
                                         NULL,
                                         hHotPlug,
                                         (LPVOID)&safeRemovalCollection
                                         );

        if (hSafeRemovalWnd != NULL) {

            while (IsWindow(hSafeRemovalWnd)) {

                if (GetMessage(&Msg, NULL, 0, 0)) {

                    TranslateMessage(&Msg);
                    DispatchMessage(&Msg);
                }
            }
        }

        //
        // Set the Event so the next surprise removal process can go to work
        // and then close the event handle.
        //
        if (hHotplugIconEvent) {

            SetEvent(hHotplugIconEvent);
            CloseHandle(hHotplugIconEvent);
        }

        if (!safeRemovalCollection.DockInList) {
            //
            // Re-enable the hotplug service so that the icon can show back up in
            // the taskbar if we have any hotplug devices.
            //
            SysTray_EnableService(STSERVICE_HOTPLUG, TRUE);
        }
    }

clean0:

    DeviceCollectionDestroy(&safeRemovalCollection);
    return 1;
}

DWORD
WINAPI
HotPlugDriverBlockedW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    HANDLE hPipeRead, hEvent;
    DEVICE_COLLECTION blockedDriverCollection;
    HANDLE hDriverBlockIconEvent = NULL;
    HANDLE hDriverBlockEvent = NULL;
    TCHAR  szEventName[MAX_PATH];

    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);

    //
    // Open the specified name pipe and event.
    //
    if (OpenPipeAndEventHandles(szCmd,
                                &hPipeRead,
                                &hEvent) == FALSE) {

        return 1;
    }

    ASSERT((hEvent != NULL) && (hEvent != INVALID_HANDLE_VALUE));
    ASSERT((hPipeRead != NULL) && (hPipeRead != INVALID_HANDLE_VALUE));

    //
    // Read out the list of blocked driver GUIDs from the Pipe.  Note that for
    // the CT_BLOCKED_DRIVER_NOTIFICATION collection type, we use only the
    // DeviceInstanceId field of each collection entry (which is OK because
    // MAX_GUID_STRING_LEN << MAX_DEVICE_ID_LEN).  All other fields are skipped.
    //
    DeviceCollectionBuildFromPipe(
        hPipeRead,
        CT_BLOCKED_DRIVER_NOTIFICATION,
        &blockedDriverCollection
        );

    //
    // On success or error, we are finished reading from the pipe, so close the
    // handle and tell umpnpmgr it can continue.
    //
    CloseHandle(hPipeRead);
    SetEvent(hEvent);
    CloseHandle(hEvent);

    //
    // Since the balloons can hang around for numerous seconds, or longer if 
    // there is no user input to the system, we need to make sure that we only
    // have one driver block event queued for any given type of driver block.
    // This way if there is an attempt to load a driver many times in a row, we
    // won't queue up numerous driver blocked ballons for the same driver.
    // We will do this by creating a local event that includes the GUID of the 
    // blocked driver or no GUID if we are showing the generic balloon.
    //
    if (SUCCEEDED(StringCchPrintf(szEventName,
                    SIZECHARS(szEventName),
                    TEXT("Local\\DRIVERBLOCK-%s"),
                    (blockedDriverCollection.NumDevices == 1)
                        ? DeviceCollectionGetDeviceInstancePath(&blockedDriverCollection, 0)
                        : TEXT("ALL")
                    ))) {
        
        hDriverBlockEvent = CreateEvent(NULL,
                                 FALSE,
                                 TRUE,
                                 szEventName
                                 );
    
        if (hDriverBlockEvent) {
            if (WaitForSingleObject(hDriverBlockEvent, 0) != WAIT_OBJECT_0) {
                //
                // This means that this driver block balloon is either being
                // displayed, or in the queue to be displayed, so we can just
                // exit this process.
                //
                goto clean0;
            }
        }
    }

    //
    // In order to prevent multipe driver blocked icons and ballons showing up
    // on the taskbar together and stepping on each other, we will create a
    // named event that will be used to serialize the driver blocked icons and 
    // balloon UI.
    //
    // Note that if we can't create the event for some reason then we will just
    // display the UI.  This might cause multiple driver blocked icons, but it
    // is better than not displaying any UI at all.
    //
    // Also note that we can coexist with normal hotplug icon. As such we have
    // a different event name and a different icon.
    //
    hDriverBlockIconEvent = CreateEvent(NULL,
                                    FALSE,
                                    TRUE,
                                    TEXT("Local\\HotPlug_DriverBlockedIcon_Event")
                                    );

    if (hDriverBlockIconEvent) {
        for (;;) {
            DWORD waitStatus;
            waitStatus = MsgWaitForMultipleObjects(1, 
                                                   &hDriverBlockIconEvent,
                                                   FALSE,
                                                   INFINITE,
                                                   QS_ALLINPUT);
    
            
            if (waitStatus == WAIT_OBJECT_0) {
                //
                // The current driver block icon went away so it is our turn.
                //
                break;
            } else if (waitStatus == (WAIT_OBJECT_0 + 1)) {
                //
                // Message in the queue.
                //
                MSG msg;
    
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    
                    if (msg.message == WM_CLOSE) {
                        goto clean0;
                    }
    
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            } else {
                //
                // This shouldn't happen.
                //
                goto clean0;
            }
        }
    }

    //
    // Show the balloon.
    //
    DisplayDriverBlockBalloon(&blockedDriverCollection);

    //
    // Since the balloon has now gone away, set the event so if we get another
    // block on the same driver it will display another balloon.
    //
    if (hDriverBlockEvent) {
        SetEvent(hDriverBlockEvent);
    }

clean0:

    //
    // Set the Event so the next blocked driver process can go to work and then
    // close the event handle.
    //
    if (hDriverBlockIconEvent) {
        SetEvent(hDriverBlockIconEvent);
        CloseHandle(hDriverBlockIconEvent);
    }

    if (hDriverBlockEvent) {
        CloseHandle(hDriverBlockEvent);
    }

    //
    // Destroy the collection.
    //
    DeviceCollectionDestroy(&blockedDriverCollection);

    return 1;
}

DWORD
WINAPI
HotPlugChildWithInvalidIdW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    HANDLE hPipeRead, hEvent;
    DEVICE_COLLECTION childWithInvalidIdCollection;
    HANDLE hChildWithInvalidIdIconEvent = NULL;
    HANDLE hChildWithInvalidIdEvent = NULL;
    TCHAR  szEventName[MAX_PATH];

    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);
    
    //
    // Open the specified name pipe and event.
    //
    if (!OpenPipeAndEventHandles(szCmd,
                                 &hPipeRead,
                                 &hEvent)) {

        return 1;
    }

    ASSERT((hEvent != NULL) && (hEvent != INVALID_HANDLE_VALUE));
    ASSERT((hPipeRead != NULL) && (hPipeRead != INVALID_HANDLE_VALUE));

    //
    // Read out the device instance Id of the parent that has a child device
    // with an invalid Id. Note, if we are passed multiple device instance
    // Ids, we will only display UI for the first one in the list.
    //
    DeviceCollectionBuildFromPipe(
        hPipeRead,
        CT_CHILD_WITH_INVALID_ID_NOTIFICATION,        
        &childWithInvalidIdCollection
        );

    //
    // On success or error, we are finished reading from the pipe, so close the
    // handle and tell umpnpmgr it can continue.
    //
    CloseHandle(hPipeRead);
    SetEvent(hEvent);
    CloseHandle(hEvent);

    //
    // Since the balloons can hang around for numerous seconds, or longer if 
    // there is no user input to the system, we need to make sure that we only
    // have one invalid child event queued for any given parent with an invalid 
    // child.
    //
    StringCchPrintf(szEventName,
                    SIZECHARS(szEventName),
                    TEXT("Local\\CHILDWITHINVALIDID-%s"),
                    DeviceCollectionGetDeviceInstancePath(&childWithInvalidIdCollection, 0)
                    );

    hChildWithInvalidIdEvent = CreateEvent(NULL,
                                           FALSE,
                                           TRUE,
                                           szEventName
                                           );

    if (hChildWithInvalidIdEvent) {
        if (WaitForSingleObject(hChildWithInvalidIdEvent, 0) != WAIT_OBJECT_0) {
            //
            // This means that this invalid child balloon is either being
            // displayed, or in the queue to be displayed, so we can just
            // exit this process.
            //
            goto clean0;
        }
    }

    //
    // In order to prevent multipe invalid child icons and ballons showing up
    // on the taskbar together and stepping on each other, we will create a
    // named event that will be used to serialize the invalid child icons and 
    // balloon UI.
    //
    // Note that if we can't create the event for some reason then we will just
    // display the UI.  This might cause multiple invalid child icons, but it
    // is better than not displaying any UI at all.
    //
    // Also note that we can coexist with normal hotplug icon. As such we have
    // a different event name and a different icon.
    //
    hChildWithInvalidIdIconEvent = CreateEvent(NULL,
                                               FALSE,
                                               TRUE,
                                               TEXT("Local\\HotPlug_ChildWithInvalidId_Event")
                                               );

    if (hChildWithInvalidIdIconEvent) {
        for (;;) {
            DWORD waitStatus;
            waitStatus = MsgWaitForMultipleObjects(1, 
                                                   &hChildWithInvalidIdIconEvent,
                                                   FALSE,
                                                   INFINITE,
                                                   QS_ALLINPUT);
    
            
            if (waitStatus == WAIT_OBJECT_0) {
                //
                // The current invalid child icon went away so it is our turn.
                //
                break;
            } else if (waitStatus == (WAIT_OBJECT_0 + 1)) {
                //
                // Message in the queue.
                //
                MSG msg;
    
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
                    
                    if (msg.message == WM_CLOSE) {
                        goto clean0;
                    }
    
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            } else {
                //
                // This shouldn't happen.
                //
                goto clean0;
            }
        }
    }

    //
    // Show the balloon.
    //
    DisplayChildWithInvalidIdBalloon(&childWithInvalidIdCollection);

    //
    // Since the balloon has now gone away, set the event so if we get another
    // invalid child device it will display another balloon.
    //
    if (hChildWithInvalidIdEvent) {
        SetEvent(hChildWithInvalidIdEvent);
    }

clean0:

    //
    // Set the Event so the next invalid child process can go to work and then
    // close the event handle.
    //
    if (hChildWithInvalidIdIconEvent) {
        SetEvent(hChildWithInvalidIdIconEvent);
        CloseHandle(hChildWithInvalidIdIconEvent);
    }

    if (hChildWithInvalidIdEvent) {
        CloseHandle(hChildWithInvalidIdEvent);
    }

    //
    // Destroy the collection.
    //
    DeviceCollectionDestroy(&childWithInvalidIdCollection);

    return 1;
}

LONG
CPlApplet(
    HWND  hWnd,
    WORD  uMsg,
    DWORD_PTR lParam1,
    LRESULT  lParam2
    )
{
    LPNEWCPLINFO lpCPlInfo;
    LPCPLINFO lpOldCPlInfo;

    UNREFERENCED_PARAMETER(lParam1);

    switch (uMsg) {
       case CPL_INIT:
           return TRUE;

       case CPL_GETCOUNT:
           return 1;

       case CPL_INQUIRE:
           lpOldCPlInfo = (LPCPLINFO)(LPARAM)lParam2;
           lpOldCPlInfo->lData = 0L;
           lpOldCPlInfo->idIcon = IDI_HOTPLUGICON;
           lpOldCPlInfo->idName = IDS_HOTPLUGNAME;
           lpOldCPlInfo->idInfo = IDS_HOTPLUGINFO;
           return TRUE;

       case CPL_NEWINQUIRE:
           lpCPlInfo = (LPNEWCPLINFO)(LPARAM)lParam2;
           lpCPlInfo->hIcon = LoadIcon(hHotPlug, MAKEINTRESOURCE(IDI_HOTPLUGICON));
           LoadString(hHotPlug, IDS_HOTPLUGNAME, lpCPlInfo->szName, SIZECHARS(lpCPlInfo->szName));
           LoadString(hHotPlug, IDS_HOTPLUGINFO, lpCPlInfo->szInfo, SIZECHARS(lpCPlInfo->szInfo));
           lpCPlInfo->dwHelpContext = IDH_HOTPLUGAPPLET;
           lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
           lpCPlInfo->lData = 0;
           lpCPlInfo->szHelpFile[0] = '\0';
           return TRUE;

       case CPL_DBLCLK:
           HotPlugDeviceTree(hWnd, TRUE);
           break;

       default:
           break;
       }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\miscutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       miscutil.cpp
//
//--------------------------------------------------------------------------

#include "HotPlug.h"
#include <initguid.h>
#include <ntddstor.h>
#include <wdmguid.h>

LPTSTR
FormatString(
    LPCTSTR format,
    ...
    )
{
    LPTSTR str = NULL;
    va_list arglist;
    va_start(arglist, format);

    if (FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                      format,
                      0,
                      MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                      (LPTSTR)&str,
                      0,
                      &arglist
                      ) == 0) {

        str = NULL;
    }

    va_end(arglist);

    return str;
}

PTCHAR
BuildLocationInformation(
    DEVINST DevInst
    )
{
    CONFIGRET ConfigRet;
    ULONG ulSize;
    DWORD UINumber;
    PTCHAR Location = NULL;
    PTCHAR ParentName = NULL;
    DEVINST DevInstParent;
    TCHAR szBuffer[MAX_PATH];
    TCHAR UINumberDescFormat[MAX_PATH];
    TCHAR szFormat[MAX_PATH];
    HKEY hKey;
    DWORD Type = REG_SZ;

    szBuffer[0] = TEXT('\0');


    //
    // We will first get any LocationInformation for the device.  This will either
    // be in the LocationInformationOverride value in the devices driver (software) key
    // or if that is not present we will look for the LocationInformation value in
    // the devices device (hardware) key.
    //
    ulSize = sizeof(szBuffer);
    if (CR_SUCCESS == CM_Open_DevNode_Key_Ex(DevInst,
                                             KEY_READ,
                                             0,
                                             RegDisposition_OpenExisting,
                                             &hKey,
                                             CM_REGISTRY_SOFTWARE,
                                             NULL
                                             )) {

        if (RegQueryValueEx(hKey,
                            REGSTR_VAL_LOCATION_INFORMATION_OVERRIDE,
                            NULL,
                            &Type,
                            (const PBYTE)szBuffer,
                            &ulSize
                            ) != ERROR_SUCCESS) {
            
            szBuffer[0] = TEXT('\0');
        }

        RegCloseKey(hKey);
    }

    //
    // If the buffer is empty then we didn't get the LocationInformationOverride
    // value in the device's software key.  So, we will see if their is a
    // LocationInformation value in the device's hardware key.
    //
    if (szBuffer[0] == TEXT('\0')) {
        //
        // Get the LocationInformation for this device.
        //
        ulSize = sizeof(szBuffer);
        if (CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                CM_DRP_LOCATION_INFORMATION,
                                                NULL,
                                                szBuffer,
                                                &ulSize,
                                                0,
                                                NULL
                                                ) != CR_SUCCESS) {
            szBuffer[0] = TEXT('\0');
        }
    }

    //
    // UINumber has precedence over all other location information so check if this
    // device has a UINumber
    //
    ulSize = sizeof(UINumber);
    if ((CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                             CM_DRP_UI_NUMBER,
                                             NULL,
                                             &UINumber,
                                             &ulSize,
                                             0,
                                             NULL
                                             ) == CR_SUCCESS) &&
        (ulSize == sizeof(UINumber))) {

        UINumberDescFormat[0] = TEXT('\0');
        ulSize = sizeof(UINumberDescFormat);

        //
        // Get the UINumber description format string from the device's parent,
        // if there is one, otherwise default to 'Location %1'
        //
        if ((CM_Get_Parent_Ex(&DevInstParent, DevInst, 0, NULL) != CR_SUCCESS) ||
            (CM_Get_DevNode_Registry_Property_Ex(DevInstParent,
                                                 CM_DRP_UI_NUMBER_DESC_FORMAT,
                                                 NULL,
                                                 UINumberDescFormat,
                                                 &ulSize,
                                                 0,
                                                 NULL) != CR_SUCCESS) ||
            (UINumberDescFormat[0] == TEXT('\0'))) {

            if (LoadString(hHotPlug, IDS_UI_NUMBER_DESC_FORMAT, UINumberDescFormat, sizeof(UINumberDescFormat)/sizeof(TCHAR)) == 0) {
                UINumberDescFormat[0] = TEXT('\0');
            }
        }

        //
        // Fill in the UINumber string.
        // If the StringCchCat fails then the UINumberDescFormat in the registry
        // is too larger (greater then 255 characters) to fit into our buffer,
        // so just move on to other location information.
        //
        if ((LoadString(hHotPlug, IDS_AT, szFormat, sizeof(szFormat)/sizeof(TCHAR)) != 0) &&
            (UINumberDescFormat[0] != TEXT('\0')) &&
            SUCCEEDED(StringCchCat(szFormat,
                                   SIZECHARS(szFormat),
                                   UINumberDescFormat))) {
            Location = FormatString(szFormat, UINumber);
        }

    } else if (*szBuffer) {
        //
        // We don't have a UINumber but we do have LocationInformation
        //
        if (LoadString(hHotPlug, IDS_LOCATION, szFormat, sizeof(szFormat)/sizeof(TCHAR)) != 0) {
    
            ulSize = lstrlen(szBuffer)*sizeof(TCHAR) + sizeof(szFormat) + sizeof(TCHAR);
            Location = (PTCHAR)LocalAlloc(LPTR, ulSize);
    
            if (Location) {
    
                StringCchPrintf(Location, ulSize/sizeof(TCHAR), szFormat, szBuffer);
            }
        }
    
    } else {
        //
        // We don't have a UINumber or LocationInformation so we need to get a 
        // description of the parent of this device.
        //
        ConfigRet = CM_Get_Parent_Ex(&DevInstParent, DevInst, 0, NULL);
        if (ConfigRet == CR_SUCCESS) {
            
            ParentName = BuildFriendlyName(DevInstParent);

            if (ParentName) {
    
                if (LoadString(hHotPlug, IDS_LOCATION_NOUINUMBER, szFormat, sizeof(szFormat)/sizeof(TCHAR)) != 0) {
                    
                    ulSize = lstrlen(ParentName)*sizeof(TCHAR) + sizeof(szFormat) + sizeof(TCHAR);
                    Location = (PTCHAR)LocalAlloc(LPTR, ulSize);
        
                    if (Location) {
        
                        StringCchPrintf(Location, ulSize/sizeof(TCHAR), szFormat, ParentName);
                    }
                }

                LocalFree(ParentName);
            }
        }
    }

    return Location;
}

PTCHAR
BuildFriendlyName(
   DEVINST DevInst
   )
{
    PTCHAR FriendlyName;
    CONFIGRET ConfigRet;
    ULONG ulSize;
    TCHAR szBuffer[MAX_PATH];

    //
    // Try the registry for FRIENDLYNAME
    //
    ulSize = sizeof(szBuffer);
    ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                    CM_DRP_FRIENDLYNAME,
                                                    NULL,
                                                    szBuffer,
                                                    &ulSize,
                                                    0,
                                                    NULL
                                                    );
    if ((ConfigRet != CR_SUCCESS) || 
        (szBuffer[0] == TEXT('\0'))) {
        //
        // Try the registry for DEVICEDESC
        //
        ulSize = sizeof(szBuffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                        CM_DRP_DEVICEDESC,
                                                        NULL,
                                                        szBuffer,
                                                        &ulSize,
                                                        0,
                                                        NULL
                                                        );
    }

    if ((ConfigRet == CR_SUCCESS) &&
        (ulSize > sizeof(TCHAR)) &&
        (szBuffer[0] != TEXT('\0'))) {

        FriendlyName = (PTCHAR)LocalAlloc(LPTR, ulSize);
        if (FriendlyName) {

            StringCchCopy(FriendlyName, ulSize/sizeof(TCHAR), szBuffer);
        }
    }

    else {

        FriendlyName = NULL;
    }

    return FriendlyName;
}

VOID
HotPlugPropagateMessage(
    HWND hWnd,
    UINT uMessage,
    WPARAM wParam,
    LPARAM lParam
    )
{
    while ((hWnd = GetWindow(hWnd, GW_CHILD)) != NULL) {

        SendMessage(hWnd, uMessage, wParam, lParam);
    }
}

void
InvalidateTreeItemRect(
    HWND hwndTree,
    HTREEITEM  hTreeItem
    )
{
    RECT rect;

    if (hTreeItem && TreeView_GetItemRect(hwndTree, hTreeItem, &rect, FALSE)) {

        InvalidateRect(hwndTree, &rect, FALSE);
    }
}

DWORD
GetHotPlugFlags(
    PHKEY phKey
    )
{
    HKEY hKey;
    LONG Error;
    DWORD HotPlugFlags = 0, cbHotPlugFlags;

    Error = RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_SYSTRAY, &hKey);
    if (Error == ERROR_SUCCESS) {

        cbHotPlugFlags = sizeof(HotPlugFlags);

        Error = RegQueryValueEx(hKey,
                                szHotPlugFlags,
                                NULL,
                                NULL,
                                (LPBYTE)&HotPlugFlags,
                                &cbHotPlugFlags
                                );

        if (phKey) {

            *phKey = hKey;
        
        } else {

            RegCloseKey(hKey);
        }
    }

    if (Error != ERROR_SUCCESS) {

        HotPlugFlags = 0;
    }

    return HotPlugFlags;
}

//
// This function determines if the device is a boot storage device.
// We spit out a warning when users are trying to remove or disable
// a boot storage device(or a device contains a boot storage device).
//
// INPUT:
//  NONE
// OUTPUT:
//  TRUE  if the device is a boot device
//  FALSE if the device is not a boot device
LPTSTR
DevNodeToDriveLetter(
    DEVINST DevInst
    )
{
    ULONG ulSize;
    TCHAR szBuffer[MAX_PATH];
    TCHAR DeviceID[MAX_DEVICE_ID_LEN];
    PTSTR DriveString = NULL;
    PTSTR DeviceInterface = NULL;

    if (CM_Get_Device_ID_Ex(DevInst,
                            DeviceID,
                            sizeof(DeviceID)/sizeof(TCHAR),
                            0,
                            NULL
                            ) != CR_SUCCESS) {

        return NULL;
    }

    // create a device info list contains all the interface classed
    // exposed by this device.
    ulSize = 0;

    if ((CM_Get_Device_Interface_List_Size(&ulSize,
                                           (LPGUID)&VolumeClassGuid,
                                           DeviceID,
                                           0)  == CR_SUCCESS) &&
        (ulSize > 1) &&
        ((DeviceInterface = (PTSTR)LocalAlloc(LPTR, ulSize*sizeof(TCHAR))) != NULL) &&
        (CM_Get_Device_Interface_List((LPGUID)&VolumeClassGuid,
                                      DeviceID,
                                      DeviceInterface,
                                      ulSize,
                                      0
                                      )  == CR_SUCCESS) &&
        *DeviceInterface)
    {
        PTSTR devicePath, p;
        TCHAR thisVolumeName[MAX_PATH];
        TCHAR enumVolumeName[MAX_PATH];
        TCHAR driveName[4];
        ULONG cchSize;
        BOOL bResult;

        cchSize = lstrlen(DeviceInterface);
        devicePath = (PTSTR)LocalAlloc(LPTR, (cchSize + 1) * sizeof(TCHAR) + sizeof(UNICODE_NULL));

        if (devicePath) {

            StringCchCopy(devicePath, cchSize+1, DeviceInterface);

            //
            // Get the first backslash after the four characters which will 
            // be \\?\
            //
            p = wcschr(&(devicePath[4]), TEXT('\\'));

            if (!p) {
                //
                // No refstring is present in the symbolic link; add a trailing
                // '\' char (as required by GetVolumeNameForVolumeMountPoint).
                //
                p = devicePath + cchSize;
                *p = TEXT('\\');
            }

            p++;
            *p = UNICODE_NULL;

            thisVolumeName[0] = UNICODE_NULL;
            bResult = GetVolumeNameForVolumeMountPoint(devicePath,
                                                       thisVolumeName,
                                                       SIZECHARS(thisVolumeName)
                                                       );
            LocalFree(devicePath);

            if (bResult && (thisVolumeName[0] != UNICODE_NULL)) {

                driveName[1] = TEXT(':');
                driveName[2] = TEXT('\\');
                driveName[3] = TEXT('\0');

                for (driveName[0] = TEXT('A'); driveName[0] <= TEXT('Z'); driveName[0]++) {

                    enumVolumeName[0] = TEXT('\0');

                    GetVolumeNameForVolumeMountPoint(driveName, enumVolumeName, SIZECHARS(enumVolumeName));

                    if (!lstrcmpi(thisVolumeName, enumVolumeName)) {

                        driveName[2] = TEXT('\0');

                        StringCchPrintf(szBuffer,
                                        SIZECHARS(szBuffer), 
                                        TEXT(" - (%s)"), 
                                        driveName
                                        );

                        ulSize = (lstrlen(szBuffer) + 1) * sizeof(TCHAR);
                        DriveString = (PTSTR)LocalAlloc(LPTR, ulSize);

                        if (DriveString) {

                            StringCchCopy(DriveString, ulSize/sizeof(TCHAR), szBuffer);
                        }

                        break;
                    }
                }
            }
        }
    }

    if (DeviceInterface) {

        LocalFree(DeviceInterface);
    }

    return DriveString;
}

BOOL
IsHotPlugDevice(
    DEVINST DevInst
    )
/**+

    A device is considered a HotPlug device if the following are TRUE:
        - has Capability CM_DEVCAP_REMOVABLE
        - does NOT have Capability CM_DEVCAP_SURPRISEREMOVALOK
        - does NOT have Capability CM_DEVCAP_DOCKDEVICE
        - must be started (have the DN_STARTED devnode flag)
            - unless has capability CM_DEVCAP_EJECTSUPPORTED
            - or unless has capability CM_DEVCAP_RAWDEVICEOK

Returns:
    TRUE if this is a HotPlug device
    FALSE if this is not a HotPlug device.

-**/
{
    DWORD Capabilities;
    DWORD cbSize;
    DWORD Status, Problem;

    Capabilities = Status = Problem = 0;

    cbSize = sizeof(Capabilities);
    if (CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                            CM_DRP_CAPABILITIES,
                                            NULL,
                                            (PVOID)&Capabilities,
                                            &cbSize,
                                            0,
                                            NULL) != CR_SUCCESS) {
        return FALSE;
    }

    if (CM_Get_DevNode_Status_Ex(&Status,
                                 &Problem,
                                 DevInst,
                                 0,
                                 NULL) != CR_SUCCESS) {
        return FALSE;
    }

    //
    // If this device is not removable, or it is surprise removal ok, or
    // it is a dock device, then it is not a hotplug device.
    //
    if ((!(Capabilities & CM_DEVCAP_REMOVABLE)) ||
        (Capabilities & CM_DEVCAP_SURPRISEREMOVALOK) ||
        (Capabilities & CM_DEVCAP_DOCKDEVICE)) {

        return FALSE;
    }

    //
    // We won't consider a device to be a hotplug device if it is not started,
    // unless it is either RAW capabile or an eject capable device.
    //
    // The reason for this test is that a bus driver might set the
    // CM_DEVCAP_REMOVABLE capability, but if the PDO doesn't get loaded then
    // it can't set the CM_DEVCAP_SURPRISEREMOVALOK. So we won't trust the
    // CM_DEVCAP_REMOVABLE capability if the PDO is not started.
    //
    if ((!(Capabilities & CM_DEVCAP_EJECTSUPPORTED)) &&
        (!(Status & DN_STARTED))) {

        return FALSE;
    }

    return TRUE;
}

BOOL
OpenPipeAndEventHandles(
    IN  LPWSTR    szCmd,
    OUT LPHANDLE  lphHotPlugPipe,
    OUT LPHANDLE  lphHotPlugEvent
    )
{
    BOOL   status = FALSE;
    HANDLE hPipe  = INVALID_HANDLE_VALUE;
    HANDLE hEvent = NULL;
    ULONG  ulEventNameSize;
    WCHAR  szEventName[MAX_PATH];
    DWORD  dwBytesRead;


    __try {
        //
        // Validate supplied arguments.
        //
        if (!lphHotPlugPipe || !lphHotPlugEvent) {
            return FALSE;
        }

        //
        // Make sure that a named pipe was specified in the cmd line.
        //
        if(!szCmd || (szCmd[0] == TEXT('\0'))) {
            return FALSE;
        }

        //
        // Wait for the specified named pipe to become available from the server.
        //
        if (!WaitNamedPipe(szCmd,
                           180000) 
                           ) {
            return FALSE;
        }

        //
        // Open a handle to the specified named pipe
        //
        hPipe = CreateFile(szCmd,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);
        if (hPipe == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        //
        // The very first thing in the pipe should be the size of the event name.
        //
        if (ReadFile(hPipe,
                     (LPVOID)&ulEventNameSize,
                     sizeof(ULONG),
                     &dwBytesRead,
                     NULL)) {

            ASSERT(ulEventNameSize != 0);
            if ((ulEventNameSize == 0) ||
                (ulEventNameSize > SIZECHARS(szEventName))) {
                goto clean0;
            }

            //
            // The next thing in the pipe should be the name of the event.
            //
            if (!ReadFile(hPipe,
                          (LPVOID)szEventName,
                          ulEventNameSize,
                          &dwBytesRead,
                          NULL)) {
                goto clean0;
            }

        } else {
            if (GetLastError() == ERROR_INVALID_HANDLE) {
                //
                // The handle to the named pipe is not valid.  Make sure we don't
                // try to close it on exit.
                //
                hPipe = INVALID_HANDLE_VALUE;
            }
            goto clean0;
        }

        //
        // Open a handle to the specified named event that we can set and wait on.
        //
        hEvent = OpenEventW(EVENT_MODIFY_STATE | SYNCHRONIZE,
                            FALSE,
                            szEventName);
        if (hEvent == NULL) {
            goto clean0;
        }

        //
        // We should now have valid handles to both the pipe and the event.
        //
        status = TRUE;
        ASSERT((hPipe != INVALID_HANDLE_VALUE) && hEvent);


    clean0:
        ;

    } __except(EXCEPTION_EXECUTE_HANDLER) {

        status = FALSE;
    }

    if (status) {

        *lphHotPlugPipe  = hPipe;
        *lphHotPlugEvent = hEvent;

    } else {

        if (hPipe != INVALID_HANDLE_VALUE) {
            CloseHandle(hPipe);
        }
        if (hEvent) {
            CloseHandle(hEvent);
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\notify.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       notify.cpp
//
//--------------------------------------------------------------------------

#include "HotPlug.h"

void
OnTimerDeviceChange(
    PDEVICETREE DeviceTree
    )
{
    //
    // if a refresh event is pending, rebuild the entire tree.
    //
    if (DeviceTree->RefreshEvent) {
        
        if (RefreshTree(DeviceTree)) {
            
            DeviceTree->RefreshEvent = FALSE;
        }
    }
}

BOOL
RefreshTree(
    PDEVICETREE DeviceTree
    )
{
    CONFIGRET ConfigRet;
    DEVINST DeviceInstance;
    DEVINST SelectedDevInst;
    PDEVTREENODE DevTreeNode;
    HTREEITEM hTreeItem;
    HCURSOR hCursor;

    if (DeviceTree->RedrawWait) {
        
        DeviceTree->RefreshEvent = TRUE;
        SetTimer(DeviceTree->hDlg, TIMERID_DEVICECHANGE,1000,NULL);
        return FALSE;
    }


    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    DeviceTree->RedrawWait = TRUE;
    SendMessage(DeviceTree->hwndTree, WM_SETREDRAW, FALSE, 0L);

    SelectedDevInst = DeviceTree->SelectedTreeNode
                          ? DeviceTree->SelectedTreeNode->DevInst
                          : 0;


    ClearRemovalList(DeviceTree);
    TreeView_DeleteAllItems(DeviceTree->hwndTree);
    RemoveChildSiblings(DeviceTree, &DeviceTree->ChildSiblingList);

    ConfigRet = CM_Get_Child_Ex(&DeviceInstance,
                                DeviceTree->DevInst,
                                0,
                                NULL
                                );

    if (ConfigRet == CR_SUCCESS) {

        AddChildSiblings(DeviceTree,
                         NULL,
                         DeviceInstance,
                         0,
                         TRUE
                         );
    }


    DisplayChildSiblings(DeviceTree,
                         &DeviceTree->ChildSiblingList,
                         NULL,
                         FALSE
                         );

    //
    // restore treeview redraw state, and reset the selected item
    //
    DevTreeNode = DevTreeNodeByDevInst(SelectedDevInst,
                                       &DeviceTree->ChildSiblingList
                                       );

    if (DevTreeNode) {
        
        hTreeItem = DevTreeNode->hTreeItem;
    }

    else {
        
        hTreeItem = NULL;
    }

    if (!hTreeItem) {
        
        hTreeItem = TreeView_GetRoot(DeviceTree->hwndTree);
    }

    SendMessage(DeviceTree->hwndTree, WM_SETREDRAW, TRUE, 0L);
    DeviceTree->RedrawWait = FALSE;

    if (hTreeItem) {
    
        TreeView_SelectItem(DeviceTree->hwndTree, hTreeItem);
    } else {
        
        //
        // No device is selected
        //
        TreeView_SelectItem(DeviceTree->hwndTree, NULL);
        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_STOPDEVICE), FALSE);
        EnableWindow(GetDlgItem(DeviceTree->hDlg, IDC_PROPERTIES), FALSE);
        SetDlgItemText(DeviceTree->hDlg, IDC_DEVICEDESC, TEXT(""));
    }

    SetCursor(hCursor);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0B7F57F6_FFB4_4669_B827_551E77DC7212__INCLUDED_)
#define AFX_STDAFX_H__0B7F57F6_FFB4_4669_B827_551E77DC7212__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0B7F57F6_FFB4_4669_B827_551E77DC7212__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\rconfirm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       rconfirm.cpp
//
//--------------------------------------------------------------------------

#include "HotPlug.h"

#define NOTIFYICONDATA_SZINFO       256
#define NOTIFYICONDATA_SZINFOTITLE  64

#define WM_NOTIFY_MESSAGE   (WM_USER + 100)

extern HMODULE hHotPlug;

DWORD
WaitDlgMessagePump(
    HWND hDlg,
    DWORD nCount,
    LPHANDLE Handles
    )
{
    DWORD WaitReturn;
    MSG Msg;

    while ((WaitReturn = MsgWaitForMultipleObjects(nCount,
                                                   Handles,
                                                   FALSE,
                                                   INFINITE,
                                                   QS_ALLINPUT
                                                   ))
           == nCount)
    {
        while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE)) {

            if (!IsDialogMessage(hDlg,&Msg)) {
                TranslateMessage(&Msg);
                DispatchMessage(&Msg);
            }
        }
    }

    return WaitReturn;
}

int
InsertDeviceNodeListView(
    HWND hwndList,
    PDEVICETREE DeviceTree,
    PDEVTREENODE  DeviceTreeNode,
    INT lvIndex
    )
{
    LV_ITEM lviItem;
    TCHAR Buffer[MAX_PATH];

    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iItem = lvIndex;
    lviItem.iSubItem = 0;

    if (SetupDiGetClassImageIndex(&DeviceTree->ClassImageList,
                                   &DeviceTreeNode->ClassGuid,
                                   &lviItem.iImage
                                   ))
    {
        lviItem.mask |= LVIF_IMAGE;
    }

    lviItem.pszText = FetchDeviceName(DeviceTreeNode);

    if (!lviItem.pszText) {

        lviItem.pszText = Buffer;
        StringCchPrintf(Buffer,
                        SIZECHARS(Buffer),
                        TEXT("%s %s"),
                        szUnknown,
                        DeviceTreeNode->Location  ? DeviceTreeNode->Location : TEXT("")
                        );
    }

    lviItem.lParam = (LPARAM) DeviceTreeNode;

    return ListView_InsertItem(hwndList, &lviItem);
}

DWORD
RemoveThread(
   PVOID pvDeviceTree
   )
{
    PDEVICETREE DeviceTree = (PDEVICETREE)pvDeviceTree;
    PDEVTREENODE  DeviceTreeNode;

    DeviceTreeNode = DeviceTree->ChildRemovalList;

    return(CM_Request_Device_Eject_Ex(DeviceTreeNode->DevInst,
                                           NULL,
                                           NULL,
                                           0,
                                           0,
                                           NULL
                                           ));
}

BOOL
OnOkRemove(
    HWND hDlg,
    PDEVICETREE DeviceTree
    )
{
    HCURSOR hCursor;
    PDEVTREENODE DeviceTreeNode;
    HANDLE hThread;
    DWORD ThreadId;
    DWORD WaitReturn;
    BOOL bSuccess;

    //
    // disable the ok\cancel buttons
    //
    EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);

    hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
    DeviceTreeNode = DeviceTree->ChildRemovalList;
    DeviceTree->RedrawWait = TRUE;

    hThread = CreateThread(NULL,
                           0,
                           RemoveThread,
                           DeviceTree,
                           0,
                           &ThreadId
                           );
    if (!hThread) {

        return FALSE;
    }

    WaitReturn = WaitDlgMessagePump(hDlg, 1, &hThread);

    bSuccess =
        (WaitReturn == 0 &&
         GetExitCodeThread(hThread, &WaitReturn) &&
         WaitReturn == CR_SUCCESS );

    SetCursor(hCursor);
    DeviceTree->RedrawWait = FALSE;
    CloseHandle(hThread);

    return bSuccess;
}

#define idh_hwwizard_confirm_stop_list  15321   // "" (SysListView32)

DWORD RemoveConfirmHelpIDs[] = {
    IDC_REMOVELIST,    idh_hwwizard_confirm_stop_list,
    IDC_NOHELP1,       NO_HELP,
    IDC_NOHELP2,       NO_HELP,
    IDC_NOHELP3,       NO_HELP,
    0,0
    };


BOOL
InitRemoveConfirmDlgProc(
    HWND hDlg,
    PDEVICETREE DeviceTree
    )
{
    HWND hwndList;
    PDEVTREENODE DeviceTreeNode;
    int lvIndex;
    LV_COLUMN lvcCol;
    HICON hIcon;


    hIcon = LoadIcon(hHotPlug,MAKEINTRESOURCE(IDI_HOTPLUGICON));

    if (hIcon) {

        SendMessage(hDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
        SendMessage(hDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
    }

    DeviceTreeNode = DeviceTree->ChildRemovalList;

    if (!DeviceTreeNode) {

        return FALSE;
    }

    DeviceTree->hwndRemove = hDlg;

    hwndList = GetDlgItem(hDlg, IDC_REMOVELIST);

    ListView_SetImageList(hwndList, DeviceTree->ClassImageList.ImageList, LVSIL_SMALL);
    ListView_DeleteAllItems(hwndList);

    // Insert a column for the class list
    lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
    lvcCol.fmt = LVCFMT_LEFT;
    lvcCol.iSubItem = 0;
    ListView_InsertColumn(hwndList, 0, (LV_COLUMN FAR *)&lvcCol);

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);

    //
    // Walk the removal list and add each of them to the listbox.
    //
    lvIndex = 0;

    do {

        InsertDeviceNodeListView(hwndList, DeviceTree, DeviceTreeNode, lvIndex++);
        DeviceTreeNode = DeviceTreeNode->NextChildRemoval;

    } while (DeviceTreeNode != DeviceTree->ChildRemovalList);


    ListView_SetItemState(hwndList, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED);
    ListView_EnsureVisible(hwndList, 0, FALSE);
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);

    return TRUE;
}

INT_PTR CALLBACK
RemoveConfirmDlgProc(
   HWND   hDlg,
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
   )
/*++

Routine Description:

   DialogProc to confirm user really wants to remove the devices.

Arguments:

   standard stuff.



Return Value:

   LRESULT

--*/

{
    PDEVICETREE DeviceTree=NULL;

    if (message == WM_INITDIALOG) {

        DeviceTree = (PDEVICETREE)lParam;

        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)DeviceTree);

        if (DeviceTree) {

            InitRemoveConfirmDlgProc(hDlg, DeviceTree);
        }

        return TRUE;
    }

    //
    // retrieve private data from window long (stored there during WM_INITDIALOG)
    //
    DeviceTree = (PDEVICETREE)GetWindowLongPtr(hDlg, DWLP_USER);


    switch (message) {

    case WM_DESTROY:
        DeviceTree->hwndRemove = NULL;
        break;


    case WM_CLOSE:
        SendMessage (hDlg, WM_COMMAND, IDCANCEL, 0L);
        break;

    case WM_COMMAND:
        switch(wParam) {
        case IDOK:
            EndDialog(hDlg, OnOkRemove(hDlg, DeviceTree) ? IDOK : IDCANCEL);
            break;

        case IDCLOSE:
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;
        }
        break;

    case WUM_EJECTDEVINST:
        EndDialog(hDlg, OnOkRemove(hDlg, DeviceTree) ? IDOK : IDCANCEL);
        break;

    case WM_SYSCOLORCHANGE:
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam,
                TEXT("hardware.hlp"),
                HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID)(PDWORD)RemoveConfirmHelpIDs
                );

        return FALSE;

    case WM_HELP:
        OnContextHelp((LPHELPINFO)lParam, RemoveConfirmHelpIDs);
        break;

    case WM_SETCURSOR:
        if (DeviceTree->RedrawWait || DeviceTree->RefreshEvent) {
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 1);
        }
        break;

    default:
        return FALSE;

    }


    return TRUE;
}

LRESULT CALLBACK
SafeRemovalBalloonProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    NOTIFYICONDATA nid;
    static HICON hHotPlugIcon = NULL;
    TCHAR szFormat[512];
    PDEVICE_COLLECTION safeRemovalCollection;
    static BOOL bCheckIfDeviceIsRemoved = FALSE;

    switch (message) {

    case WM_CREATE:
        safeRemovalCollection = (PDEVICE_COLLECTION) ((CREATESTRUCT*)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) safeRemovalCollection);

        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = WM_NOTIFY_MESSAGE;
        
        LoadString(hHotPlug, IDS_REMOVAL_COMPLETE_TEXT, szFormat, SIZECHARS(szFormat));

        if (!DeviceCollectionFormatDeviceText(
                safeRemovalCollection,
                0,
                szFormat,
                SIZECHARS(nid.szInfo),
                nid.szInfo
                )) {

            return FALSE;
        }

        hHotPlugIcon = (HICON)LoadImage(hHotPlug, 
                                        MAKEINTRESOURCE(IDI_HOTPLUGICON), 
                                        IMAGE_ICON,
                                        GetSystemMetrics(SM_CXSMICON),
                                        GetSystemMetrics(SM_CYSMICON),
                                        0
                                        );

        nid.hIcon = hHotPlugIcon;

        nid.uFlags = NIF_MESSAGE | NIF_ICON;
        nid.uCallbackMessage = WM_NOTIFY_MESSAGE;
        Shell_NotifyIcon(NIM_ADD, &nid);

        nid.uVersion = NOTIFYICON_VERSION;
        Shell_NotifyIcon(NIM_SETVERSION, &nid);

        nid.uFlags = NIF_INFO;
        nid.uTimeout = 10000;
        nid.dwInfoFlags = NIIF_INFO;

        LoadString(hHotPlug,
                   IDS_REMOVAL_COMPLETE_TITLE,
                   nid.szInfoTitle,
                   SIZECHARS(nid.szInfoTitle)
                   );

        Shell_NotifyIcon(NIM_MODIFY, &nid);

        SetTimer(hWnd, TIMERID_DEVICECHANGE, 5000, NULL);

        break;

    case WM_NOTIFY_MESSAGE:
        switch(lParam) {

        case NIN_BALLOONTIMEOUT:
        case NIN_BALLOONUSERCLICK:
            DestroyWindow(hWnd);
            break;

        default:
            break;
        }
        break;

    case WM_DEVICECHANGE:
        if ((DBT_DEVNODES_CHANGED == wParam) && bCheckIfDeviceIsRemoved) {
            SetTimer(hWnd, TIMERID_DEVICECHANGE, 1000, NULL);
        }
        break;

    case WM_TIMER:
        if (wParam == TIMERID_DEVICECHANGE) {
            KillTimer(hWnd, TIMERID_DEVICECHANGE);
            bCheckIfDeviceIsRemoved = TRUE;

            safeRemovalCollection = (PDEVICE_COLLECTION) GetWindowLongPtr(hWnd, GWLP_USERDATA);

            if (DeviceCollectionCheckIfAllRemoved(safeRemovalCollection)) {
                DestroyWindow(hWnd);
            }
        }
        break;

    case WM_DESTROY:
        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = WM_NOTIFY_MESSAGE;
        Shell_NotifyIcon(NIM_DELETE, &nid);

        if (hHotPlugIcon) {
            DestroyIcon(hHotPlugIcon);
        }

        PostQuitMessage(0);
        break;

    default:
        break;
    }

    return DefWindowProc(hWnd, message, wParam, lParam);
}

LRESULT CALLBACK
DockSafeRemovalBalloonProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    NOTIFYICONDATA nid;
    static HICON hHotPlugIcon = NULL;
    TCHAR szFormat[512];
    PDEVICE_COLLECTION safeRemovalCollection;
    static BOOL bCheckIfReDocked = FALSE;
    BOOL bIsDockStationPresent;

    switch (message) {

    case WM_CREATE:
        safeRemovalCollection = (PDEVICE_COLLECTION) ((CREATESTRUCT*)lParam)->lpCreateParams;
        SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) safeRemovalCollection);
        
        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = WM_NOTIFY_MESSAGE;

        LoadString(hHotPlug, IDS_UNDOCK_COMPLETE_TEXT, szFormat, SIZECHARS(szFormat));

        if (!DeviceCollectionFormatDeviceText(
                safeRemovalCollection,
                0,
                szFormat,
                SIZECHARS(nid.szInfo),
                nid.szInfo
                )) {

            return FALSE;
        }

        hHotPlugIcon = (HICON)LoadImage(hHotPlug, 
                                        MAKEINTRESOURCE(IDI_UNDOCKICON), 
                                        IMAGE_ICON,
                                        GetSystemMetrics(SM_CXSMICON),
                                        GetSystemMetrics(SM_CYSMICON),
                                        0
                                        );

        nid.hIcon = hHotPlugIcon;
        nid.uFlags = NIF_MESSAGE | NIF_ICON;
        nid.uCallbackMessage = WM_NOTIFY_MESSAGE;
        Shell_NotifyIcon(NIM_ADD, &nid);

        nid.uVersion = NOTIFYICON_VERSION;
        Shell_NotifyIcon(NIM_SETVERSION, &nid);

        nid.uFlags = NIF_INFO;
        nid.uTimeout = 10000;
        nid.dwInfoFlags = NIIF_INFO;

        LoadString(hHotPlug,
                   IDS_UNDOCK_COMPLETE_TITLE,
                   nid.szInfoTitle,
                   SIZECHARS(nid.szInfoTitle)
                   );

        Shell_NotifyIcon(NIM_MODIFY, &nid);

        SetTimer(hWnd, TIMERID_DEVICECHANGE, 5000, NULL);

        break;

    case WM_NOTIFY_MESSAGE:
        switch(lParam) {

        case NIN_BALLOONTIMEOUT:
        case NIN_BALLOONUSERCLICK:
            DestroyWindow(hWnd);
            break;

        default:
            break;
        }
        break;

    case WM_DEVICECHANGE:
        if ((DBT_CONFIGCHANGED == wParam) && bCheckIfReDocked) {
            SetTimer(hWnd, TIMERID_DEVICECHANGE, 1000, NULL);
        }
        break;

    case WM_TIMER:
        if (wParam == TIMERID_DEVICECHANGE) {
            KillTimer(hWnd, TIMERID_DEVICECHANGE);
            bCheckIfReDocked = TRUE;

            //
            // Check if the docking station is now present, this means that the
            // user redocked the machine and that we should kill the safe to 
            // undock balloon.
            //
            bIsDockStationPresent = FALSE;
            CM_Is_Dock_Station_Present(&bIsDockStationPresent);

            if (bIsDockStationPresent) {
                DestroyWindow(hWnd);
            }
        }
        break;

    case WM_DESTROY:
        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = WM_NOTIFY_MESSAGE;
        Shell_NotifyIcon(NIM_DELETE, &nid);

        if (hHotPlugIcon) {
            DestroyIcon(hHotPlugIcon);
        }

        PostQuitMessage(0);
        break;

    default:
        break;
    }

    return DefWindowProc(hWnd, message, wParam, lParam);
}

BOOL
VetoedRemovalUI(
    IN  PVETO_DEVICE_COLLECTION VetoedRemovalCollection
    )
{
    HANDLE hVetoEvent = NULL;
    TCHAR szEventName[MAX_PATH];
    TCHAR szFormat[512];
    TCHAR szMessage[512];
    TCHAR szTitle[256];
    PTSTR culpritDeviceId;
    PTSTR vetoedDeviceInstancePath;
    PTCHAR pStr;
    ULONG messageBase;

    //
    // The first device in the list is the device that failed ejection.
    // The next "device" is the name of the vetoer. It may in fact not be a
    // device.
    //
    vetoedDeviceInstancePath = DeviceCollectionGetDeviceInstancePath(
        (PDEVICE_COLLECTION) VetoedRemovalCollection,
        0
        );

    culpritDeviceId = DeviceCollectionGetDeviceInstancePath(
        (PDEVICE_COLLECTION) VetoedRemovalCollection,
        1
        );

    //
    // We will now check to see if this same veto message is already being
    // displayed.  We do this by creating a named event where the name
    // contains the three elements that make a veto message unique:
    //  1) device instance id
    //  2) veto type
    //  3) veto operation
    //
    // If we find an identical veto message already being displayed then we wil
    // just go away silently. This prevents multiple identical veto messages
    // from showing up on the screen.
    //
    StringCchPrintf(szEventName,
                    SIZECHARS(szEventName),
                    TEXT("Local\\VETO-%d-%d-%s"),
                    (DWORD)VetoedRemovalCollection->VetoType,
                    VetoedRemovalCollection->VetoedOperation,
                    culpritDeviceId
                    );

    //
    // Replace all of the backslashes (except the first one for Local\)
    // with pound characters since CreateEvent does not like backslashes.
    //
    pStr = StrChr(szEventName, TEXT('\\'));

    if (pStr) {
        pStr++;
    }

    while ((pStr = StrChr(pStr, TEXT('\\'))) != NULL) {
        *pStr = TEXT('#');
    }

    hVetoEvent = CreateEvent(NULL,
                             FALSE,
                             TRUE,
                             szEventName
                             );

    if (hVetoEvent) {
        if (WaitForSingleObject(hVetoEvent, 0) != WAIT_OBJECT_0) {
            //
            // This means that this veto message is already being displayed
            // by another hotplug process...so just go away.
            //
            CloseHandle(hVetoEvent);
            return FALSE;
        }
    }

    //
    // Create the veto text
    //
    switch(VetoedRemovalCollection->VetoedOperation) {

        case VETOED_UNDOCK:
        case VETOED_WARM_UNDOCK:
            messageBase = IDS_DOCKVETO_BASE;
            break;

        case VETOED_STANDBY:
            messageBase = IDS_SLEEPVETO_BASE;
            break;

        case VETOED_HIBERNATE:
            messageBase = IDS_HIBERNATEVETO_BASE;
            break;

        case VETOED_REMOVAL:
        case VETOED_EJECT:
        case VETOED_WARM_EJECT:
        default:
            messageBase = IDS_VETO_BASE;
            break;
    }

    switch(VetoedRemovalCollection->VetoType) {

        case PNP_VetoWindowsApp:

            if (culpritDeviceId) {

                //
                // Tell our user the name of the offending application.
                //
                LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szFormat, SIZECHARS(szFormat));

                DeviceCollectionFormatDeviceText(
                    (PDEVICE_COLLECTION) VetoedRemovalCollection,
                    1,
                    szFormat,
                    SIZECHARS(szMessage),
                    szMessage
                    );

            } else {

                //
                // No application, use the "some app" message.
                //
                messageBase += (IDS_VETO_UNKNOWNWINDOWSAPP - IDS_VETO_WINDOWSAPP);

                LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szMessage, SIZECHARS(szMessage));
            }
            break;

        case PNP_VetoWindowsService:
        case PNP_VetoDriver:
        case PNP_VetoLegacyDriver:
            //
            // PNP_VetoWindowsService, PNP_VetoDriver and PNP_VetoLegacyDriver 
            // are passed through the service manager to get friendlier names.
            //

            LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szFormat, SIZECHARS(szFormat));

            //
            // For these veto types, entry index 1 is the vetoing service.
            //
            DeviceCollectionFormatServiceText(
                (PDEVICE_COLLECTION) VetoedRemovalCollection,
                1,
                szFormat,
                SIZECHARS(szMessage),
                szMessage
                );

            break;

        case PNP_VetoDevice:
            if ((VetoedRemovalCollection->VetoedOperation == VETOED_WARM_UNDOCK) &&
               (!lstrcmp(culpritDeviceId, vetoedDeviceInstancePath))) {

                messageBase += (IDS_DOCKVETO_WARM_EJECT - IDS_DOCKVETO_DEVICE);
            }

            //
            // Fall through.
            //

        case PNP_VetoLegacyDevice:
        case PNP_VetoPendingClose:
        case PNP_VetoOutstandingOpen:
        case PNP_VetoNonDisableable:
        case PNP_VetoIllegalDeviceRequest:
            //
            // Include the veto ID in the display output
            //
            LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szFormat, SIZECHARS(szFormat));

            DeviceCollectionFormatDeviceText(
                (PDEVICE_COLLECTION) VetoedRemovalCollection,
                1,
                szFormat,
                SIZECHARS(szMessage),
                szMessage
                );

            break;

        case PNP_VetoInsufficientRights:

            //
            // Use the device itself in the display, but only if we are not
            // in the dock case.
            //

            if ((VetoedRemovalCollection->VetoedOperation == VETOED_UNDOCK)||
                (VetoedRemovalCollection->VetoedOperation == VETOED_WARM_UNDOCK)) {

                LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szMessage, SIZECHARS(szMessage));
                break;

            }

            //
            // Fall through.
            //

        case PNP_VetoInsufficientPower:
        case PNP_VetoTypeUnknown:

            //
            // Use the device itself in the display
            //
            LoadString(hHotPlug, messageBase+VetoedRemovalCollection->VetoType, szFormat, SIZECHARS(szFormat));

            DeviceCollectionFormatDeviceText(
                (PDEVICE_COLLECTION) VetoedRemovalCollection,
                0,
                szFormat,
                SIZECHARS(szMessage),
                szMessage
                );

            break;

        default:
            ASSERT(0);
            LoadString(hHotPlug, messageBase+PNP_VetoTypeUnknown, szFormat, SIZECHARS(szFormat));

            DeviceCollectionFormatDeviceText(
                (PDEVICE_COLLECTION) VetoedRemovalCollection,
                0,
                szFormat,
                SIZECHARS(szMessage),
                szMessage
                );

            break;
    }

    switch(VetoedRemovalCollection->VetoedOperation) {

        case VETOED_EJECT:
        case VETOED_WARM_EJECT:
            LoadString(hHotPlug, IDS_VETOED_EJECT_TITLE, szFormat, SIZECHARS(szFormat));
            break;

        case VETOED_UNDOCK:
        case VETOED_WARM_UNDOCK:
            LoadString(hHotPlug, IDS_VETOED_UNDOCK_TITLE, szFormat, SIZECHARS(szFormat));
            break;

        case VETOED_STANDBY:
            LoadString(hHotPlug, IDS_VETOED_STANDBY_TITLE, szFormat, SIZECHARS(szFormat));
            break;

        case VETOED_HIBERNATE:
            LoadString(hHotPlug, IDS_VETOED_HIBERNATION_TITLE, szFormat, SIZECHARS(szFormat));
            break;

        default:
            ASSERT(0);

            //
            // Fall through, display something at least...
            //

        case VETOED_REMOVAL:
            LoadString(hHotPlug, IDS_VETOED_REMOVAL_TITLE, szFormat, SIZECHARS(szFormat));
            break;
    }

    switch(VetoedRemovalCollection->VetoedOperation) {

        case VETOED_STANDBY:
        case VETOED_HIBERNATE:

            StringCchCopy(szTitle, SIZECHARS(szTitle), szFormat);
            break;

        case VETOED_EJECT:
        case VETOED_WARM_EJECT:
        case VETOED_UNDOCK:
        case VETOED_WARM_UNDOCK:
        case VETOED_REMOVAL:
        default:

            DeviceCollectionFormatDeviceText(
                (PDEVICE_COLLECTION) VetoedRemovalCollection,
                0,
                szFormat,
                SIZECHARS(szTitle),
                szTitle
                );

            break;
    }

    MessageBox(NULL, szMessage, szTitle, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_TOPMOST);

    if (hVetoEvent) {
        CloseHandle(hVetoEvent);
    }

    return TRUE;
}

void
DisplayDriverBlockBalloon(
    IN  PDEVICE_COLLECTION blockedDriverCollection
    )
{
    HRESULT hr;
    TCHAR szMessage[NOTIFYICONDATA_SZINFO];    // same size as NOTIFYICONDATA.szInfo
    TCHAR szFormat[NOTIFYICONDATA_SZINFO];     // same size as NOTIFYICONDATA.szInfo
    TCHAR szTitle[NOTIFYICONDATA_SZINFOTITLE]; // same size as NOTIFYICONDATA.szInfoTitle
    HICON hicon = NULL;
    HANDLE hShellReadyEvent = NULL;
    INT ShellReadyEventCount = 0;
    GUID guidDB, guidID;
    HAPPHELPINFOCONTEXT hAppHelpInfoContext = NULL;
    PTSTR Buffer;
    ULONG BufferSize, ApphelpURLBufferSize;

    if (!LoadString(hHotPlug, IDS_BLOCKDRIVER_TITLE, szTitle, SIZECHARS(szTitle))) {
        //
        // The machine is so low on memory that we can't even get the text strings, so
        // just exit.
        //
        return;
    }

    szMessage[0] = TEXT('\0');

    if (blockedDriverCollection->NumDevices == 1) {
        //
        // If we only have one device in the list then we will show specific 
        // information about this blocked driver as well as directly launching the
        // help for this blocked driver.
        //
        if (SdbGetStandardDatabaseGUID(SDB_DATABASE_MAIN_DRIVERS, &guidDB) &&
            DeviceCollectionGetGuid((PDEVICE_COLLECTION)blockedDriverCollection,
                                    &guidID,
                                    0)) {

            hAppHelpInfoContext = SdbOpenApphelpInformation(&guidDB, &guidID);

            Buffer = NULL;

            if ((hAppHelpInfoContext) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                          ApphelpAppName,
                                                          NULL,
                                                          0)) != 0) &&
                ((Buffer = (PTSTR)LocalAlloc(LPTR, BufferSize)) != NULL) &&
                ((BufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                          ApphelpAppName,
                                                          Buffer,
                                                          BufferSize)) != 0)) {
                if (LoadString(hHotPlug, IDS_BLOCKDRIVER_FORMAT, szFormat, SIZECHARS(szFormat)) &&
                    (lstrlen(szFormat) + lstrlen(Buffer) < NOTIFYICONDATA_SZINFO)) {
                    //
                    // The app name and format string will fit into the buffer so
                    // use the format for the balloon message.
                    //
                    StringCchPrintf(szMessage, 
                                    SIZECHARS(szMessage),
                                    szFormat,
                                    Buffer);
                } else {
                    //
                    // The app name is too large to be formated int he balloon 
                    // message, so just show the app name.
                    //
                    StringCchCopy(szMessage, SIZECHARS(szMessage), Buffer);
                }
            }

            if (Buffer) {
                LocalFree(Buffer);
            }
        }
    } 
                
    if (szMessage[0] == TEXT('\0')) {
        //
        // We either have more than one driver, or an error occured while trying
        // to access the specific information about the one driver we received,
        // so just show the generic message.
        //
        if (!LoadString(hHotPlug, IDS_BLOCKDRIVER_MESSAGE, szMessage, SIZECHARS(szMessage))) {
            //
            // The machine is so low on memory that we can't even get the text strings, so
            // just exit.
            //
            return;
        }
    }
    
    hicon = (HICON)LoadImage(hHotPlug, 
                             MAKEINTRESOURCE(IDI_BLOCKDRIVER), 
                             IMAGE_ICON,
                             GetSystemMetrics(SM_CXSMICON),
                             GetSystemMetrics(SM_CYSMICON),
                             0
                             );

    //
    // Make sure the shell is up and running so we can display the balloon.
    //
    while ((hShellReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("ShellReadyEvent"))) == NULL) {
        //
        // Sleep for 1 second and then try again.
        //
        Sleep(5000);
        
        if (ShellReadyEventCount++ > 120) {
            //
            // We have been waiting for the shell for 10 minutes and it still 
            // is not around.
            //
            break;
        }
    }

    if (hShellReadyEvent) {
        WaitForSingleObject(hShellReadyEvent, INFINITE);

        CloseHandle(hShellReadyEvent);
    
        if (SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE))) {
        
            IUserNotification *pun;
    
            hr = CoCreateInstance(CLSID_UserNotification, 
                                  NULL, 
                                  CLSCTX_INPROC_SERVER, 
                                  IID_IUserNotification,
                                  (void**)&pun);
    
            if (SUCCEEDED(hr)) {
                pun->SetIconInfo(hicon, szTitle);
        
                pun->SetBalloonInfo(szTitle, szMessage, NIIF_WARNING);
        
                //
                // Try once for 20 seconds
                //
                pun->SetBalloonRetry((20 * 1000), (DWORD)-1, 0);
        
                hr = pun->Show(NULL, 0);
        
                //
                // if hr is S_OK then user clicked on the balloon, if it is ERROR_CANCELLED
                // then the balloon timedout.
                //
                if (hr == S_OK) {
                    if ((blockedDriverCollection->NumDevices == 1) &&
                        (hAppHelpInfoContext != NULL)) {
                        //
                        // If we only have one device in the list then just
                        // launch the help for that blocked driver.
                        //
                        ApphelpURLBufferSize = SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                                          ApphelpHelpCenterURL,
                                                                          NULL,
                                                                          0);
    
                        if (ApphelpURLBufferSize) { 
                            
                            BufferSize = ApphelpURLBufferSize + (lstrlen(TEXT("HELPCTR.EXE -url ")) * sizeof(TCHAR));
                            
                            if ((Buffer = (PTSTR)LocalAlloc(LPTR, BufferSize)) != NULL) {
                                
                                if (SUCCEEDED(StringCbCopy(Buffer, BufferSize, TEXT("HELPCTR.EXE -url ")))) {
        
                                    SdbQueryApphelpInformation(hAppHelpInfoContext,
                                                               ApphelpHelpCenterURL,
                                                               (PVOID)&Buffer[lstrlen(TEXT("HELPCTR.EXE -url "))],
                                                               ApphelpURLBufferSize);
                                    
                                    ShellExecute(NULL,
                                                 TEXT("open"),
                                                 TEXT("HELPCTR.EXE"),
                                                 Buffer,
                                                 NULL,
                                                 SW_SHOWNORMAL);
                                }
    
                                LocalFree(Buffer);
                            }
                        }
                    } else {
                        //
                        // We have more than one device in the list so launch
                        // the summary blocked driver page.
                        //
                        ShellExecute(NULL,
                                     TEXT("open"),
                                     TEXT("HELPCTR.EXE"),
                                     TEXT("HELPCTR.EXE -url hcp://services/centers/support?topic=hcp://system/sysinfo/sysHealthInfo.htm"),
                                     NULL,
                                     SW_SHOWNORMAL
                                     );
                    }
                }
        
                pun->Release();
            }
    
            CoUninitialize();
        }
    }

    if (hicon) {
        DestroyIcon(hicon);
    }

    if (hAppHelpInfoContext) {
        SdbCloseApphelpInformation(hAppHelpInfoContext);
    }
}

void
DisplayChildWithInvalidIdBalloon(
    IN  PDEVICE_COLLECTION childWithInvalidCollection
    )
{
    HRESULT hr;
    TCHAR szMessage[NOTIFYICONDATA_SZINFO];    // same size as NOTIFYICONDATA.szInfo
    TCHAR szFormat[NOTIFYICONDATA_SZINFO];     // same size as NOTIFYICONDATA.szInfo
    TCHAR szTitle[NOTIFYICONDATA_SZINFOTITLE]; // same size as NOTIFYICONDATA.szInfoTitle
    HICON hicon = NULL;
    HANDLE hShellReadyEvent = NULL;
    INT ShellReadyEventCount = 0;
    PTSTR deviceFriendlyName;
    GUID ClassGuid;
    INT ImageIndex;
    SP_CLASSIMAGELIST_DATA ClassImageListData;

    ClassImageListData.cbSize = 0;

    if (!LoadString(hHotPlug, IDS_CHILDWITHINVALIDID_TITLE, szTitle, SIZECHARS(szTitle))) {
        //
        // The machine is so low on memory that we can't even get the text strings, so
        // just exit.
        //
        return;
    }
    
    if (!LoadString(hHotPlug, IDS_CHILDWITHINVALIDID_FORMAT, szFormat, SIZECHARS(szFormat))) {
        //
        // The machine is so low on memory that we can't even get the text strings, so
        // just exit.
        //
        return;
    }

    szMessage[0] = TEXT('\0');

    deviceFriendlyName = DeviceCollectionGetDeviceFriendlyName(
                                (PDEVICE_COLLECTION)childWithInvalidCollection,
                                0
                                );
    
    
    if (deviceFriendlyName) {

        if (lstrlen(szFormat) + lstrlen(deviceFriendlyName) < NOTIFYICONDATA_SZINFO) {
            //
            // The device friendly name and format string will fit into 
            // the buffer.
            //
            StringCchPrintf(szMessage, 
                            SIZECHARS(szMessage),
                            szFormat,
                            deviceFriendlyName);
        } else {
            //
            // The device friendly name is too large to be formated int the 
            // balloon message, so just show the device friendly name.
            //
            StringCchCopy(szMessage, SIZECHARS(szMessage), deviceFriendlyName);
        }
    } 
                
    if (szMessage[0] == TEXT('\0')) {
        return;
    }

    //
    // We have to go through a hole bunch of code to get the small class icon
    // for a device. The reason for this is setupapi only has an API to get
    // the large class icon, and not the small class icon.  To get the small
    // class icon we must get get the device's class GUID, then have setupapi
    // build up a image list of class icons (which are made up of small icons),
    // then get the index of the class icon in this list, and finally extract
    // the small icon from the image list.
    //
    if (DeviceCollectionGetGuid((PDEVICE_COLLECTION)childWithInvalidCollection,
                                &ClassGuid,
                                0)) {
        //
        // Have setupapi build up the image list of class icons.
        //
        ClassImageListData.cbSize = sizeof(ClassImageListData);
        if (SetupDiGetClassImageList(&ClassImageListData)) {
            //
            // Get the index of the class icon for this device.
            //
            if (SetupDiGetClassImageIndex(&ClassImageListData,
                                          &ClassGuid,
                                          &ImageIndex)) {
                //
                // We now have the ImageIndex of the class icon for this device
                // in the ImageList.  Class ImageList_GetIcon to get the icon
                // for the device class.
                //
                hicon = ImageList_GetIcon(ClassImageListData.ImageList,
                                          ImageIndex,
                                          ILD_NORMAL);
            }
        } else {
            //
            // We failed to build the class image list so set the cbSize field
            // to 0 so we no we don't have to call SetupDiDestroyClassImageList
            //
            ClassImageListData.cbSize = 0;
        }
    }

    //
    // Make sure the shell is up and running so we can display the balloon.
    //
    while ((hShellReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, TEXT("ShellReadyEvent"))) == NULL) {
        //
        // Sleep for 5 second and then try again.
        //
        Sleep(5000);
        
        if (ShellReadyEventCount++ > 120) {
            //
            // We have been waiting for the shell for 10 minutes and it still 
            // is not around.
            //
            break;
        }
    }

    if (hShellReadyEvent) {
        WaitForSingleObject(hShellReadyEvent, INFINITE);

        CloseHandle(hShellReadyEvent);
    
        if (SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED | COINIT_DISABLE_OLE1DDE))) {
        
            IUserNotification *pun;
    
            hr = CoCreateInstance(CLSID_UserNotification, 
                                  NULL, 
                                  CLSCTX_INPROC_SERVER, 
                                  IID_IUserNotification,
                                  (void**)&pun);
    
            if (SUCCEEDED(hr)) {
                pun->SetIconInfo(hicon, szTitle);
        
                pun->SetBalloonInfo(szTitle, szMessage, NIIF_WARNING);
        
                //
                // Try once for 20 seconds
                //
                pun->SetBalloonRetry((20 * 1000), (DWORD)-1, 0);
        
                hr = pun->Show(NULL, 0);
        
                //
                // if hr is S_OK then user clicked on the balloon, if it is ERROR_CANCELLED
                // then the balloon timedout.
                //
                if (hr == S_OK) {
                    //
                    // ISSUE: Launch helpcenter.
                    //
                }
        
                pun->Release();
            }
    
            CoUninitialize();
        }
    }

    if (hicon) {
        DestroyIcon(hicon);
    }

    if (ClassImageListData.cbSize != 0) {
        SetupDiDestroyClassImageList(&ClassImageListData);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\hotplug\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDI_HOTPLUGICON             100
#define IDI_UNDOCKICON              101
#define IDI_BLOCKDRIVER             102

#define IDR_BLKDRV                  110

#define IDH_HOTPLUGAPPLET           175

#define DLG_DEVTREE                 300
#define IDC_DEVICETREE              301

#define IDC_HDWDEVICES              304
#define IDC_STOPDEVICE              305
#define IDC_VIEWOPTION              307
#define IDC_DEVICEDESC              309

#define IDC_NOHELP1                 500
#define IDC_NOHELP2                 501
#define IDC_NOHELP3                 502
#define IDC_PROPERTIES              311
#define DLG_CONFIRMREMOVE           320
#define IDC_REMOVELIST              321

#define IDS_HOTPLUGNAME             1000
#define IDS_HOTPLUGINFO             1001
#define IDS_UNKNOWN                 1003
#define IDS_PROB_NONE               1004
#define IDS_PROB_UNKNOWN            1005
#define IDS_LOCATION                1006
#define IDS_LOCATION_NOUINUMBER     1009
#define IDS_UI_NUMBER_DESC_FORMAT   1011
#define IDS_AT                      1012
#define IDS_STOP                    1101
#define IDS_PROPERTIES              1102
#define IDS_CONFIRM_STOP            1110

//
//IDS_VETO_BASE must be the same value as the first veto string
//
#define IDS_VETO_BASE                           1200
#define IDS_VETO_UNKNOWN                        1200
#define IDS_VETO_LEGACYDEVICE                   1201
#define IDS_VETO_PENDINGCLOSE                   1202
#define IDS_VETO_WINDOWSAPP                     1203
#define IDS_VETO_WINDOWSSERVICE                 1204
#define IDS_VETO_OUTSTANDINGOPEN                1205
#define IDS_VETO_DEVICE                         1206
#define IDS_VETO_DRIVER                         1207
#define IDS_VETO_ILLEGALDEVICEREQUEST           1208
#define IDS_VETO_INSUFFICIENTPOWER              1209
#define IDS_VETO_NONDISABLEABLE                 1210
#define IDS_VETO_LEGACYDRIVER                   1211
#define IDS_VETO_INSUFFICIENT_RIGHTS            1212
#define IDS_VETO_UNKNOWNWINDOWSAPP              1299

#define IDS_DOCKVETO_BASE                       1500
#define IDS_DOCKVETO_UNKNOWN                    1500
#define IDS_DOCKVETO_LEGACYDEVICE               1501
#define IDS_DOCKVETO_PENDINGCLOSE               1502
#define IDS_DOCKVETO_WINDOWSAPP                 1503
#define IDS_DOCKVETO_WINDOWSSERVICE             1504
#define IDS_DOCKVETO_OUTSTANDINGOPEN            1505
#define IDS_DOCKVETO_DEVICE                     1506
#define IDS_DOCKVETO_DRIVER                     1507
#define IDS_DOCKVETO_ILLEGALDEVICEREQUEST       1508
#define IDS_DOCKVETO_INSUFFICIENTPOWER          1509
#define IDS_DOCKVETO_NONDISABLEABLE             1510
#define IDS_DOCKVETO_LEGACYDRIVER               1511
#define IDS_DOCKVETO_INSUFFICIENT_RIGHTS        1512
#define IDS_DOCKVETO_WARM_EJECT                 1598
#define IDS_DOCKVETO_UNKNOWNWINDOWSAPP          1599

#define IDS_SLEEPVETO_BASE                      1600
#define IDS_SLEEPVETO_UNKNOWN                   1600
#define IDS_SLEEPVETO_LEGACYDEVICE              1601
#define IDS_SLEEPVETO_PENDINGCLOSE              1602
#define IDS_SLEEPVETO_WINDOWSAPP                1603
#define IDS_SLEEPVETO_WINDOWSSERVICE            1604
#define IDS_SLEEPVETO_OUTSTANDINGOPEN           1605
#define IDS_SLEEPVETO_DEVICE                    1606
#define IDS_SLEEPVETO_DRIVER                    1607
#define IDS_SLEEPVETO_ILLEGALDEVICEREQUEST      1608
#define IDS_SLEEPVETO_INSUFFICIENTPOWER         1609
#define IDS_SLEEPVETO_NONDISABLEABLE            1610
#define IDS_SLEEPVETO_LEGACYDRIVER              1611
#define IDS_SLEEPVETO_INSUFFICIENT_RIGHTS       1612
#define IDS_SLEEPVETO_UNKNOWNWINDOWSAPP         1699

#define IDS_HIBERNATEVETO_BASE                  1700
#define IDS_HIBERNATEVETO_UNKNOWN               1700
#define IDS_HIBERNATEVETO_LEGACYDEVICE          1701
#define IDS_HIBERNATEVETO_PENDINGCLOSE          1702
#define IDS_HIBERNATEVETO_WINDOWSAPP            1703
#define IDS_HIBERNATEVETO_WINDOWSSERVICE        1704
#define IDS_HIBERNATEVETO_OUTSTANDINGOPEN       1705
#define IDS_HIBERNATEVETO_DEVICE                1706
#define IDS_HIBERNATEVETO_DRIVER                1707
#define IDS_HIBERNATEVETO_ILLEGALDEVICEREQUEST  1708
#define IDS_HIBERNATEVETO_INSUFFICIENTPOWER     1709
#define IDS_HIBERNATEVETO_NONDISABLEABLE        1710
#define IDS_HIBERNATEVETO_LEGACYDRIVER          1711
#define IDS_HIBERNATEVETO_INSUFFICIENT_RIGHTS   1712
#define IDS_HIBERNATEVETO_UNKNOWNWINDOWSAPP     1799

#define IDS_VETOED_EJECT_TITLE          2254
#define IDS_VETOED_REMOVAL_TITLE        2257
#define IDS_VETOED_UNDOCK_TITLE         2258
#define IDS_UNDOCK_COMPLETE_TEXT        2259
#define IDS_REMOVAL_COMPLETE_TEXT       2260
#define IDS_REMOVAL_COMPLETE_TITLE      2261
#define IDS_UNDOCK_COMPLETE_TITLE       2262
#define IDS_VETOED_STANDBY_TITLE        2264
#define IDS_VETOED_HIBERNATION_TITLE    2265
#define IDS_BLOCKDRIVER_TITLE           2270
#define IDS_BLOCKDRIVER_MESSAGE         2271
#define IDS_BLOCKDRIVER_FORMAT          2272
#define IDS_CHILDWITHINVALIDID_TITLE    2273
#define IDS_CHILDWITHINVALIDID_FORMAT   2274


#define IDC_STATIC                  -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\idl\imports.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    07-May-1991     danl

        Creation and initial implementation.

    06-June-1995    paulat

        Modified for Plug-and-Play.

Revision History:


--*/

//
// system include files
//
#ifdef MIDL_PASS
#include <windef.h>
#include <winbase.h>
#include <winreg.h>
#else
#include <windows.h>
#endif
#include <cfgmgr32.h>

//
// types
//
#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#endif
#define LPSTR [string] LPSTR
#define BOOL DWORD
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\inc\cfgmgrp.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    cfgmgrp.h

Abstract:

    This module contains private Plug and Play defintions and declarations used
    by the Configuration Manager, the user mode Plug and Play manager, and other
    system components.

Author:

    Paula Tomlinson (paulat) 06/19/1995


Revision History:

    Jim Cavalaris (jamesca) 03/01/2001

        Removed definitions and declarations that are specific to only either
        CFGMGR32 or UMPNPMGR, since this header file is also included privately
        by other system components such as the service control manager (SCM).

--*/

#ifndef _CFGMGRP_H_
#define _CFGMGRP_H_


//
// The following constants are used by PNP_GetVersion / CM_Get_Version to
// retrieve the version of the Configuration Manager APIs.  CONFIGMG_VERSION is
// defined as 0x0400 in the public header cfgmgr32.h and should remain constant
// across all future versions of Windows, for compatibility reasons.
//

#define PNP_VERSION               CONFIGMG_VERSION
#define CFGMGR32_VERSION          CONFIGMG_VERSION


//
// The following constants are used for version negotiation between the client
// and the server, and are for internal use only. CFGMGR32_VERSION_INTERNAL is
// supplied to PNP_GetVersionInternal by the client, and upon successful return
// receives PNP_VERSION_INTERNAL.  For simplicity, these are defined to the
// current version of Windows the corresponding client and server shipped with.
//
// Note that there is no client routine to receive the internal version of the
// server directly.  Instead, CM_Is_Version_Available is provided to determine
// support for a particular version.  The only version publicly defined is
// CFGMG_VERSION, which is constant, and always available.
//

#define PNP_VERSION_INTERNAL      WINVER
#define CFGMGR32_VERSION_INTERNAL WINVER


//
// Common PNP constant definitions
//

#define MAX_DEVICE_INSTANCE_LEN           256
#define MAX_DEVICE_INSTANCE_SIZE          512
#define MAX_SERVICE_NAME_LEN              256
#define MAX_PROFILE_ID_LEN                5
#define MAX_CM_PATH                       360

#define NT_RESLIST_VERSION                (0x00000000)
#define NT_RESLIST_REVISION               (0x00000000)
#define NT_REQLIST_VERSION                (0x00000001)
#define NT_REQLIST_REVISION               (0x00000001)

#define CM_PRIVATE_LOGCONF_SIGNATURE      (0x08156201)
#define CM_PRIVATE_RESDES_SIGNATURE       (0x08156202)
#define CM_PRIVATE_CONFLIST_SIGNATURE     (0x08156203)

#define MAX_LOGCONF_TAG                   (0xFFFFFFFF)
#define MAX_RESDES_TAG                    (0xFFFFFFFF)
#define RESDES_CS_TAG                     (MAX_RESDES_TAG - 1) // class-specific


//
// Action types for PNP_GetRelatedDeviceInstance
//
#define PNP_GET_PARENT_DEVICE_INSTANCE    0x00000001
#define PNP_GET_CHILD_DEVICE_INSTANCE     0x00000002
#define PNP_GET_SIBLING_DEVICE_INSTANCE   0x00000003

//
//  Action types for PNP_DeviceInstanceAction
//
#define PNP_DEVINST_CREATE                0x00000001
#define PNP_DEVINST_MOVE                  0x00000002
#define PNP_DEVINST_SETUP                 0x00000003
#define PNP_DEVINST_ENABLE                0x00000004
#define PNP_DEVINST_DISABLE               0x00000005
#define PNP_DEVINST_REMOVESUBTREE         0x00000006
#define PNP_DEVINST_REENUMERATE           0x00000007
#define PNP_DEVINST_QUERYREMOVE           0x00000008
#define PNP_DEVINST_REQUEST_EJECT         0x00000009

//
// Action types for PNP_EnumerateSubKeys
//
#define PNP_ENUMERATOR_SUBKEYS            0x00000001
#define PNP_CLASS_SUBKEYS                 0x00000002

//
// Action types for PNP_HwProfFlags
//
#define PNP_GET_HWPROFFLAGS               0x00000001
#define PNP_SET_HWPROFFLAGS               0x00000002

//
// flags for PNP_SetActiveService
//
#define PNP_SERVICE_STARTED               0x00000001
#define PNP_SERVICE_STOPPED               0x00000002


//
// Mask for Flags argument to CMP_RegisterNotification, PNP_RegisterNotification
// Must be kept in sync with RegisterDeviceNotification flags, in winuser.h and
// winuserp.h.
//

//#define DEVICE_NOTIFY_WINDOW_HANDLE          0x00000000
//#define DEVICE_NOTIFY_SERVICE_HANDLE         0x00000001
//#define DEVICE_NOTIFY_COMPLETION_HANDLE      0x00000002
#define DEVICE_NOTIFY_HANDLE_MASK            0x00000003

//#define DEVICE_NOTIFY_ALL_INTERFACE_CLASSES  0x00000004
#define DEVICE_NOTIFY_PROPERTY_MASK          0x00FFFFFC

#define DEVICE_NOTIFY_WOW64_CLIENT           0x01000000
#define DEVICE_NOTIFY_RESERVED_MASK          0xFF000000

#define DEVICE_NOTIFY_BITS (DEVICE_NOTIFY_HANDLE_MASK|DEVICE_NOTIFY_ALL_INTERFACE_CLASSES|DEVICE_NOTIFY_WOW64_CLIENT)

//
// Flags returned from CMP_GetServerSideDeviceInstallFlags
//
#define SSDI_REBOOT_PENDING                 0x00000001


//-------------------------------------------------------------------
// Private routines for Service Notifications, exported from
// UMPNPMGR.dll for use by the Service Control Manager only.
//-------------------------------------------------------------------

//
// Prototype definitions for the private routines supplied to the User-mode Plug
// and Play service for direct communication with the Service Control Manager.
//

typedef
DWORD
(*PSCMCALLBACK_ROUTINE) (
    IN  SERVICE_STATUS_HANDLE hServiceStatus,
    IN  DWORD         OpCode,
    IN  DWORD         dwEventType,  // PnP wParam
    IN  LPARAM        EventData,    // PnP lParam
    IN  PDWORD        result
    );

typedef
DWORD
(*PSCMAUTHENTICATION_CALLBACK) (
    IN  LPWSTR                 lpServiceName,
    OUT SERVICE_STATUS_HANDLE  *lphServiceStatus
    );


//
// Private routines called by the Service Controller to supply (and revoke)
// entrypoints for the above routines. (Note - UnRegisterScmCallback is not
// currently used by the SCM, and is consequently not exported by UMPNPMGR)
//

CONFIGRET
RegisterScmCallback(
    IN  PSCMCALLBACK_ROUTINE         pScCallback,
    IN  PSCMAUTHENTICATION_CALLBACK  pScAuthCallback
    );

CONFIGRET
UnRegisterScmCallback(
    VOID
    );


//
// Private routine called by the Service Controller to register a service to
// receive notification events other than device events, that are also delivered
// by Plug and Play (i.e. hardware profile change events, power events).
//

CONFIGRET
RegisterServiceNotification(
    IN  SERVICE_STATUS_HANDLE hService,
    IN  LPWSTR pszService,
    IN  DWORD  scControls,
    IN  BOOL   bServiceStopped
    );


//
// Private routine caled by the Service Controller whenever a service is deleted
// to delete any Plug and Play registry keys for a service (and uninstall the
// devnode when necessary).
//

CONFIGRET
DeleteServicePlugPlayRegKeys(
    IN  LPWSTR   pszService
    );


//
// Private routine called by the Service Controller to set the ActiveService for
// devices controlled by the specified service.
// [Note that this routine is NOT an RPC server routine, it is exported only!!]
//

CONFIGRET
PNP_SetActiveService(
    IN  handle_t   hBinding,
    IN  LPCWSTR    pszService,
    IN  ULONG      ulFlags
    );

//
// Private routine to get the current list of blocked drivers (GUIDs).
//

CONFIGRET
CMP_GetBlockedDriverInfo(
    OUT LPBYTE      Buffer,
    IN OUT PULONG   pulLength,
    IN ULONG        ulFlags,
    IN  HMACHINE    hMachine
    );

//
// Private routine to get server side device install flags.
//

CONFIGRET
CMP_GetServerSideDeviceInstallFlags(
    IN  PULONG      pulSSDIFlags,
    IN  ULONG       ulFlags,
    IN  HMACHINE    hMachine
    );

#endif // _CFGMGRP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\inc\ppmacros.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    ppmacros.h

Abstract:

    This header defines various generic macros for use by user mode Plug and
    Play system components.

Author:

    Jim Cavalaris (jamesca) 03/01/2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _PPMACROS_H_
#define _PPMACROS_H_


//
// Debug output is filtered at two levels: A global level and a component
// specific level.
//
// Each debug output request specifies a component id and a filter level
// or mask. These variables are used to access the debug print filter
// database maintained by the system. The component id selects a 32-bit
// mask value and the level either specified a bit within that mask or is
// the mask value itself.
//
// If any of the bits specified by the level or mask are set in either the
// component mask or the global mask, then the debug output is permitted.
// Otherwise, the debug output is filtered and not printed.
//
// The component mask for filtering the debug output of this component is
// Kd_PNPMGR_Mask and may be set via the registry or the kernel debugger.
//
// The global mask for filtering the debug output of all components is
// Kd_WIN2000_Mask and may be set via the registry or the kernel debugger.
//
// The registry key for setting the mask value for this component is:
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\
//     Session Manager\Debug Print Filter\PNPMGR
//
// The key "Debug Print Filter" may have to be created in order to create
// the component key.
//
// The following levels are used to filter debug output.
//

#define DBGF_ERRORS                       (0x00000001 | DPFLTR_MASK)
#define DBGF_WARNINGS                     (0x00000002 | DPFLTR_MASK)
#define DBGF_EVENT                        (0x00000010 | DPFLTR_MASK)
#define DBGF_REGISTRY                     (0x00000020 | DPFLTR_MASK)
#define DBGF_INSTALL                      (0x00000040 | DPFLTR_MASK)


//
// ASSERT macros
//

#ifdef MYASSERT
#undef MYASSERT
#endif
#if ASSERTS_ON
#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }
#else
#define MYASSERT(x)
#endif


//
// macros for setting and testing flags
//

#define SET_FLAG(Status, Flag)            ((Status) |= (Flag))
#define CLEAR_FLAG(Status, Flag)          ((Status) &= ~(Flag))
#define INVALID_FLAGS(ulFlags, ulAllowed) ((ulFlags) & ~(ulAllowed))
#define TEST_FLAGS(t,ulMask, ulBit)       (((t)&(ulMask)) == (ulBit))
#define IS_FLAG_SET(t,ulMask)             TEST_FLAGS(t,ulMask,ulMask)
#define IS_FLAG_CLEAR(t,ulMask)           TEST_FLAGS(t,ulMask,0)


//
// other useful macros
//

#define ARRAY_SIZE(array)                 (sizeof(array)/sizeof(array[0]))
#define SIZECHARS(x)                      (sizeof((x))/sizeof(TCHAR))


#endif // _PPMACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\inc\pnpipc.h ===
/*++

Copyright (c) 1989-2001  Microsoft Corporation

Module Name:

    pnpipc.h

Abstract:

    This module contains the private defintions used by various
    user-mode pnp components to communicate.

Author:

    Paula Tomlinson (paulat) 02/21/1996

Environment:

    User-mode only.

Revision History:

    27-February-2001     jamesca

        Additional CFGMGR32-specific and UMPNPMGR-specific definitions.
        Constrained header file to only those

--*/

#ifndef _PNPIPC_H_
#define _PNPIPC_H_


//
// Module names of support libraries and executables.
//

#define SETUPAPI_DLL                    TEXT("setupapi.dll")
#define NEWDEV_DLL                      TEXT("newdev.dll")
#define HOTPLUG_DLL                     TEXT("hotplug.dll")
#define RUNDLL32_EXE                    TEXT("rundll32.exe")
#define NTSD_EXE                        TEXT("ntsd.exe")

#define WINSTA_DLL                      TEXT("winsta.dll")
#define WTSAPI32_DLL                    TEXT("wtsapi32.dll")


//
// Pending install event, shared by cfgmgr32 and umpnpmgr.
// This event is always created in the Global (i.e. Session 0) object namespace.
//

#define PNP_NO_INSTALL_EVENTS           TEXT("Global\\PnP_No_Pending_Install_Events")


//
// Named pipe, events, and timeouts used with GUI setup.
//

#define PNP_NEW_HW_PIPE                 TEXT("\\\\.\\pipe\\PNP_New_HW_Found")
#define PNP_CREATE_PIPE_EVENT           TEXT("PNP_Create_Pipe_Event")
#define PNP_BATCH_PROCESSED_EVENT       TEXT("PNP_Batch_Processed_Event")

#define PNP_PIPE_TIMEOUT                60000  // 60 seconds
#define PNP_GUISETUP_INSTALL_TIMEOUT    60000  // 60 seconds


//
// Named pipe, events, and timeouts used for communication with newdev.
//

#define PNP_DEVICE_INSTALL_PIPE         TEXT("\\\\.\\pipe\\PNP_Device_Install_Pipe")
#define PNP_DEVICE_INSTALL_EVENT        TEXT("PNP_Device_Install_Event")

// Flags to specify behavior of the device install client (newdev.dll).
#define DEVICE_INSTALL_UI_ONLY              0x00000001
#define DEVICE_INSTALL_FINISHED_REBOOT      0x00000002
#define DEVICE_INSTALL_PLAY_SOUND           0x00000004
#define DEVICE_INSTALL_BATCH_COMPLETE       0x00000008
#define DEVICE_INSTALL_PROBLEM              0x00000010
#define DEVICE_INSTALL_DISPLAY_ON_CONSOLE   0x00010000

// Bitmask for only those flags sent to newdev.dll.
#define DEVICE_INSTALL_CLIENT_MASK          0x0000FFFF
#define DEVICE_INSTALL_SERVER_MASK          0xFFFF0000

// Length of time to allow 'device install complete' bubble to be displayed.
#define DEVICE_INSTALL_COMPLETE_WAIT_TIME         3000  //  3 seconds
#define DEVICE_INSTALL_COMPLETE_DISPLAY_TIME     10000  // 10 seconds


//
// Named pipe, events, and timeouts used for communication with hotplug.
//

#define PNP_HOTPLUG_PIPE                TEXT("\\\\.\\pipe\\PNP_HotPlug_Pipe")
#define PNP_HOTPLUG_EVENT               TEXT("PNP_HotPlug_Event")

// Flags to specify behavior of the hotplug client (hotplug.dll).
#define HOTPLUG_DISPLAY_ON_CONSOLE          0x00010000


//
// Default WindowStation and Desktop names for launching hotplug and newdev
// processes on an interactive user's desktop.
//

#define DEFAULT_WINSTA                  TEXT("WinSta0")
#define DEFAULT_DESKTOP                 TEXT("Default")
#define DEFAULT_INTERACTIVE_DESKTOP     TEXT("WinSta0\\Default")


#endif // _PNPIPC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\lib\locks.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    locks.c

Abstract:

    This module contains locking routines used by both cfgmgr32
    and umpnpmgr.

            InitPrivateResource
            DestroyPrivateResource

Author:

    Jim Cavalaris (jamesca) 03-15-2001

Environment:

    User mode only.

Revision History:

    15-March-2001     jamesca

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnplib.h"



//
// Common locking routines, used by client and server.
// (LOCKINFO type definition and inline lock / unlock routines defined in
// umpnplib.h)
//

BOOL
InitPrivateResource(
    OUT PLOCKINFO Lock
    )

/*++

Routine Description:

    Initialize a lock structure to be used with Synchronization routines.

Arguments:

    LockHandles - supplies structure to be initialized. This routine creates
        the locking event and mutex and places handles in this structure.

Return Value:

    TRUE if the lock structure was successfully initialized. FALSE if not.

--*/

{

    Lock->LockHandles[DESTROYED_EVENT] = CreateEvent(NULL, TRUE, FALSE, NULL);

    if (Lock->LockHandles[DESTROYED_EVENT] != NULL) {

        Lock->LockHandles[ACCESS_MUTEX] = CreateMutex(NULL, FALSE, NULL);

        if (Lock->LockHandles[ACCESS_MUTEX] != NULL) {
            return TRUE;
        }

        CloseHandle(Lock->LockHandles[DESTROYED_EVENT]);

        Lock->LockHandles[DESTROYED_EVENT] = NULL;
    }

    return FALSE;

} // InitPrivateResource



VOID
DestroyPrivateResource(
    IN OUT PLOCKINFO Lock
    )

/*++

Routine Description:

    Tears down a lock structure created by InitPrivateResource.
    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    LockHandle - supplies structure to be torn down. The structure itself
        is not freed.

Return Value:

    None.

--*/

{
    HANDLE h1,h2;

    h1 = Lock->LockHandles[DESTROYED_EVENT];
    h2 = Lock->LockHandles[ACCESS_MUTEX];

    Lock->LockHandles[DESTROYED_EVENT] = NULL;
    Lock->LockHandles[ACCESS_MUTEX] = NULL;

    CloseHandle(h2);

    SetEvent(h1);
    CloseHandle(h1);

    return;

} // DestroyPrivateResource



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\lib\precomp.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    precomp.h

Abstract:

    Precompiled header file for the statically linked library that is shared by
    both the Configuration Manager client DLL and User-Mode Plug and Play
    manager server DLL

Author:

    Jim Cavalaris (jamesca) 03-01-2001

Environment:

    User-mode only.

Revision History:

    01-March-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _PRECOMP_H_
#define _PRECOMP_H_

//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Win32 Public Header Files
//
#include <windows.h>
#include <regstr.h>
#include <strsafe.h>

//
// CRT Header Files
//
#include <stdlib.h>

//
// RPC Header Files
//
#include <ntrpcp.h>     // needed for rpcasync.h
#include <rpcasync.h>   // I_RpcExceptionFilter

//
// Private Header Files
//
#include "pnp.h"        // midl generated, rpc interfaces
#include "cfgmgrp.h"    // private shared header, needs handle_t so must follow pnp.h
#include "ppmacros.h"   // private macros / debug header

#endif // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\lib\cutil.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cutil.c

Abstract:

    This module contains general utility routines used by both cfgmgr32
    and umpnpmgr.

            IsLegalDeviceId
            SplitString
            SplitDeviceInstanceString
            SplitClassInstanceString
            DeletePrivateKey
            RegDeleteNode
            GetDevNodeKeyPath
            MapRpcExceptionToCR

Author:

    Paula Tomlinson (paulat) 7-12-1995

Environment:

    User mode only.

Revision History:

    12-July-1995     paulat

        Creation and initial implementation.

--*/


//
// includes
//
#include "precomp.h"
#pragma hdrstop
#include "umpnplib.h"



//
// Common private utility routines (used by client and server)
//


BOOL
IsLegalDeviceId(
    IN  LPCWSTR    pszDeviceInstance
    )

/*++

Routine Description:

    This routine parses the device instance string and validates whether it
    conforms to the appropriate rules, including:

    - Total length of the device instance path must not be longer than
      MAX_DEVICE_ID_LEN characters.

    - The device instance path must contain exactly 3 non-empty path components.

    - The device instance path string must not contain any "invalid characters".

      Invalid characters are:
          c <= 0x20 (' ')
          c >  0x7F
          c == 0x2C (',')

Arguments:

    pszDeviceInstance - Device instance path.

Return value:

    The return value is TRUE if the device instance path string conforms to the
    rules.

--*/

{
    BOOL    Status;
    LPCWSTR p;
    ULONG   ulComponentLength = 0, ulComponents = 1;
    HRESULT hr;
    size_t  len;

    try {
        //
        // A NULL or empty string is used for an optional device instance path.
        //
        // NOTE - Callers must explicitly check for this case themselves if it
        // is not valid for a particular scenario.
        //
        if ((!ARGUMENT_PRESENT(pszDeviceInstance)) ||
            (*pszDeviceInstance == L'\0')) {
            Status = TRUE;
            goto Clean0;
        }

        //
        // Make sure the device instance path isn't too long.
        //
        hr = StringCchLength(pszDeviceInstance,
                             MAX_DEVICE_ID_LEN,
                             &len);
        if (FAILED(hr)) {
            Status = FALSE;
            goto Clean0;
        }

        //
        // Walk over the entire device instance path, counting individual path
        // component lengths, and checking for the presence of invalid
        // characters.
        //
        for (p = pszDeviceInstance; *p; p++) {

            //
            // Check for the presence of invalid characters.
            //
            if ((*p <= L' ')  || (*p > (WCHAR)0x7F) || (*p == L',')) {
                Status = FALSE;
                goto Clean0;
            }

            //
            // Check the length of individual path components.
            //
            if (*p == L'\\') {

                //
                // It is illegal for a device instance path to have multiple
                // consecutive path separators, or to start with one.
                //
                if (ulComponentLength == 0) {
                    Status = FALSE;
                    goto Clean0;
                }

                ulComponentLength = 0;
                ulComponents++;

            } else {
                //
                // Count the length of this path component to verify it's not empty.
                //
                ulComponentLength++;
            }
        }

        //
        // It is illegal for a device instance path to end with a path separator
        // character.
        //
        if (ulComponentLength == 0) {
            Status = FALSE;
            goto Clean0;
        }

        //
        // A valid device instance path must contain exactly 3 path components:
        // an enumerator id, a device id, and an instance id.
        //
        if (ulComponents != 3) {
            Status = FALSE;
            goto Clean0;
        }

        //
        // Success.
        //
        Status = TRUE;

    Clean0:
        NOTHING;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = FALSE;
    }

    return Status;

} // IsLegalDeviceId



BOOL
SplitString(
    IN  LPCWSTR    SourceString,
    IN  WCHAR      SearchChar,
    IN  ULONG      nOccurrence,
    OUT LPWSTR     String1,
    IN  ULONG      Length1,
    OUT LPWSTR     String2,
    IN  ULONG      Length2
    )

/*++

Routine Description:

    Splits a string into two substring parts, occuring at at the specified
    instance of the specified search charatcter.

Arguments:

    SourceString - Specifies the string to be split.

    SearchChar   - Specifies the character to search for.

    nOccurrence  - Specifies the instance of the search character in the source
                   string to split the string at.

    String1      - Specifies a buffer to receive the first substring component.

    Length1      - Specifies the length, in characters of the buffer specified
                   by String1.

    String2      - Specifies a buffer to receive the second substring component.

    Length2      - Specifies the length, in characters of the buffer specified
                   by String2.
Return Value:

    The return value is TRUE if the function suceeds and FALSE if it fails.

Notes:

    The buffers specified by String1 and String2 should be large enough to hold
    the SourceString.

--*/

{
    BOOL    Status = TRUE;
    HRESULT hr;
    LPWSTR  p;
    ULONG   i;

    try {
        //
        // make sure valid buffers were supplied
        //
        if ((SourceString == NULL) ||
            (String1 == NULL) || (Length1 == 0) ||
            (String2 == NULL) || (Length2 == 0)) {
            Status = FALSE;
            goto Clean0;
        }

        //
        // initialize the output strings
        //
        *String1 = L'\0';
        *String2 = L'\0';

        //
        // copy the entire source string to String1
        //
        hr = StringCchCopyEx(String1,
                             Length1,
                             SourceString,
                             NULL, NULL,
                             STRSAFE_NULL_ON_FAILURE);
        if (FAILED(hr)) {
            Status = FALSE;
            goto Clean0;
        }

        //
        // if splitting at the zero'th occurrence of a character, return the
        // entire source string as String1.
        //
        if (nOccurrence == 0) {
            Status = TRUE;
            goto Clean0;
        }

        //
        // Special case the NULL search character.
        //
        if (SearchChar == L'\0') {

            if (nOccurrence == 1) {
                //
                // since the source string must be NULL terminated, splitting at
                // the first occurrence of a NULL character returns the source
                // string as String1, and an empty string as String2.
                //
                Status = TRUE;
            } else {
                //
                // requesting any other instance of a NULL character returns an
                // error, and no strings.
                //
                *String1 = L'\0';
                Status = FALSE;
            }
            goto Clean0;
        }

        //
        // find the nth instance of the delimiter character.  note that we know
        // the buffer is NULL terminated before Length1 characters, so we can
        // walk the string safely, all the to the end if necessary.
        //
        p = String1;
        i = 0;

        for (i = 0; i < nOccurrence; i++) {
            //
            // search for the nth occurrence of the search character
            //
            p = wcschr(p, SearchChar);

            //
            // if we're reached the end of the string, we're done.
            //
            if (p == NULL) {
                break;
            }

            //
            // start the next search immediately following this occurrence of
            // the search character
            //
            p++;
        }

        if (p == NULL) {
            //
            // there's no such occurance of the delimeter character in the
            // string.  return an error, but return the entire string in
            // String1 so the caller knows why the failure occured..
            //
            Status = FALSE;
            goto Clean0;
        }

        ASSERT(p != String1);
        ASSERT((*(p - 1)) == SearchChar);

        //
        // separate the first string from the rest of the string by NULL'ing out
        // this occurance the search character.
        //
        *(p - 1) = L'\0';

        //
        // if there's nothing left, we're done.
        //
        if (*p == L'\0') {
            Status = TRUE;
            goto Clean0;
        }

        //
        // copy the remainder of the string to string2.
        //
        hr = StringCchCopyEx(String2,
                             Length2,
                             p,
                             NULL, NULL,
                             STRSAFE_NULL_ON_FAILURE);
        ASSERT(SUCCEEDED(hr));
        if (FAILED(hr)) {
            *String1 = L'\0';
            Status = FALSE;
            goto Clean0;
        }

        //
        // Success
        //
        Status = TRUE;

   Clean0:
      NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
      Status = FALSE;
   }

   return Status;

} // SplitString



BOOL
SplitDeviceInstanceString(
   IN  LPCWSTR  pszDeviceInstance,
   OUT LPWSTR   pszEnumerator,
   OUT LPWSTR   pszDeviceID,
   OUT LPWSTR   pszInstanceID
   )

/*++

Routine Description:

    This routine parses a device instance string into it's three component
    parts.  This routine assumes that the specified device instance is a valid
    device instance path, whose length is no more than MAX_DEVICE_ID_LEN
    characters, including the NULL terminating character.

    This routine assumes that each of the buffers supplied to receive the device
    instance path components are each at least MAX_DEVICE_ID_LEN characters in
    length.

Arguments:

    pszDeviceInstance - Specifies a complete device instance path to separate
                        into it's constituent parts.

    pszEnumerator     - Specifies a buffer to receive the Enumerator component
                        of the device instance path.

    pszDeviceID       - Specifies a buffer to receive the Device ID component
                        of the device instance path.

    pszInstanceID     - Specifies a buffer to receive the Instance ID component
                        of the device instance path.

Return value:

    The return value is TRUE if the function suceeds and FALSE if it fails.

--*/

{
    BOOL  Status;
    WCHAR szTempString[MAX_DEVICE_ID_LEN];

    //
    // initialize the output strings
    //
    *pszEnumerator = L'\0';
    *pszDeviceID   = L'\0';
    *pszInstanceID = L'\0';

    //
    // Split off the enumerator component.
    //
    Status =
        SplitString(
            pszDeviceInstance,
            L'\\',
            1,
            pszEnumerator,
            MAX_DEVICE_ID_LEN,
            szTempString,
            MAX_DEVICE_ID_LEN
            );

    if (Status) {
        //
        // Split off the device id component.  Consider the rest to be the
        // instance id.  The device instance id should have been previously
        // validated to ensure that it has exactly thee components.
        //
        Status =
            SplitString(
                szTempString,
                L'\\',
                1,
                pszDeviceID,
                MAX_DEVICE_ID_LEN,
                pszInstanceID,
                MAX_DEVICE_ID_LEN
                );
    }

    return Status;

} // SplitDeviceInstanceString



BOOL
SplitClassInstanceString(
    IN  LPCWSTR    pszClassInstance,
    OUT LPWSTR     pszClass,
    OUT LPWSTR     pszInstance
    )

/*++

Routine Description:

    This routine parses a class instance string into it's two component
    parts.  This routine assumes that the specified device instance is a valid
    class instance path, whose length is no more than MAX_GUID_STRING_LEN + 5
    characters, including the NULL terminating character.

    This routine assumes that each of the buffers supplied to receive the device
    instance path components are each at least MAX_GUID_STRING_LEN + 5
    characters in length.

Arguments:

    pszClassInstance  - Specifies a complete class instance path to separate
                        into it's constituent parts.

    pszClass          - Specifies a buffer to receive the ClassGUID component
                        of the class instance path.

    pszInstance       - Specifies a buffer to receive the Instance component
                        of the class instance path.

Return value:

    The return value is TRUE if the function suceeds and FALSE if it fails.

--*/

{
    BOOL  Status;

    //
    // initialize the output strings
    //
    *pszClass    = L'\0';
    *pszInstance = L'\0';

    //
    // Split off the class and instance components.
    //
    Status =
        SplitString(
            pszClassInstance,
            L'\\',
            1,
            pszClass,
            MAX_GUID_STRING_LEN + 5,
            pszInstance,
            MAX_GUID_STRING_LEN + 5
            );

    return Status;

} // SplitClassInstanceString



CONFIGRET
DeletePrivateKey(
   IN HKEY     hBranchKey,
   IN LPCWSTR  pszParentKey,
   IN LPCWSTR  pszChildKey
   )
{
   CONFIGRET   Status = CR_SUCCESS;
   LONG        RegStatus = ERROR_SUCCESS;
   WCHAR       RegStr[2 * MAX_CM_PATH];
   WCHAR       szKey1[MAX_CM_PATH], szKey2[MAX_CM_PATH];
   HKEY        hKey = NULL;
   ULONG       ulSubKeys = 0;
   HRESULT     hr;
   size_t      ParentKeyLen = 0, ChildKeyLen = 0;


   try {
       //
       // Make sure the specified registry key paths are valid.
       //
       if ((!ARGUMENT_PRESENT(pszParentKey)) ||
           (!ARGUMENT_PRESENT(pszChildKey))) {
           Status = CR_INVALID_POINTER;
           goto Clean0;
       }

       hr = StringCchLength(pszParentKey,
                            MAX_CM_PATH,
                            &ParentKeyLen);
       if (FAILED(hr) || (ParentKeyLen == 0)) {
           Status = CR_INVALID_POINTER;
           goto Clean0;
       }

       hr = StringCchLength(pszChildKey,
                            MAX_CM_PATH,
                            &ChildKeyLen);
       if (FAILED(hr) || (ChildKeyLen == 0)) {
           Status = CR_INVALID_POINTER;
           goto Clean0;
       }

       //
       // is the specified child key a compound registry key?
       //
       if (!SplitString(pszChildKey,
                        L'\\',
                        1,
                        szKey1,
                        SIZECHARS(szKey1),
                        szKey2,
                        SIZECHARS(szKey2))) {

           //------------------------------------------------------------------
           // If unable to split the string, assume only a single child key
           // was specified, so just open the parent registry key and delete
           // the child (and any of its subkeys)
           //------------------------------------------------------------------

           if (RegOpenKeyEx(hBranchKey, pszParentKey, 0,
                            KEY_READ | KEY_WRITE, &hKey) != ERROR_SUCCESS) {
               goto Clean0;   // no error, nothing to delete
           }

           if (!RegDeleteNode(hKey, pszChildKey)) {
               Status = CR_REGISTRY_ERROR;
               goto Clean0;
           }

       } else {

           //------------------------------------------------------------------
           // if a compound registry path was passed in, such as key1\key2
           // then always delete key2 but delete key1 only if it has no other
           // subkeys besides key2.
           //------------------------------------------------------------------

           //
           // open the first level key
           //
           hr = StringCchPrintf(RegStr,
                                SIZECHARS(RegStr),
                                L"%s\\%s",
                                pszParentKey,
                                szKey1);
           ASSERT(SUCCEEDED(hr));
           if (FAILED(hr)) {
               Status = CR_FAILURE;
               goto Clean0;
           }

           RegStatus = RegOpenKeyEx(
               hBranchKey, RegStr, 0, KEY_QUERY_VALUE | KEY_SET_VALUE,
               &hKey);

           if (RegStatus != ERROR_SUCCESS) {
               goto Clean0;         // no error, nothing to delete
           }

           //
           // try to delete the second level key
           //
           if (!RegDeleteNode(hKey, szKey2)) {
               goto Clean0;         // no error, nothing to delete
           }

           //
           // How many subkeys are remaining?
           //
           RegStatus = RegQueryInfoKey(
               hKey, NULL, NULL, NULL, &ulSubKeys,
               NULL, NULL, NULL, NULL, NULL, NULL, NULL);

           if (RegStatus != ERROR_SUCCESS) {
               goto Clean0;         // nothing to delete
           }

           //
           // if no more subkeys, then delete the first level key
           //
           if (ulSubKeys == 0) {

               RegCloseKey(hKey);
               hKey = NULL;

               RegStatus = RegOpenKeyEx(
                   hBranchKey, pszParentKey, 0,
                   KEY_QUERY_VALUE | KEY_SET_VALUE, &hKey);

               if (RegStatus != ERROR_SUCCESS) {
                   goto Clean0;         // no error, nothing to delete
               }

               if (!RegDeleteNode(hKey, szKey1)) {
                   Status = CR_REGISTRY_ERROR;
                   goto Clean0;
               }
           }
       }

   Clean0:
       NOTHING;

   } except(EXCEPTION_EXECUTE_HANDLER) {
       Status = CR_FAILURE;

       //
       // Reference the following variables so the compiler will respect
       // statement ordering w.r.t. their assignment.
       //
       hKey = hKey;
   }

   if (hKey != NULL) {
      RegCloseKey(hKey);
   }

   return Status;

} // DeletePrivateKey



BOOL
RegDeleteNode(
   HKEY     hParentKey,
   LPCWSTR   szKey
   )
{
   ULONG ulSize = 0;
   LONG  RegStatus = ERROR_SUCCESS;
   HKEY  hKey = NULL;
   WCHAR szSubKey[MAX_PATH];


   //
   // attempt to delete the key
   //
   if (RegDeleteKey(hParentKey, szKey) != ERROR_SUCCESS) {

      //
      // If we couldn't delete the key itself, delete any subkeys it may have.
      // In case the specified key is actually a registry link, always open it
      // directly, rather than the target of the link.  The target may point
      // outside this subtree, and we're only looking to delete subkeys.
      //
      RegStatus = RegOpenKeyEx(
          hParentKey, szKey,
          REG_OPTION_OPEN_LINK,
          KEY_ALL_ACCESS, &hKey);

      //
      // enumerate subkeys and delete those nodes
      //
      while (RegStatus == ERROR_SUCCESS) {
         //
         // enumerate the first level children under the profile key
         // (always use index 0, enumeration looses track when a key
         // is added or deleted)
         //
         ulSize = MAX_PATH;
         RegStatus = RegEnumKeyEx(
                  hKey, 0, szSubKey, &ulSize, NULL, NULL, NULL, NULL);

         if (RegStatus == ERROR_SUCCESS) {
            RegDeleteNode(hKey, szSubKey);
         }
      }

      //
      // either an error occured that prevents me from deleting the
      // keys (like the key doesn't exist in the first place or an
      // access violation) or the subkeys have been deleted, try
      // deleting the top level key again
      //
      RegCloseKey(hKey);
      RegDeleteKey(hParentKey, szKey);
   }

   return TRUE;

} // RegDeleteNode



CONFIGRET
GetDevNodeKeyPath(
    IN  handle_t   hBinding,
    IN  LPCWSTR    pDeviceID,
    IN  ULONG      ulFlags,
    IN  ULONG      ulHardwareProfile,
    OUT LPWSTR     pszBaseKey,
    IN  ULONG      ulBaseKeyLength,
    OUT LPWSTR     pszPrivateKey,
    IN  ULONG      ulPrivateKeyLength,
    IN  BOOL       bCreateAlways
    )

{
   CONFIGRET   Status = CR_SUCCESS;
   WCHAR       szClassInstance[MAX_PATH], szEnumerator[MAX_DEVICE_ID_LEN];
   WCHAR       szTemp[MAX_PATH];
   ULONG       ulSize, ulDataType = 0;
   ULONG       ulTransferLen;
   HRESULT     hr;


   if (ulFlags & CM_REGISTRY_SOFTWARE) {
      //-------------------------------------------------------------
      // form the key for the software branch case
      //-------------------------------------------------------------

      //
      // retrieve the class name and instance ordinal by calling
      // the server's reg prop routine
      //
      ulSize = ulTransferLen = sizeof(szClassInstance);
      szClassInstance[0] = L'\0';

      RpcTryExcept {
         //
         // call rpc service entry point
         //
         // if calling from the client-side, this is a call to the rpc client
         // stub, resulting in an rpc call to the server.  if calling from
         // the server-side, this is simply a call to the server routine
         // directly.
         //
         Status = PNP_GetDeviceRegProp(
             hBinding,
             pDeviceID,
             CM_DRP_DRIVER,
             &ulDataType,
             (LPBYTE)szClassInstance,
             &ulTransferLen,
             &ulSize,
             0);
      }
      RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
         KdPrintEx((DPFLTR_PNPMGR_ID,
                    DBGF_ERRORS,
                    "PNP_GetDeviceRegProp caused an exception (%d)\n",
                    RpcExceptionCode()));

         Status = MapRpcExceptionToCR(RpcExceptionCode());
      }
      RpcEndExcept

      if (((Status != CR_SUCCESS) ||
           (szClassInstance[0] == L'\0')) && (bCreateAlways)) {

         //
         // no Driver (class instance) value yet so ask the server to
         // create a new unique one
         //
         ulSize = sizeof(szClassInstance);

         RpcTryExcept {
            //
            // call rpc service entry point
            //
            // if calling from the client-side, this is a call to the rpc client
            // stub, resulting in an rpc call to the server.  if calling from
            // the server-side, this is simply a call to the server routine
            // directly.
            //
            Status = PNP_GetClassInstance(
                hBinding,
                pDeviceID,
                szClassInstance,
                ulSize);
         }
         RpcExcept (I_RpcExceptionFilter(RpcExceptionCode())) {
            KdPrintEx((DPFLTR_PNPMGR_ID,
                       DBGF_ERRORS,
                       "PNP_GetClassInstance caused an exception (%d)\n",
                       RpcExceptionCode()));

            Status = MapRpcExceptionToCR(RpcExceptionCode());
         }
         RpcEndExcept
      }

      if (Status != CR_SUCCESS) {
          //
          // If the CM_DRP_DRIVER did not exist and we were not to create it, or
          // the attempt to create one was unsuccessful, return the error.
          //
          goto Clean0;
      }

      //
      // the <instance> part of the class instance is the private part
      //

      if (!SplitString(szClassInstance,
                       L'\\',
                       1,
                       szTemp,
                       SIZECHARS(szTemp),
                       pszPrivateKey,
                       ulPrivateKeyLength)) {
          ASSERT(0);
          Status = CR_FAILURE;
          goto Clean0;
      }

      hr = StringCchCopy(szClassInstance,
                         SIZECHARS(szClassInstance),
                         szTemp);
      ASSERT(SUCCEEDED(hr));
      if (FAILED(hr)) {
          Status = CR_FAILURE;
          goto Clean0;
      }

      if (ulFlags & CM_REGISTRY_CONFIG) {
          //
          // config-specific software branch case
          //

         if (ulHardwareProfile == 0) {
             //
             // curent config
             //
             // System\CCC\Hardware Profiles\Current
             //    \System\CCC\Control\Class\<DevNodeClassInstance>
             //
             hr = StringCchPrintfEx(pszBaseKey,
                                    ulBaseKeyLength,
                                    NULL, NULL,
                                    STRSAFE_NULL_ON_FAILURE,
                                    L"%s\\%s\\%s\\%s",
                                    REGSTR_PATH_HWPROFILES,
                                    REGSTR_KEY_CURRENT,
                                    REGSTR_PATH_CLASS_NT,
                                    szClassInstance);

         } else if (ulHardwareProfile == 0xFFFFFFFF) {
             //
             // all configs, use substitute string for profile id
             //
             hr = StringCchPrintfEx(pszBaseKey,
                                    ulBaseKeyLength,
                                    NULL, NULL,
                                    STRSAFE_NULL_ON_FAILURE,
                                    L"%s\\%s\\%s\\%s",
                                    REGSTR_PATH_HWPROFILES,
                                    L"%s",
                                    REGSTR_PATH_CLASS_NT,
                                    szClassInstance);

         } else {
             //
             // specific profile specified
             //
             // System\CCC\Hardware Profiles\<profile>
             //    \System\CCC\Control\Class\<DevNodeClassInstance>
             //
             hr = StringCchPrintfEx(pszBaseKey,
                                    ulBaseKeyLength,
                                    NULL, NULL,
                                    STRSAFE_NULL_ON_FAILURE,
                                    L"%s\\%04u\\%s\\%s",
                                    REGSTR_PATH_HWPROFILES,
                                    ulHardwareProfile,
                                    REGSTR_PATH_CLASS_NT,
                                    szClassInstance);
         }

      } else {
          //
          // not config-specific
          // System\CCC\Control\Class\<DevNodeClassInstance>
          //
          hr = StringCchPrintfEx(pszBaseKey,
                                 ulBaseKeyLength,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE,
                                 L"%s\\%s",
                                 REGSTR_PATH_CLASS_NT,
                                 szClassInstance);
      }

      ASSERT(SUCCEEDED(hr));
      if (FAILED(hr)) {
          Status = CR_FAILURE;
          goto Clean0;
      }

   } else {
      //-------------------------------------------------------------
      // form the key for the hardware branch case
      //-------------------------------------------------------------

      if (ulFlags & CM_REGISTRY_CONFIG) {
         //
         // config-specific hardware branch case
         //

         //
         // for profile specific, the <device>\<instance> part of
         // the device id is the private part
         //

         if (!SplitString(pDeviceID,
                          L'\\',
                          1,
                          szEnumerator,
                          SIZECHARS(szEnumerator),
                          pszPrivateKey,
                          ulPrivateKeyLength)) {
             ASSERT(0);
             Status = CR_FAILURE;
             goto Clean0;
         }

         if (ulHardwareProfile == 0) {
             //
             // curent config
             //
             hr = StringCchPrintfEx(pszBaseKey,
                                    ulBaseKeyLength,
                                    NULL, NULL,
                                    STRSAFE_NULL_ON_FAILURE,
                                    L"%s\\%s\\%s\\%s",
                                    REGSTR_PATH_HWPROFILES,
                                    REGSTR_KEY_CURRENT,
                                    REGSTR_PATH_SYSTEMENUM,
                                    szEnumerator);

         } else if (ulHardwareProfile == 0xFFFFFFFF) {
             //
             // all configs, use replacement symbol for profile id
             //
             hr = StringCchPrintfEx(pszBaseKey,
                                    ulBaseKeyLength,
                                    NULL, NULL,
                                    STRSAFE_NULL_ON_FAILURE,
                                    L"%s\\%s\\%s\\%s",
                                    REGSTR_PATH_HWPROFILES,
                                    L"%s",
                                    REGSTR_PATH_SYSTEMENUM,
                                    szEnumerator);

         } else {
             //
             // specific profile specified
             //
             hr = StringCchPrintfEx(pszBaseKey,
                                    ulBaseKeyLength,
                                    NULL, NULL,
                                    STRSAFE_NULL_ON_FAILURE,
                                    L"%s\\%04u\\%s\\%s",
                                    REGSTR_PATH_HWPROFILES,
                                    ulHardwareProfile,
                                    REGSTR_PATH_SYSTEMENUM,
                                    szEnumerator);
         }

      } else if (ulFlags & CM_REGISTRY_USER) {
          //
          // for hardware user key, the <device>\<instance> part of
          // the device id is the private part
          //

          if (!SplitString(pDeviceID,
                           L'\\',
                           1,
                           szEnumerator,
                           SIZECHARS(szEnumerator),
                           pszPrivateKey,
                           ulPrivateKeyLength)) {
              Status = CR_FAILURE;
              goto Clean0;
          }

          hr = StringCchPrintfEx(pszBaseKey,
                                 ulBaseKeyLength,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE,
                                 L"%s\\%s",
                                 REGSTR_PATH_SYSTEMENUM,
                                 szEnumerator);
      } else {
          //
          // not config-specific
          //
          hr = StringCchPrintfEx(pszBaseKey,
                                 ulBaseKeyLength,
                                 NULL, NULL,
                                 STRSAFE_NULL_ON_FAILURE,
                                 L"%s\\%s",
                                 REGSTR_PATH_SYSTEMENUM,
                                 pDeviceID);

          ASSERT(SUCCEEDED(hr));

          if (SUCCEEDED(hr)) {
              hr = StringCchCopyEx(pszPrivateKey,
                                   ulPrivateKeyLength,
                                   REGSTR_KEY_DEVICEPARAMETERS,
                                   NULL, NULL,
                                   STRSAFE_NULL_ON_FAILURE);
          }
      }

      ASSERT(SUCCEEDED(hr));

      if (FAILED(hr)) {
          Status = CR_FAILURE;
          goto Clean0;
      }
   }

  Clean0:

   return Status;

} // GetDevNodeKeyPath



CONFIGRET
MapRpcExceptionToCR(
      ULONG    ulRpcExceptionCode
      )

/*++

Routine Description:

   This routine takes an rpc exception code (typically received by
   calling RpcExceptionCode) and returns a corresponding CR_ error
   code.

Arguments:

   ulRpcExceptionCode   An RPC_S_ or RPC_X_ exception error code.

Return Value:

    Return value is one of the CR_ error codes.

--*/

{
   CONFIGRET   Status = CR_FAILURE;


   switch(ulRpcExceptionCode) {

      //
      // binding or machine name errors
      //
      case RPC_S_INVALID_STRING_BINDING:      // 1700L
      case RPC_S_WRONG_KIND_OF_BINDING:       // 1701L
      case RPC_S_INVALID_BINDING:             // 1702L
      case RPC_S_PROTSEQ_NOT_SUPPORTED:       // 1703L
      case RPC_S_INVALID_RPC_PROTSEQ:         // 1704L
      case RPC_S_INVALID_STRING_UUID:         // 1705L
      case RPC_S_INVALID_ENDPOINT_FORMAT:     // 1706L
      case RPC_S_INVALID_NET_ADDR:            // 1707L
      case RPC_S_NO_ENDPOINT_FOUND:           // 1708L
      case RPC_S_NO_MORE_BINDINGS:            // 1806L
      case RPC_S_CANT_CREATE_ENDPOINT:        // 1720L

         Status = CR_INVALID_MACHINENAME;
         break;

      //
      // general rpc communication failure
      //
      case RPC_S_INVALID_NETWORK_OPTIONS:     // 1724L
      case RPC_S_CALL_FAILED:                 // 1726L
      case RPC_S_CALL_FAILED_DNE:             // 1727L
      case RPC_S_PROTOCOL_ERROR:              // 1728L
      case RPC_S_UNSUPPORTED_TRANS_SYN:       // 1730L

         Status = CR_REMOTE_COMM_FAILURE;
         break;

      //
      // couldn't make connection to that machine
      //
      case RPC_S_SERVER_UNAVAILABLE:          // 1722L
      case RPC_S_SERVER_TOO_BUSY:             // 1723L

         Status = CR_MACHINE_UNAVAILABLE;
         break;


      //
      // server doesn't exist or not right version
      //
      case RPC_S_INVALID_VERS_OPTION:         // 1756L
      case RPC_S_INTERFACE_NOT_FOUND:         // 1759L
      case RPC_S_UNKNOWN_IF:                  // 1717L

         Status = CR_NO_CM_SERVICES;
         break;

      //
      // access denied
      //
      case RPC_S_ACCESS_DENIED:

         Status = CR_ACCESS_DENIED;
         break;

      //
      // any other RPC exceptions will just be general failures
      //
      default:
         Status = CR_FAILURE;
         break;
   }

   return Status;

} // MapRpcExceptionToCR



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\lib\umpnplib.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    umpnplib.h

Abstract:

    This module contains the private prototype defintions for routines contained
    in the statically linked library that is shared by both the Configuration
    Manager client DLL and User-Mode Plug and Play manager server DLL.

Author:

    Jim Cavalaris (jamesca) 02/27/2001

Environment:

    User mode only.

Revision History:

    27-February-2001     jamesca

        Creation and initial implementation.

--*/

#ifndef _UMPNPLIB_H_
#define _UMPNPLIB_H_


//-------------------------------------------------------------------
// Common private utility routines (used by client and server)
//-------------------------------------------------------------------

BOOL
IsLegalDeviceId(
    IN  LPCWSTR    pszDeviceInstance
    );

BOOL
SplitString(
    IN  LPCWSTR    SourceString,
    IN  WCHAR      SearchChar,
    IN  ULONG      nOccurrence,
    OUT LPWSTR     String1,
    IN  ULONG      Length1,
    OUT LPWSTR     String2,
    IN  ULONG      Length2
    );

BOOL
SplitDeviceInstanceString(
    IN  LPCWSTR    pszDeviceInstance,
    OUT LPWSTR     pszBase,
    OUT LPWSTR     pszDeviceID,
    OUT LPWSTR     pszInstanceID
    );

BOOL
SplitClassInstanceString(
    IN  LPCWSTR    pszClassInstance,
    OUT LPWSTR     pszClass,
    OUT LPWSTR     pszInstance
    );

CONFIGRET
DeletePrivateKey(
    IN  HKEY       hBranchKey,
    IN  LPCWSTR    pszParentKey,
    IN  LPCWSTR    pszChildKey
    );

BOOL
RegDeleteNode(
    IN  HKEY       hParentKey,
    IN  LPCWSTR    szKey
    );

CONFIGRET
GetDevNodeKeyPath(
    IN  handle_t   hBinding,
    IN  LPCWSTR    pDeviceID,
    IN  ULONG      ulFlags,
    IN  ULONG      ulHardwareProfile,
    OUT LPWSTR     pszBaseKey,
    IN  ULONG      ulBaseKeyLength,
    OUT LPWSTR     pszPrivateKey,
    IN  ULONG      ulPrivateKeyLength,
    IN  BOOL       bCreateAlways
    );

CONFIGRET
MapRpcExceptionToCR(
    ULONG          ulRpcExceptionCode
    );


//-------------------------------------------------------------------
// Generic (private) locking support
//-------------------------------------------------------------------

//
// Locking functions. These functions are used to make various parts of
// the DLL multithread-safe. The basic idea is to have a mutex and an event.
// The mutex is used to synchronize access to the structure being guarded.
// The event is only signalled when the structure being guarded is destroyed.
// To gain access to the guarded structure, a routine waits on both the mutex
// and the event. If the event gets signalled, then the structure was destroyed.
// If the mutex gets signalled, then the thread has access to the structure.
//

#define DESTROYED_EVENT 0
#define ACCESS_MUTEX    1

typedef struct _LOCKINFO {
    //
    // DESTROYED_EVENT, ACCESS_MUTEX
    //
    HANDLE  LockHandles[2];
} LOCKINFO, *PLOCKINFO;

BOOL
InitPrivateResource(
    OUT    PLOCKINFO  Lock
    );

VOID
DestroyPrivateResource(
    IN OUT PLOCKINFO  Lock
    );

BOOL
__inline
LockPrivateResource(
    IN     PLOCKINFO  Lock
    )
{
    DWORD d = WaitForMultipleObjects(2,
                                     Lock->LockHandles,
                                     FALSE,
                                     INFINITE);
    //
    // Success if the mutex object satisfied the wait;
    // Failure if the table destroyed event satisified the wait, or
    // the mutex was abandoned, etc.
    //
    return ((d - WAIT_OBJECT_0) == ACCESS_MUTEX);
}

VOID
__inline
UnlockPrivateResource(
    IN     PLOCKINFO  Lock
    )
{
    ReleaseMutex(Lock->LockHandles[ACCESS_MUTEX]);
}


//-------------------------------------------------------------------
// Defines and typedefs needed for logconf routines
//-------------------------------------------------------------------

#include "pshpack1.h"   // set to 1-byte packing

//
// DEFINES REQUIRED FOR PARTIAL (SUR) IMPLEMENTATION OF LOG_CONF and RES_DES
//
// We only allow one logical config (the BOOT_LOG_CONF) for SUR so no need
// to keep track of multiple log confs, this will all change for Cairo.
//
typedef struct Private_Log_Conf_Handle_s {
   ULONG    LC_Signature;           // CM_PRIVATE_LOGCONF_HANDLE
   DEVINST  LC_DevInst;
   ULONG    LC_LogConfType;
   ULONG    LC_LogConfTag;  //LC_LogConfIndex;
} Private_Log_Conf_Handle, *PPrivate_Log_Conf_Handle;

typedef struct Private_Res_Des_Handle_s {
   ULONG       RD_Signature;        // CM_PRIVATE_RESDES_HANDLE
   DEVINST     RD_DevInst;
   ULONG       RD_LogConfType;
   ULONG       RD_LogConfTag;   //RD_LogConfIndex;
   RESOURCEID  RD_ResourceType;
   ULONG       RD_ResDesTag;    //RD_ResDesIndex;
} Private_Res_Des_Handle, *PPrivate_Res_Des_Handle;

typedef struct Generic_Des_s {
   DWORD    GENERIC_Count;
   DWORD    GENERIC_Type;
} GENERIC_DES, *PGENERIC_DES;

typedef struct Generic_Resource_S {
   GENERIC_DES    GENERIC_Header;
} GENERIC_RESOURCE, *PGENERIC_RESOURCE;

typedef struct  Private_Log_Conf_s {
   ULONG           LC_Flags;       // Type of log conf
   ULONG           LC_Priority;    // Priority of log conf
   CS_RESOURCE     LC_CS;          // First and only res-des, class-specific
} Private_Log_Conf, *PPrivate_Log_Conf;

#include "poppack.h"    // restore to default packing


//-------------------------------------------------------------------
// Defines and typedefs needed for range routines
//-------------------------------------------------------------------

typedef struct Range_Element_s {
   ULONG_PTR    RL_Next;
   ULONG_PTR    RL_Header;
   DWORDLONG    RL_Start;
   DWORDLONG    RL_End;
} Range_Element, *PRange_Element;

typedef struct Range_List_Hdr_s {
   ULONG_PTR RLH_Head;
   ULONG_PTR RLH_Header;
   ULONG    RLH_Signature;
   LOCKINFO RLH_Lock;
} Range_List_Hdr, *PRange_List_Hdr;

#define Range_List_Signature     0x5959574D


#endif // _UMPNPLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\newdev\finish.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       finish.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include <help.h>


typedef
UINT
(*PDEVICEPROBLEMTEXT)(
    HMACHINE hMachine,
    DEVNODE DevNode,
    ULONG ProblemNumber,
    LPTSTR Buffer,
    UINT   BufferSize
    );

BOOL
IsNullDriverInstalled(
    DEVNODE DevNode
    )
/*++

Routine Description:

    This routine determines whether a null driver, or no driver at all, is
    installed for this device instance.  Currently the test is that I know
    a null driver was installed if the "Driver" value entry doesn't exist.

Arguments:

    DevNode

Return Value:

   Returns TRUE if a null driver was installed for this device, otherwise
   returns FALSE.

--*/

{
    TCHAR Buffer[1];
    DWORD dwSize, dwType;

    dwSize = sizeof(Buffer);
    if (CM_Get_DevNode_Registry_Property(DevNode,
                                         CM_DRP_DRIVER,
                                         &dwType,
                                         (LPVOID)Buffer,
                                         &dwSize,
                                         0) == CR_BUFFER_SMALL) {

        return FALSE;

    } else {

        return TRUE;

    }
}

PTCHAR
DeviceProblemText(
   HMACHINE hMachine,
   DEVNODE DevNode,
   ULONG ProblemNumber
   )
{
    UINT LenChars, ReqLenChars;
    HMODULE hDevMgr = NULL;
    PTCHAR Buffer = NULL;
    PDEVICEPROBLEMTEXT pDeviceProblemText = NULL;

    hDevMgr = LoadLibrary(TEXT("devmgr.dll"));
    if (hDevMgr)
    {
        pDeviceProblemText = (PDEVICEPROBLEMTEXT)GetProcAddress(hDevMgr, "DeviceProblemTextW");
    }

    if (pDeviceProblemText)
    {
        LenChars = (pDeviceProblemText)(hMachine,
                                        DevNode,
                                        ProblemNumber,
                                        Buffer,
                                        0
                                        );
        if (!LenChars)
        {
            goto DPTExitCleanup;
        }

        LenChars++;  // one extra for terminating NULL

        Buffer = LocalAlloc(LPTR, LenChars*sizeof(TCHAR));
        if (!Buffer)
        {
            goto DPTExitCleanup;
        }

        ReqLenChars = (pDeviceProblemText)(hMachine,
                                           DevNode,
                                           ProblemNumber,
                                           Buffer,
                                           LenChars
                                           );
        if (!ReqLenChars || ReqLenChars >= LenChars)
        {
            LocalFree(Buffer);
            Buffer = NULL;
        }
    }

DPTExitCleanup:

    if (hDevMgr)
    {
        FreeLibrary(hDevMgr);
    }

    return Buffer;
}

BOOL
DeviceHasResources(
   DEVINST DeviceInst
   )
{
   CONFIGRET ConfigRet;
   ULONG lcType = NUM_LOG_CONF;

   while (lcType--)
   {
       ConfigRet = CM_Get_First_Log_Conf_Ex(NULL, DeviceInst, lcType, NULL);
       if (ConfigRet == CR_SUCCESS)
       {
           return TRUE;
       }
   }

   return FALSE;
}

BOOL
GetClassGuidForInf(
    PTSTR InfFileName,
    LPGUID ClassGuid
    )
{
    TCHAR ClassName[MAX_CLASS_NAME_LEN];
    DWORD NumGuids;

    if(!SetupDiGetINFClass(InfFileName,
                           ClassGuid,
                           ClassName,
                           SIZECHARS(ClassName),
                           NULL))
    {
       return FALSE;
    }

    if (IsEqualGUID(ClassGuid, &GUID_NULL))
    {
        //
        // Then we need to retrieve the GUID associated with the INF's class name.
        // (If this class name isn't installed (i.e., has no corresponding GUID),
        // or if it matches with multiple GUIDs, then we abort.
        //
        if(!SetupDiClassGuidsFromName(ClassName, ClassGuid, 1, &NumGuids) || !NumGuids)
        {
            return FALSE;
        }
    }

    return TRUE;
}

UINT
QueueCallback(
    IN PVOID     Context,
    IN UINT      Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)Context;

    switch (Notification) {
    
    case SPFILENOTIFY_TARGETNEWER:
        //
        // When doing a driver rollback we expect that some of the files will
        // be older then the files currently on the system since most backups
        // will be of older driver packages.  So when a user does a rollback we
        // will hide the older vs. newer file prompt and always copy the older
        // backed up file.
        //
        if (NewDevWiz->Flags & IDI_FLAG_ROLLBACK) {
            return TRUE;
        }
        break;
        
    case SPFILENOTIFY_STARTCOPY:
        if (NewDevWiz->hWnd) {
            SendMessage(NewDevWiz->hWnd,
                        WUM_INSTALLPROGRESS,
                        INSTALLOP_COPY,
                        (WPARAM)((PFILEPATHS)Param1)
                        );
        }
        break;

    case SPFILENOTIFY_STARTRENAME:
        if (NewDevWiz->hWnd) {
            SendMessage(NewDevWiz->hWnd,
                        WUM_INSTALLPROGRESS,
                        INSTALLOP_RENAME,
                        (WPARAM)((PFILEPATHS)Param1)
                        );
        }
        break;

    case SPFILENOTIFY_STARTDELETE:
        if (NewDevWiz->hWnd) {
            SendMessage(NewDevWiz->hWnd,
                        WUM_INSTALLPROGRESS,
                        INSTALLOP_DELETE,
                        (WPARAM)((PFILEPATHS)Param1)
                        );
        }
        break;

    case SPFILENOTIFY_STARTBACKUP:
        if (NewDevWiz->hWnd) {
            SendMessage(NewDevWiz->hWnd,
                        WUM_INSTALLPROGRESS,
                        INSTALLOP_BACKUP,
                        (WPARAM)((PFILEPATHS)Param1)
                        );
        }
        break;
    }

    return SetupDefaultQueueCallback(NewDevWiz->MessageHandlerContext,
                                     Notification,
                                     Param1,
                                     Param2
                                     );
}

LONG
ClassInstallerInstalls(
    HWND hwndParent,
    PNEWDEVWIZ NewDevWiz,
    BOOL BackupOldDrivers,
    BOOL ReadOnlyInstall,
    BOOL DontCreateQueue
    )
{
    DWORD Err = ERROR_SUCCESS;
    HSPFILEQ FileQueue = INVALID_HANDLE_VALUE;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    DWORD ScanResult = 0;
    int FileQueueNeedsReboot = 0;

    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));

    NewDevWiz->MessageHandlerContext = NULL;

    //
    // If we can't create our own queue and we are doing a read-only install
    // then fail with ERROR_ACCESS_DENIED.
    //
    if (DontCreateQueue && ReadOnlyInstall) {
        Err = ERROR_ACCESS_DENIED;
        goto clean0;
    }

    //
    // verify with class installer, and class-specific coinstallers
    // that the driver is not blacklisted. For DIF_ALLOW_INSTALL we
    // accept ERROR_SUCCESS or ERROR_DI_DO_DEFAULT as good return codes.
    //
    if (!SetupDiCallClassInstaller(DIF_ALLOW_INSTALL,
                                   NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData
                                   ) &&
        (GetLastError() != ERROR_DI_DO_DEFAULT)) {

        Err = GetLastError();
        goto clean0;
    }

    //
    // Create our own queue.
    //
    if (!DontCreateQueue) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (!SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData,
                                           &DeviceInstallParams
                                           )) {

            Err = GetLastError();
            goto clean0;
        }

        FileQueue = SetupOpenFileQueue();

        if (FileQueue == INVALID_HANDLE_VALUE) {
           Err = ERROR_NOT_ENOUGH_MEMORY;
           goto clean0;
        }

        DeviceInstallParams.Flags |= DI_NOVCP;
        DeviceInstallParams.FileQueue = FileQueue;

        //
        // Only set the DI_FLAGSEX_PREINSTALLBACKUP flag if we are doing a
        // backup...not in the read only install case.
        //
        if (BackupOldDrivers) {
            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_PREINSTALLBACKUP;
        }

        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );

        //
        // If the IDI_FLAG_SETRESTOREPOINT flag is set then we want to set the
        // SPQ_FLAG_ABORT_IF_UNSIGNED value on the file queue. With this flag
        // setup setupapi will bail out of the copy if it encounters an unsigned
        // file. At that point we will set a system restore point and then 
        // do the copy. This way the user can back out of an unsigned driver
        // install using system restore.
        //
        // Note that system restore is currently not supported on 64-bit so
        // don't bother setting the SPQ_FLAG_ABORT_IF_UNSIGNED flag.
        //
#ifndef _WIN64
        if (NewDevWiz->Flags & IDI_FLAG_SETRESTOREPOINT) {
            SetupSetFileQueueFlags(FileQueue,
                                   SPQ_FLAG_ABORT_IF_UNSIGNED,
                                   SPQ_FLAG_ABORT_IF_UNSIGNED
                                   );
        }
#endif
    }

    //
    // Install the files first in one shot.
    // This allows new coinstallers to run during the install.
    //
    if (!SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES,
                                   NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    if (FileQueue != INVALID_HANDLE_VALUE) {
        //
        // If we created our own FileQueue then we need to
        // scan and possibly commit the queue
        //
        // If we are doing a read only install then we just queued up the files so
        // that we could do a presence check on them. We will throw away the queue
        // so that the files are not copied.
        //
        // Any other install, prune copies as needed
        //
        if (!SetupScanFileQueue(FileQueue,
                                ReadOnlyInstall
                                     ? SPQ_SCAN_FILE_PRESENCE
                                     : (SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE),
                                hwndParent,
                                NULL,
                                NULL,
                                &ScanResult
                                )) {

            //
            // If the API failed then set the ScanResult to 0 (failure).
            //
            ScanResult = 0;
        }

        if (ReadOnlyInstall && (ScanResult != 1)) {
            //
            // ReadOnlyInstall cannot perform copies, deletes or renames
            // bail now!
            //
            Err = ERROR_ACCESS_DENIED;
            goto clean0;
        }

        //
        // We will always commit the file queue, even if we pruned all of the 
        // files.  The reason for this is that backing up of drivers, for 
        // driver rollback, won't work unless the file queue is committed.
        //
        if ((NewDevWiz->Flags & IDI_FLAG_ROLLBACK) &&
            (!ReadOnlyInstall)) {
            //
            // Prepare file queue for rollback
            // we need the directory of the INF
            // that's being used for the install
            //
            SP_DRVINFO_DATA        DriverInfoData;
            SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
            DWORD                  RetVal;
            LPTSTR                 pFileName;
            TCHAR                  BackupPath[MAX_PATH];

            DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
            if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         &DriverInfoData)) {

                DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
                if (SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                               &NewDevWiz->DeviceInfoData,
                                               &DriverInfoData,
                                               &DriverInfoDetailData,
                                               sizeof(SP_DRVINFO_DETAIL_DATA),
                                               NULL) ||
                            (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
                    //
                    // we now have path of INF we're using for the restore
                    //
                    RetVal = GetFullPathName(DriverInfoDetailData.InfFileName,
                                             SIZECHARS(BackupPath),
                                             BackupPath,
                                             &pFileName);
                    if(RetVal && pFileName && (pFileName != BackupPath)) {
                        if ((*CharPrev(BackupPath,pFileName)==TEXT('\\')) ||
                            (*CharPrev(BackupPath,pFileName)==TEXT('/'))) {
                            pFileName--;
                        }
                        *pFileName = TEXT('\0');
                        //
                        // Prepare queue for rollback
                        // if this fails, carry on, it'll work in a degraded way
                        //
                        SetupPrepareQueueForRestore(FileQueue,BackupPath,0);
                    }
                }
            }
        }

        NewDevWiz->MessageHandlerContext = SetupInitDefaultQueueCallbackEx(
                                    hwndParent,
                                    (DeviceInstallParams.Flags & DI_QUIETINSTALL)
                                        ? INVALID_HANDLE_VALUE : NewDevWiz->hWnd,
                                    WUM_INSTALLPROGRESS,
                                    0,
                                    NULL
                                    );

        if (NewDevWiz->MessageHandlerContext) {
            //
            // Commit the file queue.
            //
            if (!SetupCommitFileQueue(hwndParent,
                                      FileQueue,
                                      QueueCallback,
                                      (PVOID)NewDevWiz
                                      )) {

                Err = GetLastError();

                if (Err == ERROR_SET_SYSTEM_RESTORE_POINT) {
                    UINT RestorePointResourceId;

                    //
                    // If we get back ERROR_SET_SYSTEM_RESTORE_POINT then
                    // we better have the IDI_FLAG_SETRESTOREPOINT flag
                    // set.
                    //
                    ASSERT(NewDevWiz->Flags & IDI_FLAG_SETRESTOREPOINT);

                    if (!(DeviceInstallParams.Flags & DI_QUIETINSTALL) &&
                        NewDevWiz->hWnd) {
                        PostMessage(NewDevWiz->hWnd,
                                    WUM_INSTALLPROGRESS,
                                    INSTALLOP_SETTEXT,
                                    (LPARAM)IDS_SYSTEMRESTORE_TEXT
                                    );
                    }

                    SetupTermDefaultQueueCallback(NewDevWiz->MessageHandlerContext);

                    NewDevWiz->MessageHandlerContext = SetupInitDefaultQueueCallbackEx(
                                                hwndParent,
                                                (DeviceInstallParams.Flags & DI_QUIETINSTALL)
                                                    ? INVALID_HANDLE_VALUE : NewDevWiz->hWnd,
                                                WUM_INSTALLPROGRESS,
                                                0,
                                                NULL
                                                );

                    if (NewDevWiz->MessageHandlerContext) {
                        //
                        // Set the system restore point.
                        //
                        if (NewDevWiz->Flags & IDI_FLAG_ROLLBACK) {
                            RestorePointResourceId = IDS_ROLLBACK_SETRESTOREPOINT;                            
                        } else if (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) {
                            RestorePointResourceId = IDS_NEW_SETRESTOREPOINT;                            
                        } else {
                            RestorePointResourceId = IDS_UPDATE_SETRESTOREPOINT;                            
                        }

                        pSetSystemRestorePoint(TRUE, FALSE, RestorePointResourceId);

                        NewDevWiz->SetRestorePoint = TRUE;

                        if (!(DeviceInstallParams.Flags & DI_QUIETINSTALL) &&
                            NewDevWiz->hWnd) {
                            PostMessage(NewDevWiz->hWnd,
                                        WUM_INSTALLPROGRESS,
                                        INSTALLOP_SETTEXT,
                                        (LPARAM)NULL
                                        );
                        }

                        //
                        // Clear the SPQ_FLAG_ABORT_IF_UNSIGNED flag so the file
                        // queue will be commited the next time.
                        //
                        SetupSetFileQueueFlags(FileQueue,
                                               SPQ_FLAG_ABORT_IF_UNSIGNED,
                                               0
                                               );

                        //
                        // Now that we have set the restore point and cleared the
                        // SPQ_FLAG_ABORT_IF_UNSIGNED flag from the file queue we
                        // can commit the queue again.
                        //
                        if (!SetupCommitFileQueue(hwndParent,
                                                  FileQueue,
                                                  QueueCallback,
                                                  (PVOID)NewDevWiz
                                                  )) {
                            Err = GetLastError();

                            //
                            // If the error we get is ERROR_CANCELLED then
                            // the user has canceld out of the file copy.
                            // This means that no changes have been made
                            // to the system, so we will tell system
                            // restore to cancel its restore point.
                            //
                            // Also clear the SetRestorePoint BOOL since
                            // we didn't actually set a restore point.
                            //
                            if (Err == ERROR_CANCELLED) {
                                pSetSystemRestorePoint(FALSE, TRUE, 0);
                                NewDevWiz->SetRestorePoint = FALSE;
                            }

                            goto clean0;
                        } else {
                            //
                            // We were successful in commiting the file queue, so check
                            // to see whether a reboot is required as a result of committing
                            // the queue (i.e. because files were in use, or the INF requested
                            // a reboot).
                            //
                            FileQueueNeedsReboot = SetupPromptReboot(FileQueue, NULL, TRUE);
                        }
                    }
                } else {
                    goto clean0;
                }
           } else {
               //
               // We were successful in commiting the file queue, so check
               // to see whether a reboot is required as a result of committing
               // the queue (i.e. because files were in use, or the INF requested
               // a reboot).
               //
               FileQueueNeedsReboot = SetupPromptReboot(FileQueue, NULL, TRUE);
           }
        }

        if (BackupOldDrivers) {
            //
            // If the backup succeeded and we have a UpdateDriverInfo structure
            // then we need to call SetupGetBackupInformation so we can get the
            // registry key that the backup was saved into.
            //
            SP_BACKUP_QUEUE_PARAMS BackupQueueParams;

            BackupQueueParams.cbSize = sizeof(SP_BACKUP_QUEUE_PARAMS);
            if (NewDevWiz->UpdateDriverInfo &&
                SetupGetBackupInformation(FileQueue, &BackupQueueParams)) {

                if (FAILED(StringCchCopy(NewDevWiz->UpdateDriverInfo->BackupRegistryKey,
                                         SIZECHARS(NewDevWiz->UpdateDriverInfo->BackupRegistryKey),
                                         REGSTR_PATH_REINSTALL)) ||
                    FAILED(StringCchCat(NewDevWiz->UpdateDriverInfo->BackupRegistryKey,
                                        SIZECHARS(NewDevWiz->UpdateDriverInfo->BackupRegistryKey), 
                                        TEXT("\\"))) ||
                    FAILED(StringCchCat(NewDevWiz->UpdateDriverInfo->BackupRegistryKey,
                                        SIZECHARS(NewDevWiz->UpdateDriverInfo->BackupRegistryKey),
                                        BackupQueueParams.ReinstallInstance))) {
                    //
                    // If the entire backup registry key string could NOT fit into our buffer
                    // then set the buffer to 0 since putting a partial key in the registry
                    // is useless.
                    //
                    NewDevWiz->UpdateDriverInfo->BackupRegistryKey[0] = TEXT('\0');
                }
            }
        }
    }

    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      )) {
        DWORD FileQueueFlags;
        
        //
        // If we didn't copy any files when commiting the file queue then the
        // SPQ_FLAG_FILES_MODIFIED flag will NOT be set.  In this case set
        // the DI_FLAGSEX_RESTART_DEVICE_ONLY flag so that we only stop/start
        // this single device.  By default setupapi will stop/start this device
        // as well as any other device that was using the same driver/filter 
        // that this device is using.
        //
        if ((FileQueue != INVALID_HANDLE_VALUE) &&
            SetupGetFileQueueFlags(FileQueue, &FileQueueFlags) &&
            !(FileQueueFlags & SPQ_FLAG_FILES_MODIFIED)) {
            
            DeviceInstallParams.FlagsEx |= DI_FLAGSEX_RESTART_DEVICE_ONLY;
        }

        //
        // Set the DI_NOFILECOPY flag since we already copied the files during
        // the DIF_INSTALLDEVICEFILES, so we don't need to copy them again during
        // the DIF_INSTALLDEVICE.
        //
        DeviceInstallParams.Flags |= DI_NOFILECOPY;
        
        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }

    //
    // Register any device-specific co-installers for this device,
    //
    if (!SetupDiCallClassInstaller(DIF_REGISTER_COINSTALLERS,
                                   NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    //
    // install any INF/class installer-specified interfaces.
    // and then finally the real "InstallDevice"!
    //
    if (!SetupDiCallClassInstaller(DIF_INSTALLINTERFACES,
                                  NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData
                                  )
        ||
        !SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                   NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData
                                   )) {

        Err = GetLastError();
        goto clean0;
    }

    Err = ERROR_SUCCESS;

clean0:

    if (NewDevWiz->MessageHandlerContext) {
        SetupTermDefaultQueueCallback(NewDevWiz->MessageHandlerContext);
        NewDevWiz->MessageHandlerContext = NULL;
    }

    //
    // If the file queue said that a reboot was needed then set the 
    // DI_NEEDRESTART flag.
    //
    if (FileQueueNeedsReboot) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData,
                                           &DeviceInstallParams
                                           )) {

            DeviceInstallParams.Flags |= DI_NEEDRESTART;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }
    }

    if (FileQueue != INVALID_HANDLE_VALUE) {
        //
        // If we have a valid file queue handle and there was an error during
        // the device install then we want to delete any new INFs that were
        // copied into the INF directory.  We do this under the assumption that
        // since there was an error during the install these INFs must be bad.
        //
        if (Err != ERROR_SUCCESS) {
            SetupUninstallNewlyCopiedInfs(FileQueue,
                                          0,
                                          NULL
                                          );
        }

        //
        // Clear out our file queue from the device install params. We need
        // to do this or else SetupCloseFileQueue will fail because it will
        // still have a ref count.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData,
                                           &DeviceInstallParams
                                           )) {

            DeviceInstallParams.Flags &= ~DI_NOVCP;
            DeviceInstallParams.FileQueue = INVALID_HANDLE_VALUE;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }

        SetupCloseFileQueue(FileQueue);
    }

    return Err;
}

//
// invokable only from finish page!
//
DWORD
InstallDev(
    HWND       hwndParent,
    PNEWDEVWIZ NewDevWiz
    )
{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    TCHAR ClassGuidString[MAX_GUID_STRING_LEN];
    GUID ClassGuidInf;
    LPGUID ClassGuid;
    int   ClassGuidNum;
    DWORD Error = ERROR_SUCCESS;
    BOOL IgnoreRebootFlags = FALSE;
    TCHAR Buffer[MAX_PATH];
    ULONG DevNodeStatus = 0, Problem = 0;
    BOOL Backup = FALSE;
    BOOL DontCreateQueue = FALSE;

    if (!NewDevWiz->ClassGuidSelected)
    {
        NewDevWiz->ClassGuidSelected = (LPGUID)&GUID_NULL;
    }


    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 ))
    {
        //
        // Get details on this driver node, so that we can examine the INF that this
        // node came from.
        //
        DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
        if(!SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       &DriverInfoData,
                                       &DriverInfoDetailData,
                                       sizeof(DriverInfoDetailData),
                                       NULL
                                       ))
        {
            Error = GetLastError();
            if (Error != ERROR_INSUFFICIENT_BUFFER)
            {
                goto clean0;
            }
        }

        //
        // Verif that the class is installed, if its not then
        // attempt to install it.
        //
        NdwBuildClassInfoList(NewDevWiz, 0);

        //
        // fetch classguid from inf, (It may be different than what we already
        // have in class guid selected).
        //
        if (!GetClassGuidForInf(DriverInfoDetailData.InfFileName, &ClassGuidInf))
        {
            ClassGuidInf = *(NewDevWiz->ClassGuidSelected);
        }

        if (IsEqualGUID(&ClassGuidInf, &GUID_NULL))
        {
            ClassGuidInf = GUID_DEVCLASS_UNKNOWN;
        }

        //
        // if the ClassGuidInf wasn't found then this class hasn't been installed yet.
        // -install the class installer now.
        //
        ClassGuid = NewDevWiz->ClassGuidList;
        ClassGuidNum = NewDevWiz->ClassGuidNum;
        while (ClassGuidNum--)
        {
            if (IsEqualGUID(ClassGuid, &ClassGuidInf))
            {
                break;
            }

            ClassGuid++;
        }

        if (ClassGuidNum < 0 &&
            !SetupDiInstallClass(hwndParent,
                                 DriverInfoDetailData.InfFileName,
                                 NewDevWiz->SilentMode ? DI_QUIETINSTALL : 0,
                                 NULL
                                 ))
        {
            Error = GetLastError();
            goto clean0;
        }
    }

    //
    // No selected driver, and no associated class--use "Unknown" class.
    //
    else
    {
        //
        // If the devnode is currently running 'raw', then remember this
        // fact so that we don't require a reboot later (NULL driver installation
        // isn't going to change anything).
        //
        if (CM_Get_DevNode_Status(&DevNodeStatus,
                                  &Problem,
                                  NewDevWiz->DeviceInfoData.DevInst,
                                  0) == CR_SUCCESS)
        {
            if (!SetupDiGetDeviceRegistryProperty(NewDevWiz->hDeviceInfo,
                                                  &NewDevWiz->DeviceInfoData,
                                                  SPDRP_SERVICE,
                                                  NULL,     // regdatatype
                                                  (PVOID)Buffer,
                                                  sizeof(Buffer),
                                                  NULL
                                                  ))
            {
                *Buffer = TEXT('\0');
            }

            if((DevNodeStatus & DN_STARTED) && (*Buffer == TEXT('\0')))
            {
                IgnoreRebootFlags = TRUE;
            }
        }

        if (IsEqualGUID(NewDevWiz->ClassGuidSelected, &GUID_NULL))
        {
            pSetupStringFromGuid(&GUID_DEVCLASS_UNKNOWN,
                                 ClassGuidString,
                                 SIZECHARS(ClassGuidString)
                                 );


            SetupDiSetDeviceRegistryProperty(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             SPDRP_CLASSGUID,
                                             (PBYTE)ClassGuidString,
                                             sizeof(ClassGuidString)
                                             );
        }

        ClassGuidInf = *(NewDevWiz->ClassGuidSelected);
    }

    //
    // We will backup the current drivers in all cases except if any of the following are true:
    //
    //  1) The device is a printer
    //  2) The selected driver is the currently installed driver
    //  3) The DontBackupCurrentDrivers NEWDEVWIZ BOOL is TRUE
    //  4) The device has a problem
    //
    if (IsEqualGUID(&ClassGuidInf, &GUID_DEVCLASS_PRINTER) ||
        IsInstalledDriver(NewDevWiz, NULL) ||
        (NewDevWiz->Flags & IDI_FLAG_NOBACKUP) ||
        ((CM_Get_DevNode_Status(&DevNodeStatus, &Problem, NewDevWiz->DeviceInfoData.DevInst, 0) == CR_SUCCESS) &&
         ((DevNodeStatus & DN_HAS_PROBLEM) ||
          (DevNodeStatus & DN_PRIVATE_PROBLEM)))) {

        Backup = FALSE;

    } else {

        Backup = TRUE;
    }

    //
    // We will always create our own queue during device install, except in the
    // following specific cases.
    //
    // 1) The device is a printer
    //
    // Note that if we can't create our own queue then we cannot do any of the 
    // operations that need a queue, like backup, rollback, read-only install,
    // or setting a restore point.
    //
    DontCreateQueue = IsEqualGUID(&ClassGuidInf, & GUID_DEVCLASS_PRINTER);

    Error = ClassInstallerInstalls(hwndParent,
                                   NewDevWiz,
                                   Backup,
                                   (NewDevWiz->Flags & IDI_FLAG_READONLY_INSTALL),
                                   DontCreateQueue
                                   );

    //
    // If this is a WU/CDM install and it was successful then set
    // the DriverWasUpgraded to TRUE
    //
    if (NewDevWiz->UpdateDriverInfo && (Error == ERROR_SUCCESS)) {

        NewDevWiz->UpdateDriverInfo->DriverWasUpgraded = TRUE;
    }

    //
    // If this is a new device (currently no drivers are installed) and we encounter
    // an error that is not ERROR_CANCELLED then we will install the NULL driver for
    // this device and set the FAILED INSTALL flag.
    //
    if ((Error != ERROR_SUCCESS) &&
        (Error != ERROR_CANCELLED))
    {
        if (IsNullDriverInstalled(NewDevWiz->DeviceInfoData.DevInst)) {

            if (SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         NULL
                                         ))
            {
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

                if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                                  &NewDevWiz->DeviceInfoData,
                                                  &DeviceInstallParams
                                                  ))
                {
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_SETFAILEDINSTALL;
                    SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                                  &NewDevWiz->DeviceInfoData,
                                                  &DeviceInstallParams
                                                  );
                }

                SetupDiInstallDevice(NewDevWiz->hDeviceInfo, &NewDevWiz->DeviceInfoData);
            }
        }

        goto clean0;
    }

    //
    // See if the device needs to the system to be restarted before it will work.
    //
    if(!IgnoreRebootFlags) {
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          ) &&
            (DeviceInstallParams.Flags & (DI_NEEDRESTART | DI_NEEDREBOOT))) {
            //
            // If either the DI_NEEDRESTART or the DI_NEEDREBOOT DeviceInstallParams
            // flag is set, then a restart is needed.
            //
            NewDevWiz->Reboot |= DI_NEEDREBOOT;
        
        } else if ((CM_Get_DevNode_Status(&DevNodeStatus,
                                          &Problem,
                                          NewDevWiz->DeviceInfoData.DevInst,
                                          0) == CR_SUCCESS) &&
                   (DevNodeStatus & DN_NEED_RESTART) ||
                   (Problem == CM_PROB_NEED_RESTART)) {
            //
            // If the DN_NEED_RESTART devnode status flag is set, then a restart
            // is needed.
            //
            NewDevWiz->Reboot |= DI_NEEDREBOOT;
        }
    }


clean0:

    return Error;
}

DWORD
InstallNullDriver(
    PNEWDEVWIZ NewDevWiz,
    BOOL FailedInstall
    )
{
    SP_DEVINSTALL_PARAMS    DevInstallParams;
    DWORD  Err = ERROR_SUCCESS;

    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    //
    // Set the DI_FLAGSEX_SETFAILEDINSTALL flag if this is a failed
    // install.
    //
    if (FailedInstall)
    {
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DevInstallParams
                                          ))
        {
            DevInstallParams.FlagsEx |= DI_FLAGSEX_SETFAILEDINSTALL;
            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DevInstallParams
                                          );
        }
    }

    //
    // Set the selected driver to NULL
    //
    if (SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 NULL
                                 ))
    {
        //
        // verify with class installer, and class-specific coinstallers
        // that the driver is not blacklisted. For DIF_ALLOW_INSTALL we
        // accept ERROR_SUCCESS or ERROR_DI_DO_DEFAULT as good return codes.
        //
        if (SetupDiCallClassInstaller(DIF_ALLOW_INSTALL,
                                      NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData
                                      ) ||
            (GetLastError() == ERROR_DI_DO_DEFAULT)) {

            //
            // If the class/co-installers gave the OK then call DIF_INSTALLDEVICE.
            //
            if (!SetupDiCallClassInstaller(DIF_INSTALLDEVICE,
                                           NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData
                                           )) {
                Err = GetLastError();
            }

        } else {
            Err = GetLastError();
        }
    }

    return Err;

} // InstallNullDriver


BOOL
CALLBACK
AddPropSheetPageProc(
    IN HPROPSHEETPAGE hpage,
    IN LPARAM lParam
   )
{
    *((HPROPSHEETPAGE *)lParam) = hpage;
    return TRUE;
}

void
DisplayResource(
     PNEWDEVWIZ NewDevWiz,
     HWND hWndParent
     )
{
    HINSTANCE hLib;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsPages[1];
    SP_PROPSHEETPAGE_REQUEST PropPageRequest;
    LPFNADDPROPSHEETPAGES ExtensionPropSheetPage = NULL;
    LPTSTR Title;
    SP_DEVINSTALL_PARAMS    DevInstallParams;

    //
    // Now get the resource selection page from setupapi.dll
    //
    hLib = GetModuleHandle(TEXT("setupapi.dll"));
    if (hLib)
    {
        ExtensionPropSheetPage = (LPFNADDPROPSHEETPAGES)GetProcAddress(hLib, "ExtensionPropSheetPageProc");
    }

    if (!ExtensionPropSheetPage)
    {
        return;
    }

    PropPageRequest.cbSize = sizeof(SP_PROPSHEETPAGE_REQUEST);
    PropPageRequest.PageRequested  = SPPSR_SELECT_DEVICE_RESOURCES;
    PropPageRequest.DeviceInfoSet  = NewDevWiz->hDeviceInfo;
    PropPageRequest.DeviceInfoData = &NewDevWiz->DeviceInfoData;

    if (!ExtensionPropSheetPage(&PropPageRequest,
                                AddPropSheetPageProc,
                                (LONG_PTR)hpsPages
                                ))
    {
        // warning ?
        return;
    }

    //
    // create the property sheet
    //
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    psh.hwndParent  = hWndParent;
    psh.hInstance   = hNewDev;
    psh.pszIcon     = NULL;

    switch (NewDevWiz->InstallType) {

        case NDWTYPE_FOUNDNEW:
            Title = (LPTSTR)IDS_FOUNDDEVICE;
            break;

        case NDWTYPE_UPDATE:
            Title = (LPTSTR)IDS_UPDATEDEVICE;
            break;

        default:
            Title = TEXT(""); // unknown
        }

    psh.pszCaption  = Title;

    psh.nPages      = 1;
    psh.phpage      = hpsPages;
    psh.nStartPage  = 0;
    psh.pfnCallback = NULL;


    //
    // Clear the Propchange pending bit in the DeviceInstall params.
    //
    DevInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DevInstallParams
                                      ))
    {
        DevInstallParams.FlagsEx &= ~DI_FLAGSEX_PROPCHANGE_PENDING;
        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DevInstallParams
                                      );
    }

    if (PropertySheet(&psh) == -1)
    {
        DestroyPropertySheetPage(hpsPages[0]);
    }

    //
    // If a PropChange occurred invoke the DIF_PROPERTYCHANGE
    //
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DevInstallParams
                                      ))
    {
        if (DevInstallParams.FlagsEx & DI_FLAGSEX_PROPCHANGE_PENDING)
        {
            SP_PROPCHANGE_PARAMS PropChangeParams;

            PropChangeParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
            PropChangeParams.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
            PropChangeParams.Scope = DICS_FLAG_GLOBAL;
            PropChangeParams.HwProfile = 0;

            if (SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             (PSP_CLASSINSTALL_HEADER)&PropChangeParams,
                                             sizeof(PropChangeParams)
                                             ))
            {
                SetupDiCallClassInstaller(DIF_PROPERTYCHANGE,
                                          NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData
                                          );
            }

            //
            // Clear the class install parameters.
            //
            SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         NULL,
                                         0
                                         );
        }
    }

    return;
}

DWORD WINAPI
InstallDevThreadProc(
    LPVOID lpVoid
    )
/*++

Description:

    In the Wizard, we will do the driver installation in a separate thread so that the user
    will see the driver instal wizard page.

--*/
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)lpVoid;

    //
    // Do the device install
    //
    NewDevWiz->LastError = InstallDev(NewDevWiz->hWnd, NewDevWiz);

    //
    // Post a message to the window to let it know that we are finished with the install
    //
    PostMessage(NewDevWiz->hWnd, WUM_INSTALLCOMPLETE, TRUE, GetLastError());

    return GetLastError();
}

INT_PTR CALLBACK
NDW_InstallDevDlgProc(
                     HWND hDlg,
                     UINT wMsg,
                     WPARAM wParam,
                     LPARAM lParam
                     )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    static HANDLE DeviceInstallThread = NULL;
    HICON hicon;
    TCHAR Text1[MAX_PATH], Text2[MAX_PATH], Target[MAX_PATH], Format[MAX_PATH];
    PTSTR p;

    switch (wMsg) {

    case WM_INITDIALOG: {

            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

            break;
        }

    case WM_DESTROY:
        hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_GETICON, 0, 0);
        if (hicon) {
            DestroyIcon(hicon);
        }
        break;

    case WUM_INSTALLCOMPLETE:
        //
        // This message is posted to the window when the device installation is complete.
        //
        WaitForSingleObject(DeviceInstallThread, INFINITE);
        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_INSTALL));
        NewDevWiz->CurrCursor = NULL;
        PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);
        break;

    case WUM_INSTALLPROGRESS:
        Text1[0] = Text2[0] = TEXT('\0');

        //
        // This is the message that is sent from setupapi so we can display our
        // own copy progress. 
        //
        // If wParam is 0 then the lParam is the number of files that will be
        // copied.
        // If wParam is 1 then that is a tick for a single file being copied,
        // so the progress bar should be advanced.
        //
        switch (wParam) {
        case 0:
            ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT1), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT2), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_STATUS_TEXT), SW_HIDE);
            SetDlgItemText(hDlg, IDC_FILECOPY_TEXT1, TEXT(""));
            SetDlgItemText(hDlg, IDC_FILECOPY_TEXT2, TEXT(""));
            SendMessage(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), PBM_SETRANGE,0,MAKELPARAM(0,lParam));
            SendMessage(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), PBM_SETSTEP,1,0);
            SendMessage(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), PBM_SETPOS,0,0);
            break;
        case 1:
            SendMessage(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), PBM_STEPIT,0,0);
            break;

        case INSTALLOP_COPY:
            StringCchCopy(Target, SIZECHARS(Target), ((PFILEPATHS)lParam)->Target);
            if ((p = _tcsrchr(Target,TEXT('\\'))) != NULL) {
                *p++ = 0;
                StringCchCopy(Text1, SIZECHARS(Text1), p);
                if (LoadString(hNewDev, IDS_FILEOP_TO, Format, SIZECHARS(Format))) {
                    StringCchPrintf(Text2, SIZECHARS(Text2), Format, Target);
                }
            } else {
                StringCchCopy(Text1, SIZECHARS(Text1), ((PFILEPATHS)lParam)->Target);
                Text2[0] = TEXT('\0');
            }
            break;

        case INSTALLOP_RENAME:
            StringCchCopy(Text1, SIZECHARS(Text1), ((PFILEPATHS)lParam)->Source);
            if ((p = _tcsrchr(((PFILEPATHS)lParam)->Target, TEXT('\\'))) != NULL) {
                p++;
            } else {
                p = (PTSTR)((PFILEPATHS)lParam)->Target;
            }
            if (LoadString(hNewDev, IDS_FILEOP_TO, Format, SIZECHARS(Format))) {
                StringCchPrintf(Text2, SIZECHARS(Text2), Format, p);
            }
            break;

        case INSTALLOP_DELETE:
            StringCchCopy(Target, SIZECHARS(Target), ((PFILEPATHS)lParam)->Target);
            if ((p = _tcsrchr(Target,TEXT('\\'))) != NULL) {
                *p++ = 0;
                StringCchCopy(Text1, SIZECHARS(Text1), p);
                if (LoadString(hNewDev, IDS_FILEOP_FROM, Format, SIZECHARS(Format))) {
                    StringCchPrintf(Text2, SIZECHARS(Text2), Format, Target);
                }
            } else {
                StringCchCopy(Text1, SIZECHARS(Text1), ((PFILEPATHS)lParam)->Target);
                Text2[0] = TEXT('\0');
            }
            break;

        case INSTALLOP_BACKUP:
            StringCchCopy(Target, SIZECHARS(Target), ((PFILEPATHS)lParam)->Source);
            if ((p = _tcsrchr(Target,TEXT('\\'))) != NULL) {
                *p++ = 0;
                if (((PFILEPATHS)lParam)->Target == NULL) {
                    if (LoadString(hNewDev, IDS_FILEOP_BACKUP, Format, SIZECHARS(Format))) {
                        StringCchPrintf(Text1, SIZECHARS(Text2), Format, p);
                    }
                } else {
                    StringCchCopy(Text1, SIZECHARS(Text1), p);
                }
                StringCchCopy(Text2, SIZECHARS(Text2), Target);
            } else {
                if (LoadString(hNewDev, IDS_FILEOP_BACKUP, Format, SIZECHARS(Format))) {
                    StringCchPrintf(Text1, SIZECHARS(Text2), Format, Target);
                }
                Text2[0] = TEXT('\0');
            }
            break;

        case INSTALLOP_SETTEXT:
            ShowWindow(GetDlgItem(hDlg, IDC_STATUS_TEXT), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT1), SW_HIDE);

            if (lParam) {
                if (LoadString(hNewDev, (UINT)lParam, Text2, SIZECHARS(Text2))) {
                    ShowWindow(GetDlgItem(hDlg, IDC_STATUS_TEXT), SW_SHOW);
                    SetDlgItemText(hDlg, IDC_STATUS_TEXT, Text2);
                }
            } else {
                SetDlgItemText(hDlg, IDC_STATUS_TEXT, TEXT(""));
            }
            Text1[0] = TEXT('\0');
            Text2[0] = TEXT('\0');
            break;
        }

        if ((Text1[0] != TEXT('\0')) && (Text2[0] != TEXT('\0'))) {
            ShowWindow(GetDlgItem(hDlg, IDC_STATUS_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT1), SW_SHOW);
            ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT2), SW_SHOW);
            SetDlgItemText(hDlg, IDC_FILECOPY_TEXT1, Text1);
            SetDlgItemText(hDlg, IDC_FILECOPY_TEXT2, Text2);
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE: {

                NewDevWiz->PrevPage = IDD_NEWDEVWIZ_INSTALLDEV;

                //
                // This is an intermediary status page, no buttons needed.
                // Set the device description
                // Set the class Icon
                //
                PropSheet_SetWizButtons(hwndParentDlg, 0);
                EnableWindow(GetDlgItem(GetParent(hDlg),  IDCANCEL), FALSE);
                ShowWindow(GetDlgItem(hDlg, IDC_PROGRESS_INSTALL), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT1), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_FILECOPY_TEXT2), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_STATUS_TEXT), SW_HIDE);

                SetDriverDescription(hDlg, IDC_NDW_DESCRIPTION, NewDevWiz);

                if (SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL)) {
                    hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                    if (hicon) {
                        DestroyIcon(hicon);
                    }
                }

                NewDevWiz->CurrCursor = NewDevWiz->IdcWait;
                SetCursor(NewDevWiz->CurrCursor);

                //
                // If we are doing a silent install then do the actual install here in the PSN_SETACTIVE.
                // Doing the install here means that this wizard page will never be displayed.  When we
                // are finished calling InstallDev() then we will jump to any FinishInstall pages that
                // the class/co-installers have added, or we will jump to our finish page.
                //
                if (NewDevWiz->SilentMode) {
                    //
                    // do the Install immediately and move to the next page
                    // to prevent any UI from showing.
                    //
                    NewDevWiz->hWnd = NULL;
                    NewDevWiz->LastError =InstallDev(hDlg, NewDevWiz);
                    NewDevWiz->CurrCursor = NULL;


                    //
                    // Add the FinishInstall Page and jump to it if the install was successful
                    //
                    if (NewDevWiz->LastError == ERROR_SUCCESS) {

                        NewDevWiz->WizExtFinishInstall.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_FINISHINSTALL,
                                                                                     WizExtFinishInstallDlgProc,
                                                                                     NewDevWiz
                                                                                    );

                        if (NewDevWiz->WizExtFinishInstall.hPropSheet) {

                            PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtFinishInstall.hPropSheet);
                        }

                        SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_FINISHINSTALL);

                    } else {

                        //
                        // There was an error during the install so just jump to our finish page
                        //
                        SetDlgMsgResult(hDlg, wMsg, -1);
                    }
                }

                //
                // Post ourselves a msg, to do the actual install, this allows this
                // page to show itself while the install is actually occuring.
                //
                else {
                    DWORD ThreadId;
                    NewDevWiz->hWnd = hDlg;

                    ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_INSTALL), SW_SHOW);
                    Animate_Open(GetDlgItem(hDlg, IDC_ANIMATE_INSTALL), MAKEINTRESOURCE(IDA_INSTALLING));
                    Animate_Play(GetDlgItem(hDlg, IDC_ANIMATE_INSTALL), 0, -1, -1);

                    //
                    // Start up a separate thread to do the device installation on.
                    // When the driver installation is complete the InstallDevThreadProc
                    // will post us a WUM_INSTALLCOMPLETE message.
                    //
                    DeviceInstallThread = CreateThread(NULL,
                                                       0,
                                                       (LPTHREAD_START_ROUTINE)InstallDevThreadProc,
                                                       (LPVOID)NewDevWiz,
                                                       0,
                                                       &ThreadId
                                                      );

                    //
                    // If the CreateThread fails then we will just call InstallDev() ourselves.
                    //
                    if (!DeviceInstallThread) {

                        NewDevWiz->hWnd = NULL;

                        //
                        // Do the device install
                        //
                        NewDevWiz->LastError = InstallDev(NewDevWiz->hWnd, NewDevWiz);

                        //
                        // Post a message to the window to let it know that we are finished with the install
                        //
                        PostMessage(hDlg, WUM_INSTALLCOMPLETE, TRUE, GetLastError());
                    }
                }

                break;
            }

        case PSN_WIZNEXT:

            Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_INSTALL));

            //
            // Add the FinishInstall Page and jump to it if the installation succeded.
            //
            if (NewDevWiz->LastError == ERROR_SUCCESS) {

                NewDevWiz->WizExtFinishInstall.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_FINISHINSTALL,
                                                                             WizExtFinishInstallDlgProc,
                                                                             NewDevWiz
                                                                            );

                if (NewDevWiz->WizExtFinishInstall.hPropSheet) {
                    PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtFinishInstall.hPropSheet);
                }

                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_FINISHINSTALL);

            } else {

                //
                // There was an error during the install so just jump to our finish page
                //
                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_FINISH);
            }
            break;
        }
        break;


    case WM_SETCURSOR:
        if (NewDevWiz->CurrCursor) {
            SetCursor(NewDevWiz->CurrCursor);
            break;
        }

        // fall thru to return(FALSE);

    default:
        return(FALSE);
    }

    return(TRUE);
}

void
ShowInstallSummary(
    HWND hDlg,
    PNEWDEVWIZ NewDevWiz
    )
{
    LONG Error;
    ULONG Problem, DevNodeStatus;
    BOOL HasResources;
    HWND hwndParentDlg = GetParent(hDlg);
    PTCHAR ErrorMsg, ProblemText;
    TCHAR TextBuffer[MAX_PATH*4];


    Problem = 0;
    *TextBuffer = TEXT('\0');

    Error = NewDevWiz->LastError;

    //
    // On Windows Update installs we don't want to show any UI at all, even
    // if there was an error during the installation.
    // We can tell a WU install from a CDM install because only a WU install
    // has a UpdateDriverInfo structure and is SilentMode.
    // We also never want to show the finish page if this is a NonInteractive
    // install or if we are in GUI setup.
    //
    if ((NewDevWiz->SilentMode &&
        NewDevWiz->UpdateDriverInfo) ||
        ((pSetupGetGlobalFlags() & PSPGF_NONINTERACTIVE) ||
        GuiSetupInProgress))
    {
        HideWindowByMove(hwndParentDlg);
        PropSheet_PressButton(hwndParentDlg, PSBTN_FINISH);
        return;
    }

    if (NewDevWiz->hfontTextBigBold) {
        SetWindowFont(GetDlgItem(hDlg, IDC_FINISH_MSG1), NewDevWiz->hfontTextBigBold, TRUE);
    }

    if (NDWTYPE_UPDATE == NewDevWiz->InstallType) {
        SetDlgText(hDlg, IDC_FINISH_MSG1, IDS_FINISH_MSG1_UPGRADE, IDS_FINISH_MSG1_UPGRADE);

    } else {
        SetDlgText(hDlg, IDC_FINISH_MSG1, IDS_FINISH_MSG1_NEW, IDS_FINISH_MSG1_NEW);
    }

    //
    // Installation failed
    //
    if (Error != ERROR_SUCCESS) {
        NewDevWiz->Installed = FALSE;

        SetDlgText(hDlg, IDC_FINISH_MSG1, IDS_FINISH_MSG1_INSTALL_PROBLEM, IDS_FINISH_MSG1_INSTALL_PROBLEM);
        SetDlgText(hDlg, IDC_FINISH_MSG2, IDS_FINISH_PROB_MSG2, IDS_FINISH_PROB_MSG2);

        //
        // Display failure message for installation
        //
        // We will special case the following error codes so we can give a more
        // friendly description of the problem to the user:
        //
        // TRUST_E_SUBJECT_FORM_UNKNOWN
        // ERROR_NO_ASSOCIATED_SERVICE
        // TYPE_E_ELEMENTNOTFOUND
        // ERROR_NOT_FOUND
        //
        if ((Error == TRUST_E_SUBJECT_FORM_UNKNOWN) ||
            (Error == CERT_E_EXPIRED) ||
            (Error == TYPE_E_ELEMENTNOTFOUND) ||
            (Error == ERROR_NOT_FOUND)) {

            LoadText(TextBuffer,
                     SIZECHARS(TextBuffer),
                     IDS_FINISH_PROB_TRUST_E_SUBJECT_FORM_UNKNOWN,
                     IDS_FINISH_PROB_TRUST_E_SUBJECT_FORM_UNKNOWN);

        } else if (Error == ERROR_NO_ASSOCIATED_SERVICE) {

            LoadText(TextBuffer,
                     SIZECHARS(TextBuffer),
                     IDS_FINISH_PROB_ERROR_NO_ASSOCIATED_SERVICE,
                     IDS_FINISH_PROB_ERROR_NO_ASSOCIATED_SERVICE);

        } else {

            LoadText(TextBuffer, SIZECHARS(TextBuffer), IDS_NDW_ERRORFIN1_PNP, IDS_NDW_ERRORFIN1_PNP);

            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                              NULL,
                              HRESULT_FROM_SETUPAPI(Error),
                              0,
                              (LPTSTR)&ErrorMsg,
                              0,
                              NULL
                              ))
            {
                StringCchCat(TextBuffer, SIZECHARS(TextBuffer), TEXT("\n\n"));
                StringCchCat(TextBuffer, SIZECHARS(TextBuffer), ErrorMsg);
                LocalFree(ErrorMsg);
            }
        }

        SetDlgItemText(hDlg, IDC_FINISH_MSG3, TextBuffer);
    }

    //
    // No errors installing the drivers for this device
    //
    else {
        //
        // Check to see if the device itself has any problems
        //
        Error = CM_Get_DevNode_Status(&DevNodeStatus,
                                      &Problem,
                                      NewDevWiz->DeviceInfoData.DevInst,
                                      0
                                      );
        if(Error != CR_SUCCESS) {
            //
            // For some reason, we couldn't retrieve the devnode's status.
            // Default status and problem values to zero.
            //
            DevNodeStatus = Problem = 0;
        }

        //
        // make sure the reboot flags\Problem are set correctly
        //
        if (NewDevWiz->Reboot || Problem == CM_PROB_NEED_RESTART) {
            if (Problem != CM_PROB_PARTIAL_LOG_CONF) {
                Problem = CM_PROB_NEED_RESTART;
            }

            NewDevWiz->Reboot |= DI_NEEDREBOOT;
        }


        NewDevWiz->Installed = TRUE;
        HasResources = DeviceHasResources(NewDevWiz->DeviceInfoData.DevInst);

        //
        // The device has a problem
        //
        if ((Error != CR_SUCCESS) || Problem) {
            //
            // If we are going to launch the troubleshooter then change the finish text.
            //
            // We currently launch the troubleshooter if the device has some type of problem,
            // unless the problem is CM_PROB_NEED_RESTART.
            //
            if (Problem && (Problem != CM_PROB_NEED_RESTART)) {

                SetDlgText(hDlg, IDC_FINISH_MSG1, IDS_FINISH_MSG1_DEVICE_PROBLEM, IDS_FINISH_MSG1_DEVICE_PROBLEM);
                SetDlgText(hDlg, IDC_FINISH_MSG2, IDS_FINISH_PROB_MSG2, IDS_FINISH_PROB_MSG2);

                NewDevWiz->LaunchTroubleShooter = TRUE;
                SetDlgText(hDlg, IDC_FINISH_MSG4, IDS_FINISH_PROB_MSG4, IDS_FINISH_PROB_MSG4);
            }

            //
            // Show the resource button if the device has resources and it
            // has the problem CM_PROB_PARTIAL_LOG_CONF
            //
            if (HasResources && (Problem == CM_PROB_PARTIAL_LOG_CONF)) {
                ShowWindow(GetDlgItem(hDlg, IDC_NDW_DISPLAYRESOURCE), SW_SHOW);
            }

            if (Problem == CM_PROB_NEED_RESTART) {
                LoadText(TextBuffer, SIZECHARS(TextBuffer), IDS_NEEDREBOOT, IDS_NEEDREBOOT);
            }

            else if (Problem) {
                ProblemText = DeviceProblemText(NULL,
                                                NewDevWiz->DeviceInfoData.DevInst,
                                                Problem
                                                );

                if (ProblemText) {
                    StringCchCat(TextBuffer, SIZECHARS(TextBuffer), TEXT("\n\n"));
                    StringCchCat(TextBuffer, SIZECHARS(TextBuffer), ProblemText);
                    LocalFree(ProblemText);
                }
            }
        }

        //
        // Installation was sucessful and the device does not have any problems
        //
        else {
            //
            // If this was a silent install (a Rank 0 match for example) then don't show the finish
            // page.
            //
            if (NewDevWiz->SilentMode) {
                HideWindowByMove(hwndParentDlg);
                PropSheet_PressButton(hwndParentDlg, PSBTN_FINISH);
                return;
            }
        }

        SetDlgItemText(hDlg, IDC_FINISH_MSG3, TextBuffer);
    }
}

INT_PTR CALLBACK
NDW_FinishDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HICON hicon;

    switch (wMsg) {
    case WM_INITDIALOG:
        {
            LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
            NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

            break;
        }

    case WM_DESTROY:
        hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_GETICON, 0, 0);
        if (hicon) {
            DestroyIcon(hicon);
        }
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDC_NDW_DISPLAYRESOURCE:
            DisplayResource(NewDevWiz, GetParent(hDlg));
            break;
        }

        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {
        case PSN_SETACTIVE: {
            //
            // No back button since install is already done.
            // set the device description
            // Hide Resources button until we know if resources exist or not.
            // Set the class Icon
            //
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);

            EnableWindow(GetDlgItem(GetParent(hDlg),  IDCANCEL), FALSE);

            ShowWindow(GetDlgItem(hDlg, IDC_NDW_DISPLAYRESOURCE), SW_HIDE);

            if (NewDevWiz->LastError == ERROR_CANCELLED) {

                if (NewDevWiz->SilentMode)
                {
                    HideWindowByMove(GetParent(hDlg));
                }

                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);

            } else {

                SetDriverDescription(hDlg, IDC_NDW_DESCRIPTION, NewDevWiz);

                if (SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL)) {
                    hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                    if (hicon) {
                        DestroyIcon(hicon);
                    }
                }

                ShowInstallSummary(hDlg, NewDevWiz);
            }
            break;
        }

        case PSN_RESET:
            break;


        case PSN_WIZFINISH:
            if (NewDevWiz->LaunchTroubleShooter) {

                //
                // The command line that we will run is:
                // %windir%\system32\rundll32 %windir%\system32\devmgr.dll, DeviceProblenWizard_RunDLL /deviceid %s
                // where %s is the device instance id.
                //
                TCHAR FullPath[MAX_PATH];
                TCHAR szCmdLine[512];
                TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];

                if ((CM_Get_Device_ID(NewDevWiz->DeviceInfoData.DevInst,
                                      DeviceInstanceId,
                                      SIZECHARS(DeviceInstanceId),
                                      0
                                      ) == CR_SUCCESS) &&
                    GetSystemDirectory(FullPath, SIZECHARS(FullPath)) &&
                    pSetupConcatenatePaths(FullPath, TEXT("DEVMGR.DLL"), SIZECHARS(FullPath), NULL)) {

                    if (SUCCEEDED(StringCchPrintf(szCmdLine,
                                                  SIZECHARS(szCmdLine),
                                                  TEXT("%s,DeviceProblenWizard_RunDLL /deviceid %s"),
                                                  FullPath,
                                                  DeviceInstanceId))) {
    
                        //
                        // Now get a full path to rundll32.exe, which lives
                        // in the %windir%\systrem32 directory.
                        //
                        if (GetSystemDirectory(FullPath, SIZECHARS(FullPath)) &&
                            pSetupConcatenatePaths(FullPath, TEXT("RUNDLL32.EXE"), SIZECHARS(FullPath), NULL)) {
                            
                            ShellExecute(NULL,
                                         TEXT("open"),
                                         FullPath,
                                         szCmdLine,
                                         NULL,
                                         SW_SHOWNORMAL
                                         );
                        }
                    }
                }
            }
            break;

        }
        break;


    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtFinishInstallDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {

    case WM_INITDIALOG: {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE:

            PrevPageId = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_WIZARDEXT_FINISHINSTALL;

            if (PrevPageId == IDD_NEWDEVWIZ_INSTALLDEV)
            {
                PROPSHEETPAGE psp;
                HPROPSHEETPAGE hPage = NULL;

                //
                // Moving forward on first page
                //

                //
                // If this was a silent install and NOT a NonInteractive install
                // then we need to create the FinishInstallIntro page at this
                // point so we can add it to the wizard. We do this so the wizard
                // has a proper intro and finish page with the FinishInstall
                // pages inbetween.
                //
                if (NewDevWiz->SilentMode &&
                    !(pSetupGetGlobalFlags() & PSPGF_NONINTERACTIVE)) {

                    ZeroMemory(&psp, sizeof(psp));
                    psp.dwSize = sizeof(PROPSHEETPAGE);
                    psp.hInstance = hNewDev;
                    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
                    psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_FINISHINSTALL_INTRO);
                    psp.pfnDlgProc = FinishInstallIntroDlgProc;
                    psp.lParam = (LPARAM)NewDevWiz;

                    hPage = CreatePropertySheetPage(&psp);
                }

                //
                // Add ClassWizard Extension pages for FinishInstall
                //
                if (AddClassWizExtPages(hwndParentDlg,
                                        NewDevWiz,
                                        &NewDevWiz->WizExtFinishInstall.DeviceWizardData,
                                        DIF_NEWDEVICEWIZARD_FINISHINSTALL,
                                        hPage
                                        )) {

                    //
                    // If this is a NonInteractive install then we need to set the last
                    // error at this point so the error is propagated back to the original
                    // caller.
                    //
                    if (pSetupGetGlobalFlags() & PSPGF_NONINTERACTIVE) {

                        NewDevWiz->LastError = ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;

                    } else {

                        //
                        // If we have finish install pages then we should also show the finish
                        // page.
                        //
                        NewDevWiz->SilentMode = FALSE;
                    }
                }

                //
                // Add the end page, which is FinishInstall end
                //
                NewDevWiz->WizExtFinishInstall.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_FINISHINSTALL_END,
                                                                                WizExtFinishInstallEndDlgProc,
                                                                                NewDevWiz
                                                                                );

                if (NewDevWiz->WizExtFinishInstall.hPropSheetEnd)
                {
                    PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtFinishInstall.hPropSheetEnd);
                }
            }


            //
            // We can't go backwards, so always go forward
            //
            SetDlgMsgResult(hDlg, wMsg, -1);
            break;

        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtFinishInstallEndDlgProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {

    case WM_INITDIALOG: {

        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE:

            NewDevWiz->PrevPage = IDD_WIZARDEXT_FINISHINSTALL_END;

           //
           // We can't go backwards, so always go forward
           //
           SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_FINISH);
           break;

        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            SetDlgMsgResult(hDlg, wMsg, 0);
            break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\newdev\init.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       init.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include "pnpipc.h"


HMODULE hNewDev = NULL;
BOOL bQueuedRebootNeeded = FALSE;
BOOL GuiSetupInProgress = FALSE;
HANDLE hTrayIconWnd = NULL;

BOOL
DllInitialize(
    IN PVOID hmod,
    IN ULONG ulReason,
    IN PCONTEXT pctx OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(pctx);
    
    hNewDev = hmod;

    UNREFERENCED_PARAMETER(pctx);

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hmod);

        if (!SHFusionInitializeFromModule(hmod)) {
            return FALSE;
        }

        IntializeDeviceMapInfo();
        GuiSetupInProgress = GetGuiSetupInProgress();

        LoadString(hNewDev,
                   IDS_UNKNOWN,
                   (PTCHAR)szUnknown,
                   SIZECHARS(szUnknown)
                   );

        LoadString(hNewDev,
                   IDS_UNKNOWNDEVICE,
                   (PTCHAR)szUnknownDevice,
                   SIZECHARS(szUnknownDevice)
                   );

        hSrClientDll = NULL;
        break;

    case DLL_PROCESS_DETACH:
        SHFusionUninitialize();
        break;
    }

    return TRUE;
}

BOOL
pInstallDeviceInstanceNewDevice(
    HWND hwndParent,
    HWND hBalloonTiphWnd,
    PNEWDEVWIZ NewDevWiz
    )
{
    ULONG DevNodeStatus = 0, Problem = 0;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    BOOL bHaveDriver = TRUE;

    //
    // Set the DI_QUIETINSTALL flag for the Found New Hardware case
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      )) {

        DeviceInstallParams.Flags |= DI_QUIETINSTALL;

        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }

    //
    // Do a driver search by searching the default INF locations.
    //
    DoDriverSearch(hwndParent,
                   NewDevWiz,
                   SEARCH_DEFAULT,
                   SPDIT_COMPATDRIVER,
                   FALSE
                   );

    //
    // Check if the Windows Update cache says it has a better driver if we are
    // connected to the Internet.
    //
    if (IsConnectedToInternet() &&
        SearchWindowsUpdateCache(NewDevWiz)) {

        //
        // The machine is connected to the Internet and the WU cache says it has
        // a better driver, so let's connect to the Internet and download this
        // driver from WU.
        //
        DoDriverSearch(hwndParent,
                       NewDevWiz,
                       SEARCH_INET,
                       SPDIT_COMPATDRIVER,
                       TRUE
                       );
    }

    //
    // Lets see if we found a driver for this device.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 )) {

        if (FAILED(StringCchCopy(NewDevWiz->DriverDescription,
                                 SIZECHARS(NewDevWiz->DriverDescription),
                                 DriverInfoData.Description))) {
            
            NewDevWiz->DriverDescription[0] = TEXT('\0');
        }

        //
        // fetch rank of driver found.
        //
        DriverInstallParams.cbSize = sizeof(DriverInstallParams);
        if (!SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData,
                                           &DriverInfoData,
                                           &DriverInstallParams
                                           )) {

            DriverInstallParams.Rank = (DWORD)-1;
        }

        //
        // If we have a balloon tip window then have it update its UI.
        //
        if (hBalloonTiphWnd) {
            //
            // We have a new driver description for this device so use this to update the balloon
            // tip.
            //
            PostMessage(hBalloonTiphWnd,
                        WUM_UPDATEUI,
                        0,
                        (LPARAM)NewDevWiz->DriverDescription
                        );

        } else if (NewDevWiz->Flags & IDI_FLAG_SECONDNEWDEVINSTANCE) {
            //
            // This is the second NEWDEV.DLL instance running with Administrator privileges.  We need
            // to send a message to the main NEWDEV.DLL process and have it update it's balloon tooltip.
            //
            SendMessageToUpdateBalloonInfo(NewDevWiz->DriverDescription);
        }

    } else {

        *NewDevWiz->DriverDescription = L'\0';
        DriverInstallParams.Rank = (DWORD)-1;
        DriverInstallParams.Flags = 0;
        bHaveDriver = FALSE;

        //
        // If we have a balloon tip window then have it update its UI.
        //
        if (hBalloonTiphWnd) {
            //
            // We don't have a driver description, most likely because we didn't find a driver for this device,
            // so just update the balloon text using the DeviceInstanceId.
            //
            PostMessage(hBalloonTiphWnd,
                        WUM_UPDATEUI,
                        (WPARAM)TIP_LPARAM_IS_DEVICEINSTANCEID,
                        (LPARAM)NewDevWiz->InstallDeviceInstanceId
                        );
        }

    }

    //
    // Get the status of this devnode
    //
    CM_Get_DevNode_Status(&DevNodeStatus,
                          &Problem,
                          NewDevWiz->DeviceInfoData.DevInst,
                          0
                          );


    //
    // If we have a Hardware ID match and the selected (best) driver is not
    // listed as InteractiveInstall in the INF then just install the driver 
    // for this device.
    //
    if ((DriverInstallParams.Rank <= DRIVER_HARDWAREID_RANK) &&
        (!IsDriverNodeInteractiveInstall(NewDevWiz, &DriverInfoData))) {

        NewDevWiz->SilentMode = TRUE;

        DoDeviceWizard(hwndParent, NewDevWiz, FALSE);

        //
        // Install any new child devices that have come online due to the installation
        // of this device.  If there are any then install them silently.
        //
        if (!(NewDevWiz->Capabilities & CM_DEVCAP_SILENTINSTALL)) {
            InstallSilentChilds(hwndParent, NewDevWiz);
        }
    
    }  else if (!bHaveDriver &&
                (NewDevWiz->Capabilities & CM_DEVCAP_RAWDEVICEOK) &&
                (NewDevWiz->Capabilities & CM_DEVCAP_SILENTINSTALL) &&
                (DevNodeStatus & DN_STARTED)) {

        //
        // If the device is both RAW, silent install, and already started,
        // and we didn't find any drivers, then we just want to
        // install the NULL driver.
        //
        InstallNullDriver(NewDevWiz, FALSE);
    
    } else {
        //
        // This is the case where we don't have a hardware ID match and we don't have a special
        // RAW, silent, started device.  So in this case we will bring up the Found New Hardware
        // Wizard so the user can install a driver for this device.
        //

        //
        // If we have a balloon tip window then hide it.
        //
        if (hBalloonTiphWnd) {
            PostMessage(hBalloonTiphWnd,
                        WUM_UPDATEUI,
                        (WPARAM)TIP_HIDE_BALLOON,
                        0
                        );
        }

        //
        // We are bringing up the wizard, so clear the DI_QUIETINSTALL flag.
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
        if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          )) {

            DeviceInstallParams.Flags &= ~DI_QUIETINSTALL;

            SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }


        //
        // Bring up the Found New Hardware Wizard
        //
        DoDeviceWizard(GetParent(hwndParent), NewDevWiz, TRUE);

        //
        // Install any new child devices that have come online due to the installation
        // of this device.  If there are any then install them silently.
        //
        if (!(NewDevWiz->Capabilities & CM_DEVCAP_SILENTINSTALL)) {

            InstallSilentChilds(hwndParent, NewDevWiz);
        }
    }

    return (GetLastError() == ERROR_SUCCESS);
}

BOOL
pInstallDeviceInstanceUpdateDevice(
    HWND hwndParent,
    PNEWDEVWIZ NewDevWiz
    )
{
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;

    //
    // We need to first check with the class/co-installers to give them the
    // change to bring up their own update driver UI.  This needs to be done
    // because there are some cases when our default behavior can cause the
    // device not to work. This only currently happens in the multiple
    // identical device case.
    //
    if (SetupDiCallClassInstaller(DIF_UPDATEDRIVER_UI,
                                  NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData
                                  ) ||
        (GetLastError() != ERROR_DI_DO_DEFAULT)) {
        
        //
        // If the class/co-installer returned NO_ERRROR, or some error other
        // than ERROR_DI_DO_DEFAULT then we will not display our default wizard.
        //
        return FALSE;
    }

    //
    // Jump directly into the Update Driver Wizard
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      ))
    {
        //
        // This shouldn't be a quiet install, since we are doing a normal Update Driver
        //
        DeviceInstallParams.Flags &= ~DI_QUIETINSTALL;

        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );

        DoDeviceWizard(hwndParent, NewDevWiz, TRUE);
    }

    return (GetLastError() == ERROR_SUCCESS);
}

BOOL
pInstallDeviceInstanceUpdateDeviceSilent(
    HWND hwndParent,
    PNEWDEVWIZ NewDevWiz
    )
{
    ULONG SearchOptions;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;

    if (NewDevWiz->UpdateDriverInfo &&
        NewDevWiz->UpdateDriverInfo->FromInternet) {
        //
        // Drivers are from the Internet (newdev API called from WU)
        //
        if (FAILED(StringCchCopy(NewDevWiz->BrowsePath,
                                 SIZECHARS(NewDevWiz->BrowsePath),
                                 NewDevWiz->UpdateDriverInfo->InfPathName))) {
            //
            // The path that was passed in was too large to fit in our buffer
            //
            SetLastError(ERROR_DI_BAD_PATH);
            return FALSE;
        }

        SearchOptions = SEARCH_WINDOWSUPDATE;
    
    } else {
        //
        // Normal app just telling us to update this device using the specified INF
        // or a driver rollback.
        //
        if (FAILED(StringCchCopy(NewDevWiz->SingleInfPath,
                                 SIZECHARS(NewDevWiz->SingleInfPath), 
                                 NewDevWiz->UpdateDriverInfo->InfPathName))) {
            //
            // The path that was passed in was too large to fit in our buffer
            //
            SetLastError(ERROR_DI_BAD_PATH);
            return FALSE;
        }

        SearchOptions = SEARCH_SINGLEINF;
    }

    //
    // If this is not a Force install we want to compare the driver against
    // the currently installed driver.  Note that we will only install the
    // device if it was found in the specified directory.
    //
    if (!(NewDevWiz->Flags & IDI_FLAG_FORCE)) {

        SearchOptions |= SEARCH_CURRENTDRIVER;
    }

    //
    // The silent update device code path always has the DI_QUIETINSTALL flag
    // set.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      )) {

        DeviceInstallParams.Flags |= DI_QUIETINSTALL;

        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }

    //
    // Search the specified directory or INF for drivers
    //
    DoDriverSearch(hwndParent,
                   NewDevWiz,
                   SearchOptions,
                   (NewDevWiz->Flags & IDI_FLAG_ROLLBACK) ?
                      SPDIT_CLASSDRIVER : SPDIT_COMPATDRIVER,
                   FALSE
                   );

    //
    // At this point we should already have the best driver selected, but if this is
    // a driver rollback we want to select the driver node ourselves using the
    // DevDesc, ProviderName, and Mfg of the original driver installed on this device.
    // We need to do this because the driver that we rolled back might not be the best
    // driver node in this INF.
    //
    if ((NewDevWiz->Flags & IDI_FLAG_ROLLBACK) &&
        (NewDevWiz->UpdateDriverInfo->Description[0] != TEXT('\0')) &&
        (NewDevWiz->UpdateDriverInfo->MfgName[0] != TEXT('\0')) &&
        (NewDevWiz->UpdateDriverInfo->ProviderName[0] != TEXT('\0'))) {

        ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));

        DriverInfoData.cbSize = sizeof(DriverInfoData);
        DriverInfoData.DriverType = SPDIT_CLASSDRIVER;
        DriverInfoData.Reserved = 0;
        
        if (FAILED(StringCchCopy(DriverInfoData.Description,
                                SIZECHARS(DriverInfoData.Description),
                                NewDevWiz->UpdateDriverInfo->Description)) ||
            FAILED(StringCchCopy(DriverInfoData.MfgName,
                                 SIZECHARS(DriverInfoData.MfgName),
                                 NewDevWiz->UpdateDriverInfo->MfgName)) ||
            FAILED(StringCchCopy(DriverInfoData.ProviderName,
                                 SIZECHARS(DriverInfoData.ProviderName),
                                 NewDevWiz->UpdateDriverInfo->ProviderName))) {
            //
            // If we somehow had strings in the registry that were too large for
            // setupapi's buffers, then just bail out now.
            //
            NewDevWiz->LastError = ERROR_NO_MORE_ITEMS;
            SetLastError(ERROR_NO_MORE_ITEMS);
            goto clean0;
        }

        SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 );
    }

    //
    // Since we have UpdateDriverInfo and the caller specified a specfic InfPathName (whether
    // a full path to an INF or just the path where INFs live) then we want to verify
    // that the selected driver's INF lives in that specified path.  If it does not then
    // do not automatically install it since that is not what the caller intended.
    //
    if (pVerifyUpdateDriverInfoPath(NewDevWiz)) {

        NewDevWiz->SilentMode = TRUE;

        //
        // Install the driver on this device.
        //
        DoDeviceWizard(hwndParent, NewDevWiz, FALSE);

        //
        // Quietly install any children of this device that are now present after bringing this
        // device online.
        //
        if (!NewDevWiz->UpdateDriverInfo ||
            !NewDevWiz->UpdateDriverInfo->FromInternet) {
            InstallSilentChilds(hwndParent, NewDevWiz);
        }

    } else {

        //
        // If we get to this point then that means that the best driver we found was
        // not found in the specified directory or INF.  In this case we will not
        // install the best driver found and we'll set the appropriate error
        //
        NewDevWiz->LastError = ERROR_NO_MORE_ITEMS;
        SetLastError(ERROR_NO_MORE_ITEMS);
    }

clean0:
    return (GetLastError() == ERROR_SUCCESS);
}

BOOL
InstallDeviceInstance(
    HWND hwndParent,
    HWND hBalloonTiphWnd,
    LPCTSTR DeviceInstanceId,
    PDWORD pReboot,
    PUPDATEDRIVERINFO UpdateDriverInfo,
    DWORD Flags,
    DWORD InstallType,
    HMODULE *hCdmInstance,
    HANDLE *hCdmContext,
    PBOOL pbLogDriverNotFound,
    PBOOL pbSetRestorePoint
   )
/*++

Routine Description:

    This is the main function where most of the exported functions to install drivers end up
    after they do some preprocessing.  This function will install or update the device
    depending on the parameters.


Arguments:

    hwndParent - Window handle of the top-level window to use for any UI related
                 to installing the device.

    hBalloonTiphWnd - Handle to the WNDPROC that does all of the new Balloon tip UI.  This
                      is currently only used in the NDWTYPE_FOUNDNEW case.

    DeviceInstanceId - Supplies the ID of the device instance.  This is the registry
                       path (relative to the Enum branch) of the device instance key.

    pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)

    UpdateDriverInfo -

    Flags -
        IDI_FLAG_SILENTINSTALL - means the balloon tooltip will not be displayed
        IDI_FLAG_SECONDNEWDEVINSTANCE - means this is the second instance of newdev.dll
                                        that is running and the UI data should be sent
                                        over to the first instance of newdev.dll that
                                        is running.
        IDI_FLAG_NOBACKUP - Don't backup the old drivers.
        IDI_FLAG_READONLY_INSTALL - means the install is readonly (no file copy)
        IDI_FLAG_NONINTERACTIVE - Any UI will cause the API to fail.
        IDI_FLAG_ROLLBACK - set if we are doing a rollback       
        IDI_FLAG_FORCE - set if we are to force install this driver, which means
                         install it even if it is not better then the currently
                         installed driver.         
        IDI_FLAG_MANUALINSTALL - set if this is a manuall installed device. 
        IDI_FLAG_SETRESTOREPOINT - set if we are to set a restore point if the
                                   drivers that are getting installed are not
                                   digitally signed.  Currently we only set 
                                   restore points if the INF, catalog, or one
                                   of the copied files is not signed.

    InstallType - There are currently three different install types.
        NDWTYPE_FOUNDNEW - used to install drivers on a brand new device.
        NDWTYPE_UPDATE - used to bring up the Update Driver Wizard.
        NDWTYPE_UPDATE_SILENT - used to silently update the drivers for a device. The Update Driver Wizard
          won't be dispalyed in this case.

    hCdmInstance - A pointer to a hmodule that will receive the handle of the CDM
                   library when when and if we need to load it.                   

    hCdmContext - A pointer to a Cdm context handle that will receive the Cdm
                  context handle if it is opened.
    
    pbLogDriverNotFound - pointer to a BOOL that receives information on whether or not we
                          logged to Cdm.dll that we could not find a driver for this device.
                          
    pbSetRestorePoint - pointer to a BOOL that is set to TRUE if we needed to set
                        a system restore point because the drivers we were 
                        installing were not digitally signed. It is assumed that
                        if the caller wants to know if we called SRSetRestorePoint
                        then it is their responsiblity to call it again with
                        END_NESTED_SYSTEM_CHANGE to end the restore point. If 
                        the caller does not want this responsibility then they
                        should pass in NULL for this value and this function 
                        will handle calling SRSetRestorePoint with
                        END_NESTED_SYSTEM_CHANGE.                         


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/
{
    ULONG ConfigFlag;
    NEWDEVWIZ NewDevWiz;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;
    CLOSE_CDM_CONTEXT_PROC pfnCloseCDMContext;

    if (pbSetRestorePoint) {
        *pbSetRestorePoint = FALSE;
    }
    
    //
    // ensure we have a device instance.
    //
    if (!DeviceInstanceId  || !*DeviceInstanceId) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // If the InstallType is NDWTYPE_UPDATE_SILENT then they must pass in
    // an UpdateDriverInfo structure
    //
    if ((InstallType == NDWTYPE_UPDATE_SILENT) && !UpdateDriverInfo) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    memset(&NewDevWiz, 0, sizeof(NewDevWiz));

    NewDevWiz.InstallType = InstallType;
    NewDevWiz.SilentMode = FALSE;
    NewDevWiz.UpdateDriverInfo = UpdateDriverInfo;

    NewDevWiz.hDeviceInfo = SetupDiCreateDeviceInfoList(NULL, hwndParent);

    if (NewDevWiz.hDeviceInfo == INVALID_HANDLE_VALUE) {

        return FALSE;
    }

    NewDevWiz.LastError = ERROR_SUCCESS;

    NewDevWiz.Flags = Flags;

    try {
        //
        // Set the PSPGF_NONINTERACTIVE SetupGlobalFlag if we are in NonInteractive
        // mode. This means that setupapi will fail if it needs to display any UI
        // at all.
        //
        if (Flags & IDI_FLAG_NONINTERACTIVE) {

            pSetupSetGlobalFlags(pSetupGetGlobalFlags() | PSPGF_NONINTERACTIVE);
        }

        NewDevWiz.DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (!SetupDiOpenDeviceInfo(NewDevWiz.hDeviceInfo,
                                   DeviceInstanceId,
                                   hwndParent,
                                   0,
                                   &NewDevWiz.DeviceInfoData
                                   ))
        {
            NewDevWiz.LastError = GetLastError();
            goto IDIExit;
        }
        
        if (FAILED(StringCchCopy(NewDevWiz.InstallDeviceInstanceId,
                                 SIZECHARS(NewDevWiz.InstallDeviceInstanceId),
                                 DeviceInstanceId))) {

            NewDevWiz.LastError = ERROR_INVALID_DEVINST_NAME;
            goto IDIExit;
        }

        SetupDiSetSelectedDevice(NewDevWiz.hDeviceInfo, &NewDevWiz.DeviceInfoData);


        //
        // Get the ConfigFlags
        //
        if (SetupDiGetDeviceRegistryProperty(NewDevWiz.hDeviceInfo,
                                             &NewDevWiz.DeviceInfoData,
                                             SPDRP_CONFIGFLAGS,
                                             NULL,
                                             (PVOID)&ConfigFlag,
                                             sizeof(ConfigFlag),
                                             NULL) &&
            (ConfigFlag & CONFIGFLAG_MANUAL_INSTALL)) {

            NewDevWiz.Flags |= IDI_FLAG_MANUALINSTALL;
        }

        //
        // Get the device capabilities
        //
        if (!SetupDiGetDeviceRegistryProperty(NewDevWiz.hDeviceInfo,
                                              &NewDevWiz.DeviceInfoData,
                                              SPDRP_CAPABILITIES,
                                              NULL,
                                              (PVOID)&NewDevWiz.Capabilities,
                                              sizeof(NewDevWiz.Capabilities),
                                              NULL)) {

            NewDevWiz.Capabilities = 0;
        }

        //
        // initialize DeviceInstallParams
        //
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

        if (SetupDiGetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
        {

            DeviceInstallParams.Flags |= DI_SHOWOEM;
            DeviceInstallParams.hwndParent = hwndParent;

            //
            // If not manually installed, allow excluded drivers.
            //
            if (!(NewDevWiz.Flags & IDI_FLAG_MANUALINSTALL)) {

                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;
            }

            SetupDiSetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }

        else {

            NewDevWiz.LastError = GetLastError();
            goto IDIExit;
        }

        //
        // Set the ClassGuidSelected and ClassName field of NewDevWiz so we can have
        // the correct icon and class name for the device.
        //
        if (!IsEqualGUID(&NewDevWiz.DeviceInfoData.ClassGuid, &GUID_NULL)) {

            NewDevWiz.ClassGuidSelected = &NewDevWiz.DeviceInfoData.ClassGuid;

            if (!SetupDiClassNameFromGuid(NewDevWiz.ClassGuidSelected,
                                          NewDevWiz.ClassName,
                                          sizeof(NewDevWiz.ClassName),
                                          NULL
                                          )) {

                NewDevWiz.ClassGuidSelected = NULL;
                *(NewDevWiz.ClassName) = TEXT('\0');
            }
        }

        //
        // Create the CancelEvent in case the user wants to cancel out of the driver search
        //
        NewDevWiz.CancelEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

        //
        // At this point we have three different cases.
        //
        // 1) Normal Update Driver case - In this case we jump directly to the Update Driver wizard code
        // 2) Silent Update Driver case - This case is treated very similar to the new hardware case. We
        //    will silently search for an updated driver in the given path or INF and if we find a (better)
        //    driver then we will install it.
        // 3) Normal New Hardware case  - In this case we will do an initial search for drivers with the only
        //    UI being the balloon tip on the tray.  If we can't find a driver for this device then we will
        //    Jump into the wizard case.
        //

        //
        // For UPDATE, search all drivers, including old internet drivers
        //
        switch (NewDevWiz.InstallType) {

        case NDWTYPE_FOUNDNEW:
            pInstallDeviceInstanceNewDevice(hwndParent, hBalloonTiphWnd, &NewDevWiz);
            break;

        case NDWTYPE_UPDATE:
            pInstallDeviceInstanceUpdateDevice(hwndParent, &NewDevWiz);
            break;

        case NDWTYPE_UPDATE_SILENT:
            pInstallDeviceInstanceUpdateDeviceSilent(hwndParent, &NewDevWiz);
            break;
        }

        //
        // Cleanup
        //
        if (NewDevWiz.CancelEvent) {

            CloseHandle(NewDevWiz.CancelEvent);
        }

        //
        // Launch Help Center if we could not find a driver for this device.
        //
        if (NewDevWiz.LogDriverNotFound) {

            OpenCdmContextIfNeeded(&NewDevWiz.hCdmInstance,
                                   &NewDevWiz.hCdmContext
                                   );
    
            CdmLogDriverNotFound(NewDevWiz.hCdmInstance,
                                 NewDevWiz.hCdmContext,
                                 DeviceInstanceId,
                                 0
                                 );

            //
            // Let the caller know that we logged to cdm.dll that a driver
            // was not found.
            //
            if (pbLogDriverNotFound) {
                *pbLogDriverNotFound = TRUE;
            } else {
                //
                // If the caller did not want to know if we logged a 'not found'
                // driver to cdm.dll then at this point we need to tell Cdm
                // to call help center with it's list of 'not found' drivers.
                //
                CdmLogDriverNotFound(NewDevWiz.hCdmInstance,
                                     NewDevWiz.hCdmContext,
                                     NULL,
                                     0x00000002
                                     );
            }

        } else if (pbLogDriverNotFound) {
            *pbLogDriverNotFound = FALSE;
        }

        //
        // Let the caller know whether we had to set a system restore point or 
        // not, if they want to know.
        //
        if (pbSetRestorePoint) {
            *pbSetRestorePoint = NewDevWiz.SetRestorePoint;
        } else if (NewDevWiz.SetRestorePoint) {
            //
            // If the caller did not want to know if we set a restore point and
            // we did set a restore point, then we need to END the restore point
            // by calling SRSetRestorePoint with END_NESTED_SYSTEM_CHANGE.
            //
            pSetSystemRestorePoint(FALSE, FALSE, 0);
        }

        //
        // copy out the reboot flags for the caller
        // or put up the restart dialog if caller didn't ask for the reboot flag
        //
        if (pReboot) {

            *pReboot = NewDevWiz.Reboot;
        }

        else if (NewDevWiz.Reboot) {

             RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }

IDIExit:
   ;

    } except(NdwUnhandledExceptionFilter(GetExceptionInformation())) {
          NewDevWiz.LastError = RtlNtStatusToDosError(GetExceptionCode());
    }

    if (NewDevWiz.hDeviceInfo &&
        (NewDevWiz.hDeviceInfo != INVALID_HANDLE_VALUE)) {

        SetupDiDestroyDeviceInfoList(NewDevWiz.hDeviceInfo);
        NewDevWiz.hDeviceInfo = NULL;
    }

    //
    // If the caller wants the CdmInstance hmodule and context handle then pass
    // them back, otherwise close them.
    //
    if (hCdmContext) {
        *hCdmContext = NewDevWiz.hCdmContext;
    } else {

        //
        // The caller doesn't want the cdm context so close it if we have loaded
        // cdm.dll and opened a context.
        //
        if (NewDevWiz.hCdmInstance && NewDevWiz.hCdmContext) {
    
            pfnCloseCDMContext = (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(NewDevWiz.hCdmInstance,
                                                                        "CloseCDMContext"
                                                                        );
            if (pfnCloseCDMContext) {
                pfnCloseCDMContext(NewDevWiz.hCdmContext);
            }
        }
    }

    if (hCdmInstance) {
        *hCdmInstance = NewDevWiz.hCdmInstance;
    } else {
        FreeLibrary(NewDevWiz.hCdmInstance);
    }

    //
    // Clear the PSPGF_NONINTERACTIVE SetupGlobalFlag
    //
    if (Flags & IDI_FLAG_NONINTERACTIVE) {

        pSetupSetGlobalFlags(pSetupGetGlobalFlags() &~ PSPGF_NONINTERACTIVE);
    }
    
    SetLastError(NewDevWiz.LastError);

    return NewDevWiz.LastError == ERROR_SUCCESS;
}

BOOL
InstallDevInstEx(
   HWND hwndParent,
   LPCWSTR DeviceInstanceId,
   BOOL UpdateDriver,
   PDWORD pReboot,
   BOOL SilentInstall
   )
/*++

Routine Description:

   Exported Entry point from newdev.dll. Installs an existing Device Instance,
   and is invoked by Device Mgr to update a driver, or by Config mgr when a new
   device was found. In both cases the Device Instance exists in the registry.


Arguments:

    hwndParent - Window handle of the top-level window to use for any UI related
                 to installing the device.

    DeviceInstanceId - Supplies the ID of the device instance.  This is the registry
                       path (relative to the Enum branch) of the device instance key.

    UpdateDriver      - TRUE only newer or higher rank drivers are installed.

    pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)

    SilentInstall - TRUE means the "New Hardware Found" dialog will not be displayed


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/
{
    DWORD InstallType = UpdateDriver ? NDWTYPE_UPDATE : NDWTYPE_FOUNDNEW;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    //
    // Verify that the process has sufficient Administrator privileges.
    //
    if (!pSetupIsUserAdmin()) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    //
    // Validate parameters
    //
    if ((DeviceInstanceId == NULL) ||
        (DeviceInstanceId[0] == TEXT('\0'))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return InstallDeviceInstance(hwndParent,
                                 NULL,
                                 DeviceInstanceId,
                                 pReboot,
                                 NULL,
                                 IDI_FLAG_SETRESTOREPOINT |
                                 (SilentInstall ? IDI_FLAG_SILENTINSTALL : 0),
                                 InstallType,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL
                                 );
}

BOOL
InstallDevInst(
   HWND hwndParent,
   LPCWSTR DeviceInstanceId,
   BOOL UpdateDriver,
   PDWORD pReboot
   )
{
    return InstallDevInstEx(hwndParent,
                            DeviceInstanceId,
                            UpdateDriver,
                            pReboot,
                            FALSE);
}

BOOL
EnumAndUpgradeDevices(
    HWND hwndParent,
    LPCWSTR HardwareId,
    PUPDATEDRIVERINFO UpdateDriverInfo,
    DWORD Flags,
    PDWORD pReboot
    )
{
    HDEVINFO hDevInfo;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD Index;
    DWORD Size;
    TCHAR DeviceIdList[REGSTR_VAL_MAX_HCID_LEN];
    LPWSTR SingleDeviceId;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    BOOL Match;
    BOOL Result = TRUE;
    BOOL NoSuchDevNode = TRUE;
    ULONG InstallFlags = Flags;
    DWORD SingleNeedsReboot;
    DWORD TotalNeedsReboot = 0;
    DWORD Err = ERROR_SUCCESS;
    int i, count;
    HKEY hKey;
    BOOL bSingleDeviceSetRestorePoint = FALSE;
    BOOL bSetRestorePoint = FALSE;

    count = 0;

    if (pReboot) {
        *pReboot = 0;
    }

    hDevInfo = SetupDiGetClassDevs(NULL,
                                   NULL,
                                   hwndParent,
                                   DIGCF_ALLCLASSES | DIGCF_PRESENT
                                   );

    if (INVALID_HANDLE_VALUE == hDevInfo) {
        return FALSE;
    }

    ZeroMemory(&DeviceInfoData, sizeof(DeviceInfoData));
    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    Index = 0;

    //
    // Enumerate through all of the devices until we hit an installation error
    // or we run out of devices
    //
    while (Result &&
           SetupDiEnumDeviceInfo(hDevInfo,
                                 Index++,
                                 &DeviceInfoData
                                 )) {
        Match = FALSE;

        for (i = 0; i < 2; i++) {
            ZeroMemory(DeviceIdList, sizeof(DeviceIdList));
            Size = sizeof(DeviceIdList);
            if (SetupDiGetDeviceRegistryProperty(hDevInfo,
                                                 &DeviceInfoData,
                                                 (i ? SPDRP_HARDWAREID : SPDRP_COMPATIBLEIDS),
                                                 NULL,
                                                 (PBYTE)DeviceIdList,
                                                 Size,
                                                 &Size
                                                 )) {

                //
                // If any of the devices Hardware Ids or Compatible Ids match the given ID then
                // we have a match and need to upgrade the drivers on this device.
                //
                for (SingleDeviceId = DeviceIdList;
                     *SingleDeviceId;
                     SingleDeviceId += lstrlen(SingleDeviceId) + 1) {

                    if (_wcsicmp(SingleDeviceId, HardwareId) == 0) {

                        Match = TRUE;
                        NoSuchDevNode = FALSE;
                        break;
                    }
                }
            }
        }

        //
        // If we have a match then install the drivers on this device instance
        //
        if (Match) {

            if (SetupDiGetDeviceInstanceId(hDevInfo,
                                           &DeviceInfoData,
                                           DeviceInstanceId,
                                           SIZECHARS(DeviceInstanceId),
                                           &Size
                                           )) {

                SingleNeedsReboot = 0;

                //
                // Since this API is used only by InstallWindowsUpdateDriver and
                // UpdateDriverForPlugAndPlayDevice then specifiy the NDWTYPE_UPDATE_SILENT
                // Flag.  This will tell the device install code not to show the Found New Hardware
                // balloon tip in the tray and not to bring up the Update Driver Wizard if it can't
                // find a driver in the specified location.
                //
                Result = InstallDeviceInstance(hwndParent,
                                               NULL,
                                               DeviceInstanceId,
                                               &SingleNeedsReboot,
                                               UpdateDriverInfo,
                                               InstallFlags,
                                               NDWTYPE_UPDATE_SILENT,
                                               NULL,
                                               NULL,
                                               NULL,
                                               &bSingleDeviceSetRestorePoint
                                               );

                //
                // Save the last error code from the install.  Since we will be
                // doing multiple installs we want to save any error codes that
                // we get so we will only reset the last error code if our saved
                // error is ERROR_SUCCESS.
                //
                if (!Result && (Err == ERROR_SUCCESS)) {
                    Err = GetLastError();
                }

                count++;

                TotalNeedsReboot |= SingleNeedsReboot;

                //
                // We only want to backup the first device we install...not every one.
                //
                InstallFlags |= IDI_FLAG_NOBACKUP;

                //
                // If we just set a restore point when installing the last device
                // then clear the IDI_FLAG_SETRESTOREPOINT flag so we don't do
                // it for any of the other devices we install.
                // 
                if (bSingleDeviceSetRestorePoint) {
                    bSetRestorePoint = TRUE;
                    InstallFlags &= ~IDI_FLAG_SETRESTOREPOINT;
                }

                //
                // If we performed a backup and this is not the first device, then we need to add
                // this devices DeviceInstanceId to the backup key.
                //
                if ((count > 1) &&
                    (UpdateDriverInfo->BackupRegistryKey[0] != TEXT('\0'))) {

                    DWORD cbData, cbTotalSize;
                    PTSTR DeviceIdsBuffer;
                    PTSTR p;

                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     UpdateDriverInfo->BackupRegistryKey,
                                     0,
                                     KEY_READ | KEY_WRITE,
                                     &hKey) == ERROR_SUCCESS) {


                        //
                        // Lets see how big the DeviceInstanceIds buffer is so we can allocate enough
                        // memory.
                        //
                        cbData = 0;
                        if ((RegQueryValueEx(hKey,
                                             REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS,
                                             NULL,
                                             NULL,
                                             NULL,
                                             &cbData
                                             ) == ERROR_SUCCESS) &&
                            (cbData)) {

                            //
                            // Allocate a buffer large enough to hold the current list of DeviceInstanceIds,
                            // as well as the current DeviceInstanceId.
                            //
                            cbTotalSize = cbData + ((lstrlen(DeviceInstanceId) + 1) * sizeof(TCHAR));
                            DeviceIdsBuffer = malloc(cbTotalSize);

                            if (DeviceIdsBuffer) {

                                ZeroMemory(DeviceIdsBuffer, cbTotalSize);

                                if (RegQueryValueEx(hKey,
                                                    REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS,
                                                    NULL,
                                                    NULL,
                                                    (LPBYTE)DeviceIdsBuffer,
                                                    &cbData) == ERROR_SUCCESS) {

                                    for (p = DeviceIdsBuffer; *p; p+= (lstrlen(p) + 1)) {
                                        ;
                                    }

                                    //
                                    // p now points to the second terminating NULL character at the end of
                                    // the MULTI_SZ buffer.  This is where we'll put the new DeviceInstanceId.
                                    //
                                    lstrcpyn(p, DeviceInstanceId, lstrlen(DeviceInstanceId));

                                    //
                                    // Write the new string back into the registry.
                                    //
                                    RegSetValueEx(hKey,
                                                  REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS,
                                                  0,
                                                  REG_MULTI_SZ,
                                                  (LPBYTE)DeviceIdsBuffer,
                                                  cbTotalSize
                                                  );
                                }

                                free(DeviceIdsBuffer);
                            }
                        }

                        RegCloseKey(hKey);
                    }
                }
            }
        }
    }

    SetupDiDestroyDeviceInfoList(hDevInfo);

    //
    // If we had to set a system restore point because one of the drivers we
    // installed was not digitally signed, then at this point we need to call
    // SRSetRestorePoint with END_NESTED_SYSTEM_CHANGE.
    //
    if (bSetRestorePoint) {
        pSetSystemRestorePoint(FALSE, FALSE, 0);
    }

    //
    // If the caller wants to handle the reboot themselves then pass the information
    // back to them.
    //
    if (pReboot) {
        *pReboot = TotalNeedsReboot;
    }

    //
    // The caller did not specify a pointer to a Reboot DWORD so we will handle the
    // rebooting ourselves if necessary
    //
    else {
        if (TotalNeedsReboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }
    }

    //
    // If NoSuchDevNode is TRUE then we were unable to match the specified Hardware ID against
    // any of the devices on the system.  In this case we will set the last error to
    // ERROR_NO_SUCH_DEVINST.
    //
    if (NoSuchDevNode) {
        Err = ERROR_NO_SUCH_DEVINST;
    }

    SetLastError(Err);

    return (Err == ERROR_SUCCESS);
}

BOOL
pDoRollbackDriverCleanup(
    LPCSTR RegistryKeyName,
    PDELINFNODE pDelInfNodeHead
    )
{
    HKEY hKey, hSubKey;
    DWORD Error;
    DWORD cbData;
    TCHAR ReinstallString[MAX_PATH];
    PDELINFNODE     pDelInfNodeCur;

    if ((Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              REGSTR_PATH_REINSTALL,
                              0,
                              DELETE | KEY_READ,
                              &hKey)) != ERROR_SUCCESS) {

        SetLastError(Error);
        return FALSE;
    }

    //
    // Open up the subkey so we can get the ReinstallString which will give us the directory
    // that we need to delete.
    //
    if (RegOpenKeyEx(hKey,
                     (PTSTR)RegistryKeyName,
                     0,
                     KEY_READ,
                     &hSubKey) == ERROR_SUCCESS) {


        cbData = sizeof(ReinstallString);
        if (RegQueryValueEx(hSubKey,
                            REGSTR_VAL_REINSTALL_STRING,
                            NULL,
                            NULL,
                            (LPBYTE)ReinstallString,
                            &cbData) == ERROR_SUCCESS) {

            //
            // We have verified that this directory is a subdirectory of
            // %windir%\system32\ReinstallBackups so let's delete it.
            // Note that the string contains a foo.inf on the end, so strip that
            // off first.
            //
            PTSTR p = _tcsrchr(ReinstallString, TEXT('\\'));

            if (p) {

                *p = 0;

                RemoveCdmDirectory(ReinstallString);
            }
        }

        RegCloseKey(hSubKey);
    }

    RegDeleteKey(hKey, (PTSTR)RegistryKeyName);

    RegCloseKey(hKey);

    //
    // Now attempt to uninstall any 3rd party INFs that were just rolled
    // back over.  SetupUninstallOEMInf will fail if another device is still
    // using this INF.
    //
    if (pDelInfNodeHead) {

        for (pDelInfNodeCur = pDelInfNodeHead;
             pDelInfNodeCur;
             pDelInfNodeCur = pDelInfNodeCur->pNext) {

            SetupUninstallOEMInf(pDelInfNodeCur->szInf,
                                 0,
                                 NULL
                                 );
        }
    }

    return TRUE;
}

BOOL
RollbackDriver(
    HWND   hwndParent,
    LPCSTR RegistryKeyName,
    DWORD  Flags,
    PDWORD pReboot              OPTIONAL
    )
/*++

Routine Description:

   Exported Entry point from newdev.dll. It is invoked by Windows Update to update a driver.
   This function will scan through all of the devices on the machine and attempt to install
   these drivers on any devices that match the given HardwareId.


Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   RegistryKeyName - This is a subkey of HKLM\Software\Microsoft\Windows\CurrentVersion\Reinstall

   Flags - The following flags are defined:

           ROLLBACK_FLAG_FORCE - Force the rollback even if it is not better than the current driver
           ROLLBACK_FLAG_DO_CLEANUP - Do the necessary cleanup if the rollback was successful. This
                includes deleting the registry key as well as deleting the backup directory.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)

Return Value:

   BOOL TRUE if driver rollback succeedes.
        FALSE if no rollback occured.
        GetLastError() will return one of the following values:

--*/
{
    DWORD Error;
    HKEY hKey;
    TCHAR DriverRollbackKey[MAX_DEVICE_ID_LEN];
    TCHAR ReinstallString[MAX_PATH];
    DWORD InstallDeviceFlags;
    DWORD cbData;
    DWORD TotalNeedsReboot = 0, SingleNeedsReboot;
    BOOL  Result = FALSE;
    BOOL  bSingleDeviceSetRestorePoint = FALSE;
    BOOL  bSetRestorePoint = FALSE;
    UPDATEDRIVERINFO UpdateDriverInfo;
    LPTSTR DeviceInstanceIds = NULL;
    LPTSTR p;
    TCHAR CurrentlyInstalledInf[MAX_PATH];
    DWORD cbSize;
    PDELINFNODE pDelInfNodeHead = NULL, pDelInfNodeCur;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    //
    // Verify that the process has sufficient Administrator privileges.
    //
    if (!pSetupIsUserAdmin()) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    if (!RegistryKeyName || (RegistryKeyName[0] == TEXT('\0'))) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (Flags &~ ROLLBACK_BITS) {

        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if (FAILED(StringCchCopy(DriverRollbackKey, SIZECHARS(DriverRollbackKey), REGSTR_PATH_REINSTALL)) ||
        FAILED(StringCchCat(DriverRollbackKey, SIZECHARS(DriverRollbackKey), TEXT("\\"))) ||
        FAILED(StringCchCat(DriverRollbackKey, SIZECHARS(DriverRollbackKey), (PTSTR)RegistryKeyName))) {
        //
        // The RegistryKeyName the user passed in is too large to fit in our buffer
        // which means they must have passed in a bad key name.
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    
    if ((Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              DriverRollbackKey,
                              0,
                              KEY_READ,
                              &hKey)) != ERROR_SUCCESS) {
        //
        // The registry key does not exist, the user probably passed us in a
        // bad RegistryKeyName value.
        //
        SetLastError(Error);
        return FALSE;
    }

    InstallDeviceFlags = (IDI_FLAG_NOBACKUP | IDI_FLAG_ROLLBACK);

    if (Flags & ROLLBACK_FLAG_FORCE) {
    
        InstallDeviceFlags |= IDI_FLAG_FORCE;
    }

    //
    // Set the IDI_FLAG_SETRESTOREPOINT so if the driver we are rolling back
    // to is not digitally signed then we will set a system restore point
    // in case the user needs to rollback from the rollback.
    //
    InstallDeviceFlags |= IDI_FLAG_SETRESTOREPOINT;

    ZeroMemory(&UpdateDriverInfo, sizeof(UpdateDriverInfo));

    //
    // Assume failure
    //
    UpdateDriverInfo.DriverWasUpgraded = FALSE;

    //
    // Read the "ReinstallString" string value.  This contains the path to rollback the drivers
    // from.
    //
    cbData = sizeof(ReinstallString);
    if ((Error = RegQueryValueEx(hKey,
                                REGSTR_VAL_REINSTALL_STRING,
                                NULL,
                                NULL,
                                (LPBYTE)ReinstallString,
                                &cbData)) != ERROR_SUCCESS) {

        //
        // If we can't read the ReinstallString then we can't rollback any drivers!
        //
        SetLastError(Error);
        goto clean0;

    } else if (!cbData) {

        //
        // The ReinstallString value must contain something!
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        goto clean0;
    }

    UpdateDriverInfo.InfPathName = ReinstallString;
    UpdateDriverInfo.FromInternet = FALSE;

    //
    // Get the DevDesc, ProviderName, and Mfg from the Reinstall registry key
    // so we know which specific driver node to reinstall from this INF.
    //
    // We have to have a Description and a MfgName value, but there are rare
    // cases where there might not be a ProviderName value.
    //
    cbData = sizeof(UpdateDriverInfo.Description);
    if ((Error = RegQueryValueEx(hKey,
                                 REGSTR_VAL_DEVDESC,
                                 NULL,
                                 NULL,
                                 (LPBYTE)UpdateDriverInfo.Description,
                                 &cbData
                                 )) != ERROR_SUCCESS) {
        SetLastError(Error);
        goto clean0;
    }
    
    cbData = sizeof(UpdateDriverInfo.MfgName);
    if ((Error = RegQueryValueEx(hKey,
                                 REGSTR_VAL_MFG,
                                 NULL,
                                 NULL,
                                 (LPBYTE)UpdateDriverInfo.MfgName,
                                 &cbData
                                 )) != ERROR_SUCCESS) {
        SetLastError(Error);
        goto clean0;
    }

    cbData = sizeof(UpdateDriverInfo.ProviderName);
    Error = RegQueryValueEx(hKey,
                            REGSTR_VAL_PROVIDER_NAME,
                            NULL,
                            NULL,
                            (LPBYTE)UpdateDriverInfo.ProviderName,
                            &cbData
                            );

    //
    // For the ProviderName, it is valid if we get back FileNotFound because
    // the value is not present in the registry, however any other error is
    // not acceptable.
    //
    if (Error == ERROR_FILE_NOT_FOUND) {
        UpdateDriverInfo.ProviderName[0] = TEXT('\0');
    } else if (Error != ERROR_SUCCESS) {
        SetLastError(Error);
        goto clean0;
    }

    //
    // We need to get the DeviceInstanceIds MULTI_SZ string.  This will contain a list of
    // DeviceInstanceIds that we need to rollback.
    //
    if ((Error = RegQueryValueEx(hKey,
                                 REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS,
                                 NULL,
                                 NULL,
                                 NULL,
                                 &cbData)) != ERROR_SUCCESS) {

        SetLastError(Error);
        goto clean0;

    } else if (!cbData) {

        //
        // No DeviceInstanceIds to reinstall
        //
        SetLastError(ERROR_SUCCESS);
        goto clean0;
    }

    DeviceInstanceIds = malloc(cbData + sizeof(TCHAR));

    if (!DeviceInstanceIds) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        goto clean0;
    }

    ZeroMemory(DeviceInstanceIds, cbData + sizeof(TCHAR));

    if ((Error = RegQueryValueEx(hKey,
                                 REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS,
                                 NULL,
                                 NULL,
                                 (LPBYTE)DeviceInstanceIds,
                                 &cbData)) != ERROR_SUCCESS) {

        SetLastError(Error);
        goto clean0;
    }

    //
    // Enumerate through the list of DeviceInstanceIds and call InstallDeviceInstance() on
    // each one.
    //
    for (p = DeviceInstanceIds; *p; p += lstrlen(p) + 1) {

        SingleNeedsReboot = 0;

        //
        // We we are going to do the cleanup then we need to remember the INF files
        // that were installed before we do the rollback.
        //
        if (Flags & ROLLBACK_FLAG_DO_CLEANUP) {

            cbSize = sizeof(CurrentlyInstalledInf);

            if (GetInstalledInf(0, p, CurrentlyInstalledInf, &cbSize) &&
                IsInfFromOem(CurrentlyInstalledInf)) {

                //
                // Let's check to see if this Inf is already in our list
                //
                for (pDelInfNodeCur = pDelInfNodeHead;
                     pDelInfNodeCur;
                     pDelInfNodeCur = pDelInfNodeCur->pNext) {

                    if (!lstrcmpi(pDelInfNodeCur->szInf, CurrentlyInstalledInf)) {

                        break;
                    }
                }

                //
                // if pDelInfNodeCur is NULL then that means we walked all the way
                // through the linked list and did not find a match for the
                // CurrentlyInstalledInf...so we will add a node.
                //
                if (!pDelInfNodeCur) {

                    pDelInfNodeCur = malloc(sizeof(DELINFNODE));

                    if (pDelInfNodeCur) {

                        if (SUCCEEDED(StringCchCopy(pDelInfNodeCur->szInf,
                                                    SIZECHARS(pDelInfNodeCur->szInf),
                                                    CurrentlyInstalledInf))) {
                            pDelInfNodeCur->pNext = pDelInfNodeHead;
    
                            pDelInfNodeHead = pDelInfNodeCur;
                        } else {
                            //
                            // This should never happen, but if we can't copy the name of 
                            // the INF file into our local buffer so we know to delete
                            // it later, then free the buffer now since we won't
                            // be using it.
                            //
                            free(pDelInfNodeCur);
                        }
                    }
                }
            }
        }

        Result = InstallDeviceInstance(hwndParent,
                                       NULL,
                                       p,
                                       &SingleNeedsReboot,
                                       &UpdateDriverInfo,
                                       InstallDeviceFlags,
                                       NDWTYPE_UPDATE_SILENT,
                                       NULL,
                                       NULL,
                                       NULL,
                                       &bSingleDeviceSetRestorePoint
                                       );

        TotalNeedsReboot |= SingleNeedsReboot;

        if (bSingleDeviceSetRestorePoint) {
            bSetRestorePoint = TRUE;
            InstallDeviceFlags &= ~IDI_FLAG_SETRESTOREPOINT;
        }

        //
        // If we hit an installation error, bail out.
        //
        if (!Result) {

            break;
        }
    }

clean0:
    RegCloseKey(hKey);

    if (DeviceInstanceIds) {
        free(DeviceInstanceIds);
    }

    //
    // If we were successful then lets see if the caller wants us to do the cleanup
    //
    if ((Flags & ROLLBACK_FLAG_DO_CLEANUP) &&
        Result &&
        UpdateDriverInfo.DriverWasUpgraded) {

        pDoRollbackDriverCleanup(RegistryKeyName, pDelInfNodeHead);
    }

    //
    // If we had to set a system restore point because one of the drivers we
    // installed was not digitally signed, then at this point we need to call
    // SRSetRestorePoint with END_NESTED_SYSTEM_CHANGE.
    //
    if (bSetRestorePoint) {
        pSetSystemRestorePoint(FALSE, FALSE, 0);
    }

    //
    // Free up any memory we allocated to store 3rd party Infs that we want to delete.
    //
    while (pDelInfNodeHead) {
        pDelInfNodeCur = pDelInfNodeHead->pNext;
        free(pDelInfNodeHead);
        pDelInfNodeHead = pDelInfNodeCur;
    }

    //
    // If the caller wants to handle the reboot themselves then pass the information
    // back to them.
    //
    if (pReboot) {
        *pReboot = TotalNeedsReboot;
    } else {
        //
        // The caller did not specify a pointer to a Reboot DWORD so we will handle the
        // rebooting ourselves if necessary
        if (TotalNeedsReboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }
    }

    return UpdateDriverInfo.DriverWasUpgraded;
}

BOOL
InstallWindowsUpdateDriver(
    HWND hwndParent,
    LPCWSTR HardwareId,
    LPCWSTR InfPathName,
    LPCWSTR Reserved,
    BOOL Force,
    BOOL Backup,
    PDWORD pReboot
    )
/*++

Routine Description:

   Exported Entry point from newdev.dll. It is invoked by Windows Update to update a driver.
   This function will scan through all of the devices on the machine and attempt to install
   these drivers on any devices that match the given HardwareId.


Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   HardwareId - Supplies the Hardware ID to match agaist existing devices on the
                system.

   InfPathName - Inf Pathname and associated driver files.

   Reserved - ignored, should be NULL.

   Force - if TRUE this API will only look for infs in the directory specified by InfLocation.

   Backup - if TRUE this API will backup the existing drivers before installing the drivers
            from Windows Update.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)

Return Value:

   BOOL TRUE if a device was upgraded to a CDM driver.
        FALSE if no devices were upgraded to a CDM driver.  GetLastError()
            will be ERROR_SUCCESS if nothing went wrong, this driver
            simply wasn't for any devices on the machine or wasn't
            better than the current driver.  If GetLastError() returns
            any other error then there was an error during the installation
            of this driver.

--*/
{
    UPDATEDRIVERINFO UpdateDriverInfo;
    DWORD Flags = 0;
    TCHAR FullyQualifiedInfPath[MAX_PATH];
    WIN32_FIND_DATA finddata;
    LPTSTR lpFilePart;

    UNREFERENCED_PARAMETER(Reserved);

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    //
    // Verify that the process has sufficient Administrator privileges.
    //
    if (!pSetupIsUserAdmin()) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    //
    // Validate the input paramters
    //
    if ((HardwareId == NULL) ||
        (HardwareId[0] == TEXT('\0'))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if ((InfPathName == NULL) ||
        (InfPathName[0] == TEXT('\0'))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Make sure we get the fully qualified path and not a partial
    // or relative path.
    //
    if (GetFullPathName(InfPathName,
                        SIZECHARS(FullyQualifiedInfPath),
                        FullyQualifiedInfPath,
                        &lpFilePart
                        ) == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Make sure that the FullyQualifiedInfPath exists and that it is
    // a directory.
    //
    if (!FileExists(FullyQualifiedInfPath, &finddata) ||
        !(finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

        SetLastError(ERROR_PATH_NOT_FOUND);
        return FALSE;
    }

    ZeroMemory(&UpdateDriverInfo, sizeof(UpdateDriverInfo));

    UpdateDriverInfo.InfPathName = FullyQualifiedInfPath;
    UpdateDriverInfo.FromInternet = TRUE;

    if (!Backup) {

        Flags = IDI_FLAG_NOBACKUP;
    }

    if (Force) {
        
        Flags = IDI_FLAG_FORCE;
    }

    //
    // Assume that the upgrade will fail
    //
    UpdateDriverInfo.DriverWasUpgraded = FALSE;

    //
    // Call EnumAndUpgradeDevices which will enumerate through all the devices on the machine
    // and for any that match the given hardware ID it will attempt to upgrade to the specified
    // drivers.
    //
    EnumAndUpgradeDevices(hwndParent, HardwareId, &UpdateDriverInfo, Flags, pReboot);

    return UpdateDriverInfo.DriverWasUpgraded;
}

BOOL
WINAPI
UpdateDriverForPlugAndPlayDevicesW(
    HWND hwndParent,
    LPCWSTR HardwareId,
    LPCWSTR FullInfPath,
    DWORD InstallFlags,
    PBOOL bRebootRequired OPTIONAL
    )
/*++

Routine Description:

   This function will scan through all of the devices on the machine and attempt to install
   the drivers in FullInfPath on any devices that match the given HardwareId. The default
   behavior is to only install the specified drivers if the are better then the currently
   installed driver.


Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   HardwareId - Supplies the Hardware ID to match agaist existing devices on the
                system.

   FullInfPath - Full path to an Inf and associated driver files.

   InstallFlags - INSTALLFLAG_FORCE - If this flag is specified then newdev will not compare the
                    specified INF file with the current driver.  The specified INF file and drivers
                    will always be installed unless an error occurs.
                - INSTALLFALG_READONLY - if this flag is specified then newdev will attempt
                    a read-only install. This means that no file copy will be performed and
                    only the registry will be updated. Newdev.dll will do a presence check
                    on all of the files to verify that they are present first before 
                    completing the install.  If all of the files are not present then
                    ERROR_ACCESS_DENIED is returned.
                - INSTALLFLAG_NONINTERACTIVE - absolutely no UI. If any UI needs to be displayed
                    then the API will fail!

   pReboot - Optional address of BOOL to determine if a reboot is required or not.
             If pReboot is NULL then newdev.dll will prompt for a reboot if one is needed. If
             pReboot is a valid BOOL pointer then the reboot status is passed back to the
             caller and it is the callers responsibility to prompt for a reboot if one is
             needed.

Return Value:

   BOOL TRUE if a device was upgraded to the specified driver.
        FALSE if no devices were upgraded to the specified driver.  GetLastError()
            will be ERROR_SUCCESS if nothing went wrong, this driver
            wasn't better than the current driver.  If GetLastError() returns
            any other error then there was an error during the installation
            of this driver.

--*/
{
    UPDATEDRIVERINFO UpdateDriverInfo;
    DWORD NeedsReboot = 0;
    TCHAR FullyQualifiedInfPath[MAX_PATH];
    WIN32_FIND_DATA finddata;
    LPTSTR lpFilePart;
    DWORD Flags = 0;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    //
    // Verify that the process has sufficient Administrator privileges.
    //
    if (!pSetupIsUserAdmin()) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    //
    // Verify the parameters
    //
    if ((!HardwareId || (HardwareId[0] == TEXT('\0'))) ||
        (!FullInfPath || (FullInfPath[0] == TEXT('\0')))) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (InstallFlags &~ INSTALLFLAG_BITS) {

        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    //
    // Make sure we get the fully qualified path and not a partial path.
    //
    if (GetFullPathName(FullInfPath,
                        SIZECHARS(FullyQualifiedInfPath),
                        FullyQualifiedInfPath,
                        &lpFilePart
                        ) == 0) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    //
    // Make sure that the FullyQualifiedInfPath exists and that it is not
    // a directory.
    //
    if (!FileExists(FullyQualifiedInfPath, &finddata) ||
        (finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

        SetLastError(ERROR_FILE_NOT_FOUND);
        return FALSE;
    }

    ZeroMemory(&UpdateDriverInfo, sizeof(UpdateDriverInfo));

    UpdateDriverInfo.InfPathName = FullyQualifiedInfPath;
    UpdateDriverInfo.FromInternet = FALSE;

    //
    // Assume that the upgrade will fail
    //
    UpdateDriverInfo.DriverWasUpgraded = FALSE;

    //
    // If the INSTALLFLAG_READONLY is set then we will set the internal
    // IDI_FLAG_READONLY_INSTALL flag. The IDI_FLAG_NOBACKUP is also set since
    // we don't want to attempt to backup files when doing a read-only
    // install.
    //
    if (InstallFlags & INSTALLFLAG_READONLY) {

        Flags |= (IDI_FLAG_READONLY_INSTALL | IDI_FLAG_NOBACKUP);
    }

    //
    // If the INSTALLFLAG_NONINTERACTIVE flag is set then we will set the 
    // PSPGF_NONINTERACTIVE SetupGlobalFlag which tells setupapi to fail
    // if any UI at all needs to be displayed.
    //
    if (InstallFlags & INSTALLFLAG_NONINTERACTIVE) {

        Flags |= IDI_FLAG_NONINTERACTIVE;
    }

    //
    // If the INSTALLFLAG_FORCE flag is set then we will set the
    // IDI_FLAGS_FORCE flag which will tell us to not include the 
    // currently installed driver in our search for the best driver.
    //
    if (InstallFlags & INSTALLFLAG_FORCE) {

        Flags |= IDI_FLAG_FORCE;
    }

    //
    // Call EnumAndUpgradeDevices which will enumerate through all the devices on the machine
    // and for any that match the given hardware ID it will attempt to upgrade to the specified
    // drivers.
    //
    EnumAndUpgradeDevices(hwndParent, HardwareId, &UpdateDriverInfo, Flags, &NeedsReboot);

    if (bRebootRequired) {
        if (NeedsReboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            *bRebootRequired = TRUE;
        } else {
            *bRebootRequired = FALSE;
        }
    } else {
        if (NeedsReboot & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
            RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }
    }

    return UpdateDriverInfo.DriverWasUpgraded;
}

BOOL
WINAPI
UpdateDriverForPlugAndPlayDevicesA(
    HWND hwndParent,
    LPCSTR HardwareId,
    LPCSTR FullInfPath,
    DWORD InstallFlags,
    PBOOL bRebootRequired OPTIONAL
    )
{
    WCHAR   UnicodeHardwareId[MAX_DEVICE_ID_LEN];
    WCHAR   UnicodeFullInfPath[MAX_PATH];

    //
    // Convert the HardwareId and FullInfPath to UNICODE and call
    // InstallDriverForPlugAndPlayDevicesW
    //
    UnicodeHardwareId[0] = TEXT('\0');
    UnicodeFullInfPath[0] = TEXT('\0');
    MultiByteToWideChar(CP_ACP, 0, HardwareId, -1, UnicodeHardwareId, SIZECHARS(UnicodeHardwareId));
    MultiByteToWideChar(CP_ACP, 0, FullInfPath, -1, UnicodeFullInfPath, SIZECHARS(UnicodeFullInfPath));

    return UpdateDriverForPlugAndPlayDevicesW(hwndParent,
                                              UnicodeHardwareId,
                                              UnicodeFullInfPath,
                                              InstallFlags,
                                              bRebootRequired
                                              );
}

DWORD
WINAPI
DevInstallW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
/*++

Routine Description:

    This function is called by newdev.dll itself when the current user is not an Admin.
    UMPNPMGR.DLL calls NEWDEV.DLL ClientSideInstall to install devices.  If the currently logged on
    user does not have Administrator privilleges then NEWDEV.DLL prompts the user for an Administator
    username and password.  It then spawns another instance of newdev.dll using the
    CreateProcessWithLogonW() API and calls this entry point.  This entry point verifies that the
    process has Administrator privileges and if it does it calls InstallDeviceInstance() to install
    the device.

Arguments:

    hwnd - Handle to the parent window.

    hInst - This parameter is ignored.

    szCmd - The command line is the DeviceInstanceId to install.

    nShow - This parameter is ignored.


Return Value:

    returns the last error set from InstallDeviceInstance if the API fails or ERROR_SUCCESS
    if it succeedes.

--*/
{
    DWORD RebootNeeded = 0;
    DWORD LastError = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        ExitProcess(ERROR_IN_WOW64);
    }

    //
    // First verify that the process has sufficient Administrator privileges.
    //
    if (!pSetupIsUserAdmin()) {
        ExitProcess(ERROR_ACCESS_DENIED);
    }

    InstallDeviceInstance(hwnd,
                          NULL,
                          szCmd,
                          &RebootNeeded,
                          NULL,
                          IDI_FLAG_SECONDNEWDEVINSTANCE | IDI_FLAG_SETRESTOREPOINT,
                          NDWTYPE_FOUNDNEW,
                          NULL,
                          NULL,
                          NULL,
                          NULL
                          );

    LastError = GetLastError();

    if ((LastError == ERROR_SUCCESS) &&
        (RebootNeeded & (DI_NEEDRESTART | DI_NEEDREBOOT))) {

        LastError = ERROR_SUCCESS_REBOOT_REQUIRED;
    }

    ExitProcess(LastError);
}


BOOL
SpecialRawDeviceInstallProblem(
    DEVNODE DevNode
    )
/*++

Routine Description:

    There are certain devices that have the RAW capability flag set that need
    a driver to work.  This means the results of the install for these devices
    are special cased so that we display a negative finish balloon message
    instead of a positive one.  
    
    We can tell these bus types by looking up the bus type GUID flags and 
    checking for the BIF_RAWDEVICENEEDSDRIVER flag.

Arguments:

    DevNode

Return Value:

    TRUE if this is one of the special RAW devices and we couldn't find
    a driver to install.

--*/
{
    BOOL bDeviceHasProblem = FALSE;
    DWORD Capabilities = 0;
    DWORD cbData, dwType;

    cbData = sizeof(Capabilities);
    if ((CM_Get_DevNode_Registry_Property(DevNode,
                                          CM_DRP_CAPABILITIES,
                                          &dwType,
                                          (PVOID)&Capabilities,
                                          &cbData,
                                          0) == CR_SUCCESS) &&
        (Capabilities & CM_DEVCAP_RAWDEVICEOK) &&
        (GetBusInformation(DevNode) & BIF_RAWDEVICENEEDSDRIVER) &&
        (IsNullDriverInstalled(DevNode))) {
        //
        // This is a RAW device that has the BIF_RAWDEVICENEEDSDRIVER bus
        // information flag set and it doesn't have any drivers installed on
        // it.  This means it has a problem so we can show the correct balloon
        // text.
        //
        bDeviceHasProblem = TRUE;
    }

    return bDeviceHasProblem;
}

BOOL
PromptAndRunClientAsAdmin(
    PCTSTR DeviceInstanceId,
    DWORD *RebootRequired
    )
{
    DWORD Err = ERROR_SUCCESS;
    CREDUI_INFO ci;
    PTSTR UserName = NULL;
    PTSTR User = NULL;
    PTSTR Domain = NULL;
    PTSTR Password = NULL;
    PTSTR Caption = NULL;
    PTSTR Message = NULL;
    PTSTR Format = NULL;
    DWORD Status = ERROR_SUCCESS;
    BOOL bInstallSuccessful = FALSE;
    BOOL bInstallComplete = FALSE;
    int AlreadyTriedCount = 0;
    PTCHAR FriendlyName;
    TCHAR RunDll32Path[MAX_PATH];
    HRESULT hr;

    if (RebootRequired) {
        *RebootRequired = 0;
    }

    //
    // Allocate the memory that we need.
    //
    UserName = LocalAlloc(LPTR, CREDUI_MAX_USERNAME_LENGTH);
    User = LocalAlloc(LPTR, CREDUI_MAX_USERNAME_LENGTH);
    Domain = LocalAlloc(LPTR, CREDUI_MAX_DOMAIN_TARGET_LENGTH);
    Password = LocalAlloc(LPTR, CREDUI_MAX_PASSWORD_LENGTH);
    Caption = LocalAlloc(LPTR, CREDUI_MAX_CAPTION_LENGTH);
    Message = LocalAlloc(LPTR, CREDUI_MAX_MESSAGE_LENGTH);
    Format = LocalAlloc(LPTR, CREDUI_MAX_MESSAGE_LENGTH);

    if (!UserName || !User || !Domain || !Password || !Caption ||
        !Message || !Format) {
        //
        // Not enough memory to create all of the buffers we need to call
        // CredUIPromptForCredentials, so bail out.
        //
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    LoadString(hNewDev, IDS_FOUNDNEWHARDWARE, Caption, CREDUI_MAX_CAPTION_LENGTH/sizeof(TCHAR));
    
    if (LoadString(hNewDev, IDS_LOGON_TEXT, Format, CREDUI_MAX_MESSAGE_LENGTH/sizeof(TCHAR))) {

        DEVNODE DevInst = 0;

        CM_Locate_DevNode(&DevInst, (DEVINSTID)DeviceInstanceId, 0);
    
        if ((DevInst != 0) &&
            ((FriendlyName = BuildFriendlyName(DevInst, FALSE, NULL)) != NULL)) {

            hr = StringCchPrintf(Message, CREDUI_MAX_MESSAGE_LENGTH/sizeof(TCHAR), Format, FriendlyName);

            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                Message[0] = TEXT('\0');
            }

        } else {

            hr = StringCchPrintf(Message, CREDUI_MAX_MESSAGE_LENGTH/sizeof(TCHAR), Format, szUnknownDevice);

            if (FAILED(hr) && (hr != STRSAFE_E_INSUFFICIENT_BUFFER)) {
                Message[0] = TEXT('\0');
            }
        }
    }
    
    ZeroMemory(&ci, sizeof(ci));
    
    ci.cbSize = sizeof( ci );
    ci.pszCaptionText = Caption;
    ci.pszMessageText = Message;

    do {

        //
        // The user has not provided valid Admin credentials and they have not tried to
        // provide them MAX_PASSWORD_TRIES times.  So, we need to prompt them to provide
        // valid Admin credentials.
        //
        Status = CredUIPromptForCredentials(&ci,
                                            NULL,
                                            NULL,
                                            0,
                                            UserName,
                                            CREDUI_MAX_USERNAME_LENGTH/sizeof(TCHAR),
                                            Password,
                                            CREDUI_MAX_PASSWORD_LENGTH/sizeof(TCHAR),
                                            NULL,
                                            CREDUI_FLAGS_DO_NOT_PERSIST |
                                            CREDUI_FLAGS_REQUEST_ADMINISTRATOR |
                                            CREDUI_FLAGS_INCORRECT_PASSWORD |
                                            CREDUI_FLAGS_GENERIC_CREDENTIALS |
                                            CREDUI_FLAGS_COMPLETE_USERNAME);

        if (Status == ERROR_SUCCESS) {

            PROCESS_INFORMATION pi;
            STARTUPINFO si;
            TCHAR szCmdLine[MAX_PATH];
            DWORD dwExitCode = ERROR_SUCCESS;
            BOOL bCreateProcessSuccess = FALSE;

            User[0] = TEXT('\0');
            Domain[0] = TEXT('\0');

            CredUIParseUserName(UserName,
                                User,
                                CREDUI_MAX_USERNAME_LENGTH/sizeof(TCHAR),
                                Domain,
                                CREDUI_MAX_DOMAIN_TARGET_LENGTH/sizeof(TCHAR)
                                );

            //
            // We want to create a separate process using CreateProcessEx
            //
            ZeroMemory(&si, sizeof(si));
            ZeroMemory(&pi, sizeof(pi));
            si.cb = sizeof(si);
            si.wShowWindow = SW_SHOW;

            //
            // Create a new process with the administrator credentials. The process
            // that will be lanuched is:
            //
            // %windir%\system32\rundll32.exe newdev.dll,DevInstall <device instance Id>
            //
            if (GetSystemDirectory(RunDll32Path, SIZECHARS(RunDll32Path)) &&
                pSetupConcatenatePaths(RunDll32Path, TEXT("RUNDLL32.EXE"), SIZECHARS(RunDll32Path), NULL) &&
                SUCCEEDED(StringCchPrintf(szCmdLine,
                                          SIZECHARS(szCmdLine),
                                          TEXT("%s newdev.dll,DevInstall %s"), 
                                          RunDll32Path,
                                          DeviceInstanceId))) {
    
                bCreateProcessSuccess = CreateProcessWithLogonW(User,
                                                                Domain,
                                                                Password,
                                                                0,
                                                                NULL,
                                                                szCmdLine,
                                                                0,
                                                                NULL,
                                                                NULL,
                                                                &si,
                                                                &pi
                                                                );
            }

            SecureZeroMemory(Password, CREDUI_MAX_PASSWORD_LENGTH);

            if (bCreateProcessSuccess) {
                //
                // Close the thread handle since all we need is the process handle.
                //
                CloseHandle(pi.hThread);
                
                //
                // The process was successfully created so we need to wait for it to finish.
                //
                WaitForSingleObject(pi.hProcess, INFINITE);

                //
                // Check the return value from the process.  It should be one of the following
                // return values:
                //  ERROR_SUCCESS if the install went successfully.
                //  ERROR_SUCCESS_REBOOT_REQUIRED if the install went successfully and a 
                //      reboot is needed.
                //  ERROR _ACCESS_DENIED if the credentials provided were not admin credentials.
                //  Other - a error code returned because the install failed for some reason.
                //
                GetExitCodeProcess(pi.hProcess, &dwExitCode);

                if ((dwExitCode == ERROR_SUCCESS) ||
                    (dwExitCode == ERROR_SUCCESS_REBOOT_REQUIRED)) {

                    //
                    // Mark this install as complete so we will break out of our loop.
                    //
                    bInstallComplete = TRUE;

                    bInstallSuccessful = TRUE;

                    //
                    // Check if we need to reboot.
                    //
                    if ((dwExitCode == ERROR_SUCCESS_REBOOT_REQUIRED) &&
                        RebootRequired) {

                        *RebootRequired = DI_NEEDREBOOT;
                    }
                }

                //
                // If the error code is not ERROR_SUCCESS, ERROR_SUCCESS_REBOOT_REQUIRED,
                // or ERROR_ACCESS_DENIED then it means the installed failed for some reason.
                // for this case we will set bInstallComplete so we will break out
                // of the loop since we don't want to attempt another install on this
                // device.
                //
                else if (dwExitCode != ERROR_ACCESS_DENIED) {

                    //
                    // Mark this install as complete so we will break out of our loop.
                    //
                    bInstallComplete = TRUE;
                }

                else {
                    if (dwExitCode == ERROR_CANCELLED) {
                        Status = ERROR_CANCELLED;
                    }

                    //
                    // Some type of failure occured while installing this hardware.
                    //
                    Err = dwExitCode;
                }

                CloseHandle(pi.hProcess);
            }

            //
            // If the CreateProcessWithLogonW failed or the exit code for the process
            // was ERROR_ACCESS_DENIED then we need to display the bad credentials
            // message box.
            //
            if (!bCreateProcessSuccess ||
                (dwExitCode == ERROR_ACCESS_DENIED)) {
            
                //
                // The process failed, most likely because the user did not provide a username
                // and password.  So prompt a dialog and do it again.
                //
                TCHAR szWarningMsg[MAX_PATH];
                TCHAR szWarningCaption[MAX_PATH];

                if (LoadString(hNewDev,
                               IDS_NOTADMIN_ERROR,
                               szWarningMsg,
                               SIZECHARS(szWarningMsg))
                    &&
                    LoadString(hNewDev,
                               IDS_NEWDEVICENAME,
                               szWarningCaption,
                               SIZECHARS(szWarningCaption)))
                {
                    MessageBox(NULL, szWarningMsg, szWarningCaption, MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
                }

                //
                // Increment AlreadyTriedCount.  If this gets passed a certain threshold
                // then we should bail out.
                //
                AlreadyTriedCount++;
            }
        
        } else {
            
            //
            // Increment AlreadyTriedCount.  If this gets passed a certain threshold
            // then we should bail out.
            //
            AlreadyTriedCount++;
        }

        SecureZeroMemory(Password, CREDUI_MAX_PASSWORD_LENGTH);

        //
        // We will keep looping until one of the following things happen:
        //  1) we successfully lauch the second instance of newdev to install the device.
        //  2) the user cancels out of the password prompt dialog
        //  3) the user entered bogus admin credentials more than MAX_PASSWORD_TRIES tims.
        //
    } while ((Status != ERROR_CANCELLED) && 
             !bInstallComplete &&
             (AlreadyTriedCount < MAX_PASSWORD_TRIES));

    //
    // If the install was not completed then the user either cancelled out of could not provide a
    // valid admin credentials.
    //
    if (!bInstallComplete) {
        NoPrivilegeWarning(NULL);
    }

clean0:

    //
    // Free all of the memory that we allocated.
    //
    if (UserName) {
        LocalFree(UserName);
    }

    if (User) {
        LocalFree(User);
    }

    if (Domain) {
        LocalFree(Domain);
    }

    if (Password) {
        LocalFree(Password);
    }

    if (Caption) {
        LocalFree(Caption);
    }

    if (Message) {
        LocalFree(Message);
    }

    if (Format) {
        LocalFree(Format);
    }

    SetLastError(Err);

    return bInstallSuccessful;
}

DWORD
ClientSideInstallThread(
    HANDLE hPipeRead
    )
{
    DWORD Err = ERROR_SUCCESS;
    HMODULE hCdmInstance = NULL;
    HANDLE hCdmContext = NULL;
    BOOL bRunAsAdmin = TRUE;
    HANDLE hDeviceInstallEvent = NULL;
    ULONG InstallFlags = 0;
    DWORD Flags = IDI_FLAG_SETRESTOREPOINT;
    DEVNODE DevNode;
    ULONG Status, Problem;
    ULONG DeviceInstallEventLength = 0, DeviceInstanceIdLength = 0, BytesRead = 0;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    TCHAR DeviceInstallEventName[MAX_PATH];
    DWORD InstallDeviceCount = 0;
    TCHAR FinishText[MAX_PATH];
    BOOL bTotalLogDriverNotFound = FALSE;
    BOOL  bSingleDeviceSetRestorePoint = FALSE;
    BOOL  bSetRestorePoint = FALSE;
    CLOSE_CDM_CONTEXT_PROC pfnCloseCDMContext;

    bQueuedRebootNeeded = FALSE;

    //
    // The very first thing in the pipe should be the size of the name of the
    // event that we will signal after each device is finished being installed.
    //
    if (ReadFile(hPipeRead,
                 (LPVOID)&DeviceInstallEventLength,
                 sizeof(ULONG),
                 &BytesRead,
                 NULL)) {

        ASSERT(DeviceInstallEventLength != 0);
        if ((DeviceInstallEventLength == 0) ||
            (DeviceInstallEventLength >= SIZECHARS(DeviceInstallEventName))) {
            goto clean0;
        }

        //
        // The next thing in the pipe should be the name of the event that we
        // will signal after each device is finished being installed.
        //
        if (!ReadFile(hPipeRead,
                      (LPVOID)DeviceInstallEventName,
                      DeviceInstallEventLength,
                      &BytesRead,
                      NULL)) {

            goto clean0;
        }

    } else {
        if (GetLastError() == ERROR_INVALID_HANDLE) {
            //
            // The handle to the named pipe is not valid.  Make sure we don't
            // try to close it on exit.
            //
            hPipeRead = NULL;
        }
        goto clean0;
    }

    //
    // Open a handle to the specified named event that we can set and wait on.
    //
    hDeviceInstallEvent = OpenEventW(EVENT_MODIFY_STATE | SYNCHRONIZE,
                                     FALSE,
                                     DeviceInstallEventName);
    if (!hDeviceInstallEvent) {
        goto clean0;
    }

    //
    // Continue reading from the pipe until the other end is closed.
    //
    // The first thing in the pipe is a ULONG Flags value that tells us whether
    // this is a full install or UI only.
    //
    while(ReadFile(hPipeRead,
                   (LPVOID)&InstallFlags,
                   sizeof(DWORD),
                   &BytesRead,
                   NULL)) {

        //
        // Check to see if server side install needs a reboot.
        //
        if (InstallFlags & DEVICE_INSTALL_FINISHED_REBOOT) {
            bQueuedRebootNeeded = TRUE;
        }

        if (InstallFlags & DEVICE_INSTALL_BATCH_COMPLETE) {
            //
            // This is the last message that we should get from umpnpmgr.dll
            // when it has drained it's device install queue.  We will 
            // display a "Windows finished installing hardware" balloon that
            // will hang around until umpnpmgr.dll closes the named pipe,
            // or sends a new device install message.
            //
            // There are three different balloon messages that we can diaplay.
            // 1) all successful
            // 2) need reboot before hardware will work
            // 3) problem installing one or more devices.
            //
            UINT FinishId;

            //
            // Check to see if one of the devices that was installed server-side
            // ended up with a problem.
            //
            if (InstallFlags & DEVICE_INSTALL_PROBLEM) {
                Err = ERROR_INSTALL_FAILURE;
            }

            if (bQueuedRebootNeeded) {
                FinishId = IDS_FINISH_BALLOON_REBOOT;
            } else if (Err != ERROR_SUCCESS) {
                FinishId = IDS_FINISH_BALLOON_ERROR;
            } else {
                FinishId = IDS_FINISH_BALLOON_SUCCESS;
            }

            if (!LoadString(hNewDev, 
                            FinishId, 
                            FinishText, 
                            SIZECHARS(FinishText)
                            )) {
                FinishText[0] = TEXT('\0');
            }

            PostMessage(hTrayIconWnd,
                        WUM_UPDATEUI,
                        (WPARAM)TIP_PLAY_SOUND,
                        (LPARAM)FinishText
                        );

            //
            // If we could not find a driver for any of the new devices we just
            // installed then we need to call Cdm.dll one last time telling it
            // that we are done and it should send it's list to helpcenter.exe
            //
            // Note that we do this here as well as at the bottom of the loop
            // since this finish message hangs around for 10 seconds and that
            // is a long time to wait before we launch help center.
            //
            if (bTotalLogDriverNotFound) {

                bTotalLogDriverNotFound = FALSE;
                
                OpenCdmContextIfNeeded(&hCdmInstance,
                                       &hCdmContext
                                       );

                CdmLogDriverNotFound(hCdmInstance,
                                     hCdmContext,
                                     NULL,
                                     0x00000002
                                     );
            }
        }

        //
        // Read the DeviceInstanceId from the pipe if the DeviceInstanceIdLength
        // is valid.
        //
        if (ReadFile(hPipeRead,
                     (LPVOID)&DeviceInstanceIdLength,
                     sizeof(ULONG),
                     &BytesRead,
                     NULL) &&
            (DeviceInstanceIdLength)) {

            if (DeviceInstanceIdLength >= SIZECHARS(DeviceInstanceId)) {
                goto clean0;
            }

            if (!ReadFile(hPipeRead,
                          (LPVOID)DeviceInstanceId,
                          DeviceInstanceIdLength,
                          &BytesRead,
                          NULL)) {

                //
                // If this read fails then just close the UI and close the process.
                //
                goto clean0;
            }

            if (InstallFlags & DEVICE_INSTALL_UI_ONLY) {

                //
                // If this is a UI only install then send a WUM_UPDATEUI message to the installer
                // window so that it can update the icon and message in the tray.
                //
                PostMessage(hTrayIconWnd,
                            WUM_UPDATEUI,
                            (WPARAM)(TIP_LPARAM_IS_DEVICEINSTANCEID |
                                    ((InstallFlags & DEVICE_INSTALL_PLAY_SOUND) ? TIP_PLAY_SOUND : 0)),
                            (LPARAM)DeviceInstanceId
                            );

                InstallDeviceCount++;

                //
                // If we are only installing a small amount of devices (less than 5) then we
                // want to delay between each device so the user has time to read the balloon
                // tip.  If we are installing more than 5 devices then we want to skip the
                // delay altogether since we have a lot of devices to install and the user
                // probably wants this done as quickly as possible.
                //
                if (InstallDeviceCount < DEVICE_COUNT_FOR_DELAY) {
                    Sleep(DEVICE_COUNT_DELAY);
                }

            } else {

                DWORD RebootNeeded = 0;
                BOOL bLogDriverNotFound = FALSE;

                bSingleDeviceSetRestorePoint= FALSE;

                //
                // This is a full installation.
                //
                PostMessage(hTrayIconWnd,
                            WUM_UPDATEUI,
                            (WPARAM)TIP_LPARAM_IS_DEVICEINSTANCEID,
                            (LPARAM)DeviceInstanceId
                            );

                if (pSetupIsUserAdmin()) {
                    //
                    // This user is an Admin so simply install the device.
                    //
                    InstallDeviceInstance(NULL,
                                          hTrayIconWnd,
                                          DeviceInstanceId,
                                          &RebootNeeded,
                                          NULL,
                                          Flags,
                                          NDWTYPE_FOUNDNEW,
                                          &hCdmInstance,
                                          &hCdmContext,
                                          &bLogDriverNotFound,
                                          &bSingleDeviceSetRestorePoint
                                          );

                } else {
                    
                    if (bRunAsAdmin) {
                        bRunAsAdmin = PromptAndRunClientAsAdmin(DeviceInstanceId,
                                                                &RebootNeeded
                                                                );
                    }
                }

                //
                // Remember if there is a problem installing any of the devices.
                //
                if (GetLastError() != ERROR_SUCCESS) {
                    Err = GetLastError();
                }

                if (CM_Locate_DevNode(&DevNode, DeviceInstanceId, 0) == CR_SUCCESS) {
                    //
                    // If we located the devnode and it has a problem set the Err
                    // code so we can tell the user that something failed.
                    // If we cannot locate the devnode then the user most likely
                    // removed the device during the install process, so don't
                    // show this as an error.
                    //
                    if ((CM_Get_DevNode_Status(&Status, &Problem, DevNode, 0) != CR_SUCCESS) ||
                        (Status & DN_HAS_PROBLEM) ||
                        SpecialRawDeviceInstallProblem(DevNode)) {
                        //
                        // Either we couldn't locate the device, or it has some problem,
                        // so set Err to ERROR_INSTALL_FAILURE.  This error won't be
                        // shown, but it will trigger us to put up a different finish
                        // message in the balloon.
                        //
                        Err = ERROR_INSTALL_FAILURE;
                    }
                }

                if (RebootNeeded & (DI_NEEDRESTART | DI_NEEDREBOOT)) {
                    bQueuedRebootNeeded = TRUE;
                }

                if (bLogDriverNotFound) {
                    bTotalLogDriverNotFound = TRUE;
                }

                //
                // We only want to do one system restore point be batch of device
                // installs, so if the last driver that was installed was not
                // digitally signed and we did a system restore point, then
                // clear the IDI_FLAG_SETRESTOREPOINT.
                //
                if (bSingleDeviceSetRestorePoint) {
                    bSetRestorePoint = TRUE;
                    Flags &= ~IDI_FLAG_SETRESTOREPOINT;
                }
            }
        }

        //
        // We need to set the hDeviceInstallEvent event to let umpnpmgr.dll know that we are finished.
        //
        if (hDeviceInstallEvent) {
            SetEvent(hDeviceInstallEvent);
        }
    }

clean0:

    //
    // If we could not find a driver for any of the new devices we just
    // installed then we need to call Cdm.dll one last time telling it
    // that we are done and it should send it's list to helpcenter.exe
    //
    if (bTotalLogDriverNotFound) {
        
        OpenCdmContextIfNeeded(&hCdmInstance,
                               &hCdmContext
                               );
    
        CdmLogDriverNotFound(hCdmInstance,
                             hCdmContext,
                             NULL,
                             0x00000002
                             );
    }

    if (hCdmInstance) {

        if (hCdmContext) {
            pfnCloseCDMContext = (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hCdmInstance,
                                                                        "CloseCDMContext"
                                                                        );
            if (pfnCloseCDMContext) {
                pfnCloseCDMContext(hCdmContext);
            }
        }

        FreeLibrary(hCdmInstance);
    }

    //
    // If we had to set a system restore point because one of the drivers we
    // installed was not digitally signed, then at this point we need to call
    // SRSetRestorePoint with END_NESTED_SYSTEM_CHANGE.
    //
    if (bSetRestorePoint) {
        pSetSystemRestorePoint(FALSE, FALSE, 0);
    }

    //
    // Close the event handle
    //
    if (hDeviceInstallEvent) {
        CloseHandle(hDeviceInstallEvent);
    }

    if (hPipeRead) {
        CloseHandle(hPipeRead);
    }

    //
    // Tell the UI to go away because we are done
    //
    PostMessage(hTrayIconWnd, WUM_EXIT, 0, 0);

    return bQueuedRebootNeeded;
}

DWORD
WINAPI
ClientSideInstallW(
    HWND hwnd,
    HINSTANCE hInst,
    LPWSTR szCmd,
    int nShow
    )
{
    HANDLE hThread;
    DWORD ThreadId;
    HANDLE hPipeRead;
    MSG Msg;
    WNDCLASS wndClass;

    UNREFERENCED_PARAMETER(hInst);
    UNREFERENCED_PARAMETER(nShow);

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        ExitProcess(ERROR_IN_WOW64);
    }

    //
    // NOTE: This API can be called in the process of a user that does NOT
    // have administrator credentials.  If it is then we will later prompt
    // the user for administrator credentials and complet the install
    // if they are provided.
    //

    //
    // Make sure that a named pipe was specified in the cmd line.
    //
    if(!szCmd || !*szCmd) {
        goto clean0;
    }

    //
    // Wait 3 minutes for the specified named pipe to become available from 
    // the server.
    //
    if (!WaitNamedPipe(szCmd,
                       180000) 
                       ) {
        goto clean0;
    }

    //
    // Open a handle to the specified named pipe
    //
    hPipeRead = CreateFile(szCmd,
                           GENERIC_READ,
                           0,
                           NULL,
                           OPEN_EXISTING,
                           0,
                           NULL);
    if (INVALID_HANDLE_VALUE == hPipeRead) {
        //
        // If we can't open the specified global named pipe, there is nothing
        // more we can do.
        //
        goto clean0;
    }

    //
    // Lets see if the class has been registered.
    //
    if (!GetClassInfo(hNewDev, NEWDEV_CLASS_NAME, &wndClass)) {

        //
        // register the class
        //
        memset(&wndClass, 0, sizeof(wndClass));
        wndClass.lpfnWndProc = BalloonInfoProc;
        wndClass.hInstance = hNewDev;
        wndClass.lpszClassName = NEWDEV_CLASS_NAME;

        if (!RegisterClass(&wndClass)) {
            CloseHandle(hPipeRead);
            goto clean0;
        }
    }

    //
    // Create a window.
    //
    hTrayIconWnd = CreateWindowEx(WS_EX_TOOLWINDOW,
                            NEWDEV_CLASS_NAME,
                            TEXT(""),
                            WS_DLGFRAME | WS_BORDER | WS_DISABLED,
                            CW_USEDEFAULT,
                            CW_USEDEFAULT,
                            0,
                            0,
                            NULL,
                            NULL,
                            hNewDev,
                            NULL
                            );

    if (hTrayIconWnd == NULL) {
        CloseHandle(hPipeRead);
        goto clean0;
    }


    //
    // Create the device install thread that will read from the named pipe.
    // Note that once the ClientSideInstallThread is successfully created, it is
    // responsible for closing the handle to the named pipe when its done with
    // it.
    //
    hThread = CreateThread(NULL,
                           0,
                           ClientSideInstallThread,
                           (PVOID)hPipeRead,
                           0,
                           &ThreadId
                           );

    if (!hThread) {
        DestroyWindow(hTrayIconWnd);
        CloseHandle(hPipeRead);
        goto clean0;
    }

    while (IsWindow(hTrayIconWnd)) {

        if (GetMessage(&Msg, NULL, 0, 0)) {

            TranslateMessage(&Msg);
            DispatchMessage(&Msg);
        }
    }

    //
    // Check if a reboot is needed.
    //
    if (bQueuedRebootNeeded) {

        TCHAR RebootText[MAX_PATH];

        LoadString(hNewDev, IDS_NEWDEVICE_REBOOT, RebootText, SIZECHARS(RebootText));

        RestartDialogEx(hwnd, RebootText, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
    }

clean0:
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\newdev\intro.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       intro.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include <dbt.h>


INT_PTR
InitIntroDlgProc(
    HWND hDlg,
    PNEWDEVWIZ NewDevWiz
    )
{
    HFONT hfont;
    HDC hDC;
    int FontSize, PtsPixels;
    LOGFONT LogFont;

    //
    // Create the big bold font
    //
    hDC = GetDC(hDlg);

    if (hDC) {
    
        hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_INTRO_MSG1), WM_GETFONT, 0, 0);
        GetObject(hfont, sizeof(LogFont), &LogFont);
        LogFont.lfWeight = FW_BOLD;
        PtsPixels = GetDeviceCaps(hDC, LOGPIXELSY);
        FontSize = 12;
        LogFont.lfHeight = 0 - (PtsPixels * FontSize / 72);
    
        NewDevWiz->hfontTextBigBold = CreateFontIndirect(&LogFont);
    
        if (NewDevWiz->hfontTextBigBold ) {

            SetWindowFont(GetDlgItem(hDlg, IDC_INTRO_MSG1), NewDevWiz->hfontTextBigBold, TRUE);
        }
    }

    //
    // Create the bold font
    //
    hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_INTRO_MSG3), WM_GETFONT, 0, 0);
    GetObject(hfont, sizeof(LogFont), &LogFont);
    LogFont.lfWeight = FW_BOLD;
    NewDevWiz->hfontTextBold = CreateFontIndirect(&LogFont);

    if (NewDevWiz->hfontTextBold ) {
        
        SetWindowFont(GetDlgItem(hDlg, IDC_INTRO_MSG3), NewDevWiz->hfontTextBold, TRUE);
    }

    if (NDWTYPE_UPDATE == NewDevWiz->InstallType) {

        SetDlgText(hDlg, IDC_INTRO_MSG1, IDS_INTRO_MSG1_UPGRADE, IDS_INTRO_MSG1_UPGRADE);
    
    } else {

        //
        // The default text on the Wizard is for the Found New Hardware case, so we only
        // need to set the title text.
        //
        SetDlgText(hDlg, IDC_INTRO_MSG1, IDS_INTRO_MSG1_NEW, IDS_INTRO_MSG1_NEW);
    }

    //
    // Set the Initial radio button state to do auto-search.
    //
    CheckRadioButton(hDlg,
                     IDC_INTRO_SEARCH,
                     IDC_INTRO_ADVANCED,
                     IDC_INTRO_SEARCH
                     );

    return TRUE;
}

INT_PTR CALLBACK
IntroDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    if (wMsg == WM_INITDIALOG) {
        
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        if (!InitIntroDlgProc(hDlg, NewDevWiz)) {
            
            return FALSE;
        }

        return TRUE;
    }

    switch (wMsg)  {
       
    case WM_DESTROY: {
        if (NewDevWiz->hfontTextBigBold ) {

            DeleteObject(NewDevWiz->hfontTextBigBold);
            NewDevWiz->hfontTextBigBold = NULL;
        }
        
        if (NewDevWiz->hfontTextBold ) {

            DeleteObject(NewDevWiz->hfontTextBold);
            NewDevWiz->hfontTextBold = NULL;
        }
        break;
    }

    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_INTRO;
            SetDriverDescription(hDlg, IDC_INTRO_DRVDESC, NewDevWiz);
            
            if (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) {
                SetTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID, INSTALL_COMPLETE_CHECK_TIMEOUT, NULL);
            }
            break;

        case PSN_RESET:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;

        case PSN_WIZNEXT:
            NewDevWiz->EnterFrom = IDD_NEWDEVWIZ_INTRO;

            if (IsDlgButtonChecked(hDlg, IDC_INTRO_SEARCH)) {
            
                //
                // Set the search flags to search the following places automatically:
                // - default INF search path
                // - Windows Update, if we are connected to the Internet
                // - CD-ROM drives
                // - Floppy drives
                //
                NewDevWiz->SearchOptions = (SEARCH_CURRENTDRIVER |
                                            SEARCH_DEFAULT | 
                                            SEARCH_FLOPPY | 
                                            SEARCH_CDROM | 
                                            SEARCH_INET_IF_CONNECTED
                                            );

                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SEARCHING);

            } else {

                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_ADVANCEDSEARCH);
            }
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;
        }
        break;

    case WM_DEVICECHANGE:
        if ((wParam == DBT_DEVICEARRIVAL) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_devicetype == DBT_DEVTYP_VOLUME) &&
            (((PDEV_BROADCAST_VOLUME)lParam)->dbcv_flags & DBTF_MEDIA) &&
            (IsDlgButtonChecked(hDlg, IDC_INTRO_SEARCH))) {

            PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
        }
        break;
    
    case WM_TIMER:
        if (INSTALL_COMPLETE_CHECK_TIMERID == wParam) {
            if (IsInstallComplete(NewDevWiz->hDeviceInfo, &NewDevWiz->DeviceInfoData)) {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
FinishInstallInitIntroDlgProc(
    HWND hDlg,
    PNEWDEVWIZ NewDevWiz
    )
{
    HFONT hfont;
    HDC hDC;
    int FontSize, PtsPixels;
    LOGFONT LogFont;

    //
    // Create the big bold font
    //
    hDC = GetDC(hDlg);

    if (hDC) {
    
        hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_INTRO_MSG1), WM_GETFONT, 0, 0);
        GetObject(hfont, sizeof(LogFont), &LogFont);
        LogFont.lfWeight = FW_BOLD;
        PtsPixels = GetDeviceCaps(hDC, LOGPIXELSY);
        FontSize = 12;
        LogFont.lfHeight = 0 - (PtsPixels * FontSize / 72);
    
        NewDevWiz->hfontTextBigBold = CreateFontIndirect(&LogFont);
    
        if (NewDevWiz->hfontTextBigBold ) {

            SetWindowFont(GetDlgItem(hDlg, IDC_INTRO_MSG1), NewDevWiz->hfontTextBigBold, TRUE);
        }
    }

    //
    // Create the bold font
    //
    hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_INTRO_MSG3), WM_GETFONT, 0, 0);
    GetObject(hfont, sizeof(LogFont), &LogFont);
    LogFont.lfWeight = FW_BOLD;
    NewDevWiz->hfontTextBold = CreateFontIndirect(&LogFont);

    if (NewDevWiz->hfontTextBold ) {
        
        SetWindowFont(GetDlgItem(hDlg, IDC_INTRO_MSG3), NewDevWiz->hfontTextBold, TRUE);
    }

    if (NDWTYPE_UPDATE == NewDevWiz->InstallType) {

        SetDlgText(hDlg, IDC_INTRO_MSG1, IDS_INTRO_MSG1_UPGRADE, IDS_INTRO_MSG1_UPGRADE);
    
    } else {

        //
        // The default text on the Wizard is for the Found New Hardware case, so we only
        // need to set the title text.
        //
        SetDlgText(hDlg, IDC_INTRO_MSG1, IDS_INTRO_MSG1_NEW, IDS_INTRO_MSG1_NEW);
    }
    
    return TRUE;
}

INT_PTR CALLBACK
FinishInstallIntroDlgProc(
    HWND hDlg,
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HICON hicon;

    UNREFERENCED_PARAMETER(wParam);

    if (wMsg == WM_INITDIALOG) {
        
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        if (!InitIntroDlgProc(hDlg, NewDevWiz)) {
            
            return FALSE;
        }

        return TRUE;
    }

    switch (wMsg)  {
       
    case WM_DESTROY: {
        if (NewDevWiz->hfontTextBigBold ) {

            DeleteObject(NewDevWiz->hfontTextBigBold);
            NewDevWiz->hfontTextBigBold = NULL;
        }
        
        if (NewDevWiz->hfontTextBold ) {

            DeleteObject(NewDevWiz->hfontTextBold);
            NewDevWiz->hfontTextBold = NULL;
        }

        hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_GETICON, 0, 0);
        if (hicon) {

            DestroyIcon(hicon);
        }
        break;
    }

    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_INTRO;
            SetDriverDescription(hDlg, IDC_INTRO_DRVDESC, NewDevWiz);
            if (SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL)) {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
                if (hicon) {
                    DestroyIcon(hicon);
                }
            }

            //
            // We also need to set the title for the wizard since we are the first wizard
            // page.
            //
            PropSheet_SetTitle(GetParent(hDlg),
                               0,
                               (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) ?
                                MAKEINTRESOURCE(IDS_FOUNDDEVICE) :
                                MAKEINTRESOURCE(IDS_UPDATEDEVICE)
                               );

            break;

        case PSN_RESET:
            break;

        case PSN_WIZNEXT:
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

int CALLBACK
BrowseCallbackProc(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    switch (uMsg) {
        
    case BFFM_INITIALIZED:
        SendMessage(hwnd, BFFM_SETSELECTION, (WPARAM)TRUE, lpData);
        break;

    case BFFM_SELCHANGED: {
        TCHAR CurrentPath[MAX_PATH];

        if (lParam && 
            SHGetPathFromIDList((LPITEMIDLIST)lParam, CurrentPath) &&
            pSetupConcatenatePaths(CurrentPath, TEXT("*.INF"), MAX_PATH, NULL)) {

            SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)FileExists(CurrentPath, NULL));
        } else {
            //
            // We couldn't get the directory path from shell, or the directory
            // won't fit into our CurrentPath buffer, so gray out the OK 
            // button since the directory isn't valid.
            //
            SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)FALSE);
        }

        break;
    }

    default:
        break;
    }

    return 0;
}

VOID
DoBrowse(
    HWND hDlg
    )
{
    BROWSEINFO bi;
    TCHAR CurrentLocation[MAX_PATH];
    TCHAR Title[MAX_PATH];
    LPITEMIDLIST pidl;

    ZeroMemory(&bi, sizeof(bi));

    //
    // Get the current directory path in the location combo control to pass to
    // the browse API so it can use that as it's starting point.  If there is
    // too much text in the locaion combo then just pass in the empty string
    // as the starting point to the browse control.
    //
    if (GetWindowTextLength(GetWindow(hDlg, IDC_ADVANCED_LOCATION_COMBO)) < SIZECHARS(CurrentLocation)) {
        GetDlgItemText(hDlg, 
                       IDC_ADVANCED_LOCATION_COMBO, 
                       CurrentLocation,
                       SIZECHARS(CurrentLocation)
                       );
    } else {
        StringCchCopy(CurrentLocation, SIZECHARS(CurrentLocation), TEXT(""));
    }

    if (!LoadString(hNewDev, IDS_BROWSE_TITLE, Title, SIZECHARS(Title))) {
        
        Title[0] = TEXT('0');
    }

    bi.hwndOwner = hDlg;
    bi.pidlRoot = NULL;
    bi.pszDisplayName = NULL;
    bi.lpszTitle = Title;
    bi.ulFlags = BIF_NEWDIALOGSTYLE | 
                 BIF_RETURNONLYFSDIRS | 
                 BIF_RETURNFSANCESTORS | 
                 BIF_STATUSTEXT |
                 BIF_NONEWFOLDERBUTTON |
                 BIF_UAHINT;
    bi.lpfn = BrowseCallbackProc;
    bi.lParam = (LPARAM)CurrentLocation;

    pidl = SHBrowseForFolder(&bi);

    if (pidl && SHGetPathFromIDList(pidl, CurrentLocation)) {

        SetDlgItemText(hDlg,
                       IDC_ADVANCED_LOCATION_COMBO,
                       CurrentLocation
                       );
    }
}

INT_PTR
InitAdvancedSearchDlgProc(
    HWND hDlg
    )
{
    PTSTR *PathList;
    UINT  PathCount;
    INT   i;
    DWORD SearchOptions;

    //
    // Set the Initial radio button state to do auto-search.
    //
    CheckRadioButton(hDlg,
                     IDC_ADVANCED_SEARCH,
                     IDC_ADVANCED_LIST,
                     IDC_ADVANCED_SEARCH
                     );

    SearchOptions = GetSearchOptions();

    if ((SearchOptions & SEARCH_FLOPPY) ||
        (SearchOptions & SEARCH_CDROM)) {
    
        CheckDlgButton(hDlg, IDC_ADVANCED_REMOVABLEMEDIA, BST_CHECKED);
    }

    if (SearchOptions & SEARCH_DIRECTORY) {
    
        CheckDlgButton(hDlg, IDC_ADVANCED_LOCATION, BST_CHECKED);
    }

    //
    // Fill in the paths in the combo box
    //
    if (SetupQuerySourceList(0, &PathList, &PathCount)) {

        for (i=0; i<(int)PathCount; i++) {

            SendMessage(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO),
                        CB_ADDSTRING,
                        0,
                        (LPARAM)PathList[i]
                        );
        }

        SetupFreeSourceList(&PathList, PathCount);
    }

    //
    // Disable the search combo box and browse button by default.
    //
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO), (SearchOptions & SEARCH_DIRECTORY));
    EnableWindow(GetDlgItem(hDlg, IDC_BROWSE), (SearchOptions & SEARCH_DIRECTORY));

    //
    // Limit the text in the edit control to MAX_PATH characters, select
    // the first item and set up the autocomplet for directories.
    //
    SendMessage(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO), CB_LIMITTEXT, MAX_PATH, 0);
    SendMessage(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO), CB_SETCURSEL, 0, 0);
    SHAutoComplete(GetWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO), GW_CHILD), SHACF_FILESYS_DIRS);

    return TRUE;
}

INT_PTR CALLBACK 
AdvancedSearchDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    if (wMsg == WM_INITDIALOG) {
        
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        if (!InitAdvancedSearchDlgProc(hDlg)) {
            
            return FALSE;
        }

        return TRUE;
    }

    switch (wMsg)  {
       
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        
        case IDC_ADVANCED_SEARCH:
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_REMOVABLEMEDIA), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION), TRUE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO),
                         IsDlgButtonChecked(hDlg, IDC_ADVANCED_LOCATION));
            EnableWindow(GetDlgItem(hDlg, IDC_BROWSE),
                         IsDlgButtonChecked(hDlg, IDC_ADVANCED_LOCATION));
            break;

        case IDC_ADVANCED_LIST:
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_REMOVABLEMEDIA), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_BROWSE), FALSE);
            break;

        case IDC_ADVANCED_LOCATION:
            EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_LOCATION_COMBO),
                         IsDlgButtonChecked(hDlg, IDC_ADVANCED_LOCATION));
            EnableWindow(GetDlgItem(hDlg, IDC_BROWSE),
                         IsDlgButtonChecked(hDlg, IDC_ADVANCED_LOCATION));
            break;

        case IDC_BROWSE:
            if (HIWORD(wParam) == BN_CLICKED) {
                
                DoBrowse(hDlg);
            }
        }
        break;

    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_ADVANCEDSEARCH;
            if (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) {
                SetTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID, INSTALL_COMPLETE_CHECK_TIMEOUT, NULL);
            }
            break;

        case PSN_RESET:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;

        case PSN_WIZNEXT:
            NewDevWiz->EnterFrom = IDD_NEWDEVWIZ_ADVANCEDSEARCH;
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);

            if (IsDlgButtonChecked(hDlg, IDC_ADVANCED_SEARCH)) {
            
                NewDevWiz->SearchOptions = SEARCH_CURRENTDRIVER | 
                                           SEARCH_DEFAULT | 
                                           SEARCH_INET_IF_CONNECTED;
                
                if (IsDlgButtonChecked(hDlg, IDC_ADVANCED_REMOVABLEMEDIA)) {

                    NewDevWiz->SearchOptions |= (SEARCH_FLOPPY | SEARCH_CDROM);
                }

                if (IsDlgButtonChecked(hDlg, IDC_ADVANCED_LOCATION)) {

                    TCHAR TempPath[MAX_PATH];
                    TCHAR MessageTitle[MAX_PATH];
                    TCHAR MessageText[MAX_PATH*2];
                    BOOL bPathIsGood = TRUE;

                    if ((GetWindowTextLength(GetWindow(hDlg, IDC_ADVANCED_LOCATION_COMBO)) < SIZECHARS(NewDevWiz->BrowsePath)) &&
                        GetDlgItemText(hDlg, 
                                       IDC_ADVANCED_LOCATION_COMBO, 
                                       NewDevWiz->BrowsePath,
                                       SIZECHARS(NewDevWiz->BrowsePath)
                                       )) {
                    
                        //
                        // We have a path, now lets verify it. We will verify
                        // both the path, and verify that there is at least
                        // one INF file in that location. If either of these
                        // aren't true then we will display an warning to the
                        // user and remain on this page.
                        //
                        MessageTitle[0] = TEXT('\0');
                        MessageText[0] = TEXT('\0');
                        
                        if (SUCCEEDED(StringCchCopy(TempPath, SIZECHARS(TempPath), NewDevWiz->BrowsePath)) ||
                            pSetupConcatenatePaths(TempPath, TEXT("*.INF"), MAX_PATH, NULL)) {
                            //
                            // We will first check if the path exists at all. To do
                            // this we need to verify that FindFirstFile fails on
                            // the directory, and the directory with *.INF 
                            // concatonated on the end. The reason for this is that
                            // FindFirstFile does not handle root directory paths
                            // correctly for some reason so they need to be special
                            // cased.
                            //
                            if (!FileExists(NewDevWiz->BrowsePath, NULL) &&
                                !FileExists(TempPath, NULL)) {
    
                                LoadString(hNewDev,
                                           IDS_LOCATION_BAD_DIR,
                                           MessageText,
                                           SIZECHARS(MessageText));
                                    
                                bPathIsGood = FALSE;
    
                            } else if (!FileExists(TempPath, NULL)) {
    
                                LoadString(hNewDev,
                                           IDS_LOCATION_NO_INFS,
                                           MessageText,
                                           SIZECHARS(MessageText));
                                    
                                bPathIsGood = FALSE;
                            }
                        } else {
                            //
                            // The user entered too long of a path
                            //
                            LoadString(hNewDev,
                                       IDS_LOCATION_BAD_DIR,
                                       MessageText,
                                       SIZECHARS(MessageText));

                            bPathIsGood = FALSE;
                        }
                        
                        if (bPathIsGood) {
                        
                            SetupAddToSourceList(SRCLIST_SYSIFADMIN, NewDevWiz->BrowsePath);
                            
                            NewDevWiz->SearchOptions |= SEARCH_DIRECTORY;
                        
                        } else {

                            if (GetWindowText(GetParent(hDlg), 
                                              MessageTitle,
                                              SIZECHARS(MessageTitle)) &&
                                (MessageText[0] != TEXT('\0'))) {

                                MessageBox(hDlg, MessageText, MessageTitle, MB_OK | MB_ICONWARNING);
                                SetDlgMsgResult(hDlg, wMsg, -1);
                                break;
                            }
                        }
                    }
                }

                SetSearchOptions(NewDevWiz->SearchOptions);

                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SEARCHING);

            } else {

                ULONG DevNodeStatus;
                ULONG Problem=0;
                SP_DRVINFO_DATA DriverInfoData;

                //
                // If we have a selected driver,
                // or we know the class and there wasn't a problem installing
                // go into select device
                //
                //
                DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
                if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          SPDIT_COMPATDRIVER,
                                          0,
                                          &DriverInfoData
                                          )
                    ||
                    (!IsEqualGUID(&NewDevWiz->DeviceInfoData.ClassGuid,
                                  &GUID_NULL
                                  )

                     &&
                     CM_Get_DevNode_Status(&DevNodeStatus,
                                           &Problem,
                                           NewDevWiz->DeviceInfoData.DevInst,
                                           0
                                           ) == CR_SUCCESS
                     &&
                     Problem != CM_PROB_FAILED_INSTALL
                     )) {

                    NewDevWiz->ClassGuidSelected = &NewDevWiz->DeviceInfoData.ClassGuid;
                    NewDevWiz->EnterInto = IDD_NEWDEVWIZ_SELECTDEVICE;
                    SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SELECTDEVICE);
                    break;
                }

                NewDevWiz->ClassGuidSelected = NULL;
                NewDevWiz->EnterInto = IDD_NEWDEVWIZ_SELECTCLASS;
                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SELECTCLASS);
            }
            break;

        case PSN_WIZBACK:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_INTRO);
            break;
        }
        break;

    case WM_TIMER:
        if (INSTALL_COMPLETE_CHECK_TIMERID == wParam) {
            if (IsInstallComplete(NewDevWiz->hDeviceInfo, &NewDevWiz->DeviceInfoData)) {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\newdev\miscutil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       miscutil.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"

TCHAR szUnknownDevice[64];
TCHAR szUnknown[64];
HMODULE hSrClientDll;

typedef
BOOL
(*SRSETRESTOREPOINT)(
    PRESTOREPOINTINFO pRestorePtSpec,
    PSTATEMGRSTATUS pSMgrStatus
    );


PTCHAR
BuildFriendlyName(
    DEVINST DevInst,
    BOOL UseNewDeviceDesc,
    HMACHINE hMachine
    )
{
    PTCHAR FriendlyName;
    CONFIGRET ConfigRet = CR_FAILURE;
    ULONG cbSize = 0;
    TCHAR szBuffer[LINE_LEN];

    *szBuffer = TEXT('\0');

    //
    // Try the registry for NewDeviceDesc
    //
    if (UseNewDeviceDesc) {

        HKEY hKey;
        DWORD dwType = REG_SZ;

        ConfigRet = CM_Open_DevNode_Key(DevInst,
                                        KEY_READ,
                                        0,
                                        RegDisposition_OpenExisting,
                                        &hKey,
                                        CM_REGISTRY_HARDWARE
                                        );

        if (ConfigRet == CR_SUCCESS) {

            cbSize = sizeof(szBuffer);
            if (RegQueryValueEx(hKey,
                               REGSTR_VAL_NEW_DEVICE_DESC,
                               NULL,
                               &dwType,
                               (LPBYTE)szBuffer,
                               &cbSize
                               ) != ERROR_SUCCESS) {
                
                ConfigRet = CR_FAILURE;
            }

            RegCloseKey(hKey);
        }
    }

    if (ConfigRet != CR_SUCCESS) {
        //
        // Try the registry for FRIENDLYNAME
        //
        cbSize = sizeof(szBuffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                        CM_DRP_FRIENDLYNAME,
                                                        NULL,
                                                        szBuffer,
                                                        &cbSize,
                                                        0,
                                                        hMachine
                                                        );
    }

    if (ConfigRet != CR_SUCCESS) {
        //
        // Try the registry for DEVICEDESC
        //
        cbSize = sizeof(szBuffer);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DevInst,
                                                        CM_DRP_DEVICEDESC,
                                                        NULL,
                                                        szBuffer,
                                                        &cbSize,
                                                        0,
                                                        hMachine
                                                        );
    }

    if ((ConfigRet == CR_SUCCESS) && 
        *szBuffer &&
        (cbSize > 0)) {

        FriendlyName = LocalAlloc(LPTR, cbSize);

        if (FriendlyName) {

            StringCbCopy(FriendlyName, cbSize, szBuffer);
        }
    }
    else {

        FriendlyName = NULL;
    }

    return FriendlyName;
}

/* ----------------------------------------------------------------------
 * SetDlgText - Set Dialog Text Field
 *
 * Concatenates a number of string resources and does a SetWindowText()
 * for a dialog text control.
 *
 * Parameters:
 *
 *      hDlg         - Dialog handle
 *      iControl     - Dialog control ID to receive text
 *      nStartString - ID of first string resource to concatenate
 *      nEndString   - ID of last string resource to concatenate
 *
 *      Note: the string IDs must be consecutive.
 */

void
SetDlgText(HWND hDlg, int iControl, int nStartString, int nEndString)
{
    int     iX;
    TCHAR   szText[SDT_MAX_TEXT];

    szText[0] = '\0';

    for (iX = nStartString; iX<= nEndString; iX++) {

        LoadString(hNewDev,
                    iX,
                    szText + lstrlen(szText),
                    SIZECHARS(szText) - lstrlen(szText)
                    );
    }

    if (iControl) {

        SetDlgItemText(hDlg, iControl, szText);

    } else {

        SetWindowText(hDlg, szText);
    }
}


void
LoadText(PTCHAR szText, int SizeText, int nStartString, int nEndString)
{
    int     iX;

    for (iX = nStartString; iX<= nEndString; iX++) {

        LoadString(hNewDev,
                    iX,
                    szText + lstrlen(szText),
                    SizeText - lstrlen(szText)
                    );
    }

    return;
}

VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hChildWnd;

    hChildWnd = GetWindow(hWnd, GW_CHILD);

    while (hChildWnd != NULL) {

        SendMessage(hChildWnd, WM_SYSCOLORCHANGE, wParam, lParam);
        hChildWnd = GetWindow(hChildWnd, GW_HWNDNEXT);
    }
}

BOOL
NoPrivilegeWarning(
   HWND hWnd
   )
/*++

    This function checks to see if the user has Administrator privileges.

    If the user does NOT have this administrator privilege then a warning is displayed telling
    them that they have insufficient privileges to install hardware on this machine.

Arguments

    hWnd - Parent window handle

Return Value:
    TRUE if the user does NOT have Administrator privileges and
    FALSE if the user does have this privilege

--*/
{
   TCHAR szMsg[MAX_PATH];
   TCHAR szCaption[MAX_PATH];

   if (!pSetupIsUserAdmin()) {

       if (LoadString(hNewDev,
                      IDS_NDW_NOTADMIN,
                      szMsg,
                      SIZECHARS(szMsg))
          &&
           LoadString(hNewDev,
                      IDS_NEWDEVICENAME,
                      szCaption,
                      SIZECHARS(szCaption)))
        {
            MessageBox(hWnd, szMsg, szCaption, MB_OK | MB_ICONEXCLAMATION);
        }

       return TRUE;
    }

   return FALSE;
}

LONG
NdwBuildClassInfoList(
    PNEWDEVWIZ NewDevWiz,
    DWORD ClassListFlags
    )
{
    LONG Error;

    //
    // Build the class info list
    //
    while (!SetupDiBuildClassInfoList(ClassListFlags,
                                      NewDevWiz->ClassGuidList,
                                      NewDevWiz->ClassGuidSize,
                                      &NewDevWiz->ClassGuidNum
                                      ))
    {
        Error = GetLastError();

        if (NewDevWiz->ClassGuidList) {

            LocalFree(NewDevWiz->ClassGuidList);
            NewDevWiz->ClassGuidList = NULL;
        }

        if (Error == ERROR_INSUFFICIENT_BUFFER &&
            NewDevWiz->ClassGuidNum > NewDevWiz->ClassGuidSize)
        {
            NewDevWiz->ClassGuidList = LocalAlloc(LPTR, NewDevWiz->ClassGuidNum*sizeof(GUID));

            if (!NewDevWiz->ClassGuidList) {

                NewDevWiz->ClassGuidSize = 0;
                NewDevWiz->ClassGuidNum = 0;
                return ERROR_NOT_ENOUGH_MEMORY;
            }

            NewDevWiz->ClassGuidSize = NewDevWiz->ClassGuidNum;

        } else {

            if (NewDevWiz->ClassGuidList) {

                LocalFree(NewDevWiz->ClassGuidList);
            }

            NewDevWiz->ClassGuidSize = 0;
            NewDevWiz->ClassGuidNum = 0;
            NewDevWiz->ClassGuidList = NULL;
            return Error;
        }
    }

    return ERROR_SUCCESS;
}

void
HideWindowByMove(
    HWND hDlg
    )
{
    RECT rect;

    //
    // Move the window offscreen, using the virtual coords for Upper Left Corner
    //
    GetWindowRect(hDlg, &rect);
    MoveWindow(hDlg,
               GetSystemMetrics(SM_XVIRTUALSCREEN),
               GetSystemMetrics(SM_YVIRTUALSCREEN) - (rect.bottom - rect.top),
               rect.right - rect.left,
               rect.bottom - rect.top,
               TRUE
               );
}

LONG
NdwUnhandledExceptionFilter(
    struct _EXCEPTION_POINTERS *ExceptionPointers
    )
{
    LONG lRet;
    BOOL BeingDebugged;

    lRet = UnhandledExceptionFilter(ExceptionPointers);

    BeingDebugged = IsDebuggerPresent();

    //
    // Normal code path is to handle the exception.
    // However, if a debugger is present, and the system's unhandled
    // exception filter returns continue search, we let it go
    // thru to allow the debugger a chance at it.
    //
    if (lRet == EXCEPTION_CONTINUE_SEARCH && !BeingDebugged) {
        lRet = EXCEPTION_EXECUTE_HANDLER;
    }

    return lRet;
}

BOOL
SetClassGuid(
    HDEVINFO hDeviceInfo,
    PSP_DEVINFO_DATA DeviceInfoData,
    LPGUID ClassGuid
    )
{
    TCHAR ClassGuidString[MAX_GUID_STRING_LEN];

    pSetupStringFromGuid(ClassGuid,
                         ClassGuidString,
                         SIZECHARS(ClassGuidString)
                         );

    return SetupDiSetDeviceRegistryProperty(hDeviceInfo,
                                            DeviceInfoData,
                                            SPDRP_CLASSGUID,
                                            (LPBYTE)ClassGuidString,
                                            sizeof(ClassGuidString)
                                            );
}

HPROPSHEETPAGE
CreateWizExtPage(
   int PageResourceId,
   DLGPROC pfnDlgProc,
   PNEWDEVWIZ NewDevWiz
   )
{
    PROPSHEETPAGE    psp;

    memset(&psp, 0, sizeof(psp));
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = hNewDev;
    psp.lParam = (LPARAM)NewDevWiz;
    psp.pszTemplate = MAKEINTRESOURCE(PageResourceId);
    psp.pfnDlgProc = pfnDlgProc;

    return CreatePropertySheetPage(&psp);
}

BOOL
AddClassWizExtPages(
   HWND hwndParentDlg,
   PNEWDEVWIZ NewDevWiz,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData,
   DI_FUNCTION InstallFunction,
   HPROPSHEETPAGE hIntroPage
   )
{
    DWORD NumPages;
    BOOL bRet = FALSE;

    memset(DeviceWizardData, 0, sizeof(SP_NEWDEVICEWIZARD_DATA));
    DeviceWizardData->ClassInstallHeader.InstallFunction = InstallFunction;
    DeviceWizardData->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    DeviceWizardData->hwndWizardDlg = hwndParentDlg;

    if (SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     &DeviceWizardData->ClassInstallHeader,
                                     sizeof(SP_NEWDEVICEWIZARD_DATA)
                                     )
        &&

        (SetupDiCallClassInstaller(InstallFunction,
                                  NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData
                                  )

            ||

            (ERROR_DI_DO_DEFAULT == GetLastError()))

        &&
        SetupDiGetClassInstallParams(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     &DeviceWizardData->ClassInstallHeader,
                                     sizeof(SP_NEWDEVICEWIZARD_DATA),
                                     NULL
                                     )
        &&
        DeviceWizardData->NumDynamicPages)
    {
        //
        // If this is not a non interactive install and we were given a intro
        // page then add it first.
        //
        PropSheet_AddPage(hwndParentDlg, hIntroPage);
        
        for (NumPages = 0; NumPages < DeviceWizardData->NumDynamicPages; NumPages++) {

            //
            // If this is a non interactive install then we will destory the property
            // sheet pages since we can't display them, otherwise we will add them
            // to the wizard.
            //
            if (pSetupGetGlobalFlags() & PSPGF_NONINTERACTIVE) {

                DestroyPropertySheetPage(DeviceWizardData->DynamicPages[NumPages]);

            } else {

                PropSheet_AddPage(hwndParentDlg, DeviceWizardData->DynamicPages[NumPages]);
            }
        }

        //
        // If class/co-installers said they had pages to display then we always return TRUE,
        // regardless of if we actually added those pages to the wizard or not.
        //
        bRet = TRUE;
    }

    //
    // Clear the class install parameters.
    //
    SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 NULL,
                                 0
                                 );

    return bRet;
}

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName, &findData);

    if(FindHandle == INVALID_HANDLE_VALUE) {

        Error = GetLastError();

    } else {

        FindClose(FindHandle);

        if(FindData) {

            *FindData = findData;
        }

        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

BOOL
pVerifyUpdateDriverInfoPath(
    PNEWDEVWIZ NewDevWiz
    )

/*++

    This API will verify that the selected driver node lives in the path
    specified in UpdateDriverInfo->InfPathName.

Return Value:
    This API will return TRUE in all cases except where we have a valid
    UpdateDriverInfo structure and a valid InfPathName field and that
    path does not match the path where the selected driver lives.

--*/

{
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;

    //
    // If we don't have a UpdateDriverInfo structure or a valid InfPathName field
    // in that structure then just return TRUE now.
    //
    if (!NewDevWiz->UpdateDriverInfo || !NewDevWiz->UpdateDriverInfo->InfPathName) {

        return TRUE;
    }

    //
    // Get the selected driver's path
    //
    ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 )) {
        //
        // There is no selected driver so just return TRUE
        //
        return TRUE;
    }

    DriverInfoDetailData.cbSize = sizeof(DriverInfoDetailData);
    if (!SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                    &NewDevWiz->DeviceInfoData,
                                    &DriverInfoData,
                                    &DriverInfoDetailData,
                                    sizeof(DriverInfoDetailData),
                                    NULL
                                    )
        &&
        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {

        //
        // We should never hit this case, but if we have a selected driver and
        // we can't get the SP_DRVINFO_DETAIL_DATA that contains the InfFileName
        // the return FALSE.              
        //
        return FALSE;
    }

    if (lstrlen(NewDevWiz->UpdateDriverInfo->InfPathName) ==
        lstrlen(DriverInfoDetailData.InfFileName)) {

        //
        // If the two paths are the same size then we will just compare them
        //
        return (!lstrcmpi(NewDevWiz->UpdateDriverInfo->InfPathName,
                          DriverInfoDetailData.InfFileName));

    } else {

        //
        // The two paths are different lengths so we'll tack a trailing backslash
        // onto the UpdateDriverInfo->InfPathName and then do a _tcsnicmp
        // NOTE that we only tack on a trailing backslash if the length of the
        // path is greater than two since it isn't needed on the driver letter
        // followed by a colon case (A:).
        //
        // The reason we do this is we don't want the following case to match
        // c:\winnt\in
        // c:\winnt\inf\foo.inf
        //
        TCHAR TempPath[MAX_PATH];

        if (FAILED(StringCchCopy(TempPath, SIZECHARS(TempPath), NewDevWiz->UpdateDriverInfo->InfPathName))) {
            //
            // If we were passed in a path greater than MAX_PATH then just return FALSE.
            //
            return FALSE;
        }

        if (lstrlen(NewDevWiz->UpdateDriverInfo->InfPathName) > 2) {

            if (FAILED(StringCchCat(TempPath, SIZECHARS(TempPath), TEXT("\\")))) {
                //
                // If we were passed in a path of MAX_PATH size and we can't add a 
                // backslash on the end, then just return FALSE.
                //
                return FALSE;
            }
        }

        return (!_tcsnicmp(TempPath,
                           DriverInfoDetailData.InfFileName,
                           lstrlen(TempPath)));
    }
}

BOOL
RemoveDir(
    PTSTR Path
    )
/*++

Routine Description:

    This routine recursively deletes the specified directory and all the
    files in it.


Arguments:

    Path - Path to remove.

Return Value:

    TRUE - if the directory was sucessfully deleted.
    FALSE - if the directory was not successfully deleted.

--*/
{
    WIN32_FIND_DATA FindFileData;
    HANDLE          hFind;
    BOOL            bFind = TRUE;
    BOOL            Ret = TRUE;
    TCHAR           szTemp[MAX_PATH];
    TCHAR           FindPath[MAX_PATH];
    DWORD           dwAttributes;

    if (FAILED(StringCchCopy(FindPath, SIZECHARS(FindPath), Path))) {
        //
        // If the specified Path does not fit in our local buffer then
        // fail now, since we don't want to delete a partial path!
        //
        return FALSE;
    }
    
    //
    //If this is a directory then tack on *.* to the end of the path
    //
    dwAttributes = GetFileAttributes(Path);
    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        if (!pSetupConcatenatePaths(FindPath,TEXT("*.*"),MAX_PATH,NULL)) {
            // 
            // We can't tack *.* onto the end so bail out now, otherwise
            // we won't be deleting what we think we should be deleting.
            //
            return FALSE;
        }
    }

    hFind = FindFirstFile(FindPath, &FindFileData);

    while ((hFind != INVALID_HANDLE_VALUE) && (bFind == TRUE)) {
        //
        // Only process the directory, or delete the file, if we can
        // fit the path and filename in our buffer, otherwise we could
        // delete some other file!
        //
        if (SUCCEEDED(StringCchCopy(szTemp, SIZECHARS(szTemp), Path)) &&
            pSetupConcatenatePaths(szTemp,FindFileData.cFileName,SIZECHARS(szTemp),NULL)) {
            
            if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
                //
                // Handle the reparse point case.
                //
                HANDLE hReparsePoint = INVALID_HANDLE_VALUE;
                
                hReparsePoint = CreateFile(szTemp,
                                           DELETE,
                                           FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                                           NULL,
                                           OPEN_EXISTING,
                                           FILE_FLAG_DELETE_ON_CLOSE | FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT,
                                           NULL
                                           );
                
                 if (hReparsePoint != INVALID_HANDLE_VALUE) {
                      CloseHandle(hReparsePoint);
                 }

            } else if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                //
                // Handle the directory case.
                // 
                // NOTE: Do not follow the . or .. directories or we will be 
                // spinning forever.
                //
                if ((lstrcmp(FindFileData.cFileName, TEXT(".")) != 0) &&
                    (lstrcmp(FindFileData.cFileName, TEXT("..")) != 0)) {
    
                    if (!RemoveDir(szTemp)) {
        
                        Ret = FALSE;
                    }
        
                    RemoveDirectory(szTemp);
                }
            } else {
                //
                // Handle the file case.
                // Make sure to clear off any hidden, read-only, or system
                // attributes off of the file.
                //
                SetFileAttributes(szTemp, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(szTemp);
            }
        }

        bFind = FindNextFile(hFind, &FindFileData);
    }

    FindClose(hFind);

    //
    //Remove the root directory
    //
    dwAttributes = GetFileAttributes(Path);
    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY) {

        if (!RemoveDirectory(Path)) {

            Ret = FALSE;
        }
    }

    return Ret;
}

BOOL
pAToI(
    IN  PCTSTR      Field,
    OUT PINT        IntegerValue
    )

/*++

Routine Description:

Arguments:

Return Value:

Remarks:

    Hexadecimal numbers are also supported.  They must be prefixed by '0x' or '0X', with no
    space allowed between the prefix and the number.

--*/

{
    INT Value;
    UINT c;
    BOOL Neg;
    UINT Base;
    UINT NextDigitValue;
    INT OverflowCheck;
    BOOL b;

    if(!Field) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if(*Field == TEXT('-')) {
        Neg = TRUE;
        Field++;
    } else {
        Neg = FALSE;
        if(*Field == TEXT('+')) {
            Field++;
        }
    }

    if ((*Field == TEXT('0')) &&
        ((*(Field+1) == TEXT('x')) || (*(Field+1) == TEXT('X')))) {
        //
        // The number is in hexadecimal.
        //
        Base = 16;
        Field += 2;
    } else {
        //
        // The number is in decimal.
        //
        Base = 10;
    }

    for(OverflowCheck = Value = 0; *Field; Field++) {

        c = (UINT)*Field;

        if((c >= (UINT)'0') && (c <= (UINT)'9')) {
            NextDigitValue = c - (UINT)'0';
        } else if(Base == 16) {
            if((c >= (UINT)'a') && (c <= (UINT)'f')) {
                NextDigitValue = (c - (UINT)'a') + 10;
            } else if ((c >= (UINT)'A') && (c <= (UINT)'F')) {
                NextDigitValue = (c - (UINT)'A') + 10;
            } else {
                break;
            }
        } else {
            break;
        }

        Value *= Base;
        Value += NextDigitValue;

        //
        // Check for overflow.  For decimal numbers, we check to see whether the
        // new value has overflowed into the sign bit (i.e., is less than the
        // previous value.  For hexadecimal numbers, we check to make sure we
        // haven't gotten more digits than will fit in a DWORD.
        //
        if(Base == 16) {
            if(++OverflowCheck > (sizeof(INT) * 2)) {
                break;
            }
        } else {
            if(Value < OverflowCheck) {
                break;
            } else {
                OverflowCheck = Value;
            }
        }
    }

    if(*Field) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }

    if(Neg) {
        Value = 0-Value;
    }
    b = TRUE;
    try {
        *IntegerValue = Value;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return(b);
}

void
RemoveCdmDirectory(
    PTSTR CdmDirectory
    )
{
    TCHAR ReinstallBackupDirectory[MAX_PATH];

    //
    // First verify that this directory is a subdirectory of %windir%\system32\ReinstallBackups
    //
    if (GetSystemDirectory(ReinstallBackupDirectory, SIZECHARS(ReinstallBackupDirectory)) &&
        pSetupConcatenatePaths(ReinstallBackupDirectory, TEXT("ReinstallBackups"), SIZECHARS(ReinstallBackupDirectory), NULL)) {

        do {

            PTSTR p = _tcsrchr(CdmDirectory, TEXT('\\'));

            if (!p) {

                break;
            }

            *p = 0;

            if (_tcsnicmp(CdmDirectory,
                          ReinstallBackupDirectory,
                          lstrlen(ReinstallBackupDirectory))) {

                //
                // This is not a subdirectory of the ReinstallBackups directory, so don't
                // delete it!
                //
                break;
            }

            if (!lstrcmpi(CdmDirectory,
                          ReinstallBackupDirectory)) {

                //
                // We have reached the actuall ReinstallBackups directory so stop deleting!
                //
                break;
            }

        } while (RemoveDir(CdmDirectory));
    }
}

BOOL
pSetupGetDriverDate(
    IN     PCTSTR     DriverVer,
    IN OUT PFILETIME  pFileTime
    )

/*++

Routine Description:

    Retreive the date from a DriverVer string.

    The Date specified in DriverVer string has the following format:

    DriverVer=xx/yy/zzzz

        or

    DriverVer=xx-yy-zzzz

    where xx is the month, yy is the day, and zzzz is the for digit year.
    Note that the year MUST be 4 digits.  A year of 98 will be considered
    0098 and not 1998!

    This date should be the date of the Drivers and not for the INF itself.
    So a single INF can have multiple driver install Sections and each can
    have different dates depending on when the driver was last updated.

Arguments:

    DriverVer - String that holds the DriverVer entry from an INF file.

    pFileTime - points to a FILETIME structure that will receive the Date,
        if it exists.

Return Value:

    BOOL. TRUE if a valid date existed in the specified string and FALSE otherwise.

--*/

{
    SYSTEMTIME SystemTime;
    TCHAR DriverDate[LINE_LEN];
    PTSTR Convert, Temp;
    DWORD Value;

    if (!DriverVer) {

        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    try {

        *DriverDate = 0;
        ZeroMemory(&SystemTime, sizeof(SystemTime));
        pFileTime->dwLowDateTime = 0;
        pFileTime->dwHighDateTime = 0;

        //
        // First copy just the DriverDate portion of the DriverVer into the DriverDate
        // variable.  The DriverDate should be everything before the first comma.
        // If this can't fit, then someone put bad data into their INF, so just treat
        // the driver date as 0/0/0000 and the time as 0.
        //
        if (SUCCEEDED(StringCchCopy(DriverDate, SIZECHARS(DriverDate), DriverVer))) {
    
            Temp = DriverDate;
    
            while (*Temp && (*Temp != TEXT(','))) {
    
                Temp++;
            }
    
            if (*Temp) {
                *Temp = TEXT('\0');
            }
    
            Convert = DriverDate;
    
            if (*Convert) {
    
                Temp = DriverDate;
                while (*Temp && (*Temp != TEXT('-')) && (*Temp != TEXT('/')))
                    Temp++;
    
                if (*Temp == TEXT('\0')) {
                    //
                    // There is no day or year in this date, so exit.
                    //
                    goto clean0;
                }

                *Temp = 0;
    
                //
                //Convert the month
                //
                pAToI(Convert, (PINT)&Value);
                SystemTime.wMonth = LOWORD(Value);
    
                Convert = Temp+1;
    
                if (*Convert) {
    
                    Temp = Convert;
                    while (*Temp && (*Temp != TEXT('-')) && (*Temp != TEXT('/')))
                        Temp++;
    
                    if (*Temp == TEXT('\0')) {
                        //
                        // There is no year in this date, so exit.
                        //
                        goto clean0;
                    }

                    *Temp = 0;
    
                    //
                    //Convert the day
                    //
                    pAToI(Convert, (PINT)&Value);
                    SystemTime.wDay = LOWORD(Value);
    
                    Convert = Temp+1;
    
                    if (*Convert) {
    
                        //
                        //Convert the year
                        //
                        pAToI(Convert, (PINT)&Value);
                        SystemTime.wYear = LOWORD(Value);
    
                        //
                        //Convert SYSTEMTIME into FILETIME
                        //
                        SystemTimeToFileTime(&SystemTime, pFileTime);
                    }
                }
            }
        }

clean0:;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    SetLastError(NO_ERROR);
    return((pFileTime->dwLowDateTime != 0) || (pFileTime->dwHighDateTime != 0));
}

BOOL
IsInternetAvailable(
    HMODULE *hCdmInstance
    )
{
    CDM_INTERNET_AVAILABLE_PROC pfnCDMInternetAvailable;

    if (!hCdmInstance) {
        return FALSE;
    }

    //
    // We can't call CDM during GUI setup.
    //
    if (GuiSetupInProgress) {
        return FALSE;
    }

    //
    // Load CDM.DLL if it is not already loaded
    //
    if (!(*hCdmInstance)) {

        *hCdmInstance = LoadLibrary(TEXT("CDM.DLL"));
    }

    if (!(*hCdmInstance)) {
        return FALSE;
    }

    pfnCDMInternetAvailable = (CDM_INTERNET_AVAILABLE_PROC)GetProcAddress(*hCdmInstance,
                                                                          "DownloadIsInternetAvailable"
                                                                           );

    if (!pfnCDMInternetAvailable) {
        return FALSE;
    }

    return pfnCDMInternetAvailable();
}

BOOL
GetLogPnPIdPolicy(
    )
/*++

Routine Description:

    This function checks the policy portion of the registry to see if the user wants
    us to log the Hardware Id for devices that we cannot find drivers for.

Arguments:

    none

Return Value:

    BOOL - TRUE if we can log the Hardware Id and FALSE if the policy tells us not
    to log the hardware Id.

--*/
{
    HKEY hKey;
    DWORD LogPnPIdPolicy;
    ULONG cbData;
    BOOL bLogHardwareIds = TRUE;

    //
    // If we are in gui-setup then we can't log hardware Ids, so always return
    // FALSE.
    //
    if (GuiSetupInProgress) {
        return FALSE;
    }

    if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                     TEXT("Software\\Policies\\Microsoft\\Windows\\DriverSearching"),
                     0,
                     KEY_READ,
                     &hKey
                     ) == ERROR_SUCCESS) {

        LogPnPIdPolicy = 0;
        cbData = sizeof(LogPnPIdPolicy);
        if ((RegQueryValueEx(hKey,
                             TEXT("DontLogHardwareIds"),
                             NULL,
                             NULL,
                             (LPBYTE)&LogPnPIdPolicy,
                             &cbData
                             ) == ERROR_SUCCESS) &&
            (LogPnPIdPolicy)) {

            bLogHardwareIds = FALSE;
        }

        RegCloseKey(hKey);
    }

    return (bLogHardwareIds);
}

void
CdmLogDriverNotFound(
    HMODULE hCdmInstance,
    HANDLE  hContext,
    LPCTSTR DeviceInstanceId,
    DWORD   Flags
    )
{
    LOG_DRIVER_NOT_FOUND_PROC pfnLogDriverNotFound;

    if (!hCdmInstance) {
        return;
    }

    pfnLogDriverNotFound = (LOG_DRIVER_NOT_FOUND_PROC)GetProcAddress(hCdmInstance,
                                                                     "LogDriverNotFound"
                                                                     );

    if (!pfnLogDriverNotFound) {
        return;
    }

    pfnLogDriverNotFound(hContext, DeviceInstanceId, Flags);
}

void
CdmCancelCDMOperation(
    HMODULE hCdmInstance
    )
{
    CANCEL_CDM_OPERATION_PROC pfnCancelCDMOperation;

    if (!hCdmInstance) {
        return;
    }

    pfnCancelCDMOperation = (CANCEL_CDM_OPERATION_PROC)GetProcAddress(hCdmInstance,
                                                                      "CancelCDMOperation"
                                                                      );

    if (!pfnCancelCDMOperation) {
        return;
    }

    pfnCancelCDMOperation();
}

BOOL
GetInstalledInf(
    IN     DEVNODE DevNode,           OPTIONAL
    IN     PTSTR   DeviceInstanceId,  OPTIONAL
    IN OUT PTSTR   InfFile,
    IN OUT DWORD   *Size
    )
{
    DEVNODE dn;
    HKEY hKey = INVALID_HANDLE_VALUE;
    DWORD dwType;
    BOOL bSuccess = FALSE;

    if (DevNode != 0) {

        dn = DevNode;

    } else  if (CM_Locate_DevNode(&dn, DeviceInstanceId, 0) != CR_SUCCESS) {

        goto clean0;
    }

    //
    // Open the device's driver (software) registry key so we can get the InfPath
    //
    if (CM_Open_DevNode_Key(dn,
                            KEY_READ,
                            0,
                            RegDisposition_OpenExisting,
                            &hKey,
                            CM_REGISTRY_SOFTWARE
                            ) != CR_SUCCESS) {

        goto clean0;
    }

    if (hKey != INVALID_HANDLE_VALUE) {

        dwType = REG_SZ;

        if (RegQueryValueEx(hKey,
                            REGSTR_VAL_INFPATH,
                            NULL,
                            &dwType,
                            (LPBYTE)InfFile,
                            Size
                            ) == ERROR_SUCCESS) {

            bSuccess = TRUE;
        }
    }

clean0:

    if (hKey != INVALID_HANDLE_VALUE) {

        RegCloseKey(hKey);
    }

    return bSuccess;
}

BOOL
IsInfFromOem(
    IN  PCTSTR                InfFile
    )

/*++

Routine Description:

    Determine if an Inf is an OEM Inf.

Arguments:

    InfFile - supplies name of Inf file.

Return Value:

    BOOL. TRUE if the InfFile is an OEM Inf file, and FALSE otherwise.

--*/

{
    PTSTR p;

    //
    // Make sure we are passed a valid Inf file and it's length is at least 8
    // chararacters or more for oemX.inf
    if (!InfFile ||
        (InfFile[0] == TEXT('\0')) ||
        (lstrlen(InfFile) < 8)) {

        return FALSE;
    }

    //
    // First check that the first 3 characters are OEM
    //
    if (_tcsnicmp(InfFile, TEXT("oem"), 3)) {

        return FALSE;
    }

    //
    // Next verify that any characters after "oem" and before ".inf"
    // are digits.
    //
    p = (PTSTR)InfFile;
    p = CharNext(p);
    p = CharNext(p);
    p = CharNext(p);

    while ((*p != TEXT('\0')) && (*p != TEXT('.'))) {

        if ((*p < TEXT('0')) || (*p > TEXT('9'))) {

            return FALSE;
        }

        p = CharNext(p);
    }

    //
    // Finally, verify that the last 4 characters are ".inf"
    //
    if (_wcsicmp(p, TEXT(".inf"))) {

        return FALSE;
    }

    //
    // This is an OEM Inf file
    //
    return TRUE;
}

BOOL
IsConnectedToInternet()
{
    DWORD dwFlags = INTERNET_CONNECTION_LAN | 
                    INTERNET_CONNECTION_MODEM |
                    INTERNET_CONNECTION_PROXY;

    //
    // If we are in gui-setup then return FALSE since we can't connect to the 
    // Internet at this time, and since the network is not fully installed yet
    // bad things can happen when we call Inet APIs.
    //
    if (GuiSetupInProgress) {
        return FALSE;
    }

    return InternetGetConnectedState(&dwFlags, 0);
}

DWORD
GetSearchOptions(
    void
    )
{
    DWORD SearchOptions = SEARCH_FLOPPY;
    DWORD cbData;
    HKEY hKeyDeviceInstaller;

    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     REGSTR_PATH_DEVICEINSTALLER,
                     0,
                     KEY_READ,
                     &hKeyDeviceInstaller
                     ) == ERROR_SUCCESS) {

        cbData = sizeof(SearchOptions);

        if (RegQueryValueEx(hKeyDeviceInstaller,
                            REGSTR_VAL_SEARCHOPTIONS,
                            NULL,
                            NULL,
                            (LPBYTE)&SearchOptions,
                            &cbData
                            ) != ERROR_SUCCESS) {

            SearchOptions = SEARCH_FLOPPY;
        }

        RegCloseKey(hKeyDeviceInstaller);
    }

    return SearchOptions;
}

VOID
SetSearchOptions(
    DWORD SearchOptions
    )
{
    HKEY hKeyDeviceInstaller;

    if (RegCreateKeyEx(HKEY_CURRENT_USER,
                       REGSTR_PATH_DEVICEINSTALLER,
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_WRITE,
                       NULL,
                       &hKeyDeviceInstaller,
                       NULL) == ERROR_SUCCESS) {

        RegSetValueEx(hKeyDeviceInstaller,
                      REGSTR_VAL_SEARCHOPTIONS,
                      0,
                      REG_DWORD,
                      (LPBYTE)&SearchOptions,
                      sizeof(SearchOptions)
                      );

        RegCloseKey(hKeyDeviceInstaller);
    }
}

BOOL
IsInstallComplete(
    HDEVINFO         hDevInfo,
    PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine determines whether the install is complete on the specified
    device or not. If a device has configflags and CONFIGFLAG_REINSTALL and
    CONFIGFLAG_FINISH_INSTALL are not set then the install is considered
    complete.
    
    This API is needed since we could bring up the Found New Hardware wizard
    for one user and another user can switch away to their session. Umpnpmgr.dll
    will prompt the new user to install drivers as well.  If the new user does
    complete the device install then we want the first user's Found New
    Hardware wizard to go away as well.

Arguments:

    hDevInfo -
    
    DeviceInfoData - 

Return Value:

    BOOL. TRUE if the installation is complete and FALSE otherwise.

--*/
{
    BOOL bDriverInstalled = FALSE;
    DWORD ConfigFlags = 0;

    if (SetupDiGetDeviceRegistryProperty(hDevInfo,
                                         DeviceInfoData,
                                         SPDRP_CONFIGFLAGS,
                                         NULL,
                                         (PBYTE)&ConfigFlags,
                                         sizeof(ConfigFlags),
                                         NULL) &&
        !(ConfigFlags & CONFIGFLAG_REINSTALL) &&
        !(ConfigFlags & CONFIGFLAG_FINISH_INSTALL)) {

        bDriverInstalled = TRUE;
    }

    return bDriverInstalled;
}

BOOL
GetIsWow64 (
    VOID
    )
/*++

Routine Description:

    Determine if we're running on WOW64 or not.  This will tell us if somebody
    is calling the 32-bit version of newdev.dll on a 64-bit machine.
    
    We call the GetSystemWow64Directory API, and if it fails and GetLastError()
    returns ERROR_CALL_NOT_IMPLENETED then this means we are on a 32-bit OS.

Arguments:

    none

Return value:

    TRUE if running under WOw64 (and special Wow64 features available)

--*/
{
#ifdef _WIN64
    //
    // If this is the 64-bit version of newdev.dll then always return FALSE.
    //
    return FALSE;

#else
    TCHAR Wow64Directory[MAX_PATH];

    if ((GetSystemWow64Directory(Wow64Directory, SIZECHARS(Wow64Directory)) == 0) &&
        (GetLastError() == ERROR_CALL_NOT_IMPLEMENTED)) {
        return FALSE;
    }
    
    //
    // GetSystemWow64Directory succeeded so we are on a 64-bit OS.
    //
    return TRUE;
#endif
}

BOOL
OpenCdmContextIfNeeded(
    HMODULE *hCdmInstance,
    HANDLE *hCdmContext
    )
{
    OPEN_CDM_CONTEXT_EX_PROC pfnOpenCDMContextEx;

    //
    // We can't load CDM if we are in the gui-setup.
    //
    if (GuiSetupInProgress) {
        return FALSE;
    }

    //
    // First check to see if they are already loaded
    //
    if (*hCdmInstance && *hCdmContext) {
        return TRUE;
    }

    //
    // Load CDM.DLL if it is not already loaded
    //
    if (!(*hCdmInstance)) {
        
        *hCdmInstance = LoadLibrary(TEXT("CDM.DLL"));
    }

    if (*hCdmInstance) {
        //
        // Get a context handle to Cdm.dll by calling OpenCDMContextEx(FALSE).  
        // By passing FALSE we are telling CDM.DLL to not connect to the Internet
        // if there isn't currently a connection.
        //
        if (!(*hCdmContext)) {
            pfnOpenCDMContextEx = (OPEN_CDM_CONTEXT_EX_PROC)GetProcAddress(*hCdmInstance,
                                                                           "OpenCDMContextEx"
                                                                           );
        
            if (pfnOpenCDMContextEx) {
                *hCdmContext = pfnOpenCDMContextEx(FALSE);
            }
        }
    }

    if (*hCdmInstance && *hCdmContext) {
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
pSetSystemRestorePoint(
    BOOL Begin,
    BOOL CancelOperation,
    int RestorePointResourceId
    )
{
    RESTOREPOINTINFO RestorePointInfo;
    STATEMGRSTATUS SMgrStatus;
    SRSETRESTOREPOINT pfnSrSetRestorePoint;    
    BOOL b = FALSE;
    
    if (!hSrClientDll) {

        hSrClientDll = LoadLibrary(TEXT("SRCLIENT.DLL"));

        if (!hSrClientDll) {
            return FALSE;
        }
    }

    pfnSrSetRestorePoint = (SRSETRESTOREPOINT)GetProcAddress(hSrClientDll,
                                                             "SRSetRestorePointW"
                                                             );

    //
    // If we can't get the proc address for SRSetRestorePoint then just
    // free the library.
    //
    if (!pfnSrSetRestorePoint) {
        FreeLibrary(hSrClientDll);
        hSrClientDll = FALSE;
        return FALSE;
    }

    //
    // Set the system restore point.
    //
    RestorePointInfo.dwEventType = Begin 
        ? BEGIN_NESTED_SYSTEM_CHANGE
        : END_NESTED_SYSTEM_CHANGE;
    RestorePointInfo.dwRestorePtType = CancelOperation 
        ? CANCELLED_OPERATION
        : DEVICE_DRIVER_INSTALL;
    RestorePointInfo.llSequenceNumber = 0;

    if (RestorePointResourceId) {
        if (!LoadString(hNewDev,
                        RestorePointResourceId,
                        (LPTSTR)RestorePointInfo.szDescription,
                        SIZECHARS(RestorePointInfo.szDescription)
                        )) {
            RestorePointInfo.szDescription[0] = TEXT('\0');
        }
    } else {
        RestorePointInfo.szDescription[0] = TEXT('\0');
    }

    b = pfnSrSetRestorePoint(&RestorePointInfo, &SMgrStatus);

    //
    // If we are calling END_NESTED_SYSTEM_CHANGE then unload the srclient.dll
    // since we won't be needing it again.
    //
    if (!Begin) {
        FreeLibrary(hSrClientDll);
        hSrClientDll = FALSE;
    }

    return b;
}

BOOL
GetProcessorExtension(
    LPTSTR ProcessorExtension,
    DWORD  ProcessorExtensionSize
    )
{
    SYSTEM_INFO SystemInfo;
    BOOL bReturn = TRUE;

    ZeroMemory(&SystemInfo, sizeof(SystemInfo));

    GetSystemInfo(&SystemInfo);

    switch(SystemInfo.wProcessorArchitecture) {
    case PROCESSOR_ARCHITECTURE_INTEL:
        if (FAILED(StringCchCopy(ProcessorExtension, ProcessorExtensionSize, TEXT("i386")))) {
            bReturn = FALSE;
        }
        break;

    case PROCESSOR_ARCHITECTURE_IA64:
        if (FAILED(StringCchCopy(ProcessorExtension, ProcessorExtensionSize, TEXT("IA64")))) {
            bReturn = FALSE;
        }
        break;

    case PROCESSOR_ARCHITECTURE_MSIL:
        if (FAILED(StringCchCopy(ProcessorExtension, ProcessorExtensionSize, TEXT("MSIL")))) {
            bReturn = FALSE;
        }
        break;

    case PROCESSOR_ARCHITECTURE_AMD64:
        if (FAILED(StringCchCopy(ProcessorExtension, ProcessorExtensionSize, TEXT("AMD64")))) {
            bReturn = FALSE;
        }
        break;

    default:
        ASSERT(0);
        bReturn = FALSE;
        break;
    }

    return bReturn;
}

BOOL
GetGuiSetupInProgress(
    VOID
    )
/*++

Routine Description:

    This routine determines if we're doing a gui-mode setup.

    This value is retrieved from the following registry location:

    \HKLM\System\Setup\

        SystemSetupInProgress : REG_DWORD : 0x00 (where nonzero means we're doing a gui-setup)

Arguments:

    None.

Return Value:

    TRUE if we are in gui-mode setup, FALSE otherwise.

--*/
{
    HKEY hKey;
    DWORD Err, DataType, DataSize = sizeof(DWORD);
    DWORD Value = 0;

    if((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("System\\Setup"),
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {
        //
        // Attempt to read the the "SystemSetupInProgress" value.
        //
        Err = RegQueryValueEx(
                    hKey,
                    TEXT("SystemSetupInProgress"),
                    NULL,
                    &DataType,
                    (LPBYTE)&Value,
                    &DataSize);

        RegCloseKey(hKey);
    }

    if(Err == NO_ERROR) {
        if(Value) {
            return(TRUE);
        }
    }

    return(FALSE);

}

DWORD
GetBusInformation(
    DEVNODE DevNode
    )
/*++

Routine Description:

    This routine retrieves the bus information flags.

Arguments:

    DeviceInfoSet -
    
    DeviceInfoData - 

Return Value:

    DWORD that contains the bus information flags.

--*/
{
    GUID BusTypeGuid;
    TCHAR BusTypeGuidString[MAX_GUID_STRING_LEN];
    HKEY hBusInformationKey;
    DWORD BusInformation = 0;
    DWORD dwType, cbData;

    //
    // Get the bus type GUID for this device.
    //
    cbData = sizeof(BusTypeGuid);
    if (CM_Get_DevNode_Registry_Property(DevNode,
                                         CM_DRP_BUSTYPEGUID,
                                         &dwType,
                                         (PVOID)&BusTypeGuid,
                                         &cbData,
                                         0) != CR_SUCCESS) {
        goto clean0;
    }

    //
    // Convert the bus type GUID into a string.
    //
    if (pSetupStringFromGuid(&BusTypeGuid,
                             BusTypeGuidString,
                             SIZECHARS(BusTypeGuidString)
                             ) != NO_ERROR) {
        goto clean0;
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     REGSTR_PATH_BUSINFORMATION,
                     0,
                     KEY_READ,
                     &hBusInformationKey
                     ) != ERROR_SUCCESS) {
        goto clean0;
    }

    cbData = sizeof(BusInformation);
    if (RegQueryValueEx(hBusInformationKey,
                        BusTypeGuidString,
                        NULL,
                        &dwType,
                        (LPBYTE)&BusInformation,
                        &cbData) != ERROR_SUCCESS) {

        BusInformation = 0;
    }

    RegCloseKey(hBusInformationKey);

clean0:
    return BusInformation;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\newdev\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#define IDB_BANNERBMP                   100
#define IDB_WATERBMP                    101

#define IDI_NEWDEVICEICON               200
#define IDI_CD                          201
#define IDI_HELPCENTER                  204
#define IDI_BLANK                       205
#define IDI_SIGNED                      206
#define IDI_WARN                        207
#define IDI_INFO                        208
#define IDI_CERT                        209

#define IDA_SEARCHING                   300
#define IDA_INSTALLING                  301
#define IDA_INTERNETDOWNLOAD            302

#define IDD_NEWDEVWIZ_INTRO                 10125
#define IDD_NEWDEVWIZ_SELECTCLASS           10126
#define IDD_NEWDEVWIZ_SELECTDEVICE          10127
#define IDD_WIZARDEXT_SELECT                IDD_DYNAWIZ_SELECTCLASS_PAGE
                   // setupapi contains IDD_DYNAWIZ_SELECTDEV_PAGE
#define IDD_WIZARDEXT_SELECT_END            IDD_DYNAWIZ_ANALYZEDEV_PAGE
#define IDD_NEWDEVWIZ_INSTALLDEV            10133

#define IDD_NEWDEVWIZ_FINISHINSTALL_INTRO   10134
#define IDD_WIZARDEXT_FINISHINSTALL         10135
#define IDD_WIZARDEXT_FINISHINSTALL_END     10136
#define IDD_NEWDEVWIZ_FINISH                10137

#define IDD_NEWDEVWIZ_ADVANCEDSEARCH        10153
#define IDD_NEWDEVWIZ_SEARCHING             10154
#define IDD_NEWDEVWIZ_LISTDRIVERS           10155
#define IDD_NEWDEVWIZ_WUPROMPT              10156
#define IDD_NEWDEVWIZ_USECURRENT_FINISH     10157
#define IDD_NEWDEVWIZ_NODRIVER_FINISH       10158

#define IDC_NDW_TEXT                    1002
#define IDC_NDW_PICKCLASS_CLASSLIST     1007
#define IDC_NDW_PICKCLASS_HWTYPES       1008
#define IDC_NDW_DESCRIPTION             1009
#define IDC_NDW_DISPLAYRESOURCE         1011
#define IDC_CLASSICON                   1014
#define IDC_DRVUPD_DRVDESC              1018
#define IDC_TEXT_INTERNETDOWNLOAD       1055
#define IDC_ANIMATE_INTERNETDOWNLOAD    1056
#define IDC_ANIMATE_SEARCH              1057
#define IDC_ANIMATE_INSTALL             1058
#define IDC_PROGRESS_INSTALL            1059
#define IDC_FILECOPY_TEXT1              1061
#define IDC_FILECOPY_TEXT2              1062
#define IDC_STATUS_TEXT                 1063
#define IDC_FINISH_PROMPT               1030
#define IDC_LISTDRIVERS_LISTVIEW        1043
#define IDC_INTRO_MSG1                  1044
#define IDC_INTRO_MSG2                  1045
#define IDC_INTRO_MSG3                  1047
#define IDC_INTRO_DRVDESC               1048
#define IDC_INTRO_SEARCH                1049
#define IDC_INTRO_ADVANCED              1050
#define IDC_INTRO_ICON                  1051
#define IDC_FINISH_MSG1                 1052
#define IDC_FINISH_MSG2                 1053
#define IDC_FINISH_MSG3                 1054
#define IDC_FINISH_MSG4                 1055
#define IDC_HELPCENTER_TEXT             1056
#define IDC_ADVANCED_SEARCH             1058
#define IDC_ADVANCED_LIST               1059
#define IDC_ADVANCED_REMOVABLEMEDIA     1060
#define IDC_ADVANCED_LOCATION           1061
#define IDC_ADVANCED_LOCATION_COMBO     1062
#define IDC_BROWSE                      1063
#define IDC_WU_SEARCHINET               1064
#define IDC_WU_NOSEARCH                 1065
#define IDC_WUPROMPT_MSG1               1066
#define IDC_HELPCENTER_ICON             1069
#define IDC_INFO_ICON                   1070
#define IDC_SIGNED_ICON                 1071
#define IDC_SIGNED_TEXT                 1072
#define IDC_SIGNED_LINK                 1073

#define IDS_UNKNOWN                     2000
#define IDS_NDW_NOTADMIN                2001
#define IDS_NEWDEVICENAME               2002

#define IDS_NEEDREBOOT                  2009
#define IDS_NDW_PICKCLASS1              2027
#define IDS_UPDATEDEVICE                2039
#define IDS_FOUNDDEVICE                 2040
#define IDS_NDW_ERRORFIN1               2041
#define IDS_NDW_ERRORFIN1_PNP           2043
#define IDS_FINISH_PROB_MSG2            2049
#define IDS_FINISH_PROB_MSG4            2050
#define IDS_FINISH_PROB_ERROR_NO_ASSOCIATED_SERVICE     2051
#define IDS_FINISH_PROB_TRUST_E_SUBJECT_FORM_UNKNOWN    2052

#define IDS_NEWDEVWIZ_ADVANCEDSEARCH     2068
#define IDS_NEWDEVWIZ_SEARCH             2069
#define IDS_NEWDEVWIZ_SEARCHING          2070
#define IDS_NEWDEVWIZ_SELECTCLASS        2072
#define IDS_NEWDEVWIZ_SELECTDEVICE       2074
#define IDS_NEWDEVWIZ_INSTALLDEV         2078
#define IDS_NEWDEVWIZ_WUPROMPT           2079
#define IDS_NEWDEVWIZ_LISTDRIVERS        2082
#define IDS_DRIVERDESC                   2085
#define IDS_DRIVERVERSION                2086
#define IDS_DRIVERMFG                    2087
#define IDS_DRIVERINF                    2088
#define IDS_DRIVER_CURR                  2090
#define IDS_DEFAULT_INTERNET_HOST        2099
#define IDS_FOUNDNEW_FOUND               2105
#define IDS_UNKNOWNDEVICE                2108
#define IDS_SEARCHING_RESULTS            2110
#define IDS_INTRO_MSG1_NEW               2113
#define IDS_INTRO_MSG1_UPGRADE           2114
#define IDS_FINISH_MSG1_UPGRADE          2116
#define IDS_FINISH_MSG1_NEW              2117
#define IDS_FINISH_MSG1_INSTALL_PROBLEM  2118
#define IDS_FINISH_MSG1_DEVICE_PROBLEM   2119
#define IDS_NEWDEVICE_REBOOT             2121
#define IDS_NEWSEARCH                    2122
#define IDS_FOUNDNEWHARDWARE             2123
#define IDS_NOTADMIN_ERROR               2125
#define IDS_BROWSE_TITLE                 2135
#define IDS_LOGON_TEXT                   2136
#define IDS_LOCATION_BAD_DIR             2137
#define IDS_LOCATION_NO_INFS             2138
#define IDS_SHOWALLDEVICES               2150
#define IDS_FINISH_BALLOON_SUCCESS       2151
#define IDS_FINISH_BALLOON_REBOOT        2152
#define IDS_FINISH_BALLOON_ERROR         2153
#define IDS_UPDATE_SETRESTOREPOINT       2160
#define IDS_NEW_SETRESTOREPOINT          2161
#define IDS_ROLLBACK_SETRESTOREPOINT     2162
#define IDS_FILEOP_FROM                  2170
#define IDS_FILEOP_TO                    2171
#define IDS_FILEOP_FILE                  2172
#define IDS_FILEOP_BACKUP                2173
#define IDS_SYSTEMRESTORE_TEXT           2174
#define IDS_DRIVER_IS_SIGNED             2175
#define IDS_DRIVER_NOT_SIGNED            2176
#define IDS_DRIVER_AUTHENTICODE_SIGNED   2177



#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\newdev\newdev.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       newdev.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include <initguid.h>

//
// Define and initialize all device class GUIDs.
// (This must only be done once per module!)
//
#include <devguid.h>

//
// Define and initialize a global variable, GUID_NULL
// (from coguid.h)
//
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

typedef
BOOL
(*PINSTALLNEWDEVICE)(
    HWND hwndParent,
    LPGUID ClassGuid,
    PDWORD pReboot
    );

WNDPROC           g_OldWizardProc;
PINSTALLNEWDEVICE pInstallNewDevice = NULL;
int g_BlankIconIndex;

typedef struct _NewDevWizPropertySheet {
    PROPSHEETHEADER   PropSheetHeader;
    HPROPSHEETPAGE    PropSheetPages[16];
} NDWPROPERTYSHEET, *PNDWPROPERTYSHEET;


LRESULT CALLBACK
WizParentWindowProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
/*++

Routine Description:

    This function disables auto-run when the Found New Hardware Wizard is running.
    It is a subclass of the wizard's main window.

Arguments:

    hwnd -

    uMsg -

    wParam -

    lParam -

Return Value:

    If the message is QueryCancelAutoPlay then return TRUE to cancel AutoPlay,
    otherwise return the default window value.

--*/
{
    static UINT msgQueryCancelAutoPlay = 0;

    if (!msgQueryCancelAutoPlay) {

        msgQueryCancelAutoPlay = RegisterWindowMessage(TEXT("QueryCancelAutoPlay"));
    }

    if (uMsg == msgQueryCancelAutoPlay) {

        //
        // Cancel Auto-Play when the wizard is running.
        //
        SetWindowLongPtr(hwnd, DWLP_MSGRESULT, TRUE);
        return 1;

    } else {

        return CallWindowProc(g_OldWizardProc, hwnd, uMsg, wParam, lParam);
    }
}

INT CALLBACK
iNDWDlgCallback(
    IN HWND             hwndDlg,
    IN UINT             uMsg,
    IN LPARAM           lParam
    )
/*++

Routine Description:

    Call back used to remove the "?" from the wizard page.
    Also used to subclass the wizard's window to catch the
    QueryCancelAutoRun message sent by the shell when an AutoRun
    CD is inserted.

Arguments:

    hwndDlg - Handle to the property sheet dialog box.

    uMsg - Identifies the message being received. This parameter
            is one of the following values:

            PSCB_INITIALIZED - Indicates that the property sheet is
            being initialized. The lParam value is zero for this message.

            PSCB_PRECREATE      Indicates that the property sheet is about
            to be created. The hwndDlg parameter is NULL and the lParam
            parameter is a pointer to a dialog template in memory. This
            template is in the form of a DLGTEMPLATE structure followed
            by one or more DLGITEMTEMPLATE structures.

    lParam - Specifies additional information about the message. The
            meaning of this value depends on the uMsg parameter.

Return Value:

    The function returns zero.

--*/
{

    switch( uMsg ) {

    case PSCB_INITIALIZED:
        g_OldWizardProc = (WNDPROC)SetWindowLongPtr(hwndDlg,
                                                   DWLP_DLGPROC,
                                                   (LONG_PTR)WizParentWindowProc
                                                   );
        break;

    case PSCB_PRECREATE:
        if( lParam ){

            //
            // This is done to hide the X and ? at the top of the wizard
            //
            DLGTEMPLATE *pDlgTemplate = (DLGTEMPLATE *)lParam;
            pDlgTemplate->style &= ~(DS_CONTEXTHELP | WS_SYSMENU);
        }
        break;
    }

    return FALSE;
}


PNDWPROPERTYSHEET
InitNDWPropSheet(
   HWND            hwndParent,
   PNEWDEVWIZ      NewDevWiz,
   int             StartPageId
   )
{
    PNDWPROPERTYSHEET NdwPropertySheet;
    LPPROPSHEETHEADER PropSheetHeader;
    PROPSHEETPAGE    psp;
    LPTSTR Title;

    //
    // Allocate memory for the header and the page array.
    //
    NdwPropertySheet = LocalAlloc(LPTR, sizeof(NDWPROPERTYSHEET));

    if (!NdwPropertySheet) {

        NewDevWiz->LastError = ERROR_NOT_ENOUGH_MEMORY;
        return NULL;
    }

    NewDevWiz->LastError = NdwBuildClassInfoList(NewDevWiz, DIBCI_NOINSTALLCLASS);

    if (NewDevWiz->LastError != ERROR_SUCCESS) {

        return NULL;
    }

    //
    // Initialize the PropertySheet Header
    //
    PropSheetHeader = &(NdwPropertySheet->PropSheetHeader);
    PropSheetHeader->dwSize = sizeof(NdwPropertySheet->PropSheetHeader);
    PropSheetHeader->dwFlags = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 | PSH_WATERMARK | PSH_STRETCHWATERMARK | PSH_HEADER;
    PropSheetHeader->pszbmWatermark = MAKEINTRESOURCE(IDB_WATERBMP);
    PropSheetHeader->pszbmHeader = MAKEINTRESOURCE(IDB_BANNERBMP);
    PropSheetHeader->hwndParent = hwndParent;
    PropSheetHeader->hInstance = hNewDev;
    PropSheetHeader->pfnCallback = iNDWDlgCallback;

    switch (NewDevWiz->InstallType) {

        case NDWTYPE_FOUNDNEW:
            Title = (LPTSTR)IDS_FOUNDDEVICE;
            break;

        case NDWTYPE_UPDATE:
            Title = (LPTSTR)IDS_UPDATEDEVICE;
            break;

        default:
            Title = TEXT(""); // unknown
    }

    PropSheetHeader->pszCaption = Title;
    PropSheetHeader->phpage = NdwPropertySheet->PropSheetPages;
    PropSheetHeader->nStartPage = 0;

    PropSheetHeader->nPages = 0;
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.hInstance = hNewDev;
    psp.lParam = (LPARAM)NewDevWiz;
    psp.pszTitle = Title;

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

    if (StartPageId == IDD_NEWDEVWIZ_INSTALLDEV) {
        //
        // Found New Hardware, with a rank Zero match.
        // jump straight into install page.
        //
        ;

    }

    else {

        //
        // Update driver, or found new hardware without rank Zero driver
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_INTRO);
        psp.pfnDlgProc = IntroDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;

        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_ADVANCEDSEARCH);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_ADVANCEDSEARCH);
        psp.pfnDlgProc = AdvancedSearchDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
        
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_SEARCHING);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_SEARCHING);
        psp.pfnDlgProc = DriverSearchingDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_WUPROMPT);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_WUPROMPT);
        psp.pfnDlgProc = WUPromptDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
        
        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_LISTDRIVERS);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_LISTDRIVERS);
        psp.pfnDlgProc = ListDriversDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_SELECTCLASS);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_SELECTCLASS);
        psp.pfnDlgProc = NDW_PickClassDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_SELECTDEVICE);
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_SELECTDEVICE);
        psp.pfnDlgProc = NDW_SelectDeviceDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        //
        // These last two wizard pages are finish pages...so hide the header
        //
        psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_USECURRENT_FINISH);
        psp.pfnDlgProc = UseCurrentDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_NODRIVER_FINISH);
        psp.pfnDlgProc = NoDriverDlgProc;
        PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    }

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
    psp.pszHeaderTitle = MAKEINTRESOURCE(IDS_NEWDEVWIZ_INSTALLDEV);
    psp.pszHeaderSubTitle = NULL;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_INSTALLDEV);
    psp.pfnDlgProc = NDW_InstallDevDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);

    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_HIDEHEADER;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_NEWDEVWIZ_FINISH);
    psp.pfnDlgProc = NDW_FinishDlgProc;
    PropSheetHeader->phpage[PropSheetHeader->nPages++] = CreatePropertySheetPage(&psp);
    
    //
    // Get the Class Icon Image Lists.
    //
    NewDevWiz->ClassImageList.cbSize = sizeof(SP_CLASSIMAGELIST_DATA);

    if (SetupDiGetClassImageList(&NewDevWiz->ClassImageList)) {

        HICON hIcon;

        //
        // Add the blank icon for "Show All Devices"
        //
        if ((hIcon = LoadIcon(hNewDev, MAKEINTRESOURCE(IDI_BLANK))) != NULL) {

            g_BlankIconIndex = ImageList_AddIcon(NewDevWiz->ClassImageList.ImageList, hIcon);
        }
    } else {

        NewDevWiz->ClassImageList.cbSize = 0;
    }

    NewDevWiz->CurrCursor = NULL;
    NewDevWiz->IdcWait        = LoadCursor(NULL, IDC_WAIT);
    NewDevWiz->IdcAppStarting = LoadCursor(NULL, IDC_APPSTARTING);
    NewDevWiz->IdcArrow = LoadCursor(NULL, IDC_ARROW);

    return NdwPropertySheet;
}

BOOL
DoDeviceWizard(
    HWND hWnd,
    PNEWDEVWIZ NewDevWiz,
    BOOL bUpdate
    )
{
    int  PropSheetResult = 0;
    PNDWPROPERTYSHEET NdwPropertySheet;

    NdwPropertySheet = InitNDWPropSheet(hWnd, 
                                        NewDevWiz, 
                                        bUpdate ? 0 : IDD_NEWDEVWIZ_INSTALLDEV
                                        );

    if (NdwPropertySheet) {

        CoInitialize(NULL);

        PropSheetResult = (int)PropertySheet(&NdwPropertySheet->PropSheetHeader);

        CoUninitialize();

        LocalFree(NdwPropertySheet);
    }

    //
    // If there were no other errors encounted while installing drivers and the
    // user canceled out of the wizard, then set the LastError to ERROR_CANCELED.
    //
    if ((NewDevWiz->LastError == ERROR_SUCCESS) &&
        (PropSheetResult == 0)) {
        NewDevWiz->LastError = ERROR_CANCELLED;
    }

    //
    // Final cleanup of DeviceInfoData and DeviceInfoList.
    //
    if (NewDevWiz->ClassGuidList) {
        LocalFree(NewDevWiz->ClassGuidList);
        NewDevWiz->ClassGuidList = NULL;
        NewDevWiz->ClassGuidSize = NewDevWiz->ClassGuidNum = 0;
    }

    //
    // Destroy the ClassImageList
    //
    if (NewDevWiz->ClassImageList.cbSize) {
        SetupDiDestroyClassImageList(&NewDevWiz->ClassImageList);
        NewDevWiz->ClassImageList.cbSize = 0;
    }

    return NewDevWiz->LastError == ERROR_SUCCESS;
}

BOOL
InstallSelectedDriver(
   HWND hwndParent,
   HDEVINFO hDeviceInfo,
   LPCWSTR Reserved,
   BOOL Backup,
   PDWORD pReboot
   )
/*++

Routine Description:

   Installs the selected driver on the selected device in the hDeviceInfo.

Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   HDEVINFO hDeviceInfo - DeviceInfoList which supplies the selected device to install the
                          selected driver on.

   Reserved - ignored, should be NULL.

   Backup - BOOL that indicates whether or not we should back up the current drivers before
            installing the new ones.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)


Return Value:

    BOOL    TRUE if the driver was installed
            FALSE if the driver was not installed.  Check GetLastError() to see if the specific
                  error.

--*/
{
    NEWDEVWIZ  NewDevWiz;
    UPDATEDRIVERINFO UpdateDriverInfo;

    UNREFERENCED_PARAMETER(Reserved);

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    //
    // Verify that the process has sufficient Administrator privileges.
    //
    if (!pSetupIsUserAdmin()) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }

    memset(&NewDevWiz, 0, sizeof(NewDevWiz));
    NewDevWiz.InstallType = NDWTYPE_UPDATE_SILENT;
    NewDevWiz.hDeviceInfo = hDeviceInfo;

    try {

        NewDevWiz.DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (!SetupDiGetSelectedDevice(NewDevWiz.hDeviceInfo,
                                      &NewDevWiz.DeviceInfoData
                                      ))
        {
            NewDevWiz.LastError = GetLastError();
            goto INDLeaveExcept;
        }

        NewDevWiz.ClassGuidSelected = &NewDevWiz.DeviceInfoData.ClassGuid;

        if (!SetupDiGetClassDescription(NewDevWiz.ClassGuidSelected,
                                        NewDevWiz.ClassDescription,
                                        SIZECHARS(NewDevWiz.ClassDescription),
                                        NULL
                                        )
            ||
            !SetupDiClassNameFromGuid(NewDevWiz.ClassGuidSelected,
                                       NewDevWiz.ClassName,
                                       SIZECHARS(NewDevWiz.ClassName),
                                       NULL
                                       ))
        {
            NewDevWiz.LastError = GetLastError();
            goto INDLeaveExcept;
        }

        ZeroMemory(&UpdateDriverInfo, sizeof(UpdateDriverInfo));
        NewDevWiz.UpdateDriverInfo = &UpdateDriverInfo;

        if (Backup == FALSE) {

            NewDevWiz.Flags |= IDI_FLAG_NOBACKUP;
        }

        //
        // If the driver we are installing is not digitally signed then we 
        // want to set a system restore point.
        //
        NewDevWiz.Flags |= IDI_FLAG_SETRESTOREPOINT;

        //
        // Do the install quietly since we may have a batch of installs to do,
        // only showing UI when really needed.
        //
        NewDevWiz.SilentMode = TRUE;

        DoDeviceWizard(hwndParent, &NewDevWiz, FALSE);

INDLeaveExcept:;

    } except(NdwUnhandledExceptionFilter(GetExceptionInformation())) {

          NewDevWiz.LastError = RtlNtStatusToDosError(GetExceptionCode());
    }

    if (pReboot) {
        //
        // copy out the reboot flags for the caller
        //
        *pReboot = NewDevWiz.Reboot;
    
    } else if (NewDevWiz.Reboot) {
        //
        // The caller didn't want the reboot flags so just prompt for a reboot
        // ourselves if one is needed.
        //
        RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
    }

    SetLastError(NewDevWiz.LastError);

    return NewDevWiz.LastError == ERROR_SUCCESS;
}

BOOL
InstallSelectedDevice(
   HWND hwndParent,
   HDEVINFO hDeviceInfo,
   PDWORD pReboot
   )
/*++

Routine Description:

   Installs the selected device in the hDeviceInfo.

Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   HDEVINFO hDeviceInfo - DeviceInfoList which supplies the selected device to install.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/
{
    BOOL DriversFound;
    NEWDEVWIZ  NewDevWiz;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DEVINSTALL_PARAMS  DeviceInstallParams;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }

    //
    // Verify that the process has sufficient Administrator privileges.
    //
    if (!pSetupIsUserAdmin()) {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }
    
    memset(&NewDevWiz, 0, sizeof(NewDevWiz));
    NewDevWiz.InstallType = NDWTYPE_FOUNDNEW;
    NewDevWiz.hDeviceInfo = hDeviceInfo;

    try {
        
        NewDevWiz.DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

        if (!SetupDiGetSelectedDevice(NewDevWiz.hDeviceInfo,
                                  &NewDevWiz.DeviceInfoData
                                  ))
        {
            NewDevWiz.LastError = GetLastError();
            goto INDLeaveExcept;
        }


        NewDevWiz.ClassGuidSelected = &NewDevWiz.DeviceInfoData.ClassGuid;

        if (!SetupDiGetClassDescription(NewDevWiz.ClassGuidSelected,
                                       NewDevWiz.ClassDescription,
                                       SIZECHARS(NewDevWiz.ClassDescription),
                                       NULL
                                       )
            ||
            !SetupDiClassNameFromGuid(NewDevWiz.ClassGuidSelected,
                                      NewDevWiz.ClassName,
                                      SIZECHARS(NewDevWiz.ClassName),
                                      NULL
                                      ))
         {
            NewDevWiz.LastError = GetLastError();
            goto INDLeaveExcept;
        }

        //
        // Do the install quietly since we may have a batch of installs to do,
        // only showing UI when really needed. During legacy detect the
        // detect summary page is showing.
        //
        NewDevWiz.SilentMode = TRUE;
        DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

        //
        // If the driver we are installing is not digitally signed then we 
        // want to set a system restore point.
        //
        NewDevWiz.Flags = IDI_FLAG_SETRESTOREPOINT;

        if (SetupDiGetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData,
                                          &DeviceInstallParams
                                          ))
       {
            DeviceInstallParams.Flags |= DI_SHOWOEM | DI_QUIETINSTALL;
            DeviceInstallParams.hwndParent = hwndParent;
            DeviceInstallParams.DriverPath[0] = TEXT('\0');

            SetupDiSetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData,
                                          &DeviceInstallParams
                                          );
        }

        //
        // If no driver list search the win inf default locations
        // If we still can't find a driver, then start at the driver
        // search page.
        //
        // otherwise go straight to the finish page and install.
        // To preserve drivers preselected by the caller (legacy detect)
        // the currently SelectedDriver is used, but if there is no selected
        // driver the highest ranking  driver is used.
        //
        DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        DriversFound = SetupDiEnumDriverInfo(NewDevWiz.hDeviceInfo,
                                            &NewDevWiz.DeviceInfoData,
                                            SPDIT_COMPATDRIVER,
                                            0,
                                            &DriverInfoData
                                            );

        if (!DriversFound) {

            SetupDiDestroyDriverInfoList(NewDevWiz.hDeviceInfo,
                                         &NewDevWiz.DeviceInfoData,
                                         SPDIT_COMPATDRIVER
                                         );

            if (SetupDiGetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                              &NewDevWiz.DeviceInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                DeviceInstallParams.DriverPath[0] = TEXT('\0');
                SetupDiSetDeviceInstallParams(NewDevWiz.hDeviceInfo,
                                              &NewDevWiz.DeviceInfoData,
                                              &DeviceInstallParams
                                              );
            }



            if (SetupDiBuildDriverInfoList(NewDevWiz.hDeviceInfo,
                                           &NewDevWiz.DeviceInfoData,
                                           SPDIT_COMPATDRIVER
                                           ))
            {
                SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                          NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData
                                          );
            }

            DriversFound = SetupDiEnumDriverInfo(NewDevWiz.hDeviceInfo,
                                                &NewDevWiz.DeviceInfoData,
                                                SPDIT_COMPATDRIVER,
                                                0,
                                                &DriverInfoData
                                                );
        }

        if (DriversFound) {

            SP_DRVINFO_DATA SelectedDriverInfo;

            SelectedDriverInfo.cbSize = sizeof(SP_DRVINFO_DATA);

            if (!SetupDiGetSelectedDriver(NewDevWiz.hDeviceInfo,
                                          &NewDevWiz.DeviceInfoData,
                                          &SelectedDriverInfo
                                          ))
            {
                SetupDiSetSelectedDriver(NewDevWiz.hDeviceInfo,
                                         &NewDevWiz.DeviceInfoData,
                                         &DriverInfoData
                                         );
            }

            DoDeviceWizard(hwndParent, &NewDevWiz, FALSE);
        }

        else {

            DoDeviceWizard(hwndParent, &NewDevWiz, TRUE);
        }

        if (pReboot) {
            //
            // copy out the reboot flags for the caller
            //
            *pReboot = NewDevWiz.Reboot;
        
        } else if (NewDevWiz.Reboot) {
            //
            // The caller didn't want the reboot flags so just prompt for a reboot
            // ourselves if one is needed.
            //
            RestartDialogEx(hwndParent, NULL, EWX_REBOOT, REASON_PLANNED_FLAG | REASON_HWINSTALL);
        }

INDLeaveExcept:;

    } except(NdwUnhandledExceptionFilter(GetExceptionInformation())) {

          NewDevWiz.LastError = RtlNtStatusToDosError(GetExceptionCode());
    }

    if (NewDevWiz.hDeviceInfo &&
        (NewDevWiz.hDeviceInfo != INVALID_HANDLE_VALUE)) {

        SetupDiDestroyDriverInfoList(NewDevWiz.hDeviceInfo, &NewDevWiz.DeviceInfoData, SPDIT_COMPATDRIVER);
        SetupDiDestroyDeviceInfoList(NewDevWiz.hDeviceInfo);
    }

    SetLastError(NewDevWiz.LastError);

    return NewDevWiz.LastError == ERROR_SUCCESS;
}




BOOL
InstallNewDevice(
   HWND hwndParent,
   LPGUID ClassGuid,
   PDWORD pReboot
   )
/*++

Routine Description:

   Exported Entry point from newdev.dll. Installs a new device. A new Devnode is
   created and the user is prompted to select the device. If the class guid
   is not specified then then the user begins at class selection.

   This function has been moved to hdwwiz.cpl (which handles all legacy device
   functions now).  This entry point just forwards the function call onto hdwwiz.cpl
   now.

Arguments:

   hwndParent - Window handle of the top-level window to use for any UI related
                to installing the device.

   LPGUID ClassGuid - Optional class of the new device to install.
                      If ClassGuid is NULL we start at detection choice page.
                      If ClassGuid == GUID_NULL or GUID_DEVCLASS_UNKNOWN
                         we start at class selection page.

   pReboot - Optional address of variable to receive reboot flags (DI_NEEDRESTART,DI_NEEDREBOOT)


Return Value:

   BOOL TRUE for success (does not mean device was installed or updated),
        FALSE unexpected error. GetLastError returns the winerror code.

--*/
{
    HMODULE hHdwWiz = NULL;
    BOOL Return = FALSE;

    //
    // If someone calls the 32-bit newdev.dll on a 64-bit OS then we need
    // to fail and set the last error to ERROR_IN_WOW64.
    //
    if (GetIsWow64()) {
        SetLastError(ERROR_IN_WOW64);
        return FALSE;
    }
    
    hHdwWiz = LoadLibrary(TEXT("HDWWIZ.CPL"));

    if (NULL == hHdwWiz) {

        return FALSE;
    }

    if (NULL == pInstallNewDevice) {

        pInstallNewDevice = (PINSTALLNEWDEVICE)GetProcAddress(hHdwWiz, "InstallNewDevice");
    }

    if (NULL == pInstallNewDevice) {

        return FALSE;
    }

    Return = (pInstallNewDevice)(hwndParent, ClassGuid, pReboot);

    FreeLibrary(hHdwWiz);

    return Return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\newdev\selclass.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       selclass.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"   

int CALLBACK
ClassListCompare(
    LPARAM lParam1,
    LPARAM lParam2,
    LPARAM lParamSort
    )
{
    TCHAR ClassDescription1[LINE_LEN];
    TCHAR ClassDescription2[LINE_LEN];

    UNREFERENCED_PARAMETER(lParamSort);

    //
    // Check if the 1st item is GUID_DEVCLASS_UNKNOWN
    //
    if (IsEqualGUID((LPGUID)lParam1, &GUID_DEVCLASS_UNKNOWN)) {
        return -1;
    }

    //
    // Check if the 2nd item is GUID_DEVCLASS_UNKNOWN
    //
    if (IsEqualGUID((LPGUID)lParam2, &GUID_DEVCLASS_UNKNOWN)) {
        return 1;
    }

    if (SetupDiGetClassDescription((LPGUID)lParam1,
                                   ClassDescription1,
                                   LINE_LEN,
                                   NULL
                                   ) &&
        SetupDiGetClassDescription((LPGUID)lParam2,
                                   ClassDescription2,
                                   LINE_LEN,
                                   NULL
                                   )) {
    
        return (lstrcmpi(ClassDescription1, ClassDescription2));
    }

    return 0;
}

void 
InitNDW_PickClassDlg(
    HWND hwndClassList,
    PNEWDEVWIZ NewDevWiz
    )
{
    LPGUID ClassGuid, lpClassGuidSelected;
    GUID ClassGuidSelected;
    int    lvIndex;
    DWORD  ClassGuidNum;
    LV_ITEM lviItem;
    TCHAR ClassDescription[LINE_LEN];

    SendMessage(hwndClassList, WM_SETREDRAW, FALSE, 0L);

    //
    // Clear the Class List
    //
    ListView_DeleteAllItems(hwndClassList);

    lviItem.mask = LVIF_TEXT | LVIF_PARAM;
    lviItem.iItem = -1;
    lviItem.iSubItem = 0;

    ClassGuid = NewDevWiz->ClassGuidList;
    ClassGuidNum = NewDevWiz->ClassGuidNum;

    //
    // Keep track of previosuly selected item
    //
    if (IsEqualGUID(&NewDevWiz->lvClassGuidSelected, &GUID_NULL)) {
        
        lpClassGuidSelected = NULL;
    }
    
    else {
        
        ClassGuidSelected = NewDevWiz->lvClassGuidSelected;
        NewDevWiz->lvClassGuidSelected = GUID_NULL;
        lpClassGuidSelected = &ClassGuidSelected;
    }


    while (ClassGuidNum--) {
        
        if (SetupDiGetClassDescription(ClassGuid,
                                       ClassDescription,
                                       SIZECHARS(ClassDescription),
                                       NULL
                                       ))
        {
            if (IsEqualGUID(ClassGuid, &GUID_DEVCLASS_UNKNOWN)) {

                //
                // We need to special case the UNKNOWN class and to give it a 
                // special icon (blank) and special text (Show All Devices).
                //
                LoadString(hNewDev, 
                           IDS_SHOWALLDEVICES, 
                           ClassDescription, 
                           SIZECHARS(ClassDescription)
                           );
                lviItem.iImage = g_BlankIconIndex;                
                lviItem.mask |= LVIF_IMAGE;

            } else if (SetupDiGetClassImageIndex(&NewDevWiz->ClassImageList,
                                           ClassGuid,
                                           &lviItem.iImage
                                           )) {

                lviItem.mask |= LVIF_IMAGE;
            
            } else {
                
                lviItem.mask &= ~LVIF_IMAGE;
            }

            lviItem.pszText = ClassDescription;
            lviItem.lParam = (LPARAM) ClassGuid;
            lvIndex = ListView_InsertItem(hwndClassList, &lviItem);

            //
            // check for previous selection
            //
            if (lpClassGuidSelected &&
                IsEqualGUID(lpClassGuidSelected, ClassGuid))
            {
                ListView_SetItemState(hwndClassList,
                                      lvIndex,
                                      LVIS_SELECTED|LVIS_FOCUSED,
                                      LVIS_SELECTED|LVIS_FOCUSED
                                      );

                lpClassGuidSelected = NULL;
            }
        }

        ClassGuid++;
    }

    //
    // Sort the list
    //
    ListView_SortItems(hwndClassList, (PFNLVCOMPARE)ClassListCompare, NULL);

    //
    // if previous selection wasn't found select first in list.
    //
    if (IsEqualGUID(&NewDevWiz->lvClassGuidSelected, &GUID_NULL)) {
        
        lvIndex = 0;
        ListView_SetItemState(hwndClassList,
                              lvIndex,
                              LVIS_SELECTED|LVIS_FOCUSED,
                              LVIS_SELECTED|LVIS_FOCUSED
                              );
    }

    //
    // previous selection was found, fetch its current index
    //
    else {
        
        lvIndex = ListView_GetNextItem(hwndClassList,
                                       -1,
                                       LVNI_SELECTED
                                       );
    }


    //
    // scroll the selected item into view.
    //
    ListView_EnsureVisible(hwndClassList, lvIndex, FALSE);
    ListView_SetColumnWidth(hwndClassList, 0, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndClassList, WM_SETREDRAW, TRUE, 0L);
}

INT_PTR CALLBACK
NDW_PickClassDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndClassList = GetDlgItem(hDlg, IDC_NDW_PICKCLASS_CLASSLIST);
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        LV_COLUMN lvcCol;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        SetDlgText(hDlg, IDC_NDW_TEXT, IDS_NDW_PICKCLASS1, IDS_NDW_PICKCLASS1);

        //
        // Get the Class Icon Image Lists.  We do this only the first
        // time this dialog is initialized.
        //
        if (NewDevWiz->ClassImageList.cbSize) {
            ListView_SetImageList(hwndClassList,
                                  NewDevWiz->ClassImageList.ImageList,
                                  LVSIL_SMALL
                                  );
        }

        //
        // Insert a column for the class list
        //
        lvcCol.mask = LVCF_FMT | LVCF_WIDTH;
        lvcCol.fmt = LVCFMT_LEFT;
        lvcCol.iSubItem = 0;
        ListView_InsertColumn(hwndClassList, 0, (LV_COLUMN FAR *)&lvcCol);

        //
        // Save the class before the user chooses one. This will be restored
        // in the event the install is cancelled.
        //
        NewDevWiz->SavedClassGuid = NewDevWiz->DeviceInfoData.ClassGuid;

        break;
    }


    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        //
        // This dialog is being activated.  Each time we are activated
        // we free up the current DeviceInfo and create a new one. Although
        // inefficient, its necessary to reenumerate the class list.
        //
        case PSN_SETACTIVE:

            PropSheet_SetWizButtons(hwndParentDlg, PSWIZB_BACK | PSWIZB_NEXT);
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_SELECTCLASS;

            //
            // If we have DeviceInfo from going forward delete it.
            //
            if (NewDevWiz->ClassGuidSelected) {

                SetClassGuid(NewDevWiz->hDeviceInfo,
                             &NewDevWiz->DeviceInfoData,
                             &NewDevWiz->SavedClassGuid
                             );
            }

            NewDevWiz->ClassGuidSelected = NULL;

            NdwBuildClassInfoList(NewDevWiz, 0);
            InitNDW_PickClassDlg(hwndClassList, NewDevWiz);
            if (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) {
                SetTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID, INSTALL_COMPLETE_CHECK_TIMEOUT, NULL);
            }
            break;

        case PSN_RESET:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            SetClassGuid(NewDevWiz->hDeviceInfo,
                         &NewDevWiz->DeviceInfoData,
                         &NewDevWiz->SavedClassGuid
                         );
            break;



        case PSN_WIZBACK:
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_SELECTCLASS;
               
            if (NewDevWiz->EnterInto == IDD_NEWDEVWIZ_SELECTCLASS) {
                   
                SetDlgMsgResult(hDlg, wMsg, NewDevWiz->EnterFrom);
            }
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;



        case PSN_WIZNEXT: {
               
            LPGUID  ClassGuidSelected;

            SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SELECTDEVICE);

            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);

            if (IsEqualGUID(&NewDevWiz->lvClassGuidSelected, &GUID_NULL)) {
                   
                NewDevWiz->ClassGuidSelected = NULL;
                break;
            }

            ClassGuidSelected = &NewDevWiz->lvClassGuidSelected;
            NewDevWiz->ClassGuidSelected = ClassGuidSelected;

            //
            // Add a new element to the DeviceInfo from the GUID and class name
            //
            NewDevWiz->DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

            if (!SetupDiGetClassDescription(NewDevWiz->ClassGuidSelected,
                                            NewDevWiz->ClassDescription,
                                            SIZECHARS(NewDevWiz->ClassDescription),
                                            NULL
                                            )
                ||
                !SetupDiClassNameFromGuid(NewDevWiz->ClassGuidSelected,
                                          NewDevWiz->ClassName,
                                          SIZECHARS(NewDevWiz->ClassName),
                                          NULL
                                          ))
            {
                // unhandled error!
                NewDevWiz->ClassGuidSelected = NULL;
                break;
            }

            if (IsEqualGUID(NewDevWiz->ClassGuidSelected, &GUID_DEVCLASS_UNKNOWN)) {
                   
                ClassGuidSelected = (LPGUID)&GUID_NULL;
            }


            SetClassGuid(NewDevWiz->hDeviceInfo,
                         &NewDevWiz->DeviceInfoData,
                         ClassGuidSelected
                         );

            break;
        }

        case NM_DBLCLK:
            PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);
            break;

        case LVN_ITEMCHANGED: {
               
            LPNM_LISTVIEW   lpnmlv = (LPNM_LISTVIEW)lParam;

            if ((lpnmlv->uChanged & LVIF_STATE)) {
                   
                if (lpnmlv->uNewState & LVIS_SELECTED) {
                       
                    NewDevWiz->lvClassGuidSelected = *((LPGUID)lpnmlv->lParam);
                }
                   
                else if (IsEqualGUID((LPGUID)lpnmlv->lParam,
                                        &NewDevWiz->lvClassGuidSelected
                                        ))
                {
                    NewDevWiz->lvClassGuidSelected = GUID_NULL;
                }
            }

            break;
        }
        }
        break;


    case WM_SYSCOLORCHANGE:
        _OnSysColorChange(hDlg, wParam, lParam);

        //
        // Update the ImageList Background color
        //
        ImageList_SetBkColor((HIMAGELIST)SendMessage(GetDlgItem(hDlg, IDC_NDW_PICKCLASS_CLASSLIST), LVM_GETIMAGELIST, (WPARAM)(LVSIL_SMALL), 0L),
                                GetSysColor(COLOR_WINDOW));
        break;

    case WM_TIMER:
        if (INSTALL_COMPLETE_CHECK_TIMERID == wParam) {
            if (IsInstallComplete(NewDevWiz->hDeviceInfo, &NewDevWiz->DeviceInfoData)) {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

//
// The real select device page is in setupapi.  his page is a blank page which 
// never shows its face to have a consistent place to jump to when the class 
// is known.
//
INT_PTR CALLBACK
NDW_SelectDeviceDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE: {
            int PrevPage, BackUpPage;

            PrevPage = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_SELECTDEVICE;
            BackUpPage = NewDevWiz->EnterInto == IDD_NEWDEVWIZ_SELECTDEVICE
                           ? NewDevWiz->EnterFrom : IDD_NEWDEVWIZ_SELECTCLASS;

            if (!NewDevWiz->ClassGuidSelected || PrevPage == IDD_WIZARDEXT_SELECT) {

                //
                // going backwards, cleanup and backup
                //
                SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         NULL
                                         );

                SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             SPDIT_COMPATDRIVER
                                             );

                SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             SPDIT_CLASSDRIVER
                                             );

                //
                // Cleanup the WizExtSelect Page
                //
                if (NewDevWiz->WizExtSelect.hPropSheet) {
                       
                    PropSheet_RemovePage(GetParent(hDlg),
                                         (WPARAM)-1,
                                         NewDevWiz->WizExtSelect.hPropSheet
                                         );
                }

                SetDlgMsgResult(hDlg, wMsg, BackUpPage);
                break;
            }


            //
            // Set the Cursor to an Hourglass
            //
            SetCursor(LoadCursor(NULL, IDC_WAIT));

            NewDevWiz->WizExtSelect.hPropSheet = CreateWizExtPage(IDD_WIZARDEXT_SELECT,
                                                                  WizExtSelectDlgProc,
                                                                  NewDevWiz
                                                                  );
            
            if (NewDevWiz->WizExtSelect.hPropSheet) {
                   
                PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtSelect.hPropSheet);
                SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_SELECT);
            }

            else {
                
                SetDlgMsgResult(hDlg, wMsg, BackUpPage);
            }

            break;
        }

        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtSelectDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;
    PSP_INSTALLWIZARD_DATA  InstallWizard;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;


    case WM_NOTIFY:
       
        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:

            PrevPageId = NewDevWiz->PrevPage;
            NewDevWiz->PrevPage = IDD_WIZARDEXT_SELECT;

            if (PrevPageId == IDD_NEWDEVWIZ_SELECTDEVICE) {
            
                SP_DEVINSTALL_PARAMS  DeviceInstallParams;

                //
                // Moving forward on first page
                //
                // Prepare to call the class installer, for class install wizard pages.
                // and Add in setup's SelectDevice wizard page.
                //
                InstallWizard = &NewDevWiz->InstallDynaWiz;
                memset(InstallWizard, 0, sizeof(SP_INSTALLWIZARD_DATA));
                InstallWizard->ClassInstallHeader.InstallFunction = DIF_INSTALLWIZARD;
                InstallWizard->ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
                InstallWizard->hwndWizardDlg = GetParent(hDlg);

                if (!SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                                  &NewDevWiz->DeviceInfoData,
                                                  &InstallWizard->ClassInstallHeader,
                                                  sizeof(SP_INSTALLWIZARD_DATA)
                                                  ))
                {
                    SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_SELECT);
                    break;
                }


                SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                         &NewDevWiz->DeviceInfoData,
                                         NULL
                                         );

                SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             SPDIT_COMPATDRIVER
                                             );

                SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             SPDIT_CLASSDRIVER
                                             );
                
                //
                // Get current DeviceInstall parameters, and then set the fields
                // we wanted changed from default
                //
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                  
                if (!SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                                   &NewDevWiz->DeviceInfoData,
                                                   &DeviceInstallParams
                                                   ))
                {
                    SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_SELECT);
                    break;
                }


                DeviceInstallParams.Flags |= DI_SHOWCLASS | DI_SHOWCOMPAT | DI_SHOWOEM | DI_CLASSINSTALLPARAMS;

                DeviceInstallParams.DriverPath[0] = TEXT('\0');

                if (IsEqualGUID(NewDevWiz->ClassGuidSelected, &GUID_DEVCLASS_UNKNOWN)) {
                      
                    DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_FILTERCLASSES;
                }
                  
                else {
                
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_FILTERCLASSES;
                }

                //
                // Check to see if we should show all class drivers or only similar
                // drivers for this device.
                //
                if (GetBusInformation(NewDevWiz->DeviceInfoData.DevInst) & BIF_SHOWSIMILARDRIVERS) {
                    
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_FILTERSIMILARDRIVERS;
                
                } else {

                    DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_FILTERSIMILARDRIVERS;
                }

                DeviceInstallParams.hwndParent = hwndParentDlg;
                if (!SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                                   &NewDevWiz->DeviceInfoData,
                                                   &DeviceInstallParams
                                                   ))
                {
                    SetDlgMsgResult(hDlg, wMsg, IDD_WIZARDEXT_SELECT);
                    break;
                }

                InstallWizard->DynamicPageFlags = 0;
                NewDevWiz->SelectDevicePage = NULL;

                NewDevWiz->SelectDevicePage = SetupDiGetWizardPage(NewDevWiz->hDeviceInfo,
                                                                   &NewDevWiz->DeviceInfoData,
                                                                   InstallWizard,
                                                                   SPWPT_SELECTDEVICE,
                                                                   SPWP_USE_DEVINFO_DATA
                                                                   );

                PropSheet_AddPage(hwndParentDlg, NewDevWiz->SelectDevicePage);

                //
                // Clear the class install parameters.
                //
                SetupDiSetClassInstallParams(NewDevWiz->hDeviceInfo,
                                             &NewDevWiz->DeviceInfoData,
                                             NULL,
                                             0
                                             );

                //
                // Add the end page, which is the select end page.
                //
                NewDevWiz->WizExtSelect.hPropSheetEnd = CreateWizExtPage(IDD_WIZARDEXT_SELECT_END,
                                                                          WizExtSelectEndDlgProc,
                                                                          NewDevWiz
                                                                          );

                PropSheet_AddPage(hwndParentDlg, NewDevWiz->WizExtSelect.hPropSheetEnd);

                PropSheet_PressButton(hwndParentDlg, PSBTN_NEXT);

            }

            else {
                //
                // Moving backwards on first page
                //
                // Clean up proppages added.
                //
                if (NewDevWiz->SelectDevicePage) {
                      
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         NewDevWiz->SelectDevicePage
                                         );
                      
                    NewDevWiz->SelectDevicePage = NULL;
                }


                if (NewDevWiz->WizExtSelect.hPropSheetEnd) {
                      
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         NewDevWiz->WizExtSelect.hPropSheetEnd
                                         );
                      
                    NewDevWiz->WizExtSelect.hPropSheetEnd = NULL;
                }

                //
                // Jump back
                //
                SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_SELECTDEVICE);
            }
            break;

        case PSN_WIZNEXT:
          SetDlgMsgResult(hDlg, wMsg, 0);
          break;
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
WizExtSelectEndDlgProc(
    HWND hDlg, 
    UINT wMsg, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND hwndParentDlg = GetParent(hDlg);
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ )GetWindowLongPtr(hDlg, DWLP_USER);
    int PrevPageId;

    UNREFERENCED_PARAMETER(wParam);

    switch (wMsg) {
       
    case WM_INITDIALOG: {
           
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ )lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        break;
    }

    case WM_DESTROY:
        break;


   case WM_NOTIFY:
       
       switch (((NMHDR FAR *)lParam)->code) {
           
       case PSN_SETACTIVE:

           PrevPageId = NewDevWiz->PrevPage;
           NewDevWiz->PrevPage = IDD_WIZARDEXT_SELECT_END;

           if (PrevPageId == IDD_WIZARDEXT_SELECT) {
               //
               // Moving forward 
               //
               SetDlgMsgResult(hDlg, wMsg, IDD_NEWDEVWIZ_INSTALLDEV);

           } else {
                //
                // Moving backwards 
                //
                // Clean up proppages added.
                //
                if (NewDevWiz->WizExtSelect.hPropSheetEnd) {
                    
                    PropSheet_RemovePage(hwndParentDlg,
                                         (WPARAM)-1,
                                         NewDevWiz->WizExtSelect.hPropSheetEnd
                                         );
                    NewDevWiz->WizExtSelect.hPropSheetEnd = NULL;
                }

                //
                // Jump back
                //
                NewDevWiz->PrevPage = IDD_WIZARDEXT_SELECT;
                SetDlgMsgResult(hDlg, wMsg, IDD_DYNAWIZ_SELECTDEV_PAGE);
            }

           break;

       case PSN_WIZNEXT:
           SetDlgMsgResult(hDlg, wMsg, 0);
           break;
           
       }
       break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\newdev\newdevp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       newdevp.h
//
//--------------------------------------------------------------------------

#define OEMRESOURCE

#pragma warning( disable : 4201 ) // nonstandard extension used : nameless struct/union

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <tchar.h>
#include <commctrl.h>
#include <setupapi.h>
#include <spapip.h>
#include <cfgmgr32.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shlobjp.h>
#include <devguid.h>
#include <pnpmgr.h> //REGSTR_VAL_NEW_DEVICE_DESC
#include <lmcons.h>
#include <dsrole.h>
#include <newdev.h>
#include <cdm.h>
#include <wininet.h>
#include <wincrui.h>
#include <regstr.h>
#include <srrestoreptapi.h>
#include <shfusion.h>
#include <strsafe.h>
#include "resource.h"

#pragma warning( default : 4201 )
                                

#define NEWDEV_CLASS_NAME   TEXT("NewDevClass")

#define ARRAYSIZE(array)     (sizeof(array) / sizeof(array[0]))
#define SIZECHARS(x)         (sizeof((x))/sizeof(TCHAR))


//
// The Install type, these are mutually exclusive.
//
// NDWTYPE_FOUNDNEW - A new device was found.  We will do an initial search for 
//   drivers with the only UI being a subtle balloon tip on the systray.  If we 
//   don't find a driver in our initial search then we will prompt the user with 
//   the Found New Hardware wizard.
// NDWTYPE_UPDATE - This is the case where a user is manually updating a driver.  
//   For this case we just jump directly into the Update Driver Wizard code.
// NDWTYPE_UPDATE_SILENT - This is the case where someone has us silently update 
//   a driver for a given device. For this case we will do a driver search in 
//   the locations specified in the API call.  If we don't find a driver in 
//   these locations then we do NOT bring up the wizard. Note that we could
//   still display some UI in this case (digital signature warning, or a prompt
//   for drivers) but that should only occur if the driver package is not
//   correct.
//
#define NDWTYPE_FOUNDNEW        1
#define NDWTYPE_UPDATE          2
#define NDWTYPE_UPDATE_SILENT   3


//
// DEVICE_COUNT_Xxx values are used for the following settings:
//
// DEVICE_COUNT_FOR_DELAY is the number of devices (times two) that we want to slow
//                        down the install for so the user can see the UI and have
//                        time to read it.  Once we get past this number of devices
//                        then we will skip the dealy.
// DEVICE_COUNT_DELAY is the number of milliseconds that we will delay between UI only
//                    (server side) installs to give the user some time to read the UI.
//
#define DEVICE_COUNT_FOR_DELAY  10
#define DEVICE_COUNT_DELAY      2000

//
// Values used to check if the device, that the Found New Hardware wizard has
// been displayed for, has been installed by some other process. This will 
// most likely happen when one user switches desktops and installs the drivers
// on this device.
//
#define INSTALL_COMPLETE_CHECK_TIMERID  1000
#define INSTALL_COMPLETE_CHECK_TIMEOUT  5000


typedef struct _NewDeviceWizardExtension {
   HPROPSHEETPAGE hPropSheet;
   HPROPSHEETPAGE hPropSheetEnd;         // optional
   SP_NEWDEVICEWIZARD_DATA DeviceWizardData;
} WIZARDEXTENSION, *PWIZARDEXTENSION;

typedef struct _UpdateDriverInfo {
   LPCWSTR InfPathName;
   BOOL    DriverWasUpgraded;
   BOOL    FromInternet;
   TCHAR   BackupRegistryKey[MAX_DEVICE_ID_LEN];
   TCHAR   Description[LINE_LEN];
   TCHAR   MfgName[LINE_LEN];
   TCHAR   ProviderName[LINE_LEN];
} UPDATEDRIVERINFO, *PUPDATEDRIVERINFO;

typedef struct _NewDeviceWizard {
    HWND                    hWnd;

    HDEVINFO                hDeviceInfo;
    int                     EnterInto;
    int                     EnterFrom;
    int                     PrevPage;

    DWORD                   ClassGuidNum;
    DWORD                   ClassGuidSize;
    LPGUID                  ClassGuidList;
    LPGUID                  ClassGuidSelected;
    GUID                    lvClassGuidSelected;
    GUID                    SavedClassGuid;

    HCURSOR  CurrCursor;
    HCURSOR  IdcWait;
    HCURSOR  IdcAppStarting;
    HCURSOR  IdcArrow;
    HFONT    hfontTextNormal;
    HFONT    hfontTextBigBold;
    HFONT    hfontTextBold;

    HANDLE DriverSearchThread;
    HANDLE CancelEvent;

    SP_DEVINFO_DATA         DeviceInfoData;
    SP_INSTALLWIZARD_DATA   InstallDynaWiz;
    HPROPSHEETPAGE          SelectDevicePage;
    SP_CLASSIMAGELIST_DATA  ClassImageList;

    BOOL     Installed;
    BOOL     ExitSearch;
    BOOL     SilentMode;
    BOOL     MultipleDriversFound;
    BOOL     DoAutoInstall;
    BOOL     CurrentDriverIsSelected;
    BOOL     NoDriversFound;
    BOOL     LaunchTroubleShooter;
    BOOL     AlreadySearchedWU;
    BOOL     LogDriverNotFound;
    BOOL     SetRestorePoint;
    DWORD    Flags;
    DWORD    InstallType;
    DWORD    SearchOptions;
    DWORD    LastError;
    DWORD    Reboot;
    DWORD    Capabilities;
    PUPDATEDRIVERINFO UpdateDriverInfo;

    PVOID MessageHandlerContext;

    HMODULE  hCdmInstance;
    HANDLE   hCdmContext;

    WIZARDEXTENSION WizExtSelect;
    WIZARDEXTENSION WizExtFinishInstall;

    TCHAR    ClassName[MAX_CLASS_NAME_LEN];
    TCHAR    ClassDescription[LINE_LEN];
    TCHAR    DriverDescription[LINE_LEN];
    TCHAR    BrowsePath[MAX_PATH];
    TCHAR    SingleInfPath[MAX_PATH];
    TCHAR    InstallDeviceInstanceId[MAX_DEVICE_ID_LEN];
} NEWDEVWIZ, *PNEWDEVWIZ;

typedef struct _DELINFNODE {
    TCHAR               szInf[MAX_PATH];
    struct _DELINFNODE  *pNext;
} DELINFNODE, *PDELINFNODE;

//
// This is the number of times that we will prompt the user for valid
// administrator credentials to install a device.
//
#define MAX_PASSWORD_TRIES  3

//
// InstallDeviceInstance Flag values
//
#define IDI_FLAG_SILENTINSTALL          0x00000001
#define IDI_FLAG_SECONDNEWDEVINSTANCE   0x00000002
#define IDI_FLAG_NOBACKUP               0x00000004
#define IDI_FLAG_READONLY_INSTALL       0x00000008
#define IDI_FLAG_NONINTERACTIVE         0x00000010
#define IDI_FLAG_ROLLBACK               0x00000020
#define IDI_FLAG_FORCE                  0x00000040
#define IDI_FLAG_MANUALINSTALL          0x00000080
#define IDI_FLAG_SETRESTOREPOINT        0x00000100

//
// RollbackDriver Flag values
//
#define ROLLBACK_FLAG_FORCE             0x00000001
#define ROLLBACK_FLAG_DO_CLEANUP        0x00000002
#define ROLLBACK_BITS                   0x00000003

BOOL
DoDeviceWizard(
    HWND hWnd,
    PNEWDEVWIZ NewDevWiz,
    BOOL bUpdate
    );

BOOL
InstallSelectedDevice(
   HWND hwndParent,
   HDEVINFO hDeviceInfo,
   PDWORD pReboot
   );

BOOL
IntializeDeviceMapInfo(
    void
    );

UINT
GetNextDriveByType(
    UINT DriveType,
    UINT DriveNumber
    );

//
// from search.c
//
BOOL
FixUpDriverListForInet(
    PNEWDEVWIZ NewDevWiz
    );

BOOL
IsDriverNodeInteractiveInstall(
   PNEWDEVWIZ NewDevWiz,
   PSP_DRVINFO_DATA DriverInfoData
   );

void
SearchDriveForDrivers(
    PNEWDEVWIZ NewDevWiz,
    UINT DriveType,
    UINT DriveNumber
    );

BOOL
SetDriverPath(
   PNEWDEVWIZ NewDevWiz,
   PCTSTR     DriverPath
   );

BOOL
IsInstalledDriver(
   PNEWDEVWIZ NewDevWiz,
   PSP_DRVINFO_DATA DriverInfoData
   );

void
DoDriverSearch(
    HWND hWnd,
    PNEWDEVWIZ NewDevWiz,
    ULONG SearchOptions,
    DWORD DriverType,
    BOOL bAppendToExistingDriverList
    );

BOOL
SearchWindowsUpdateCache(
    PNEWDEVWIZ NewDevWiz
    );



//
// from miscutil.c
//
BOOL
SetClassGuid(
    HDEVINFO hDeviceInfo,
    PSP_DEVINFO_DATA DeviceInfoData,
    LPGUID ClassGuid
    );


#define SDT_MAX_TEXT         1024        // Max SetDlgText

void
SetDlgText(
   HWND hDlg,
   int iControl,
   int nStartString,
   int nEndString
   );

void
LoadText(
   PTCHAR szText,
   int SizeText,
   int nStartString,
   int nEndString
   );

VOID
_OnSysColorChange(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
NoPrivilegeWarning(
   HWND hWnd
   );

LONG
NdwBuildClassInfoList(
   PNEWDEVWIZ NewDevWiz,
   DWORD ClassListFlags
   );

void
HideWindowByMove(
   HWND hDlg
   );

LONG
NdwUnhandledExceptionFilter(
   struct _EXCEPTION_POINTERS *ExceptionPointers
   );

HPROPSHEETPAGE
CreateWizExtPage(
   int PageResourceId,
   DLGPROC pfnDlgProc,
   PNEWDEVWIZ NewDevWiz
   );

BOOL
AddClassWizExtPages(
   HWND hwndParentDlg,
   PNEWDEVWIZ NewDevWiz,
   PSP_NEWDEVICEWIZARD_DATA DeviceWizardData,
   DI_FUNCTION InstallFunction,
   HPROPSHEETPAGE hIntroPage
   );

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    );

BOOL
pVerifyUpdateDriverInfoPath(
    PNEWDEVWIZ NewDevWiz
    );

BOOL
RemoveDir(
    PTSTR Path
    );

void
RemoveCdmDirectory(
    PTSTR CdmDirectory
    );

BOOL
pSetupGetDriverDate(
    IN     PCTSTR     DriverVer,
    IN OUT PFILETIME  pFileTime
    );

BOOL
IsInternetAvailable(
    HMODULE *hCdmInstance
    );

void
CdmLogDriverNotFound(
    HMODULE hCdmInstance,
    HANDLE  hContext,
    LPCTSTR DeviceInstanceId,
    DWORD   Flags
    );

void
CdmCancelCDMOperation(
    HMODULE hCdmInstance
    );

BOOL
GetInstalledInf(
    IN     DEVNODE DevNode,           OPTIONAL
    IN     PTSTR   DeviceInstanceId,  OPTIONAL
    IN OUT PTSTR   InfFile,
    IN OUT DWORD   *Size
    );

BOOL
IsInfFromOem(
    IN  PCTSTR                InfFile
    );

BOOL
IsConnectedToInternet(
    void
    );

BOOL
GetLogPnPIdPolicy(
    void
    );

DWORD
GetSearchOptions(
    void
    );

VOID
SetSearchOptions(
    DWORD SearchOptions
    );

BOOL
IsInstallComplete(
    HDEVINFO         hDevInfo,
    PSP_DEVINFO_DATA DeviceInfoData
    );

BOOL
GetIsWow64 (
    VOID
    );

BOOL
OpenCdmContextIfNeeded(
    HMODULE *hCdmInstance,
    HANDLE *hCdmContext
    );

BOOL
pSetSystemRestorePoint(
    BOOL Begin,
    BOOL CancelOperation,
    int RestorePointResourceId
    );

BOOL
GetProcessorExtension(
    LPTSTR ProcessorExtension,
    DWORD  ProcessorExtensionSize
    );

BOOL
GetGuiSetupInProgress(
    VOID
    );

DWORD
GetBusInformation(
    DEVNODE DevNode
    );

PTCHAR
BuildFriendlyName(
    DEVINST DevInst,
    BOOL UseNewDeviceDesc,
    HMACHINE hMachine
    );

extern TCHAR szUnknownDevice[64];
extern TCHAR szUnknown[64];
extern int g_BlankIconIndex;
extern HMODULE hSrClientDll;
extern HMODULE hNewDev;
extern BOOL GuiSetupInProgress;

//
// newdev.c, init.c
//
BOOL
InstallDevInst(
   HWND hwndParent,
   LPCWSTR DeviceInstanceId,
   BOOL UpdateDriver,
   PDWORD pReboot
   );

BOOL
InstallNewDevice(
   HWND hwndParent,
   LPGUID ClassGuid,
   PDWORD pReboot
   );



//
// finish.c
//
BOOL
IsNullDriverInstalled(
    DEVNODE DevNode
    );

DWORD
InstallNullDriver(
   PNEWDEVWIZ NewDevWiz,
   BOOL FailedInstall
   );

//
// update.c
//
void
SetDriverDescription(
    HWND hDlg,
    int iControl,
    PNEWDEVWIZ NewDevWiz
    );

void
InstallSilentChilds(
   HWND hwndParent,
   PNEWDEVWIZ NewDevWiz
   );

void
SendMessageToUpdateBalloonInfo(
    PTSTR DeviceDesc
    );



//
// Driver search options
//
#define SEARCH_CURRENTDRIVER            0x00000001  // Get the currently installed driver.
#define SEARCH_DEFAULT                  0x00000002  // Search all Default INFs (in %windir%\INF)
#define SEARCH_FLOPPY                   0x00000004  // Search all INFs on all Floppies on the system
#define SEARCH_CDROM                    0x00000008  // Search all INFs on all CD-ROMs on the system
#define SEARCH_DIRECTORY                0x00000010  // Search all INFs in NewDevWiz->BrowsePath directory
#define SEARCH_INET                     0x00000020  // Tell Setupapi to call CDM.DLL to see if the
                                                    //  WU web site has updated drivers for this device.
#define SEARCH_WINDOWSUPDATE            0x00000040  // Search all INFs in NewDevWiz->BrowsePath, but tell
                                                    //  SETUPAPI.DLL that they are from the Internet.
#define SEARCH_SINGLEINF                0x00000080  // Just search INF in NewDevWiz->SingleInfPath
#define SEARCH_INET_IF_CONNECTED        0x00000200  // If the machine is connected to the Internet and WU
                                                    // appears to have the best driver then basically do
                                                    // a SEARCH_INET.

//
// Balloon Tip flags
//
#define TIP_LPARAM_IS_DEVICEINSTANCEID  0x00000001  // lParam is a DeviceInstanceId and not just text
#define TIP_PLAY_SOUND                  0x00000002  // play sound when balloon info is displayed
#define TIP_HIDE_BALLOON                0x00000004  // Hide the balloon

//
// Driver List Flags
//
#define DRIVER_LIST_CURRENT_DRIVER      0x00000001  // This is the currently installed driver
#define DRIVER_LIST_SELECTED_DRIVER     0x00000002  // This is the selected/best driver in the list
#define DRIVER_LIST_SIGNED_DRIVER       0x00000004  // This driver is digitally signed.
#define DRIVER_LIST_AUTHENTICODE_DRIVER 0x00000008  // This driver is Authenticode signed.

//
// Private window messages
//
#define WUM_SEARCHDRIVERS           (WM_USER+279)
#define WUM_INSTALLCOMPLETE         (WM_USER+280)
#define WUM_UPDATEUI                (WM_USER+281)
#define WUM_EXIT                    (WM_USER+282)
#define WUM_INSTALLPROGRESS         (WM_USER+283)
#define WUM_STARTINTERNETDOWNLOAD   (WM_USER+284)
#define WUM_ENDINTERNETDOWNLOAD     (WM_USER+285)


//
// Private device install notifications
//
// 0 is used by setupapi to signify the begining of processing a file queue.
// 1 is used by setupapi to notify us that it has processed one file.
//
#define INSTALLOP_COPY          0x00000100
#define INSTALLOP_RENAME        0x00000101
#define INSTALLOP_DELETE        0x00000102
#define INSTALLOP_BACKUP        0x00000103
#define INSTALLOP_SETTEXT       0x00000104

//
// The wizard dialog procs
//
INT_PTR CALLBACK IntroDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK FinishInstallIntroDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NDW_PickClassDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NDW_InstallDevDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NDW_FinishDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NDW_SelectDeviceDlgProc(HWND hDlg,UINT wMsg,WPARAM wParam,LPARAM lParam);

LRESULT CALLBACK BalloonInfoProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK AdvancedSearchDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DriverSearchingDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK WUPromptDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK InstallNewDeviceDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK ListDriversDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK UseCurrentDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NoDriverDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK WizExtSelectDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK WizExtSelectEndDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK WizExtFinishInstallDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK WizExtFinishInstallEndDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam,LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\newdev\update.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       update.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"

#define INSTALL_UI_TIMERID  1423

PROCESS_DEVICEMAP_INFORMATION ProcessDeviceMapInfo={0};

//
// returns TRUE if we were able to find a reasonable name
// (something besides unknown device).
//
void
SetDriverDescription(
    HWND hDlg,
    int iControl,
    PNEWDEVWIZ NewDevWiz
    )
{
    PTCHAR FriendlyName;
    SP_DRVINFO_DATA DriverInfoData;

    //
    // If there is a selected driver use its driver description,
    // since this is what the user is going to install.
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 )
        &&
        *(DriverInfoData.Description)) {

        StringCchCopy(NewDevWiz->DriverDescription,
                      SIZECHARS(NewDevWiz->DriverDescription),
                      DriverInfoData.Description);
        SetDlgItemText(hDlg, iControl, NewDevWiz->DriverDescription);
        return;
    }


    FriendlyName = BuildFriendlyName(NewDevWiz->DeviceInfoData.DevInst, FALSE, NULL);
    if (FriendlyName) {

        SetDlgItemText(hDlg, iControl, FriendlyName);
        LocalFree(FriendlyName);
        return;
    }

    SetDlgItemText(hDlg, iControl, szUnknown);

    return;
}

BOOL
IntializeDeviceMapInfo(
   void
   )
/*++

Routine Description:

    Initializes\Updates the global ProcessDeviceMapInfo which is
    used by GetNextDriveByType().

Arguments:

    none

Return Value:

    TRUE if we can get the device map information, FALSE otherwise.   

--*/
{
    NTSTATUS Status;

    Status = NtQueryInformationProcess(NtCurrentProcess(),
                                       ProcessDeviceMap,
                                       &ProcessDeviceMapInfo.Query,
                                       sizeof(ProcessDeviceMapInfo.Query),
                                       NULL
                                       );
    if (!NT_SUCCESS(Status)) {

        RtlZeroMemory(&ProcessDeviceMapInfo, sizeof(ProcessDeviceMapInfo));
        return FALSE;
    }

    return TRUE;
}

UINT
GetNextDriveByType(
    UINT DriveType,
    UINT DriveNumber
    )
/*++

Routine Description:

   Inspects each drive starting from DriveNumber in ascending order to find the
   first drive of the specified DriveType from the global ProcessDeviceMapInfo.
   The ProcessDeviceMapInfo must have been intialized and may need refreshing before
   invoking this function. Invoke IntializeDeviceMapInfo to initialize or update
   the DeviceMapInfo.

Arguments:

   DriveType - DriveType as defined in winbase, GetDriveType().

   DriveNumber - Starting DriveNumber, 1 based.

Return Value:

   DriveNumber - if nonzero Drive found, 1 based.

--*/
{

    //
    // OneBased DriveNumber to ZeroBased.
    //
    DriveNumber--;
    while (DriveNumber < 26) {

        if ((ProcessDeviceMapInfo.Query.DriveMap & (1<< DriveNumber)) &&
             ProcessDeviceMapInfo.Query.DriveType[DriveNumber] == DriveType) {

            return DriveNumber+1; // return 1 based DriveNumber found.
        }

        DriveNumber++;
    }

    return 0;
}

void
InstallSilentChildSiblings(
   HWND hwndParent,
   PNEWDEVWIZ NewDevWiz,
   DEVINST DeviceInstance
   )
{
    CONFIGRET ConfigRet;
    DEVINST ChildDeviceInstance;
    ULONG Ulong, ulValue;
    BOOL NeedsInstall, IsSilent;

    do {
        //
        // Assume the device is not a silent install.
        //
        IsSilent = FALSE;
        
        //
        // Check if the device should be silently installed by seeing if the
        // CM_DEVCAP_SILENTINSTALL capability flag is set.
        //
        Ulong = sizeof(ulValue);
        ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                        CM_DRP_CAPABILITIES,
                                                        NULL,
                                                        (PVOID)&ulValue,
                                                        &Ulong,
                                                        0,
                                                        NULL
                                                        );

        if (ConfigRet == CR_SUCCESS && (ulValue & CM_DEVCAP_SILENTINSTALL)) {

            IsSilent = TRUE;
        }

        if (IsSilent) {
            //
            // The device is a silent install device, so now check if it
            // needs to be installed.  
            // A device needs to be installed if it has the 
            // CONFIGFLAG_FINISH_INSTALL flag set, or if it has the problems
            // CM_PROB_REINSTALL or CM_PROB_NOT_CONFIGURED.
            //
            Ulong = sizeof(ulValue);
            ConfigRet = CM_Get_DevNode_Registry_Property_Ex(DeviceInstance,
                                                            CM_DRP_CONFIGFLAGS,
                                                            NULL,
                                                            (PVOID)&ulValue,
                                                            &Ulong,
                                                            0,
                                                            NULL
                                                            );

            if (ConfigRet == CR_SUCCESS && (ulValue & CONFIGFLAG_FINISH_INSTALL)) {

                NeedsInstall = TRUE;

            } else {

                ConfigRet = CM_Get_DevNode_Status(&Ulong,
                                                  &ulValue,
                                                  DeviceInstance,
                                                  0
                                                  );

                NeedsInstall = ConfigRet == CR_SUCCESS &&
                               (ulValue == CM_PROB_REINSTALL ||
                                ulValue == CM_PROB_NOT_CONFIGURED
                                );
            }


            if (NeedsInstall) {
                //
                // Install the device by calling InstallDevInst.
                //
                TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];

                ConfigRet = CM_Get_Device_ID(DeviceInstance,
                                            DeviceInstanceId,
                                            SIZECHARS(DeviceInstanceId),
                                            0
                                            );

                if (ConfigRet == CR_SUCCESS) {

                    if (InstallDevInst(hwndParent,
                                       DeviceInstanceId,
                                       FALSE,  
                                       &Ulong
                                       )) {

                        NewDevWiz->Reboot |= Ulong;
                    }


                    //
                    // If this devinst has children, then recurse to install 
                    // them as well.
                    //
                    ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance,
                                                DeviceInstance,
                                                0,
                                                NULL
                                                );

                    if (ConfigRet == CR_SUCCESS) {

                        InstallSilentChildSiblings(hwndParent, NewDevWiz, ChildDeviceInstance);
                    }
                }
            }
        }


        //
        // Next sibling ...
        //
        ConfigRet = CM_Get_Sibling_Ex(&DeviceInstance,
                                      DeviceInstance,
                                      0,
                                      NULL
                                      );

    } while (ConfigRet == CR_SUCCESS);
}

void
InstallSilentChilds(
   HWND hwndParent,
   PNEWDEVWIZ NewDevWiz
   )
{
    CONFIGRET ConfigRet;
    DEVINST ChildDeviceInstance;

    ConfigRet = CM_Get_Child_Ex(&ChildDeviceInstance,
                                NewDevWiz->DeviceInfoData.DevInst,
                                0,
                                NULL
                                );

    if (ConfigRet == CR_SUCCESS) {

        InstallSilentChildSiblings(hwndParent, NewDevWiz, ChildDeviceInstance);
    }
}

void
SendMessageToUpdateBalloonInfo(
    PTSTR DeviceDesc
    )
{
    HWND hBalloonInfoWnd;
    COPYDATASTRUCT cds;

    hBalloonInfoWnd = FindWindow(NEWDEV_CLASS_NAME, NULL);

    if (hBalloonInfoWnd) {

        cds.dwData = 0;
        cds.cbData = (lstrlen(DeviceDesc) + 1) * sizeof(TCHAR);
        cds.lpData = DeviceDesc;

        SendMessage(hBalloonInfoWnd, WM_COPYDATA, 0, (LPARAM)&cds);
    }
}

void
UpdateBalloonInfo(
    HWND hWnd,
    PTSTR DeviceDesc    OPTIONAL,
    DEVINST DevInst     OPTIONAL,
    BOOL bPlaySound
    )
{
    PTCHAR FriendlyName = NULL;
    NOTIFYICONDATA nid;

    ZeroMemory(&nid, sizeof(nid));
    nid.cbSize = sizeof(nid);
    nid.hWnd = hWnd;
    nid.uID = 1;                                       

    if (DeviceDesc || DevInst) {
        if (DeviceDesc) {
            //
            // First use the DeviceDesc string that is passed into this API
            //
            StringCchCopy(nid.szInfo, SIZECHARS(nid.szInfo), DeviceDesc);
        
        } else if ((FriendlyName = BuildFriendlyName(DevInst, TRUE, NULL)) != NULL) {
            //
            // If no DeviceDesc string was passed in then use the DevInst to get
            // the Device's FriendlyName or DeviceDesc property
            //
            StringCchCopy(nid.szInfo, SIZECHARS(nid.szInfo), FriendlyName);
            LocalFree(FriendlyName);
        
        } else {
            //
            // If we could not get a friendly name for the device or no device was specified
            // so just display the Searching... text.
            //
            LoadString(hNewDev, IDS_NEWSEARCH, nid.szInfo, SIZECHARS(nid.szInfo));
        }
    
        nid.uFlags = NIF_INFO;
        nid.uTimeout = 60000;
        nid.dwInfoFlags = NIIF_INFO | (bPlaySound ? 0 : NIIF_NOSOUND);
        LoadString(hNewDev, IDS_FOUNDNEWHARDWARE, nid.szInfoTitle, SIZECHARS(nid.szInfoTitle));
        Shell_NotifyIcon(NIM_MODIFY, &nid);
    }
}

LRESULT CALLBACK
BalloonInfoProc(
    HWND   hWnd,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
   )
{
    static HICON hNewDevIcon = NULL;
    static BOOL bCanExit;
    NOTIFYICONDATA nid;
    
    switch (message) {
     
    case WM_CREATE:
        hNewDevIcon = LoadImage(hNewDev, 
                                MAKEINTRESOURCE(IDI_NEWDEVICEICON), 
                                IMAGE_ICON,
                                GetSystemMetrics(SM_CXSMICON),
                                GetSystemMetrics(SM_CYSMICON),
                                0
                                );

        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = 1;
        nid.hIcon = hNewDevIcon;

        nid.uVersion = NOTIFYICON_VERSION;
        Shell_NotifyIcon(NIM_SETVERSION, &nid);

        nid.uFlags = NIF_ICON;
        Shell_NotifyIcon(NIM_ADD, &nid);

        //
        // We want the tray icon to be displayed for at least 3 seconds otherwise it flashes too 
        // quickly and a user can't see it.
        //
        bCanExit = FALSE;
        SetTimer(hWnd, INSTALL_UI_TIMERID, 3000, NULL);
        break;

    case WM_DESTROY: {

        ZeroMemory(&nid, sizeof(nid));
        nid.cbSize = sizeof(nid);
        nid.hWnd = hWnd;
        nid.uID = 1;
        Shell_NotifyIcon(NIM_DELETE, &nid);

        if (hNewDevIcon) {

            DestroyIcon(hNewDevIcon);
        }

        break;
    }

    case WM_TIMER:
        if (INSTALL_UI_TIMERID == wParam) {
            //
            // At this point the tray icon has been displayed for at least 3 
            // seconds so we can exit whenever we are finished.  If bCanExit is 
            // already TRUE then we have already been asked to exit so just do a 
            // DestroyWindow at this point, otherwise set bCanExit to TRUE so we 
            // can exit when we are finished installing devices.
            //
            if (bCanExit) {
            
                DestroyWindow(hWnd);

            } else {
                
                KillTimer(hWnd, INSTALL_UI_TIMERID);
                bCanExit = TRUE;
            }
        }
        break;

    case WUM_UPDATEUI:
        if (wParam & TIP_HIDE_BALLOON) {
            //
            // Hide the balloon.
            //
            ZeroMemory(&nid, sizeof(nid));
            nid.cbSize = sizeof(nid);
            nid.hWnd = hWnd;
            nid.uID = 1;                                       
            nid.uFlags = NIF_INFO;
            nid.uTimeout = 0;
            nid.dwInfoFlags = NIIF_INFO;
            Shell_NotifyIcon(NIM_MODIFY, &nid);

        } else if (wParam & TIP_LPARAM_IS_DEVICEINSTANCEID) {
            //
            // The lParam is a DeviceInstanceID.  Convert it to a devnode
            // and then call UpdateBalloonInfo.
            //
            DEVINST DevInst = 0;

            if (lParam &&
                (CM_Locate_DevNode(&DevInst,
                                  (PTSTR)lParam,
                                  CM_LOCATE_DEVNODE_NORMAL
                                  ) == CR_SUCCESS)) {
                UpdateBalloonInfo(hWnd, 
                                  NULL, 
                                  DevInst, 
                                  (wParam & TIP_PLAY_SOUND) ? TRUE : FALSE
                                  );
            }
        } else {
            //
            // The lParam is plain text (device description).  Send it directly
            // to UpdateBalloonInfo.
            //
            UpdateBalloonInfo(hWnd, 
                              (PTSTR)lParam, 
                              0, 
                              (wParam & TIP_PLAY_SOUND) ? TRUE : FALSE
                              );
        }
        break;

    case WM_COPYDATA:
    {
        //
        // This is the case where we needed to launch another instance of 
        // newdev.dll with Admin credentials to do the actuall device install.  
        // In order for it to update the UI it will send the main newdev.dll a 
        // WM_COPYDATA message which will contain the string to display in the 
        // balloon tooltip.
        //
        PCOPYDATASTRUCT pcds = (PCOPYDATASTRUCT)lParam;

        if (pcds && pcds->lpData) {

            //
            // We assume that the lParam is plain text since the main newdev.dll 
            // updated the balloon initially with the DeviceDesc.
            //
            UpdateBalloonInfo(hWnd, (PTSTR)pcds->lpData, 0, FALSE);
        }
        
        break;
    }

    case WUM_EXIT:
        if (bCanExit) {
        
            DestroyWindow(hWnd);
        } else {

            ShowWindow(hWnd, SW_SHOW);
            bCanExit = TRUE;
        }
        break;

    default:
        break;

    }

    return DefWindowProc(hWnd, message, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\newdev\search.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation
//
//  File:       search.c
//
//--------------------------------------------------------------------------

#include "newdevp.h"
#include <infstr.h>

typedef struct _DirectoryNameList {
   struct _DirectoryNameList *Next;
   UNICODE_STRING DirectoryName;
   WCHAR NameBuffer[1];
} DIRNAMES, *PDIRNAMES;


WCHAR StarDotStar[]=L"*.*";


BOOL
IsSearchCanceled(
    PNEWDEVWIZ NewDevWiz
    )
{
    DWORD Result;

    //
    // If the caller doesn't pass us a cancel event then that just means they can't
    // cancel the search.
    //
    if (!NewDevWiz->CancelEvent) {

        return FALSE;
    }

    Result = WaitForSingleObject(NewDevWiz->CancelEvent, 0);

    //
    // If Result is WAIT_OBJECT_0 then someone set the event.  This means that
    // we should cancel the driver search.
    //
    if (Result == WAIT_OBJECT_0) {

        return TRUE;
    }

    return FALSE;
}

void
GetDriverSearchPolicy(
    PULONG SearchPolicy
    )
{
    HKEY hKey;
    DWORD CurrentPolicy;
    ULONG cbData;

    //
    // Assume that all search locations are valid.
    //
    *SearchPolicy = 0;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, 
                     TEXT("Software\\Policies\\Microsoft\\Windows\\DriverSearching"),
                     0,
                     KEY_READ,
                     &hKey
                     ) == ERROR_SUCCESS) {

        //
        // Check if we can search the CD
        //
        CurrentPolicy = 0;
        cbData = sizeof(CurrentPolicy);
        if ((RegQueryValueEx(hKey,
                             TEXT("DontSearchCD"),
                             NULL,
                             NULL,
                             (LPBYTE)&CurrentPolicy,
                             &cbData
                             ) == ERROR_SUCCESS) &&
            (CurrentPolicy)) {

            *SearchPolicy |= SEARCH_CDROM;
        }

        //
        // Check if we can search the Floppies
        //
        CurrentPolicy = 0;
        cbData = sizeof(CurrentPolicy);
        if ((RegQueryValueEx(hKey,
                             TEXT("DontSearchFloppies"),
                             NULL,
                             NULL,
                             (LPBYTE)&CurrentPolicy,
                             &cbData
                             ) == ERROR_SUCCESS) &&
            (CurrentPolicy)) {

            *SearchPolicy |= SEARCH_FLOPPY;
        }

        CurrentPolicy = 0;
        cbData = sizeof(CurrentPolicy);
        if ((RegQueryValueEx(hKey,
                             TEXT("DontSearchWindowsUpdate"),
                             NULL,
                             NULL,
                             (LPBYTE)&CurrentPolicy,
                             &cbData
                             ) == ERROR_SUCCESS) &&
            (CurrentPolicy)) {

            *SearchPolicy |= SEARCH_INET;
            *SearchPolicy |= SEARCH_INET_IF_CONNECTED;
        }

        RegCloseKey(hKey);
    }
}

DWORD
GetWUDriverRank(
    PNEWDEVWIZ NewDevWiz,
    LPTSTR HardwareId
    )
{
    DWORD Rank = 0xFFFF;
    TCHAR TempBuffer[REGSTR_VAL_MAX_HCID_LEN];
    ULONG TempBufferLen;
    LPTSTR TempBufferPos;
    int RankCounter;

    //
    // First of all we will start off with a Rank of 0xFFFF which is the worst possible.
    // 
    // We will assume that WU will only return an INF Hardware Id match to us.  This means
    // that if we match against one of the device's HardwareIds then Rank will be between
    // 0x0000 and 0x0999.  Otherwise if we match against one of the device's Compatible Ids
    // then the Rank will be between 0x2000 and 0x2999.
    //
    ZeroMemory(TempBuffer, sizeof(TempBuffer));
    TempBufferLen = sizeof(TempBuffer);
    if (CM_Get_DevInst_Registry_Property(NewDevWiz->DeviceInfoData.DevInst,
                                         CM_DRP_HARDWAREID,
                                         NULL,
                                         TempBuffer,
                                         &TempBufferLen,
                                         0
                                         ) == CR_SUCCESS) {

        if (TempBufferLen > 2 * sizeof(TCHAR)) {

            RankCounter = 0x0000;
            for (TempBufferPos = TempBuffer; 
                 *TempBufferPos;
                 TempBufferPos += (lstrlen(TempBufferPos) + 1), RankCounter++) {

                if (!lstrcmpi(TempBufferPos, HardwareId)) {

                    //
                    // Matched against a Hardware Id
                    //
                    Rank = RankCounter;
                    break;
                }
            }
        }
    }

    if (Rank == 0xFFFF) {
        
        // 
        // We didn't match against a HardwareId so let's go through the Compatible Ids
        //
        ZeroMemory(TempBuffer, sizeof(TempBuffer));
        TempBufferLen = sizeof(TempBuffer);
        if (CM_Get_DevInst_Registry_Property(NewDevWiz->DeviceInfoData.DevInst,
                                             CM_DRP_COMPATIBLEIDS,
                                             NULL,
                                             TempBuffer,
                                             &TempBufferLen,
                                             0
                                             ) == CR_SUCCESS) {

            if (TempBufferLen > 2 * sizeof(TCHAR)) {

                RankCounter = 0x2000;
                for (TempBufferPos = TempBuffer; 
                     *TempBufferPos;
                     TempBufferPos += (lstrlen(TempBufferPos) + 1), RankCounter++) {

                    if (!lstrcmpi(TempBufferPos, HardwareId)) {

                        //
                        // Matcheds against a compatible Id
                        //
                        Rank = RankCounter;
                        break;
                    }
                }
            }
        }
    }

    return Rank;
}

BOOL
IsWUDriverBetter(
    PNEWDEVWIZ NewDevWiz,
    LPTSTR HardwareId,
    LPTSTR DriverVer
    )
{
    BOOL bWUDriverIsBetter = FALSE;
    DWORD WURank;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;
    FILETIME WUFileTime;

    //
    // WU must at least give us a Hardware Id to compare against.
    //
    if (!HardwareId) {
        
        return FALSE;
    }

    //
    // If we can't get the selected driver then return TRUE.  This will
    // usually happen if we did not find a local driver.
    //
    DriverInfoData.cbSize = sizeof(DriverInfoData);
    if (!SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  &DriverInfoData
                                  )) {
        
        return TRUE;
    }

    //
    // Get the Driver Install Params so we can get the Rank of the selected (best)
    // driver.
    //
    DriverInstallParams.cbSize = sizeof(DriverInstallParams);
    if (!SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       &DriverInfoData,
                                       &DriverInstallParams
                                       )) {

        return TRUE;
    }

    //
    // Get the Rank of the HardwareId that WU returned to us.
    //
    WURank = GetWUDriverRank(NewDevWiz, HardwareId);

    if (WURank < DriverInstallParams.Rank) {

        bWUDriverIsBetter = TRUE;
    
    } else if (WURank == DriverInstallParams.Rank) {

        //
        // Need to compare the DriverDates.
        //
        if (pSetupGetDriverDate(DriverVer,
                                &WUFileTime
                                )) {

            //
            // If CompareFileTime returns 1 then the best driver date is larger.  If
            // it returns 0 or -1 then the dates are the same or the WUFileTime is
            // better, which means we should download this driver.
            //
            if (CompareFileTime(&DriverInfoData.DriverDate, &WUFileTime) != 1) {

                bWUDriverIsBetter = TRUE;
            }
        }
    }

    //
    // default is that the Best driver found is better than the WUDriver.
    //

    return bWUDriverIsBetter;
}

BOOL
SearchWindowsUpdateCache(
    PNEWDEVWIZ NewDevWiz
    )
{
    ULONG DontSearchPolicy = 0;
    FIND_MATCHING_DRIVER_PROC pfnFindMatchingDriver;
    DOWNLOADINFO DownloadInfo;
    WUDRIVERINFO WUDriverInfo;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    BOOL FoundBetterDriver = FALSE;

    //
    // Verify that this user is allowed to search Windows Update before we continue.
    //
    GetDriverSearchPolicy(&DontSearchPolicy);

    if (DontSearchPolicy & SEARCH_INET) {
        //
        // This user is NOT allowed to search Windows Update!
        //
        return FALSE;
    }

    //
    // Check if the search has been canceled.
    //
    if (IsSearchCanceled(NewDevWiz)) {
        goto clean0;
    }

    //
    // Load the Cdm DLL and open a context handle if needed.  If we can't then
    // bail out.
    //
    if (!OpenCdmContextIfNeeded(&NewDevWiz->hCdmInstance,
                                &NewDevWiz->hCdmContext
                                )) {
        goto clean0;
    }

    //
    // Check if the search has been canceled.
    //
    if (IsSearchCanceled(NewDevWiz)) {
        goto clean0;
    }

    pfnFindMatchingDriver = (FIND_MATCHING_DRIVER_PROC)GetProcAddress(NewDevWiz->hCdmInstance,
                                                                      "FindMatchingDriver"
                                                                      );

    if (!pfnFindMatchingDriver) {
        goto clean0;
    }
    //
    // First select the best driver in the list of drivers we have built so far
    //
    SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                              NewDevWiz->hDeviceInfo,
                              &NewDevWiz->DeviceInfoData
                              );

    //
    // Fill in the DOWNLOADINFO structure to pass to CDM.DLL
    //
    ZeroMemory(&DownloadInfo, sizeof(DownloadInfo));
    DownloadInfo.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
    DownloadInfo.lpFile = NULL;

    DeviceInstanceId[0] = TEXT('\0');
    CM_Get_Device_ID(NewDevWiz->DeviceInfoData.DevInst,
                     DeviceInstanceId,
                     SIZECHARS(DeviceInstanceId),
                     0
                     );

    DownloadInfo.lpDeviceInstanceID = (LPCTSTR)DeviceInstanceId;

    GetVersionEx((OSVERSIONINFO*)&DownloadInfo.OSVersionInfo);

    //
    // Set dwArchitecture to PROCESSOR_ARCHITECTURE_UNKNOWN, this
    // causes Windows Update to get the architecture of the machine
    // itself.  
    //
    DownloadInfo.dwArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
    DownloadInfo.dwFlags = 0;
    DownloadInfo.dwClientID = 0;
    DownloadInfo.localid = 0;

    //
    // Fill in the WUDRIVERINFO structure to pass to CDM.DLL
    //
    ZeroMemory(&WUDriverInfo, sizeof(WUDriverInfo));
    WUDriverInfo.dwStructSize = sizeof(WUDRIVERINFO);

    //
    // Check if the search has been canceled.
    //
    if (IsSearchCanceled(NewDevWiz)) {
        goto clean0;
    }

    if (pfnFindMatchingDriver(NewDevWiz->hCdmContext,
                              &DownloadInfo,
                              &WUDriverInfo
                              )) {

        //
        // Check to see if the WU Driver is better than the best selected
        // driver.
        //
        FoundBetterDriver = IsWUDriverBetter(NewDevWiz,
                                             WUDriverInfo.wszHardwareID,
                                             WUDriverInfo.wszDriverVer
                                             );
    }

clean0:
    ;


    return FoundBetterDriver;
}

void
DoDriverSearchInSpecifiedLocations(
    HWND hWnd,
    PNEWDEVWIZ NewDevWiz,
    ULONG SearchOptions,
    DWORD DriverType
    )
/*++


--*/
{
    SP_DEVINSTALL_PARAMS DeviceInstallParams;

    //
    // Set the Device Install Params to set the parent window handle.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      ))
    {
        DeviceInstallParams.hwndParent = hWnd;
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;
        
        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }


    //
    // Search any single INFs (this only comes in through the 
    // UpdateDriverForPlugAndPlayDevices API.  
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_SINGLEINF)) {

        SP_DRVINFO_DATA DrvInfoData;

        if (SetDriverPath(NewDevWiz, NewDevWiz->SingleInfPath)) {
            //
            // OR in the DI_ENUMSINGLEINF flag so that we only look at this specific INF
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                DeviceInstallParams.Flags |= DI_ENUMSINGLEINF;
    
                SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              );
            }        
            
            //
            // Build up the list in this specific INF file
            //
            SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       DriverType
                                       );
    
            //
            // Clear the DI_ENUMSINGLEINF flag in case we build from the default 
            // INF path next.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                DeviceInstallParams.Flags &= ~DI_ENUMSINGLEINF;
    
                SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              );
            }        
    
            //
            // At this point we should have a list of drivers in the INF that the caller
            // of the UpdateDriverForPlugAndPlayDevices specified.  If the list is empty
            // then the INF they passed us cannot be used on the Hardware Id that they
            // passed in.  In this case we will SetLastError to ERROR_DI_BAD_PATH.
            //
            ZeroMemory(&DrvInfoData, sizeof(DrvInfoData));
            DrvInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    
            if (!SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      DriverType,
                                      0,
                                      &DrvInfoData
                                      )) {
    
                //
                // We wern't able to find any drivers in the specified INF that match
                // the specified hardware ID.
                //
                NewDevWiz->LastError = ERROR_DI_BAD_PATH;
            }
        }
    }

    //
    // Get the currently installed driver for this device only
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_CURRENTDRIVER)) {

        if (SetDriverPath(NewDevWiz, NULL)) {
            //
            // Set the DI_FLAGSEX_INSTALLEDDRIVER flag to let setupapi know that we
            // just want the installed driver added to the list.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_INSTALLEDDRIVER;
    
                SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              );
            }        
    
            SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       DriverType
                                       );
    
            //
            // Clear the DI_FLAGSEX_INSTALLEDDRIVER flag now that we have added
            // the installed driver to the list.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_INSTALLEDDRIVER;
    
                SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              );
            }        
        }
    }

    //
    // Search the default INF path
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_DEFAULT))
        
    {
        if (SetDriverPath(NewDevWiz, NULL)) {
            
            SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       DriverType
                                       );
        }
    }

    //
    // Search any extra paths that the user specified in the wizard
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_DIRECTORY)) 
    {
        if (SetDriverPath(NewDevWiz, NewDevWiz->BrowsePath)) {
    
            SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       DriverType
                                       );
        }
    }


    //
    // Search any Windows Update paths.
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_WINDOWSUPDATE)) 
    {
        BOOL bOldInetDriversAllowed = TRUE;

        if (SetDriverPath(NewDevWiz, NewDevWiz->BrowsePath)) {
            //
            // We need to OR in the DI_FLAGSEX_INET_DRIVER flag so that setupapi will
            // mark in the INFs PNF that it is from the Internet.  This is important 
            // because we don't want to ever use an Internet INF again since we don't
            // have the drivers locally.
            //
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                //
                // When searching using Windows Update we must allow old Internet drivers.  We need
                // to do this since it is posible to backup old Internet drivers and then reinstall 
                // them.
                //
                bOldInetDriversAllowed = (DeviceInstallParams.FlagsEx & DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS)
                    ? FALSE : TRUE;
                
                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_INET_DRIVER;
                DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;
    
    
                SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              );
            }        
            
            SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       DriverType
                                       );
    
            if (!bOldInetDriversAllowed) {
    
                //
                // Old Internet drivers were not allowed so we need to reset the DI_FLAGSEX_EXLCUED_OLD_INET_DRIVERS
                // FlagsEx
                //
                DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
                if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                                  &NewDevWiz->DeviceInfoData,
                                                  &DeviceInstallParams
                                                  ))
                {
                    DeviceInstallParams.FlagsEx |= DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS;
    
                    SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                                  &NewDevWiz->DeviceInfoData,
                                                  &DeviceInstallParams
                                                  );
                }        
            }
        }
    }


    //
    // Search all floppy drives
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_FLOPPY) )
    {
        UINT DriveNumber=0;

        while (!IsSearchCanceled(NewDevWiz) &&
               ((DriveNumber = GetNextDriveByType(DRIVE_REMOVABLE, ++DriveNumber)) != 0))
        {
            SearchDriveForDrivers(NewDevWiz, DRIVE_REMOVABLE, DriveNumber);
        }
    }


    //
    // Search all CD-ROM drives
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_CDROM))
    {
        UINT DriveNumber=0;

        while (!IsSearchCanceled(NewDevWiz) &&
               ((DriveNumber = GetNextDriveByType(DRIVE_CDROM, ++DriveNumber)) != 0))
        {
            SearchDriveForDrivers(NewDevWiz, DRIVE_CDROM, DriveNumber);
        }
    }

    //
    // Search the Internet using CDM.DLL, only if the machine is currently connected
    // to the Internet and CDM.DLL says it has the best driver.
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_INET_IF_CONNECTED)) {

        //
        // If the machine is connected to the Internet and the WU cache says it has
        // a better driver then set the SEARCH_INET flag to get the driver from CDM.DLL
        //
        if (IsInternetAvailable(&NewDevWiz->hCdmInstance) &&
            IsConnectedToInternet() &&
            SearchWindowsUpdateCache(NewDevWiz)) {

            SearchOptions |= SEARCH_INET;
        }
    }

    //
    // Search the Internet using CDM.DLL
    //
    if (!IsSearchCanceled(NewDevWiz) && (SearchOptions & SEARCH_INET))
    {
        PostMessage(NewDevWiz->hWnd, WUM_STARTINTERNETDOWNLOAD, TRUE, GetLastError());

        if (SetDriverPath(NewDevWiz, NULL)) {
    
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                DeviceInstallParams.FlagsEx |= DI_FLAGSEX_DRIVERLIST_FROM_URL;
    
                SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              );
            }        
    
            SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       SPDIT_COMPATDRIVER
                                       );
    
            DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
            if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              ))
            {
                DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_DRIVERLIST_FROM_URL;
    
                SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                              &NewDevWiz->DeviceInfoData,
                                              &DeviceInstallParams
                                              );
            }
    
            //
            // NOTE: JasonC 1/20/2002
            // This PostMessage stops the Internet download animation.
            // In the future if this function is changed so that another SEARCH_Xxx
            // operation is done after SEARCH_INET, then the WUM_ENDINTERNETDOWNLOAD
            // message should not only stop the Inetnet download animation, but it
            // should also start up the searching animation again.
            //
            PostMessage(NewDevWiz->hWnd, WUM_ENDINTERNETDOWNLOAD, TRUE, GetLastError());
        }
    }
}

void
DoDriverSearch(
    HWND hWnd,
    PNEWDEVWIZ NewDevWiz,
    ULONG SearchOptions,
    DWORD DriverType,
    BOOL bAppendToExistingDriverList
    )
{
    ULONG DontSearchPolicy;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;

    //
    // The first thing that we do in this code is to Reset the CancelEvent in case it was set 
    // previously.
    //
    if (NewDevWiz->CancelEvent) {
        ResetEvent(NewDevWiz->CancelEvent);
    }

    //
    // Make sure that we filter out the locations that this user is not allowed to search.
    //
    DontSearchPolicy = 0;
    GetDriverSearchPolicy(&DontSearchPolicy);

    SearchOptions &= ~DontSearchPolicy;

    //
    // If the user does not want to append to the existing list then delete the 
    // current driver list.
    //
    if (!bAppendToExistingDriverList) {

        SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     SPDIT_COMPATDRIVER
                                     );
        
        SetupDiDestroyDriverInfoList(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     SPDIT_CLASSDRIVER
                                     );
    }

    //
    // Clear out the selected driver
    //
    SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                             &NewDevWiz->DeviceInfoData,
                             NULL
                             );

    //
    // Set the DI_FLAGSEX_APPENDDRIVERLIST since we will be building a big
    // list.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      ))
    {
        DeviceInstallParams.FlagsEx |= DI_FLAGSEX_APPENDDRIVERLIST;
        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }
    
    //
    // Build up the list of drivers based on the SearchOptions
    //
    DoDriverSearchInSpecifiedLocations(hWnd, NewDevWiz, SearchOptions, DriverType);

    //
    //Pick the best driver from the list we just created
    //
    SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                              NewDevWiz->hDeviceInfo,
                              &NewDevWiz->DeviceInfoData
                              );
    
    if (!IsSearchCanceled(NewDevWiz)) 
    {
        //
        // Update the NewDevWiz->ClassGuidSelected with the class of the selected driver.
        //
        if (!IsEqualGUID(&NewDevWiz->DeviceInfoData.ClassGuid, &GUID_NULL)) {
        
            NewDevWiz->ClassGuidSelected = &NewDevWiz->DeviceInfoData.ClassGuid;
        }

        //
        // Note whether we found multiple drivers or not.
        //
        DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  SPDIT_COMPATDRIVER,
                                  1,
                                  &DriverInfoData
                                  )) {

            NewDevWiz->MultipleDriversFound = TRUE;
        
        } else {
            
            NewDevWiz->MultipleDriversFound = FALSE;

        }
    }

    //
    // Clear the DI_FLAGSEX_APPENDDRIVERLIST flag from the Device Install Params.
    //
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if (SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      ))
    {
        DeviceInstallParams.FlagsEx &= ~DI_FLAGSEX_APPENDDRIVERLIST;
        SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      &DeviceInstallParams
                                      );
    }
}

void
CancelDriverSearch(
    PNEWDEVWIZ NewDevWiz
    )
{
    //
    // First verify that there is a driver search going on by checking that the
    // NewDevWiz->DriverSearchThread is not NULL
    //
    if (NewDevWiz->DriverSearchThread) {

        if (NewDevWiz->CancelEvent) {
        
            //
            // Set the Cancel Event to that the DoDriverSearch() API knows to stop searching.
            //
            SetEvent(NewDevWiz->CancelEvent);
        }

        //
        // Tell cdm.dll to stop it's current operation
        //
        CdmCancelCDMOperation(NewDevWiz->hCdmInstance);
    
        //
        // Tell setupapi.dll to stop it's current driver info search
        //
        SetupDiCancelDriverInfoSearch(NewDevWiz->hDeviceInfo);
    
        //
        // We should always have a window handle if the user was able to cancel.
        //
        if (NewDevWiz->hWnd) {
        
            MSG Msg;
            DWORD WaitReturn;

            //
            // And finaly, wait for the NewDevWiz->DriverSearchThread to terminate
            //
            while ((WaitReturn = MsgWaitForMultipleObjects(1,
                                                           &NewDevWiz->DriverSearchThread,
                                                           FALSE,
                                                           INFINITE,
                                                           QS_ALLINPUT
                                                           ))
                   == WAIT_OBJECT_0 + 1) {

                while (PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE)) {

                    if (!IsDialogMessage(NewDevWiz->hWnd, &Msg)) {

                        TranslateMessage(&Msg);
                        DispatchMessage(&Msg);
                    }
                }
            }
        }
    }
}

BOOL
SetDriverPath(
   PNEWDEVWIZ NewDevWiz,
   PCTSTR     DriverPath
   )
{
    BOOL bRet = TRUE;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;

    DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);
    if (!SetupDiGetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       &DeviceInstallParams
                                       )) {
        bRet = FALSE;
        goto clean0;
    }

    if (FAILED(StringCchCopy(DeviceInstallParams.DriverPath,
                             SIZECHARS(DeviceInstallParams.DriverPath),
                             DriverPath ? DriverPath : L""))) {
        bRet = FALSE;
        goto clean0;
    }

    if (!SetupDiSetDeviceInstallParams(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       &DeviceInstallParams
                                       )) {
        bRet = FALSE;
        goto clean0;
    }

clean0:
    return bRet;
}

void
SearchDirectoryForDrivers(
    PNEWDEVWIZ NewDevWiz,
    PCTSTR Directory
    )
{
    HANDLE FindHandle;
    PDIRNAMES DirNamesHead = NULL;
    PDIRNAMES DirNames, Next;
    USHORT Len;
    WIN32_FIND_DATAW FindData;
    WCHAR DirectoryName[MAX_PATH];

    if (IsSearchCanceled(NewDevWiz)) {
        return;
    }

    //
    // See if there are is anything (files, subdirs) in this dir.
    //
    if (FAILED(StringCchCopy(DirectoryName, SIZECHARS(DirectoryName), Directory)) ||
        !pSetupConcatenatePaths(DirectoryName, StarDotStar, SIZECHARS(DirectoryName), NULL)) {
        return;
    }
    
    FindHandle = FindFirstFileW(DirectoryName, &FindData);
    

    if (FindHandle == INVALID_HANDLE_VALUE) {
        return;
    }

    //
    // There might be inf files so invoke setup to look.
    //
    if (SetDriverPath(NewDevWiz, Directory)) {
        SetupDiBuildDriverInfoList(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       SPDIT_COMPATDRIVER
                                       );
    }

    //
    // find all of the subdirs, and save them in a temporary buffer,
    // so that we can close the find handle *before* going recursive.
    //
    do {

        if (IsSearchCanceled(NewDevWiz)) {
            break;
        }

        if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
            wcscmp(FindData.cFileName, L".") &&
            wcscmp(FindData.cFileName, L".."))
        {
            Len = (USHORT)lstrlen(FindData.cFileName) * sizeof(WCHAR);
            DirNames = malloc(sizeof(DIRNAMES) + Len);
            if (!DirNames) {
                return;
            }

            DirNames->DirectoryName.Length = Len;
            DirNames->DirectoryName.MaximumLength = Len + sizeof(WCHAR);
            DirNames->DirectoryName.Buffer = DirNames->NameBuffer;
            memcpy(DirNames->NameBuffer, FindData.cFileName, Len + sizeof(WCHAR));

            DirNames->Next = DirNamesHead;
            DirNamesHead = DirNames;

        }

    } while (FindNextFileW(FindHandle, &FindData));

    FindClose(FindHandle);

    if (!DirNamesHead) {
        return;
    }

    Next = DirNamesHead;
    while (Next) {

        DirNames = Next;

        if (SUCCEEDED(StringCchCopy(DirectoryName, SIZECHARS(DirectoryName), Directory)) &&
            pSetupConcatenatePaths(DirectoryName, DirNames->DirectoryName.Buffer, SIZECHARS(DirectoryName), NULL)) {

            Next= DirNames->Next;
            free(DirNames);
            SearchDirectoryForDrivers(NewDevWiz, DirectoryName);
        }
    }
}

void
SearchDriveForDrivers(
    PNEWDEVWIZ NewDevWiz,
    UINT DriveType,
    UINT DriveNumber
    )
/*++

Routine Description:

    This routine will return whether or not the specified media should be
    searched for drivers, and it will return the path where the search should
    start.
    
    First the specified driver will be checked for an autorun.inf file. If there
    is an autorun.inf with a [DeviceInstall] section that contains a DriverPath=
    value then we will start the search at the path specified by DriverPath=. 
    If the [DeviceInstall] section does not contain any DriverPath= values then
    the entire drive will be skipped. This is a good way for CD's that do not 
    contain drivers to be excluded from the driver search.
    
    If there is no [DeviceInstall] section of the autorun.inf, or there is no 
    autorun.inf then the following rules apply.
    
    - DRIVE_REMOVABLE - search the entire drive if the drive root is A: or B:,
                        otherwise don't search this media.
                        
    - DRIVE_CDROM - search the entire media if the size is less than 1Gig.
                    This means if the media is a CD then we will search the
                    entire CD, but if it is another larger media source, like a
                    DVD then we will not.  We need to search the entire CD for
                    backwards compatibility even through it takes quite a while.

Arguments:

    NewDevWiz - NEWDEVWIZ structure.
    
    DriveType - specifies the type of drive this is, usually DRIVE_REMOVABLE
                or DRIVE_CDROM.
                
    DriveNumber - number specifiy the drive to search: 0 for A:, 1 for B:, etc.                

    
Return Value:


--*/
{
    TCHAR szAutoRunFile[MAX_PATH];
    TCHAR szSectionName[MAX_PATH];
    TCHAR szDriverPath[MAX_PATH];
    TCHAR szSearchPath[MAX_PATH];
    TCHAR DriveRoot[]=TEXT("a:");
    HINF  hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT Context;
    UINT  ErrorLine;
    UINT  PrevMode;

    DriveRoot[0] = ((TCHAR)DriveNumber - 1 + DriveRoot[0]);

    PrevMode = SetErrorMode(0);
    SetErrorMode(PrevMode | SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    try {
        
        szSectionName[0] = TEXT('\0');

        //
        // First check the media for a autorun.inf that contains a [DeviceInstall]
        // section with a DriverPath= value.
        //
        if (SUCCEEDED(StringCchCopy(szAutoRunFile, SIZECHARS(szAutoRunFile), DriveRoot)) &&
            pSetupConcatenatePaths(szAutoRunFile, TEXT("autorun.inf"), MAX_PATH, NULL)) {
        
            hInf = SetupOpenInfFile(szAutoRunFile, NULL, INF_STYLE_OLDNT, &ErrorLine);
        
            if (hInf != INVALID_HANDLE_VALUE) {
                
                if (SUCCEEDED(StringCchCopy(szSectionName, SIZECHARS(szSectionName), TEXT("DeviceInstall")))) {
                    //
                    // First try the decorated section.
                    //
                    if (!GetProcessorExtension(szDriverPath, SIZECHARS(szDriverPath)) ||
                        (FAILED(StringCchCat(szSectionName, SIZECHARS(szSectionName), TEXT(".")))) ||
                        (FAILED(StringCchCat(szSectionName, SIZECHARS(szSectionName), szDriverPath))) ||
                        (SetupGetLineCount(hInf, szSectionName) == -1)) {
                        //
                        // Decorated section does not exist so try the undecorated section.
                        //
                        StringCchCopy(szSectionName, SIZECHARS(szSectionName), TEXT("DeviceInstall"));
                        if (SetupGetLineCount(hInf, szSectionName) == -1) {
                            //
                            // There is no [DeviceInstall] section in this autorun.inf
                            //
                            szSectionName[0] = TEXT('\0');
                        }
                    }
                }
            }
        }
    
        //
        // If szSectionName is not 0 then we have a [DeviceInstall] section.  Enumerate
        // this section looking for all of the DriverPath= lines.
        //
        if (szSectionName[0] != TEXT('\0')) {
            if (SetupFindFirstLine(hInf, szSectionName, TEXT("DriverPath"), &Context)) {
                do {
                    //
                    // Process the DriverPath= line.
                    //
                    if (SetupGetStringField(&Context,
                                            1,
                                            szDriverPath,
                                            SIZECHARS(szDriverPath),
                                            NULL)) {
                        //
                        // Search this location recursively.
                        //
                        if (SUCCEEDED(StringCchCopy(szSearchPath, SIZECHARS(szSearchPath), DriveRoot)) &&
                            pSetupConcatenatePaths(szSearchPath, szDriverPath, SIZECHARS(szSearchPath), NULL)) {
                        
                            SearchDirectoryForDrivers(NewDevWiz,  (PCTSTR)szSearchPath);
                        }
                    }
                } while (SetupFindNextMatchLine(&Context, TEXT("DriverPath"), &Context));
            }
    
            //
            // If we had a valid [DeviceInstall] section then we are done.
            //
            goto clean0;
        }
    
        //
        // At this point there either was no autorun.inf, or it didn't contain a 
        // [DeviceInstall] section or the [DeviceInstall] section didn't contain
        // a DriverPath, so just do the default behavior.
        //
        if (DriveType == DRIVE_REMOVABLE) {
            //
            // We only search A: and B: removable drives by default.
            //
            if ((_wcsicmp(DriveRoot, TEXT("a:")) == 0) ||
                (_wcsicmp(DriveRoot, TEXT("b:")) == 0)) {
                //
                // This is probably a floppy disk since it is A: or B: so search
                // the drive.
                //
                SearchDirectoryForDrivers(NewDevWiz,  (PCTSTR)DriveRoot);
            }
        }
    
        if (DriveType == DRIVE_CDROM) {
            //
            // For DRIVE_CDROM drives we will check the media size and if it is 
            // less than 1Gig then we will assume it is a CD media and search it
            // recursively, otherwise we won't search the drive by default.
            //
            ULARGE_INTEGER FreeBytesAvailable;
            ULARGE_INTEGER TotalNumberOfBytes;
    
            if (GetDiskFreeSpaceEx(DriveRoot,
                                 &FreeBytesAvailable,
                                 &TotalNumberOfBytes,
                                 NULL) &&
                (FreeBytesAvailable.HighPart == 0) &&
                (FreeBytesAvailable.LowPart <= 0x40000000)) {
                //
                // There is less than 1Gig of stuff on this disk so it is probably
                // a CD, so search the entire thing.
                //
                SearchDirectoryForDrivers(NewDevWiz,  (PCTSTR)DriveRoot);
            }
        }
    } except(NdwUnhandledExceptionFilter(GetExceptionInformation())) {
        ;
    }

clean0:

    SetErrorMode(PrevMode);

    if (hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
}

BOOL
IsSelectedDriver(
    PNEWDEVWIZ NewDevWiz,
    PSP_DRVINFO_DATA DriverInfoData
    )
/*++

--*/
{
    SP_DRVINFO_DATA SelectedDriverInfoData;

    SelectedDriverInfoData.cbSize = sizeof(SelectedDriverInfoData);
    if (!SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &SelectedDriverInfoData
                                 )) {

        //
        // If we can't get the selected driver then just return FALSE
        //
        return FALSE;
    }

    //
    // Just compare the Reserved fields.  Setupapi sets these to it's actuall
    // memory pointers so if the two reserved fields are the same, then the
    // drivers are the same.
    //
    return (DriverInfoData->Reserved == SelectedDriverInfoData.Reserved);
}

BOOL
IsInstalledDriver(
   PNEWDEVWIZ NewDevWiz,
   PSP_DRVINFO_DATA DriverInfoData  OPTIONAL
   )
/*++
    Determines if the currently selected driver is the
    currently installed driver. By comparing DriverInfoData
    and DriverInfoDetailData.
    
--*/
{
    BOOL bReturn;
    HKEY  hDevRegKey;
    DWORD cbData;
    PWCHAR pwch;
    SP_DRVINFO_DATA SelectedDriverInfoData;
    PSP_DRVINFO_DATA BestDriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    TCHAR Buffer[MAX_PATH*2];

    //
    // Use the PSP_DRVINFO_DATA that was passed in.  If one wasn't passed in the get the
    // selected driver.
    //
    if (DriverInfoData) {

        BestDriverInfoData = DriverInfoData;
    
    } else {

        SelectedDriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     &SelectedDriverInfoData
                                     )) {

            BestDriverInfoData = &SelectedDriverInfoData;

        } else {
            
            //
            // If there is no currently selected driver then it can't be the installed one
            //
            return FALSE;
        }
    }

    bReturn = FALSE;

    //
    // Open a reg key to the driver specific location
    //
    hDevRegKey = SetupDiOpenDevRegKey(NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData,
                                      DICS_FLAG_GLOBAL,
                                      0,
                                      DIREG_DRV,
                                      KEY_READ
                                      );

    if (hDevRegKey == INVALID_HANDLE_VALUE) {
    
        goto SIIDExit;
    }

    //
    // Compare Description, Manufacturer, and Provider Name.
    // These are the three unique "keys" within a single inf file.
    // Fetch the drvinfo, drvdetailinfo for the selected device.
    //

    //
    // If the Device Description isn't the same, its a different driver.
    //
    if (!SetupDiGetDeviceRegistryProperty(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          SPDRP_DEVICEDESC,
                                          NULL,                 // regdatatype
                                          (LPVOID)Buffer,
                                          sizeof(Buffer),
                                          NULL
                                          )) {
                                          
        *Buffer = TEXT('\0');
    }

    if (_wcsicmp(BestDriverInfoData->Description, Buffer)) {
    
        goto SIIDExit;
    }

    //
    // If the Manufacturer Name isn't the same, its different
    //
    if (!SetupDiGetDeviceRegistryProperty(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          SPDRP_MFG,
                                          NULL, // regdatatype
                                          (LPVOID)Buffer,
                                          sizeof(Buffer),
                                          NULL
                                          )) {
                                          
        *Buffer = TEXT('\0');
    }

    if (_wcsicmp(BestDriverInfoData->MfgName, Buffer)) {
    
        goto SIIDExit;
    }

    //
    // If the Provider Name isn't the same, its different
    //
    cbData = sizeof(Buffer);
    if (RegQueryValueEx(hDevRegKey,
                        REGSTR_VAL_PROVIDER_NAME,
                        NULL,
                        NULL,
                        (LPVOID)Buffer,
                        &cbData
                        ) != ERROR_SUCCESS) {
                        
        *Buffer = TEXT('\0');
    }

    if (_wcsicmp(BestDriverInfoData->ProviderName, Buffer)) {
    
        goto SIIDExit;
    }

    //
    // Check the InfName, InfSection and DriverDesc
    // NOTE: the installed infName will not contain the path to the default windows
    // inf directory. If the same inf name has been found for the selected driver
    // from another location besides the default inf search path, then it will
    // contain a path, and is treated as a *different* driver.
    //
    DriverInfoDetailData.cbSize = sizeof(DriverInfoDetailData);
    if (!SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                    &NewDevWiz->DeviceInfoData,
                                    BestDriverInfoData,
                                    &DriverInfoDetailData,
                                    sizeof(DriverInfoDetailData),
                                    NULL
                                    )
        &&
        GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        
        goto SIIDExit;
    }

    if (GetWindowsDirectory(Buffer, SIZECHARS(Buffer)) &&
        pSetupConcatenatePaths(Buffer, TEXT("INF\\"), SIZECHARS(Buffer), NULL)) {
    
        pwch = Buffer + lstrlen(Buffer);

        cbData = SIZECHARS(Buffer) - lstrlen(Buffer);
        if (RegQueryValueEx(hDevRegKey,
                            REGSTR_VAL_INFPATH,
                            NULL,
                            NULL,
                            (PVOID)pwch,
                            &cbData
                            ) != ERROR_SUCCESS )
        {
            *Buffer = TEXT('\0');
        }

        if (_wcsicmp( DriverInfoDetailData.InfFileName, Buffer)) {
        
            goto SIIDExit;
        }

    } else {
    
        goto SIIDExit;
    }

    cbData = sizeof(Buffer);
    if (RegQueryValueEx(hDevRegKey,
                        REGSTR_VAL_INFSECTION,
                        NULL,
                        NULL,
                        (LPVOID)Buffer,
                        &cbData
                        ) != ERROR_SUCCESS ) {
                        
        *Buffer = TEXT('\0');
    }

    if (_wcsicmp(DriverInfoDetailData.SectionName, Buffer)) {
    
        goto SIIDExit;
    }

    bReturn = TRUE;


SIIDExit:

    if (hDevRegKey != INVALID_HANDLE_VALUE) {
    
        RegCloseKey(hDevRegKey);
    }

    return bReturn;
}

BOOL
IsDriverNodeInteractiveInstall(
   PNEWDEVWIZ NewDevWiz,
   PSP_DRVINFO_DATA DriverInfoData
   )
/*++

    This function checks to see if the given PSP_DRVINFO_DATA is listed as a
    InteractiveInstall in the [ControlFlags] section of the INF.

Return Value:

    TRUE if the driver node is InteractiveInstall, FALSE otherwise.
    
--*/
{
    BOOL b;
    DWORD Err;
    DWORD DriverInfoDetailDataSize;
    HINF hInf;
    INFCONTEXT InfContext;
    TCHAR szBuffer[MAX_PATH];
    DWORD i;
    LPTSTR p;
    PSP_DRVINFO_DETAIL_DATA pDriverInfoDetailData;

    //
    // Get the SP_DRVINFO_DETAIL_DATA so we can get the list of hardware and
    // compatible Ids for this device.
    //
    b = SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                   &NewDevWiz->DeviceInfoData,
                                   DriverInfoData,
                                   NULL,
                                   0,
                                   &DriverInfoDetailDataSize
                                   );

    Err = GetLastError();

    //
    // The above call to get the driver info detail data should never succeed because the
    // buffer will always be too small (we're just interested in sizeing the buffer
    // at this point).
    //
    if (b || (Err != ERROR_INSUFFICIENT_BUFFER)) {

        //
        // For some reason the SetupDiGetDriverInfoDetail API failed...so return FALSE.
        //
        return FALSE;
    }

    //
    // Now that we know how big of a buffer we need to hold the driver info details,
    // allocate the buffer and retrieve the information.
    //
    pDriverInfoDetailData = malloc(DriverInfoDetailDataSize);

    if (!pDriverInfoDetailData) {
        return FALSE;
    }

    pDriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);

    if (!SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                    &NewDevWiz->DeviceInfoData,
                                    DriverInfoData,
                                    pDriverInfoDetailData,
                                    DriverInfoDetailDataSize,
                                    NULL)) {

        free(pDriverInfoDetailData);
        return FALSE;
    }

    //
    // At this point we have all of the hardware and compatible IDs for this driver node.
    // Now we need to open up the INF and see if any of them are referenced in an
    // "InteractiveInstall" control flag entry.
    //
    hInf = SetupOpenInfFile(pDriverInfoDetailData->InfFileName,
                            NULL,
                            INF_STYLE_WIN4,
                            NULL
                            );

    if (hInf == INVALID_HANDLE_VALUE) {

        //
        // For some reason we couldn't open the INF!
        //
        free(pDriverInfoDetailData);
        return FALSE;
    }

    b = FALSE;

    //
    // Look at each InteractiveInstall line in the INF's [ControlFlags] section...
    //
    if (SetupFindFirstLine(hInf, INFSTR_CONTROLFLAGS_SECTION, INFSTR_KEY_INTERACTIVEINSTALL, &InfContext)) {

        do {
            //
            // and within each line, examine each value...
            //
            for (i = 1;
                 SetupGetStringField(&InfContext, i, szBuffer, SIZECHARS(szBuffer), NULL);
                 i++) {
                //
                // Check to see if this ID matches up with one of the driver node's hardware
                // or compatible IDs.
                //
                for (p = pDriverInfoDetailData->HardwareID; *p; p+= (lstrlen(p) + 1)) {

                    if (!lstrcmpi(p, szBuffer)) {
                        //
                        // We found a match, this device is marked with 
                        // InteractiveInstall.
                        //
                        b = TRUE;
                    }
                }
            }

        } while (SetupFindNextMatchLine(&InfContext, INFSTR_KEY_INTERACTIVEINSTALL, &InfContext));
    }

    SetupCloseInfFile(hInf);
    free(pDriverInfoDetailData);

    return b;
}

BOOL
IsDriverAutoInstallable(
   PNEWDEVWIZ NewDevWiz,
   PSP_DRVINFO_DATA BestDriverInfoData
   )
/*++

    A driver (the selected driver) is considered auto installable if the following are TRUE:
    
        - It is not a printer
        - This must be a NDWTYPE_FOUNDNEW or NDWTYPE_UPDATE InstallType.
        - There is no "InteractiveInstall" key in the [ControlFlags] section for any of the 
          Hardware or Compatible IDs of this device.
        - There are no other drivers in the list that have the same or better Ranks or Dates then 
          the selected driver.
        - If this is an Update Driver case the selected driver must not be the current driver
        
    The reason for this function is that in the Found New Hardware case we want to automatically
    install the best driver we find.  We can't do that in the case where we have multiple drivers
    that have the same Rank as the best driver found.  The problem is that there are certain cases
    where a user MUST choose the driver in these cases and so we can't automatically make the decision
    for them.  If this API does return FALSE that just means that the user will have to hit Next
    on one extra wizard page.

Return Value:

    TRUE if this device/driver is auto installable.
    FALSE if this device/driver is NOT auto installable.  This means that we will stop on the install
          page and the user will have to hit Next to proceede.
    
--*/
{
    DWORD BestRank;
    DWORD DriverIndex;
    DWORD BestRankCount = 0;
    FILETIME BestDriverDate;
    DWORDLONG BestDriverVersion;
    TCHAR BestProviderName[LINE_LEN];
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;

    //
    // We only do Auto Installs if this is a NDWTYPE_FOUNDNEW or NDWTYPE_UPDATE install
    //
    if ((NewDevWiz->InstallType != NDWTYPE_FOUNDNEW) &&
        (NewDevWiz->InstallType != NDWTYPE_UPDATE)) {

        return FALSE;
    }

    //
    // We need to special case printers as usuall.
    //
    if (IsEqualGUID(&NewDevWiz->DeviceInfoData.ClassGuid, &GUID_DEVCLASS_PRINTER)) {
        //
        // This is a printer, so if there is more than one printer driver node
        // in the list, this isn't auto-installable.
        //
        DriverInfoData.cbSize = sizeof(DriverInfoData);
        if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  SPDIT_COMPATDRIVER,
                                  1,
                                  &DriverInfoData
                                  )) {

            return FALSE;
        }
    }

    //
    // Check if the best driver is listed in the INF as InteractiveInstall. If
    // it is, and there is more than one driver in the list, then this driver
    // is not auto-installable.
    //
    if (IsDriverNodeInteractiveInstall(NewDevWiz, BestDriverInfoData)) {
        //
        // The best driver is marked as InteractiveInstall.  If there is more 
        // than one driver in the list then this driver is NOT auto-installable.
        //
        DriverInfoData.cbSize = sizeof(DriverInfoData);
        if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  SPDIT_COMPATDRIVER,
                                  1,
                                  &DriverInfoData
                                  )) {

            return FALSE;
        }
    }

    //
    // First get the Rank of the selected driver.
    //
    DriverInstallParams.cbSize = sizeof(DriverInstallParams);
    if (!SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                       &NewDevWiz->DeviceInfoData,
                                       BestDriverInfoData,
                                       &DriverInstallParams
                                       )) {

        //
        // If we can't get the Rank of the best driver then just return FALSE
        //
        return FALSE;
    }

    //
    // Remember the Rank and DriverDate of the selected (best) driver.
    //
    BestRank = DriverInstallParams.Rank;
    memcpy(&BestDriverDate, &BestDriverInfoData->DriverDate, sizeof(BestDriverDate));
    BestDriverVersion = BestDriverInfoData->DriverVersion;
    StringCchCopy(BestProviderName, SIZECHARS(BestProviderName), BestDriverInfoData->ProviderName);

    DriverInfoData.cbSize = sizeof(DriverInfoData);
    DriverIndex = 0;
    while (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 SPDIT_COMPATDRIVER,
                                 DriverIndex++,
                                 &DriverInfoData
                                 )) {

        DriverInstallParams.cbSize = sizeof(DriverInstallParams);
        if (SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                           &NewDevWiz->DeviceInfoData,
                                           &DriverInfoData,
                                           &DriverInstallParams
                                           )) {

            //
            // Don't bother doing the comparison if this driver is marked as a BAD driver
            //
            if (!(DriverInstallParams.Flags & DNF_BAD_DRIVER) &&
                !(DriverInstallParams.Flags & DNF_OLD_INET_DRIVER)) {
                //
                // Check if the current driver node is identical enough to the
                // best driver that setupapi picked, so that we need the user
                // to manually pick the one to install.  This should be very
                // rare that the user would ever need to make this choice.
                //
                if (DriverInstallParams.Rank < BestRank) {
                    //
                    // We found another driver node in the list that has a
                    // better (smaller) rank then the best driver.
                    //
                    BestRankCount++;

                } else if ((DriverInstallParams.Rank == BestRank) &&
                           (CompareFileTime(&DriverInfoData.DriverDate, &BestDriverDate) == 1)) {
                    //
                    // We found another driver node in the list that has the 
                    // same rank as the best driver and it has a newer driver
                    // date.
                    //
                    BestRankCount++;

                } else if ((DriverInstallParams.Rank == BestRank) &&
                           (CompareFileTime(&DriverInfoData.DriverDate, &BestDriverDate) == 0)) {
                    //
                    // We found another driver node in the list that has the 
                    // same rank as the best driver and the driver dates are
                    // the same.
                    // Check the provider names and if they are the same, then
                    // check which driver has the larger version, otherwise 
                    // the driver version is meaningless so the user will have
                    // to make the choice.
                    //
                    if (lstrcmpi(BestProviderName, DriverInfoData.ProviderName) == 0) {
                        //
                        // Since the provider names are the same if the current
                        // driver node has a better, or the same, version as the 
                        // best driver then the user will have to manually pick 
                        // which driver they want.
                        //
                        if (DriverInfoData.DriverVersion >= BestDriverVersion) {
                            BestRankCount++;
                        }
                    } else {
                        //
                        // The provider names are different, which means the
                        // driver version information is meaningless, so the
                        // user will have to pick which driver they want.
                        //
                        BestRankCount++;
                    }
                }
            }
        }
    }

    //
    // If BestRankCount is 2 or more than that means we have multiple drivers with the same or better
    // Rank as the best driver.
    //
    if (BestRankCount >= 2) {

        return FALSE;
    }

    //
    // If we are in a NDWTYPE_UPDATE install then we need to make sure that the selected driver is not
    // the current driver.
    //
    if ((NewDevWiz->InstallType == NDWTYPE_UPDATE) &&
        IsInstalledDriver(NewDevWiz, BestDriverInfoData)) {

        return FALSE;
    }

    //
    // If we have come this far then that means 
    // - we're not dealing with a printer
    // - this is either a NDWTYPE_FOUNDNEW or NDWTYPE_UPDATE install
    // - this is not an "InteractiveInstall"
    // - no other driver has the same or better rank then the selected driver.
    // - if this is a NDWTYPE_UPDATE then the selected driver is not the current driver.
    // 
    return TRUE;
}

DWORD WINAPI
DriverSearchThreadProc(
    LPVOID lpVoid
    )
/*++

Description:
    
    In the Wizard, we must do the driver search in a separate thread so that the user has the option
    to cancel out.

--*/
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)lpVoid;

    //
    // Do the driver search.
    //
    DoDriverSearch(NewDevWiz->hWnd, 
                   NewDevWiz, 
                   NewDevWiz->SearchOptions,
                   SPDIT_COMPATDRIVER,
                   FALSE
                   );


    //
    // Post a message to the window to let it know that we are finished with the search
    //
    PostMessage(NewDevWiz->hWnd, WUM_SEARCHDRIVERS, TRUE, GetLastError());

    return GetLastError();
}

INT_PTR CALLBACK
DriverSearchingDlgProc(
    HWND hDlg, 
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz;
    TCHAR PropSheetHeaderTitle[MAX_PATH];
    HICON hicon;

    UNREFERENCED_PARAMETER(wParam);

    if (message == WM_INITDIALOG) {
        
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);
        return TRUE;
    }

    NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    switch(message) {

    case WM_NOTIFY:
        switch (((NMHDR FAR *)lParam)->code) {

        case PSN_SETACTIVE: {
            SetDriverDescription(hDlg, IDC_DRVUPD_DRVDESC, NewDevWiz);

            hicon = NULL;
            if (NewDevWiz->ClassGuidSelected &&
                SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL))
            {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            }
            
            else {
                
                SetupDiLoadClassIcon(&GUID_DEVCLASS_UNKNOWN, &hicon, NULL);
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            }

            if (hicon) {
                
                DestroyIcon(hicon);
            }

            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_SEARCHING;
            NewDevWiz->ExitSearch = FALSE;


            //
            // if coming from IDD_NEWDEVWIZ_INTRO or IDD_NEWDEVWIZ_ADVANCEDSEARCH
            // page then begin driver search
            //
            if ((NewDevWiz->EnterFrom == IDD_NEWDEVWIZ_INTRO) ||
                (NewDevWiz->EnterFrom == IDD_NEWDEVWIZ_ADVANCEDSEARCH) ||
                (NewDevWiz->EnterFrom == IDD_NEWDEVWIZ_WUPROMPT)) {

                DWORD ThreadId;

                if (LoadString(hNewDev, IDS_NEWDEVWIZ_SEARCHING, PropSheetHeaderTitle, SIZECHARS(PropSheetHeaderTitle))) {

                    PropSheet_SetHeaderTitle(GetParent(hDlg),
                                             PropSheet_IdToIndex(GetParent(hDlg), IDD_NEWDEVWIZ_SEARCHING),
                                             PropSheetHeaderTitle
                                             );
                }
                
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);

                ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), SW_SHOW);
                ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_INTERNETDOWNLOAD), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_TEXT_INTERNETDOWNLOAD), SW_HIDE);
                Animate_Open(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), MAKEINTRESOURCE(IDA_SEARCHING));
                Animate_Play(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), 0, -1, -1);

                NewDevWiz->CurrCursor = NewDevWiz->IdcAppStarting;
                SetCursor(NewDevWiz->CurrCursor);

                NewDevWiz->hWnd = hDlg;

                //
                // Start up a separate thread to do the driver search on.
                // When the driver searching is complete the DriverSearchThreadProc
                // will post us a WUM_SEARCHDRIVERS message.
                //
                NewDevWiz->DriverSearchThread = CreateThread(NULL,
                                                             0,
                                                             (LPTHREAD_START_ROUTINE)DriverSearchThreadProc,
                                                             (LPVOID)NewDevWiz,
                                                             0,
                                                             &ThreadId
                                                             );
            }
        }
        break;

        case PSN_WIZNEXT:
            
            NewDevWiz->EnterInto = IDD_NEWDEVWIZ_INSTALLDEV;

            if (NewDevWiz->DoAutoInstall) {
                //
                // This is the case where we found a better driver (or a driver in the 
                // Found New Hardware case) and so we will just do an AutoInstall.
                //
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_INSTALLDEV);
            
            } else if (NewDevWiz->CurrentDriverIsSelected) {
                //
                // This is the case where the current driver is the best driver.
                //
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_USECURRENT_FINISH);
            
            } else if (NewDevWiz->NoDriversFound) {
                //
                // This is the case where we could not find any drivers for this device.
                //
                //
                // If we could not find any drivers for this device then we have two choices,
                // we either take the user to the Windows Update prompting wizard page,
                // or take them directly to the no driver found finish page.  We will only
                // take them to the Windows Update prompting page if the AlreadySearchedInet
                // BOOL is FALSE and the machine is NOT currently connected to the Internet.
                //
                if (!IsInternetAvailable(&NewDevWiz->hCdmInstance) ||
                    NewDevWiz->AlreadySearchedWU ||
                    IsConnectedToInternet()) {
                
                    SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_NODRIVER_FINISH);

                } else {

                    SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_WUPROMPT);
                }
            } else {
                //
                // If we aren't doing an AutoInstall and this is NOT the current driver or 
                // NO driver case, then we need to jump to the page that lists out the drivers.
                //
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_LISTDRIVERS);
            }
             
            break;

        case PSN_WIZBACK:
            if (NewDevWiz->ExitSearch) {
                SetDlgMsgResult(hDlg, message, -1);
                break;
            }

            NewDevWiz->CurrentDriverIsSelected = FALSE;
            NewDevWiz->ExitSearch = TRUE;
            NewDevWiz->CurrCursor = NewDevWiz->IdcWait;
            SetCursor(NewDevWiz->CurrCursor);
            CancelDriverSearch(NewDevWiz);
            NewDevWiz->CurrCursor = NULL;
            EnableWindow(GetDlgItem(GetParent(hDlg), IDCANCEL), TRUE);
            SetDlgMsgResult(hDlg, message, NewDevWiz->EnterFrom);
            Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
            Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_INTERNETDOWNLOAD));
            break;

        case PSN_QUERYCANCEL:
            if (NewDevWiz->ExitSearch) {
                
                SetDlgMsgResult(hDlg, message, TRUE);
                break;
            }

            NewDevWiz->ExitSearch = TRUE;
            NewDevWiz->CurrCursor = NewDevWiz->IdcWait;
            SetCursor(NewDevWiz->CurrCursor);
            CancelDriverSearch(NewDevWiz);
            NewDevWiz->CurrCursor = NULL;
            SetDlgMsgResult(hDlg, message, FALSE);
            break;

        case PSN_RESET:
            Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
            Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_INTERNETDOWNLOAD));
            break;

        default:
            return FALSE;
        }

        break;


    case WM_DESTROY:
        CancelDriverSearch(NewDevWiz);
        hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_GETICON, 0, 0L);
        if (hicon) {
            DestroyIcon(hicon);
        }
        break;


    case WUM_STARTINTERNETDOWNLOAD:
        //
        // Stop the searching animation, and hide it's window, and
        // start up the Internet download animation.
        //
        ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_INTERNETDOWNLOAD), SW_SHOW);
        ShowWindow(GetDlgItem(hDlg, IDC_TEXT_INTERNETDOWNLOAD), SW_SHOW);
        ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), SW_HIDE);
        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
        Animate_Open(GetDlgItem(hDlg, IDC_ANIMATE_INTERNETDOWNLOAD), MAKEINTRESOURCE(IDA_INTERNETDOWNLOAD));
        Animate_Play(GetDlgItem(hDlg, IDC_ANIMATE_INTERNETDOWNLOAD), 0, -1, -1);
        break;
    
    
    case WUM_ENDINTERNETDOWNLOAD:
        //
        // Stop the Internet download animation, and hide it's window
        //
        // NOTE: This message doesn't start the searching animation again, 
        // since downloading drivers from the Internet is the last search 
        // action.  If that ever changes, then this message should also
        // start up the searching animation again.
        //
        ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_INTERNETDOWNLOAD), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_TEXT_INTERNETDOWNLOAD), SW_HIDE);
        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_INTERNETDOWNLOAD));
        break;


    case WUM_SEARCHDRIVERS: {
    
        SP_DRVINFO_DATA DriverInfoData;

        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH));
        ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_SEARCH), SW_HIDE);
        Animate_Stop(GetDlgItem(hDlg, IDC_ANIMATE_INTERNETDOWNLOAD));
        ShowWindow(GetDlgItem(hDlg, IDC_ANIMATE_INTERNETDOWNLOAD), SW_HIDE);

        NewDevWiz->CurrCursor = NULL;
        SetCursor(NewDevWiz->IdcArrow);

        if (NewDevWiz->ExitSearch) {
            
            break;
        }

        DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
        if (SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     &DriverInfoData
                                     ))
        {
            ULONG Status = 0, Problem = 0;

            //
            // We basically have three cases when we find a driver for the device.
            // 1) The driver is autoinstallable. This means we jump directly to the install page.
            // 2) The driver is the current driver. This means we don't reinstall the driver.
            // 3) We have muliple drivers or the drivers aren't autoinstallable.  This means we
            //    show a list of the drivers to the user and make them pick.
            //
            NewDevWiz->NoDriversFound = FALSE;                 

            //
            // If this driver is Auto Installable then we will skip stoping at the Install
            // confirmation page.
            //
            NewDevWiz->DoAutoInstall = IsDriverAutoInstallable(NewDevWiz, &DriverInfoData);
            
            //
            // If the selected driver is the currently installed driver and the
            // device does NOT have a problem OR we are doing an Update then
            // jump to the currently installed driver finish page.
            //
            if ((((CM_Get_DevNode_Status(&Status, &Problem, NewDevWiz->DeviceInfoData.DevInst, 0) == CR_SUCCESS) &&
                  !(Status & DN_HAS_PROBLEM)) ||
                 (NewDevWiz->InstallType == NDWTYPE_UPDATE)) &&
                (IsInstalledDriver(NewDevWiz, &DriverInfoData))) {
            
                NewDevWiz->CurrentDriverIsSelected = TRUE;
            }

        } else {

            //
            // This is the case where we could not get a selected driver because we didn't
            // find any drivers in the driver search.
            //
            NewDevWiz->NoDriversFound = TRUE;                 
        }

        //
        // Auto Jump to the next page.
        //
        PropSheet_PressButton(GetParent(hDlg), PSBTN_NEXT);
        break;
    }


    case WM_SETCURSOR:
        if (NewDevWiz->CurrCursor) {

            SetCursor(NewDevWiz->CurrCursor);
            break;
        }

        // fall thru to return(FALSE);


    default:
        return FALSE;

    } // end of switch on message


    return TRUE;
}

INT_PTR CALLBACK
WUPromptDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    static int BackupPage;
    static DWORD dwWizCase = 0;
    HICON hicon;

    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);

    UNREFERENCED_PARAMETER(wParam);

    switch (message)  {
        
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        //
        // Set the Initial radio button state to connect to the Internet.
        //
        CheckRadioButton(hDlg,
                         IDC_WU_SEARCHINET,
                         IDC_WU_NOSEARCH,
                         IDC_WU_SEARCHINET
                         );
    }
    break;

    case WM_DESTROY:
        hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_GETICON, 0, 0);
        if (hicon) {

            DestroyIcon(hicon);
        }
        break;

    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            //
            // This page is always entered from the driver searching page, which
            // is a transient page and so it doesn't set the EnterFrom value.
            // Therefore we will remember the page that entered the driver
            // searching page, which will be the intro or the advanced search
            // page.
            //
            if ((NewDevWiz->EnterFrom == IDD_NEWDEVWIZ_INTRO) ||
                (NewDevWiz->EnterFrom == IDD_NEWDEVWIZ_ADVANCEDSEARCH)) {
                
                BackupPage = NewDevWiz->EnterFrom;
            }
            
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_WUPROMPT;

            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

            hicon = NULL;
            if (NewDevWiz->ClassGuidSelected &&
                SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL))
            {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            }
            
            else {
                
                SetupDiLoadClassIcon(&GUID_DEVCLASS_UNKNOWN, &hicon, NULL);
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            }

            if (hicon) {
                
                DestroyIcon(hicon);
            }

            SetDriverDescription(hDlg, IDC_DRVUPD_DRVDESC, NewDevWiz);
            break;

        case PSN_RESET:
            break;

        case PSN_WIZNEXT:
            NewDevWiz->AlreadySearchedWU = TRUE;
            NewDevWiz->EnterFrom = IDD_NEWDEVWIZ_WUPROMPT;

            //
            // Set the SEARCH_INET search option and go to the searching
            // wizard page.
            //
            if (IsDlgButtonChecked(hDlg, IDC_WU_SEARCHINET)) {
            
                NewDevWiz->SearchOptions = SEARCH_INET;

                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_SEARCHING);

            } else {
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_NODRIVER_FINISH);
            }
            break;
        
        case PSN_WIZBACK:
            NewDevWiz->AlreadySearchedWU = FALSE;
            SetDlgMsgResult(hDlg, message, BackupPage);
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

void
FillDriversList(
    HWND hwndList,
    PNEWDEVWIZ NewDevWiz,
    int SignedIconIndex,
    int CertIconIndex,
    int UnsignedIconIndex
    )
{
    int IndexDriver;
    int SelectedDriver;
    int lvIndex;
    LV_ITEM lviItem;
    BOOL FoundInstalledDriver;
    BOOL FoundSelectedDriver;
    SP_DRVINFO_DATA DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    SP_DRVINSTALL_PARAMS DriverInstallParams;

    SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);
    ListView_DeleteAllItems(hwndList);
    ListView_SetExtendedListViewStyle(hwndList, LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    IndexDriver = 0;
    SelectedDriver = 0;
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DriverInfoDetailData.cbSize = sizeof(DriverInfoDetailData);

    FoundInstalledDriver = FALSE;
    FoundSelectedDriver = FALSE;
    while (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 SPDIT_COMPATDRIVER,
                                 IndexDriver,
                                 &DriverInfoData
                                 )) {

        //
        // Get the DriverInstallParams so we can see if we got this driver from the Internet
        //
        DriverInstallParams.cbSize = sizeof(SP_DRVINSTALL_PARAMS);
        if (SetupDiGetDriverInstallParams(NewDevWiz->hDeviceInfo,
                                          &NewDevWiz->DeviceInfoData,
                                          &DriverInfoData,
                                          &DriverInstallParams))  {
            //
            // Don't show old Internet drivers because we don't have the files locally
            // anymore to install these!  Also don't show BAD drivers.
            //
            if ((DriverInstallParams.Flags & DNF_OLD_INET_DRIVER) ||
                (DriverInstallParams.Flags & DNF_BAD_DRIVER)) {

                IndexDriver++;
                continue;
            }
                                 
            lviItem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
            lviItem.iItem = IndexDriver;
            lviItem.iSubItem = 0;
            lviItem.pszText = DriverInfoData.Description;
            lviItem.lParam = 0;
            
            if (DriverInstallParams.Flags & DNF_AUTHENTICODE_SIGNED) {
                lviItem.iImage = CertIconIndex;
            } else if (DriverInstallParams.Flags & DNF_INF_IS_SIGNED) {
                lviItem.iImage = SignedIconIndex;
            } else {
                lviItem.iImage = UnsignedIconIndex;
            }

            //
            // If this is the currently installed driver then set the DRIVER_LIST_CURRENT_DRIVER
            // flag in the lParam.
            //
            if (!FoundInstalledDriver &&
                (NewDevWiz->InstallType == NDWTYPE_UPDATE) &&
                IsInstalledDriver(NewDevWiz, &DriverInfoData)) {

                lviItem.lParam |= DRIVER_LIST_CURRENT_DRIVER;
            }

            //
            // If this is the selected driver then set the DRIVER_LIST_SELECTED_DRIVER
            // flag in the lParam
            //
            if (!FoundSelectedDriver &&
                IsSelectedDriver(NewDevWiz, &DriverInfoData)) {

                lviItem.lParam |= DRIVER_LIST_SELECTED_DRIVER;
                SelectedDriver = IndexDriver;
            }

            if (DriverInstallParams.Flags & DNF_INF_IS_SIGNED) {
                lviItem.lParam |= DRIVER_LIST_SIGNED_DRIVER;
            }

            if (DriverInstallParams.Flags & DNF_AUTHENTICODE_SIGNED) {
                lviItem.lParam |= DRIVER_LIST_AUTHENTICODE_DRIVER;
            }
            
            lvIndex = ListView_InsertItem(hwndList, &lviItem);

            if (DriverInfoData.DriverVersion != 0) {

                ULARGE_INTEGER Version;
                TCHAR VersionString[LINE_LEN];

                Version.QuadPart = DriverInfoData.DriverVersion;

                StringCchPrintf(VersionString,
                                SIZECHARS(VersionString), 
                                TEXT("%0d.%0d.%0d.%0d"),
                                HIWORD(Version.HighPart), LOWORD(Version.HighPart),
                                HIWORD(Version.LowPart), LOWORD(Version.LowPart));
            
                ListView_SetItemText(hwndList, lvIndex, 1, VersionString);
            
            } else {
                
                ListView_SetItemText(hwndList, lvIndex, 1, szUnknown);
            }
            
            ListView_SetItemText(hwndList, lvIndex, 2, DriverInfoData.MfgName);


            if (DriverInstallParams.Flags & DNF_INET_DRIVER) {
                //
                // Driver is from the Internet
                //
                TCHAR WindowsUpdate[MAX_PATH];
                if (!LoadString(hNewDev, IDS_DEFAULT_INTERNET_HOST, WindowsUpdate, SIZECHARS(WindowsUpdate))) {
                    StringCchCopy(WindowsUpdate, SIZECHARS(WindowsUpdate), TEXT(""));
                }

                ListView_SetItemText(hwndList, lvIndex, 3, WindowsUpdate);

            } else {           
                //
                // Driver is not from the Internet
                //
                if (SetupDiGetDriverInfoDetail(NewDevWiz->hDeviceInfo,
                                               &NewDevWiz->DeviceInfoData,
                                               &DriverInfoData,
                                               &DriverInfoDetailData,
                                               sizeof(DriverInfoDetailData),
                                               NULL
                                               )
                    ||
                    GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                    
                    ListView_SetItemText(hwndList, lvIndex, 3, DriverInfoDetailData.InfFileName);

                } else {
                    ListView_SetItemText(hwndList, lvIndex, 3, TEXT(""));
                }
            }            
        }

        IndexDriver++;
    }

    //
    // Select the SelectedDriver item in the list and scroll it into view
    // since this is the best driver in the list.
    //
    ListView_SetItemState(hwndList,
                          SelectedDriver,
                          LVIS_SELECTED|LVIS_FOCUSED,
                          LVIS_SELECTED|LVIS_FOCUSED
                          );

    ListView_EnsureVisible(hwndList, SelectedDriver, FALSE);
    ListView_SetColumnWidth(hwndList, 0, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hwndList, 1, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hwndList, 2, LVSCW_AUTOSIZE_USEHEADER);
    ListView_SetColumnWidth(hwndList, 3, LVSCW_AUTOSIZE_USEHEADER);

    SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);
}

BOOL
SelectDriverFromList(
    HWND hwndList,
    PNEWDEVWIZ NewDevWiz
    )
{
    int lvSelected;
    SP_DRVINFO_DATA DriverInfoData;
    LVITEM lvi;

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    lvSelected = ListView_GetNextItem(hwndList,
                                      -1,
                                      LVNI_SELECTED
                                      );

    if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                              &NewDevWiz->DeviceInfoData,
                              SPDIT_COMPATDRIVER,
                              lvSelected,
                              &DriverInfoData
                              ))
    {
        SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                 &NewDevWiz->DeviceInfoData,
                                 &DriverInfoData
                                 );
    }

    //
    // if there is no selected driver call DIF_SELECTBESTCOMPATDRV.
    //
    if (!SetupDiGetSelectedDriver(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  &DriverInfoData
                                  ))
    {
        if (SetupDiEnumDriverInfo(NewDevWiz->hDeviceInfo,
                                  &NewDevWiz->DeviceInfoData,
                                  SPDIT_COMPATDRIVER,
                                  0,
                                  &DriverInfoData
                                  ))
        {
            //
            // Pick the best driver from the list we just created
            //
            SetupDiCallClassInstaller(DIF_SELECTBESTCOMPATDRV,
                                      NewDevWiz->hDeviceInfo,
                                      &NewDevWiz->DeviceInfoData
                                      );
        }

        else 
        {
            SetupDiSetSelectedDriver(NewDevWiz->hDeviceInfo,
                                     &NewDevWiz->DeviceInfoData,
                                     NULL
                                     );
        }
    }

    //
    // Return TRUE if the selected driver in the list is the current driver, otherwise return FALSE
    //
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.iItem = lvSelected;
    lvi.mask = LVIF_PARAM;

    if (ListView_GetItem(hwndList, &lvi) &&
        (lvi.lParam & DRIVER_LIST_CURRENT_DRIVER)) {

        return(TRUE);
    }

    return(FALSE);
}

INT_PTR CALLBACK
ListDriversDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    static int BackupPage;
    static HIMAGELIST himl = NULL;
    static int SignedIconIndex, CertIconIndex, UnsignedIconIndex;
    OSVERSIONINFOEX osVersionInfoEx;
    HICON hicon;

    UNREFERENCED_PARAMETER(wParam);

    switch (message)  {
        
    case WM_INITDIALOG: {
            
        HWND hwndList;
        LV_COLUMN lvcCol;
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        TCHAR Buffer[64];
        HFONT hfont;
        LOGFONT LogFont;

        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        //
        // Create the normal and bold fonts
        //
        hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_SIGNED_TEXT), WM_GETFONT, 0, 0);
        GetObject(hfont, sizeof(LogFont), &LogFont);
        NewDevWiz->hfontTextNormal = CreateFontIndirect(&LogFont);

        hfont = (HFONT)SendMessage(GetDlgItem(hDlg, IDC_SIGNED_TEXT), WM_GETFONT, 0, 0);
        GetObject(hfont, sizeof(LogFont), &LogFont);
        LogFont.lfWeight = FW_BOLD;
        NewDevWiz->hfontTextBold = CreateFontIndirect(&LogFont);

        hwndList = GetDlgItem(hDlg, IDC_LISTDRIVERS_LISTVIEW);

        //
        // Create the image list that contains the signed and not signed icons.
        //
        himl = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                GetSystemMetrics(SM_CYSMICON),
                                ILC_MASK |
                                ((GetWindowLong(GetParent(hDlg), GWL_EXSTYLE) & WS_EX_LAYOUTRTL)
                                    ? ILC_MIRROR 
                                    : 0),
                                1,
                                1);

        //
        // Associate the image list with the list view.
        //
        if (himl) {
            HICON hIcon;

            ImageList_SetBkColor(himl, GetSysColor(COLOR_WINDOW));
            
            //
            // Add the signed and unsigned icons to the imagelist.
            //
            if ((hIcon = LoadIcon(hNewDev, MAKEINTRESOURCE(IDI_BLANK))) != NULL) {
                UnsignedIconIndex = ImageList_AddIcon(himl, hIcon);
            }

            if ((hIcon = LoadIcon(hNewDev, MAKEINTRESOURCE(IDI_SIGNED))) != NULL) {
                SignedIconIndex = ImageList_AddIcon(himl, hIcon);
            }

            if ((hIcon = LoadIcon(hNewDev, MAKEINTRESOURCE(IDI_CERT))) != NULL) {
                CertIconIndex = ImageList_AddIcon(himl, hIcon);
            }

            ListView_SetImageList(hwndList,
                                  himl,
                                  LVSIL_SMALL
                                  );
        }

        //
        // Insert columns for listview.
        // 0 == device name
        // 1 == version
        // 2 == manufacturer
        // 3 == INF location
        //
        lvcCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
        lvcCol.fmt = LVCFMT_LEFT;
        lvcCol.pszText = Buffer;

        lvcCol.iSubItem = 0;
        LoadString(hNewDev, IDS_DRIVERDESC, Buffer, SIZECHARS(Buffer));
        ListView_InsertColumn(hwndList, 0, &lvcCol);

        lvcCol.iSubItem = 1;
        LoadString(hNewDev, IDS_DRIVERVERSION, Buffer, SIZECHARS(Buffer));
        ListView_InsertColumn(hwndList, 1, &lvcCol);

        lvcCol.iSubItem = 2;
        LoadString(hNewDev, IDS_DRIVERMFG, Buffer, SIZECHARS(Buffer));
        ListView_InsertColumn(hwndList, 2, &lvcCol);

        lvcCol.iSubItem = 3;
        LoadString(hNewDev, IDS_DRIVERINF, Buffer, SIZECHARS(Buffer));
        ListView_InsertColumn(hwndList, 3, &lvcCol);

        SendMessage(hwndList,
                    LVM_SETEXTENDEDLISTVIEWSTYLE,
                    LVS_EX_FULLROWSELECT,
                    LVS_EX_FULLROWSELECT
                    );
    }
    break;

    case WM_DESTROY:
        if (NewDevWiz->hfontTextNormal ) {
            DeleteObject(NewDevWiz->hfontTextNormal);
            NewDevWiz->hfontTextBigBold = NULL;
        }
        
        if (NewDevWiz->hfontTextBold ) {
            DeleteObject(NewDevWiz->hfontTextBold);
            NewDevWiz->hfontTextBold = NULL;
        }

        if (himl) {
            ImageList_Destroy(himl);
        }

        hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_GETICON, 0, 0L);
        if (hicon) {
            DestroyIcon(hicon);
        }
        break;

    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE: {
            //
            // We are always entered from the driver searching page, but it
            // is a transient page so it doesn't set the EnterFrom value, which
            // means the EnterFrom is still from the page that entered the
            // searching page.  If this happens to be either the Intro, 
            // Advanced Search, or the WU Prompt page then we need to remember
            // that so we can jump back to that page if the user hits the Back
            // button.
            //
            if ((NewDevWiz->EnterFrom == IDD_NEWDEVWIZ_INTRO) ||
                (NewDevWiz->EnterFrom == IDD_NEWDEVWIZ_ADVANCEDSEARCH) ||
                (NewDevWiz->EnterFrom == IDD_NEWDEVWIZ_WUPROMPT)) {
            
                BackupPage = NewDevWiz->EnterFrom;
            }
            
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_LISTDRIVERS;

            SetDriverDescription(hDlg, IDC_DRVUPD_DRVDESC, NewDevWiz);
            ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_ICON), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_TEXT), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_LINK), SW_HIDE);

            hicon = NULL;
            if (NewDevWiz->ClassGuidSelected &&
                SetupDiLoadClassIcon(NewDevWiz->ClassGuidSelected, &hicon, NULL)) {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            } else {
                SetupDiLoadClassIcon(&GUID_DEVCLASS_UNKNOWN, &hicon, NULL);
                SendDlgItemMessage(hDlg, IDC_CLASSICON, STM_SETICON, (WPARAM)hicon, 0L);
            }

            if (hicon) {
                DestroyIcon(hicon);
            }

            //
            // Fill the list view
            //
            FillDriversList(GetDlgItem(hDlg, IDC_LISTDRIVERS_LISTVIEW),
                            NewDevWiz,
                            SignedIconIndex,
                            CertIconIndex,
                            UnsignedIconIndex);

        }
        break;

        case PSN_RESET:
            break;

        case PSN_WIZBACK:
            SetDlgMsgResult(hDlg, message, BackupPage);
            break;

        case PSN_WIZNEXT:

            NewDevWiz->EnterFrom = IDD_NEWDEVWIZ_LISTDRIVERS;
            
            if (SelectDriverFromList(GetDlgItem(hDlg, IDC_LISTDRIVERS_LISTVIEW), NewDevWiz)) {

                NewDevWiz->EnterInto = IDD_NEWDEVWIZ_USECURRENT_FINISH;
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_USECURRENT_FINISH);
            
            } else {

                NewDevWiz->EnterInto = IDD_NEWDEVWIZ_INSTALLDEV;
                SetDlgMsgResult(hDlg, message, IDD_NEWDEVWIZ_INSTALLDEV);
            }
            break;

        case LVN_ITEMCHANGED: {

            LPNM_LISTVIEW   lpnmlv = (LPNM_LISTVIEW)lParam;
            int StringId = 0;
            int DigitalSignatureSignedId = 0;
            int IconSignedId = 0;
            
            hicon = NULL;

            if ((lpnmlv->uChanged & LVIF_STATE)) {
                if (lpnmlv->uNewState & LVIS_SELECTED) {
                    //
                    // lParam & DRIVER_LIST_CURRENT_DRIVER means this is the currently installed driver.
                    // lParam & DRIVER_LIST_SELECTED_DRIVER means this is the selected/best driver.
                    //
                    if (lpnmlv->lParam & DRIVER_LIST_CURRENT_DRIVER) {
                        StringId = IDS_DRIVER_CURR;
                    }

                    if (lpnmlv->lParam & DRIVER_LIST_AUTHENTICODE_DRIVER) {
                        DigitalSignatureSignedId = IDS_DRIVER_AUTHENTICODE_SIGNED;
                        IconSignedId = IDI_CERT;
                    } else if (lpnmlv->lParam & DRIVER_LIST_SIGNED_DRIVER) {
                        DigitalSignatureSignedId = IDS_DRIVER_IS_SIGNED;
                        IconSignedId = IDI_SIGNED;
                    } else {
                        DigitalSignatureSignedId = IDS_DRIVER_NOT_SIGNED;
                        IconSignedId = IDI_WARN;
                    }

                    hicon = LoadImage(hNewDev,
                                      MAKEINTRESOURCE(IconSignedId),
                                      IMAGE_ICON,
                                      GetSystemMetrics(SM_CXSMICON),
                                      GetSystemMetrics(SM_CYSMICON),
                                      0
                                      );

                    if (NewDevWiz->hfontTextNormal && NewDevWiz->hfontTextBold) {
                        SetWindowFont(GetDlgItem(hDlg, IDC_SIGNED_TEXT),
                                      (lpnmlv->lParam & DRIVER_LIST_SIGNED_DRIVER)
                                          ? NewDevWiz->hfontTextNormal
                                          : NewDevWiz->hfontTextBold,
                                      TRUE
                                      );
                    }

                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_ICON), SW_SHOW);
                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_TEXT), SW_SHOW);
                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_LINK), SW_SHOW);

                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                } else {
                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_ICON), SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_TEXT), SW_HIDE);
                    ShowWindow(GetDlgItem(hDlg, IDC_SIGNED_LINK), SW_HIDE);
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
                }

                if (!StringId) {
                    SetDlgItemText(hDlg, IDC_NDW_TEXT, TEXT(""));
                } else {
                    SetDlgText(hDlg, IDC_NDW_TEXT, StringId, StringId);
                }

                if (!DigitalSignatureSignedId) {
                    SetDlgItemText(hDlg, IDC_SIGNED_TEXT, TEXT(""));
                } else {
                    SetDlgText(hDlg, IDC_SIGNED_TEXT, DigitalSignatureSignedId, DigitalSignatureSignedId);
                }

                if (hicon) {
                    hicon = (HICON)SendDlgItemMessage(hDlg,
                                  IDC_SIGNED_ICON,
                                  STM_SETICON,
                                  (WPARAM)hicon,
                                  0L
                                  );
                }

                if (hicon) {
                    DestroyIcon(hicon);
                }
            }
        }
        break;

        case NM_RETURN:
        case NM_CLICK:
            if((((LPNMHDR)lParam)->idFrom) == IDC_SIGNED_LINK) {
                //
                // We need to know if this is a server machine or a workstation 
                // machine since there are different help topic structures for
                // the different products.
                //
                ZeroMemory(&osVersionInfoEx, sizeof(osVersionInfoEx));
                osVersionInfoEx.dwOSVersionInfoSize = sizeof(osVersionInfoEx);
                if (!GetVersionEx((LPOSVERSIONINFO)&osVersionInfoEx)) {
                    //
                    // If GetVersionEx fails then assume this is a workstation
                    // machine.
                    //
                    osVersionInfoEx.wProductType = VER_NT_WORKSTATION;
                }

                ShellExecute(hDlg,
                             TEXT("open"),
                             TEXT("HELPCTR.EXE"),
                             (osVersionInfoEx.wProductType == VER_NT_WORKSTATION)
                                ? TEXT("HELPCTR.EXE -url hcp://services/subsite?node=TopLevelBucket_4/Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm")
                                : TEXT("HELPCTR.EXE -url hcp://services/subsite?node=Hardware&topic=MS-ITS%3A%25HELP_LOCATION%25%5Csysdm.chm%3A%3A/logo_testing.htm"),
                             NULL,
                             SW_SHOWNORMAL
                             );
            }
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR CALLBACK
UseCurrentDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
          
    UNREFERENCED_PARAMETER(wParam);

    UNREFERENCED_PARAMETER(wParam);

    switch (message)  {
        
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        if (NewDevWiz->hfontTextBigBold) {

            SetWindowFont(GetDlgItem(hDlg, IDC_FINISH_MSG1), NewDevWiz->hfontTextBigBold, TRUE);
        }
    }
    break;

    case WM_DESTROY:
        break;

    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_USECURRENT_FINISH;
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
            break;

        case PSN_RESET:
            break;

        case PSN_WIZBACK:
            NewDevWiz->CurrentDriverIsSelected = FALSE;
            SetDlgMsgResult(hDlg, message, NewDevWiz->EnterFrom);
            break;
        }

        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}

INT_PTR
InitNoDriversDlgProc(
    HWND hDlg,
    PNEWDEVWIZ NewDevWiz
    )
{
    if (NewDevWiz->hfontTextBigBold) {
        SetWindowFont(GetDlgItem(hDlg, IDC_FINISH_MSG1), NewDevWiz->hfontTextBigBold, TRUE);
    }
    
    if (NDWTYPE_UPDATE == NewDevWiz->InstallType) {
        ShowWindow(GetDlgItem(hDlg, IDC_FINISH_MSG3), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_HELPCENTER_ICON), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_HELPCENTER_TEXT), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_FINISH_PROMPT), SW_HIDE);

    } else {

        CheckDlgButton(hDlg, IDC_FINISH_PROMPT, BST_CHECKED);

        //
        // If this user has the policy set to not send the Hardware Id to Windows
        // Update then don't put in the text about launching help center.
        //
        if (GetLogPnPIdPolicy() == FALSE) {
            ShowWindow(GetDlgItem(hDlg, IDC_FINISH_MSG3), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_HELPCENTER_ICON), SW_HIDE);
            ShowWindow(GetDlgItem(hDlg, IDC_HELPCENTER_TEXT), SW_HIDE);
        }
    }

    return TRUE;
}

INT_PTR CALLBACK
NoDriverDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    PNEWDEVWIZ NewDevWiz = (PNEWDEVWIZ)GetWindowLongPtr(hDlg, DWLP_USER);
    HICON hicon;

    switch (message)  {
        
    case WM_INITDIALOG: {
        LPPROPSHEETPAGE lppsp = (LPPROPSHEETPAGE)lParam;
        NewDevWiz = (PNEWDEVWIZ)lppsp->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NewDevWiz);

        InitNoDriversDlgProc(hDlg, NewDevWiz);
    }
    break;

    case WM_DESTROY:
        break;

    case WM_NOTIFY:

        switch (((NMHDR FAR *)lParam)->code) {
           
        case PSN_SETACTIVE:
            NewDevWiz->PrevPage = IDD_NEWDEVWIZ_USECURRENT_FINISH;

            //
            // Set the Help Center icon next to the text
            //
            hicon = LoadImage(hNewDev, 
                              MAKEINTRESOURCE(IDI_HELPCENTER), 
                              IMAGE_ICON,
                              GetSystemMetrics(SM_CXSMICON),
                              GetSystemMetrics(SM_CYSMICON),
                              0
                              );

            if (hicon) {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_HELPCENTER_ICON, STM_SETICON, (WPARAM)hicon, 0L);
            }

            if (hicon) {
                DestroyIcon(hicon);
            }

            //
            // Set the Info icon next to the text
            //
            hicon = LoadImage(hNewDev, 
                              MAKEINTRESOURCE(IDI_INFO), 
                              IMAGE_ICON,
                              GetSystemMetrics(SM_CXSMICON),
                              GetSystemMetrics(SM_CYSMICON),
                              0
                              );

            if (hicon) {
                hicon = (HICON)SendDlgItemMessage(hDlg, IDC_INFO_ICON, STM_SETICON, (WPARAM)hicon, 0L);
            }

            if (hicon) {
                DestroyIcon(hicon);
            }
            
            if (NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) {
                SetTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID, INSTALL_COMPLETE_CHECK_TIMEOUT, NULL);
            }

            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
            break;

        case PSN_RESET:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;

        case PSN_WIZFINISH:
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            
            if (IsDlgButtonChecked(hDlg, IDC_FINISH_PROMPT)) {
                InstallNullDriver(NewDevWiz,
                                  (NewDevWiz->Capabilities & CM_DEVCAP_RAWDEVICEOK)
                                     ? FALSE : TRUE
                                  );
            
            } else {
                NewDevWiz->LastError = ERROR_CANCELLED;
            }

            //
            // Set the BOOL that tells us to log that we could not find a 
            // driver for this device.
            //
            if ((NewDevWiz->InstallType == NDWTYPE_FOUNDNEW) &&
                GetLogPnPIdPolicy()) {
            
                NewDevWiz->LogDriverNotFound = TRUE;
            }
            break;
        
        case PSN_WIZBACK:
            NewDevWiz->CurrentDriverIsSelected = FALSE;
            SetDlgMsgResult(hDlg, message, NewDevWiz->EnterFrom);
            KillTimer(hDlg, INSTALL_COMPLETE_CHECK_TIMERID);
            break;
        }
        break;

    case WM_TIMER:
        if (INSTALL_COMPLETE_CHECK_TIMERID == wParam) {
            if (IsInstallComplete(NewDevWiz->hDeviceInfo, &NewDevWiz->DeviceInfoData)) {
                PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
            }
        }
        break;

    default:
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\backup.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    backup.c

Abstract:

    Routines to control backup during install process
    And restore of an old install process

Author:

    Jamie Hunter (jamiehun) 13-Jan-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

VOID
pSetupExemptFileFromProtection(
    IN  PCTSTR             FileName,
    IN  DWORD              FileChangeFlags,
    IN  PSETUP_LOG_CONTEXT LogContext,      OPTIONAL
    OUT PDWORD             QueueNodeFlags   OPTIONAL
    );


//
// ==========================================================
//

DWORD
pSetupQueueBackupCopy(
    IN HSPFILEQ QueueHandle,
    IN LONG   TargetRootPath,
    IN LONG   TargetSubDir,       OPTIONAL
    IN LONG   TargetFilename,
    IN LONG   BackupRootPath,
    IN LONG   BackupSubDir,       OPTIONAL
    IN LONG   BackupFilename
    )

/*++

Routine Description:

    Place a backup copy operation on a setup file queue.
    Target is to be backed up at Backup location

Arguments:

    QueueHandle - supplies a handle to a setup file queue, as returned
        by SetupOpenFileQueue.

    TargetRootPath  - Supplies the source directory, eg C:\WINNT\

    TargetSubDir    - Supplies the optional sub-directory (eg WINNT if RootPath = c:\ )

    TargetFilename - supplies the filename part of the file to be copied.

    BackupRootPath - supplies the directory where the file is to be copied.

    BackupSubDir   - supplies the optional sub-directory

    BackupFilename - supplies the name of the target file.

Return Value:

    same value as GetLastError() indicating error, or NO_ERROR

--*/

{
    PSP_FILE_QUEUE Queue;
    PSP_FILE_QUEUE_NODE QueueNode,TempNode;
    int Size;
    DWORD Err;
    PVOID StringTable;
    PTSTR FullRootName;

    Queue = (PSP_FILE_QUEUE)QueueHandle;
    Err = NO_ERROR;

    try {
        StringTable = Queue->StringTable;  // used for strings in source queue
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    //
    // Allocate a queue structure.
    //
    QueueNode = MyMalloc(sizeof(SP_FILE_QUEUE_NODE));
    if (!QueueNode) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // Operation is backup.
    //
    QueueNode->Operation = FILEOP_BACKUP;
    QueueNode->InternalFlags = 0;

    QueueNode->SourceRootPath = BackupRootPath;
    QueueNode->SourcePath = BackupSubDir;
    QueueNode->SourceFilename = BackupFilename;

    // if target has a sub-dir, we have to combine root and subdir into one string
    if (TargetSubDir != -1) {

        FullRootName = pSetupFormFullPath(
                                            StringTable,
                                            TargetRootPath,
                                            TargetSubDir,
                                            -1);

        if (!FullRootName) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;
        }

        TargetRootPath = pSetupStringTableAddString(StringTable,
                                                FullRootName,
                                                STRTAB_CASE_SENSITIVE
                                                );
        MyFree(FullRootName);

        if (TargetRootPath == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean1;
        }

        // now combined into TargetRootPath
        TargetSubDir = -1;

    }
    QueueNode->TargetDirectory = TargetRootPath;
    QueueNode->TargetFilename = TargetFilename;

    QueueNode->Next = NULL;

    //
    // Link the node onto the end of the backup queue
    //

    if (Queue->BackupQueue) {
        for (TempNode = Queue->BackupQueue; TempNode->Next; TempNode=TempNode->Next) /* blank */ ;
        TempNode->Next = QueueNode;
    } else {
        Queue->BackupQueue = QueueNode;
    }

    Queue->BackupNodeCount++;

    Err = NO_ERROR;
    goto clean0;

clean1:
    MyFree(QueueNode);
clean0:
    SetLastError(Err);
    return Err;
}


//
// ==========================================================
//

BOOL
pSetupGetFullBackupPath(
    OUT     PTSTR       FullPath,
    IN      PCTSTR      Path,           OPTIONAL
    IN      UINT        TargetBufferSize,
    OUT     PUINT       RequiredSize    OPTIONAL
    )
/*++

Routine Description:

    This routine takes a potentially relative path
    and concatenates it to the base path

Arguments:

    FullPath    - Destination for full path
    Path        - Relative source path to backup directory if specified.
                    If NULL, generates a temporary path
    TargetBufferSize - Size of buffer (characters)
    RequiredSize - Filled in with size required to contain full path

Return Value:

    If the function succeeds, return TRUE
    If there was an error, return FALSE

--*/
{
    UINT PathLen;
    LPCTSTR Base = WindowsBackupDirectory;

    if(!Path) {
        //
        // temporary location
        //
        Path = SP_BACKUP_OLDFILES;
        Base = WindowsDirectory;
    }

    //
    // Backup directory is stored in "WindowsBackupDirectory" for permanent backups
    // and WindowsDirectory\SP_BACKUP_OLDFILES for temporary backups
    //

    PathLen = lstrlen(Base);

    if ( FullPath == NULL || TargetBufferSize <= PathLen ) {
        // just calculate required path len
        FullPath = (PTSTR) Base;
        TargetBufferSize = 0;
    } else {
        // calculate and copy
        lstrcpy(FullPath, Base);
    }
    return pSetupConcatenatePaths(FullPath, Path, TargetBufferSize, RequiredSize);
}

//
// ==========================================================
//

DWORD
pSetupBackupCopyString(
    IN PVOID            DestStringTable,
    OUT PLONG           DestStringID,
    IN PVOID            SrcStringTable,
    IN LONG             SrcStringID
    )
/*++

Routine Description:

    Gets a string from source string table, adds it to destination string table with new ID.

Arguments:

    DestStringTable     - Where string has to go
    DestStringID        - pointer, set to string ID in respect to DestStringTable
    SrcStringTable      - Where string is coming from
    StringID            - string ID in respect to SrcStringTable

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/

{
    DWORD Err = NO_ERROR;
    LONG DestID;
    PTSTR String;

    if (DestStringID == NULL) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    if (SrcStringID == -1) {
        // "not supplied"
        DestID = -1;
    } else {
        // actually need to copy

        String = pSetupStringTableStringFromId( SrcStringTable, SrcStringID );
        if (String == NULL) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        DestID = pSetupStringTableAddString( DestStringTable, String, STRTAB_CASE_SENSITIVE );
        if (DestID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        *DestStringID = DestID;
    }

    Err = NO_ERROR;

clean0:
    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupGetTargetByPath(
    IN HSPFILEQ         QueueHandle,
    IN PVOID            PathStringTable,    OPTIONAL
    IN PCTSTR           TargetPath,         OPTIONAL
    IN LONG             TargetRoot,
    IN LONG             TargetSubDir,       OPTIONAL
    IN LONG             TargetFilename,
    OUT PLONG           TableID,            OPTIONAL
    OUT PSP_TARGET_ENT  TargetInfo
    )
/*++

Routine Description:

    Given a pathname, obtains/creates target info

Arguments:

    QueueHandle         - Queue we're looking at
    PathStringTable     - String table used for the Target Root/SubDir/Filename strings, NULL if same as QueueHandle's
    TargetPath          - if given, is the full path, previously generated
    TargetRoot          - root portion, eg c:\winnt
    TargetSubDir        - optional sub-directory portion, -1 if not provided
    TargetFilename      - filename , eg readme.txt
    TableID             - filled with ID for future use in pSetupBackupGetTargetByID or pSetupBackupSetTargetByID
    TargetInfo          - Filled with information about target

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/

{
    LONG PathID;
    TCHAR PathBuffer[MAX_PATH];
    PTSTR TmpPtr;
    PVOID LookupTable = NULL;
    PVOID QueueStringTable = NULL;
    PTSTR FullTargetPath = NULL;
    DWORD Err = NO_ERROR;
    PSP_FILE_QUEUE Queue;
    DWORD RequiredSize;

    Queue = (PSP_FILE_QUEUE)QueueHandle;
    try {
        LookupTable = Queue->TargetLookupTable;  // used for path lookup in source queue
        QueueStringTable = Queue->StringTable;  // used for strings in source queue
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    if (PathStringTable == NULL) {
        // default string table is that of queue's
        PathStringTable = QueueStringTable;
    }

    if (TargetPath == NULL) {
        // obtain the complete target path and filename (Duplicated String)
        FullTargetPath = pSetupFormFullPath(
                                            PathStringTable,
                                            TargetRoot,
                                            TargetSubDir,
                                            TargetFilename);

        if (!FullTargetPath) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        TargetPath = FullTargetPath;
    }

    //
    // normalize path
    //
    RequiredSize = GetFullPathName(TargetPath,
                                   SIZECHARS(PathBuffer),
                                   PathBuffer,
                                   &TmpPtr
                                  );
    //
    // This call should always succeed.
    //
    MYASSERT((RequiredSize > 0) &&
             (RequiredSize < SIZECHARS(PathBuffer)) // RequiredSize doesn't include terminating NULL char
            );

    //
    // Even though we asserted that this should not be the case above,
    // we should handle failure in case asserts are turned off.
    //
    if(!RequiredSize) {
        Err = GetLastError();
        goto clean0;
    } else if(RequiredSize >= SIZECHARS(PathBuffer)) {
        Err = ERROR_BUFFER_OVERFLOW;
        goto clean0;
    }

    PathID = pSetupStringTableLookUpStringEx(LookupTable, PathBuffer, 0, TargetInfo, sizeof(SP_TARGET_ENT));
    if (PathID == -1) {
        ZeroMemory(TargetInfo, sizeof(SP_TARGET_ENT));
        if (PathStringTable != QueueStringTable) {
            // need to add entries to Queue's string table if we're using another

            Err = pSetupBackupCopyString(QueueStringTable, &TargetRoot, PathStringTable, TargetRoot);
            if (Err != NO_ERROR) {
                goto clean0;
            }
            Err = pSetupBackupCopyString(QueueStringTable, &TargetSubDir, PathStringTable, TargetSubDir);
            if (Err != NO_ERROR) {
                goto clean0;
            }
            Err = pSetupBackupCopyString(QueueStringTable, &TargetFilename, PathStringTable, TargetFilename);
            if (Err != NO_ERROR) {
                goto clean0;
            }
            PathStringTable = QueueStringTable;
        }
        TargetInfo->TargetRoot = TargetRoot;
        TargetInfo->TargetSubDir = TargetSubDir;
        TargetInfo->TargetFilename = TargetFilename;
        TargetInfo->BackupRoot = -1;
        TargetInfo->BackupSubDir = -1;
        TargetInfo->BackupFilename = -1;
        TargetInfo->NewTargetFilename = -1;
        TargetInfo->InternalFlags = 0;

        PathID = pSetupStringTableAddStringEx(LookupTable, PathBuffer, 0, TargetInfo, sizeof(SP_TARGET_ENT));
        if (PathID == -1)
        {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
    }

    if (TableID != NULL) {
        *TableID = PathID;
    }

    Err = NO_ERROR;

clean0:
    if (FullTargetPath != NULL) {
        MyFree(FullTargetPath);
    }

    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupGetTargetByID(
    IN HSPFILEQ         QueueHandle,
    IN LONG             TableID,
    OUT PSP_TARGET_ENT  TargetInfo
    )
/*++

Routine Description:

    Given an entry in the LookupTable, gets info

Arguments:

    QueueHandle         - Queue we're looking at
    TableID             - ID relating to string entry we've found (via pSetupBackupGetTargetByPath)
    TargetInfo          - Filled with information about target

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/

{
    PVOID LookupTable = NULL;
    DWORD Err = NO_ERROR;
    PSP_FILE_QUEUE Queue;

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    try {
        LookupTable = Queue->TargetLookupTable;  // used for strings in source queue
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    if (pSetupStringTableGetExtraData(LookupTable, TableID, TargetInfo, sizeof(SP_TARGET_ENT)) == FALSE) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    Err = NO_ERROR;

clean0:
    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupSetTargetByID(
    IN HSPFILEQ         QueueHandle,
    IN LONG             TableID,
    IN PSP_TARGET_ENT   TargetInfo
    )
/*++

Routine Description:

    Given an entry in the LookupTable, sets info

Arguments:

    QueueHandle         - Queue we're looking at
    TableID             - ID relating to string entry we've found (via pSetupBackupGetTargetByPath)
    TargetInfo          - Filled with information about target

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/

{
    PVOID LookupTable = NULL;
    DWORD Err = NO_ERROR;
    PSP_FILE_QUEUE Queue;

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    try {
        LookupTable = Queue->TargetLookupTable;  // used for strings in source queue
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    if ( pSetupStringTableSetExtraData(LookupTable, TableID, TargetInfo, sizeof(SP_TARGET_ENT)) == FALSE) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    Err = NO_ERROR;

clean0:
    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupGetReinstallKeyStrings(
    IN PSP_FILE_QUEUE   BackupFileQueue,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN PCTSTR           DeviceID
    )
/*++

Routine Description:

    This routine will save the values needed to create the Reinstall backup key
    in the string table of the backup queue. We save these strings in the string
    table before the new drivers are installed and then create the registry key
    after the new device is installed. It is done this way because the Rollback
    UI code will look for the Reinstall subkeys, so we want to make sure that
    we have successfully backed-up all of the needed files before we create
    this Reinstall subkey.

Arguments:

    BackupFileQueue     -
    DeviceInfoSet       -
    DeviceInfoData      -
    DeviceID            -

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/
{
    DWORD Err = NO_ERROR;
    HKEY hKeyDevReg = INVALID_HANDLE_VALUE;
    DWORD RegCreated, cbData;
    TCHAR Buffer[MAX_PATH];

    try {

        //
        // Get the DeviceDesc of the device and fill in the BackupDevDescID and
        // BackupDisplayNameID values in the string table. This value is
        // required since it is needed during a rollback for us to choose the
        // exact driver that was installed from the specific INF.
        //
        if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                              DeviceInfoData,
                                              SPDRP_DEVICEDESC,
                                              NULL,
                                              (PBYTE)Buffer,
                                              sizeof(Buffer),
                                              NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        BackupFileQueue->BackupDeviceDescID =
            pSetupStringTableAddString(BackupFileQueue->StringTable,
                                       Buffer,
                                       STRTAB_CASE_SENSITIVE);

        if (BackupFileQueue->BackupDeviceDescID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // At this point we will also set the BackupDisplayNameID value just in
        // case the device does not have a FriendlyName.
        //
        BackupFileQueue->BackupDisplayNameID =
            pSetupStringTableAddString(BackupFileQueue->StringTable,
                                       Buffer,
                                       STRTAB_CASE_SENSITIVE);

        if (BackupFileQueue->BackupDisplayNameID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // We will try and get the device's FriendlyName. If it has one then we
        // will set the BackupDisplayNameID to this value, otherwise DisplayName
        // will just be the DeviceDesc.
        //
        if (SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                             DeviceInfoData,
                                             SPDRP_FRIENDLYNAME,
                                             NULL,
                                             (PBYTE)Buffer,
                                             sizeof(Buffer),
                                             NULL)) {

            BackupFileQueue->BackupDisplayNameID =
                pSetupStringTableAddString(BackupFileQueue->StringTable,
                                           Buffer,
                                           STRTAB_CASE_SENSITIVE);

            if (BackupFileQueue->BackupDisplayNameID == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
        }

        //
        // Set the BackupMfgID value.
        //
        if (!SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                              DeviceInfoData,
                                              SPDRP_MFG,
                                              NULL,
                                              (PBYTE)Buffer,
                                              sizeof(Buffer),
                                              NULL)) {
            Err = GetLastError();
            goto clean0;
        }

        BackupFileQueue->BackupMfgID =
            pSetupStringTableAddString(BackupFileQueue->StringTable,
                                       Buffer,
                                       STRTAB_CASE_SENSITIVE);

        if (BackupFileQueue->BackupMfgID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Set the BackupProviderNameID value.
        //
        hKeyDevReg = SetupDiOpenDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_READ
                                          );

        if (hKeyDevReg == INVALID_HANDLE_VALUE) {
            goto clean0;
        }

        cbData = sizeof(Buffer);
        Err = RegQueryValueEx(hKeyDevReg,
                              pszProviderName,
                              NULL,
                              NULL,
                              (PBYTE)Buffer,
                              &cbData
                              );

        RegCloseKey(hKeyDevReg);

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        BackupFileQueue->BackupProviderNameID =
            pSetupStringTableAddString(BackupFileQueue->StringTable,
                                       Buffer,
                                       STRTAB_CASE_SENSITIVE);

        if (BackupFileQueue->BackupProviderNameID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Set the DeviceInstanceIds value. This is a multi-sz value so make
        // sure we put a double NULL on the end.
        //
        BackupFileQueue->BackupDeviceInstanceID =
            pSetupStringTableAddString(BackupFileQueue->StringTable,
                                       (PTSTR)DeviceID,
                                       STRTAB_CASE_SENSITIVE);

        if (BackupFileQueue->BackupDeviceInstanceID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }


clean0: ;   // Nothing to do.


    } except(EXCEPTION_EXECUTE_HANDLER) {
          //
          // if we except, assume it's due to invalid parameter
          //
          Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupCreateReinstallKey(
    IN PSP_FILE_QUEUE   BackupFileQueue
    )
/*++

Routine Description:

    This routine will create the needed reinstall registry key so that these
    drivers can be later rolled back. The reinstall registry key lives in the
    following location:

        HKLM\Software\Microsoft\Windows\CurrentVersion\Reinstall\xxxx

    where xxxx is the BackupInstanceId.

    Under this key we will store the following information

        DisplayName         - This is the name that is displayed in any UI of
                              drivers that can be reinstalled. This is normally
                              just the device description.
        DeviceInstanceIds   - Multi-sz string of the device instance Ids of
                              every device that is using this backup. Setupapi
                              only sets the first device instance Id. Newdev
                              can append other device instance Ids to this list
                              if it is doing multiple device installs (in the
                              case of UpdateDriverForPlugAndPlayDevices or
                              InstallWindowsUpdateDriver).
        ReinstallString     - The full backup path including the INF file
        DeviceDesc          - The DeviceDesc of the driver that was installed.
                              This is needed to make sure we pick the identical
                              driver during a roll back.
        Mfg                 - The Mfg of the driver that was installed.
                              This is needed to make sure we pick the identical
                              driver during a roll back.
        ProviderName        - The ProviderName of the driver that was installed.
                              This is needed to make sure we pick the identical
                              driver during a roll back.


Arguments:

    BackupFileQueue         -

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/
{
    DWORD Err = NO_ERROR;
    HKEY hKeyReinstall = INVALID_HANDLE_VALUE;
    HKEY hKeyReinstallInstance = INVALID_HANDLE_VALUE;
    DWORD RegCreated, cbData;
    TCHAR Buffer[MAX_PATH];
    BOOL b;

    try {

        //
        // Make sure the BackupInfID is valid. If it is -1 then something went
        // wrong during the backup and so we do not want to create the Reinstall
        // instance subkey.
        //
        if (BackupFileQueue->BackupInfID == -1) {

            Err = ERROR_NO_BACKUP;
            goto clean0;
        }

        //
        // Open/Create the Reinstall registry key. Call RegCreateKeyEx in case
        // this is the first time a backup is being performed and this key
        // does not yet exist.
        //
        Err = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                             pszReinstallPath,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hKeyReinstall,
                             &RegCreated
                             );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Create the Reinstall instance key under the Reinstall key.
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupInstanceID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegCreateKeyEx(hKeyReinstall,
                             Buffer,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_WRITE,
                             NULL,
                             &hKeyReinstallInstance,
                             &RegCreated
                             );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Add the DeviceDesc to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupDeviceDescID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegSetValueEx(hKeyReinstallInstance,
                            pszDeviceDesc,
                            0,
                            REG_SZ,
                            (PBYTE)Buffer,
                            (lstrlen(Buffer) + 1) * sizeof(TCHAR)
                            );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Add the DisplayName to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupDisplayNameID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        RegSetValueEx(hKeyReinstallInstance,
                      pszReinstallDisplayName,
                       0,
                       REG_SZ,
                       (PBYTE)Buffer,
                       (lstrlen(Buffer) + 1) * sizeof(TCHAR)
                       );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Add the Mfg to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupMfgID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegSetValueEx(hKeyReinstallInstance,
                            pszMfg,
                            0,
                            REG_SZ,
                            (PBYTE)Buffer,
                            (lstrlen(Buffer) + 1) * sizeof(TCHAR)
                            );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Add the ProviderName to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupProviderNameID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegSetValueEx(hKeyReinstallInstance,
                            pszProviderName,
                            0,
                            REG_SZ,
                            (PBYTE)Buffer,
                            (lstrlen(Buffer) + 1) * sizeof(TCHAR)
                            );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Set the DeviceInstanceIds value. This is a multi-sz value so make
        // sure we put a double NULL on the end.
        //
        //
        // Add the Mfg to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        ZeroMemory(Buffer, sizeof(Buffer));
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupDeviceInstanceID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegSetValueEx(hKeyReinstallInstance,
                            pszReinstallDeviceInstanceIds,
                            0,
                            REG_MULTI_SZ,
                            (PBYTE)Buffer,
                            (lstrlen(Buffer) + 2) * sizeof(TCHAR)
                            );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

        //
        // Add the ReinstallString to the Reinstall instance subkey
        //
        cbData = MAX_PATH;
        b = pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                            BackupFileQueue->BackupInfID,
                                            Buffer,
                                            &cbData);
        if (b == FALSE) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        Err = RegSetValueEx(hKeyReinstallInstance,
                            pszReinstallString,
                            0,
                            REG_SZ,
                            (PBYTE)Buffer,
                            (lstrlen(Buffer) + 1) * sizeof(TCHAR)
                            );

        if (Err != ERROR_SUCCESS) {
            goto clean0;
        }

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
          //
          // if we except, assume it's due to invalid parameter
          //
          Err = ERROR_INVALID_PARAMETER;
    }

    if (hKeyReinstallInstance != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyReinstallInstance);
    }

    if (hKeyReinstall != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyReinstall);
    }

    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupBackupAppendFiles(
    IN HSPFILEQ         TargetQueueHandle,
    IN PCTSTR           BackupSubDir,
    IN DWORD            BackupFlags,
    IN HSPFILEQ         SourceQueueHandle OPTIONAL
    )
/*++

Routine Description:

    This routine will take a list of files from SourceQueueHandle Copy sub-queue's
    These files will appear in the Target Queue's target cache
    And may be placed into the Target Backup Queue
    Typically the copy queue is entries of..
        <oldsrc-root>\<oldsrc-sub>\<oldsrc-name> copied to
        <olddest-path>\<olddest-name>

Arguments:

    TargetQueueHandle   - Where Backups are queued to
    BackupSubDir        - Directory to backup to, relative to backup root
    BackupFlags         - How backup should occur
    SourceQueueHandle   - Handle that has a series of copy operations (backup hint)
                          created, say, by pretending to do the re-install
                          If not specified, only flags are passed

Return Value:

    Returns error code (LastError is also set)
    If the function succeeds, returns NO_ERROR

--*/
{
    TCHAR BackupPath[MAX_PATH];
    PSP_FILE_QUEUE SourceQueue = NULL;
    PSP_FILE_QUEUE TargetQueue = NULL;
    PSP_FILE_QUEUE_NODE QueueNode = NULL;
    PSOURCE_MEDIA_INFO SourceMediaInfo = NULL;
    BOOL b = TRUE;
    PVOID SourceStringTable = NULL;
    PVOID TargetStringTable = NULL;
    LONG BackupRootID = -1;
    DWORD Err = NO_ERROR;
    LONG PathID = -1;
    SP_TARGET_ENT TargetInfo;

    SourceQueue = (PSP_FILE_QUEUE)SourceQueueHandle; // optional
    TargetQueue = (PSP_FILE_QUEUE)TargetQueueHandle;

    b=TRUE; // set if we can skip this routine
    try {

        TargetStringTable = TargetQueue->StringTable;  // used for strings in target queue

        if (SourceQueue == NULL) {
            b = TRUE; // nothing to do
        } else {
            SourceStringTable = SourceQueue->StringTable;  // used for strings in source queue
            b = (!SourceQueue->CopyNodeCount);
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    // these are backup flags to be passed into the queue
    if (BackupFlags & SP_BKFLG_CALLBACK) {
        TargetQueue->Flags |= FQF_BACKUP_AWARE;
    }

    if (b) {
        // nothing to do
        goto clean0;
    }

    //
    // get full directory path of backup - this appears as the "dest" for any backup entries
    //
    if ( BackupSubDir == NULL ) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    if ( pSetupGetFullBackupPath(BackupPath, BackupSubDir, MAX_PATH,NULL) == FALSE ) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    //
    // Target will often use this, so we create the ID now instead of later
    //
    BackupRootID = pSetupStringTableAddString(TargetStringTable,
                                              BackupPath,
                                              STRTAB_CASE_SENSITIVE);
    if (BackupRootID == -1) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // CopyQueue is split over a number of media's
    // we're not (currently) bothered about media
    // iterate through all the copy sub-queue's
    // and (1) add them to the target lookup table
    // (2) if wanted, add them into the backup queue

    for (SourceMediaInfo=SourceQueue->SourceMediaList; SourceMediaInfo!=NULL ; SourceMediaInfo=SourceMediaInfo->Next) {
        if (!SourceMediaInfo->CopyNodeCount) {
            continue;
        }
        MYASSERT(SourceMediaInfo->CopyQueue);

        for (QueueNode = SourceMediaInfo->CopyQueue; QueueNode!=NULL; QueueNode = QueueNode->Next) {
            // for each "Copy"
            // we want information about the destination path
            //

            Err = pSetupBackupGetTargetByPath(TargetQueueHandle,
                                                    SourceStringTable,
                                                    NULL, // precalculated string
                                                    QueueNode->TargetDirectory,
                                                    -1,
                                                    QueueNode->TargetFilename,
                                                    &PathID,
                                                    &TargetInfo);
            if (Err != NO_ERROR) {
                goto clean0;
            }

            // we now have a created (or obtained) TargetInfo, and PathID
            // provide a source name for backup
            TargetInfo.BackupRoot = BackupRootID;
            Err = pSetupBackupCopyString(TargetStringTable, &TargetInfo.BackupSubDir, SourceStringTable, QueueNode->SourcePath);
            if (Err != NO_ERROR) {
                goto clean0;
            }
            Err = pSetupBackupCopyString(TargetStringTable, &TargetInfo.BackupFilename, SourceStringTable, QueueNode->SourceFilename);
            if (Err != NO_ERROR) {
                goto clean0;
            }

            if ((BackupFlags & SP_BKFLG_LATEBACKUP) == FALSE) {
                // we need to add this item to the backup queue
                Err = pSetupQueueBackupCopy(TargetQueueHandle,
                                      // source
                                      TargetInfo.TargetRoot,
                                      TargetInfo.TargetSubDir,
                                      TargetInfo.TargetFilename,
                                      TargetInfo.BackupRoot,
                                      TargetInfo.BackupSubDir,
                                      TargetInfo.BackupFilename);

                if (Err != NO_ERROR) {
                    goto clean0;
                }
                // flag that we've added it to the pre-copy backup sub-queue
                TargetInfo.InternalFlags |= SP_TEFLG_BACKUPQUEUE;
            }

            // any backups should go to this specified directory
            TargetInfo.InternalFlags |= SP_TEFLG_ORIGNAME;

            Err = pSetupBackupSetTargetByID(TargetQueueHandle, PathID, &TargetInfo);
            if (Err != NO_ERROR) {
                goto clean0;
            }

        }
    }

    Err = NO_ERROR;

clean0:

    SetLastError(Err);
    return (Err);
}

//
// ==========================================================
//

DWORD
pSetupBackupFile(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR TargetPath,
    IN PCTSTR BackupPath,
    IN LONG   TargetID,         OPTIONAL
    IN LONG   TargetRootPath,
    IN LONG   TargetSubDir,
    IN LONG   TargetFilename,
    IN LONG   BackupRootPath,
    IN LONG   BackupSubDir,
    IN LONG   BackupFilename,
    OUT BOOL *InUseFlag
    )
/*++

Routine Description:

    If BackupFilename not supplied, it is obtained/created
    Will either
    1) copy a file to the backup directory, or
    2) queue that a file is backed up on reboot
    The latter occurs if the file was locked.

Arguments:

HSPFILEQ    - QueueHandle   - specifies Queue
LONG        - TargetID      - if specified (not -1), use for target
LONG        - TargetRootPath - used if TargetID == -1
LONG        - TargetSubDir - used if TargetID == -1
LONG        - TargetFilename - used if TargetID == -1
LONG        - BackupRootPath - alternate root (valid if BackupFilename != -1)
LONG        - BackupSubDir - alternate directory (valid if BackupFilename != -1)
LONG        - BackupFilename - alternate filename

Return Value:

    If the function succeeds, return value is TRUE
    If the function fails, return value is FALSE

--*/
{
    PSP_FILE_QUEUE Queue = NULL;
    PVOID StringTable = NULL;
    PVOID LookupTable = NULL;
    DWORD Err = NO_ERROR;
    SP_TARGET_ENT TargetInfo;
    PTSTR FullTargetPath = NULL;
    PTSTR FullBackupPath = NULL;
    BOOL InUse = FALSE;
    PTSTR TempNamePtr = NULL, DirTruncPos;
    TCHAR TempPath[MAX_PATH];
    TCHAR TempFilename[MAX_PATH];
    TCHAR ParsedPath[MAX_PATH];
    UINT OldMode;
    LONG NewTargetFilename;
    BOOL DoRename = FALSE;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    Queue = (PSP_FILE_QUEUE)QueueHandle;

    try {
        StringTable = Queue->StringTable;  // used for strings in source queue
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }

    if(TargetPath == NULL && TargetID == -1) {

        if (TargetRootPath == -1 || TargetFilename == -1) {
            Err = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        // complete target path

        FullTargetPath = pSetupFormFullPath(
                                           StringTable,
                                           TargetRootPath,
                                           TargetSubDir,
                                           TargetFilename
                                           );

        if (!FullTargetPath) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        TargetPath = FullTargetPath;

    }

    if (TargetID == -1) {
        Err = pSetupBackupGetTargetByPath(QueueHandle,
                                                NULL, // string table
                                                TargetPath, // precalculated string
                                                TargetRootPath,
                                                TargetSubDir,
                                                TargetFilename,
                                                &TargetID,
                                                &TargetInfo);
    } else {
        Err = pSetupBackupGetTargetByID(QueueHandle,
                                                TargetID,
                                                &TargetInfo);
    }

    if(Err != NO_ERROR) {
        goto clean0;
    }

    //
    // if we're not interested in backing up (global flag) we can skip
    // but it's only safe to do so if we'd copy & then later throw the copy away on success
    // note that if FQF_DEVICE_BACKUP is set, we'll always backup
    //
    if (((TargetInfo.InternalFlags & SP_TEFLG_RENAMEEXISTING) == 0)
         && ((Queue->Flags & FQF_DEVICE_BACKUP)==0)
         && ((GlobalSetupFlags & PSPGF_NO_BACKUP)!=0)) {

        Err = NO_ERROR;
        goto clean0;
    }
    //
    // Figure out whether we've been asked to rename the existing file to a
    // temp name in the same directory, but haven't yet done so.
    //
    DoRename = ((TargetInfo.InternalFlags & (SP_TEFLG_RENAMEEXISTING | SP_TEFLG_MOVED)) == SP_TEFLG_RENAMEEXISTING);

    if(BackupFilename == -1) {
        //
        // non-specific backup
        //
        if((TargetInfo.InternalFlags & SP_TEFLG_SAVED) && !DoRename) {
            //
            // Already backed up, and we don't need to rename the existing file.
            // Nothing to do.
            //
            Err = NO_ERROR;
            goto clean0;
        }

        if(TargetInfo.InternalFlags & SP_TEFLG_INUSE) {
            //
            // Previously marked as INUSE, not allowed to change it.  If we
            // were asked to rename the existing file, then we need to return
            // failure, otherwise, we can report success.
            //
            //
            InUse = TRUE;

            Err = DoRename ? ERROR_SHARING_VIOLATION : NO_ERROR;
            goto clean0;
        }

        if(TargetInfo.InternalFlags & SP_TEFLG_ORIGNAME) {
            //
            // original name given, use that
            //
            BackupRootPath = TargetInfo.BackupRoot;
            BackupSubDir = TargetInfo.BackupSubDir;
            BackupFilename = TargetInfo.BackupFilename;
        }

    } else {
        //
        // We should never be called if the file has already been
        // saved.
        //
        MYASSERT(!(TargetInfo.InternalFlags & SP_TEFLG_SAVED));

        //
        // Even if the above assert fires, we should still deal with
        // the case where this occurs.  Also, we should deal with the
        // case where a backup was previously attempted but failed due
        // to the file being in-use.
        //
        if(TargetInfo.InternalFlags & SP_TEFLG_SAVED) {
            //
            // nothing to do, we shouldn't treat this as an actual error
            //
            Err = NO_ERROR;
            goto clean0;
        } else if(TargetInfo.InternalFlags & SP_TEFLG_INUSE) {
            //
            // force the issue of InUse
            //
            InUse = TRUE;

            Err = ERROR_SHARING_VIOLATION;
            goto clean0;
        }

        TargetInfo.BackupRoot = BackupRootPath;
        TargetInfo.BackupSubDir = BackupSubDir;
        TargetInfo.BackupFilename = BackupFilename;
        TargetInfo.InternalFlags |= SP_TEFLG_ORIGNAME;
        TargetInfo.InternalFlags &= ~SP_TEFLG_TEMPNAME;
    }

    if(TargetPath == NULL) {
        //
        // must have looked up using TargetID, use TargetInfo to generate TargetPath
        // complete target path
        //
        FullTargetPath = pSetupFormFullPath(StringTable,
                                            TargetInfo.TargetRoot,
                                            TargetInfo.TargetSubDir,
                                            TargetInfo.TargetFilename
                                           );

        if(!FullTargetPath) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        TargetPath = FullTargetPath;
    }

    if(DoRename) {
        //
        // We'd better not already have a temp filename stored in our TargetInfo.
        //
        MYASSERT(TargetInfo.NewTargetFilename == -1);

        //
        // First, strip the filename off the path.
        //
        _tcscpy(TempPath, TargetPath);
        TempNamePtr = (PTSTR)pSetupGetFileTitle(TempPath);
        *TempNamePtr = TEXT('\0');

        //
        // Now get a temp filename within that directory...
        //
        if(GetTempFileName(TempPath, TEXT("OLD"), 0, TempFilename) == 0 ) {
            Err = GetLastError();
            goto clean0;
        }

        //
        // ...and store this path's string ID in our TargetInfo
        //
        NewTargetFilename = pSetupStringTableAddString(StringTable,
                                                 TempFilename,
                                                 STRTAB_CASE_SENSITIVE
                                                );

        if(NewTargetFilename == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
    }

    if(!(TargetInfo.InternalFlags & (SP_TEFLG_ORIGNAME | SP_TEFLG_TEMPNAME))) {
        //
        // If we don't yet have a name to use in backing up this file, then
        // generate one now.  If we are doing a rename, we can use that name.
        //
        if(DoRename) {
            //
            // Make sure that all flags agree on the fact that we need to back
            // up this file.
            //
            MYASSERT(!(TargetInfo.InternalFlags & SP_TEFLG_SAVED));

            //
            // Temp filename was stored in TempFilename buffer above.
            //
            TempNamePtr = (PTSTR)pSetupGetFileTitle(TempFilename);

            BackupFilename = pSetupStringTableAddString(StringTable, TempNamePtr, STRTAB_CASE_SENSITIVE);
            if(BackupFilename == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            DirTruncPos = CharPrev(TempFilename, TempNamePtr);

            //
            // (We know pSetupGetFileTitle will never return a pointer to a path
            // separator character, so the following check is valid.)
            //
            if(*DirTruncPos == TEXT('\\')) {
                //
                // If this is in a root directory (e.g., "A:\"), then we don't want to strip off
                // the trailing backslash.
                //
                if(((DirTruncPos - TempFilename) != 2) || (*CharNext(TempFilename) != TEXT(':'))) {
                    TempNamePtr = DirTruncPos;
                }
            }

            lstrcpyn(TempPath, TempFilename, (int)(TempNamePtr - TempFilename) + 1);

            BackupRootPath = pSetupStringTableAddString(StringTable, TempPath, STRTAB_CASE_SENSITIVE);
            if(BackupRootPath == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

        } else {

            //
            // specify "NULL" as the sub-directory, since all we want is a temporary location
            //
            if(pSetupGetFullBackupPath(TempPath, NULL, MAX_PATH,NULL) == FALSE ) {
                Err = ERROR_INVALID_HANDLE;
                goto clean0;
            }
            _tcscpy(TempFilename,TempPath);

            //
            // Note:  In the code below, we employ a "trick" to get the
            // pSetupMakeSurePathExists API to make sure that a directory
            // exists.  Since we don't yet know the filename (we need to call
            // GetTempFileName against an existing directory to find that out),
            // we just use a dummy placeholder filename ("OLD") so that it can
            // be discarded by the pSetupMakeSurePathExists API.
            //
            if(pSetupConcatenatePaths(TempFilename, TEXT("OLD"), MAX_PATH, NULL) == FALSE ) {
                Err = GetLastError();
                goto clean0;
            }
            pSetupMakeSurePathExists(TempFilename);
            if(GetTempFileName(TempPath, TEXT("OLD"), 0, TempFilename) == 0 ) {
                Err = GetLastError();
                goto clean0;
            }

            TempNamePtr = TempFilename + _tcslen(TempPath) + 1 /* 1 to skip past \ */;
            BackupRootPath = pSetupStringTableAddString( StringTable, TempPath, STRTAB_CASE_SENSITIVE );
            if(BackupRootPath == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
            BackupFilename = pSetupStringTableAddString( StringTable, TempNamePtr, STRTAB_CASE_SENSITIVE );
            if(BackupFilename == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }
        }

        BackupPath = TempFilename;

        TargetInfo.BackupRoot = BackupRootPath;
        TargetInfo.BackupSubDir = BackupSubDir = -1;
        TargetInfo.BackupFilename = BackupFilename;
        TargetInfo.InternalFlags |= SP_TEFLG_TEMPNAME;

    }


    if(BackupPath == NULL) {
        //
        // make a complete path from this source
        //
        FullBackupPath = pSetupFormFullPath(StringTable,
                                            BackupRootPath,
                                            BackupSubDir,
                                            BackupFilename
                                           );

        if (!FullBackupPath) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        BackupPath = FullBackupPath;
    }

    //
    // If we need to make a copy of the existing file, do so now.
    //
    if(!DoRename || (TargetInfo.InternalFlags & SP_TEFLG_ORIGNAME)) {

        SetFileAttributes(BackupPath, FILE_ATTRIBUTE_NORMAL);
        pSetupMakeSurePathExists(BackupPath);
        Err = CopyFile(TargetPath, BackupPath, FALSE) ? NO_ERROR : GetLastError();

        if(Err == NO_ERROR) {
            TargetInfo.InternalFlags |= SP_TEFLG_SAVED;
        } else {
            //
            // Delete placeholder file created by GetTempFileName.
            //
            SetFileAttributes(BackupPath, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(BackupPath);

            if(Err == ERROR_SHARING_VIOLATION) {
                //
                // Unless we were also going to attempt a rename, don't
                // consider sharing violations to be errors.
                //
                InUse = TRUE;
                TargetInfo.InternalFlags |= SP_TEFLG_INUSE;
                if(!DoRename) {
                    Err = NO_ERROR;
                }
            }
        }
    }

    //
    // OK, now rename the existing file, if necessary.
    //
    if(DoRename && (Err == NO_ERROR)) {

        if(DoMove(TargetPath, TempFilename)) {

            TargetInfo.InternalFlags |= SP_TEFLG_MOVED;
            TargetInfo.NewTargetFilename = NewTargetFilename;

            //
            // Post a delayed deletion for this temp filename so it'll get
            // cleaned up after reboot.
            //
            if(!PostDelayedMove(Queue, TempFilename, NULL, -1, FALSE)) {
                //
                // Don't abort just because we couldn't schedule a delayed
                // delete.  If this fails, the only bad thing that will happen
                // is a turd will get left over after reboot.
                //
                // We should log an event about this, however.
                //
                Err = GetLastError();

                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                              MSG_LOG_RENAME_EXISTING_DELAYED_DELETE_FAILED,
                              NULL,
                              TargetPath,
                              TempFilename
                             );

                WriteLogError(Queue->LogContext,
                              SETUP_LOG_WARNING,
                              Err
                             );

                Err = NO_ERROR;
            }

        } else {
            Err = GetLastError();
            SetFileAttributes(TempFilename, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(TempFilename);
            if(Err == ERROR_SHARING_VIOLATION) {
                InUse = TRUE;
                TargetInfo.InternalFlags |= SP_TEFLG_INUSE;
            }
        }
    }

    //
    // update internal info (this call should never fail)
    //
    pSetupBackupSetTargetByID(QueueHandle,
                              TargetID,
                              &TargetInfo
                             );

clean0:

    if (FullTargetPath != NULL) {
        MyFree(FullTargetPath);
    }
    if (FullBackupPath != NULL) {
        MyFree(FullBackupPath);
    }
    if (Err != NO_ERROR) {
        //
        // note the fact that at least one backup error has occurred
        //
        Queue->Flags |= FQF_BACKUP_INCOMPLETE;
    }

clean1:
    SetErrorMode(OldMode);

    SetLastError(Err);

    if(InUseFlag) {
        *InUseFlag = InUse;
    }

    return Err;

}

//
// ==========================================================
//

VOID
pSetupDeleteBackup(
    IN PCTSTR           BackupInstance
    )
/*++

Routine Description:

    This function will delete an entire backup instance. This entails deleting
    the relative BackupInstance out of the registry Reinstall key as well

Arguments:

    BackupInstance - Instance Id of the backup

Return Value:

    If the function succeeds, return value is TRUE
    If the function fails, return value is FALSE

--*/
{
    TCHAR Buffer[MAX_PATH];
    HKEY hKeyReinstall = INVALID_HANDLE_VALUE;

    if (BackupInstance == NULL) {
        return;
    }

    //
    // Delete this instance from the Reinstall key.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     pszReinstallPath,
                     0,
                     KEY_ALL_ACCESS,
                     &hKeyReinstall
                     ) == ERROR_SUCCESS) {

        RegDeleteKey(hKeyReinstall, BackupInstance);

        RegCloseKey(hKeyReinstall);
    }


    //
    // Now delete the entire backup directory.
    //
    if (pSetupGetFullBackupPath(Buffer, BackupInstance, MAX_PATH, NULL)) {
        pRemoveDirectory(Buffer);
    }
}


//
// ==========================================================
//

DWORD
pSetupGetCurrentlyInstalledDriverNode(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Get driver node that relates to current INF file of device

Arguments:

    DeviceInfoSet
    DeviceInfoData

Return Value:

    Error Status

--*/
{
    DWORD Err;
    SP_DEVINSTALL_PARAMS DeviceInstallParams;
    SP_DRVINFO_DATA DriverInfoData;

    ZeroMemory(&DeviceInstallParams, sizeof(DeviceInstallParams));
    ZeroMemory(&DriverInfoData, sizeof(DriverInfoData));

    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    DeviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    if(!SetupDiGetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
        return GetLastError();
    }

    //
    // Set the flags that tell SetupDiBuildDriverInfoList to just put the currently installed
    // driver node in the list, and that it should allow excluded drivers.
    //
    DeviceInstallParams.FlagsEx |= (DI_FLAGSEX_INSTALLEDDRIVER | DI_FLAGSEX_ALLOWEXCLUDEDDRVS);

    if(!SetupDiSetDeviceInstallParams(DeviceInfoSet, DeviceInfoData, &DeviceInstallParams)) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Now build a class driver list that just contains the currently installed driver.
    //
    if(!SetupDiBuildDriverInfoList(DeviceInfoSet, DeviceInfoData, SPDIT_CLASSDRIVER)) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // The only driver in the list should be the currently installed driver, if there
    // is a currently installed driver.
    //
    if (!SetupDiEnumDriverInfo(DeviceInfoSet, DeviceInfoData, SPDIT_CLASSDRIVER,
                               0, &DriverInfoData)) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Make the currently installed driver the selected driver.
    //
    if(!SetupDiSetSelectedDriver(DeviceInfoSet, DeviceInfoData, &DriverInfoData)) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // At this point, we've successfully selected the currently installed driver for the specified
    // device information element.  We're done!
    //

    Err = NO_ERROR;

clean0:

    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

DWORD
pSetupGetBackupQueue(
    IN      PCTSTR      DeviceID,
    IN OUT  HSPFILEQ    FileQueue,
    IN      DWORD       BackupFlags
    )
/*++

Routine Description:

    Creates a backup Queue for current device (DeviceID)
    Also makes sure that the INF file is backed up

Arguments:

    DeviceID            String ID of device
    FileQueue           Backup queue is filled with files that need copying
    BackupFlags         Various flags

Return Value:

    Error Status

--*/


{

    //
    // we want to obtain a copy/move list of device associated with DeviceID
    //
    //
    PSP_FILE_QUEUE FileQ = (PSP_FILE_QUEUE)FileQueue;
    HDEVINFO TempInfoSet = (HDEVINFO)INVALID_HANDLE_VALUE;
    HSPFILEQ TempQueueHandle = (HSPFILEQ)INVALID_HANDLE_VALUE;
    SP_DEVINFO_DATA TempInfoData;
    SP_DEVINSTALL_PARAMS TempParams;
    TCHAR SubDir[MAX_PATH];
    LONG Instance;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PTSTR szInfFileName = NULL;
    PTSTR szInfFileNameExt = NULL;
    PTSTR BackupPathExt = NULL;
    TCHAR BackupInstance[MAX_PATH];
    TCHAR BackupPath[MAX_PATH];
    TCHAR ReinstallString[MAX_PATH];
    TCHAR OemOrigName[MAX_PATH];
    TCHAR CatBackupPath[MAX_PATH];
    TCHAR CatSourcePath[MAX_PATH];
    DWORD Err;
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    int InstanceId;
    DWORD BackupInfID = -1;
    DWORD BackupInstanceID = -1;
    PSP_INF_INFORMATION pInfInformation = NULL;
    DWORD InfInformationSize;
    SP_ORIGINAL_FILE_INFO InfOriginalFileInformation;
    BOOL success;
    PSETUP_LOG_CONTEXT SavedLogContext = NULL;
    PSETUP_LOG_CONTEXT LocalLogContext = NULL;
    BOOL  ChangedThreadLogContext = FALSE;

    //
    // if backup information exists, abort (no flags will be set)
    //
    if(FileQ->BackupInfID != -1) {
        return ERROR_ALREADY_EXISTS;
    }

    //
    // detach any backup related logging from current log section
    // putting it into it's own section
    // this stops confusion when debugging (v)verbose logs
    // and we're going down this path
    //
    CreateLogContext(NULL,FALSE,&LocalLogContext);
    if(LocalLogContext) {
        DWORD LogTag = AllocLogInfoSlot(LocalLogContext,TRUE);
        if(LogTag) {
            WriteLogEntry(LocalLogContext,
                          LogTag,
                          MSG_LOG_DRIVERBACKUP,
                          NULL,
                          DeviceID
                         );
        }

    }
    ChangedThreadLogContext = SetThreadLogContext(LocalLogContext,&SavedLogContext);

    CatBackupPath[0] = 0; // by default, don't bother with a catalog
    CatSourcePath[0] = 0;

    // pretend we're installing old INF
    // this gives us a list of files we need

    TempInfoSet = SetupDiCreateDeviceInfoList(NULL, NULL);
    if ( TempInfoSet == (HDEVINFO)INVALID_HANDLE_VALUE ) {
        Err = GetLastError();
        goto clean0;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(TempInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }
    //
    // make sure info-set has our local context
    //
    InheritLogContext(LocalLogContext,&pDeviceInfoSet->InstallParamBlock.LogContext);

    //
    // Open the driver info, related to DeviceID I was given
    //

    TempInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if ( SetupDiOpenDeviceInfo(TempInfoSet ,DeviceID, NULL, 0, &TempInfoData) == FALSE ) {
        Err = GetLastError();
        goto clean0;
    }
    //
    // make sure the temporary element has our backup logging context
    //
    DevInfoElem = FindAssociatedDevInfoElem(TempInfoSet,
                                                 &TempInfoData,
                                                 NULL);
    MYASSERT(DevInfoElem);
    if(DevInfoElem) {
        InheritLogContext(LocalLogContext,&DevInfoElem->InstallParamBlock.LogContext);
    }

    //
    // Get the currently-installed driver node selected for this element.
    //
    if ( pSetupGetCurrentlyInstalledDriverNode(TempInfoSet, &TempInfoData) != NO_ERROR ) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Now queue all files to be copied by this driver node into our own file queue.
    // it'll inherit the backup logging context
    //
    TempQueueHandle = SetupOpenFileQueue();

    if ( TempQueueHandle == (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        //
        // SetupOpenFileQueue modified to return error
        //
        Err = GetLastError();
        goto clean0;
    }

    TempParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);
    if ( !SetupDiGetDeviceInstallParams(TempInfoSet, &TempInfoData, &TempParams) ) {
        Err = GetLastError();
        goto clean0;
    }

    TempParams.FileQueue = TempQueueHandle;
    TempParams.Flags |= DI_NOVCP;

    if ( !SetupDiSetDeviceInstallParams(TempInfoSet, &TempInfoData, &TempParams) ) {
        Err = GetLastError();
        goto clean0;
    }

    if ( !SetupDiCallClassInstaller(DIF_INSTALLDEVICEFILES, TempInfoSet, &TempInfoData) ) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // We want this backup to be in a unique directory. To do this we just do
    // the standard instance number trick where we enumerate from 0000 to 9999
    // and choose the first number where there isn't a backup directory with
    // that name already created.
    //
    for (InstanceId=0; InstanceId<=9999; InstanceId++) {

        wsprintf(SubDir, TEXT("\\%04d\\%s"), (LONG) InstanceId, (PCTSTR) SP_BACKUP_DRIVERFILES );

        if ( pSetupGetFullBackupPath(BackupPath, SubDir, MAX_PATH, NULL) == FALSE ) {
            Err = ERROR_INVALID_HANDLE;
            goto clean0;
        }

        //
        // If this backup path does not exist then we have a valid directory.
        //
        if (!FileExists(BackupPath, NULL)) {
            break;
        }
    }

    if (InstanceId <= 9999) {
        //
        // Add string indicating Backup InstanceID to file Queue
        // for later retrieval
        //
        wsprintf(BackupInstance, TEXT("%04d"), (LONG) InstanceId);
        BackupInstanceID = pSetupStringTableAddString(FileQ->StringTable,
                                                  BackupInstance,
                                                  STRTAB_CASE_SENSITIVE);
        if (BackupInstanceID == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
    } else {
        //
        // If we don't have any free backup directories then we will fail. There
        // should never be this many drivers backed up so this shouldn't be a
        // problem.
        //
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // get the path of the INF file, we will need to back it up
    //
    if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                 &TempInfoData,
                                                 NULL))) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }
    szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                             DevInfoElem->SelectedDriver->InfFileName
                                            );
    if (szInfFileName == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // we want to get the "real" name of the INF - we may have a precompiled inf
    //

    ZeroMemory(&InfOriginalFileInformation, sizeof(InfOriginalFileInformation));

    //
    // if nothing else, use same name as is in the INF directory
    //
    lstrcpy(OemOrigName,pSetupGetFileTitle(szInfFileName));

    //
    // but use the original name if available
    //
    InfInformationSize = 8192;  // I'd rather have this too big and succeed first time, than read the INF twice
    pInfInformation = (PSP_INF_INFORMATION)MyMalloc(InfInformationSize);

    if (pInfInformation != NULL) {
        success = SetupGetInfInformation(szInfFileName,INFINFO_INF_NAME_IS_ABSOLUTE,pInfInformation,InfInformationSize,&InfInformationSize);
        if (!success && GetLastError()==ERROR_INSUFFICIENT_BUFFER) {
            PVOID newbuff = MyRealloc(pInfInformation,InfInformationSize);
            if (!newbuff) {
                MyFree(pInfInformation);
                pInfInformation = NULL;
            } else {
                pInfInformation = (PSP_INF_INFORMATION)newbuff;
                success = SetupGetInfInformation(szInfFileName,INFINFO_INF_NAME_IS_ABSOLUTE,pInfInformation,InfInformationSize,&InfInformationSize);
            }
        }
        if (success) {
            InfOriginalFileInformation.cbSize = sizeof(InfOriginalFileInformation);
            if (SetupQueryInfOriginalFileInformation(pInfInformation,0,NULL,&InfOriginalFileInformation)) {
                if (InfOriginalFileInformation.OriginalInfName[0]) {
                    //
                    // we have a "real" inf name
                    //
                    lstrcpy(OemOrigName,pSetupGetFileTitle(InfOriginalFileInformation.OriginalInfName));
                } else {
                    MYASSERT(InfOriginalFileInformation.OriginalInfName[0]);
                }

                //
                // Don't bother finding out about the INF's catalog if we're in
                // "minimal embedded" mode...
                //
                if(!(GlobalSetupFlags & PSPGF_MINIMAL_EMBEDDED)) {

                    if (InfOriginalFileInformation.OriginalCatalogName[0]) {

                        TCHAR CurrentCatName[MAX_PATH];

                        //
                        // given that the file is ....\OEMx.INF the catalog is "OEMx.CAT"
                        // we key off OemOrigName (eg mydisk.inf )
                        // and we won't bother copying the catalog if we can't verify the inf
                        //
                        lstrcpy(CurrentCatName,pSetupGetFileTitle(szInfFileName));
                        lstrcpy(_tcsrchr(CurrentCatName, TEXT('.')), pszCatSuffix);

                        //
                        // we have a catalog name
                        // now consider making a copy of the cached catalog 
                        // into our backup we get out CatProblem and 
                        // szCatFileName
                        //
                        // if all seems ok, copy file from szCatFileName to
                        // backupdir\OriginalCatalogName
                        //

                        Err = _VerifyFile(
                                  FileQ->LogContext,
                                  &(FileQ->VerifyContext),
                                  CurrentCatName, // eg "OEMx.CAT"
                                  NULL,0,         // we're not verifying against another catalog image
                                  OemOrigName,    // eg "mydisk.inf"
                                  szInfFileName,  // eg "....\OEMx.INF"
                                  NULL,           // return: problem info
                                  NULL,           // return: problem file
                                  FALSE,          // has to be FALSE because we're getting full path
                                  ((PSP_FILE_QUEUE)TempQueueHandle)->ValidationPlatform, // alt platform info
                                  VERIFY_FILE_IGNORE_SELFSIGNED | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK,
                                  CatSourcePath,  // return: catalog file, full path
                                  NULL,           // return: number of catalogs considered
                                  NULL,
                                  NULL,
                                  NULL
                                 );

                        if(Err != NO_ERROR) {
                            //
                            // There may be an Authenticode-signed catalog, so
                            // we'll look for that, too.
                            //
                            Err = _VerifyFile(
                                      FileQ->LogContext,
                                      &(FileQ->VerifyContext),
                                      CurrentCatName, // eg "OEMx.CAT"
                                      NULL,0,         // we're not verifying against another catalog image
                                      OemOrigName,    // eg "mydisk.inf"
                                      szInfFileName,  // eg "....\OEMx.INF"
                                      NULL,           // return: problem info
                                      NULL,           // return: problem file
                                      FALSE,          // has to be FALSE because we're getting full path
                                      ((PSP_FILE_QUEUE)TempQueueHandle)->ValidationPlatform, // alt platform info
                                      (VERIFY_FILE_IGNORE_SELFSIGNED 
                                        | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK
                                        | VERIFY_FILE_USE_AUTHENTICODE_CATALOG),
                                      CatSourcePath,  // return: catalog file, full path
                                      NULL,           // return: number of catalogs considered
                                      NULL,
                                      NULL,
                                      NULL
                                     );

                            //
                            // For the purposes of this routine, we don't care
                            // whether or not the publisher is in the
                            // TrustedPublisher store.
                            //
                            if((Err == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                               (Err == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {

                                Err = NO_ERROR;
                            }
                        }

                        if(Err == NO_ERROR && CatSourcePath[0]) {
                            //
                            // we have a catalog file of interest to copy
                            //
                            lstrcpy(CatBackupPath,BackupPath);
                            if (!pSetupConcatenatePaths(CatBackupPath, InfOriginalFileInformation.OriginalCatalogName, MAX_PATH, NULL)) {
                                //
                                // non-fatal
                                //
                                CatSourcePath[0]=0;
                                CatBackupPath[0]=0;
                            }
                        }
                    }
                }
            }
        }
        if (pInfInformation != NULL) {
            MyFree(pInfInformation);
            pInfInformation = NULL;
        }
    }
    if ( pSetupConcatenatePaths(BackupPath, OemOrigName, MAX_PATH, NULL) == FALSE ) {
        Err = ERROR_INVALID_HANDLE;
        goto clean0;
    }

    pSetupMakeSurePathExists(BackupPath);
    SetFileAttributes(BackupPath,FILE_ATTRIBUTE_NORMAL);
    Err = CopyFile(szInfFileName, BackupPath ,FALSE) ? NO_ERROR : GetLastError();

    if (Err != NO_ERROR) {
        goto clean0;
    }

    if(CatSourcePath[0] && CatBackupPath[0]) {
        //
        // if we copied Inf file, try to copy catalog file
        // if we don't succeed, don't consider this a fatal error
        //
        SetFileAttributes(CatBackupPath,FILE_ATTRIBUTE_NORMAL);
        CopyFile(CatSourcePath, CatBackupPath ,FALSE);
    }

    //
    // Add string indicating Backup INF location to file Queue
    // for later retrieval
    //

    BackupInfID = pSetupStringTableAddString(FileQ->StringTable,
                                              BackupPath,
                                              STRTAB_CASE_SENSITIVE);
    if (BackupInfID == -1) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    //
    // Save the full inf backup path since we need to put it in the registry
    // below.
    //
    lstrcpy(ReinstallString, BackupPath);

    //
    // Also backup the PNF file
    //
    // WARNING: We reuse the szInfFileName and BackupPath variables at this point
    // so if you add code that needs them then add it above.
    //
    szInfFileNameExt = _tcsrchr(szInfFileName,TEXT('.'));
    MYASSERT(szInfFileNameExt);
    BackupPathExt = _tcsrchr(BackupPath,TEXT('.'));
    MYASSERT(BackupPathExt);

    if (szInfFileNameExt && BackupPathExt) {
        lstrcpy(szInfFileNameExt,pszPnfSuffix);
        lstrcpy(BackupPathExt,pszPnfSuffix);
        SetFileAttributes(BackupPath,FILE_ATTRIBUTE_NORMAL);
        CopyFile(szInfFileName, BackupPath, FALSE);
    }

    //
    // add items we may need to backup
    // (ie the copy queue of TempQueueHandle is converted to a backup queue of FileQueue)
    //

    if ( pSetupBackupAppendFiles(FileQueue, SubDir, BackupFlags, TempQueueHandle) != NO_ERROR ) {
        Err = GetLastError();
        goto clean0;
    }

    //
    // Create the Reinstall registry key that points to the backup directory we
    // just made.
    //

    if (pSetupBackupGetReinstallKeyStrings(FileQ,
                                           TempInfoSet,
                                           &TempInfoData,
                                           DeviceID
                                       ) != NO_ERROR) {
        Err = GetLastError();
        goto clean0;
    }

    Err = NO_ERROR;

    //
    // update BackupInfID so that INF name can be queried later. We will set
    // these values at the very end since the fact that FileQ->BackupInfID is
    // not -1 means the backup initialization has been successful.
    //
    FileQ->BackupInfID = BackupInfID;
    FileQ->BackupInstanceID = BackupInstanceID;

    //
    // Set the FQF_DEVICE_BACKUP flag so that we know this is a device install
    // backup.
    //
    FileQ->Flags |= FQF_DEVICE_BACKUP;

clean0:

    //
    // If we encountered an error during our backup initialization then we want
    // to clean out the backup directory and Reinstall subkey.
    //
    if ((Err != NO_ERROR) &&
        (BackupInstanceID != -1)) {
        if (pSetupStringTableStringFromIdEx(FileQ->StringTable,
                                            BackupInstanceID,
                                            BackupInstance,
                                            NULL)) {
            pSetupDeleteBackup(BackupInstance);
        }
    }

    //
    // delete temporary structures used
    //
    if (pDeviceInfoSet != NULL ) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }
    if ( TempInfoSet != (HDEVINFO)INVALID_HANDLE_VALUE ) {
        SetupDiDestroyDeviceInfoList(TempInfoSet);
    }
    if ( TempQueueHandle != (HSPFILEQ)INVALID_HANDLE_VALUE ) {
        SetupCloseFileQueue(TempQueueHandle);
    }

    if(ChangedThreadLogContext) {
        //
        // restore thread log context if we changed (cleared) it
        //
        SetThreadLogContext(SavedLogContext,NULL);
    }
    DeleteLogContext(LocalLogContext);

    SetLastError(Err);

    return Err;
}

//
// ==========================================================
//

DWORD
pSetupCompleteBackup(
    IN OUT  HSPFILEQ    FileQueue
    )
/*++

Routine Description:

    This routine is called after we have successfully finished installing a
    device. At this point the new backup that we have created is valid and
    so any old backups that this device was using need to be removed.

    To do this the code will enumerate all of the backup instances under the
    Reinstall key and scan their DeviceInstanceIds multi-sz value. If it finds
    this DeviceInstanceId in the list then it will remove it. If the list is
    empty after this removal then the entire backup instance and its
    cooresponding backup directory will be deleted.

Arguments:

    FileQueue           Backup queue is filled with files that need copying

Return Value:

    Error Status

--*/


{
    PSP_FILE_QUEUE BackupFileQueue = (PSP_FILE_QUEUE)FileQueue;
    HKEY hKeyReinstall;
    HKEY hKeyReinstallInstance;
    DWORD Index;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    TCHAR ReinstallInstance[MAX_PATH];
    FILETIME ftLastWriteTime;
    DWORD cbData, cbInstanceSize;
    BOOL bDeleteBackupInstance;
    DWORD Err = NO_ERROR;
    PTSTR DeviceInstanceIdsList, p;

    try {

        //
        // If we don't have a BackupInfID then the backup failed, so don't bother
        // cleaning out the old backup information or creating the new Reinstall
        // instance key.
        //
        if (BackupFileQueue->BackupInfID == -1) {
            Err = ERROR_NO_BACKUP;
            goto clean0;
        }

        //
        // Get the Device Instance Id from the backup queue. This value must be
        // cleaned out from all other Reinstall Instance keys.
        //
        cbData = MAX_PATH;
        if (!pSetupStringTableStringFromIdEx(BackupFileQueue->StringTable,
                                             BackupFileQueue->BackupDeviceInstanceID,
                                             DeviceInstanceId,
                                             &cbData)) {
            if (cbData == 0) {
                Err = ERROR_NO_BACKUP;
            } else {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto clean0;
        }

        //
        // Open the Reinstall key so we can enumerate all of the instance subkeys.
        //
        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           pszReinstallPath,
                           0,
                           KEY_ALL_ACCESS,
                           &hKeyReinstall
                           );

        if (Err == ERROR_SUCCESS) {

            cbInstanceSize = sizeof(ReinstallInstance) / sizeof(TCHAR);
            Index = 0;
            while (RegEnumKeyEx(hKeyReinstall,
                                Index++,
                                ReinstallInstance,
                                &cbInstanceSize,
                                NULL,
                                NULL,
                                NULL,
                                &ftLastWriteTime
                                ) == ERROR_SUCCESS) {

                //
                // Assume that we don't need to delete this backup instance
                //
                bDeleteBackupInstance = FALSE;

                Err = RegOpenKeyEx(hKeyReinstall,
                                   ReinstallInstance,
                                   0,
                                   KEY_ALL_ACCESS,
                                   &hKeyReinstallInstance
                                   );

                if (Err == ERROR_SUCCESS) {

                    cbData = 0;
                    if ((RegQueryValueEx(hKeyReinstallInstance,
                                         pszReinstallDeviceInstanceIds,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &cbData
                                         ) == ERROR_SUCCESS) &&
                        (cbData)) {

                        DeviceInstanceIdsList = MyMalloc(cbData + sizeof(TCHAR));

                        if (DeviceInstanceIdsList) {

                            if (RegQueryValueEx(hKeyReinstallInstance,
                                                pszReinstallDeviceInstanceIds,
                                                NULL,
                                                NULL,
                                                (LPBYTE)DeviceInstanceIdsList,
                                                &cbData) == ERROR_SUCCESS) {

                                //
                                // Walk the list of DeviceInstanceIds and check for
                                // a match with our device.
                                //
                                for (p = DeviceInstanceIdsList;
                                     *p;
                                     p += (lstrlen(p) + 1)) {

                                    if (lstrcmpi(p, DeviceInstanceId) == 0) {

                                        //
                                        // We have a match! First we will check to
                                        // see if this is the only DeviceInstanceId
                                        // in the list. To do this take the length of
                                        // the string and add two for the two terminating
                                        // NULLs of a multi-sz string and compare that
                                        // to cbData.  If it is the same as (or larger
                                        // than) cbData then this is the only string
                                        // in the multi-sz list.
                                        //
                                        if ((p == DeviceInstanceIdsList) &&
                                            (((lstrlen(DeviceInstanceIdsList) + 2) * sizeof(TCHAR)) >= cbData)) {

                                            //
                                            // Since there is only this one DeviceInstanceId
                                            // in the list set bDeleteBackupInstance to TRUE
                                            // so we can delete this entire subkey along
                                            // with the files that are backed up for it.
                                            //
                                            bDeleteBackupInstance = TRUE;

                                        } else {

                                            //
                                            // Since there is more than this DeviceInstanceId
                                            // in the list we need to remove just this
                                            // one Id from the multi-sz string and
                                            // put the new multi-sz string back
                                            // into the registry.
                                            //
                                            DWORD pLength = lstrlen(p);
                                            PTSTR p2 = p + (pLength + 1);

                                            memcpy(p, p2, cbData - ((ULONG_PTR)p2 - (ULONG_PTR)DeviceInstanceIdsList));

                                            RegSetValueEx(hKeyReinstallInstance,
                                                          pszReinstallDeviceInstanceIds,
                                                          0,
                                                          REG_MULTI_SZ,
                                                          (PBYTE)DeviceInstanceIdsList,
                                                          cbData - ((pLength + 1) * sizeof(TCHAR))
                                                          );
                                        }

                                        break;
                                    }
                                }
                            }

                            MyFree(DeviceInstanceIdsList);
                        }
                    }

                    RegCloseKey(hKeyReinstallInstance);

                    //
                    // If this entire subkey and it's corresponding directory need
                    // to be deleted then do it now.
                    //
                    if (bDeleteBackupInstance) {

                        pSetupDeleteBackup(ReinstallInstance);
                    }
                }

                //
                // Need to update the cbInstanceSize variable before calling
                // RegEnumKeyEx again.
                //
                cbInstanceSize = sizeof(ReinstallInstance) / sizeof(TCHAR);
            }

            RegCloseKey(hKeyReinstall);
        }

        //
        // Create the new Reinstall instance backup subkey.
        //
        Err = pSetupBackupCreateReinstallKey(BackupFileQueue);

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
          //
          // if we except, assume it's due to invalid parameter
          //
          Err = ERROR_INVALID_PARAMETER;
    }

    SetLastError(Err);
    return Err;
}

//
// ==========================================================
//

VOID
pSetupCleanupBackup(
    IN PSP_FILE_QUEUE   Queue
    )
/*++

Routine Description:

    This routine is called to delete any backup directories or registry entries
    associated with this queue.

Arguments:

    Queue               file queue

Return Value:

    VOID

--*/
{
    TCHAR BackupInstance[MAX_PATH];
    DWORD cbData;

    //
    // If we don't have a BackupInfID or a BackupInstanceID then the backup
    // must have failed much earlier. If the backup failed then it would have
    // cleaned itself up so there is no cleanup that needs to be done now.
    //
    if ((Queue->BackupInfID == -1) ||
        (Queue->BackupInstanceID == -1)) {
        return;
    }

    //
    // Get the Backup Instance from the backup queue.
    //
    cbData = MAX_PATH;
    if (pSetupStringTableStringFromIdEx(Queue->StringTable,
                                        Queue->BackupInstanceID,
                                        BackupInstance,
                                        &cbData)) {

        pSetupDeleteBackup(BackupInstance);
    }
}

//
// ==========================================================
//

BOOL
PostDelayedMove(
                IN PSP_FILE_QUEUE    Queue,
                IN PCTSTR CurrentName,
                IN PCTSTR NewName,       OPTIONAL
                IN DWORD SecurityDesc,
                IN BOOL TargetIsProtected
                )
/*++

Routine Description:

    Helper for DelayedMove
    We don't do any delayed Moves until we know all else succeeded

Arguments:

    Queue               Queue that the move is applied to
    CurrentName         Name of file we want to move
    NewName             Name we want to move to
    SecurityDesc        Index in string table of Security Descriptor string or -1 if not present
    TargetIsProtected   Indicates whether target file is a protected system file

Return Value:

    FALSE if error

--*/
{
    PSP_DELAYMOVE_NODE DelayMoveNode;
    LONG SourceFilename;
    LONG TargetFilename;
    DWORD Err;

    if (CurrentName == NULL) {
        SourceFilename = -1;
    } else {
        SourceFilename = pSetupStringTableAddString(Queue->StringTable,
                                                (PTSTR)CurrentName,
                                                STRTAB_CASE_SENSITIVE
                                                );
        if (SourceFilename == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
    }
    if (NewName == NULL) {
        TargetFilename = -1;
    } else {
        TargetFilename = pSetupStringTableAddString(Queue->StringTable,
                                                (PTSTR)NewName,
                                                STRTAB_CASE_SENSITIVE
                                                );
        if (TargetFilename == -1) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
    }

    DelayMoveNode = MyMalloc(sizeof(SP_DELAYMOVE_NODE));

    if (DelayMoveNode == NULL) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    DelayMoveNode->NextNode = NULL;
    DelayMoveNode->SourceFilename = SourceFilename;
    DelayMoveNode->TargetFilename = TargetFilename;
    DelayMoveNode->SecurityDesc = SecurityDesc;
    DelayMoveNode->TargetIsProtected = TargetIsProtected;

    if (Queue->DelayMoveQueueTail == NULL) {
        Queue->DelayMoveQueue = DelayMoveNode;
    } else {
        Queue->DelayMoveQueueTail->NextNode = DelayMoveNode;
    }
    Queue->DelayMoveQueueTail = DelayMoveNode;

    Err = NO_ERROR;

clean0:

    SetLastError(Err);

    return (Err == NO_ERROR);

}

//
// ==========================================================
//

DWORD
DoAllDelayedMoves(
    IN PSP_FILE_QUEUE    Queue
    )
/*++

Routine Description:

    Execute the Delayed Moves previously posted

Arguments:

    Queue               Queue that has the list in

Return Value:

    Error Status

--*/
{
    PSP_DELAYMOVE_NODE DelayMoveNode;
    PTSTR CurrentName;
    PTSTR TargetName;
    BOOL b = TRUE;
    PSP_DELAYMOVE_NODE DoneQueue = NULL;
    PSP_DELAYMOVE_NODE NextNode = NULL;
    DWORD Err = NO_ERROR;
    BOOL EnableProtectedRenames = FALSE;

    for (DelayMoveNode = Queue->DelayMoveQueue ; DelayMoveNode ; DelayMoveNode = NextNode ) {
        NextNode = DelayMoveNode->NextNode;

        MYASSERT(DelayMoveNode->SourceFilename != -1);
        CurrentName = pSetupStringTableStringFromId(Queue->StringTable, DelayMoveNode->SourceFilename);
        MYASSERT(CurrentName);

        if (DelayMoveNode->TargetFilename == -1) {
            TargetName = NULL;
        } else {
            TargetName = pSetupStringTableStringFromId( Queue->StringTable, DelayMoveNode->TargetFilename );
            MYASSERT(TargetName);
        }

        //
        // Keep track of whether we've encountered any protected system files.
        //
        EnableProtectedRenames |= DelayMoveNode->TargetIsProtected;

#ifdef UNICODE
        //
        // If this is a move (instead of a delete), then set security (letting
        // SCE know what the file's final name will be.
        //
        if((DelayMoveNode->SecurityDesc != -1) && TargetName) {

            Err = pSetupCallSCE(ST_SCE_RENAME,
                                CurrentName,
                                Queue,
                                TargetName,
                                DelayMoveNode->SecurityDesc,
                                NULL
                               );

            if(Err != NO_ERROR ){
                //
                // If we're on the first delay-move node, then we can abort.
                // However, if we've already processed one or more nodes, then
                // we can't abort--we must simply log an error indicating what
                // happened and keep on going.
                //
                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_DELAYED_MOVE_SCE_FAILED,
                              NULL,
                              CurrentName,
                              TargetName
                             );

                WriteLogError(Queue->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              Err
                             );

                if(DelayMoveNode == Queue->DelayMoveQueue) {
                    //
                    // Failure occurred on 1st node--we can abort.
                    //
                    WriteLogEntry(Queue->LogContext,
                                  SETUP_LOG_ERROR,
                                  MSG_LOG_OPERATION_CANCELLED,
                                  NULL
                                 );
                    break;
                } else {
                    //
                    // There's no turning back--log an error and keep on going.
                    //
                    WriteLogEntry(Queue->LogContext,
                                  SETUP_LOG_ERROR,
                                  MSG_LOG_ERROR_IGNORED,
                                  NULL
                                 );

                    Err = NO_ERROR;
                }
            }

        } else
#endif
        {
            Err = NO_ERROR;
        }

        //
        // finally delay the move
        //
        if(!DelayedMove(CurrentName, TargetName)) {

            Err = GetLastError();

            //
            // Same deal as above with SCE call--if we've already processed one
            // or more delay-move nodes, we can't abort.
            //
            if(TargetName) {
                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_DELAYED_MOVE_FAILED,
                              NULL,
                              CurrentName,
                              TargetName
                             );
            } else {
                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_DELAYED_DELETE_FAILED,
                              NULL,
                              CurrentName
                             );
            }

            WriteLogError(Queue->LogContext,
                          SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                          Err
                         );

            if(DelayMoveNode == Queue->DelayMoveQueue) {
                //
                // Failure occurred on 1st node--we can abort.
                //
                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_OPERATION_CANCELLED,
                              NULL
                             );
                break;
            } else {
                //
                // There's no turning back--log an error and keep on going.
                //
                WriteLogEntry(Queue->LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_ERROR_IGNORED,
                              NULL
                             );

                Err = NO_ERROR;
            }
        }

        //
        // Move node to queue containing nodes that have already been processed
        //
        DelayMoveNode->NextNode = DoneQueue;
        DoneQueue = DelayMoveNode;
    }

    //
    // If we have any replacement of protected system files, then we need to
    // inform session manager so that it allows the replacement to occur upon
    // reboot.
    //
    // NOTE: We don't have to worry about enabling replacement of system files
    // with unsigned (hence, untrusted) versions.  We only queue up unsigned
    // system files for replacement if the user was explicitly warned of (and
    // agreed to) the consequences.
    //
    // NTRAID#55485-2000/02/03-jamiehun
    // Protected renames only allows "rename all" or "rename none"
    //
    //         the session manager only allows the granularity of "allow all
    //         renames" or "allow no renames".  If Err != NO_ERROR, then we
    //         might want to clear out this flag, but that means we'd negate
    //         any renames that were previously allowed.  Yuck.  So we flip a
    //         coin, decide to do nothing, and hope for the best if an error
    //         occurred.  We have similar situation above -- it's all or
    //         nothing.
    //
    if((Err == NO_ERROR) && EnableProtectedRenames) {
        pSetupProtectedRenamesFlag(TRUE);
    }

    //
    // any nodes that are left are dropped
    //
    for ( ; DelayMoveNode ; DelayMoveNode = NextNode ) {
        NextNode = DelayMoveNode->NextNode;

        MyFree(DelayMoveNode);
    }
    Queue->DelayMoveQueue = NULL;
    Queue->DelayMoveQueueTail = NULL;

    //
    // delete all nodes we queue'd
    //
    for ( ; DoneQueue ; DoneQueue = NextNode ) {
        NextNode = DoneQueue->NextNode;
        //
        // done with node
        //
        MyFree(DoneQueue);
    }

    return Err;
}

//
// ==========================================================
//

VOID
pSetupUnwindAll(
    IN PSP_FILE_QUEUE    Queue,
    IN BOOL              Succeeded
    )
/*++

Routine Description:

    Processes the Unwind Queue. If Succeeded is FALSE, restores any data that was backed up

Arguments:

    Queue               Queue to be unwound
    Succeeded           Indicates if we should treat the whole operation as succeeded or failed

Return Value:

    None--this routine should always succeed.  (Any file errors encountered
    along the way are logged in the setupapi logfile.)

--*/

{
    // if Succeeded, we need to delete Temp files
    // if we didn't succeed, we need to restore backups

    PSP_UNWIND_NODE UnwindNode;
    PSP_UNWIND_NODE ThisNode;
    SP_TARGET_ENT TargetInfo;
    PTSTR BackupFilename;
    PTSTR TargetFilename;
    PTSTR RenamedFilename;
    DWORD Err = NO_ERROR;
    TCHAR TempPath[MAX_PATH];
    PTSTR TempNamePtr;
    TCHAR TempFilename[MAX_PATH];
    BOOL  RestoreByRenaming;
    BOOL  OkToDeleteBackup;

    try {
        if (Succeeded == FALSE) {
            //
            // we need to restore backups
            //

            WriteLogEntry(
                Queue->LogContext,
                SETUP_LOG_WARNING,
                MSG_LOG_UNWIND,
                NULL);

            for ( UnwindNode = Queue->UnwindQueue; UnwindNode != NULL; ) {
                ThisNode = UnwindNode;
                UnwindNode = UnwindNode->NextNode;

                if (pSetupBackupGetTargetByID((HSPFILEQ)Queue, ThisNode->TargetID, &TargetInfo) == NO_ERROR) {


                    BackupFilename = NULL;
                    TargetFilename = NULL;
                    RenamedFilename = NULL;

                    // restore backup
                    if(!(TargetInfo.InternalFlags & SP_TEFLG_RESTORED)) {

                        // get target name
                        TargetFilename = pSetupFormFullPath(
                                            Queue->StringTable,
                                            TargetInfo.TargetRoot,
                                            TargetInfo.TargetSubDir,
                                            TargetInfo.TargetFilename);

                        if(TargetInfo.InternalFlags & SP_TEFLG_MOVED) {
                            //
                            // Get renamed filename
                            //
                            RenamedFilename = pSetupStringTableStringFromId(Queue->StringTable,
                                                                      TargetInfo.NewTargetFilename
                                                                     );
                        }

                        if(TargetInfo.InternalFlags & SP_TEFLG_SAVED) {
                            //
                            // get backup name
                            //
                            BackupFilename = pSetupFormFullPath(
                                                Queue->StringTable,
                                                TargetInfo.BackupRoot,
                                                TargetInfo.BackupSubDir,
                                                TargetInfo.BackupFilename);

                        }
                    }

                    if(TargetFilename && (RenamedFilename || BackupFilename)) {
                        //
                        // We either renamed the original file or we backed it up.
                        // We need to put it back.
                        //
                        RestoreByRenaming = RenamedFilename ? TRUE : FALSE;

                        RestoreRenamedOrBackedUpFile(TargetFilename,
                                                     (RestoreByRenaming
                                                        ? RenamedFilename
                                                        : BackupFilename),
                                                     RestoreByRenaming,
                                                     Queue->LogContext
                                                    );

                        //
                        // If we were doing a copy (i.e., from a backup) as opposed
                        // to a rename, then we need to reapply timestamp and
                        // security.
                        //
                        if(!RestoreByRenaming) {

                            Err = GetSetFileTimestamp(TargetFilename,
                                                      &(ThisNode->CreateTime),
                                                      &(ThisNode->AccessTime),
                                                      &(ThisNode->WriteTime),
                                                      TRUE
                                                     );

                            if(Err != NO_ERROR) {
                                //
                                // We just blew away the timestamp on the file--log
                                // an error entry to that effect.
                                //
                                WriteLogEntry(Queue->LogContext,
                                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                              MSG_LOG_BACKUP_EXISTING_RESTORE_FILETIME_FAILED,
                                              NULL,
                                              TargetFilename
                                             );

                                WriteLogError(Queue->LogContext,
                                              SETUP_LOG_ERROR,
                                              Err
                                             );
                            }

                            if(ThisNode->SecurityDesc != NULL){

                                Err = StampFileSecurity(TargetFilename, ThisNode->SecurityDesc);

                                if(Err != NO_ERROR) {
                                    //
                                    // We just blew away the existing security on
                                    // the file--log an error entry to that effect.
                                    //
                                    WriteLogEntry(Queue->LogContext,
                                                  SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                                  MSG_LOG_BACKUP_EXISTING_RESTORE_SECURITY_FAILED,
                                                  NULL,
                                                  TargetFilename
                                                 );

                                    WriteLogError(Queue->LogContext,
                                                  SETUP_LOG_ERROR,
                                                  Err
                                                 );
                                }
    #ifdef UNICODE
                                Err = pSetupCallSCE(ST_SCE_UNWIND,
                                                    TargetFilename,
                                                    NULL,
                                                    NULL,
                                                    -1,
                                                    ThisNode->SecurityDesc
                                                   );

                                if(Err != NO_ERROR) {
                                    //
                                    // We just blew away the existing security on
                                    // the file--log an error entry to that effect.
                                    //
                                    WriteLogEntry(Queue->LogContext,
                                                  SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                                  MSG_LOG_BACKUP_EXISTING_RESTORE_SCE_FAILED,
                                                  NULL,
                                                  TargetFilename
                                                 );

                                    WriteLogError(Queue->LogContext,
                                                  SETUP_LOG_ERROR,
                                                  Err
                                                 );
                                }
    #endif
                            }
                        }

                        //
                        // Now mark that we've restored this file.  We'll delete
                        // tempfiles later
                        //
                        TargetInfo.InternalFlags |= SP_TEFLG_RESTORED;
                        pSetupBackupSetTargetByID((HSPFILEQ)Queue, ThisNode->TargetID, &TargetInfo);
                    }

                    if(BackupFilename) {
                        MyFree(BackupFilename);
                    }
                    if(TargetFilename) {
                        MyFree(TargetFilename);
                    }
                }
            }
        }

        //
        // cleanup - remove temporary files
        //
        for ( UnwindNode = Queue->UnwindQueue; UnwindNode != NULL; ) {
            ThisNode = UnwindNode;
            UnwindNode = UnwindNode->NextNode;

            if (pSetupBackupGetTargetByID((HSPFILEQ)Queue, ThisNode->TargetID, &TargetInfo) == NO_ERROR) {
                // delete temporary file
                if (TargetInfo.InternalFlags & SP_TEFLG_TEMPNAME) {
                    //
                    // get name of file that was used for backup
                    //
                    BackupFilename = pSetupFormFullPath(
                                        Queue->StringTable,
                                        TargetInfo.BackupRoot,
                                        TargetInfo.BackupSubDir,
                                        TargetInfo.BackupFilename);

                    if(BackupFilename) {
                        //
                        // If this operation was a bootfile replacement, then we
                        // don't want to delete the backup (if we used the renamed
                        // file for the backup as well).  A delayed delete will
                        // have been queued to get rid of the file after a reboot.
                        //
                        OkToDeleteBackup = TRUE;

                        if(TargetInfo.InternalFlags & SP_TEFLG_MOVED) {
                            //
                            // Retrieve the renamed filename to see if it's the
                            // same as the backup filename.
                            //
                            RenamedFilename = pSetupStringTableStringFromId(Queue->StringTable,
                                                                      TargetInfo.NewTargetFilename
                                                                     );

                            if(!lstrcmpi(BackupFilename, RenamedFilename)) {
                                OkToDeleteBackup = FALSE;
                            }
                        }

                        if(OkToDeleteBackup) {
                            //
                            // since it was temporary, delete it
                            //
                            SetFileAttributes(BackupFilename, FILE_ATTRIBUTE_NORMAL);
                            if(!DeleteFile(BackupFilename)) {
                                //
                                // Alright, see if we can set it up for delayed delete
                                // instead.
                                //
                                if(!DelayedMove(BackupFilename, NULL)) {
                                    //
                                    // Oh well, just write a log entry indicating that
                                    // this file turd was left on the user's disk.
                                    //
                                    Err = GetLastError();

                                    WriteLogEntry(Queue->LogContext,
                                                  SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                                                  MSG_LOG_BACKUP_DELAYED_DELETE_FAILED,
                                                  NULL,
                                                  BackupFilename
                                                 );

                                    WriteLogError(Queue->LogContext,
                                                  SETUP_LOG_WARNING,
                                                  Err
                                                 );
                                }
                            }
                        }

                        MyFree(BackupFilename);
                    }
                }

                pSetupResetTarget(Queue->TargetLookupTable,
                                  ThisNode->TargetID,
                                  NULL,
                                  &TargetInfo,
                                  sizeof(TargetInfo),
                                  (LPARAM)0
                                 );
            }

            // cleanup node
            if (ThisNode->SecurityDesc != NULL) {
                MyFree(ThisNode->SecurityDesc);
            }
            MyFree(ThisNode);
        }
        Queue->UnwindQueue = NULL;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // should generally not get here
        // unless Queue is invalid
        //
    }
}

//
// ==========================================================
//

DWORD _SetupGetBackupInformation(
         IN     PSP_FILE_QUEUE               Queue,
         OUT    PSP_BACKUP_QUEUE_PARAMS_V2   BackupParams
         )
/*++

Routine Description:

    Get Backup INF path - Internal version

Arguments:

    Queue - pointer to queue structure (validated)
    BackupParams OUT - filled with INF file path

Return Value:

    TRUE if success, else FALSE

--*/
{
    //
    // Queue is assumed to have been validated
    // BackupParams is in Native format
    //

    LONG BackupInfID;
    ULONG BufSize = MAX_PATH;
    BOOL b;
    DWORD err = NO_ERROR;
    LPCTSTR filename;
    INT offset;

    BackupInfID = Queue->BackupInfID;

    if (BackupInfID != -1) {
        //
        // get inf from stringtable
        //
        b = pSetupStringTableStringFromIdEx(Queue->StringTable,
                                    BackupInfID,
                                    BackupParams->FullInfPath,
                                    &BufSize);
        if (b == FALSE) {
            if (BufSize == 0) {
                err = ERROR_NO_BACKUP;
            } else {
                err = ERROR_INSUFFICIENT_BUFFER;
            }
            goto Clean0;
        }

        //
        // find index of filename
        //
        filename = pSetupGetFileTitle(BackupParams->FullInfPath);
        offset = (INT)(filename - BackupParams->FullInfPath);
        BackupParams->FilenameOffset = offset;

        //
        // If the caller passed in a SP_BACKUP_QUEUE_PARAMS_V2 structure then
        // also fill in the ReinstallInstance string value.
        //
        if (BackupParams->cbSize >= sizeof(SP_BACKUP_QUEUE_PARAMS_V2)) {
            BufSize = MAX_PATH;
            if(Queue->BackupInstanceID != -1) {
                b = pSetupStringTableStringFromIdEx(Queue->StringTable,
                                                    Queue->BackupInstanceID,
                                                    BackupParams->ReinstallInstance,
                                                    &BufSize);
            } else {
                //
                // no instance ID
                //
                BackupParams->ReinstallInstance[0] = TEXT('\0');
            }
            if (b == FALSE) {
                if (BufSize == 0) {
                    err = ERROR_NO_BACKUP;
                } else {
                    err = ERROR_INSUFFICIENT_BUFFER;
                }
                goto Clean0;
            }
        }

    } else {
        //
        // no backup path
        //
        err = ERROR_NO_BACKUP;
    }

Clean0:

    return err;
}




#ifdef UNICODE
//
// ANSI version in UNICODE
//
BOOL
WINAPI
SetupGetBackupInformationA(
    IN     HSPFILEQ                     QueueHandle,
    OUT    PSP_BACKUP_QUEUE_PARAMS_V2_A BackupParams
    )
{
    BOOL b;
    int i;
    INT c;
    LPCSTR p;
    SP_BACKUP_QUEUE_PARAMS_W BackupParamsW;

    //
    // confirm structure size
    //

    try {
        if((BackupParams->cbSize != sizeof(SP_BACKUP_QUEUE_PARAMS_V2_A)) &&
           (BackupParams->cbSize != sizeof(SP_BACKUP_QUEUE_PARAMS_V1_A))) {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            leave;              // exit try block
        }
        //
        // call Unicode version of API
        //
        ZeroMemory( &BackupParamsW, sizeof(BackupParamsW) );
        BackupParamsW.cbSize = sizeof(BackupParamsW);

        b = SetupGetBackupInformationW(QueueHandle,&BackupParamsW);
        if (b) {
            //
            // success, convert structure from UNICODE to ANSI
            //
            i = WideCharToMultiByte(
                    CP_ACP,
                    0,
                    BackupParamsW.FullInfPath,
                    MAX_PATH,
                    BackupParams->FullInfPath,
                    MAX_PATH,
                    NULL,
                    NULL
                    );
            if (i==0) {
                //
                // error occurred (LastError set to error)
                //
                b = FALSE;
                leave;              // exit try block
            }

            //
            // we need to recalc the offset of INF filename
            // taking care of internationalization
            //
            p = BackupParams->FullInfPath;
            for(c = 0; c < BackupParamsW.FilenameOffset; c++) {
                p = CharNextA(p);
            }
            BackupParams->FilenameOffset = (int)(p-(BackupParams->FullInfPath));  // new offset in ANSI

            if (BackupParams->cbSize >= sizeof(SP_BACKUP_QUEUE_PARAMS_V2_A)) {
                //
                // instance
                //
                i = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        BackupParamsW.ReinstallInstance,
                        MAX_PATH,
                        BackupParams->ReinstallInstance,
                        MAX_PATH,
                        NULL,
                        NULL
                        );
                if (i==0) {
                    //
                    // error occurred (LastError set to error)
                    //
                    b = FALSE;
                    leave;              // exit try block
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
          //
          // if we except, assume it's due to invalid parameter
          //
          SetLastError(ERROR_INVALID_PARAMETER);
          b = FALSE;
    }

    return b;
}

#else
//
// Unicode version in ANSI
//
BOOL
WINAPI
SetupGetBackupInformationW(
   IN     HSPFILEQ                     QueueHandle,
   OUT    PSP_BACKUP_QUEUE_PARAMS_V2_W BackupParams
   )
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(BackupParams);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif

//
// Native version
//
BOOL
WINAPI
SetupGetBackupInformation(
    IN     HSPFILEQ                     QueueHandle,
    OUT    PSP_BACKUP_QUEUE_PARAMS_V2   BackupParams
    )
/*++

Routine Description:

    Get Backup INF path

Arguments:

    QueueHandle - handle of queue to retrieve backup INF file from
    BackupParams - IN - has cbSize set, OUT - filled with INF file path

Return Value:

    TRUE if success, else FALSE

--*/
{
    BOOL b = TRUE;
    PSP_FILE_QUEUE Queue = (PSP_FILE_QUEUE)QueueHandle;
    DWORD res;

    //
    // first validate QueueHandle
    //
    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_HANDLE);
        goto Clean0;
    }

    //
    // now fill in structure
    // if we except, assume bad pointer
    //
    try {
        if((BackupParams->cbSize != sizeof(SP_BACKUP_QUEUE_PARAMS_V2)) &&
           (BackupParams->cbSize != sizeof(SP_BACKUP_QUEUE_PARAMS_V1))) {
            SetLastError(ERROR_INVALID_PARAMETER);
            b = FALSE;
            leave;              // exit try block
        }
        res = _SetupGetBackupInformation(Queue,BackupParams);
        if (res == NO_ERROR) {
            b = TRUE;
        } else {
            SetLastError(res);
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
          //
          // if we except, assume it's due to invalid parameter
          //
          SetLastError(ERROR_INVALID_PARAMETER);
          b = FALSE;
    }

Clean0:
    return b;
}


//
// ==========================================================
//

VOID
RestoreRenamedOrBackedUpFile(
    IN PCTSTR             TargetFilename,
    IN PCTSTR             CurrentFilename,
    IN BOOL               RenameFile,
    IN PSETUP_LOG_CONTEXT LogContext       OPTIONAL
    )
/*++

Routine Description:

    This routine does its best to restore a backed-up or renamed file back to
    its original name.

Arguments:

    TargetFilename - filename to be restored to

    CurrentFilename - file to restore

    RenameFile - if TRUE, CurrentFilename was previously renamed from
        TargetFilename (hence should be renamed back).  If FALSE,
        CurrentFilename is merely a copy, and should be copied back.

    LogContext - supplies a log context used if errors are encountered.

Return Value:

    None.

--*/
{
    DWORD Err;
    TCHAR TempPath[MAX_PATH];
    PTSTR TempNamePtr;
    TCHAR TempFilename[MAX_PATH];
    DWORD LogTag = AllocLogInfoSlotOrLevel(LogContext,SETUP_LOG_INFO,FALSE);

    WriteLogEntry(
        LogContext,
        LogTag,
        MSG_LOG_UNWIND_FILE,
        NULL,
        CurrentFilename,
        TargetFilename
        );

    //
    // First, clear target attributes...
    //
    SetFileAttributes(TargetFilename, FILE_ATTRIBUTE_NORMAL);

    if(RenameFile) {
        //
        // simple case, move temporary file over existing file
        //
        pSetupExemptFileFromProtection(
                    TargetFilename,
                    SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME,
                    LogContext,
                    NULL
                    );
        Err = DoMove(CurrentFilename, TargetFilename) ? NO_ERROR : GetLastError();
    } else {
        pSetupExemptFileFromProtection(
                    TargetFilename,
                    SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME,
                    LogContext,
                    NULL
                    );
        Err = CopyFile(CurrentFilename, TargetFilename, FALSE) ? NO_ERROR : GetLastError();
    }

    if(Err != NO_ERROR) {
        //
        // Can't replace the file that got copied in place of
        // the original one--try to move that one to a tempname
        // and schedule it for delayed deletion.
        //
        WriteLogEntry(LogContext,
                    SETUP_LOG_ERROR|SETUP_LOG_BUFFER,
                    MSG_LOG_UNWIND_TRY1_FAILED,
                    NULL,
                    CurrentFilename,
                    TargetFilename
                    );
        WriteLogError(LogContext,
                    SETUP_LOG_ERROR,
                    Err
                    );

        //
        // First, strip the filename off the path.
        //
        _tcscpy(TempPath, TargetFilename);
        TempNamePtr = (PTSTR)pSetupGetFileTitle(TempPath);
        *TempNamePtr = TEXT('\0');

        //
        // Now get a temp filename within that directory...
        //
        if(GetTempFileName(TempPath, TEXT("OLD"), 0, TempFilename) == 0 ) {
            //
            // Uh oh!
            //
            Err = GetLastError();
        } else if(!DoMove(TargetFilename, TempFilename)) {
            Err = GetLastError();
        } else {
            //
            // OK, we were able to rename the current file to a
            // temp filename--now attempt to copy or move the
            // original file back to its original name.
            //
            if(RenameFile) {
                Err = DoMove(CurrentFilename, TargetFilename) ? NO_ERROR : GetLastError();
            } else {
                Err = CopyFile(CurrentFilename, TargetFilename, FALSE) ? NO_ERROR : GetLastError();
            }

            if(Err != NO_ERROR) {
                //
                // This is very bad--put the current file back (it's probably
                // better to have something than nothing at all).
                //
                DoMove(TempFilename, TargetFilename);
            }
        }

        if(Err == NO_ERROR) {
            //
            // We successfully moved the current file to a temp
            // filename, and put the original file back.  Now
            // queue a delayed delete for the temp file.
            //
            if(!DelayedMove(TempFilename, NULL)) {
                //
                // All this means is that a file turd will get
                // left on the disk--simply log an event about
                // this.
                //
                Err = GetLastError();

                WriteLogEntry(LogContext,
                              SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                              MSG_LOG_RENAME_EXISTING_DELAYED_DELETE_FAILED,
                              NULL,
                              TargetFilename,
                              TempFilename
                             );

                WriteLogError(LogContext,
                              SETUP_LOG_WARNING,
                              Err
                             );
            }

        } else {
            //
            // We were unable to put the original file back--we
            // can't fail, so just log an error about this and
            // keep on going.
            //
            // in the case of a backed-up file,
            // we might get away with queueing the original file
            // for a delayed rename and then prompting the user
            // to reboot.  However, that won't work for renamed
            // files, because they're typically needed very
            // early on in the boot (i.e., before session
            // manager has had a chance to process the delayed
            // rename operations).
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                          (RenameFile
                              ? MSG_LOG_RENAME_EXISTING_RESTORE_FAILED
                              : MSG_LOG_BACKUP_EXISTING_RESTORE_FAILED),
                          NULL,
                          CurrentFilename,
                          TargetFilename
                         );

            WriteLogError(LogContext,
                          SETUP_LOG_ERROR,
                          Err
                         );
        }
    }

    if (LogTag) {
        ReleaseLogInfoSlot(LogContext,LogTag);
    }
}

//
// ==========================================================
//

BOOL
UnPostDelayedMove(
    IN PSP_FILE_QUEUE Queue,
    IN PCTSTR         CurrentName,
    IN PCTSTR         NewName      OPTIONAL
    )
/*++

Routine Description:

    Locates a delay-move node (either for rename or delete), and removes it
    from the delay-move queue.

Arguments:

    Queue               Queue that the move was applied to
    CurrentName         Name of file to be moved
    NewName             Name to move file to (NULL if delayed-delete)

Return Value:

    If successful, the return value is TRUE, otherwise it is FALSE.

--*/
{
    PSP_DELAYMOVE_NODE CurNode, PrevNode;
    PCTSTR SourceFilename, TargetFilename;

    //
    // Since the path string IDs in the delay-move nodes are case-sensitive, we
    // don't attempt to match on ID.  We instead retrieve the strings, and do
    // case-insensitive string compares.  Since this routine is rarely used, the
    // performance hit isn't a big deal.
    //
    for(CurNode = Queue->DelayMoveQueue, PrevNode = NULL;
        CurNode;
        PrevNode = CurNode, CurNode = CurNode->NextNode) {

        if(NewName) {
            //
            // We're searching for a delayed rename, so we must pay attention
            // to the target filename.
            //
            if(CurNode->TargetFilename == -1) {
                continue;
            } else {
                TargetFilename = pSetupStringTableStringFromId(Queue->StringTable, CurNode->TargetFilename);
                MYASSERT(TargetFilename);
                if(lstrcmpi(NewName, TargetFilename)) {
                    //
                    // Target filenames differ--move on.
                    //
                    continue;
                }
            }

        } else {
            //
            // We're searching for a delayed delete.
            //
            if(CurNode->TargetFilename != -1) {
                //
                // This is a rename, not a delete--move on.
                //
                continue;
            }
        }

        //
        // If we get to here, then the target filenames match (if this is a
        // rename), or they're both empty (if it's a delete).  Now compare the
        // source filenames.
        //
        MYASSERT(CurNode->SourceFilename != -1);
        SourceFilename = pSetupStringTableStringFromId(Queue->StringTable, CurNode->SourceFilename);
        MYASSERT(SourceFilename);

        if(lstrcmpi(CurrentName, SourceFilename)) {
            //
            // Source filenames differ--move on.
            //
            continue;
        } else {
            //
            // We have a match--remove the node from the delay-move queue.
            //
            if(PrevNode) {
                PrevNode->NextNode = CurNode->NextNode;
            } else {
                Queue->DelayMoveQueue = CurNode->NextNode;
            }
            if(!CurNode->NextNode) {
                MYASSERT(Queue->DelayMoveQueueTail == CurNode);
                Queue->DelayMoveQueueTail = PrevNode;
            }
            MyFree(CurNode);

            return TRUE;
        }
    }

    //
    // We didn't find a match.
    //
    return FALSE;
}


DWORD
pSetupDoLastKnownGoodBackup(
    IN struct _SP_FILE_QUEUE *Queue,           OPTIONAL
    IN PCTSTR                 TargetFilename,
    IN DWORD                  Flags,
    IN PSETUP_LOG_CONTEXT     LogContext       OPTIONAL
    )
/*++

Routine Description:

    Process LastKnownGood backups into <<LastGoodDirectory>>.
    If files are to be deleted on restore, write apropriate flags to HKLM\System\LastGoodRecovery\LastGood\<path/file>

    Caviats:

    If file is not inside <<WindowsDirectory>> or sub-directory, exit no-error.

    Backup will not occur if PSPGF_NO_BACKUP is set.

    If !SP_LKG_FLAG_FORCECOPY
        If file is inside <<LastGoodDirectory>>, exit with error.
        If file is inside <<InfDirectory>> throw warnings

    If an INF inside of <<InfDirectory>> is backed up, it's PNF is backed up too.

    If backup fails, we don't abort copy.

Arguments:

    Queue               Queue (optional) if specified, flags will be checked
    TargetFilename      Name of file to backup
    Flags
        SP_LKG_FLAG_FORCECOPY       - if set, turns copy safety-guards off
        SP_LKG_FLAG_DELETEIFNEW     - if set, writes a delete entry for new files
        SP_LKG_FLAG_DELETEEXISTING  - if set, writes a delete entry for existing files
        SP_LKG_FLAG_DELETEOP        - if set, primary operation is trying to delete/rename file

    LogContext          If specified, provides preferred logging context

Return Value:

    error if operation should be aborted, NO_ERROR otherwise.

--*/
{
#ifdef UNICODE
    int wd_len;   // windows directory len
    int tf_len;   // target file len
    int id_len;   // inf directory len
    int lkgd_len; // last known good directory len
    int rf_len;   // relative file len (including preceeding slash)
    BOOL is_inf = FALSE;
    BOOL is_infdir = FALSE;
    BOOL write_delete = FALSE;
    BOOL no_copy = FALSE;
    BOOL source_exists = FALSE;
    BOOL target_exists = FALSE;
    TCHAR FullTargetFilename[MAX_PATH];
    TCHAR BackupTargetFilename[MAX_PATH+14];
    TCHAR TempFilename[MAX_PATH];
    TCHAR RegName[MAX_PATH];
    PCTSTR RelativeFilename;
    PCTSTR CharPtr;
    PTSTR DestPtr;
    PTSTR NamePart = NULL;
    PTSTR ExtPart = NULL;
    DWORD attr;
    HANDLE hFile;
    HKEY hKeyLastGood;
    DWORD disposition;
    LONG regres;
    DWORD LastGoodFlags = 0;
    DWORD rval = NO_ERROR;
    PSETUP_LOG_CONTEXT LocalLogContext = NULL;

    if (!LogContext) {
        //
        // LogContext may be obmitted if there's a Queue parameter
        //
        if (Queue && Queue->LogContext) {
            LogContext = Queue->LogContext;
        } else {
            if(CreateLogContext(NULL,TRUE,&LocalLogContext)==NO_ERROR) {
                LogContext = LocalLogContext;
            }
        }
        MYASSERT(LogContext);
    }

    if ((GlobalSetupFlags & PSPGF_NO_BACKUP)!=0) {
        //
        // in a scenario where (1) we trust what we're doing and
        // (2) what we're doing modifies lots of files
        // or (3) what we're doing is undoable (eg, upgrading OS)
        //
        no_copy = TRUE;
    }
#if 0
    else if (Queue && !(Queue->Flags & FQF_DEVICE_INSTALL)) {
        //
        // in this scenario, a queue was specified, but it's not marked
        // for device install
        // we're not interested in this case
        //
        no_copy = TRUE;
    }
#endif

    //
    // cannonicalize the Target name so user doesn't do stuff like .../TEMP/../INF
    //
    tf_len = (int)GetFullPathName(TargetFilename,
                             MAX_PATH,
                             FullTargetFilename,
                             &NamePart);
    if (tf_len <= 0 || tf_len > MAX_PATH) {
        //
        // we don't do large paths very well
        //
        rval = NO_ERROR;
        goto final;
    }
    wd_len = lstrlen(WindowsDirectory);
    lkgd_len = lstrlen(LastGoodDirectory);
    id_len = lstrlen(InfDirectory);

    //
    // see if this file is nested below <<WindowsDirectory>>
    // note that such a file must be at least two characters longer
    //
    if((tf_len <= wd_len)
       || (FullTargetFilename[wd_len] != TEXT('\\'))
       || (_tcsnicmp(WindowsDirectory,FullTargetFilename,wd_len)!=0)) {
        //
        // this file is outside of %windir%, not handled by LKG
        //
        rval = NO_ERROR;
        goto final;
    }
    if (!(Flags&SP_LKG_FLAG_FORCECOPY)) {
        //
        // sanity check for files being copied into LKG dir
        //
        if((tf_len > lkgd_len)
           && (FullTargetFilename[lkgd_len] == TEXT('\\'))
           && (_tcsnicmp(LastGoodDirectory,FullTargetFilename,lkgd_len)==0)) {
            //
            // this file is prefixed by LastGoodDirectory
            // not allowed - throw a log message and inform caller of this mistake
            // return FALSE to abort the operation
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_ERROR,
                          MSG_LOG_FILE_BLOCK,
                          NULL,
                          FullTargetFilename,
                          LastGoodDirectory
                          );
            rval = ERROR_ACCESS_DENIED;
            goto final;
        }
    }
    if((tf_len > id_len)
       && (FullTargetFilename[id_len] == TEXT('\\'))
       && (_tcsnicmp(InfDirectory,FullTargetFilename,id_len)==0)
       && ((NamePart-FullTargetFilename) == (id_len+1))) {
        //
        // the file sits in the primary INF directory
        //
        is_infdir = TRUE;
        //
        // check for name ending in ".INF" - if so, we need to backup ".PNF" too
        //
        ExtPart = FullTargetFilename+tf_len;
        while ((ExtPart = CharPrev(NamePart,ExtPart)) != NamePart) {
            if (ExtPart[0] == TEXT('.')) {
                break;
            }
        }

        if(_tcsicmp(ExtPart,TEXT(".INF"))==0) {
            //
            // ends in .INF
            //
            is_inf = TRUE;
            //
            // we should only get here if Force is set (ie, we've already determined
            // what is being copied and all is OK). If we don't, this implies someone
            // is trying a back-door INF copy. we've already logged above that they're writing
            // to this directory when they shouldn't. However, if we don't do anything
            // about it, culprit could render machine in bad state
            // change this behavior into a "Force" behavior
            //
            if (!(Flags&SP_LKG_FLAG_FORCECOPY)) {
                no_copy = FALSE; // ensure we'll go through copy logic
                WriteLogEntry(LogContext,
                              SETUP_LOG_ERROR,
                              MSG_LOG_INF_WARN,
                              NULL,
                              FullTargetFilename,
                              InfDirectory
                              );
                if(!(Flags&SP_LKG_FLAG_DELETEOP)) {
                    //
                    // we're invalidly trying to overwrite an INF/create an INF
                    //
                    Flags|=SP_LKG_FLAG_DELETEIFNEW;
                }
            }
        } else if (!(Flags&SP_LKG_FLAG_FORCECOPY)) {
            //
            // writing something else into this directory - huh?
            // well, if it's not an INF, we won't pick it up via INF searching
            // if it's a PNF or cache, we're regenerate it
            // don't fret too much, but slap wrist.
            //
            WriteLogEntry(LogContext,
                          SETUP_LOG_ERROR,
                          MSG_LOG_FILE_WARN,
                          NULL,
                          FullTargetFilename,
                          InfDirectory
                          );
        }
    }

    if (no_copy) {
        //
        // we determined that we're not going to backup, and we've now done logging items
        //
        rval = NO_ERROR;
        goto final;
    }

    //
    // does source really exist?
    //
    if ((attr=GetFileAttributes(FullTargetFilename))!=(DWORD)(-1)) {
        source_exists = TRUE;
        if (Flags & SP_LKG_FLAG_DELETEEXISTING) {
            write_delete = TRUE;
        }
    } else if (Flags & SP_LKG_FLAG_DELETEIFNEW) {
        write_delete = TRUE;
    } else {
        //
        // we're done
        //
        rval = NO_ERROR;
        goto final;
    }
    //
    // remap to LKG directory
    //
    RelativeFilename = FullTargetFilename+wd_len; // includes preceeding backslash
    rf_len = tf_len-wd_len;
    MYASSERT((MAX_PATH+(lkgd_len-wd_len))<=SIZECHARS(BackupTargetFilename));
    lstrcpy(BackupTargetFilename,LastGoodDirectory);
    lstrcpy(BackupTargetFilename+lkgd_len,RelativeFilename);

    //
    // does backup already exist?
    //
    if ((attr=GetFileAttributes(BackupTargetFilename))!=(DWORD)(-1)) {
        //
        // if it does, nothing useful to do.
        //
        rval = NO_ERROR;
        goto final;
    }

    //
    // create intermediate directories as needed
    //
    pSetupMakeSurePathExists(BackupTargetFilename);

    //
    // we need to use a temporary file first, and then move it into place
    // so we don't get in the situation where we write a bad file, reboot
    // and decide to use LKG.
    //
    if(GetTempFileName(LastGoodDirectory, TEXT("TMP"), 0, TempFilename) == 0 ) {
        //
        // if this fails, it could be because we haven't got right permissions
        // non-fatal
        //
        rval = NO_ERROR;
        goto final;
    }
    //
    // after this point, aborts require cleaning up of temporary file
    //

    if (write_delete) {
        //
        // GetTempFileName created an empty place holder
        // ensure it has right attributes
        // before moving into place
        //
        SetFileAttributes(TempFilename,FILE_ATTRIBUTE_HIDDEN);
    } else {
        //
        // copy original to this temporary file
        // apply apropriate permissions
        //
        if(!CopyFile(FullTargetFilename, TempFilename ,FALSE)) {
            //
            // copy failed - non fatal
            //
            goto cleanup;
        }
    }

    //
    // we have a temporary file ready to be moved into place
    // move it to final name, ensuring that while we were doing above, a new file
    // was not already written
    //
    if(!MoveFileEx(TempFilename,BackupTargetFilename,MOVEFILE_WRITE_THROUGH)) {
        //
        // could be that a file with that name now exists, but didn't earlier
        // oh well, clean up the mess and leave gracefully
        //
        goto cleanup;
    }

    if (write_delete) {
        //
        // if we successfully wrote an empty placeholder for a file to be deleted, we need to shadow this file with
        // an entry in registry
        //
        regres = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                REGSTR_PATH_LASTGOOD,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKeyLastGood,
                                &disposition);
        if (regres == NO_ERROR) {
            //
            // copy string, remapping slash's from '\\' to '/'
            //
            CharPtr = RelativeFilename+1; // after initial '\'
            DestPtr = RegName;
            while(*CharPtr) {
                PCTSTR Next = _tcschr(CharPtr,TEXT('\\'));
                if (!Next) {
                    Next = CharPtr + lstrlen(CharPtr);
                }
                if(Next-CharPtr) {
                    CopyMemory(DestPtr,CharPtr,(Next-CharPtr)*sizeof(TCHAR));
                    DestPtr+=(Next-CharPtr);
                    CharPtr = Next;
                }
                if (*CharPtr == TEXT('\\')) {
                    *DestPtr = TEXT('/');
                    DestPtr++;
                    CharPtr++;
                }
            }
            *DestPtr = TEXT('\0');

            //
            // write key, name = modified relative path, value = flags
            //
            LastGoodFlags = LASTGOOD_OPERATION_DELETE;
            regres = RegSetValueEx(hKeyLastGood,
                                   RegName,
                                   0,
                                   REG_DWORD,
                                   (PBYTE)&LastGoodFlags,
                                   sizeof(LastGoodFlags));
            RegCloseKey(hKeyLastGood);
        }
    }

    //
    // ok, now we've populated the LKG directory with this file
    //
    if (is_inf) {
        //
        // if we backed up an INF that's in primary INF directory, we should also backup existing PNF
        // if we're writing an entry to delete INF, we'll always write an entry to delete PNF
        //
        MYASSERT(ExtPart);
        lstrcpy(ExtPart,TEXT(".PNF"));
        if(pSetupDoLastKnownGoodBackup(NULL,
                                       FullTargetFilename,
                                       SP_LKG_FLAG_FORCECOPY|SP_LKG_FLAG_DELETEIFNEW|(write_delete?SP_LKG_FLAG_DELETEEXISTING:0),
                                       LogContext) != NO_ERROR) {
            //
            // should never fail
            //
            MYASSERT(FALSE);
        }
    }
    //
    // done!
    //
    rval = NO_ERROR;
    goto final;

cleanup:

    //
    // cleanup in the case where we've already created temporary file
    //
    SetFileAttributes(TempFilename, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(TempFilename);

    rval = NO_ERROR;

final:
    if(LocalLogContext) {
        DeleteLogContext(LocalLogContext);
    }
    return rval;

#else
    //
    // ANSI - not supported
    //
    return NO_ERROR;
#endif
}

#ifdef UNICODE
BOOL
pSetupRestoreLastKnownGoodFile(
    IN PCTSTR                 TargetFilename,
    IN DWORD                  Flags,
    IN PSETUP_LOG_CONTEXT     LogContext       OPTIONAL
    )
/*++

Routine Description:

    Restore a single LKG file
    The assumption here is that if this API was called, we detected something
    really bad that needs to be fixed immediately

Arguments:

    TargetFilename      Name of file to restore
    Flags

    LogContext          If specified, provides preferred logging context

Return Value:

    TRUE if file was successfully restored

--*/
{
    int wd_len;   // windows directory len
    int tf_len;   // target file len
    int lkgd_len; // last known good directory len
    int rf_len;   // relative file len (including preceeding slash)
    TCHAR FullTargetFilename[MAX_PATH];
    TCHAR BackupTargetFilename[MAX_PATH+14];
    TCHAR TempFilename[MAX_PATH];
    TCHAR TempPathname[MAX_PATH];
    TCHAR RegName[MAX_PATH];
    PCTSTR RelativeFilename;
    PTSTR NamePart = NULL;
    BOOL rflag = FALSE;
    PSETUP_LOG_CONTEXT LocalLogContext = NULL;
    LONG regres;
    HKEY hKeyLastGood;
    PCTSTR CharPtr;
    PTSTR DestPtr;
    DWORD RegType;
    DWORD RegSize;
    DWORD LastGoodFlags = 0;

    if (!LogContext) {
        //
        // LogContext may be obmitted if there's a Queue parameter
        //
        if(CreateLogContext(NULL,TRUE,&LocalLogContext)==NO_ERROR) {
            LogContext = LocalLogContext;
        }
        MYASSERT(LogContext);
    }

    //
    // cannonicalize the Target name so user doesn't do stuff like .../TEMP/../INF
    //
    tf_len = (int)GetFullPathName(TargetFilename,
                             MAX_PATH,
                             FullTargetFilename,
                             &NamePart);
    if (tf_len <= 0 || tf_len > MAX_PATH) {
        //
        // we don't do large paths very well
        //
        goto final;
    }
    wd_len = lstrlen(WindowsDirectory);
    lkgd_len = lstrlen(LastGoodDirectory);

    //
    // see if this file is nested below <<WindowsDirectory>>
    // note that such a file must be at least two characters longer
    //
    if((tf_len <= wd_len)
       || (FullTargetFilename[wd_len] != TEXT('\\'))
       || (_tcsnicmp(WindowsDirectory,FullTargetFilename,wd_len)!=0)) {
        //
        // this file is outside of %windir%, not handled by LKG
        //
        goto final;
    }

    //
    // remap to LKG directory
    //
    RelativeFilename = FullTargetFilename+wd_len; // includes preceeding backslash
    rf_len = tf_len-wd_len;
    MYASSERT((MAX_PATH+(lkgd_len-wd_len))<=SIZECHARS(BackupTargetFilename));
    lstrcpy(BackupTargetFilename,LastGoodDirectory);
    lstrcpy(BackupTargetFilename+lkgd_len,RelativeFilename);

    //
    // does backup already exist?
    //
    if (GetFileAttributes(BackupTargetFilename)==(DWORD)(-1)) {
        //
        // if not, nothing we can do
        //
        goto final;
    }
    //
    // find LKG flags to see what we need to do
    //
    regres = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                          REGSTR_PATH_LASTGOOD,
                          0,
                          KEY_READ,
                          &hKeyLastGood);
    if (regres == NO_ERROR) {
        //
        // copy string, remapping slash's from '\\' to '/'
        //
        CharPtr = RelativeFilename+1; // after initial '\'
        DestPtr = RegName;
        while(*CharPtr) {
            PCTSTR Next = _tcschr(CharPtr,TEXT('\\'));
            if (!Next) {
                Next = CharPtr + lstrlen(CharPtr);
            }
            if(Next-CharPtr) {
                CopyMemory(DestPtr,CharPtr,(Next-CharPtr)*sizeof(TCHAR));
                DestPtr+=(Next-CharPtr);
                CharPtr = Next;
            }
            if (*CharPtr == TEXT('\\')) {
                *DestPtr = TEXT('/');
                DestPtr++;
                CharPtr++;
            }
        }
        *DestPtr = TEXT('\0');

        RegSize = sizeof(LastGoodFlags);
        regres = RegQueryValueEx(hKeyLastGood,
                                 RegName,
                                 NULL,
                                 &RegType,
                                 (PBYTE)&LastGoodFlags,
                                 &RegSize);
        if((regres != NO_ERROR)
           || (RegType != REG_DWORD)
           || (RegSize != sizeof(DWORD))) {
            //
            // default action is copy
            //
            LastGoodFlags = 0;
        }
        RegCloseKey(hKeyLastGood);
    }

    //
    // base directory of target file
    //
    lstrcpyn(TempPathname, FullTargetFilename, MAX_PATH);
    *((PTSTR)pSetupGetFileTitle(TempPathname)) = TEXT('\0');

    if (LastGoodFlags & LASTGOOD_OPERATION_DELETE) {
        //
        // delete
        //
        if(GetFileAttributes(FullTargetFilename)==(DWORD)(-1)) {
            //
            // already deleted
            //
            rflag = TRUE;
            goto final;
        }

        pSetupExemptFileFromProtection(
                    FullTargetFilename,
                    SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME,
                    LogContext,
                    NULL
                    );
        //
        // try the simple way first
        //
        SetFileAttributes(FullTargetFilename, FILE_ATTRIBUTE_NORMAL);
        if(!DeleteFile(FullTargetFilename)) {
            //
            // can't delete target directly
            //
            if(!GetTempFileName(TempPathname, TEXT("SETP"), 0, BackupTargetFilename)) {
                //
                // can't create backup temp, nothing we can do
                //
                goto final;
            }
            //
            // move existing file into a temp backup
            //
            if(!MoveFileEx(FullTargetFilename,BackupTargetFilename,MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)) {
                //
                // this failed too for some reason
                //
                SetFileAttributes(BackupTargetFilename, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(BackupTargetFilename);
                goto final;
            }
            //
            // now do something with the bad file
            // we don't care if this fails
            //
            SetFileAttributes(BackupTargetFilename, FILE_ATTRIBUTE_NORMAL);
            if(!DeleteFile(BackupTargetFilename)) {
                MoveFileEx(BackupTargetFilename,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);
            }
        }

    } else {
        //
        // restore back to LKG file
        //

        //
        // create intermediate directories as needed as part of the restore
        //
        pSetupMakeSurePathExists(FullTargetFilename);

        //
        // create a temporary filename to copy to
        // before moving restored file into place
        //
        if(!GetTempFileName(TempPathname, TEXT("SETP"), 0, TempFilename)) {
            //
            // can't create temp, nothing we can do
            //
            goto final;
        }
        if(!CopyFile(BackupTargetFilename,TempFilename,FALSE)) {
            //
            // failed to copy to temporary file
            //
            DeleteFile(TempFilename);
            goto final;
        }
        //
        // simple case, move temporary file over existing file
        //
        pSetupExemptFileFromProtection(
                    FullTargetFilename,
                    SFC_ACTION_ADDED | SFC_ACTION_REMOVED | SFC_ACTION_MODIFIED
                    | SFC_ACTION_RENAMED_OLD_NAME |SFC_ACTION_RENAMED_NEW_NAME,
                    LogContext,
                    NULL
                    );
        SetFileAttributes(FullTargetFilename, FILE_ATTRIBUTE_NORMAL);
        if(!MoveFileEx(TempFilename,FullTargetFilename,MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)) {
            //
            // we failed to overwrite file, need slightly different stratagy
            //
            if(!GetTempFileName(TempPathname, TEXT("SETP"), 0, BackupTargetFilename)) {
                //
                // can't create backup temp, nothing we can do
                //
                SetFileAttributes(TempFilename, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(TempFilename);
                goto final;
            }
            //
            // move existing file into a temp backup
            //
            if(!MoveFileEx(FullTargetFilename,BackupTargetFilename,MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)) {
                //
                // this failed too for some reason
                //
                SetFileAttributes(BackupTargetFilename, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(BackupTargetFilename);
                SetFileAttributes(TempFilename, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(TempFilename);
                goto final;
            }
            //
            // we moved existing file out of place, now move new file into place
            //
            if(!MoveFileEx(TempFilename,FullTargetFilename,MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH)) {
                //
                // huh? Ok, that failed, try to recover
                //
                MoveFileEx(BackupTargetFilename,FullTargetFilename,MOVEFILE_REPLACE_EXISTING|MOVEFILE_WRITE_THROUGH);
                SetFileAttributes(TempFilename, FILE_ATTRIBUTE_NORMAL);
                DeleteFile(TempFilename);
                goto final;
            }
            //
            // now do something with the bad file
            // we don't care if this fails
            //
            SetFileAttributes(BackupTargetFilename, FILE_ATTRIBUTE_NORMAL);
            if(!DeleteFile(BackupTargetFilename)) {
                MoveFileEx(BackupTargetFilename,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);
            }
        }
    }

    //
    // done!
    //
    rflag = TRUE;

final:
    if(LocalLogContext) {
        DeleteLogContext(LocalLogContext);
    }
    return rflag;
}
#endif


#ifdef UNICODE
WINSETUPAPI
BOOL
WINAPI
SetupPrepareQueueForRestoreA(
    IN     HSPFILEQ                     QueueHandle,
    IN     PCSTR                        BackupPath,
    IN     DWORD                        RestoreFlags
    )
/*++

    See SetupPrepareQueueForRestore

--*/
{
    BOOL f;
    DWORD rc;
    PCWSTR UnicodeBackupPath;

    if(BackupPath) {
        rc = pSetupCaptureAndConvertAnsiArg(BackupPath, &UnicodeBackupPath);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return FALSE;
        }
    } else {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    f = SetupPrepareQueueForRestore(QueueHandle,UnicodeBackupPath,RestoreFlags);
    rc = GetLastError();
    MyFree(UnicodeBackupPath);
    SetLastError(rc);
    return f;
}

#else

WINSETUPAPI
BOOL
WINAPI
SetupPrepareQueueForRestoreW(
    IN     HSPFILEQ                     QueueHandle,
    IN     PCWSTR                       BackupPath,
    IN     DWORD                        RestoreFlags
    )
/*++

    ANSI stub

--*/
{
    UNREFERENCED_PARAMETER(QueueHandle);
    UNREFERENCED_PARAMETER(BackupPath);
    UNREFERENCED_PARAMETER(RestoreFlags);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}

#endif

WINSETUPAPI
BOOL
WINAPI
SetupPrepareQueueForRestore(
    IN     HSPFILEQ                     QueueHandle,
    IN     PCTSTR                       BackupPath,
    IN     DWORD                        RestoreFlags
    )
/*++

Routine Description:

    Initializes restore directory

Arguments:

    QueueHandle      - file queue to modify
    BackupPath       - original backup directory to use for restore
    RestoreFlags     - options

Return Value:

    TRUE if success, else FALSE

--*/
{
    BOOL b = TRUE;
    DWORD rc;
    BOOL f = FALSE;
    PSP_FILE_QUEUE Queue = (PSP_FILE_QUEUE)QueueHandle;
    LONG RestorePathID;

    //
    // validate string pointer
    //
    if(!BackupPath) {
        rc = ERROR_INVALID_PARAMETER;
        goto clean;
    }
    //
    // validate flags (currently not implemented)
    //
    if(RestoreFlags) {
        rc = ERROR_INVALID_PARAMETER;
        goto clean;
    }
    //
    // validate QueueHandle
    //
    try {
        if(Queue->Signature != SP_FILE_QUEUE_SIG) {
            b = FALSE;
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        rc = ERROR_INVALID_HANDLE;
        goto clean;
    }

    try {
        //
        // if a restore point has previously been set, return error
        //
        if(Queue->RestorePathID != -1) {
            rc = ERROR_ALREADY_EXISTS;
            leave;
        }
        RestorePathID = pSetupStringTableAddString(Queue->StringTable,
                                                   (PTSTR)BackupPath ,
                                                   STRTAB_CASE_SENSITIVE);
        if (RestorePathID == -1) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        //
        // done - just need to set the restore-path
        //
        Queue->RestorePathID = RestorePathID;

        WriteLogEntry(Queue->LogContext,
                      SETUP_LOG_WARNING,
                      MSG_LOG_RESTORE,
                      NULL,
                      BackupPath
                     );

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_DATA;
    }

    f = TRUE;
    rc = NO_ERROR;
clean:
    //
    // no cleanup required
    //
    SetLastError(rc);
    return f;
}


#define SP_TEFLG_BITS_TO_RESET  (  SP_TEFLG_SAVED         \
                                 | SP_TEFLG_TEMPNAME      \
                                 | SP_TEFLG_ORIGNAME      \
                                 | SP_TEFLG_MODIFIED      \
                                 | SP_TEFLG_MOVED         \
                                 | SP_TEFLG_BACKUPQUEUE   \
                                 | SP_TEFLG_RESTORED      \
                                 | SP_TEFLG_UNWIND        \
                                 | SP_TEFLG_SKIPPED       \
                                 | SP_TEFLG_INUSE         \
                                 | SP_TEFLG_RENAMEEXISTING )

BOOL
pSetupResetTarget(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,        OPTIONAL
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    )

/*++

Routine Description:

    This routine resets the SP_TARGET_ENT data stored with a string table entry
    in a file queue's TargetLookupTable.  This routine may be used as the
    callback function to iterate such entries via pSetupStringTableEnum.

Arguments:

    StringTable - Supplies a handle to the string table being enumerated

    StringId - Supplies the ID of the current string

    String - Optionally, supplies a pointer to the current string (this will
        always be filled in when this routine is used as a callback for
        pSetupStringTableEnum, but other callers may omit it, as it isn't
        needed).

    ExtraData - Supplies a pointer to the SP_TARGET_ENT data associatd with
        the string

    ExtraDataSize - Supplies the size of the buffer pointed to by ExtraData--
        should always be sizeof(SP_TARGET_ENT)

    lParam - unused

Return Value:

    This routine always returns TRUE, so that all string entries will be
    enumerated.

--*/

{
    PSP_TARGET_ENT TargetInfo;
    BOOL b;

    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(lParam);

    MYASSERT(ExtraData);
    MYASSERT(ExtraDataSize == sizeof(SP_TARGET_ENT));

    //
    // Clear the bits that will get re-generated when the queue is committed
    // again.
    //
    ((PSP_TARGET_ENT)ExtraData)->InternalFlags &= ~SP_TEFLG_BITS_TO_RESET;

    //
    // Also need to reset the NewTargetFilename
    //
    ((PSP_TARGET_ENT)ExtraData)->NewTargetFilename = -1;

    //
    // Store the modified data back to the string table entry
    //
    b = pSetupStringTableSetExtraData(StringTable,
                                      StringId,
                                      ExtraData,
                                      ExtraDataSize
                                     );
    //
    // This should never fail
    //
    MYASSERT(b);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\cntxtlog.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cntxtlog.c

Abstract:

    This module implements more logging for setupapi

Author:

    Gabe Schaffer (t-gabes) 25-Jun-1998

Revision History:

    Jamie Hunter (jamiehun) Apr 11 2000 - added #xnnnn identifiers
    Jamie Hunter (jamiehun) Feb 2 2000  - cleanup
    Jamie Hunter (jamiehun) Aug 31 1998

--*/

#include "precomp.h"
#pragma hdrstop

//
// global data used by logging
//

struct _GlobalLogData {

    CRITICAL_SECTION CritSec;
    BOOL             DoneInitCritSec;
    LONG             UID;
    ULONG            Flags;
    PTSTR            FileName;

} GlobalLogData;

#define LogLock()          EnterCriticalSection(&GlobalLogData.CritSec)
#define LogUnlock()        LeaveCriticalSection(&GlobalLogData.CritSec)

// process-wide log counter
//
// C = critical
// E = error
// W = warning
// I = information
// V = verbose
// T = timing
// * = currently undefined
//
static const TCHAR LogLevelShort[17] = TEXT("CEWIVTTV********");
#define LOGLEVELSHORT_MASK (0x0f)
#define LOGLEVELSHORT_INIT (0x100)
#define LOGLEVELSHORT_SHIFT (4)


__inline // we want to always optimize this out
BOOL
_WouldNeverLog(
    IN DWORD Level
    )

/*++

Routine Description:

    Determines if at the current logging level and the required level, we would never log
    inline'd for optimization (used only in this file)


Arguments:

    Level - only required to check for special case of 0.

Return Value:

    TRUE if we know we would never log based on passed information

--*/

{

    if (Level == 0) {
        //
        // don't-log level
        //
        return TRUE;
    }

    if (((GlobalLogData.Flags & SETUP_LOG_LEVELMASK) <= SETUP_LOG_NOLOG)
        &&((GlobalLogData.Flags & DRIVER_LOG_LEVELMASK) <= DRIVER_LOG_NOLOG)) {
        //
        // Global flags indicate do no logging at all
        //
        return TRUE;
    }

    return FALSE;
}

__inline // we want to always optimize this out
BOOL
_WouldLog(
    IN DWORD Level
    )

/*++

Routine Description:

    Determines if at the current logging level and the required level, we would log
    inline'd for optimization (used only in this file)

    Note that if _WouldNeverLog is TRUE, _WouldLog is always FALSE
    if _WouldLog is TRUE, _WouldNeverLog is always FALSE
    if both are FALSE, then we are on "maybe"

Arguments:

    Level - bitmask indicating logging flags. See SETUP_LOG_* and DRIVER_LOG_*
        at the beginning of cntxtlog.h for details. It may also be a slot
        returned by AllocLogInfoSlot, or 0 (no logging)

Return Value:

    TRUE if we know we would log

--*/

{

    if (_WouldNeverLog(Level)) {
        //
        // some simple tests (LogLevel==NULL is a not sure case)
        //
        return FALSE;
    }

    if ((Level & SETUP_LOG_IS_CONTEXT)!=0) {
        //
        // context logging - ignored here (a not sure case)
        //
        return FALSE;
    }

    //
    // determine logability
    //
    if ((Level & SETUP_LOG_LEVELMASK) > 0 && (Level & SETUP_LOG_LEVELMASK) <= (GlobalLogData.Flags & SETUP_LOG_LEVELMASK)) {
        //
        // we're interested in logging - raw error level
        //
        return TRUE;
    }
    if ((Level & DRIVER_LOG_LEVELMASK) > 0 && (Level & DRIVER_LOG_LEVELMASK) <= (GlobalLogData.Flags & DRIVER_LOG_LEVELMASK)) {
        //
        // we're interested in logging - driver error level
        //
        return TRUE;
    }

    return FALSE;
}

VOID
UnMapLogFile(
    IN PSTR baseaddr,
    IN HANDLE hLogfile,
    IN HANDLE hMapping,
    IN BOOL seteof
    )

/*++

Routine Description:

    Unmap, possibly unlock, maybe set the EOF, and close a file.  Note, setting
    EOF must occur after unmapping.

Arguments:

    baseaddr - this is the address where the file is mapped.  It must be what
        was returned by MapLogFile.

    hLogfile - this is the Win32 handle for the log file.

    hMapping - this is the Win32 handle to the mapping object.

    seteof - Boolean value indicating whether the EOF should be set to the
        current file pointer.  If the EOF is set and the file pointer has not
        been moved, the EOF will be set at byte 0, thus truncating the file
        to 0 bytes.

Return Value:

    NONE.

--*/

{
    DWORD success;

    //
    // we brute-force try to close everything up
    //

    try {
        if (baseaddr != NULL) {
            success = UnmapViewOfFile(baseaddr);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing
        //
    }

    try {
        if (hMapping != NULL) {
            //
            // hMapping uses NULL to indicate a problem
            //
            success = CloseHandle(hMapping);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing
        //
    }

    try {
        if (hLogfile != INVALID_HANDLE_VALUE && seteof) {
            success = SetEndOfFile(hLogfile);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing
        //
    }

    try {
        if (hLogfile != INVALID_HANDLE_VALUE) {
            if (!(GlobalLogData.Flags & SETUP_LOG_NOFLUSH)) {
                FlushFileBuffers(hLogfile);
            }
            success = CloseHandle(hLogfile);
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing
        //
    }
    //
    // Win9x provides no way to wait for a file to become unlocked, so we
    // have to poll. Putting this Sleep(0) allows others to have a chance
    // at the file.
    //
    Sleep(0);
}

VOID
WriteLogFileHeader(
    IN HANDLE hLogFile
    )
/*++

Routine Description:

    Write general information at start of log file

    [SetupAPI Log]
    OS Version = %1!u!.%2!u!.%3!u! %4!s!
    Platform ID = %5!u!
    Service Pack = %6!u!.%7!u!
    Suite = 0x%8!04x!
    Product Type = %9!u!

Arguments:

    hLogfile - file to write header to

Return Value:

    NONE

--*/
{
#ifdef UNICODE
    OSVERSIONINFOEX VersionInfo;
#else
    OSVERSIONINFO VersionInfo;
#endif
    DWORD count;
    DWORD written;
    PTSTR buffer;
    PSTR ansibuffer;
    ULONG_PTR args[14];
    DWORD MessageId = MSG_LOGFILE_HEADER_OTHER;

    ZeroMemory(&VersionInfo,sizeof(VersionInfo));
#ifdef UNICODE
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if(!GetVersionEx((POSVERSIONINFO)&VersionInfo)) {
        VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if(!GetVersionEx((POSVERSIONINFO)&VersionInfo)) {
            return;
        }
    }
#else
    VersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx((POSVERSIONINFO)&VersionInfo)) {
        return;
    }
#endif

    args[1] = (ULONG_PTR)VersionInfo.dwMajorVersion;
    args[2] = (ULONG_PTR)VersionInfo.dwMinorVersion;
    args[4] = (ULONG_PTR)VersionInfo.szCSDVersion;   // string
    args[5] = (ULONG_PTR)VersionInfo.dwPlatformId;
    if(VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) {
        args[3] = (ULONG_PTR)VersionInfo.dwBuildNumber;
#ifdef UNICODE
        MessageId = MSG_LOGFILE_HEADER_NT;
#endif
    } else {
        args[3] = (ULONG_PTR)LOWORD(VersionInfo.dwBuildNumber); // Win9x re-uses high word
    }
#ifdef UNICODE
    args[6] = (ULONG_PTR)VersionInfo.wServicePackMajor;
    args[7] = (ULONG_PTR)VersionInfo.wServicePackMinor;
    args[8] = (ULONG_PTR)VersionInfo.wSuiteMask;
    args[9] = (ULONG_PTR)VersionInfo.wProductType;
    args[10] = (ULONG_PTR)pszPlatformName;
#endif

    count = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_ARGUMENT_ARRAY|FORMAT_MESSAGE_FROM_HMODULE,
                          MyDllModuleHandle,
                          MessageId,
                          0,
                          (LPTSTR) &buffer,
                          0,
                          (va_list*)(args+1));
    if (count && buffer) {
#ifdef UNICODE
        ansibuffer = pSetupUnicodeToMultiByte(buffer,CP_ACP);
        if (ansibuffer) {
            WriteFile(hLogFile,ansibuffer,strlen(ansibuffer),&written,NULL);
            MyFree(ansibuffer);
        }
#else
        WriteFile(hLogFile,buffer,strlen(buffer),&written,NULL);
#endif
        LocalFree(buffer);
    }
}

DWORD
MapLogFile(
    IN PCTSTR FileName,
    OUT PHANDLE hLogfile,
    OUT PHANDLE hMapping,
    OUT PDWORD dwFilesize,
    OUT PSTR *mapaddr,
    IN DWORD extrabytes
    )

/*++

Routine Description:

    Open the log file for writing and memory map it.  On NT the file is locked,
    but Win9x doesn't allow memory mapped access to locked files, so the file
    is opened without FILE_SHARE_WRITE access.  Since CreateFile won't block
    like LockFileEx, we have to poll once per second on Win9x until the file
    opens.

Arguments:

    FileName - supplies path name to the log file.

    hLogfile - receives the Win32 file handle for the log file.

    hMapping - receives the Win32 handle to the mapping object.

    dwFileSize - receives the size of the file before it is mapped, because
        mapping increases the size of the file by extrabytes.

    mapaddr - receives the address of where the log file is mapped.

    extrabytes - supplies the number of extra bytes (beyond the size of the
        file) to add to the size of the mapping object to allow for appending
        the new log line and possibly a section header.

Return Value:

    NO_ERROR if the file is successfully opened and mapped.  The caller must
    call UnMapLogFile when finished with the file.

    Win32 error code if the file is not open.

--*/

{
    HANDLE logfile = INVALID_HANDLE_VALUE;
    HANDLE mapping = NULL;
    DWORD filesize = 0;
    DWORD lockretrywait = 1;
    DWORD wait_total = 0;
    PSTR baseaddr = NULL;
    DWORD retval = ERROR_INVALID_PARAMETER;

    //
    // wrap it all up in a nice big try/except, because you just never know
    //
    try {

        //
        // give initial "failed" values
        // this also validates the pointers
        //
        *hLogfile = logfile;
        *hMapping = mapping;
        *dwFilesize = filesize;
        *mapaddr = baseaddr;

        do {
            //
            // retry here, in case lock fails
            //
            logfile = CreateFile(
                FileName,
                GENERIC_READ | GENERIC_WRITE,   // access mode
                FILE_SHARE_READ,
                NULL,                           // security
                OPEN_ALWAYS,                    // open, or create if not already there
                //FILE_FLAG_WRITE_THROUGH,        // flags - ensures that if machine crashes in the next operation, we are still logged
                0,
                NULL);                          // template

            if (logfile == INVALID_HANDLE_VALUE) {
                retval = GetLastError();
                if (retval != ERROR_SHARING_VIOLATION) {
                    MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Could not create file %s. Error %d\n"), FileName, retval));
                    leave;
                }
                if(wait_total >= MAX_LOG_WAIT) {
                    MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Given up waiting for log file %s.\n"), FileName));
                    leave;
                }
                //
                // don't want to wait more than a second at a time
                //
                if (lockretrywait < MAX_LOG_INTERVAL) {
                    lockretrywait *= 2;
                }
                MYTRACE((DPFLTR_WARNING_LEVEL, TEXT("Setup: Could not open file. Error %d; waiting %ums\n"), GetLastError(), lockretrywait));

                Sleep(lockretrywait);
                wait_total += lockretrywait;
            }
        } while (logfile == INVALID_HANDLE_VALUE);

        //
        // this will NOT work with files >= 4GB, but it's not supposed to
        //
        filesize = GetFileSize(logfile,NULL);

        if (filesize == 0) {
            //
            // fill some OS information into file
            //
            WriteLogFileHeader(logfile);
            filesize = GetFileSize(logfile,NULL);
        }

        //
        // make the mapping object with extra space to accomodate the new log entry
        //
        mapping = CreateFileMapping(
            logfile,            // file to map
            NULL,               // security
            PAGE_READWRITE,     // protection
            0,                  // maximum size high
            filesize + extrabytes,      // maximum size low
            NULL);              // name

        if (mapping != NULL) {
            //
            // NULL isn't a bug, CreateFileMapping returns this
            // to indicate error, instead of INVALID_HANDLE_VALUE
            //

            //
            // now we have a section object, so attach it to the log file
            //
            baseaddr = (PSTR) MapViewOfFile(
                mapping,                // file mapping object
                FILE_MAP_ALL_ACCESS,    // desired access
                0,                      // file offset high
                0,                      // file offset low
                0);                     // number of bytes to map (0 = whole file)
        }
        else {
            retval = GetLastError();
            MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Could not create mapping. Error %d\n"), retval));
            leave;
        }

        if (baseaddr == NULL) {
            //
            // either the mapping object couldn't be created or
            // the file couldn't be mapped
            //
            retval = GetLastError();
            MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Could not map file. Error %d\n"), retval));
            leave;
        }

        //
        // now put everything where the caller can see it, but make sure we clean
        // up first
        //
        *hLogfile = logfile;
        *hMapping = mapping;
        *dwFilesize = filesize;
        *mapaddr = baseaddr;

        retval = NO_ERROR;

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // something bad happened, probably an AV, so just dump everything
        // and return an error meaning "Attempt to access invalid address."
        //
    }

    if (retval != NO_ERROR) {
        //
        // an error occurred, cleanup what we need to
        //
        UnMapLogFile(baseaddr, logfile, mapping, FALSE);
    }

    return retval;
}

BOOL
IsSectionHeader(
    IN PCSTR Header,
    IN DWORD Size,
    IN PCSTR Beginning
    )

/*++

Routine Description:

    Determines whether a given string starts with a section header.  This is
    the routine that essentially defines what a valid section header is.

Arguments:

    Header - supplies a pointer to what may be the first character in a header.

    Size - supplies the length of the string passed in, which is NOT the size
        of the header.

    Beginning - supplies a pointer to the beginning of the file.

Return Value:

    BOOL indicating if Header points to a valid section header.

--*/

{
    //
    // assume a header looks like [foobar]\r\n
    //
    DWORD i;
    //
    // state holds the value we're looking for
    UINT state = '[';

    //
    // a section header must always be either at the start of a line or at
    // the beginning of a file
    //
    if (Header != Beginning && Header[-1] != '\n')
        return FALSE;

    for (i = 0; i < Size; i++) {
        switch (state) {
        case '[':
            if (Header[i] == '[') {
                state = ']';
            } else {
                return FALSE;
            }
            break;

        case ']':
            if (Header[i] == ']') {
                state = '\r';
            }
            break;

        case '\r':
            if (Header[i] == '\r') {
                state = '\n';
            //
            // allow for the case where a line has a linefeed, but no CR
            //
            } else if (Header[i] == '\n') {
                return TRUE;
            } else {
                return FALSE;
            }
            break;

        case '\n':
            if (Header[i] == '\n') {
                return TRUE;
            } else {
                return FALSE;
            }
            //
            // break; -- commented out to avoid unreachable code error
            //
        default:
            MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: Invalid state! (%d)\n"), state));
            MYASSERT(0);
        }
    }

    return FALSE;
}

BOOL
IsEqualSection(
    IN PCSTR Section1,
    IN DWORD Len1,
    IN PCSTR Section2,
    IN DWORD Len2
    )

/*++

Routine Description:

    Says whether two ANSI strings both start with the same section header.  One of
    the strings must be just a section header, while the other one may be
    anything, such as the entire log file.

Arguments:

    Section1 - supplies the address of the first string.

    Len1 - supplies the length of the first string.

    Section2 - supplies the address of the second string.

    Len2 - supplies the length of the second string.

Return Value:

    BOOL indicating if the longer string starts with the shorter string.

--*/

{
    //
    // maxlen is the maximum length that both strings could be, and still be
    // the same section name
    //
    DWORD maxlen = Len2;

    if (Len1 < Len2) {
        maxlen = Len1;
    }

    if (_strnicmp(Section1, Section2, maxlen) == 0) {
        //
        // they're the same (ignoring case)
        //
        return TRUE;
    }

    return FALSE;
}

DWORD
AppendLogEntryToSection(
    IN PCTSTR FileName,
    IN PCSTR Section,
    IN PCSTR Entry,
    IN BOOL SimpleAppend
    )

/*++

Routine Description:

    Opens the log file, finds the appropriate section, moves it to the end of
    the file, appends the new entry, and closes the file.

Arguments:

    FileName - supplies the path name of the log file.

    Section - supplies the ANSI name of the section to be logged to.

    Entry - supplies the ANSI string to be logged.

    SimpleAppend - specifies whether entries will simply be appended to the log
        file or appended to the section where they belong.

Return Value:

    NO_ERROR if the entry gets written to the log file.

    Win32 error or exception code if anything went wrong.

--*/

{
    DWORD retval = NO_ERROR;
    DWORD fpoff;
    HANDLE hLogfile = INVALID_HANDLE_VALUE;
    HANDLE hMapping = NULL;
    DWORD filesize = 0;
    PSTR baseaddr = NULL;
    DWORD sectlen = lstrlenA(Section);
    DWORD entrylen = lstrlenA(Entry);
    DWORD error;
    BOOL seteof = FALSE;
    BOOL mapped = FALSE;
    PSTR eof;
    PSTR curptr;
    PSTR lastsect = NULL;

    try {
        MYASSERT(Section != NULL && Entry != NULL);

        sectlen = lstrlenA(Section);
        entrylen = lstrlenA(Entry);
        if (sectlen == 0 || entrylen == 0) {
            //
            // not an error as such, but not useful either
            //
            retval = NO_ERROR;
            leave;
        }

        error = MapLogFile(
                    FileName,
                    &hLogfile,
                    &hMapping,
                    &filesize,
                    &baseaddr,
                    sectlen + entrylen + 8);// add some extra space to the mapping
                                            // to take into account the log entry
                                            // +2 to terminate unterminated last line
                                            // +2 to append CRLF or ": " after section
                                            // +2 to append CRLF after entrylen if req
                                            // +2 for good measure
        if (error != NO_ERROR) {
            //
            // could not map file
            //
            retval = error;
            leave;
        }

        mapped = TRUE;

        eof = baseaddr + filesize; // end of file, as of now
        curptr = eof;

        while (curptr > baseaddr && (curptr[-1]==0 || curptr[-1]==0x1A)) {
            //
            // eat up trailing Nul's or ^Z's
            // the former is a side-effect of mapping
            // the latter could be introduced by an editor
            //
            curptr --;
            eof = curptr;
        }
        if (eof > baseaddr && eof[-1] != '\n') {
            //
            // make sure file already ends in LF
            // if it doesn't, append a CRLF
            //
            memcpy(eof, "\r\n", 2);
            eof += 2;
        }
        if (SimpleAppend) {
            //
            // instead of having a regular section header, the section name is
            // placed at the beginning of each log line followed by a colon.
            // this is particularly only of interest when debugging the logging functions
            //
            memcpy(eof, Section, sectlen);
            eof += sectlen;
            memcpy(eof, ": ", 2);
            eof += 2;

        } else {
            //
            // the entry must be appended to the correct section in the log,
            // which requires finding the section and moving it to the end of
            // the file if required.
            //
            // search backwards in the file, looking for the section header
            //
            if (eof == baseaddr) {
                //
                // truncated (empty) file
                //
                curptr = NULL;
            } else {
                curptr = eof - 1;

                while(curptr > baseaddr) {
                    //
                    // scan for section header a line at a time
                    // going backwards, since our section should be near end
                    //
                    if (curptr[-1] == '\n') {
                        //
                        // speed optimization: only bother checking if we think we're at the beginning of a new line
                        // this may find a '\n' that is part of a MBCS char,
                        // but should be eliminated by IsSectionHeader check
                        //
                        if (IsSectionHeader(curptr, (DWORD)(eof - curptr), baseaddr)) {
                            //
                            // looks like a section header, now see if it's the one we want
                            //
                            if (IsEqualSection(curptr, (DWORD)(eof - curptr), Section, sectlen)) {
                                //
                                // yep - done
                                //
                                break;
                            } else {
                                //
                                // will eventually be the section after the one of interest
                                //
                                lastsect = curptr;
                            }
                        }
                    }
                    curptr --;
                }
                if (curptr == baseaddr) {
                    //
                    // final check if we got to the beginning of the file (no find)
                    //
                    if (IsSectionHeader(curptr, (DWORD)(eof - curptr), baseaddr)) {
                        //
                        // the first line should always be a section header
                        //
                        if (!IsEqualSection(curptr, (DWORD)(eof - curptr), Section, sectlen)) {
                            //
                            // first section isn't the one of interest
                            // so therefore we couldn't find it
                            //
                            curptr = NULL;
                        }
                    }
                }
            }
            if (curptr == NULL) {
                //
                // no matching section found (or file was empty)
                // copy the section header to the end of the file
                // eof is known to be actual end of file
                //
                memcpy(eof, Section, sectlen);
                eof += sectlen;
                memcpy(eof, "\r\n", 2);
                eof += 2;

            } else if (lastsect != NULL) {
                //
                // we have to rearrange the sections, as we have a case as follows:
                //
                // ....
                // ....
                // (curptr) [section A]     = section of interest
                // ....
                // ....
                // (lastsect) [section B]   = section after section of interest
                // ....
                // ....
                //
                // we want to move the text between curptr and lastsect to end of file
                //
                PSTR buffer = MyMalloc((DWORD)(lastsect - curptr));

                if (buffer) {
                    // first copy the important section to the buffer
                    //
                    memcpy(buffer, curptr, (size_t)(lastsect - curptr));
                    //
                    // now move the rest of the thing back
                    //
                    memcpy(curptr, lastsect, (size_t)(eof - lastsect));
                    //
                    // put the important section at the end where it belongs
                    //
                    memcpy(curptr - lastsect + eof, buffer, (size_t)(lastsect - curptr));

                    MyFree(buffer);

                } else {
                    //
                    // For some reason, we cannot allocate enough memory.
                    //
                    // There are 4 options here:
                    // 1. Do nothing; this will cause the entry to be appended to
                    //    the file, but as part of the wrong section.
                    // 2. Bail; this will cause the log entry to get lost.
                    // 3. Create a second file to contain a temporary copy of the
                    //    section; this will require creating another file, and
                    //    then deleting it.
                    // 4. Extend the mapping of the current file to be big enough
                    //    to hold another copy of the section; this will cause the
                    //    file to have a lot of 0s or possibly another copy of the
                    //    section, should the machine crash during the processing.
                    //
                    // we do option 2 - BAIL!
                    //
                    retval = ERROR_NOT_ENOUGH_MEMORY;
                    leave;
                }
            }
        }

        //
        // now append the log entry
        //
        memcpy(eof, Entry, entrylen);
        eof += entrylen;
        if (eof[-1] != '\n') {
            //
            // entry did not supply en end of line, so we will
            //
            memcpy(eof, "\r\n", 2);
            eof += 2;
        }
        //
        // because of the memory mapping, the file size will not be correct,
        // so set the pointer to where we think the end of file is, and then
        // the real EOF will be set after unmapping, but before closing
        //
        fpoff = SetFilePointer(
            hLogfile,           // handle of file
            (LONG)(eof - baseaddr), // number of bytes to move file pointer
            NULL,               // pointer to high-order DWORD of
                                // distance to move
            FILE_BEGIN);        // how to move

        if (fpoff == (DWORD)(-1) && (error = GetLastError()) != NO_ERROR) {
            MYTRACE((DPFLTR_ERROR_LEVEL, TEXT("Setup: SFP returned %u; eof = %u\n"), error, (eof - baseaddr)));
            retval = error;
            leave;
        }
        seteof = TRUE;
        retval = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // invalid data
        //
        retval = ERROR_INVALID_DATA;
    }

    //
    // unmap
    //
    if (mapped) {
        UnMapLogFile(baseaddr, hLogfile, hMapping, seteof);
    }

    return retval;
}

VOID
WriteLogSectionEntry(
    IN PCTSTR FileName,
    IN PCTSTR Section,
    IN PCTSTR Entry,
    IN BOOL SimpleAppend
    )

/*++

Routine Description:

    Convert parameters to ANSI, then append an entry to a given section of the
    log file.

Arguments:

    FileName - supplies the path name of the log file.

    Section - supplies the name of section.

    Entry - supplies the string to append to section.

    SimpleAppend - specifies whether entries will simply be appended to the log
        file or appended to the section where they belong.

Return Value:

    NONE.

--*/

{
    PCSTR ansiSection = NULL;
    PCSTR ansiEntry = NULL;

    try {
        MYASSERT(Section != NULL && Entry != NULL);

#ifdef UNICODE
        ansiSection = pSetupUnicodeToMultiByte(Section, CP_ACP);
        ansiEntry = pSetupUnicodeToMultiByte(Entry, CP_ACP);

        if(!ansiSection || !ansiEntry) {
            leave;
        }
#else
        ansiSection = Section;
        ansiEntry = Entry;
#endif

        AppendLogEntryToSection(
            FileName,
            ansiSection,
            ansiEntry,
            SimpleAppend);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // invalid data
        //
    }
#ifdef UNICODE
    if (ansiSection != NULL) {
        MyFree(ansiSection);
    }
    if (ansiEntry != NULL) {
        MyFree(ansiEntry);
    }
#endif

}

DWORD
MakeUniqueName(
    IN  PCTSTR Component,        OPTIONAL
    OUT PTSTR * UniqueString
    )

/*++

Routine Description:

    Create a section name that's unique by using a timestamp.
    If Component is supplied, append that to the timestamp.

Arguments:

    Component - supplies a string to be included in the unique name.
    UniqueString - supplies a pointer to be set with return string

Return Value:

    Error status

--*/

{
    SYSTEMTIME now;
    LPTSTR buffer = NULL;
    DWORD status = ERROR_INVALID_DATA;
    ULONG sz;
    LONG UID;

    try {
        if (UniqueString == NULL) {
            //
            // invalid param
            //
            status = ERROR_INVALID_PARAMETER;
            leave;
        }
        *UniqueString = NULL;

        if (Component == NULL) {
            //
            // treat as empty string
            //
            Component = TEXT("");
        }

        UID = InterlockedIncrement(&(GlobalLogData.UID)); // returns a new ID value whenever called, ensures uniqueness per process

        //
        // calculate how big string is going to be, be generous (see wsprintf below)
        //
        sz = /*[] and padding*/ 4 /*date*/ +5+3+3 /*time*/ +3+3+3 /*PID*/ +12 /*UID*/ +12 /*Component*/ +1+lstrlen(Component);
        buffer = MyTaggedMalloc(sz * sizeof(TCHAR),MEMTAG_LCSECTION);
        if (buffer == NULL) {
            status = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        GetLocalTime(&now);

        wsprintf(buffer, TEXT("[%04d/%02d/%02d %02d:%02d:%02d %u.%u%s%s]"),
            now.wYear, now.wMonth, now.wDay,
            now.wHour, now.wMinute, now.wSecond,
            (UINT)GetCurrentProcessId(),
            (UINT)UID,
            (Component[0] ? TEXT(" ") : TEXT("")),
            Component);

        *UniqueString = buffer;
        buffer = NULL;

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // status remains ERROR_INVALID_DATA
        //
    }

    if (buffer != NULL) {
        MyTaggedFree(buffer,MEMTAG_LCSECTION);
    }

    return status;
}

DWORD
CreateLogContext(
    IN  PCTSTR SectionName,              OPTIONAL
    IN  BOOL UseDefault,
    OUT PSETUP_LOG_CONTEXT *LogContext
    )

/*++

Routine Description:

    Creates and initializes a SETUP_LOG_CONTEXT struct.

Arguments:

    SectionName - supplies an initial string to be used as part of the
        section name.

    LogContext - supplies a pointer to where the pointer to the allocated
        SETUP_LOG_CONTEXT should be stored.

Return Value:

    NO_ERROR in case of successful structure creation.

    Win32 error code in case of error.

--*/

{
    PSETUP_LOG_CONTEXT lc = NULL;
    DWORD status = ERROR_INVALID_DATA;
    DWORD rc;

    try {

        if (LogContext == NULL) {
            status = ERROR_INVALID_PARAMETER;
            leave;
        }

        *LogContext = NULL;

        if (UseDefault) {
            lc = GetThreadLogContext();
            RefLogContext(lc);
        }
        if (!lc) {
            lc = (PSETUP_LOG_CONTEXT) MyTaggedMalloc(sizeof(SETUP_LOG_CONTEXT),MEMTAG_LOGCONTEXT);
            if (lc == NULL) {
                status = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }
            //
            // all fields start out at 0
            //
            ZeroMemory(lc, sizeof(SETUP_LOG_CONTEXT));
            lc->RefCount = 1;
            lc->ContextInfo = NULL;
            lc->ContextIndexes = NULL;
            lc->ContextBufferSize = 0;
            lc->ContextLastUnused = -1;
            lc->ContextFirstUsed = -1;
            lc->ContextFirstAuto = -1;

            rc = MakeUniqueName(SectionName,&(lc->SectionName));
            if (rc != NO_ERROR) {
                status = rc;
                leave;
            }
        }
        *LogContext = lc;

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // status remains ERROR_INVALID_DATA
        //
    }

    if (status != NO_ERROR) {
        if (lc != NULL) {
            DeleteLogContext(lc);
            lc = NULL;
        }
    }

    return status;
}

DWORD
AllocLogInfoSlotOrLevel(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN DWORD              Level,
    IN BOOL               AutoRelease
    )
/*++

Routine Description:

    Obtain a new context stack entry for a context string only if current logging level is less verbose than specified
    Eg, if we specified DRIVER_LOG_VERBOSE, we will either return DRIVER_LOG_VERBOSE (if we would log it) or a slot
    if we would not normally log it.

Arguments:

    LogContext - supplies a pointer to the SETUP_LOG_CONTEXT to use
    Level - logging level we want to always log the information at
    AutoRelease - if set, will release the context when dumped

Return Value:

    Slot value to pass to logging functions, or a copy of Level
    note that if there is an error, 0 is returned
    return value can always be passed to ReleaseLogInfoSlot

--*/
{
    if((LogContext == NULL) || _WouldNeverLog(Level)) {
        //
        // when 0 get's passed to logging functions, it will exit out very quickly
        //
        return 0;
    }
    if(_WouldLog(Level)) {
        //
        // Level specifies a verbosity level that would cause logging
        //
        return Level;
    } else {
        //
        // interestingly enough, we will also get here if Level is a slot
        // this is what we want
        //
        return AllocLogInfoSlot(LogContext,AutoRelease);
    }
}

DWORD
AllocLogInfoSlot(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN BOOL               AutoRelease
    )
/*++

Routine Description:

    Obtain a new context stack entry for a context string

Arguments:

    LogContext - supplies a pointer to the SETUP_LOG_CONTEXT to use
    AutoRelease - if set, will release the context when dumped

Return Value:

    Slot value to pass to logging functions
    note that if there is an error, 0 is returned
    which may be safely used (means don't log)

--*/
{
    DWORD retval = 0;
    LPVOID newbuffer;
    int newsize;
    int newitem;
    BOOL locked = FALSE;

    if (LogContext == NULL) {

        //
        // if they pass no LogContext - duh!
        //
        return 0;
    }

    if (((GlobalLogData.Flags & SETUP_LOG_LEVELMASK) <= SETUP_LOG_NOLOG)
        &&((GlobalLogData.Flags & DRIVER_LOG_LEVELMASK) <= DRIVER_LOG_NOLOG)) {
        //
        // no logging, period! Don't waste time in locked code
        //
        return 0;
    }



    try {
        LogLock();
        locked = TRUE;

        if (LogContext->ContextLastUnused < 0) {
            //
            // need to allocate more
            //
            if (LogContext->ContextBufferSize >= SETUP_LOG_CONTEXTMASK) {
                //
                // too many contexts
                //
                leave;
            }
            //
            // need to (re)alloc buffer
            //
            newsize = LogContext->ContextBufferSize+10;

            if (LogContext->ContextInfo) {
                newbuffer = MyTaggedRealloc(LogContext->ContextInfo,sizeof(PTSTR)*(newsize),MEMTAG_LCINFO);
            } else {
                newbuffer = MyTaggedMalloc(sizeof(PTSTR)*(newsize),MEMTAG_LCINFO);
            }
            if (newbuffer == NULL) {
                leave;
            }
            LogContext->ContextInfo = (PTSTR*)newbuffer;

            if (LogContext->ContextIndexes) {
                newbuffer = MyTaggedRealloc(LogContext->ContextIndexes,sizeof(UINT)*(newsize),MEMTAG_LCINDEXES);
            } else {
                newbuffer = MyTaggedMalloc(sizeof(UINT)*(newsize),MEMTAG_LCINDEXES);
            }
            if (newbuffer == NULL) {
                leave;
            }
            LogContext->ContextIndexes = (UINT*)newbuffer;
            LogContext->ContextLastUnused = LogContext->ContextBufferSize;
            LogContext->ContextBufferSize ++;
            while(LogContext->ContextBufferSize < newsize) {
                LogContext->ContextIndexes[LogContext->ContextBufferSize-1] = LogContext->ContextBufferSize;
                LogContext->ContextBufferSize ++;
            }
            LogContext->ContextIndexes[LogContext->ContextBufferSize-1] = -1;
        }

        newitem = LogContext->ContextLastUnused;
        LogContext->ContextLastUnused = LogContext->ContextIndexes[newitem];

        if(AutoRelease) {
            if (LogContext->ContextFirstAuto<0) {
                //
                // first auto-release context item
                //
                LogContext->ContextFirstAuto = newitem;
            } else {
                int lastitem = LogContext->ContextFirstAuto;
                while (LogContext->ContextIndexes[lastitem]>=0) {
                    lastitem = LogContext->ContextIndexes[lastitem];
                }
                LogContext->ContextIndexes[lastitem] = newitem;
            }
        } else {
            if (LogContext->ContextFirstUsed<0) {
                //
                // first context item
                //
                LogContext->ContextFirstUsed = newitem;
            } else {
                int lastitem = LogContext->ContextFirstUsed;
                while (LogContext->ContextIndexes[lastitem]>=0) {
                    lastitem = LogContext->ContextIndexes[lastitem];
                }
                LogContext->ContextIndexes[lastitem] = newitem;
            }
        }
        LogContext->ContextIndexes[newitem] = -1;   // init
        LogContext->ContextInfo[newitem] = NULL;

        retval = (DWORD)(newitem) | SETUP_LOG_IS_CONTEXT;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing special; this just allows us to catch errors
        //
        retval = 0;
    }

    if(locked) {
        LogUnlock();
    }

    //
    // returns a logging flag (SETUP_LOG_IS_CONTEXT | n) or 0
    //
    return retval;
}

VOID
ReleaseLogInfoSlot(
    IN PSETUP_LOG_CONTEXT LogContext,
    DWORD Slot
    )
/*++

Routine Description:

    Releases (non auto-release) slot previously obtained

Arguments:

    LogContext - supplies a pointer to the SETUP_LOG_CONTEXT to use
    Slot - supplies Slot value returned by AllocLogInfoSlot

Return Value:

    none

--*/
{
    int item;
    int lastitem;
    BOOL locked = FALSE;

    if ((Slot & SETUP_LOG_IS_CONTEXT) == 0) {
        //
        // GetLogContextMark had failed, value wasn't set, or not a context log
        //
        return;
    }
    MYASSERT(LogContext != NULL);


    try {
        LogLock();
        locked = TRUE;
        //
        // log context must have been supplied
        //

        item = (int)(Slot & SETUP_LOG_CONTEXTMASK);

        MYASSERT(item >= 0);
        MYASSERT(item < LogContext->ContextBufferSize);
        MYASSERT(LogContext->ContextFirstUsed >= 0);

        //
        // remove item out of linked list
        //

        if (item == LogContext->ContextFirstUsed) {
            //
            // removing first in list
            //
            LogContext->ContextFirstUsed = LogContext->ContextIndexes[item];
        } else {
            lastitem = LogContext->ContextFirstUsed;
            while (lastitem >= 0) {
                if (LogContext->ContextIndexes[lastitem] == item) {
                    LogContext->ContextIndexes[lastitem] = LogContext->ContextIndexes[item];
                    break;
                }
                lastitem = LogContext->ContextIndexes[lastitem];
            }
        }

        //
        // drop a string that hasn't been output
        //

        if (LogContext->ContextInfo[item] != NULL) {
            MyTaggedFree(LogContext->ContextInfo[item],MEMTAG_LCBUFFER);
            LogContext->ContextInfo[item] = NULL;
        }

        //
        // add item into free list
        //

        LogContext->ContextIndexes[item] = LogContext->ContextLastUnused;
        LogContext->ContextLastUnused = item;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing special; this just allows us to catch errors
        //
    }

    if(locked) {
        LogUnlock();
    }

}

VOID
ReleaseLogInfoList(
    IN     PSETUP_LOG_CONTEXT LogContext,
    IN OUT PINT               ListStart
    )
/*++

Routine Description:

    Releases whole list of slots
    Helper function. Caller must have exclusive access to LogContext

Arguments:

    LogContext - supplies a pointer to the SETUP_LOG_CONTEXT to use
    ListStart - pointer to list index

Return Value:

    none

--*/
{
    int item;

    MYASSERT(ListStart);

    try {
        if (*ListStart < 0) {
            //
            // list is empty
            //
            leave;
        }

        //
        // log context must have been supplied
        //

        MYASSERT(LogContext != NULL);

        while (*ListStart >= 0) {
            item = *ListStart;                                  // item we're about to release
            MYASSERT(item < LogContext->ContextBufferSize);
            *ListStart = LogContext->ContextIndexes[item];      // next item on list (we're going to trash this index)

            if (LogContext->ContextInfo[item] != NULL) {
                MyTaggedFree(LogContext->ContextInfo[item],MEMTAG_LCBUFFER);          // release string if still allocated
                LogContext->ContextInfo[item] = NULL;
            }

            //
            // add to free list
            //
            LogContext->ContextIndexes[item] = LogContext->ContextLastUnused;
            LogContext->ContextLastUnused = item;
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing special; this just allows us to catch errors
        //
    }
}

VOID
DeleteLogContext(
    IN PSETUP_LOG_CONTEXT LogContext
    )

/*++

Routine Description:

    Decrement ref count of LogContext, and delete if zero.

Arguments:

    LogContext - supplies a pointer to the SETUP_LOG_CONTEXT to be deleted.

Return Value:

    NONE.

--*/

{
    BOOL locked = FALSE;

    if (!LogContext) {
        return;
    }


    try {
        LogLock();
        locked = TRUE;

        //
        // check ref count
        //
        MYASSERT(LogContext->RefCount > 0);
        if (--LogContext->RefCount) {
            leave;
        }

        //
        // we can unlock now, since we have exclusive access to this context (it is unowned)
        // and we don't want to hold global lock longer than needed
        //
        LogUnlock();
        locked = FALSE;
        ReleaseLogInfoList(LogContext,&LogContext->ContextFirstAuto);
        ReleaseLogInfoList(LogContext,&LogContext->ContextFirstUsed);

        if (LogContext->SectionName) {
            MyTaggedFree(LogContext->SectionName,MEMTAG_LCSECTION);
        }

        if (LogContext->Buffer) {
            MyTaggedFree(LogContext->Buffer,MEMTAG_LCBUFFER);
        }

        if (LogContext->ContextInfo) {
            MyTaggedFree(LogContext->ContextInfo,MEMTAG_LCINFO);
        }

        if (LogContext->ContextIndexes) {
            MyTaggedFree(LogContext->ContextIndexes,MEMTAG_LCINDEXES);
        }

        //
        // now deallocate the struct
        //
        MyTaggedFree(LogContext,MEMTAG_LOGCONTEXT);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // cleanup below
        //
    }
    //
    // if we have not yet released global lock, release it now
    //
    if(locked) {
        LogUnlock();
    }

    return;
}

DWORD
RefLogContext(  // increment reference count
    IN PSETUP_LOG_CONTEXT LogContext
    )

/*++

Routine Description:

    Increment the reference count on a SETUP_LOG_CONTEXT object.


Arguments:

    LogContext - supplies a pointer to a valid SETUP_LOG_CONTEXT object. If
        NULL, this is a NOP.

Return Value:

    DWORD containing old reference count.

--*/

{
    DWORD ref = 0;
    BOOL locked = FALSE;

    if (LogContext == NULL) {
        return 0;
    }


    try {
        LogLock();
        locked = TRUE;

        ref = LogContext->RefCount++;
        MYASSERT(LogContext->RefCount);

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }

    if(locked) {
        LogUnlock();
    }

    return ref;
}

VOID
SendLogString(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR Buffer
    )

/*++

Routine Description:

    Send a string to the logfile and/or debugger based on settings.

    It's expected that LogLock has been called prior to calling this function
    LogLock causes per-process thread synchronisation

Arguments:

    LogContext - supplies a pointer to a valid SETUP_LOG_CONTEXT object.

    Buffer - supplies the buffer to be sent to the logfile/debugger.

Return Value:

    NONE.

--*/

{
    int len;

    try {
        MYASSERT(LogContext);
        MYASSERT(Buffer);

        if (Buffer[0] == 0) {
            //
            // useless call
            //
            leave;
        }

        if (GlobalLogData.FileName) {
            WriteLogSectionEntry(
                GlobalLogData.FileName,
                LogContext->SectionName,
                Buffer,
                (GlobalLogData.Flags & SETUP_LOG_SIMPLE) ? TRUE : FALSE);
        }

        //
        // do debugger output here
        //
        if (GlobalLogData.Flags & SETUP_LOG_DEBUGOUT) {
            DebugPrintEx(DPFLTR_ERROR_LEVEL,
                TEXT("SetupAPI: %s: %s"),
                LogContext->SectionName,
                Buffer);
            len = lstrlen(Buffer);
            if (Buffer[len-1] != TEXT('\n')) {
                DebugPrintEx(DPFLTR_ERROR_LEVEL, TEXT("\r\n"));
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }
}

DWORD
pSetupWriteLogEntry(
    IN PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    IN DWORD Level,
    IN DWORD MessageId,
    IN PCTSTR MessageStr,               OPTIONAL
    ...                                 OPTIONAL
    )

/*++

Routine Description:

    Write a log entry to a file or debugger. If MessageId is 0 and MessageStr
    is NULL, the LogContext's buffer will be flushed.

Arguments:

    LogContext - optionally supplies a pointer to the SETUP_LOG_CONTEXT to be
        used for logging. If not supplied, a temporary one is created just for
        a single use.

    Level - bitmask indicating logging flags. See SETUP_LOG_* and DRIVER_LOG_*
        at the beginning of cntxtlog.h for details. It may also be a slot
        returned by AllocLogInfoSlot, or 0 (no logging)

    MessageId - ID of string from string table. Ignored if MessageStr is
        supplied. The string may contain formatting codes for FormatMessage.

    MessageStr - optionally supplies string to be formatted with FormatMessage.
        If not supplied, MessageId is used instead.

    ... - supply optional parameters based on string to be formatted.

Return Value:

    Win32 error code.

--*/

{
    PSETUP_LOG_CONTEXT lc = NULL;
    DWORD retval = NO_ERROR;
    DWORD error;
    DWORD flags;
    DWORD context = 0;
    DWORD logmask;
    DWORD count;
    LPVOID source = NULL;
    PTSTR buffer = NULL;
    PTSTR locbuffer = NULL;
    PTSTR buffer2 = NULL;
    va_list arglist;
    BOOL logit = FALSE;
    BOOL timestamp = FALSE;
    BOOL endsync = FALSE;
    SYSTEMTIME now;
    TCHAR scratch[1024];
    int logindex;
    int thisindex;
    int numeric=0;

    try {
        //
        // return immediately if we know we'll never log
        //
        if (_WouldNeverLog(Level)) {
            retval = NO_ERROR;
            leave;
        }

        if ((Level & SETUP_LOG_IS_CONTEXT)!=0) {
            //
            // write to context slot
            //
            if(Level & ~SETUP_LOG_VALIDCONTEXTBITS) {
                MYASSERT((Level & ~SETUP_LOG_VALIDCONTEXTBITS)==0);
                retval = ERROR_INVALID_PARAMETER;
                leave;
            }
            if ((GlobalLogData.Flags & SETUP_LOG_ALL_CONTEXT)!=0) {
                //
                // don't treat as context - log it anyway
                //
                Level = 0;
                logit = TRUE;
            } else if (LogContext) {
                //
                // determine which slot
                //
                context = Level & SETUP_LOG_CONTEXTMASK;
                Level = SETUP_LOG_IS_CONTEXT;   // effective log level, we've stripped out log context
                logit = TRUE;
            } else {
                //
                // can't write something to slot if there's no LogContext
                //
                leave;
            }
        }

        if(!logit) {
            //
            // we're still not sure if we'll end up logging this, let's see if we should log this based on level rules
            //
            logit = _WouldLog(Level);
            if (!logit) {
                leave;
            }
        }

        if (LogContext == NULL) {
            //
            // if they pass no LogContext and they want buffering, this call's a nop
            //
            if (Level & SETUP_LOG_BUFFER) {
                retval = NO_ERROR;
                leave;
            }

            //
            // now make a temporary context
            //
            error = CreateLogContext(NULL, TRUE, &lc);
            if (error != NO_ERROR) {
                lc = NULL;
                retval = error;
                leave;
            }

            LogContext = lc;
        }

        //
        // after this point, we know we're going to log something, and we know we have a LogContext
        // note that going down this path is a perf hit.
        // anything we can do in reducing number of times we go down here for "context" information is good
        //
        // hold the lock through to cleanup. It is needed for ReleaseLogInfoList,
        // LogContext modifications and will reduce conflicts when actually writing to the log file
        //
        LogLock();
        endsync = TRUE; // indicate we need to release later

        timestamp = (GlobalLogData.Flags & SETUP_LOG_TIMESTAMP)
                    || ((Level & DRIVER_LOG_LEVELMASK) >= DRIVER_LOG_TIME)
                    || ((Level & SETUP_LOG_LEVELMASK) >= SETUP_LOG_TIME)
                    || (((Level & SETUP_LOG_LEVELMASK) > 0) && (SETUP_LOG_TIMEALL <= (GlobalLogData.Flags & SETUP_LOG_LEVELMASK)))
                    || (((Level & DRIVER_LOG_LEVELMASK) > 0) && (DRIVER_LOG_TIMEALL <= (GlobalLogData.Flags & DRIVER_LOG_LEVELMASK)));

        if ((Level & SETUP_LOG_IS_CONTEXT) == FALSE) {
            //
            // only do this if we're about to do REAL logging
            //
            // if this is the first log output in the section, we will give the
            // command line and module to help the user see what's going on
            //
            if (LogContext->LoggedEntries==0) {
                //
                // recursively call ourselves to log what the command line is
                // note that some apps (eg rundll32) will go and trash command line
                // if this is the case, try and do the right thing
                // we're willing to spend a little extra time in this case, since we know we're going to
                // log something to the section, and we'll only do this once per section
                //
                PTSTR CmdLine = GetCommandLine();

                LogContext->LoggedEntries++; // stop calling this code when we do the pSetupWriteLogEntry's below

                if (CmdLine[0] == TEXT('\"')) {
                    CmdLine++;
                }
                if(_tcsnicmp(ProcessFileName,CmdLine,_tcslen(ProcessFileName))==0) {
                    //
                    // commandline is prefixed with process file name
                    // chance is it's good
                    //
                    pSetupWriteLogEntry(
                        LogContext,
                        AllocLogInfoSlot(LogContext,TRUE),  // delayed slot
                        MSG_LOG_COMMAND_LINE,
                        NULL,
                        GetCommandLine());
                } else {
                    //
                    // it appears that the command line has been modified somewhat
                    // so show what we have
                    //
                    pSetupWriteLogEntry(
                        LogContext,
                        AllocLogInfoSlot(LogContext,TRUE),  // delayed slot
                        MSG_LOG_BAD_COMMAND_LINE,
                        NULL,
                        ProcessFileName,
                        GetCommandLine());

#ifdef UNICODE
                    {
                        //
                        // UNICODE only
                        //
                        // now see if we can get something more useful by looking at the ANSI command line buffer
                        //
                        PSTR AnsiProcessFileName = pSetupUnicodeToMultiByte(ProcessFileName,CP_ACP);
                        PSTR AnsiCmdLine = GetCommandLineA();
                        if (AnsiCmdLine[0] == '\"') {
                            AnsiCmdLine++;
                        }
                        if(AnsiProcessFileName && _mbsnicmp(AnsiProcessFileName,AnsiCmdLine,_mbslen(AnsiProcessFileName))==0) {
                            //
                            // well, the Ansi version appears ok, let's use that
                            //
                            pSetupWriteLogEntry(
                                LogContext,
                                AllocLogInfoSlot(LogContext,TRUE),  // delayed slot
                                MSG_LOG_COMMAND_LINE_ANSI,
                                NULL,
                                GetCommandLineA());
                        } else {
                            //
                            // appears that both Unicode and Ansi might be bad
                            //
                            AnsiCmdLine = pSetupUnicodeToMultiByte(GetCommandLine(),CP_ACP);
                            if (AnsiCmdLine && _mbsicmp(AnsiCmdLine,GetCommandLineA())!=0) {
                                //
                                // also log ansi as reference, since it's different
                                //
                                pSetupWriteLogEntry(
                                    LogContext,
                                    AllocLogInfoSlot(LogContext,TRUE),  // delayed slot
                                    MSG_LOG_BAD_COMMAND_LINE_ANSI,
                                    NULL,
                                    GetCommandLineA());
                            }
                            if (AnsiCmdLine) {
                                MyFree(AnsiCmdLine);
                            }
                        }
                        if (AnsiProcessFileName) {
                            MyFree(AnsiProcessFileName);
                        }
                    }
#endif // UNICODE
                }
#ifdef UNICODE
#ifndef _WIN64
                //
                // we're running 32-bit setupapi
                //
                if (IsWow64) {
                    //
                    // we're running it under WOW64
                    //
                    pSetupWriteLogEntry(
                        LogContext,
                        AllocLogInfoSlot(LogContext,TRUE),  // delayed slot
                        MSG_LOG_WOW64,
                        NULL,
                        GetCommandLine());
                }
#endif
#endif // UNICODE
            }
        }

        flags = FORMAT_MESSAGE_ALLOCATE_BUFFER;

        //
        // if MessageStr is supplied, we use that; otherwise use a
        // string from a string table
        //
        if (MessageStr) {
            flags |= FORMAT_MESSAGE_FROM_STRING;
            source = (PTSTR) MessageStr;    // cast away const
        } else if (MessageId) {
            //
            // the message ID may be an HRESULT error code
            //
            if (MessageId & 0xC0000000) {
                flags |= FORMAT_MESSAGE_FROM_SYSTEM;
                //
                // Some system messages contain inserts, but whomever is calling
                // will not supply them, so this flag prevents us from
                // tripping over those cases.
                //
                flags |= FORMAT_MESSAGE_IGNORE_INSERTS;
            } else {
                flags |= FORMAT_MESSAGE_FROM_HMODULE;
                source = MyDllModuleHandle;
                numeric = (int)(MessageId-MSG_LOG_FIRST);
            }
        }

        if (MessageStr || MessageId) {
            va_start(arglist, MessageStr);
            count = FormatMessage(
                        flags,
                        source,
                        MessageId,
                        0,              // LANGID
                        (LPTSTR) &locbuffer,
                        0,              // minimum size of buffer
                        &arglist);

        } else {
            //
            // There is no string to format, so we are probably just
            // flushing the buffer.
            //
            count = 1;
        }

        if (count > 0) {
            //
            // no error; prefix string with a code and place into a MyMalloc allocated buffer
            // we don't want to prefix string with a code if we're appending to an existing message
            //
            if (locbuffer) {
                if ((numeric > 0) && (LogContext->Buffer==NULL)) {
                    //
                    // determine level code, which indicates severity for why we logged this
                    // and machine readable ID
                    //
                    if (Level & SETUP_LOG_IS_CONTEXT) {
                        //
                        // if this is context information, use #-xxxx
                        //
                        _stprintf(scratch,TEXT("#-%03d "),numeric);
                    } else {
                        logindex = LOGLEVELSHORT_INIT; // maps to 0. after >>4&0x0f.

                        if ((Level & SETUP_LOG_LEVELMASK) > 0 && (Level & SETUP_LOG_LEVELMASK) <= (GlobalLogData.Flags & SETUP_LOG_LEVELMASK)) {
                            thisindex = (Level & SETUP_LOG_LEVELMASK) >> SETUP_LOG_SHIFT;
                            if (thisindex < logindex) {
                                logindex = thisindex;
                            }
                        }
                        if ((Level & DRIVER_LOG_LEVELMASK) > 0 && (Level & DRIVER_LOG_LEVELMASK) <= (GlobalLogData.Flags & DRIVER_LOG_LEVELMASK)) {
                            thisindex = (Level & DRIVER_LOG_LEVELMASK) >> DRIVER_LOG_SHIFT;
                            if (thisindex < logindex) {
                                logindex = thisindex;
                            }
                        }
                        //
                        // #Cxxxx #Vxxxx etc
                        //
                        _stprintf(scratch,TEXT("#%c%03d "),LogLevelShort[(logindex>>LOGLEVELSHORT_SHIFT)&LOGLEVELSHORT_MASK],numeric);
                    }
                } else {
                    scratch[0] = TEXT('\0');
                }
                buffer = (PTSTR)MyTaggedMalloc((lstrlen(scratch)+lstrlen(locbuffer)+1)*sizeof(TCHAR),MEMTAG_LCBUFFER);
                if (buffer) {
                    lstrcpy(buffer,scratch);
                    lstrcat(buffer,locbuffer);
                }
                LocalFree(locbuffer);
            } else {
                buffer = NULL;
            }

            //
            // Check to see if the buffer has anything in it. If so, the newest
            // string needs to be appended to it.
            //
            if (LogContext->Buffer) {
                //
                // in case of a flush, buffer == NULL
                //
                if (buffer!=NULL) {
                    int blen = lstrlen(LogContext->Buffer);
                    int pad = 0;
                    TCHAR lastchr = *CharPrev(LogContext->Buffer,LogContext->Buffer+blen);

                    if (lastchr != TEXT(' ')) {
                        //
                        // silently correct any errors in the message text (which should end in a space)
                        //
                        while((lastchr == TEXT('\t')) ||
                              (lastchr == TEXT('\r')) ||
                              (lastchr == TEXT('\n'))) {
                            blen--; // these characters are always sizeof(TCHAR)
                            lastchr = *CharPrev(LogContext->Buffer,LogContext->Buffer+blen);
                        }
                        LogContext->Buffer[blen] = TEXT('\0');
                        if (lastchr != TEXT(' ')) {
                            //
                            // we want to insert a space padding
                            //
                            pad++;
                        }
                    }
                    buffer2 = MyTaggedRealloc(LogContext->Buffer,
                                              (blen + pad + lstrlen(buffer) + 1) * sizeof(TCHAR),
                                              MEMTAG_LCBUFFER
                                              );

                    //
                    // if the realloc was successful, add the new data, otherwise
                    // just drop it on the floor
                    //
                    if (buffer2) {
                        if (pad) {
                            lstrcat(buffer2,TEXT(" "));
                        }
                        lstrcat(buffer2, buffer);
                        LogContext->Buffer = buffer2;
                        buffer2 = NULL;
                    }

                    MyTaggedFree(buffer,MEMTAG_LCBUFFER);
                    buffer = NULL;
                }
                buffer = LogContext->Buffer;
                LogContext->Buffer = NULL;
            }

            if (Level & SETUP_LOG_BUFFER) {

                LogContext->Buffer = buffer;
                buffer = NULL;

            } else if (Level & SETUP_LOG_IS_CONTEXT) {

                PTSTR TempDupeString;

                //
                // replace the string indicated
                //

                if(buffer) {
                    if (LogContext->ContextInfo[context]) {
                        MyTaggedFree(LogContext->ContextInfo[context],MEMTAG_LCBUFFER);
                    }
                    LogContext->ContextInfo[context] = buffer;
                    buffer = NULL;
                }

            } else {
                int item;
                //
                // actually do some logging
                //
                LogContext->LoggedEntries++;

                if (!LogContext->SectionName) {
                     error = MakeUniqueName(NULL,&(LogContext->SectionName));
                }

                //
                // first dump the auto-release context info
                //
                item = LogContext->ContextFirstAuto;

                while (item >= 0) {
                    if (LogContext->ContextInfo[item]) {
                        //
                        // dump this string
                        //
                        SendLogString(LogContext, LogContext->ContextInfo[item]);
                        MyTaggedFree (LogContext->ContextInfo[item],MEMTAG_LCBUFFER);
                        LogContext->ContextInfo[item] = NULL;
                    }
                    item = LogContext->ContextIndexes[item];
                }

                ReleaseLogInfoList(LogContext,&LogContext->ContextFirstAuto);

                //
                // now dump any strings set in currently allocated slots
                //
                item = LogContext->ContextFirstUsed;

                while (item >= 0) {
                    if (LogContext->ContextInfo[item]) {
                        //
                        // dump this string
                        //
                        SendLogString(LogContext, LogContext->ContextInfo[item]);
                        MyTaggedFree (LogContext->ContextInfo[item],MEMTAG_LCBUFFER);
                        LogContext->ContextInfo[item] = NULL;
                    }
                    item = LogContext->ContextIndexes[item];
                }

                //
                // we have built up a line to send
                //
                if (buffer != NULL) {
                    if(timestamp) {
                        //
                        // this is the point we're interested in prefixing with timestamp
                        // this allows us to build up a string, then emit it prefixed with stamp
                        //
                        GetLocalTime(&now);

                        _stprintf(scratch, TEXT("@ %02d:%02d:%02d.%03d "),
                            now.wHour, now.wMinute, now.wSecond, now.wMilliseconds);

                        buffer2 = MyTaggedMalloc((lstrlen(scratch)+lstrlen(buffer)+1)*sizeof(TCHAR),MEMTAG_LCBUFFER);
                        if (buffer2) {
                            lstrcpy(buffer2,scratch);
                            lstrcat(buffer2,buffer);
                            MyTaggedFree(buffer,MEMTAG_LCBUFFER);
                            buffer = buffer2;
                            buffer2 = NULL;
                        }
                    }

                    SendLogString(LogContext,buffer);
                }
            }

        } else {
            //
            // the FormatMessage failed
            //
            retval = GetLastError();
            if(retval == NO_ERROR) {
                retval = ERROR_INVALID_DATA;
            }
        }

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing special; this just allows us to catch errors
        //
        retval = ERROR_INVALID_DATA;
    }

    //
    // cleanup
    //
    if (endsync) {
        LogUnlock();
    }

    if (buffer) {
        MyTaggedFree(buffer,MEMTAG_LCBUFFER);
    }
    if (lc) {
        DeleteLogContext(lc);
    }
    return retval;
}

VOID
SetLogSectionName(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR SectionName
    )

/*++

Routine Description:

    Sets the section name for the log context if it hasn't been used.

Arguments:

    LogContext - supplies pointer to SETUP_LOG_CONTEXT.

    SectionName - supplies a pointer to a string to be included in the
        section name.

Return Value:

    NONE.

--*/

{
    DWORD rc;
    PTSTR NewSectionName = NULL;
    BOOL locked = FALSE;

    MYASSERT(LogContext);
    MYASSERT(SectionName);


    try {
        LogLock();
        locked = TRUE;

        //
        // make sure the entry has never been used before
        //
        if (LogContext->LoggedEntries==0 || LogContext->SectionName==NULL) {
            //
            // get rid of any previous name
            //

            rc = MakeUniqueName(SectionName,&NewSectionName);
            if (rc == NO_ERROR) {
                if (LogContext->SectionName) {
                    MyTaggedFree(LogContext->SectionName,MEMTAG_LCSECTION);
                }
                LogContext->SectionName = NewSectionName;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
    }

    if(locked) {
        LogUnlock();
    }
}

#if MEM_DBG
#undef InheritLogContext            // defined again below
#endif

DWORD
InheritLogContext(
    IN TRACK_ARG_DECLARE TRACK_ARG_COMMA
    IN PSETUP_LOG_CONTEXT Source,
    OUT PSETUP_LOG_CONTEXT *Dest
    )

/*++

Routine Description:

    Copies a log context from one structure to another, deleting the one that
    gets overwritten. If Source and Dest are both NULL, a new log context is
    created for Dest.

Arguments:

    Source - supplies pointer to source SETUP_LOG_CONTEXT. If NULL, this
        creates a new log context for Dest.

    Dest - supplies the location to receive a pointer to the log context.

Return Value:

    NONE.

--*/

{
    DWORD status = ERROR_INVALID_DATA;
    DWORD rc;
    PSETUP_LOG_CONTEXT Old = NULL;

    TRACK_PUSH

    try {
        MYASSERT(Dest);
        Old = *Dest;
        if (Old == NULL && Source == NULL) {
            //
            // this is a roundabout way of saying we want to create a context
            // used when the source logcontext is optional
            //
            rc = CreateLogContext(NULL, TRUE, Dest);
            if (rc != NO_ERROR) {
                status = rc;
                leave;
            }
        } else if (Source != NULL && (Old == NULL || Old->LoggedEntries == 0)) {
            //
            // We can replace Dest, since it hasn't been used yet
            //
            *Dest = Source;
            RefLogContext(Source);
            if (Old != NULL) {
                //
                // now delete old
                //
                DeleteLogContext(Old);
            }
        }

        status = NO_ERROR;

    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }

    TRACK_POP

    return status;
}

#if MEM_DBG
#define InheritLogContext(a,b)          InheritLogContext(TRACK_ARG_CALL,a,b)
#endif

DWORD
ShareLogContext(
    IN OUT PSETUP_LOG_CONTEXT *Primary,
    IN OUT PSETUP_LOG_CONTEXT *Secondary
    )
/*++

Routine Description:

    Bidirectional inherit

Arguments:

    Primary - preferred source

    Secondary - preferred target

Return Value:

    any potential error

--*/
{
    DWORD rc = ERROR_INVALID_DATA;

    try {
        MYASSERT(Primary);
        MYASSERT(*Primary);
        MYASSERT(Secondary);
        MYASSERT(*Secondary);

        if((*Secondary)->LoggedEntries) {
            //
            // secondary has already been used, so see if we can update primary
            //
            rc = InheritLogContext(*Secondary,Primary);
        } else {
            //
            // else behave exactly like InheritLogContext
            //
            rc = InheritLogContext(*Primary,Secondary);
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        //
        // do nothing; this just allows us to catch errors
        //
    }
    return rc;
}

VOID
pSetupWriteLogError(
    IN PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    IN DWORD Level,
    IN DWORD Error
    )

/*++

Routine Description:

    Logs an error code and an error message on the same line.

Arguments:

    LogContext - supplies a pointer to a valid SETUP_LOG_CONTEXT object. If
        NULL, this is a NOP.

    Level - supplies a log level as defined by pSetupWriteLogEntry.

    Error - supplies the Win32 error, HRESULT, or SETUPAPI error code to log.

Return Value:

    NONE.

--*/

{
    DWORD err;

    if (!LogContext) {
        //
        // error is meaningless without context
        //
        goto final;
    }

    if (Error == NO_ERROR) {
        pSetupWriteLogEntry(
            LogContext,
            Level,
            MSG_LOG_NO_ERROR,
            NULL);
        goto final;
    }

    pSetupWriteLogEntry(
        LogContext,
        Level | SETUP_LOG_BUFFER,
        //
        // print HRESULTs in hex, Win32 errors in decimal
        //
        (Error & 0xC0000000 ? MSG_LOG_HRESULT_ERROR
                            : MSG_LOG_WIN32_ERROR),
        NULL,
        Error);

    //
    // If it's a Win32 error, we convert it to an HRESULT, because
    // pSetupWriteLogEntry only knows that it's an error code by the fact
    // that it's an HRESULT.  However, we don't want the user to
    // get an HRESULT if we can help it, so just do the conversion
    // after converting to a string. Also, SETUPAPI errors are not
    // in proper HRESULT format without conversion
    //
    Error = HRESULT_FROM_SETUPAPI(Error);

    //
    // writing the error message may fail...
    //
    err = pSetupWriteLogEntry(
        LogContext,
        Level,
        Error,
        NULL);

    if (err != NO_ERROR) {
        pSetupWriteLogEntry(
            LogContext,
            Level,
            MSG_LOG_UNKNOWN_ERROR,
            NULL);
    }

final:
    SetLastError(Error);
}

BOOL
ContextLoggingTlsInit(
    IN BOOL Init
    )
/*++

Routine Description:

    Init = TRUE Initializes per-thread data for logging
    Init = FALSE releases memory on cleanup

Arguments:

    Init - set to initialize

Return Value:

    TRUE if initialized ok.

--*/
{
    BOOL b = FALSE;
    PSETUP_TLS pTLS;
    PSETUP_LOG_TLS pLogTLS;

    pTLS = SetupGetTlsData();
    MYASSERT(pTLS);
    pLogTLS = &pTLS->SetupLog;

    if (Init) {
        pLogTLS->ThreadLogContext = NULL;
        b = TRUE;
    } else {
        //
        // ISSUE-JamieHun-2001/05/01 ASSERT when thread terminated
        // thread might not have terminated cleanly
        // causing this assert to fire
        //
        // MYASSERT(!pLogTLS->ThreadLogContext);
        b = TRUE;
    }
    return b;
}

BOOL
SetThreadLogContext(
    IN PSETUP_LOG_CONTEXT LogContext,
    OUT PSETUP_LOG_CONTEXT *PrevContext  OPTIONAL
    )
/*++

Routine Description:

    Modify current thread log context

Arguments:

    LogContext new log context (expected to be apropriately ref counted)
    PrevContext if set, filled with previous context

Return Value:

    TRUE if set ok.

--*/
{
    PSETUP_TLS pTLS;
    PSETUP_LOG_TLS pLogTLS;
    PSETUP_LOG_CONTEXT Top;

    pTLS = SetupGetTlsData();
    if(!pTLS) {
        return FALSE;
    }
    pLogTLS = &pTLS->SetupLog;

    if (PrevContext) {
        *PrevContext = pLogTLS->ThreadLogContext;
    }
    pLogTLS->ThreadLogContext = LogContext;
    return TRUE;
}

PSETUP_LOG_CONTEXT
GetThreadLogContext(
    )
/*++

Routine Description:

    Return thread's default log context

Arguments:

    NONE

Return Value:

    Current LogContext or NULL

--*/
{
    PSETUP_TLS pTLS;

    pTLS = SetupGetTlsData();
    if(!pTLS) {
        return NULL;
    }
    return pTLS->SetupLog.ThreadLogContext;
}

BOOL
InitializeContextLogging(
    IN BOOL Attach
    )
/*++

Routine Description:

    Initializes structures/data for logging or releases allocated memory.

Arguments:

    Attach - set when called at attach time as opposed to detach time

Return Value:

    TRUE if initialized ok.

--*/
{
    BOOL Successful = FALSE;

    if (Attach) {

        LONG error;
        HKEY key;
        HKEY loglevel;
        DWORD len;
        DWORD level = 0;
        DWORD type;
        PTSTR PathName = NULL;
        TCHAR testchar;
        BOOL isdir = FALSE;

        GlobalLogData.FileName = NULL;
        GlobalLogData.Flags = 0;
        GlobalLogData.UID = 0;
        GlobalLogData.DoneInitCritSec = FALSE;

        try {
            InitializeCriticalSection(&GlobalLogData.CritSec);
            GlobalLogData.DoneInitCritSec = TRUE;
            error = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                REGSTR_PATH_SETUP REGSTR_KEY_SETUP,
                0,                  // reserved
                KEY_QUERY_VALUE,
                &key);

            if (error == ERROR_SUCCESS) {

                if(QueryRegistryDwordValue(key,SP_REGKEY_LOGLEVEL,&level) != NO_ERROR) {
                    level = 0;
                }

                if(QueryRegistryValue(key,SP_REGKEY_LOGPATH,&PathName,&type,&len) != NO_ERROR) {
                    PathName = NULL;
                }

                //
                // Allow a user to override the log level for a particular program
                //

                error = RegOpenKeyEx(
                    key,
                    SP_REGKEY_APPLOGLEVEL,
                    0,                  // reserved
                    KEY_QUERY_VALUE,
                    &loglevel);

                if (error == ERROR_SUCCESS) {

                    DWORD override;
                    if(QueryRegistryDwordValue(loglevel,pSetupGetFileTitle(ProcessFileName),&override) == NO_ERROR) {
                        level = override;
                    }

                    RegCloseKey(loglevel);
                }

                RegCloseKey(key);
            }

            //
            // if they don't supply a valid name, we use the Windows dir
            //
            if (!(PathName && PathName[0])) {
                if(PathName) {
                    MyFree(PathName);
                }
                PathName = DuplicateString(WindowsDirectory);
                if(!PathName) {
                    leave;
                }
                isdir = TRUE; // we know this should be a directory
            } else {
                //
                // see if we're pointing at a directory
                //
                testchar = CharPrev(PathName,PathName+lstrlen(PathName))[0];
                if(testchar == TEXT('\\') || testchar == TEXT('/')) {
                    //
                    // explicit directiory
                    //
                    isdir = TRUE;
                } else {
                    DWORD attr = GetFileAttributes(PathName);
                    if (isdir || (attr != (DWORD)(-1) && (attr & FILE_ATTRIBUTE_DIRECTORY) != 0 )) {
                        //
                        // implicit directory
                        //
                        isdir = TRUE;
                    }
                }
            }

            if (isdir) {
                //
                // if they gave a directory, add a filename
                //
                LPTSTR NewPath;
                if(!pSetupAppendPath(PathName,SP_LOG_FILENAME,&NewPath)) {
                    MyFree(PathName);
                    PathName = NULL;
                    leave;
                }
                MyFree(PathName);
                PathName = NewPath;
            }
            pSetupMakeSurePathExists(PathName);

            //
            // validate level flags
            //
            level &= SETUP_LOG_VALIDREGBITS;
            //
            // handle defaults
            //
            if((level & SETUP_LOG_LEVELMASK) == 0) {
                //
                // level not explicitly set
                //
                level |= SETUP_LOG_DEFAULT;
            }

            if((level & DRIVER_LOG_LEVELMASK) == 0) {
                //
                // level not explicitly set
                //
                level |= DRIVER_LOG_DEFAULT;
            }
            GlobalLogData.Flags = level;

            GlobalLogData.FileName = PathName;
            PathName = NULL;
            if (GlobalLogData.FileName == NULL) {
                leave;
            }

            Successful = TRUE;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            //
            // Successful remains FALSE
            //
        }


    } else {

        if (GlobalLogData.FileName) {
            MyFree(GlobalLogData.FileName);
            GlobalLogData.FileName = NULL;
        }
        if(GlobalLogData.DoneInitCritSec) {
            DeleteCriticalSection(&GlobalLogData.CritSec);
        }
        Successful = TRUE;
    }

    return Successful;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\backup.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    backup.h

Abstract:

    Private header for....
    Routines to control backup during install process
    And restore of an old install process
    (See also backup.c)

Author:

    Jamie Hunter (jamiehun) 13-Jan-1997

Revision History:

--*/

typedef struct _SP_TARGET_ENT {
    //
    // Used for backup and unwind-backup
    // Data of TargetLookupTable of a file Queue
    //

    // this file information (strings in StringTable)
    LONG        TargetRoot;
    LONG        TargetSubDir;
    LONG        TargetFilename;

    // where file is, or is-to-be backed up (strings in StringTable)
    LONG        BackupRoot;
    LONG        BackupSubDir;
    LONG        BackupFilename;

    // if file has been renamed, what the new target is (string in TargetLookupTable)
    LONG        NewTargetFilename;

    // Various flags as needed
    DWORD       InternalFlags;

    // security attributes etc
    // (jamiehun TODO)

} SP_TARGET_ENT, *PSP_TARGET_ENT;

typedef struct _SP_UNWIND_NODE {
    //
    // List of things to unwind, FILO
    //
    struct _SP_UNWIND_NODE *NextNode;

    LONG TargetID;                          // TargetID to use for UNWIND
    PSECURITY_DESCRIPTOR SecurityDesc;      // Security descriptor to apply
    FILETIME CreateTime;                    // Time stamps to apply
    FILETIME AccessTime;
    FILETIME WriteTime;

} SP_UNWIND_NODE, *PSP_UNWIND_NODE;

typedef struct _SP_DELAYMOVE_NODE {
    //
    // List of things to rename, FIFO
    //
    struct _SP_DELAYMOVE_NODE *NextNode;

    LONG SourceFilename;                    // What to rename
    LONG TargetFilename;                    // what to rename to
    DWORD SecurityDesc;                     // security descriptor index in the string table
    BOOL TargetIsProtected;                 // target file is a protected system file

} SP_DELAYMOVE_NODE, *PSP_DELAYMOVE_NODE;

#define SP_BKFLG_LATEBACKUP      (1)        // backup only if file is modified in any way
#define SP_BKFLG_PREBACKUP       (2)        // backup uninstall files first
#define SP_BKFLG_CALLBACK        (4)        // flag, indicating app should be callback aware

#define SP_TEFLG_SAVED          (0x00000001)    // set if file already copied/moved to backup
#define SP_TEFLG_TEMPNAME       (0x00000002)    // set if backup is temporary file
#define SP_TEFLG_ORIGNAME       (0x00000004)    // set if backup specifies an original name
#define SP_TEFLG_MODIFIED       (0x00000008)    // set if target has been modified/deleted (backup has original)
#define SP_TEFLG_MOVED          (0x00000010)    // set if target has been moved (to NewTargetFilename)
#define SP_TEFLG_BACKUPQUEUE    (0x00000020)    // set if backup queued in backup sub-queue
#define SP_TEFLG_RESTORED       (0x00000040)    // set if file already restored during unwind operation
#define SP_TEFLG_UNWIND         (0x00000080)    // set if file added to unwind list
#define SP_TEFLG_SKIPPED        (0x00000100)    // we didn't manage to back it up, we cannot back it up, we should not try again
#define SP_TEFLG_INUSE          (0x00000200)    // while backing up, we determined we cannot backup file because it cannot be read
#define SP_TEFLG_RENAMEEXISTING (0x00000400)    // rename existing file to temp filename in same directory.
#define SP_TEFLG_PRUNE_COPY     (0x00010000)    // set during file pruning, detected this file is on copy queue
#define SP_TEFLG_PRUNE_DEL      (0x00020000)    // set during file pruning, detected this file is on delete queue
#define SP_TEFLG_PRUNE_RENSRC   (0x00040000)    // set during file pruning, detected this file is on rename queue
#define SP_TEFLG_PRUNE_RENTARG  (0x00080000)    // file RENSRC is renamed to RENTARG

#define SP_BACKUP_DRIVERFILES   TEXT("DriverFiles")
#define SP_BACKUP_OLDFILES      TEXT("Temp") // relative to the windows directory
#define SP_LASTGOOD_NAME        TEXT("LastGood")

//
// these are private routines
//


DWORD
pSetupQueueBackupCopy(
    IN HSPFILEQ QueueHandle,
    IN LONG   TargetRootPath,
    IN LONG   TargetSubDir,       OPTIONAL
    IN LONG   TargetFilename,
    IN LONG   BackupRootPath,
    IN LONG   BackupSubDir,       OPTIONAL
    IN LONG   BackupFilename
    );

BOOL
pSetupGetFullBackupPath(
    OUT     PTSTR       FullPath,
    IN      PCTSTR      Path,
    IN      UINT        TargetBufferSize,
    OUT     PUINT       RequiredSize    OPTIONAL
    );

DWORD
pSetupBackupCopyString(
    IN PVOID            DestStringTable,
    OUT PLONG           DestStringID,
    IN PVOID            SrcStringTable,
    IN LONG             SrcStringID
    );

DWORD
pSetupBackupGetTargetByPath(
    IN HSPFILEQ         QueueHandle,
    IN PVOID            PathStringTable,    OPTIONAL
    IN PCTSTR           TargetPath,         OPTIONAL
    IN LONG             TargetRoot,
    IN LONG             TargetSubDir,       OPTIONAL
    IN LONG             TargetFilename,
    OUT PLONG           TableID,            OPTIONAL
    OUT PSP_TARGET_ENT  TargetInfo
    );

DWORD
pSetupBackupGetTargetByID(
    IN HSPFILEQ         QueueHandle,
    IN LONG             TableID,
    OUT PSP_TARGET_ENT  TargetInfo
    );

DWORD
pSetupBackupSetTargetByID(
    IN HSPFILEQ         QueueHandle,
    IN LONG             TableID,
    IN PSP_TARGET_ENT   TargetInfo
    );

BOOL
pSetupResetTarget(
    IN PVOID  StringTable,
    IN LONG   StringId,
    IN PCTSTR String,        OPTIONAL
    IN PVOID  ExtraData,
    IN UINT   ExtraDataSize,
    IN LPARAM lParam
    );

DWORD
pSetupBackupAppendFiles(
    IN HSPFILEQ         TargetQueueHandle,
    IN PCTSTR           BackupSubDir,
    IN DWORD            BackupFlags,
    IN HSPFILEQ         SourceQueueHandle OPTIONAL
    );

DWORD
pSetupBackupFile(
    IN HSPFILEQ QueueHandle,
    IN PCTSTR TargetPath,
    IN PCTSTR BackupPath,
    IN LONG   TargetID,         OPTIONAL
    IN LONG   TargetRootPath,
    IN LONG   TargetSubDir,
    IN LONG   TargetFilename,
    IN LONG   BackupRootPath,
    IN LONG   BackupSubDir,
    IN LONG   BackupFilename,
    BOOL *DelayedBackup
    );

VOID
pSetupDeleteBackup(
    IN PCTSTR           BackupInstance
    );

DWORD
pSetupGetCurrentlyInstalledDriverNode(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );

DWORD
pSetupGetBackupQueue(
    IN      PCTSTR      DeviceID,
    IN OUT  HSPFILEQ    FileQueue,
    IN      DWORD       BackupFlags
    );

BOOL
PostDelayedMove(
    IN struct _SP_FILE_QUEUE *Queue,
    IN PCTSTR                 CurrentName,
    IN PCTSTR                 NewName,     OPTIONAL
    IN DWORD                  SecurityDesc,
    IN BOOL                   TargetIsProtected
    );

BOOL
UnPostDelayedMove(
    IN struct _SP_FILE_QUEUE *Queue,
    IN PCTSTR                 CurrentName,
    IN PCTSTR                 NewName      OPTIONAL
    );

DWORD
DoAllDelayedMoves(
    IN struct _SP_FILE_QUEUE *Queue
    );

DWORD
pSetupCompleteBackup(
    IN OUT  HSPFILEQ    FileQueue
    );

VOID
pSetupUnwindAll(
    IN struct _SP_FILE_QUEUE *Queue,
    IN BOOL              Succeeded
    );

VOID
pSetupCleanupBackup(
    IN struct _SP_FILE_QUEUE *Queue
    );

VOID
RestoreRenamedOrBackedUpFile(
    IN PCTSTR             TargetFilename,
    IN PCTSTR             CurrentFilename,
    IN BOOL               RenameFile,
    IN PSETUP_LOG_CONTEXT LogContext       OPTIONAL
    );

DWORD
pSetupDoLastKnownGoodBackup(
    IN struct _SP_FILE_QUEUE *Queue,           OPTIONAL
    IN PCTSTR                 TargetFilename,
    IN DWORD                  Flags,
    IN PSETUP_LOG_CONTEXT     LogContext       OPTIONAL
    );

BOOL
pSetupRestoreLastKnownGoodFile(
    IN PCTSTR                 TargetFilename,
    IN DWORD                  Flags,
    IN PSETUP_LOG_CONTEXT     LogContext       OPTIONAL
    );

#define SP_LKG_FLAG_FORCECOPY       0x00000001  // if set, turns copy safety-guards off
#define SP_LKG_FLAG_DELETEIFNEW     0x00000002  // if set, writes a delete entry for new files
#define SP_LKG_FLAG_DELETEEXISTING  0x00000004  // if set, writes a delete entry for existing files
#define SP_LKG_FLAG_DELETEOP        0x00000008  // if set, caller is deleting (or renaming) a file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\childreg.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    childreg.h

Abstract:

    Shared between setupapi.dll and wowreg32.exe

Author:

    Jamie Hunter (jamiehun) May-25-2000

--*/

//
// definition of shared memory region for wow surragate dll registration
//
typedef struct _WOW_IPC_REGION_TOSURRAGATE {
    WCHAR               FullPath[MAX_PATH];
    WCHAR               Argument[MAX_PATH];
    UINT                RegType;
    BOOL                Register; // or unregister
} WOW_IPC_REGION_TOSURRAGATE, *PWOW_IPC_REGION_TOSURRAGATE;

//
// definition of shared memory region for wow surragate dll registration
//
typedef struct _WOW_IPC_REGION_FROMSURRAGATE {
    DWORD               Win32Error;
    DWORD               FailureCode;
} WOW_IPC_REGION_FROMSURRAGATE, *PWOW_IPC_REGION_FROMSURRAGATE;

//
// this should be the max of WOW_IPC_REGION_TOSURRAGATE,WOW_IPC_REGION_FROMSURRAGATE
//
#define WOW_IPC_REGION_SIZE  sizeof(WOW_IPC_REGION_TOSURRAGATE)

#ifdef _WIN64
#define SURRAGATE_PROCESSNAME                   L"%SystemRoot%\\syswow64\\WOWReg32.exe"
#else
#define SURRAGATE_PROCESSNAME                   L"%SystemRoot%\\system32\\WOWReg32.exe"
#endif
#define SURRAGATE_REGIONNAME_SWITCH             L"/RegionName"
#define SURRAGATE_SIGNALREADY_SWITCH            L"/SignalReady"
#define SURRAGATE_SIGNALCOMPLETE_SWITCH         L"/SignalComplete"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\cntxtlog.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    cntxtlog.h

Abstract:

    This module implements more logging for setupapi

Author:

    Gabe Schaffer (t-gabes) 7-Jul-1998

Revision History:

    Jamie Hunter (jamiehun) 26-Aug-1998

--*/

/*
    There are two log levels. One is set in the registry, which determines
    what is logged and how. The other is passed as a parameter, and indicates
    under what conditions the entry should be logged. For example, the registry
    would say that all errors and warnings should be logged, while the call to
    WriteLogEntry would specify in the LogLevel parameter that some string
    should be logged as a warning.

    The 24 least-significant bits specify flags which indicate the type of
    message when passed as a parameter, or the type of messages to logged
    when set in the registry.

    The 4 most-significant bits are flags:

    SETUP_LOG_DEBUGOUT - when specified in the registry, indicates that all
        log output should be sent to the debugger as well as the logfile.
        This flag is currently not supported as a parameter to WriteLogEntry.

    SETUP_LOG_SIMPLE - when specified in the registry, indicates that all
        logfile entries should be appended to the logfile in chronological
        order, rather than grouped by section name. This flag is not
        currently supported as a parameter.

    SETUP_LOG_BUFFER - when specified as a parameter, indicates that the
        message to be logged will be buffered until such time as a call to
        WriteLogEntry with the same LogContext but this flag is not specified.
        When an entry is to be logged without this flag set, the latest
        message will be added to the buffer, and the buffer will be flushed to
        the logfile.

        This allows you to build up a string to log without having to do
        buffer management everywhere.

        This flag does not make sense in the registry.

        NOTE: for proper functioning, do not mix log levels while buffering
        output.

        NOTE: if this flag is NOT specified, the string to be logged MUST
        end in a newline, otherwise bad stuff will happen if another log
        context writes to the logfile immediately afterward.

    SETUP_LOG_IS_CONTEXT - when specified in the registry, indicates that
        all context messages should be immediately logged to the logfile,
        rather than buffered in the LogContext.

        This flag should never appear in a file other than cntxtlog.*;
        that is, as a parameter it only makes sense if added to a multiple
        of SETUP_FIRST_LOG_CONTEXT.

        NOTE: the context buffering mechanism is explained below where
        ContextInfo is defined in SETUP_LOG_CONTEXT.
*/

//
// These registry/filename strings should probably belong elsewhere
//
#define SP_REGKEY_LOGLEVEL      TEXT("LogLevel")
#define SP_REGKEY_LOGPATH       TEXT("LogPath")
#define SP_REGKEY_APPLOGLEVEL   TEXT("AppLogLevels")
#define SP_LOG_FILENAME         TEXT("setupapi.log")


//
// these are for general setup log entries
//
#define SETUP_LOG_SHIFT         (0)
#define SETUP_LOG_LEVELMASK     0x000000FF
#define SETUP_LOG_NOLOG         0x00000001 // indicates no-logging (remember 0 is default)
#define SETUP_LOG_ERROR         0x00000010 // 10-1f is varying levels of errors
#define SETUP_LOG_WARNING       0x00000020 // 20-2f is varying levels of warnings
#define SETUP_LOG_INFO          0x00000030 // 30-3f is varying levels of info
#define SETUP_LOG_VERBOSE       0x00000040 // 40-4f is varying levels of verbose
#define SETUP_LOG_TIME          0x00000050 // 50+ allow logging of time-stamped enties
#define SETUP_LOG_TIMEALL       0x00000060 // 60+ turns on time-stamping of all entries
#define SETUP_LOG_VVERBOSE      0x00000070 // 70-7f is very-verbose - reserved for stuff that logging really slows down
#define SETUP_LOG_DEFAULT       0x00000020

//
// these are for driver-only log entries
//
#define DRIVER_LOG_SHIFT        (8)
#define DRIVER_LOG_LEVELMASK    0x0000FF00
#define DRIVER_LOG_NOLOG        0x00000100 // indicates no-logging (remember 0 is default)
#define DRIVER_LOG_ERROR        0x00001000
#define DRIVER_LOG_WARNING      0x00002000
#define DRIVER_LOG_INFO         0x00003000
#define DRIVER_LOG_INFO1        0x00003100
#define DRIVER_LOG_VERBOSE      0x00004000
#define DRIVER_LOG_VERBOSE1     0x00004100
#define DRIVER_LOG_TIME         0x00005000
#define DRIVER_LOG_TIMEALL      0x00006000
#define DRIVER_LOG_VVERBOSE     0x00007000 // 70-7f is very-verbose - reserved for stuff that logging really slows down
#define DRIVER_LOG_DEFAULT      0x00003000

//
// Calling AllocLogInfoSlot will return an index with SETUP_LOG_IS_CONTEXT set
// this index represents a nested stack entry for logging information
// that will get dumped if an actual log entry is dumped
// thus providing more information
// note that lower 16 bits are used for index, re-using above Log level bits
//
#define SETUP_LOG_IS_CONTEXT    0x10000000
#define SETUP_LOG_CONTEXTMASK   0x0000ffff

//
// pass this flag to WriteLogEntry to have the entry stored in a buffer,
// to be spit out the next time the flag is *not* specified
//
#define SETUP_LOG_BUFFER    0x20000000

//
// pass this flag to registry to have output sent to debugger
//
#define SETUP_LOG_DEBUGOUT  0x80000000
//
// pass this flag to registry to have entries simply appended to the log
//
#define SETUP_LOG_SIMPLE    0x40000000
//
// pass this flag to registry to speed up logging
//
#define SETUP_LOG_NOFLUSH   0x20000000
//
// pass this flag to registry to indicate we want to always log SETUP_LOG_ISCONTEXT
//
#define SETUP_LOG_ALL_CONTEXT 0x10000000
//
// pass this flag to registry to indicate we always want to log timestamp
//
#define SETUP_LOG_TIMESTAMP 0x08000000
//
// for validating registry log value
//
#define SETUP_LOG_VALIDREGBITS (SETUP_LOG_DEBUGOUT|SETUP_LOG_SIMPLE|SETUP_LOG_NOFLUSH|SETUP_LOG_ALL_CONTEXT|SETUP_LOG_TIMESTAMP|DRIVER_LOG_LEVELMASK|SETUP_LOG_LEVELMASK)
//
// for validating non-context log value
//
#define SETUP_LOG_VALIDLOGBITS (SETUP_LOG_DEBUGOUT|SETUP_LOG_BUFFER|DRIVER_LOG_LEVELMASK|SETUP_LOG_LEVELMASK)
//
// for validating context log value
//
#define SETUP_LOG_VALIDCONTEXTBITS (SETUP_LOG_IS_CONTEXT | SETUP_LOG_CONTEXTMASK)


//
// timeouts when waiting for log acquired by another process
//
#define MAX_LOG_INTERVAL        (1000)       // 1s
#define MAX_LOG_WAIT            (10 * MAX_LOG_INTERVAL)


//
// This is the structure that holds all of the data required to persist logging
// information. It is not to be confused with the SETUPLOG_CONTEXT struct that
// is used elsewhere in setup.
//
typedef struct _SETUP_LOG_CONTEXT {
    //
    // Pointer to allocated name of section to be used.
    // If NULL, a section name will be generated on first use.
    //
    PTSTR       SectionName;

    //
    // Multiple structures may simultaneously have pointers to
    // this struct, so a ref count is needed. CreateLogContext()
    // will set this to 1, and DeleteLogContext() will decrement
    // this until it reaches 0 (at which point the structure is
    // actually freed).
    //
    UINT        RefCount;

    //
    // This is the number of entries that have been logged in this
    // context. If timestamp is used for the section name, this will
    // allow us to use the time of the first error, rather than the
    // time the log context was created.
    //
    UINT        LoggedEntries;

    //
    // These fields are for implementation of
    // AllocLogSlot and ReleaseLogSlot functions
    // ContextInfo is a list of strings indexable via SETUP_LOG_CONTEXTMASK
    // bits of a context slot returned by AllocLogSlot (ie, the slot)
    // it is also enumeratable via the link list headed by ContextFirstUsed
    // ContextFirstUsed points to first slot currently in use (bottom of stack)
    // ContextIndexes[ContextFirstUsed] points to next and so on
    // ContextLastUnused points to last slot that was released
    // -1 is used as end of list value
    // An entry may disappear in the middle of the stack if the context is used in
    // more than one thread
    //
    PTSTR       *ContextInfo;       // pointer to array of strings
    int         *ContextIndexes;    // by mark, is either index to ContextInfo, or to next unused mark
    int         ContextLastUnused;  // LIFO linked list of unused marks
    int         ContextBufferSize;  // items allocated for
    int         ContextFirstUsed;   // FIFO linked list of used marks
    int         ContextFirstAuto;   // FIFO linked list of auto-release used marks

    //
    // Sometimes multiple strings need to be logged as one entry, which
    // requires making multiple calls to WriteLogEntry. If SETUP_LOG_BUFFER
    // is specified, the text will be accumulated in the buffer until such
    // time as SETUP_LOG_BUFFER is not specified, in which case the
    // contents of Buffer is output together with the current string.
    //
    PTSTR       Buffer;

    //
    // In case multiple threads access this struct simultaneously,
    // access to ContextInfo must be serialized. Also, we
    // don't want this to be deleted while another thread is using it.
    //

} SETUP_LOG_CONTEXT, *PSETUP_LOG_CONTEXT;

//
// TLS data used by logging
//
typedef struct _SETUP_LOG_TLS {
    //
    // stack of context's
    //
    PSETUP_LOG_CONTEXT  ThreadLogContext;

} SETUP_LOG_TLS, *PSETUP_LOG_TLS;

//
// Convenient macro for determining whether a deletion failure should be
// considered an error or a verbose entry.
//
#define DEL_ERR_LOG_LEVEL(Err) ((((Err) == ERROR_FILE_NOT_FOUND) || ((Err) == ERROR_PATH_NOT_FOUND)) \
                                ? SETUP_LOG_VERBOSE : SETUP_LOG_ERROR)

DWORD
CreateLogContext(
    IN PCTSTR SectionName,              OPTIONAL
    IN  BOOL UseDefault,
    OUT PSETUP_LOG_CONTEXT *LogContext
    );

VOID
DeleteLogContext(
    IN PSETUP_LOG_CONTEXT LogContext
    );

DWORD
RefLogContext(  // increment reference count
    IN PSETUP_LOG_CONTEXT LogContext
    );

VOID
SetLogSectionName(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR SectionName
    );

DWORD
InheritLogContext(
    IN TRACK_ARG_DECLARE TRACK_ARG_COMMA
    IN PSETUP_LOG_CONTEXT Source,
    OUT PSETUP_LOG_CONTEXT *Dest
    );

DWORD
ShareLogContext(
    IN OUT PSETUP_LOG_CONTEXT *Primary,
    IN OUT PSETUP_LOG_CONTEXT *Secondary
    );

DWORD
pSetupWriteLogEntry(
    IN PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    IN DWORD Level,
    IN DWORD MessageId,
    IN PCTSTR MessageStr,               OPTIONAL
    ...                                 OPTIONAL
    );

VOID
pSetupWriteLogError(
    IN PSETUP_LOG_CONTEXT LogContext,   OPTIONAL
    IN DWORD Level,
    IN DWORD Error
    );

#define WriteLogEntry pSetupWriteLogEntry
#define WriteLogError pSetupWriteLogError

DWORD
MakeUniqueName(
    IN  PCTSTR Component,        OPTIONAL
    OUT PTSTR * UniqueString
    );

DWORD
AllocLogInfoSlot(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN BOOL               AutoRelease
    );

DWORD
AllocLogInfoSlotOrLevel(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN DWORD              Level,
    IN BOOL               AutoRelease
    );

VOID
ReleaseLogInfoSlot(
    IN PSETUP_LOG_CONTEXT LogContext,
    DWORD Slot
    );

BOOL
InitializeContextLogging(
    IN BOOL Attach
    );

BOOL
ContextLoggingTlsInit(
    IN BOOL Init
    );

BOOL
SetThreadLogContext(
    IN PSETUP_LOG_CONTEXT LogContext,
    OUT PSETUP_LOG_CONTEXT *PrevContext   OPTIONAL
    );

PSETUP_LOG_CONTEXT
GetThreadLogContext(
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\debug.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    debug.c

Abstract:

    Diagnositc/debug routines for Windows NT Setup API dll.

Author:

    Ted Miller (tedm) 17-Jan-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#if ASSERTS_ON

extern BOOL InInitialization;


VOID
AssertFail(
    IN PCSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition,
    IN BOOL NoUI
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    LPSTR Msg;
    DWORD msglen;
    DWORD sz;
    DWORD rc;

    rc = GetLastError(); // preserve GLE

    //
    // Use dll name as caption
    //
    sz = GetModuleFileNameA(NULL,Name,MAX_PATH);
    if((sz == 0) || (sz > MAX_PATH)) {
        strcpy(Name,"?");
    }
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }
    msglen = strlen(p)+strlen(FileName)+strlen(Condition)+128;
    //
    // assert might be out of memory condition
    // stack alloc is more likely to succeed than memory alloc
    //
    try {
        Msg = (LPSTR)_alloca(msglen);
        wsprintfA(
            Msg,
            "Assertion failure at line %u in file %s!%s: %s%s",
            LineNumber,
            p,
            FileName,
            Condition,
            (GlobalSetupFlags & PSPGF_NONINTERACTIVE) ? "\r\n" : "\n\nCall DebugBreak()?"
            );

        OutputDebugStringA(Msg);

        if((GlobalSetupFlags & PSPGF_NONINTERACTIVE) || InInitialization || NoUI) {
            i = IDYES;
        } else {
            i = MessageBoxA(
                    NULL,
                    Msg,
                    p,
                    MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
                    );
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        OutputDebugStringA("SetupAPI ASSERT!!!! (out of stack)\r\n");
        i=IDYES;
    }


    if(i == IDYES) {
        SetLastError(rc);
        DebugBreak();
    }
    SetLastError(rc);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\debug.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    debug.h

Abstract:

    Private header file for sputils
    Debugging (ASSERT/VERIFY) macro's

Author:

    Jamie Hunter (JamieHun) Mar-26-2002

Revision History:

--*/


#ifndef ASSERTS_ON
#if DBG
#define ASSERTS_ON 1
#else
#define ASSERTS_ON 0
#endif
#endif

#if DBG
#ifndef MEM_DBG
#define MEM_DBG 1
#endif
#else
#ifndef MEM_DBG
#define MEM_DBG 0
#endif
#endif

#if ASSERTS_ON

//
// MYASSERT is a validity check with block symantics of {} or {if(foo); }
// ie, foo is only executed if ASSERTS_ON is 1 and should return a boolean
//
// MYVERIFY is a validity check with block symantics of ((foo) ? TRUE : FALSE)
// ie, foo is always executed and should return a boolean, with the side effect
// that it may also throw an assert if ASSERTS_ON is 1.
//

VOID
AssertFail(
    IN PCSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition,
    IN BOOL NoUI
    );

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x,FALSE); }
#define MYVERIFY(x) ((x) ? (TRUE) : (AssertFail(__FILE__,__LINE__,#x,FALSE),FALSE) )

#else

#define MYASSERT(x)
#define MYVERIFY(x) ((x) ? TRUE : FALSE)

#endif

//
// in case we accidently pick up ASSERT/VERIFY from elsewhere
//
#undef ASSERT
#undef VERIFY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\copy.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    copy.c

Abstract:

    High-level file copy/installation functions

Author:

    Ted Miller (tedm) 14-Feb-1995

Revision History:

--*/

#include "precomp.h"

#pragma hdrstop

#include <winioctl.h>

#define FILE_COMPARE_BLOCK_SIZE (0x1000000)

ULONG
_cdecl
DbgPrint(
    PCH Format,
    ...
    );


//
// Mask for all copy flags that will require us to determine
// version information.
//
#define SP_COPY_MASK_NEEDVERINFO    (SP_COPY_NEWER_OR_SAME | SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER | SP_COPY_LANGUAGEAWARE)


VOID
pGetVersionText(
   OUT PTSTR VersionText,
   IN DWORDLONG Version
   )
/*++

Routine Description:

    Convert a 64-bit version number into either
    n.n.n.n  or "0"

Arguments:

    VersionText - buffer, big enough to hold 4x16 bit numbers
    Version - 64-bit version, or 0 if no version

Return Value:

    none

--*/
{
    if (Version == 0) {
        lstrcpy(VersionText,TEXT("0"));
    } else {
        int m1 = (int)((Version >> 48) & 0xffff);
        int m2 = (int)((Version >> 32) & 0xffff);
        int m3 = (int)((Version >> 16) & 0xffff);
        int m4 = (int)(Version & 0xffff);

        wsprintf(VersionText,TEXT("%d.%d.%d.%d"),m1,m2,m3,m4);
    }
}

DWORD
CreateTargetAsLinkToMaster(
   IN PSP_FILE_QUEUE Queue,
   IN PCTSTR FullSourceFilename,
   IN PCTSTR FullTargetFilename,
   IN PVOID CopyMsgHandler OPTIONAL,
   IN PVOID Context OPTIONAL,
   IN BOOL IsMsgHandlerNativeCharWidth
   )
{
#ifdef ANSI_SETUPAPI
    return ERROR_CALL_NOT_IMPLEMENTED;
#else

    PTSTR p;
    TCHAR c;
    DWORD bytesReturned;
    DWORD error;
    BOOL ok;
    DWORD sourceLength;
    DWORD targetLength;
    DWORD sourceDosDevLength;
    DWORD targetDosDevLength;
    DWORD copyFileSize;
    PSI_COPYFILE copyFile;
    PCHAR s;
    HANDLE targetHandle;

    //
    // Get the name of the source directory.
    //
    p = _tcsrchr( FullSourceFilename, TEXT('\\') );
    if ( (p == NULL) || (p == FullSourceFilename) ) {
        return ERROR_FILE_NOT_FOUND;    // copy by usual means
    }
    if ( *(p-1) == TEXT(':') ) {
        p++;
    }
    c = *p;
    *p = 0;

    //
    // If this is the same as the previous source directory, then we already
    // have a handle to the directory; otherwise, close the old handle and
    // open a handle to this directory.
    //
    if ( (Queue->SisSourceDirectory == NULL) ||
         (_tcsicmp(FullSourceFilename, Queue->SisSourceDirectory) != 0) ) {

        if ( Queue->SisSourceHandle != INVALID_HANDLE_VALUE ) {
            CloseHandle( Queue->SisSourceHandle );
        }
        Queue->SisSourceHandle = CreateFile(
                                    FullSourceFilename,
                                    GENERIC_READ,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_FLAG_BACKUP_SEMANTICS,
                                    NULL
                                    );
        if ( Queue->SisSourceHandle == INVALID_HANDLE_VALUE ) {
            return ERROR_FILE_NOT_FOUND;
        }
        if ( Queue->SisSourceDirectory != NULL ) {
            MyFree( Queue->SisSourceDirectory );
        }
        Queue->SisSourceDirectory = DuplicateString( FullSourceFilename );

        //
        // If the DuplicateString fails, we press on. Because SisSourceDirectory
        // is NULL, we'll reopen the source directory next time.
        //
    }

    *p = c;

    //
    // Build the FSCTL command buffer.
    //

    sourceLength = (_tcslen(FullSourceFilename) + 1) * sizeof(TCHAR);
    if ( *FullSourceFilename != TEXT('\\') ) {
        sourceDosDevLength = _tcslen(TEXT("\\??\\")) * sizeof(TCHAR);
    } else {
        sourceDosDevLength = 0;
    }
    targetLength = (_tcslen(FullTargetFilename) + 1) * sizeof(TCHAR);
    if ( *FullTargetFilename != TEXT('\\') ) {
        targetDosDevLength = _tcslen(TEXT("\\??\\")) * sizeof(TCHAR);
    } else {
        targetDosDevLength = 0;
    }

    copyFileSize = FIELD_OFFSET(SI_COPYFILE, FileNameBuffer) +
                    sourceDosDevLength + sourceLength +
                    targetDosDevLength + targetLength;

    copyFile = MyMalloc( copyFileSize );
    if ( copyFile == NULL ) {
        return ERROR_FILE_NOT_FOUND;
    }

    copyFile->SourceFileNameLength = sourceDosDevLength + sourceLength;
    copyFile->DestinationFileNameLength = targetDosDevLength + targetLength;
    copyFile->Flags = COPYFILE_SIS_REPLACE;

    s = (PCHAR)copyFile->FileNameBuffer;
    if ( sourceDosDevLength != 0 ) {
        RtlCopyMemory(
            s,
            TEXT("\\??\\"),
            sourceDosDevLength
            );
        s += sourceDosDevLength;
    }
    RtlCopyMemory(
        s,
        FullSourceFilename,
        sourceLength
        );
    s += sourceLength;

    if ( targetDosDevLength != 0 ) {
        RtlCopyMemory(
            s,
            TEXT("\\??\\"),
            targetDosDevLength
            );
        s += targetDosDevLength;
    }
    RtlCopyMemory(
        s,
        FullTargetFilename,
        targetLength
        );

    //
    // Invoke the SIS CopyFile FsCtrl.
    //

    ok = DeviceIoControl(
            Queue->SisSourceHandle,
            FSCTL_SIS_COPYFILE,
            copyFile,               // Input buffer
            copyFileSize,           // Input buffer length
            NULL,                   // Output buffer
            0,                      // Output buffer length
            &bytesReturned,
            NULL
            );
    error = GetLastError( );

    MyFree( copyFile );

    if ( ok ) {

        //DbgPrint( "\n\nCreateTargetAsLinkToMaster: SIS copy %ws->%ws succeeded\n\n\n", FullSourceFilename, FullTargetFilename );

        //
        // Open the target file so that CSC knows about it and pins it,
        // if necessary.
        //

        targetHandle = CreateFile(
                            FullTargetFilename,
                            GENERIC_READ,
                            FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL
                            );
        if ( targetHandle == INVALID_HANDLE_VALUE ) {
            error = GetLastError();
            DbgPrint( "\n\nCreateTargetAsLinkToMaster: SIS copy %ws->%ws succeeded, but open failed: %d\n\n\n", FullSourceFilename, FullTargetFilename, error );
        } else {
            CloseHandle( targetHandle );
        }

        error = NO_ERROR;

    } else {

        //DbgPrint( "\n\nCreateTargetAsLinkToMaster: SIS copy %ws->%ws failed: %d\n\n\n", FullSourceFilename, FullTargetFilename, error );

        //
        // If it looks like SIS isn't active on the remote file system, close
        // the SIS root handle so that we can avoid repeatedly getting this
        // error.
        //
        // Note: NTFS returns STATUS_INVALID_PARAMETER (ERROR_INVALID_PARAMETER).
        // FAT returns STATUS_INVALID_DEVICE_REQUEST (ERROR_INVALID_FUNCTION).
        //

        if ( (error == ERROR_INVALID_PARAMETER) ||
             (error == ERROR_INVALID_FUNCTION) ) {
            CloseHandle( Queue->SisSourceHandle );
            Queue->SisSourceHandle = INVALID_HANDLE_VALUE;
            if ( Queue->SisSourceDirectory != NULL ) {
                MyFree( Queue->SisSourceDirectory );
                Queue->SisSourceDirectory = NULL;
            }
            Queue->Flags &= ~FQF_TRY_SIS_COPY;
        }
    }

    return error;

#endif
}

BOOL
pCompareFilesExact(
    IN PCTSTR File1,
    IN PCTSTR File2
    )
/*++

Routine Description:

    Determine if File1 and File2 are byte-for-byte exactly the same. If they are, we don't need to do anything.

Arguments:

    File1 - the two files to compare. The order does not matter
    File2

Return Value:

    TRUE if the files are exactly the same
    Note that we have to allow for potentially huge files.

--*/
{
    HANDLE hFile1,hFile2;
    HANDLE hMap1,hMap2;
    LPVOID View1,View2;
    ULARGE_INTEGER Size1,Size2,Offset;
    SIZE_T BlockSize;
    SIZE_T ChunkSize;
    BOOL match;

    match = FALSE;
    hFile1=hFile2=INVALID_HANDLE_VALUE;
    hMap1=hMap2=NULL;
    View1=View2=NULL;

    try {
        hFile1 = CreateFile(File1,
                            GENERIC_READ,
                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL);
        if (hFile1 == INVALID_HANDLE_VALUE) {
            leave;
        }
        hFile2 = CreateFile(File2,
                            GENERIC_READ,
                            FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,
                            NULL);
        if (hFile2 == INVALID_HANDLE_VALUE) {
            leave;
        }

        Size1.LowPart = GetFileSize(hFile1,&Size1.HighPart);
        if(Size1.LowPart == (DWORD)(-1) && GetLastError()) {
            //
            // get file size failed
            //
            leave;
        }
        Size2.LowPart = GetFileSize(hFile2,&Size2.HighPart);
        if(Size2.LowPart == (DWORD)(-1) && GetLastError()) {
            //
            // get file size failed
            //
            leave;
        }
        if (Size1.QuadPart != Size2.QuadPart) {
            leave;
        }

        if (Size1.QuadPart == 0) {
            //
            // both files are zero length, nothing to do
            //
            match = TRUE;
            leave;
        }

        //
        // basic checks done, we'll mark both files as mappable to do the byte-checks
        //
        hMap1 = CreateFileMapping(hFile1,
                                  NULL,
                                  PAGE_READONLY,
                                  Size1.HighPart,
                                  Size1.LowPart,
                                  NULL);
        if (hMap1 == NULL) {
            //
            // mapping failed
            //
            leave;
        }

        hMap2 = CreateFileMapping(hFile2,
                                  NULL,
                                  PAGE_READONLY,
                                  Size1.HighPart,
                                  Size1.LowPart,
                                  NULL);
        if (hMap2 == NULL) {
            //
            // mapping failed
            //
            leave;
        }

        if (Size1.QuadPart > FILE_COMPARE_BLOCK_SIZE) {
            BlockSize = FILE_COMPARE_BLOCK_SIZE;
        } else {
            BlockSize = (SIZE_T)Size1.QuadPart;
            MYASSERT(BlockSize);
        }

        //
        // now proceed in BlockSize chunks comparing the two files
        //
        Offset.QuadPart = 0;

        do {
            if ((Size1.QuadPart - Offset.QuadPart) < BlockSize) {
                ChunkSize = (SIZE_T)(Size1.QuadPart - Offset.QuadPart);
                MYASSERT(ChunkSize);
            } else {
                ChunkSize = BlockSize;
            }

            //
            // map and compare the two views
            // for most files, we will only need to do this once
            // for big files, we'll do this approx (Size1+BlockSize-1)/BlockSize times
            //
            View1 = MapViewOfFile(hMap1,
                                  FILE_MAP_READ,
                                  Offset.HighPart,
                                  Offset.LowPart,
                                  ChunkSize);
            if (View1 == NULL) {
                //
                // get view failed
                //
                leave;
            }
            View2 = MapViewOfFile(hMap2,
                                  FILE_MAP_READ,
                                  Offset.HighPart,
                                  Offset.LowPart,
                                  ChunkSize);
            if (View2 == NULL) {
                //
                // get view failed
                //
                leave;
            }
            if(memcmp(View1,View2,ChunkSize) != 0) {
                //
                // file chunks mismatch
                //
                leave;
            }
            UnmapViewOfFile(View1);
            UnmapViewOfFile(View2);
            View1 = NULL;
            View2 = NULL;

            Offset.QuadPart += ChunkSize;

        } while (Offset.QuadPart<Size1.QuadPart);

        //
        // if we get here, we have a 100% match
        //
        match = TRUE;

    } except(EXCEPTION_EXECUTE_HANDLER) {
    }

    if (View1 != NULL) {
        UnmapViewOfFile(View1);
    }
    if (View2 != NULL) {
        UnmapViewOfFile(View2);
    }
    if (hMap1 != NULL) {
        CloseHandle(hMap1);
    }
    if (hMap2 != NULL) {
        CloseHandle(hMap2);
    }
    if (hFile1 != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile1);
    }
    if (hFile2 != INVALID_HANDLE_VALUE) {
        CloseHandle(hFile2);
    }
    return match;
}

BOOL
_SetupInstallFileEx(
    IN  PSP_FILE_QUEUE      Queue,             OPTIONAL
    IN  PSP_FILE_QUEUE_NODE QueueNode,         OPTIONAL
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCTSTR              SourceFile,        OPTIONAL
    IN  PCTSTR              SourcePathRoot,    OPTIONAL
    IN  PCTSTR              DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PVOID               CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse,
    IN  BOOL                IsMsgHandlerNativeCharWidth,
    OUT PBOOL               SignatureVerifyFailed
    )

/*++

Routine Description:

    Actual implementation of SetupInstallFileEx. Handles either ANSI or
    Unicode callback routine.

Arguments:

    Same as SetupInstallFileEx().

    QueueNode - must be specified if Queue is supplied.  This parameter gives
        us the queue node for this operation so we can get at the pertinent
        catalog info for driver signing.

    IsMsgHandlerNativeCharWidth - supplies a flag indicating whether
        CopyMsgHandler expects native char widths args (or ansi ones, in the
        unicode build of the dll).

    SignatureVerifyFailed - supplies the address of a boolean variable that is
        set to indicate whether or not digital signature verification failed 
        for the source file.  This will be set to FALSE if some other failure 
        caused us to abort prior to attempting the signature verification.  
        This is used by the queue commit routines to determine whether or not 
        the queue callback routine should be given a chance to handle a copy 
        failure (skip, retry, etc.).  Digital signature verification failures 
        are handled within this routine (including user prompting, if policy
        requires it), and queue callback routines _are not_ allowed to override
        the behavior.

Return Value:

    Same as SetupInstallFileEx().

--*/

{
    BOOL b;
    BOOL Ok;
    DWORD rc = NO_ERROR;
    DWORD SigVerifRc;
    UINT SourceId;
    TCHAR Buffer1[MAX_PATH];
    TCHAR Buffer2[MAX_PATH];
    PCTSTR FullSourceFilename;
    PCTSTR FullTargetFilename;
    PCTSTR SourceFilenamePart;
    PTSTR ActualSourceFilename;
    PTSTR TemporaryTargetFile;
    UINT CompressionType;
    DWORD SourceFileSize;
    DWORD TargetFileSize;
    PTSTR p;
    DWORDLONG SourceVersion, TargetVersion;
    TCHAR SourceVersionText[50], TargetVersionText[50];
    LANGID SourceLanguage;
    LANGID TargetLanguage;
    WIN32_FIND_DATA SourceFindData;
    UINT NotifyFlags;
    PSECURITY_DESCRIPTOR SecurityInfo;
    FILEPATHS FilePaths;
    UINT param;
    FILETIME sFileTime,tFileTime;
    WORD sDosTime,sDosDate,tDosTime,tDosDate;
    BOOL Moved;
    SetupapiVerifyProblem Problem;
    BOOL ExistingTargetFileWasSigned;
    PSETUP_LOG_CONTEXT lc = NULL;
    DWORD slot_fileop = 0;
    SP_TARGET_ENT TargetInfo;
    PCTSTR ExistingFile = NULL;
    PCTSTR CompareFile = NULL;
    PCTSTR BackupFileName = NULL;
    BOOL CompareSameFilename = FALSE;
    BOOL FileUnchanged = FALSE;
    PLOADED_INF LoadedInf = NULL;
    DWORD ExemptCopyFlags = 0;
    BOOL DoingDeviceInstall;
    DWORD DriverSigningPolicy;
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform = NULL;
    PTSTR DeviceDesc = NULL;

    if (Queue) {
        lc = Queue->LogContext;
    } else if (InfHandle && InfHandle != INVALID_HANDLE_VALUE) {
        //
        // Lock INF for the duration of this routine.
        //
        try {
            if(!LockInf((PLOADED_INF)InfHandle)) {
                rc = ERROR_INVALID_HANDLE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            //
            // Assume InfHandle was bad pointer
            //
            rc = ERROR_INVALID_HANDLE;
        }
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return FALSE;
        }

        LoadedInf = (PLOADED_INF)InfHandle;

        lc = LoadedInf->LogContext;
    }

    //
    // If Queue is specified, then so must QueueNode (and vice versa).
    //
    MYASSERT((Queue && QueueNode) || !(Queue || QueueNode));

    *SignatureVerifyFailed = FALSE;
    SigVerifRc = NO_ERROR;

    //
    // Assume failure.
    //
    Ok = FALSE;
    SecurityInfo = NULL;
    Moved = FALSE;
    try {
        *FileWasInUse = FALSE;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_PARAMETER;
    }

    if((rc == NO_ERROR) && InfContext) {
        if(!InfHandle || (InfHandle == INVALID_HANDLE_VALUE)) {
            rc = ERROR_INVALID_PARAMETER;
        }
    }

    if(rc != NO_ERROR) {
        goto clean0;
    }

    //
    // Determine the full source path and filename of the file.
    //
    if(CopyStyle & SP_COPY_SOURCE_ABSOLUTE) {
        if (!SourceFile) {
            rc = ERROR_INVALID_PARAMETER;
            goto clean0;
        }
        FullSourceFilename = DuplicateString(SourceFile);
    } else {

        //
        // Get the relative path for this file if necessary.
        //
        if(CopyStyle & SP_COPY_SOURCEPATH_ABSOLUTE) {
            Buffer2[0] = TEXT('\0');
            b = TRUE;
        } else {
            b = _SetupGetSourceFileLocation(
                    InfHandle,
                    InfContext,
                    SourceFile,
                    (Queue && (Queue->Flags & FQF_USE_ALT_PLATFORM))
                        ? &(Queue->AltPlatformInfo)
                        : NULL,
                    &SourceId,
                    Buffer2,
                    MAX_PATH,
                    NULL,
                    NULL
                   );
        }

        //
        // Concatenate the relative path and the filename to the source root.
        //
        if(!b) {
            rc = (GetLastError() == ERROR_INSUFFICIENT_BUFFER
               ? ERROR_FILENAME_EXCED_RANGE : GetLastError());
            goto clean0;
        }

        if (SourcePathRoot) {
            lstrcpyn(Buffer1,SourcePathRoot,MAX_PATH);
        } else {
            Buffer1[0] = TEXT('\0');
        }

        if(!pSetupConcatenatePaths(Buffer1,Buffer2,MAX_PATH,NULL)
        || !pSetupConcatenatePaths(Buffer1,SourceFile,MAX_PATH,NULL)) {
            rc = ERROR_FILENAME_EXCED_RANGE;
            goto clean0;
        }

        FullSourceFilename = DuplicateString(Buffer1);
    }

    if(!FullSourceFilename) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto clean0;
    }

    SourceFilenamePart = pSetupGetFileTitle(FullSourceFilename);

    //
    // Determine the full target path and filename of the file.
    // For now ignore the issues regarding compressed vs. uncompressed names.
    //
    if(InfContext) {
        //
        // DestinationName is the filename only (no path) of the target.
        // We'll need to fetch the target path information for the section
        // that InfContext references.
        //
        b = SetupGetTargetPath(
                InfHandle,
                InfContext,
                NULL,
                Buffer1,
                MAX_PATH,
                NULL
                );

        if(!b) {
            rc = (GetLastError() == ERROR_INSUFFICIENT_BUFFER
               ? ERROR_FILENAME_EXCED_RANGE : GetLastError());
            goto clean1;
        }

        lstrcpyn(Buffer2,Buffer1,MAX_PATH);

        b = pSetupConcatenatePaths(
                Buffer2,
                DestinationName ? DestinationName : SourceFilenamePart,
                MAX_PATH,
                NULL
                );

        if(!b) {
            rc = ERROR_FILENAME_EXCED_RANGE;
            goto clean1;
        }

        FullTargetFilename = DuplicateString(Buffer2);
    } else {
        //
        // DestinationName is the full path and filename of the target file.
        //
        FullTargetFilename = DuplicateString(DestinationName);
    }

    if(!FullTargetFilename) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto clean1;
    }

    //
    // Log the file copy - only if we log something else
    // note that once we've determined temporary name, we'll change this message
    //
    slot_fileop = AllocLogInfoSlot(lc,FALSE); // for conditional display of extra logging info
    WriteLogEntry(
        lc,
        slot_fileop,
        MSG_LOG_COPYING_FILE,
        NULL,
        FullSourceFilename,
        FullTargetFilename);

    //
    // Make sure the target path exists.
    //
    rc = pSetupMakeSurePathExists(FullTargetFilename);
    if(rc != NO_ERROR) {
        rc = ERROR_INVALID_TARGET;
        goto clean2;
    }

    //
    // Determine if the source file is compressed and get compression type
    // if so.
    //
    rc = SetupInternalGetFileCompressionInfo(
            FullSourceFilename,
            &ActualSourceFilename,
            &SourceFindData,
            &TargetFileSize,
            &CompressionType
            );

    //
    // If the source doesn't exist but the target does, and we don't want to
    // overwrite it, then there is no error and we're finished.
    //
    // When doing a driver uninstall (i.e., re-installing the
    // previous driver from the backup directory), it's possible that not all
    // source files will be present in that directory (i.e., only those files
    // that were modified got backed up).  In that case, we want to consider a
    // source file-not-found error here to be OK, even if the force-nooverwrite
    // flag isn't set.
    //
    // Note that driver signing isn't relevant here, because if an INF was signed
    // with the force-nooverwrite flag, then the signer (i.e., WHQL) must've been
    // satisfied that the file in question was not crucial to the package's
    // integrity/operation (a default INI file would be an example of this).
    //
    if(rc == ERROR_FILE_NOT_FOUND &&
        CopyStyle & SP_COPY_FORCE_NOOVERWRITE &&
        FileExists(FullTargetFilename,NULL)
        ) {

        rc = NO_ERROR;
        goto clean2;

    } else if(rc != NO_ERROR) {
        goto clean2;
    }

    //
    // Got the actual source file name now.
    //
    MyFree(FullSourceFilename);
    FullSourceFilename = ActualSourceFilename;
    SourceFilenamePart = pSetupGetFileTitle(FullSourceFilename);

    //
    // If the file to be copied is a .CAB and the source and destination
    // filenames are the same, then we don't want to attempt to decompress it
    // (because if we do, we'd just be pulling the first file out of the cab
    // and renaming it to the destination filename, which is never the desired
    // behavior.
    //
    if(!lstrcmpi(SourceFilenamePart, pSetupGetFileTitle(FullTargetFilename))) {
        p = _tcsrchr(SourceFilenamePart, TEXT('.'));
        if(p && !_tcsicmp(p, TEXT(".CAB"))) {
            CopyStyle |= SP_COPY_NODECOMP;
        }
    }

    //
    // If SP_COPY_NODECOMP flag is set, adjust the target filename so that
    // the filename part is the same as the actual name of the source.
    // We do this regardless of whether the source file is compressed.
    //
    // Note:  For driver signing, the fact that this file is installed in its
    // compressed form means we must have an entry for the compressed file in
    // the catalog.  However, if at some point in the future this file is going
    // to be expanded (as is typically the case), then we need to have the
    // expanded file's signature in the catalog as well, so that sigverif
    // doesn't consider this expanded file to be from a non-certified package.
    //
    if(CopyStyle & SP_COPY_ALREADYDECOMP) {
        //
        // this flag indicates we've decompressed it as far as we want
        // (used when restoring backup)
        //
        CompressionType = FILE_COMPRESSION_NONE;

    } else if(CopyStyle & SP_COPY_NODECOMP) {
        //
        // Strip out version-related bits and ensure that we treat the file
        // as uncompressed.
        //
        CopyStyle &= ~SP_COPY_MASK_NEEDVERINFO;
        CompressionType = FILE_COMPRESSION_NONE;

        //
        // Isolate the path part of the target filename.
        //
        lstrcpyn(Buffer1, FullTargetFilename, MAX_PATH);
        *((PTSTR)pSetupGetFileTitle(Buffer1)) = TEXT('\0');

        //
        // Concatenate the source filename onto the target pathname.
        //
        if(!pSetupConcatenatePaths(Buffer1,SourceFilenamePart,MAX_PATH,NULL)) {
            rc = ERROR_FILENAME_EXCED_RANGE;
            goto clean2;
        }

        p = DuplicateString(Buffer1);
        if(!p) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean2;
        }

        MyFree(FullTargetFilename);
        FullTargetFilename = p;
    }

    //
    // See if the target file exists, either as a renamed file (i.e., because
    // we're replacing a boot file), or as a file presently existing at the
    // target location.
    //
    if(Queue && (CopyStyle & SP_COPY_REPLACE_BOOT_FILE)) {
        //
        // First, we need to find the corresponding target info node so
        // we can find out what temporary name our file was renamed to.
        //
        rc = pSetupBackupGetTargetByPath((HSPFILEQ)Queue,
                                         NULL, // use Queue's string table
                                         FullTargetFilename,
                                         QueueNode->TargetDirectory,
                                         -1,
                                         QueueNode->TargetFilename,
                                         NULL,
                                         &TargetInfo
                                        );
        if(rc == NO_ERROR) {
            //
            // Has the file previously been renamed (and not yet restored)?
            //
            if((TargetInfo.InternalFlags & (SP_TEFLG_MOVED | SP_TEFLG_RESTORED)) == SP_TEFLG_MOVED) {

                CompareFile = ExistingFile =
                       pSetupStringTableStringFromId(
                                                     Queue->StringTable,
                                                     TargetInfo.NewTargetFilename
                                                     );
                MYASSERT(ExistingFile);
            }
        }
    }

    if(!ExistingFile && FileExists(FullTargetFilename, NULL)) {
        CompareFile = ExistingFile = FullTargetFilename;
        CompareSameFilename = TRUE; // allows optimization later
    }

    if(ExistingFile) {

        if(CopyStyle & SP_COPY_FORCE_NOOVERWRITE) {
            //
            // No overwrite and no callback notification either
            //
            // Note that driver signing isn't relevant here, because if an INF
            // was signed with the force-nooverwrite flag, then the signer
            // (i.e., WHQL) must've been satisfied that the file in question was
            // not crucial to the package's integrity/operation (a default INI
            // file would be an example of this).
            //
            rc = NO_ERROR;
            goto clean2;
        }

        if(CopyStyle & SP_COPY_MASK_NEEDVERINFO) {
            if(!GetVersionInfoFromImage(ExistingFile, &TargetVersion, &TargetLanguage)) {
                TargetVersion = 0;
                TargetLanguage = 0;
            }
        }

        //
        // If the target file exists we'll want to preserve security info on it.
        //
        if(RetreiveFileSecurity(ExistingFile, &SecurityInfo) != NO_ERROR) {
            SecurityInfo = NULL;
        }

    } else {

        if(CopyStyle & SP_COPY_REPLACEONLY) {
            //
            // Target file doesn't exist, so there's nothing to do.
            //
            rc = NO_ERROR;
            goto clean2;
        }
        if(Queue && ((Queue->Flags & FQF_FILES_MODIFIED)==0)) {
            //
            // maybe the file was renamed/deleted first
            // so we might still want to compare against backup
            // to determine if it was "modified"
            //
            rc = pSetupBackupGetTargetByPath((HSPFILEQ)Queue,
                                             NULL, // use Queue's string table
                                             FullTargetFilename,
                                             QueueNode->TargetDirectory,
                                             -1,
                                             QueueNode->TargetFilename,
                                             NULL,
                                             &TargetInfo
                                            );
            if((rc == NO_ERROR) &&
                  ((TargetInfo.InternalFlags & (SP_TEFLG_MOVED | SP_TEFLG_SAVED)) != 0)) {
                    //
                    // get filename of copy of original file, if there is one
                    //
                    CompareFile = BackupFileName =
                                     pSetupFormFullPath(Queue->StringTable,
                                                        TargetInfo.TargetRoot,
                                                        TargetInfo.TargetSubDir,
                                                        TargetInfo.TargetFilename
                                                       );
            }
        }
    }

    //
    // If the source is not compressed (LZ or cabinet), and SIS is (or might be)
    // present, create the target as an SIS link to the master instead of copying it.
    //
    // If the target exists, and NOOVERWRITE was specified, don't try to create
    // an SIS link. Instead, fall through to the normal copy code. The overwrite
    // semantics are wrong if the file already exists.
    //
    if((CompressionType == FILE_COMPRESSION_NONE) &&
       (!ExistingFile || ((CopyStyle & SP_COPY_NOOVERWRITE) == 0)) &&
       (Queue != NULL) &&
       ((Queue->Flags & FQF_TRY_SIS_COPY) != 0)) {

        //
        // First, verify that the sourcefile is signed.  If it is not, but the
        // user elects to proceed with the copy (or if the policy is 'ignore')
        // then we'll go ahead and attempt to setup the SIS link.
        //
        ValidationPlatform = (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                ? &(Queue->AltPlatformInfo)
                                : Queue->ValidationPlatform;

        rc = VerifySourceFile(lc,
                              Queue,
                              QueueNode,
                              pSetupGetFileTitle(FullTargetFilename),
                              FullSourceFilename,
                              NULL,
                              ValidationPlatform,
                              0,
                              &Problem,
                              Buffer1,
                              NULL,
                              NULL,
                              NULL,
                              NULL
                             );

        if(rc != NO_ERROR) {
            //
            // Store the error away from the above validation failure.  We'll
            // refrain from setting the "SignatureVerifyFailed" flag until we
            // figure out whether the file is Authenticode-signed.
            //
            SigVerifRc = rc;

            //
            // If policy is forced to Block, then we don't even try to
            // validate the file using Authenticode policy.  This is done by
            // Windows File Protection, for example, which doesn't respect
            // Authenticode signatures, and we mustn't either.
            //
            if(Queue->Flags & FQF_QUEUE_FORCE_BLOCK_POLICY) {
                *SignatureVerifyFailed = TRUE;
                goto clean2;
            }

            if(IsFileProtected(FullTargetFilename, lc, NULL)) {
                //
                // If the file is protected, then Authenticode can't save us!
                //
                *SignatureVerifyFailed = TRUE;

                if(QueueNode && QueueNode->CatalogInfo) {
                    //
                    // We never allow Authenticode-signed files to replace
                    // system-protected files.  In fact, when we detect such a
                    // trick, we abort the whole installation!
                    //
                    if(QueueNode->CatalogInfo->Flags & CATINFO_FLAG_AUTHENTICODE_SIGNED) {

                        WriteLogEntry(lc,
                                      SETUP_LOG_ERROR,
                                      MSG_LOG_AUTHENTICODE_SIGNATURE_BLOCKED_FOR_SFC_SIS,
                                      NULL,
                                      FullTargetFilename,
                                      FullSourceFilename
                                     );
                        goto clean2;
                    }
                }

                if(Problem != SetupapiVerifyDriverBlocked) {
                    //
                    // If this is a device installation and the policy is 
                    // "Ignore", then crank it up to "Warn" if the file is 
                    // under SFP's protection.  This will allow the user to 
                    // update a driver that ships in our box for which no WHQL 
                    // certification program exists.
                    //
                    if((Queue->Flags & FQF_DEVICE_INSTALL) &&
                       ((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE) 
                        == DRIVERSIGN_NONE)) {

                        //
                        // (We don't care if we blow away the Authenticode bit,
                        // since that's not valid for this queue, now that
                        // we've discovered it's trying to replace system
                        // protected files.)
                        //
                        Queue->DriverSigningPolicy = DRIVERSIGN_WARNING;

                        //
                        // Log the fact that policy was elevated.
                        //
                        WriteLogEntry(lc,
                                      SETUP_LOG_ERROR,
                                      MSG_LOG_POLICY_ELEVATED_FOR_SFC,
                                      NULL
                                     );
                    }
                }

            } else {
                //
                // If the file may be validated by an Authenticode-signed
                // catalog, then check for that now.  If that validation fails,
                // then we simply want to bail, because that indicates
                // tampering.  At this point, we've already confirmed that the
                // signer should be trusted, so there's no need for UI (i.e.,
                // we don't need to call _HandleFailedVerification).
                //
                if((rc != ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH) &&
                   QueueNode && 
                   QueueNode->CatalogInfo &&
                   (QueueNode->CatalogInfo->Flags & CATINFO_FLAG_AUTHENTICODE_SIGNED)) {

                    rc = VerifySourceFile(lc,
                                          Queue,
                                          QueueNode,
                                          pSetupGetFileTitle(FullTargetFilename),
                                          FullSourceFilename,
                                          NULL,
                                          ValidationPlatform,
                                          VERIFY_FILE_USE_AUTHENTICODE_CATALOG,
                                          &Problem,
                                          Buffer1,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL
                                         );

                    if((rc == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                       (rc == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {

                        SigVerifRc = rc = NO_ERROR;

                    } else {
                        *SignatureVerifyFailed = TRUE;
                        goto clean2;
                    }

                } else {
                    //
                    // File isn't associated with an Authenticode catalog, so
                    // we can finally say with certainty we had a signature
                    // verification failure.
                    //
                    *SignatureVerifyFailed = TRUE;
                }
            }

            //
            // Unless we were saved by an Authenticode signature, we need to
            // handle the verification failure...
            //
            if(*SignatureVerifyFailed) {

                if(!_HandleFailedVerification(
                        Queue->hWndDriverSigningUi,
                        Problem,
                        (Problem == SetupapiVerifyDriverBlocked)
                          ? FullSourceFilename : Buffer1,
                        ((Queue->DeviceDescStringId == -1)
                            ? NULL
                            : pStringTableStringFromId(Queue->StringTable, Queue->DeviceDescStringId)),
                        Queue->DriverSigningPolicy,
                        (Queue->Flags & FQF_DIGSIG_ERRORS_NOUI),
                        rc,
                        lc,
                        (((Queue->Flags & FQF_ABORT_IF_UNSIGNED) &&
                          (Problem != SetupapiVerifyDriverBlocked))
                            ? NULL : &ExemptCopyFlags),
                        (((Queue->Flags & FQF_ABORT_IF_UNSIGNED) &&
                          (Problem != SetupapiVerifyDriverBlocked))
                            ? NULL : FullTargetFilename),
                        NULL))
                {
                    //
                    // User elected not to install the unsigned file (or was 
                    // blocked by policy from doing so).
                    //
                    goto clean2;
                }

                //
                // The user wants to proceed with the unsigned installation (or
                // policy is ignore, so they weren't even informed).  If the
                // caller wants a chance to set a system restore point prior to
                // doing any unsigned installations, then we abort now with a
                // "special" error code that tells them what to do...
                //                
                if(Queue->Flags & FQF_ABORT_IF_UNSIGNED) {
                    //
                    // We don't want the user to see the driver signing UI 
                    // again when the queue is re-committed...
                    //
                    if((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE) 
                       != DRIVERSIGN_NONE) {

                        Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                    }

                    rc = ERROR_SET_SYSTEM_RESTORE_POINT;
                    goto clean2;
                }

                //
                // Set a flag in the queue that indicates the user has been informed
                // of a signature problem with this queue, and has elected to go
                // ahead and install anyway.  Don't set this flag if the queue's
                // policy is "Ignore", on the chance that the policy might be
                // altered later, and we'd want the user to get informed on any
                // subsequent errors.
                //
                if((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE) 
                   != DRIVERSIGN_NONE) {

                    Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                }

                if(QueueNode) {
                    QueueNode->InternalFlags |= ExemptCopyFlags;
                }

                //
                // Reset rc to NO_ERROR and carry on.
                //
                rc = NO_ERROR;
            }
        }

        if(rc == NO_ERROR) {

            rc = CreateTargetAsLinkToMaster(
                    Queue,
                    FullSourceFilename,
                    FullTargetFilename,
                    CopyMsgHandler,
                    Context,
                    IsMsgHandlerNativeCharWidth
                    );
        }

        if(rc == NO_ERROR) {
            //
            // ISSUE JamieHun-2001/03/20 Is this best thing to do for SIS link?
            //
            Queue->Flags |= FQF_FILES_MODIFIED;

            //
            // We're done!
            //
            Ok = TRUE;
            goto clean2;
        }
    }

    //
    // We will copy the file to a temporary location. This makes version checks
    // possible in all cases (even when the source is compressed) and simplifies
    // the logic below. Start by forming the name of the temporary file.
    //
    lstrcpyn(Buffer1, FullTargetFilename, MAX_PATH);
    *((PTSTR)pSetupGetFileTitle(Buffer1)) = TEXT('\0');

    if(!GetTempFileName(Buffer1, TEXT("SETP"), 0, Buffer2)) {
        rc = ERROR_INVALID_TARGET;
        goto clean2;
    }

    TemporaryTargetFile = DuplicateString(Buffer2);
    if(!TemporaryTargetFile) {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        goto clean2;
    }
    //
    // Log the file copy - only if we log something else unless at Info level
    //
    ReleaseLogInfoSlot(lc,slot_fileop);
    slot_fileop = AllocLogInfoSlotOrLevel(lc,SETUP_LOG_INFO,FALSE); // for conditional display of extra logging info
    WriteLogEntry(
        lc,
        slot_fileop,
        MSG_LOG_COPYING_FILE_VIA,
        NULL,
        FullSourceFilename,
        FullTargetFilename,
        TemporaryTargetFile);

    //
    // Perform the actual file copy. This creates the temporary target file.
    // Move is allowed as an optimization if we're deleting the source file.
    // The call we make below will not use move if the file is compressed
    // and we are supposed to decompress it, so the right thing will happen
    // in all cases.
    //
    // There are 2 potential issues:
    //
    // 1) When we call the callback function below for a version check,
    //    the source file won't exist any more if the file was moved. Oh well.
    //
    // 2) If the MoveFileEx below fails, the source will have still been 'deleted'.
    //    This is different from the non-move case, where the source remains
    //    intact unless this function is successful.
    //
    // Otherwise this is a non-issue since any compressed file will be decompressed
    // by this call, so version gathering, etc, will all work properly.
    //
    rc = pSetupDecompressOrCopyFile(
            FullSourceFilename,
            TemporaryTargetFile,
            &CompressionType,
            ((CopyStyle & SP_COPY_DELETESOURCE) != 0),
            &Moved
            );

    if(rc != NO_ERROR) {
        goto clean3;
    }

    //
    // Do digital signature check on source file, now that it exists in its
    // final form under a temp name.  Note that for signed files, we ignore
    // version checking since they're an inherently unreliable mechanism for
    // comparing files provided from two different vendors (who use different
    // versioning schemes, etc.)
    //
    // To see why we ignore version numbers, consider the decision tree we'd
    // use if we were paying attention to version numbers as well as digital
    // signatures.  In the discussion that follows, NewFile is the (signed) 
    // file we're going to copy, and OldFile is the file that will be 
    // overwritten if the copy goes through...
    //
    // if NewFile is versioned {
    //     if OldFile is signed {
    //         if OldFile is versioned {
    //             //
    //             // Both NewFile and OldFile are signed and versioned.
    //             //
    //             if OldFile is a newer version {
    //                 //
    //                 // This is the controversial case.  Since these two incarnations could've come from different vendors
    //                 // with different versioning schemes, we really can't use versioning as a very accurate method of determining
    //                 // which file is 'better'.  So there are two options:
    //                 //    1.  Leave OldFile alone, and if the package being installed can't work with OldFile, then the user must 'undo'
    //                 //         the installation, and then call their vendor to gripe--there'll be no way for them to get the new package to
    //                 //         work, even though WHQL certified it.
    //                 //    2.  Overwrite OldFile.  Since we're then guaranteeing that every file signed as part of the package will be
    //                 //         present, then we can have a much higher degree of certainty that our WHQL certification will hold true
    //                 //         for every user's machine.  If replacing OldFile breaks someone else (e.g., the previously-installed package
    //                 //         that uses it, then the user can 'undo' the installation.  This scenario is better because even though the old
    //                 //         and new packages can't be used simultaneously, at least one or the other can be made to work
    //                 //         independently.
    //                 //
    //                 overwrite OldFile
    //             } else {  // NewFile is a newer version
    //                 overwrite OldFile
    //             }
    //         } else {  // OldFile isn't versioned--NewFile wins
    //             overwrite OldFile
    //         }
    //     } else {  // OldFile isn't signed--we don't care what its version is
    //         overwrite OldFile
    //     }
    // } else {  // NewFile isn't versioned
    //     if OldFile is versioned {
    //         if OldFile is signed {
    //             //
    //             // (See discussion above where both OldFile and NewFile are signed and versioned, and OldFile is newer.  Note
    //             // that something funny is going on if we've been asked to replace a versionable file with an unversionable one!)
    //             //
    //             overwrite OldFile
    //         } else {  // OldFile isn't signed
    //             overwrite OldFile
    //         }
    //     } else {  // OldFile isn't versioned either
    //         overwrite OldFile
    //     }
    // }
    //

    //
    // Check to see if the source file is signed.  (Note--we may have already
    // checked this previously in determining whether an SIS link could be
    // created.  If we failed to verify the file's digital signature then,
    // there's no use in re-verifying here.)
    //
    if(*SignatureVerifyFailed) {
        //
        // We saved the signature verification failure error when we previously
        // attempted to verify this file.  Restore that code to rc now, because
        // the code below relies on the value of rc.
        //
        MYASSERT(SigVerifRc != NO_ERROR);
        rc = SigVerifRc;

    } else {

        if(Queue) {

            ValidationPlatform = (Queue->Flags & FQF_USE_ALT_PLATFORM)
                                    ? &(Queue->AltPlatformInfo)
                                    : Queue->ValidationPlatform;
        } else {
            //
            // Since we aren't dealing with a queue, we need to retrieve the
            // appropriate validation platform information, if any, for our INF.
            //
            DoingDeviceInstall = IsInfForDeviceInstall(
                                     lc,
                                     NULL,
                                     LoadedInf,
                                     &DeviceDesc,
                                     &ValidationPlatform,
                                     &DriverSigningPolicy,
                                     NULL,
                                     TRUE // use non-driver signing policy unless it's a WHQL class
                                    );
        }

        rc = VerifySourceFile(lc,
                              Queue,
                              QueueNode,
                              pSetupGetFileTitle(FullTargetFilename),
                              TemporaryTargetFile,
                              FullSourceFilename,
                              ValidationPlatform,
                              0,
                              &Problem,
                              Buffer1,
                              NULL,
                              NULL,
                              NULL,
                              NULL
                             );

        if(rc != NO_ERROR) {

            if(Queue) {
                //
                // If policy is forced to Block, then we don't even try to
                // validate the file using Authenticode policy.  This is done by
                // Windows File Protection, for example, which doesn't respect
                // Authenticode signatures, and we mustn't either.
                //
                if(Queue->Flags & FQF_QUEUE_FORCE_BLOCK_POLICY) {
                    *SignatureVerifyFailed = TRUE;
                    goto clean4;
                }

                if(IsFileProtected(FullTargetFilename, lc, NULL)) {
                    //
                    // If the file is protected, then Authenticode can't save 
                    // us!
                    //
                    *SignatureVerifyFailed = TRUE;

                    if(QueueNode && QueueNode->CatalogInfo) {
                        //
                        // We never allow Authenticode-signed files to replace
                        // system-protected files.  In fact, when we detect 
                        // such a trick, we abort the whole installation!
                        //
                        if(QueueNode->CatalogInfo->Flags & CATINFO_FLAG_AUTHENTICODE_SIGNED) {

                            WriteLogEntry(lc,
                                          SETUP_LOG_ERROR,
                                          MSG_LOG_AUTHENTICODE_SIGNATURE_BLOCKED_FOR_SFC,
                                          NULL,
                                          FullTargetFilename
                                         );
                            goto clean4;
                        }
                    }

                } else {
                    //
                    // If the file may be validated by an Authenticode-signed
                    // catalog, then check for that now.  If that validation 
                    // fails, then we simply want to bail, because that 
                    // indicates tampering.  At this point, we've already 
                    // confirmed that the signer should be trusted, so there's 
                    // no need for UI (i.e., we don't need to call 
                    // _HandleFailedVerification).
                    //
                    if((rc != ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH) &&
                       QueueNode && 
                       QueueNode->CatalogInfo &&
                       (QueueNode->CatalogInfo->Flags & CATINFO_FLAG_AUTHENTICODE_SIGNED)) {

                        rc = VerifySourceFile(lc,
                                              Queue,
                                              QueueNode,
                                              pSetupGetFileTitle(FullTargetFilename),
                                              TemporaryTargetFile,
                                              FullSourceFilename,
                                              ValidationPlatform,
                                              VERIFY_FILE_USE_AUTHENTICODE_CATALOG,
                                              &Problem,
                                              Buffer1,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL
                                             );

                        if((rc == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                           (rc == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {

                            rc = NO_ERROR;

                        } else {
                            *SignatureVerifyFailed = TRUE;
                            goto clean4;
                        }

                    } else {
                        //
                        // File isn't associated with an Authenticode catalog, 
                        // so we can finally say with certainty we had a 
                        // signature verification failure.
                        //
                        *SignatureVerifyFailed = TRUE;
                    }
                }

            } else {
                //
                // We don't have a queue, so we know there's no possibility of
                // validating via an Authenticode catalog.
                //
                *SignatureVerifyFailed = TRUE;
            }
        }
    }

    //
    // Don't muck with the value of rc below unless you're setting it
    // immediately before jumping to clean4.  The return value from
    // VerifySourceFile needs to be preserved until we finish with the
    // _HandleFailedVerification stuff.
    //

    //
    // If we are going to perform version checks, fetch the version data
    // of the source (which is now the temporary target file).
    //
    NotifyFlags = 0;
    if(ExistingFile) {

        param = 0;

        //
        // If we're not supposed to overwrite existing files,
        // then the overwrite check fails.
        //
        if(CopyStyle & SP_COPY_NOOVERWRITE) {
            NotifyFlags |= SPFILENOTIFY_TARGETEXISTS;
        }

        //
        // Even if the source file has a verified digital signature, we still
        // want to retrieve version information for the source and target.  We
        // do this so that we can detect when we've overwritten a newer-
        // versioned file with an older-versioned one.  If we discover that
        // this is the case, then we generate an exception log entry that will
        // help PSS troubleshoot any problems that result.
        //
        if(!GetVersionInfoFromImage(TemporaryTargetFile, &SourceVersion, &SourceLanguage)) {
            SourceVersion = 0;
            SourceLanguage = 0;
        }

        //
        // If we're not supposed to overwrite files in a different language
        // and the languages differ, then the language check fails.
        // If either file doesn't have language data, then don't do a language
        // check.
        //
        //
        // Special case:
        //
        // If
        //  a) the source version is greater than the target version
        //  b) the source doesn't have a lang id
        //  c) the target does have a lang id
        // Then
        //  we will do a language check, and we will consider this language check
        //  as passed since we are replacing an older language specific file with
        //  a language neutral file, which is an OK thing.
        //
        //
        if(CopyStyle & SP_COPY_LANGUAGEAWARE) {
            if ( SourceLanguage
                 && TargetLanguage
                 && (SourceLanguage != TargetLanguage) ) {

                NotifyFlags |= SPFILENOTIFY_LANGMISMATCH;
                param = (UINT)MAKELONG(SourceLanguage, TargetLanguage);

            } else if ( !SourceLanguage
                        && TargetLanguage
                        && (TargetVersion >= SourceVersion) ) {

                NotifyFlags |= SPFILENOTIFY_LANGMISMATCH;
                param = (UINT)MAKELONG(SourceLanguage, TargetLanguage);

            }

        }


        //
        // If we're not supposed to overwrite newer versions and the target is
        // newer than the source, then the version check fails. If either file
        // doesn't have version info, fall back to timestamp comparison.
        //
        // If the files are the same version/timestamp, assume that either
        // replacing the existing one is a benevolent operation, or that
        // we are upgrading an existing file whose version info is unimportant.
        // In this case we just go ahead and copy the file (unless the
        // SP_COPY_NEWER_ONLY flag is set).
        //
        // Note that the version checks below are made without regard to presence
        // or absence of digital signatures on either the source or target files.
        // That will be handled later.  We want to see what would've happened
        // without driver signing, so we can generate a PSS exception log when
        // something weird happens.
        //
        if(SourceVersion || TargetVersion) {

            b = (CopyStyle & SP_COPY_NEWER_ONLY)
              ? (TargetVersion >= SourceVersion)
              : (TargetVersion > SourceVersion);

        } else {
            //
            // Assume the target file is older.  Doing timestamp-based checking
            // is simply too unreliable.
            //
            b  = FALSE;
        }

        //
        // At this point, if b is TRUE then the target file has a later (newer)
        // version than the sourcefile.  If we've been asked to pay attention 
        // to that, then set the NotifyFlags to indicate this problem.
        // Note that this may get reset later if the source file is signed.  We
        // still wanted to get this information so we could put it in our PSS
        // logfile.
        //
        if(b &&
           (CopyStyle & (SP_COPY_NEWER_OR_SAME | SP_COPY_NEWER_ONLY | SP_COPY_FORCE_NEWER))) {

            NotifyFlags |= SPFILENOTIFY_TARGETNEWER;
        }
    }

    if(NotifyFlags & SPFILENOTIFY_TARGETNEWER) {

        if(!*SignatureVerifyFailed) {
            //
            // Source file is signed, but the target file is newer.  We know
            // that we still want to replace the existing targetfile with the
            // sourcefile, regardless of version numbers.  However, we need to
            // make note of that in our PSS logfile.
            //
            NotifyFlags &= ~SPFILENOTIFY_TARGETNEWER;

            //
            // Check to see if the target file is signed, in order to include
            // this information in our PSS logfile.
            //
            ExistingTargetFileWasSigned = 
                (NO_ERROR == _VerifyFile(lc,
                                         (Queue
                                             ? &(Queue->VerifyContext) 
                                             : NULL),
                                         NULL,
                                         NULL,
                                         0,
                                         pSetupGetFileTitle(FullTargetFilename),
                                         ExistingFile,
                                         NULL,
                                         NULL,
                                         FALSE,
                                         ValidationPlatform,
                                         (VERIFY_FILE_USE_OEM_CATALOGS 
                                          | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL,
                                         NULL));

            //
            // SPLOG -- report that newer target was overwritten by older (signed)
            // source, whether target was signed, both files' versions, etc.
            // Also probably want to throw in the fact that the SP_COPY_FORCE_NEWER
            // flag was ignored, if it's set.
            //
            pGetVersionText(SourceVersionText,SourceVersion);
            pGetVersionText(TargetVersionText,TargetVersion);
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                MSG_LOG_NEWER_FILE_OVERWRITTEN,
                NULL,
                FullTargetFilename,
                SourceVersionText,
                TargetVersionText);

            if (CopyStyle & SP_COPY_FORCE_NEWER) {
                WriteLogEntry(
                    lc,
                    SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                    MSG_LOG_FLAG_FORCE_NEWER_IGNORED,
                    NULL);
            }
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                (ExistingTargetFileWasSigned ?
                    MSG_LOG_TARGET_WAS_SIGNED :
                    MSG_LOG_TARGET_WAS_NOT_SIGNED),
                NULL);
            //
            // flush the log buffer
            //
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING,
                0,
                TEXT("\n"));

        } else {
            //
            // Source file isn't signed, so we'll let the old behavior apply.
            // If version dialogs are allowed, for example, the user will be
            // prompted that they're attempting to overwrite a newer file with 
            // an older one.  If they say "go ahead and copy over the older 
            // version", _then_ they'll get a prompt about the file not having 
            // a valid signature.
            //
            // Check special case where a flag is set indicating that we should
            // just silently not copy the newer file.
            //
            if(CopyStyle & SP_COPY_FORCE_NEWER) {
                //
                // Target is newer; don't copy the file.
                //
                rc = NO_ERROR;
                goto clean4;
            }

        }
    }

    //
    // If we have any reason to notify the caller via the callback,
    // do that here. If there is no callback, then don't copy the file,
    // because one of the conditions has not been met.
    //
    if((NotifyFlags & SPFILENOTIFY_LANGMISMATCH) && ! *SignatureVerifyFailed) {
        //
        // if the source was signed, we will ignore a language mismatch
        // as this is a package deal
        // NTRAID9#498046-2001/11/20-JamieHun handle LANGMISMATCH better
        //
        NotifyFlags &=~SPFILENOTIFY_LANGMISMATCH;
        WriteLogEntry(
            lc,
            SETUP_LOG_WARNING,
            MSG_LOG_LANGMISMATCH_IGNORED,
            NULL,
            FullTargetFilename,
            SourceLanguage,
            TargetLanguage);

    }
    if(NotifyFlags) {

        FilePaths.Source = FullSourceFilename;
        FilePaths.Target = FullTargetFilename;
        FilePaths.Win32Error = NO_ERROR;

        if(!CopyMsgHandler
        || !pSetupCallMsgHandler(
                lc,
                CopyMsgHandler,
                IsMsgHandlerNativeCharWidth,
                Context,
                NotifyFlags,
                (UINT_PTR)&FilePaths,
                param))
        {
            if(ExistingFile) {
                //
                // Check to see if the target file is signed, in order to 
                // include this information in our PSS logfile.
                //
                ExistingTargetFileWasSigned = 
                    (NO_ERROR == _VerifyFile(lc,
                                             (Queue 
                                                 ? &(Queue->VerifyContext) 
                                                 : NULL),
                                             NULL,
                                             NULL,
                                             0,
                                             pSetupGetFileTitle(FullTargetFilename),
                                             ExistingFile,
                                             NULL,
                                             NULL,
                                             FALSE,
                                             ValidationPlatform,
                                             (VERIFY_FILE_USE_OEM_CATALOGS 
                                              | VERIFY_FILE_NO_DRIVERBLOCKED_CHECK),
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL));
            }

            //
            // SPLOG -- error that occurred, info on whether source and target
            // files were signed, what their versions were, etc.
            //

            pGetVersionText(SourceVersionText,SourceVersion);
            pGetVersionText(TargetVersionText,TargetVersion);
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                MSG_LOG_FILE_NOT_OVERWRITTEN,
                NULL,
                SourceVersionText,
                TargetVersionText);
            if (NotifyFlags & SPFILENOTIFY_TARGETEXISTS) {
                WriteLogEntry(
                    lc,
                    SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                    MSG_LOG_NOTIFY_TARGETEXISTS,
                    NULL);
            }
            if (NotifyFlags & SPFILENOTIFY_LANGMISMATCH) {
                WriteLogEntry(
                    lc,
                    SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                    MSG_LOG_NOTIFY_LANGMISMATCH,
                    NULL);
            }
            if (NotifyFlags & SPFILENOTIFY_TARGETNEWER) {
                WriteLogEntry(
                    lc,
                    SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                    MSG_LOG_NOTIFY_TARGETNEWER,
                    NULL);
            }
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                (ExistingTargetFileWasSigned ?
                    MSG_LOG_TARGET_WAS_SIGNED :
                    MSG_LOG_TARGET_WAS_NOT_SIGNED),
                NULL);
            WriteLogEntry(
                lc,
                SETUP_LOG_WARNING | SETUP_LOG_BUFFER,
                (*SignatureVerifyFailed ?
                    MSG_LOG_SOURCE_WAS_NOT_SIGNED :
                    MSG_LOG_SOURCE_WAS_SIGNED),
                NULL);
            WriteLogError(
                lc,
                SETUP_LOG_WARNING,
                rc);

            rc = NO_ERROR;
            goto clean4;
        }
    }

    //
    // OK, now that all non-codesigning stuff is done, tell the user about
    // any digital signature problems we found with the source file.
    //
    // NOTE: If SigVerifRc is set to something other than NO_ERROR, then we 
    // know that the _HandleFailedVerification routine has already been 
    // called, thus we don't want to call it again or otherwise the user may 
    // get multiple prompts about a bad signature for the same file.
    //
    if(*SignatureVerifyFailed) {

        if(SigVerifRc == NO_ERROR) {

            MYASSERT(ExemptCopyFlags == 0);

            //
            // Save away the verification error in SigVerifRc, so we can use
            // this later to determine whether we're dealing with an unsigned
            // file.
            //
            MYASSERT(rc != NO_ERROR);
            SigVerifRc = rc;

            //
            // If we're using a file queue, then retrieve information from the
            // queue regarding policy, whether it's a device install (and if
            // so, what description to use), etc.  There's no need to do this
            // in the non-queue case, because we already did this previously.
            //
            if(Queue) {

                if(Queue->DeviceDescStringId != -1) {
                    DeviceDesc = pStringTableStringFromId(
                                     Queue->StringTable,
                                     Queue->DeviceDescStringId
                                    );
                    MYASSERT(DeviceDesc);
                } else {
                    DeviceDesc = NULL;
                }

                DoingDeviceInstall = Queue->Flags & FQF_DEVICE_INSTALL;
                DriverSigningPolicy = Queue->DriverSigningPolicy;
            }

            if(Problem != SetupapiVerifyDriverBlocked) {
                //
                // If this is a device installation and the policy is "Ignore",
                // then crank it up to "Warn" if the file is under SFP's
                // protection.  This will allow the user to update a driver 
                // that ships in our box for which no WHQL certification 
                // program exists.
                //
                if(DoingDeviceInstall && 
                   ((DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE) == DRIVERSIGN_NONE) &&
                   IsFileProtected(FullTargetFilename, lc, NULL)) {

                    //
                    // (We don't care if we blow away the Authenticode bit,
                    // since that's no longer an option now that we've caught
                    // an attempted replacement of a system-protected file!)
                    //
                    DriverSigningPolicy = DRIVERSIGN_WARNING;

                    //
                    // If we have a queue, update the queue's policy as well.
                    //
                    if(Queue) {
                        Queue->DriverSigningPolicy = DRIVERSIGN_WARNING;
                    }

                    //
                    // Log the fact that policy was elevated.
                    //
                    WriteLogEntry(lc,
                                  SETUP_LOG_ERROR,
                                  MSG_LOG_POLICY_ELEVATED_FOR_SFC,
                                  NULL
                                 );
                }
            }

            if(!_HandleFailedVerification(
                    (Queue ? Queue->hWndDriverSigningUi : NULL),
                    Problem,
                    (Problem == SetupapiVerifyDriverBlocked)
                      ? FullSourceFilename : Buffer1,
                    DeviceDesc,
                    DriverSigningPolicy,
                    (Queue ? (Queue->Flags & FQF_DIGSIG_ERRORS_NOUI) : FALSE),
                    rc,
                    lc,
                    (((Queue && (Queue->Flags & FQF_ABORT_IF_UNSIGNED)) &&
                      (Problem != SetupapiVerifyDriverBlocked))
                        ? NULL : &ExemptCopyFlags),
                    (((Queue && (Queue->Flags & FQF_ABORT_IF_UNSIGNED)) &&
                      (Problem != SetupapiVerifyDriverBlocked))
                        ? NULL : FullTargetFilename),
                    NULL))
            {
                //
                // User elected not to install the unsigned file (or was 
                // blocked by policy from doing so).
                //
                goto clean4;
            }
        }

        if(Queue) {
            //
            // If the caller wants a chance to set a system restore point prior
            // to doing any unsigned installations, then we abort now with a
            // "special" error code that tells them what to do...
            //
            if(Queue->Flags & FQF_ABORT_IF_UNSIGNED) {
                //
                // We don't want the user to see the driver signing UI again
                // when the queue is re-committed...
                //
                if((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE) 
                   != DRIVERSIGN_NONE) {

                    Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
                }

                rc = ERROR_SET_SYSTEM_RESTORE_POINT;
                goto clean4;
            }

            //
            // Set a flag in the queue that indicates the user has been 
            // informed of a signature problem with this queue, and has elected 
            // to go ahead and install anyway.  Don't set this flag if the 
            // queue's policy is "Ignore", on the chance that the policy might 
            // be altered later, and we'd want the user to get informed on any
            // subsequent errors.
            //
            if((Queue->DriverSigningPolicy & ~DRIVERSIGN_ALLOW_AUTHENTICODE) 
               != DRIVERSIGN_NONE) {

                Queue->Flags |= FQF_DIGSIG_ERRORS_NOUI;
            }

            if (QueueNode) {
                QueueNode->InternalFlags |= ExemptCopyFlags;
            }
        }

        //
        // Reset rc to NO_ERROR and carry on.
        //
        rc = NO_ERROR;
    }

    //
    // Move the target file into its final location.
    //
    SetFileAttributes(FullTargetFilename, FILE_ATTRIBUTE_NORMAL);

    if(Queue && ((Queue->Flags & FQF_FILES_MODIFIED)==0)) {
        //
        // so far we haven't flagged that any files are modified
        //
        if(CompareFile) {
            //
            // we have an "original" file
            //
            if(pCompareFilesExact(TemporaryTargetFile,CompareFile)) {
                //
                // new file of this name is same as original file of same name
                //
                if(CompareSameFilename) {
                    //
                    // original is already in place
                    // don't need to do a delayed-rename
                    //
                    FileUnchanged = TRUE;
                }
            } else {
                //
                // file appears to have been modified
                //
                Queue->Flags |= FQF_FILES_MODIFIED;
            }
        } else {
            //
            // be safe, copying over nothing = modified
            //
            Queue->Flags |= FQF_FILES_MODIFIED;
        }
    }


    //
    // If the target exists and the force-in-use flag is set, then don't try to
    // move the file into place now -- automatically drop into in-use behavior.
    //
    // Want to use MoveFileEx but it didn't exist in Win95. Ugh.
    //
    if(!(ExistingFile && (CopyStyle & SP_COPY_FORCE_IN_USE))
        && (b = DoMove(TemporaryTargetFile, FullTargetFilename))) {
        //
        // Place security information on the target file if necessary.
        // Ignore errors. The theory here is that the file is already on
        // the target, so if this fails the worst case is that the file is
        // not secure. But the user can still use the system.
        //
        if(SecurityInfo) {
            DWORD err = StampFileSecurity(FullTargetFilename, SecurityInfo);
            if(err != NO_ERROR) {
                WriteLogEntry(lc,
                              SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                              MSG_LOG_FILE_SECURITY_FAILED,
                              NULL,
                              FullTargetFilename
                             );
                WriteLogError(lc,SETUP_LOG_ERROR,err);
            } else {
                WriteLogEntry(lc,
                              SETUP_LOG_VERBOSE,
                              MSG_LOG_SET_FILE_SECURITY,
                              NULL,
                              FullTargetFilename
                             );
            }
        }
    } else {
        //
        // If this fails, assume the file is in use and mark it for copy on next
        // boot (except in the case where we're copying a boot file, in which
        // case this is a catastrophic failure).
        //
        if(ExistingFile != FullTargetFilename) {

            WriteLogEntry(lc,
                          SETUP_LOG_ERROR,
                          MSG_LOG_REPLACE_BOOT_FILE_FAILED,
                          NULL,
                          FullTargetFilename
                         );

            b = FALSE;
            SetLastError(ERROR_ACCESS_DENIED);
        } else if (((CopyStyle & SP_COPY_FORCE_IN_USE) == 0) &&
                   (FileUnchanged || pCompareFilesExact(TemporaryTargetFile,FullTargetFilename))) {
            //
            // It turns out that new file and old file are exactly the same
            // we can optimize out the delayed move and delete the temporary file
            //
            WriteLogEntry(lc,
                          SETUP_LOG_INFO,
                          MSG_LOG_COPY_IDENTICAL,
                          NULL,
                          FullTargetFilename,
                          TemporaryTargetFile
                         );

            if(SecurityInfo) {
                //
                // we still need to adjust security on it though
                //
                DWORD err = StampFileSecurity(FullTargetFilename, SecurityInfo);
                if(err != NO_ERROR) {
                    WriteLogEntry(lc,
                                  SETUP_LOG_ERROR | SETUP_LOG_BUFFER,
                                  MSG_LOG_FILE_SECURITY_FAILED,
                                  NULL,
                                  FullTargetFilename
                                 );
                    WriteLogError(lc,SETUP_LOG_ERROR,err);
                } else {
                    WriteLogEntry(lc,
                                  SETUP_LOG_VERBOSE,
                                  MSG_LOG_SET_FILE_SECURITY,
                                  NULL,
                                  FullTargetFilename
                                 );
                }
            }

            SetFileAttributes(TemporaryTargetFile, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(TemporaryTargetFile);

            b = TRUE;

        } else {
            b = TRUE;
            try {
                *FileWasInUse = TRUE;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                b = FALSE;
            }

            if(b) {
                //
                // If we're trying to do a delayed move to replace a protected
                // system file (using an unsigned one), and we've not been
                // granted an exception to do so, then we should skip the
                // operation altogether (and make a log entry about it)
                //
                if((SigVerifRc != NO_ERROR) &&
                   ((ExemptCopyFlags & (IQF_TARGET_PROTECTED | IQF_ALLOW_UNSIGNED)) == IQF_TARGET_PROTECTED)) {

                    WriteLogEntry(lc,
                                  SETUP_LOG_ERROR,
                                  MSG_LOG_DELAYED_MOVE_SKIPPED_FOR_SFC,
                                  NULL,
                                  FullTargetFilename
                                  );

                    //
                    // Delete the source file.
                    //

                    SetFileAttributes(TemporaryTargetFile, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile(TemporaryTargetFile);

                } else {

                    BOOL TargetIsProtected = IsFileProtected(FullTargetFilename, lc, NULL);

                    if(Queue == NULL) {

                        b = DelayedMove(
                                TemporaryTargetFile,
                                FullTargetFilename
                                );

                        if(b && TargetIsProtected) {
                            //
                            // we have to explicitly tell the session manager it's ok
                            // to replace the changed files on reboot.
                            //
                            // in the case that we're using a queue, we post the
                            // delayed move and set this flag only if all the delayed
                            // move operations succeed
                            //
                            pSetupProtectedRenamesFlag(TRUE);
                        }
                    } else {
                        b = PostDelayedMove(
                                Queue,
                                TemporaryTargetFile,
                                FullTargetFilename,
                                QueueNode->SecurityDesc,
                                TargetIsProtected
                                );
                    }

                    if(b) {
                        //
                        // Couldn't set security info on the actual target, so at least
                        // set it on the temp file that will become the target.
                        //
                        if(SecurityInfo) {
                            StampFileSecurity(TemporaryTargetFile,SecurityInfo);
                        }

                        if (lc) {
                            WriteLogEntry(lc,
                                          SETUP_LOG_WARNING,
                                          MSG_LOG_COPY_DELAYED,
                                          NULL,
                                          FullTargetFilename,
                                          TemporaryTargetFile
                                          );
                        }

                        //
                        // Tell the callback that we queued this file for delayed copy.
                        //
                        if(CopyMsgHandler) {

                            FilePaths.Source = TemporaryTargetFile;
                            FilePaths.Target = FullTargetFilename;
                            FilePaths.Win32Error = NO_ERROR;
                            FilePaths.Flags = FILEOP_COPY;

                            pSetupCallMsgHandler(
                                lc,
                                CopyMsgHandler,
                                IsMsgHandlerNativeCharWidth,
                                Context,
                                SPFILENOTIFY_FILEOPDELAYED,
                                (UINT_PTR)&FilePaths,
                                0
                                );
                        }
                    }
                }

            } else {
                //
                // FileWasInUse pointer went bad
                //
                SetLastError(ERROR_INVALID_PARAMETER);
            }
        }
    }

    if(!b) {
        rc = GetLastError();
        goto clean4;
    }

    //
    // We're done. Delete the source if necessary and return.
    //
    if((CopyStyle & SP_COPY_DELETESOURCE) && !Moved) {
        DeleteFile(FullSourceFilename);
    }

    rc = NO_ERROR;
    Ok = TRUE;
    goto clean3;

clean4:
    //
    // Remove temporary target file.
    // In case pSetupDecompressOrCopyFile MoveFile'd the source,
    // we really need to try to move it back, so the source file isn't
    // blown away when this routine fails.
    //
    if(Moved) {
        MoveFile(TemporaryTargetFile,FullSourceFilename);
    } else {
        SetFileAttributes(TemporaryTargetFile,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(TemporaryTargetFile);
    }

clean3:
    MyFree(TemporaryTargetFile);
    //
    // If we didn't have a file queue, then we may have allocated a device
    // description and validation platform structure when we called
    // IsInfForDeviceInstall.  Clean those up now.
    //
    if(!Queue) {
        if(DeviceDesc) {
            MyFree(DeviceDesc);
        }
        if(ValidationPlatform) {
            MyFree(ValidationPlatform);
        }
    }

clean2:
    if (BackupFileName) {
        MyFree(BackupFileName);
    }
    MyFree(FullTargetFilename);

clean1:
    MyFree(FullSourceFilename);

clean0:
    if(SecurityInfo) {
        MyFree(SecurityInfo);
    }
    //
    // if there was an error of some sort, log it
    //
    if(rc != NO_ERROR) {
        //
        // maybe we ought to embelish this a bit.
        //
        WriteLogEntry(
            lc,
            SETUP_LOG_ERROR,
            rc,
            NULL);
    }

    if(slot_fileop) {
        ReleaseLogInfoSlot(lc, slot_fileop);
    }

    if(LoadedInf) {
        UnlockInf(LoadedInf);
    }

    SetLastError(rc);
    return(Ok);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupInstallFileExA(
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCSTR               SourceFile,        OPTIONAL
    IN  PCSTR               SourcePathRoot,    OPTIONAL
    IN  PCSTR               DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PSP_FILE_CALLBACK_A CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse
    )
{
    PCWSTR sourceFile,sourcePathRoot,destinationName;
    BOOL b, DontCare;
    DWORD rc;

    sourceFile = NULL;
    sourcePathRoot = NULL;
    destinationName = NULL;
    rc = NO_ERROR;

    if(SourceFile) {
        rc = pSetupCaptureAndConvertAnsiArg(SourceFile,&sourceFile);
    }
    if((rc == NO_ERROR) && SourcePathRoot) {
        rc = pSetupCaptureAndConvertAnsiArg(SourcePathRoot,&sourcePathRoot);
    }
    if((rc == NO_ERROR) && DestinationName) {
        rc = pSetupCaptureAndConvertAnsiArg(DestinationName,&destinationName);
    }

    if(rc == NO_ERROR) {

        b = _SetupInstallFileEx(
                NULL,
                NULL,
                InfHandle,
                InfContext,
                sourceFile,
                sourcePathRoot,
                destinationName,
                CopyStyle,
                CopyMsgHandler,
                Context,
                FileWasInUse,
                FALSE,
                &DontCare
                );

        rc = b ? NO_ERROR : GetLastError();

    } else {
        b = FALSE;
    }

    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(sourcePathRoot) {
        MyFree(sourcePathRoot);
    }
    if(destinationName) {
        MyFree(destinationName);
    }
    SetLastError(rc);
    return b;
}
#else
//
// Unicode stub
//
BOOL
SetupInstallFileExW(
    IN  HINF                InfHandle,         OPTIONAL
    IN  PINFCONTEXT         InfContext,        OPTIONAL
    IN  PCWSTR              SourceFile,        OPTIONAL
    IN  PCWSTR              SourcePathRoot,    OPTIONAL
    IN  PCWSTR              DestinationName,   OPTIONAL
    IN  DWORD               CopyStyle,
    IN  PSP_FILE_CALLBACK_W CopyMsgHandler,    OPTIONAL
    IN  PVOID               Context,           OPTIONAL
    OUT PBOOL               FileWasInUse
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfContext);
    UNREFERENCED_PARAMETER(SourceFile);
    UNREFERENCED_PARAMETER(SourcePathRoot);
    UNREFERENCED_PARAMETER(DestinationName);
    UNREFERENCED_PARAMETER(CopyStyle);
    UNREFERENCED_PARAMETER(CopyMsgHandler);
    UNREFERENCED_PARAMETER(Context);
    UNREFERENCED_PARAMETER(FileWasInUse);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupInstallFileEx(
    IN  HINF              InfHandle,         OPTIONAL
    IN  PINFCONTEXT       InfContext,        OPTIONAL
    IN  PCTSTR            SourceFile,        OPTIONAL
    IN  PCTSTR            SourcePathRoot,    OPTIONAL
    IN  PCTSTR            DestinationName,   OPTIONAL
    IN  DWORD             CopyStyle,
    IN  PSP_FILE_CALLBACK CopyMsgHandler,    OPTIONAL
    IN  PVOID             Context,           OPTIONAL
    OUT PBOOL             FileWasInUse
    )

/*++

Routine Description:

    Same as SetupInstallFile().

Arguments:

    Same as SetupInstallFile().

    FileWasInUse - receives flag indicating whether the file was in use.

Return Value:

    Same as SetupInstallFile().

--*/

{
    BOOL b, DontCare;
    PCTSTR sourceFile,sourcePathRoot,destinationName;
    PCTSTR p;
    DWORD rc;

    //
    // Capture args.
    //
    if(SourceFile) {
        rc = CaptureStringArg(SourceFile,&p);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return FALSE;
        }
        sourceFile = p;
    } else {
        sourceFile = NULL;
    }

    if(SourcePathRoot) {
        rc = CaptureStringArg(SourcePathRoot,&p);
        if(rc != NO_ERROR) {
            if(sourceFile) {
                MyFree(sourceFile);
            }
            SetLastError(rc);
            return FALSE;
        }
        sourcePathRoot = p;
    } else {
        sourcePathRoot = NULL;
    }

    if(DestinationName) {
        rc = CaptureStringArg(DestinationName,&p);
        if(rc != NO_ERROR) {
            if(sourceFile) {
                MyFree(sourceFile);
            }
            if(sourcePathRoot) {
                MyFree(sourcePathRoot);
            }
            SetLastError(rc);
            return FALSE;
        }
        destinationName = p;
    } else {
        destinationName = NULL;
    }

    b = _SetupInstallFileEx(
            NULL,
            NULL,
            InfHandle,
            InfContext,
            sourceFile,
            sourcePathRoot,
            destinationName,
            CopyStyle,
            CopyMsgHandler,
            Context,
            FileWasInUse,
            TRUE,
            &DontCare
            );

    //
    // We GetLastError and then set it back again before returning, so that
    // the memory frees we do below can't blow away the error code.
    //
    rc = b ? NO_ERROR : GetLastError();

    if(sourceFile) {
        MyFree(sourceFile);
    }
    if(sourcePathRoot) {
        MyFree(sourcePathRoot);
    }
    if(destinationName) {
        MyFree(destinationName);
    }

    SetLastError(rc);
    return b;
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
SetupInstallFileA(
    IN HINF                InfHandle,         OPTIONAL
    IN PINFCONTEXT         InfContext,        OPTIONAL
    IN PCSTR               SourceFile,        OPTIONAL
    IN PCSTR               SourcePathRoot,    OPTIONAL
    IN PCSTR               DestinationName,   OPTIONAL
    IN DWORD               CopyStyle,
    IN PSP_FILE_CALLBACK_A CopyMsgHandler,    OPTIONAL
    IN PVOID               Context            OPTIONAL
    )
{
    BOOL b;
    BOOL InUse;

    b = SetupInstallFileExA(
            InfHandle,
            InfContext,
            SourceFile,
            SourcePathRoot,
            DestinationName,
            CopyStyle,
            CopyMsgHandler,
            Context,
            &InUse
            );

    return(b);
}
#else
//
// Unicode stub
//
BOOL
SetupInstallFileW(
    IN HINF                InfHandle,         OPTIONAL
    IN PINFCONTEXT         InfContext,        OPTIONAL
    IN PCWSTR              SourceFile,        OPTIONAL
    IN PCWSTR              SourcePathRoot,    OPTIONAL
    IN PCWSTR              DestinationName,   OPTIONAL
    IN DWORD               CopyStyle,
    IN PSP_FILE_CALLBACK_W CopyMsgHandler,    OPTIONAL
    IN PVOID               Context            OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(InfHandle);
    UNREFERENCED_PARAMETER(InfContext);
    UNREFERENCED_PARAMETER(SourceFile);
    UNREFERENCED_PARAMETER(SourcePathRoot);
    UNREFERENCED_PARAMETER(DestinationName);
    UNREFERENCED_PARAMETER(CopyStyle);
    UNREFERENCED_PARAMETER(CopyMsgHandler);
    UNREFERENCED_PARAMETER(Context);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return(FALSE);
}
#endif


BOOL
SetupInstallFile(
    IN HINF              InfHandle,         OPTIONAL
    IN PINFCONTEXT       InfContext,        OPTIONAL
    IN PCTSTR            SourceFile,        OPTIONAL
    IN PCTSTR            SourcePathRoot,    OPTIONAL
    IN PCTSTR            DestinationName,   OPTIONAL
    IN DWORD             CopyStyle,
    IN PSP_FILE_CALLBACK CopyMsgHandler,    OPTIONAL
    IN PVOID             Context            OPTIONAL
    )

/*++

Routine Description:

    Note: no disk prompting is performed by this routine. The caller must
    ensure that the source specified in SourcePathRoot or SourceFile
    (see below) is accessible.

Arguments:

    InfHandle - handle of inf file containing [SourceDisksNames]
        and [SourceDisksFiles] sections. If InfContext is not specified
        and CopyFlags includes SP_COPY_SOURCE_ABSOLUTE or
        SP_COPY_SOURCEPATH_ABSOLUTE, then InfHandle is ignored.

    InfContext - if specified, supplies context for a line in a copy file
        section in an inf file. The routine looks this file up in the
        [SourceDisksFiles] section of InfHandle to get file copy info.
        If not specified, SourceFile must be.  If this parameter is specified,
        then InfHandle must also be specified.

    SourceFile - if specified, supplies the file name (no path) of the file
        to be copied. The file is looked up in [SourceDisksFiles].
        Must be specified if InfContext is not; ignored if InfContext
        is specified.

    SourcePathRoot - Supplies the root path for the source (for example,
        a:\ or f:\).  Paths in [SourceDisksNames] are appended to this path.
        Ignored if CopyStyle includes SP_COPY_SOURCE_ABSOLUTE.

    DestinationName - if InfContext is specified, supplies the filename only
        (no path) of the target file. Can be NULL to indicate that the
        target file is to have the same name as the source file. If InfContext is
        not specified, supplies the full target path and filename for the target
        file.

    CopyStyle - supplies flags that control the behavior of the copy operation.

        SP_COPY_DELETESOURCE - Delete the source file upon successful copy.
            The caller receives no notification if the delete fails.

        SP_COPY_REPLACEONLY - Copy the file only if doing so would overwrite
            a file at the destination path.

        SP_COPY_NEWER - Examine each file being copied to see if its version resources
            (or timestamps for non-image files) indicate that it it is not newer than
            an existing copy on the target. If so, and a CopyMsgHandler is specified,
            the caller is notified and may veto the copy. If CopyMsgHandler is not
            specified, the file is not copied.

        SP_COPY_NOOVERWRITE - Check whether the target file exists, and, if so,
            notify the caller who may veto the copy. If no CopyMsgHandler is specified,
            the file is not overwritten.

        SP_COPY_NODECOMP - Do not decompress the file. When this option is given,
            the target file is not given the uncompressed form of the source name
            (if appropriate). For example, copying f:\mips\cmd.ex_ to \\foo\bar
            will result a target file \\foo\bar\cmd.ex_. (If this flag wasn't specified
            the file would be decompressed and the target would be called
            \\foo\bar\cmd.exe). The filename part of the target file name
            is stripped and replaced with the filename of the soruce. When this option
            is given, SP_COPY_LANGUAGEAWARE and SP_COPY_NEWER are ignored.

        SP_COPY_ALREADYDECOMP - assume file to be decompressed but may have
            compressed source name. In this case, rename the file on copy and
            check SP_COPY_LANGUAGEAWARE/SP_COPY_NEWER, but don't attempt to
            decompress the file any further.

        SP_COPY_LANGUAGEAWARE - Examine each file being copied to see if its language
            differs from the language of any existing file already on the target.
            If so, and a CopyMsgHandler is specified, the caller is notified and
            may veto the copy. If CopyMsgHandler is not specified, the file is not copied.

        SP_COPY_SOURCE_ABSOLUTE - SourceFile is a full source path.
            Do not attempt to look it up in [SourceDisksNames].

        SP_COPY_SOURCEPATH_ABSOLUTE - SourcePathRoot is the full path part of the
            source file. Ignore the relative source specified in the [SourceDisksNames]
            section of the inf file for the source media where the file is located.
            Ignored if SP_COPY_SOURCE_ABSOLUTE is specified.

        SP_COPY_FORCE_IN_USE - if the target exists, behave as if it is in use and
            queue the file for copy on next reboot.

    CopyMsgHandler - if specified, supplies a callback function to be notified of
        various conditions that may arise during the file copy.

    Context - supplies a caller-defined value to be passed as the first
        parameter to CopyMsgHandler.

Return Value:

    TRUE if a file was copied. FALSE if not. Use GetLastError for extended
    error information. If GetLastError returns NO_ERROR, then the file copy was
    aborted because (a) it wasn't needed or (b) a callback function returned
    FALSE.

--*/

{
    BOOL b;
    BOOL InUse;

    b = SetupInstallFileEx(
            InfHandle,
            InfContext,
            SourceFile,
            SourcePathRoot,
            DestinationName,
            CopyStyle,
            CopyMsgHandler,
            Context,
            &InUse
            );

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\decomp.c ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    decomp.c

Abstract:

    File decompression support routines.

Author:

    Ted Miller (tedm) 1-Feb-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#include <pshpack1.h>
struct LZINFO;
typedef struct LZINFO *PLZINFO;
#include <lz_header.h>
#include <poppack.h>


typedef struct _SFD_INFO {
    unsigned FileCount;
    PCTSTR TargetFile;
    BOOL GotTimestamp;
    FILETIME FileTime;
} SFD_INFO, *PSFD_INFO;


UINT
pGetCompressInfoCB(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    );

UINT
pSingleFileDecompCB(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    );

//
// OldMyMalloc/OldMyFree used by SetupGetFileCompressionInfo
// for app-compat
//
PVOID
OldMyMalloc(
    IN DWORD Size
    );

VOID
OldMyFree(
    IN PVOID Block
    );

PTSTR
SetupGenerateCompressedName(
    IN PCTSTR Filename
    )

/*++

Routine Description:

    Given a filename, generate the compressed form of the name.
    The compressed form is generated as follows:

    Look backwards for a dot.  If there is no dot, append "._" to the name.
    If there is a dot followed by 0, 1, or 2 charcaters, append "_".
    Otherwise there is a 3-character or greater extension and we replace
    the last character with "_".

Arguments:

    Filename - supplies filename whose compressed form is desired.

Return Value:

    Pointer to buffer containing nul-terminated compressed-form filename.
    The caller must free this buffer via MyFree().

--*/

{
    PTSTR CompressedName,p,q;
    UINT u;

    //
    // The maximum length of the compressed filename is the length of the
    // original name plus 2 (for ._).
    //
    if(CompressedName = MyMalloc((lstrlen(Filename)+3)*sizeof(TCHAR))) {

        lstrcpy(CompressedName,Filename);

        p = _tcsrchr(CompressedName,TEXT('.'));
        q = _tcsrchr(CompressedName,TEXT('\\'));
        if(q < p) {

            //
            // If there are 0, 1, or 2 characters after the dot, just append
            // the underscore.  p points to the dot so include that in the length.
            //
            u = lstrlen(p);
            if(u < 4) {
                lstrcat(CompressedName,TEXT("_"));
            } else {
                //
                // There are at least 3 characters in the extension.
                // Replace the final one with an underscore.
                //
                p[u-1] = TEXT('_');
            }
        } else {
            //
            // No dot, just add ._.
            //
            lstrcat(CompressedName,TEXT("._"));
        }
    }

    return(CompressedName);
}


DWORD
pSetupAttemptLocate(
    IN  PCTSTR           FileName,
    OUT PBOOL            Found,
    OUT PWIN32_FIND_DATA FindData
    )

/*++

Routine Description:

    Attempt to locate a source file via FindFirstFile().

    Errors of the 'file not found' type are not considered errors
    and result in NO_ERROR. Any non-NO_ERROR return indicates that
    we could not determine whether the file is present or not
    because of some hardware or system problem, etc.

Arguments:

    FileName - supplies filename of the file to be located.

    Found - receives a value indicating whether the file was found.
        This value is only valid when the function returns NO_ERROR.

    FindData - if found, returns win32 find data for the file.

Return Value:

    Win32 error code indicating the outcome. If NO_ERROR, check
    the Found return value to see whether the file was found.

--*/

{
    DWORD d;

    if(*Found = FileExists(FileName,FindData)) {
        d = NO_ERROR;
    } else {
        //
        // We didn't find the file. See whether that was because
        // the file wasn't there or because some other error occured.
        //
        d = GetLastError();

        if((d == ERROR_NO_MORE_FILES)
        || (d == ERROR_FILE_NOT_FOUND)
        || (d == ERROR_PATH_NOT_FOUND)
        || (d == ERROR_BAD_NETPATH))
        {
            d = NO_ERROR;
        }
    }

    return(d);
}


DWORD
SetupDetermineSourceFileName(
    IN  PCTSTR            FileName,
    OUT PBOOL             UsedCompressedName,
    OUT PTSTR            *FileNameLocated,
    OUT PWIN32_FIND_DATA  FindData
    )

/*++

Routine Description:

    Attempt to locate a source file whose name can be compressed
    or uncompressed.

    The order of attempt is

    - the name as given (should be the uncompressed name)
    - the compressed form, using _ as the compression char
    - the compressed form, using $ as the compression char

Arguments:

    FileName - supplies filename of the file to be located.

    UsedCompressedName - receives a boolean indicating whether
        the filename we located seems to indicate that the file
        is compressed.

    FileNameLocated - receives a pointer to the filename actually
        located. The caller must free with MyFree().

    FindData - if found, returns win32 find data for the file.

Return Value:

    Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located; check UsedCompressedName and FileNameOpened.

    Others - something is wrong with the hardware or system.

--*/

{
    DWORD d;
    PTSTR TryName;
    BOOL Found;


    TryName = DuplicateString(FileName);
    if(!TryName) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *UsedCompressedName = FALSE;
    *FileNameLocated = TryName;

    d = pSetupAttemptLocate(TryName,&Found,FindData);
    if(d != NO_ERROR) {
        MyFree(TryName);
        *FileNameLocated = NULL;
        return(d);
    }

    if(Found) {
        return(NO_ERROR);
    }

    MyFree(TryName);
    *UsedCompressedName = TRUE;
    *FileNameLocated = NULL;

    TryName = SetupGenerateCompressedName(FileName);
    if(!TryName) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *FileNameLocated = TryName;

    d = pSetupAttemptLocate(TryName,&Found,FindData);
    if(d != NO_ERROR) {
        MyFree(TryName);
        *FileNameLocated = NULL;
        return(d);
    }

    if(Found) {
        return(NO_ERROR);
    }

    MYASSERT(TryName[lstrlen(TryName)-1] == TEXT('_'));
    TryName[lstrlen(TryName)-1] = TEXT('$');

    d = pSetupAttemptLocate(TryName,&Found,FindData);

    if((d != NO_ERROR) || !Found) {
        *FileNameLocated = NULL;
        MyFree(TryName);
    }

    return(Found ? NO_ERROR : ERROR_FILE_NOT_FOUND);
}

BOOL
pSetupDoesFileMatch(
    IN  PCTSTR            InputName,
    IN  PCTSTR            CompareName,
    OUT PBOOL             UsedCompressedName,
    OUT PTSTR            *FileNameLocated
    )

/*++

Routine Description:

    determine if the specified input file matches the
    name to compare it with.  We try the undecorated name
    as well as the compressed versions of the file name.

    The order of attempt is

    - the name as given (should be the uncompressed name)
    - the compressed form, using _ as the compression char
    - the compressed form, using $ as the compression char

Arguments:

    FileName - supplies filename we're looking at.

    CompareName -supplies the filename we're comparing against

    UsedCompressedName - receives a boolean indicating whether
        the filename we located seems to indicate that the file
        is compressed.

    FileNameLocated - receives a pointer to the filename actually
        located. The caller must free with MyFree().


Return Value:

    Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located; check UsedCompressedName and FileNameOpened.

    Others - something is wrong with the hardware or system.

--*/

{
    DWORD d;
    PTSTR TryName,TargetName,src,dst;
    BOOL Found;


    TryName = DuplicateString(InputName);
    if(!TryName) {
        return(FALSE);
    }

    TargetName = DuplicateString(CompareName);
    if(!TargetName) {
        MyFree(TryName);
        return(FALSE);
    }

    dst = _tcsrchr(TryName,TEXT('.'));
    if (dst) {
        *dst = 0;
    }
    src = _tcsrchr(TargetName,TEXT('.'));
    if (src) {
        *src = 0;
    }

    if (lstrcmpi(TargetName,TryName)) {
        // the "surnames" do not match, so none of the other comparisons will work.
        MyFree(TryName);
        MyFree(TargetName);
        return(FALSE);
    }

    if (dst) {
        *dst = TEXT('.');
    }

    if (src) {
        *src = TEXT('.');
    }

    *UsedCompressedName = FALSE;
    *FileNameLocated = TryName;

    if (!lstrcmpi(TryName,TargetName)) {
        // we matched
        MyFree(TargetName);
        return(TRUE);
    }

    MyFree(TryName);
    *UsedCompressedName = TRUE;

    TryName = SetupGenerateCompressedName(TargetName);
    if(!TryName) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    *FileNameLocated = TryName;

    if (!lstrcmpi(TryName,InputName)) {
        // we matched
        MyFree(TargetName);
        return(TRUE);
    }

    MYASSERT(TryName[lstrlen(TryName)-1] == TEXT('_'));
    TryName[lstrlen(TryName)-1] = TEXT('$');

    if (!lstrcmpi(TryName,InputName)) {
        // we matched
        MyFree(TargetName);
        return(TRUE);
    }

    //
    // no match
    //
    MyFree(TargetName);
    MyFree(TryName);

    return(FALSE);
}



DWORD
pSetupDecompressWinLzFile(
    IN PTSTR SourceFileName,
    IN PTSTR TargetFileName
    )

/*++

Routine Description:

    Determine whether a file is compressed, and retreive additional
    information about it.

Arguments:

    SourceFileName - supplies filename of the file to be checked.
        This filename is used as a base; if not found then we look
        for the 2 compressed forms (ie, foo.ex_, foo.ex$) as well.

    ActualSourceFileName - receives a pointer to the filename
        that was actually located. Caller can free with MyFree().
        Valid only if the return code from this routine is NO_ERROR.

    SourceFileSize - receives the size of the located file in its
        current (ie, compressed) form. Valid only if this routine
        returns NO_ERROR.

    TargetFileSize - receives the uncompressed size of the file.
        If the file is not compressed this will be the same as
        SourceFileSize. Valid only if this routine returns NO_ERROR.

    CompressionType - receives a value indicating the compression type.
        Valid only if this routine returns NO_ERROR.

Return Value:

    Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located and output params are filled in.

    Others - something is wrong with the hardware or system.

--*/

{
    INT hSrc,hDst;
    OFSTRUCT ofSrc,ofDst;
    LONG l;
    DWORD d;
    FILETIME CreateTime,AccessTime,WriteTime;

    //
    // Get the timestamp of the source.
    //
    d = GetSetFileTimestamp(
            SourceFileName,
            &CreateTime,
            &AccessTime,
            &WriteTime,
            FALSE
            );

    if(d != NO_ERROR) {
        return(d);
    }

    hSrc = LZOpenFile(SourceFileName,&ofSrc,OF_READ|OF_SHARE_DENY_WRITE);
    if(hSrc >= 0) {

        hDst = LZOpenFile(TargetFileName,&ofSrc,OF_CREATE|OF_WRITE|OF_SHARE_EXCLUSIVE);
        if(hDst >= 0) {

            l = LZCopy(hSrc,hDst);
            if(l >= 0) {
                l = 0;

                //
                // Set the timestamp of the target. The file is already there
                // so just ignore errors.
                //
                GetSetFileTimestamp(
                    TargetFileName,
                    &CreateTime,
                    &AccessTime,
                    &WriteTime,
                    TRUE
                    );
            }

            LZClose(hDst);

        } else {
            l = hDst;
        }

        LZClose(hSrc);

    } else {
        l = hSrc;
    }

    //
    // lz error to win32 error
    //
    switch(l) {

    case 0:
        return(NO_ERROR);

    case LZERROR_BADINHANDLE:
    case LZERROR_READ:
        return(ERROR_READ_FAULT);

    case LZERROR_BADOUTHANDLE:
    case LZERROR_WRITE:
        return(ERROR_WRITE_FAULT);

    case LZERROR_GLOBALLOC:
    case LZERROR_GLOBLOCK:
        return(ERROR_NOT_ENOUGH_MEMORY);

    case LZERROR_BADVALUE:
    case LZERROR_UNKNOWNALG:
        return(ERROR_INVALID_DATA);

    default:
        return(ERROR_INVALID_FUNCTION);
    }
}


DWORD
SetupInternalGetFileCompressionInfo(
    IN  PCTSTR            SourceFileName,
    OUT PTSTR            *ActualSourceFileName,
    OUT PWIN32_FIND_DATA  SourceFindData,
    OUT PDWORD            TargetFileSize,
    OUT PUINT             CompressionType
    )

/*++

Routine Description:

    Determine whether a file is compressed, and retreive additional
    information about it.

Arguments:

    SourceFileName - supplies filename of the file to be checked.
        This filename is used as a base; if not found then we look
        for the 2 compressed forms (ie, foo.ex_, foo.ex$) as well.

    ActualSourceFileName - receives a pointer to the filename
        that was actually located. Caller can free with MyFree().
        Valid only if the return code from this routine is NO_ERROR.

    SourceFindData - receives win32 find data for the located file in its
        current (ie, compressed) form. Valid only if this routine
        returns NO_ERROR.

    TargetFileSize - receives the uncompressed size of the file.
        If the file is not compressed this will be the same as
        SourceFileSize. Valid only if this routine returns NO_ERROR.

    CompressionType - receives a value indicating the compression type.
        Valid only if this routine returns NO_ERROR.

Return Value:

    Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located and output params are filled in.

    Others - something is wrong with the hardware or system.

--*/

{
    DWORD d;
    DWORD caberr = NO_ERROR;
    BOOL b;
    HANDLE hFile,hMapping;
    DWORD size;
    FH UNALIGNED *LZHeader;

    d = SetupDetermineSourceFileName(
            SourceFileName,
            &b,
            ActualSourceFileName,
            SourceFindData
            );

    if(d != NO_ERROR) {
        return(d);
    }

    //
    // If the file is 0-length it isn't compressed;
    // trying to map it in below will fail in this case.
    //
    if(SourceFindData->nFileSizeLow) {

        //
        // See if it's a diamond file.
        //
        d = DiamondProcessCabinet(
                *ActualSourceFileName,
                0,
                pGetCompressInfoCB,
                &size,
                TRUE
                );

        if(d == NO_ERROR) {

            *TargetFileSize = size;
            *CompressionType = FILE_COMPRESSION_MSZIP;
            return(NO_ERROR);
        } else if (d != ERROR_INVALID_DATA) {
            //
            // general problems not specific to the file format itself
            // however if this might be a plain file, ignore it
            //
            size_t len1 = lstrlen(SourceFileName);
            size_t len2 = lstrlen(*ActualSourceFileName);
            TCHAR c1 = *CharPrev(SourceFileName,SourceFileName+len1);
            TCHAR c2 = *CharPrev(*ActualSourceFileName,*ActualSourceFileName+len2);
            if(((c2 == TEXT('_')) || (c2 == TEXT('$'))) && ((len1 != len2) || (c1 != c2))) {
                //
                // ActualSourceFileName ends in '_' or '$' and is a modification of SourceFileName
                // don't let us try and parse this as a plain file
                //
                caberr = d;
            }
        }

        //
        // See if it's a WINLZ file.
        //
        d = pSetupOpenAndMapFileForRead(
                *ActualSourceFileName,
                &SourceFindData->nFileSizeLow,
                &hFile,
                &hMapping,
                (PVOID *)&LZHeader
                );

        if(d != NO_ERROR) {
            MyFree(*ActualSourceFileName);
            return(d);
        }

        b = FALSE;
        try {
            if((SourceFindData->nFileSizeLow >= HEADER_LEN)
            && !memcmp(LZHeader->rgbyteMagic,COMP_SIG,COMP_SIG_LEN)
            && RecognizeCompAlg(LZHeader->byteAlgorithm))
            {
                *TargetFileSize = LZHeader->cbulUncompSize;
                b = TRUE;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ;
        }

        pSetupUnmapAndCloseFile(hFile,hMapping,LZHeader);

        if(b) {
            *CompressionType = FILE_COMPRESSION_WINLZA;
            return(NO_ERROR);
        }

        if(caberr) {
            //
            // looks like a compressed file and DiamondProcessCabinet
            // returned a suspicious error
            //
            return(caberr);
        }
    }

    //
    // File is not compressed.
    //
    *CompressionType = FILE_COMPRESSION_NONE;
    *TargetFileSize = SourceFindData->nFileSizeLow;
    return(NO_ERROR);
}


UINT
pGetCompressInfoCB(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
{
    PFILE_IN_CABINET_INFO FileInfo;
    DWORD rc;

    switch(Notification) {

    case SPFILENOTIFY_CABINETINFO:
        //
        // We don't do anything with this.
        //
        rc = NO_ERROR;
        break;

    case SPFILENOTIFY_FILEINCABINET:
        //
        // New file within a cabinet.
        //
        // We don't ever want to copy the file. Save size info
        // and abort.
        //
        FileInfo = (PFILE_IN_CABINET_INFO)Param1;

        *((PDWORD)Context) = FileInfo->FileSize;

        FileInfo->Win32Error = NO_ERROR;
        rc = FILEOP_ABORT;
        SetLastError(NO_ERROR);
        break;

    //case SPFILENOTIFY_FILEEXTRACTED:
    //case SPFILENOTIFY_NEEDNEWCABINET:
    default:
        //
        // We should never get these.
        //
        MYASSERT(0);
        rc = ERROR_INVALID_FUNCTION;
        break;
    }

    return(rc);
}


#ifdef UNICODE
//
// ANSI version
//
DWORD
SetupGetFileCompressionInfoA(
    IN  PCSTR   SourceFileName,
    OUT PSTR   *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )
{
    WIN32_FIND_DATA FindData;
    DWORD d;
    PCWSTR source;
    PWSTR actualsource = NULL;
    PSTR actualsourceansi = NULL;
    PSTR la_actualsourceansi = NULL;
    DWORD targetsize;
    UINT type;

    d = pSetupCaptureAndConvertAnsiArg(SourceFileName,&source);
    if(d != NO_ERROR) {
        return(d);
    }

    d = SetupInternalGetFileCompressionInfo(source,&actualsource,&FindData,&targetsize,&type);

    if(d == NO_ERROR) {

        MYASSERT(actualsource);

        if((actualsourceansi = pSetupUnicodeToAnsi(actualsource))==NULL) {
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
        if((la_actualsourceansi = (PSTR)OldMyMalloc(1+strlen(actualsourceansi)))==NULL) {
            d = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
        strcpy(la_actualsourceansi,actualsourceansi);
        try {
            *SourceFileSize = FindData.nFileSizeLow;
            *ActualSourceFileName = la_actualsourceansi; // free using LocalFree
            *TargetFileSize = targetsize;
            *CompressionType = type;
            la_actualsourceansi = NULL;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
    }

clean0:
    if(actualsource) {
        MyFree(actualsource);
    }
    if(actualsourceansi) {
        MyFree(actualsourceansi);
    }
    if(la_actualsourceansi) {
        OldMyFree(la_actualsourceansi);
    }

    MyFree(source);

    return(d);
}
#else
//
// Unicode stub
//
DWORD
SetupGetFileCompressionInfoW(
    IN  PCWSTR  SourceFileName,
    OUT PWSTR  *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )
{
    UNREFERENCED_PARAMETER(SourceFileName);
    UNREFERENCED_PARAMETER(ActualSourceFileName);
    UNREFERENCED_PARAMETER(SourceFileSize);
    UNREFERENCED_PARAMETER(TargetFileSize);
    UNREFERENCED_PARAMETER(CompressionType);
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif

DWORD
SetupGetFileCompressionInfo(
    IN  PCTSTR  SourceFileName,
    OUT PTSTR  *ActualSourceFileName,
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )

/*++

Routine Description:

    Here for App-Compat only
    Replaced by SetupGetFileCompressionInfoEx

    Return pointer is allocated by OldMyMalloc,
    it can be freed by (*cough*) OldMyFree (exported as MyFree)
    This is because there are apps out there that use this,
    and run-time link to setupapi!MyFree to release memory

    !!!! DO NOT USE THIS API !!!!

Arguments:

    SourceFileName - supplies filename of the file to be checked.
        This filename is used as a base; if not found then we look
        for the 2 compressed forms (ie, foo.ex_, foo.ex$) as well.

    ActualSourceFileName - receives a pointer to the filename
        that was actually located. Caller can free with exported MyFree().
        Valid only if the return code from this routine is NO_ERROR.

    SourceFileSize - receives the size of the located file in its
        current (ie, compressed) form. Valid only if this routine
        returns NO_ERROR.

    TargetFileSize - receives the uncompressed size of the file.
        If the file is not compressed this will be the same as
        SourceFileSize. Valid only if this routine returns NO_ERROR.

    CompressionType - receives a value indicating the compression type.
        Valid only if this routine returns NO_ERROR.

Return Value:

    Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located and output params are filled in.

    Others - something is wrong with the hardware or system.

--*/

{
    WIN32_FIND_DATA FindData;
    DWORD d;
    PCTSTR source;
    PTSTR actualsource = NULL;
    PTSTR la_actualsource = NULL;
    DWORD targetsize;
    UINT type;

    d = CaptureStringArg(SourceFileName,&source);
    if(d != NO_ERROR) {
        return(d);
    }

    d = SetupInternalGetFileCompressionInfo(source,&actualsource,&FindData,&targetsize,&type);

    if(d == NO_ERROR) {
        MYASSERT(actualsource);
        la_actualsource = (PTSTR)OldMyMalloc(sizeof(TCHAR)*(1+lstrlen(actualsource)));
        if (la_actualsource == NULL) {
            MyFree(actualsource);
            MyFree(source);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        lstrcpy(la_actualsource,actualsource);
        try {
            *SourceFileSize = FindData.nFileSizeLow;
            *ActualSourceFileName = la_actualsource; // free using LocalFree
            *TargetFileSize = targetsize;
            *CompressionType = type;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
        if(d != NO_ERROR) {
            OldMyFree(la_actualsource);
        }
        MyFree(actualsource);
    }

    MyFree(source);

    return(d);
}


#ifdef UNICODE
//
// ANSI version
//
BOOL
WINAPI
SetupGetFileCompressionInfoExA(
    IN  PCSTR   SourceFileName,
    IN  PSTR    ActualSourceFileNameBuffer,
    IN  DWORD   ActualSourceFileNameBufferLen,
    OUT PDWORD  RequiredBufferLen,              OPTIONAL
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )
{
    WIN32_FIND_DATA FindData;
    DWORD d;
    PCWSTR source;
    PWSTR actualsource = NULL;
    PSTR actualsourceansi = NULL;
    DWORD targetsize;
    DWORD reqbufsize;
    UINT type;

    d = pSetupCaptureAndConvertAnsiArg(SourceFileName,&source);
    if(d != NO_ERROR) {
        SetLastError(d);
        return (d==NO_ERROR);
    }

    d = SetupInternalGetFileCompressionInfo(source,&actualsource,&FindData,&targetsize,&type);

    if(d == NO_ERROR) {
        MYASSERT(actualsource);
        actualsourceansi = pSetupUnicodeToAnsi(actualsource);
        if(actualsourceansi != NULL) {
            try {
                reqbufsize = strlen(actualsourceansi)+1;
                if (RequiredBufferLen) {
                    *RequiredBufferLen = reqbufsize;
                }
                if(ActualSourceFileNameBuffer) {
                    if((ActualSourceFileNameBufferLen < reqbufsize)) {
                        d = ERROR_INSUFFICIENT_BUFFER;
                    } else {
                        strcpy(ActualSourceFileNameBuffer,actualsourceansi);
                    }
                } else if(ActualSourceFileNameBufferLen) {
                    d = ERROR_INVALID_USER_BUFFER;
                }
                *SourceFileSize = FindData.nFileSizeLow;
                *TargetFileSize = targetsize;
                *CompressionType = type;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                d = ERROR_INVALID_PARAMETER;
            }
        } else {
            d = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if(actualsource) {
        MyFree(actualsource);
    }
    if(actualsourceansi) {
        MyFree(actualsourceansi);
    }
    MyFree(source);

    SetLastError(d);
    return (d==NO_ERROR);
}
#else
//
// Unicode stub
//
BOOL
WINAPI
SetupGetFileCompressionInfoExW(
    IN  PCWSTR  SourceFileName,
    IN  PWSTR   ActualSourceFileNameBuffer,
    IN  DWORD   ActualSourceFileNameBufferLen,
    OUT PDWORD  RequiredBufferLen,              OPTIONAL
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )
{
    UNREFERENCED_PARAMETER(SourceFileName);
    UNREFERENCED_PARAMETER(ActualSourceFileNameBuffer);
    UNREFERENCED_PARAMETER(ActualSourceFileNameBufferLen);
    UNREFERENCED_PARAMETER(RequiredBufferLen);
    UNREFERENCED_PARAMETER(SourceFileSize);
    UNREFERENCED_PARAMETER(TargetFileSize);
    UNREFERENCED_PARAMETER(CompressionType);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif

BOOL
WINAPI
SetupGetFileCompressionInfoEx(
    IN  PCTSTR  SourceFileName,
    IN  PTSTR   ActualSourceFileNameBuffer,
    IN  DWORD   ActualSourceFileNameBufferLen,
    OUT PDWORD  RequiredBufferLen,              OPTIONAL
    OUT PDWORD  SourceFileSize,
    OUT PDWORD  TargetFileSize,
    OUT PUINT   CompressionType
    )

/*++

Routine Description:

    Determine whether a file is compressed, and retreive additional
    information about it.
    This is the replacement for the very broken SetupGetFileCompressionInfo
    Caller must pass in a buffer
    If the buffer is NULL, return size
    and all other parameters filled out (unless some other error occurred)
    note however, you would typically call this with a buffer size of MAX_PATH.

Arguments:

    SourceFileName - supplies filename of the file to be checked.
        This filename is used as a base; if not found then we look
        for the 2 compressed forms (ie, foo.ex_, foo.ex$) as well.

    ActualSourceFileNameBuffer - if not NULL, receives actual filename
        Valid only if the return code from this routine is NO_ERROR.

    ActualSourceFileNameBufferLen - pass in length (characters) of
        ActualSourceFileNameBuffer. must be 0 if ActualSourceFileNameBuffer
        is NULL.

    RequiredBufferLen - if not NULL, filled with length of actual filename
        including terminating NULL.
        Valid only if the return code from this routine is NO_ERROR or ERROR_INSUFFICIENT_BUFFER.

    SourceFileSize - receives the size of the located file in its
        current (ie, compressed) form. Valid only if this routine
        returns NO_ERROR or  ERROR_INSUFFICIENT_BUFFER.

    TargetFileSize - receives the uncompressed size of the file.
        If the file is not compressed this will be the same as
        SourceFileSize. Valid only if this routine returns NO_ERROR or  ERROR_INSUFFICIENT_BUFFER.

    CompressionType - receives a value indicating the compression type.
        Valid only if this routine returns NO_ERROR or  ERROR_INSUFFICIENT_BUFFER.

Return Value:

    TRUE indicating success (NO_ERROR)
    FALSE indicating failure
    GetLastError() provides Win32 error code indicating the outcome.

    ERROR_FILE_NOT_FOUND - normal code indicating everything is ok
        but we can't find the file

    NO_ERROR - file was located and all output params are filled in including ActualSourceFileNameBuffer.
        also returned if ActualSourceFileNameBuffer is NULL

    ERROR_INSUFFICIENT_BUFFER - file was located and output params are filled in, excluding
        ActualSourceFileNameBuffer.

    Others - something is wrong with the hardware or system.

--*/

{
    WIN32_FIND_DATA FindData;
    DWORD d;
    PCTSTR source;
    PTSTR actualsource = NULL;
    DWORD targetsize;
    UINT type;
    DWORD reqbufsize;

    d = CaptureStringArg(SourceFileName,&source);
    if(d != NO_ERROR) {
        SetLastError(d);
        return (d==NO_ERROR);
    }

    d = SetupInternalGetFileCompressionInfo(source,&actualsource,&FindData,&targetsize,&type);

    if(d == NO_ERROR) {
        MYASSERT(actualsource);
        try {
            reqbufsize = lstrlen(actualsource)+1;
            if (RequiredBufferLen) {
                *RequiredBufferLen = reqbufsize;
            }
            if(ActualSourceFileNameBuffer) {
                if(ActualSourceFileNameBufferLen < reqbufsize) {
                    d = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    lstrcpy(ActualSourceFileNameBuffer,actualsource);
                }
            } else if(ActualSourceFileNameBufferLen) {
                d = ERROR_INVALID_USER_BUFFER;
            }
            *SourceFileSize = FindData.nFileSizeLow;
            *TargetFileSize = targetsize;
            *CompressionType = type;
        } except(EXCEPTION_EXECUTE_HANDLER) {
            d = ERROR_INVALID_PARAMETER;
        }
        MyFree(actualsource);
    }

    MyFree(source);

    SetLastError(d);
    return (d==NO_ERROR);
}


#ifdef UNICODE
//
// ANSI version
//
DWORD
SetupDecompressOrCopyFileA(
    IN  PCSTR   SourceFileName,
    OUT PCSTR   TargetFileName,
    OUT PUINT   CompressionType OPTIONAL
    )
{
    DWORD rc;
    PCWSTR s,t;

    rc = pSetupCaptureAndConvertAnsiArg(SourceFileName,&s);
    if(rc == NO_ERROR) {

        rc = pSetupCaptureAndConvertAnsiArg(TargetFileName,&t);
        if(rc == NO_ERROR) {

            rc = pSetupDecompressOrCopyFile(s,t,CompressionType,FALSE,NULL);
            MyFree(t);
        }

        MyFree(s);
    }

    return(rc);
}
#else
//
// Unicode stub
//
DWORD
SetupDecompressOrCopyFileW(
    IN  PCWSTR  SourceFileName,
    OUT PCWSTR  TargetFileName,
    OUT PUINT   CompressionType OPTIONAL
    )
{
    UNREFERENCED_PARAMETER(SourceFileName);
    UNREFERENCED_PARAMETER(TargetFileName);
    UNREFERENCED_PARAMETER(CompressionType);
    return(ERROR_CALL_NOT_IMPLEMENTED);
}
#endif

DWORD
SetupDecompressOrCopyFile(
    IN PCTSTR SourceFileName,
    IN PCTSTR TargetFileName,
    IN PUINT  CompressionType OPTIONAL
    )

/*++

Routine Description:

    Decompress or copy a file.

Arguments:

    SourceFileName - supplies filename of the file to be decompressed.
        If CompressionType is specified, no additional processing is
        performed on this name -- the caller is responsible for determining
        the actual file name (ie, foo.ex_ instead of foo.exe) before calling
        this routine. If CompressionType is not specified, then this routine
        attempts to locate the compressed form of the filename if the file
        is not found with the name given.

    TargetFileName - supplies filename of target file.

    CompressionType - if specified, supplies type of compression in use
        on the source. This can be determined by calling
        SetupGetFileCompressionInfo(). Specifying FILE_COMPRESSION_NONE
        results in the file being copied and not decompressed,
        regardless of the type of compression that may be in use on the source.
        If this value is not specified then this routine attempts to determine
        the compression type and decompresses/copies accordingly.

Return Value:

    Win32 error code indicating the outcome.

--*/

{
    DWORD rc;
    PCTSTR s,t;

    rc = CaptureStringArg(SourceFileName,&s);
    if(rc == NO_ERROR) {

        rc = CaptureStringArg(TargetFileName,&t);
        if(rc == NO_ERROR) {

            rc = pSetupDecompressOrCopyFile(s,t,CompressionType,FALSE,NULL);
            MyFree(t);
        }

        MyFree(s);
    }

    return(rc);
}


DWORD
pSetupDecompressOrCopyFile(
    IN  PCTSTR SourceFileName,
    IN  PCTSTR TargetFileName,
    IN  PUINT  CompressionType, OPTIONAL
    IN  BOOL   AllowMove,
    OUT PBOOL  Moved            OPTIONAL
    )

/*++

Routine Description:

    Decompress or copy a file.

Arguments:

    SourceFileName - supplies filename of the file to be decompressed.
        If CompressionType is specified, no additional processing is
        performed on this name -- the caller is responsible for determining
        the actual file name (ie, foo.ex_ instead of foo.exe) before calling
        this routine. If CompressionType is not specified, then this routine
        attempts to locate the compressed form of the filename if the file
        is not found with the name given.

    TargetFileName - supplies filename of target file.

    CompressionType - if specified, supplies type of compression in use
        on the source. This can be determined by calling
        SetupGetFileCompressionInfo(). Specifying FILE_COMPRESSION_NONE
        results in the file being copied and not decompressed,
        regardless of the type of compression that may be in use on the source.
        If this value is not specified then this routine attempts to determine
        the compression type and decompresses/copies accordingly.

    AllowMove - if specified, then files that do not require decompression
        will be moved instead of copied.

    Moved - if specified receives a boolean indicating whether the file was
        moved (as opposed to copied or decompressed).

Return Value:

    Win32 error code indicating the outcome.

--*/

{
    DWORD d;
    UINT ComprType;
    PTSTR ActualName;
    DWORD TargetSize;
    FILETIME CreateTime,AccessTime,WriteTime;
    SFD_INFO CBData;
    BOOL moved;
    WIN32_FIND_DATA FindData;

    if(Moved) {
        *Moved = FALSE;
    }

    if(CompressionType) {
        ComprType = *CompressionType;
        ActualName = (PTSTR)SourceFileName;
    } else {
        //
        // Need to determine compresison type.
        //
        d = SetupInternalGetFileCompressionInfo(
                SourceFileName,
                &ActualName,
                &FindData,
                &TargetSize,
                &ComprType
                );

        if(d != NO_ERROR) {
            return(d);
        }
    }

    //
    // Blast the target file. Ignore if failure -- it'll be caught later.
    //
    SetFileAttributes(TargetFileName,FILE_ATTRIBUTE_NORMAL);
    DeleteFile(TargetFileName);

    switch(ComprType) {

    case FILE_COMPRESSION_NONE:
        moved = (AllowMove ? MoveFile(ActualName,TargetFileName) : FALSE);
        if(moved) {
            d = NO_ERROR;
            if(Moved) {
                *Moved = TRUE;
            }
        } else {
            d = GetSetFileTimestamp(ActualName,&CreateTime,&AccessTime,&WriteTime,FALSE);
            if(d == NO_ERROR) {
                d = CopyFile(ActualName,TargetFileName,FALSE) ? NO_ERROR : GetLastError();
                if(d == NO_ERROR) {
                    GetSetFileTimestamp(TargetFileName,&CreateTime,&AccessTime,&WriteTime,TRUE);
                }
            }
        }
        break;

    case FILE_COMPRESSION_WINLZA:
        d = pSetupDecompressWinLzFile(ActualName,(PTSTR)TargetFileName);
        break;

    case FILE_COMPRESSION_MSZIP:

        CBData.FileCount = 0;
        CBData.TargetFile = TargetFileName;
        CBData.GotTimestamp = FALSE;

        d = DiamondProcessCabinet(
                ActualName,
                0,
                pSingleFileDecompCB,
                &CBData,
                TRUE
                );
        break;

    default:
        d = ERROR_INVALID_PARAMETER;
        break;
    }

    if(!CompressionType) {
        MyFree(ActualName);
    }

    return(d);
}


UINT
pSingleFileDecompCB(
    IN PVOID Context,
    IN UINT  Notification,
    IN UINT_PTR  Param1,
    IN UINT_PTR  Param2
    )
{
    PSFD_INFO Data;
    PFILE_IN_CABINET_INFO FileInfo;
    PFILEPATHS FilePaths;
    DWORD rc;
    HANDLE h;

    Data = Context;

    switch(Notification) {

    case SPFILENOTIFY_CABINETINFO:
        //
        // We don't do anything with this.
        //
        rc = NO_ERROR;
        break;

    case SPFILENOTIFY_FILEINCABINET:
        //
        // New file within a cabinet.
        //
        FileInfo = (PFILE_IN_CABINET_INFO)Param1;
        FileInfo->Win32Error = NO_ERROR;

        //
        // We only want the first file. If this is a subsequent file,
        // bail out.
        //
        if(Data->FileCount++) {

            rc = FILEOP_ABORT;
            SetLastError(NO_ERROR);

        } else {
            //
            // We want the file. Ignore the names in the cabinet and
            // use the name given to us. Also, we want to preserve
            // the timestamp of the cabinet, not of the file within it.
            //
            lstrcpyn(FileInfo->FullTargetName,Data->TargetFile,MAX_PATH);

            h = CreateFile(
                    (PCTSTR)Param2,         // cabinet filename
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

            if(h != INVALID_HANDLE_VALUE) {
                if(GetFileTime(h,NULL,NULL,&Data->FileTime)) {
                    Data->GotTimestamp = TRUE;
                }
                CloseHandle(h);
            }

            rc = FILEOP_DOIT;
        }

        break;

    case SPFILENOTIFY_FILEEXTRACTED:
        //
        // File was successfully extracted.
        // Preserve timestamp.
        //
        FilePaths = (PFILEPATHS)Param1;

        if(Data->GotTimestamp) {

            h = CreateFile(
                    FilePaths->Target,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

            if(h != INVALID_HANDLE_VALUE) {
                SetFileTime(h,NULL,NULL,&Data->FileTime);
                CloseHandle(h);
            }
        }

        rc = NO_ERROR;
        break;

    //case SPFILENOTIFY_NEEDNEWCABINET:
    default:
        //
        // We should never get this.
        //
        MYASSERT(0);
        rc = ERROR_INVALID_FUNCTION;
        break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devclass.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devclass.c

Abstract:

    Device Installer routines dealing with class installation

Author:

    Lonny McMichael (lonnym) 1-May-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetINFClassA(
    IN  PCSTR  InfName,
    OUT LPGUID ClassGuid,
    OUT PSTR   ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    )
{
    PWSTR UnicodeInfName = NULL;
    WCHAR UnicodeClassName[MAX_CLASS_NAME_LEN];
    PSTR AnsiClassName = NULL;
    DWORD LocalRequiredSize;
    DWORD rc;
    HRESULT hr;

    try {

        rc = pSetupCaptureAndConvertAnsiArg(InfName, &UnicodeInfName);
        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiGetINFClassW(UnicodeInfName,
                                             ClassGuid,
                                             UnicodeClassName,
                                             SIZECHARS(UnicodeClassName),
                                             &LocalRequiredSize)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        AnsiClassName = pSetupUnicodeToAnsi(UnicodeClassName);

        if(AnsiClassName) {

            LocalRequiredSize = lstrlenA(AnsiClassName) + 1;

            if(RequiredSize) {
                *RequiredSize = LocalRequiredSize;
            }

            if (!ClassName && (ClassNameSize == 0)) {
                //
                // If the caller passed in a NULL ClassName and 0 for 
                // ClassNameSize then they simply wanted to know the
                // required size.
                //
                rc = ERROR_INSUFFICIENT_BUFFER;

            } else {
    
                hr = StringCchCopyA(ClassName,
                                    (size_t)ClassNameSize,
                                    AnsiClassName
                                    );
    
                if(FAILED(hr)) {
                    rc = HRESULT_CODE(hr);
                } else {
                    rc = NO_ERROR;
                }
            }

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(UnicodeInfName) {
        MyFree(UnicodeInfName);
    }

    if(AnsiClassName) {
        MyFree(AnsiClassName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiGetINFClass(
    IN  PCTSTR InfName,
    OUT LPGUID ClassGuid,
    OUT PTSTR  ClassName,
    IN  DWORD  ClassNameSize,
    OUT PDWORD RequiredSize   OPTIONAL
    )
/*++

Routine Description:

    This API will return the class of the specified (Windows 4.0) INF.  If just the
    filename was specified, then the file will be searched for in each of the
    directories listed in the DevicePath value entry under:

        HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion

    Otherwise, the filename will be used as-is.

Arguments:

    InfName - Supplies the name of the INF file for which to retrieve class information.
        This name may include a path.

    ClassGuid - Receives the class GUID for the specified INF file.  If the INF
        does not specify a class GUID, this variable will be set to GUID_NULL.
        (SetupDiClassGuidsFromName may then be used to determine if one or more
        classes of this name have already been installed.)

    ClassName - Receives the name of the class for the specified INF file.  If the
        INF does not specify a class name, but does specify a GUID, then this buffer
        receives the name retrieved by calling SetupDiClassNameFromGuid.  If
        SetupDiClassNameFromGuid can't retrieve a class name (e.g., the class hasn't
        yet been installed), then an empty string will be returned.

    ClassNameSize - Supplies the size, in characters, of the ClassName buffer.

    RequiredSize - Optionally, receives the number of characters required to store
        the class name (including terminating NULL).  This will always be less
        than MAX_CLASS_NAME_LEN.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    TCHAR PathBuffer[MAX_PATH];
    PLOADED_INF Inf = NULL;
    PCTSTR GuidString, ClassNameString;
    DWORD ErrorLineNumber, ClassNameStringLen;
    DWORD Err;
    BOOL TryPnf;
    WIN32_FIND_DATA FindData;
    PTSTR DontCare;
    DWORD TempRequiredSize;
    HRESULT hr;

    try {

        if(InfName == pSetupGetFileTitle(InfName)) {
            //
            // The specified INF name is a simple filename.  Search for it in
            // the DevicePath search path list.
            //
            Err = SearchForInfFile(InfName,
                                   &FindData,
                                   INFINFO_INF_PATH_LIST_SEARCH,
                                   PathBuffer,
                                   SIZECHARS(PathBuffer),
                                   NULL
                                  );
            if(Err == NO_ERROR) {
                TryPnf = TRUE;
            } else {
                leave;
            }

        } else {
            //
            // The specified INF filename contains more than just a filename.
            // Assume it's an absolute path.  (We need to make sure it's
            // fully-qualified, because that's what LoadInfFile expects.)
            //
            Err = GLE_FN_CALL(0,
                              TempRequiredSize = GetFullPathName(
                                                     InfName,
                                                     SIZECHARS(PathBuffer),
                                                     PathBuffer,
                                                     &DontCare)
                             );


            if(Err != NO_ERROR) {
                leave;
            } else if(TempRequiredSize >= SIZECHARS(PathBuffer)) {
                MYASSERT(0);
                Err = ERROR_BUFFER_OVERFLOW;
                leave;
            }

            Err = GLE_FN_CALL(FALSE, FileExists(PathBuffer, &FindData));

            if(Err == NO_ERROR) {
                //
                // We have a valid file path, and we're ready to load this INF.
                //
                InfSourcePathFromFileName(PathBuffer, NULL, &TryPnf);
            } else {
                leave;
            }
        }

        //
        // Load the INF.
        //
        Err = LoadInfFile(PathBuffer,
                          &FindData,
                          INF_STYLE_WIN4,
                          LDINF_FLAG_IGNORE_VOLATILE_DIRIDS | (TryPnf ? LDINF_FLAG_ALWAYS_TRY_PNF : 0),
                          NULL,
                          NULL,
                          NULL,
                          NULL,
                          NULL, // LogContext
                          &Inf,
                          &ErrorLineNumber,
                          NULL
                         );
        if(Err != NO_ERROR) {
            Inf = NULL; // don't assume this wasn't touched in failure case
            leave;
        }

        //
        // Retrieve the Class name from the version section of the INF, if
        // supplied.
        //
        ClassNameString = pSetupGetVersionDatum(&(Inf->VersionBlock), pszClass);
        if(ClassNameString) {

            ClassNameStringLen = lstrlen(ClassNameString) + 1;
            if(RequiredSize) {
                *RequiredSize = ClassNameStringLen;
            }

            if (!ClassName && (ClassNameSize == 0)) {
                //
                // If the caller passed in a NULL ClassName and 0 for 
                // ClassNameSize then they simply wanted to know the
                // required size.
                //
                Err = ERROR_INSUFFICIENT_BUFFER;
                leave;
            
            } else {

                hr = StringCchCopy(ClassName,
                                   (size_t)ClassNameSize,
                                   ClassNameString
                                   );
    
                if(FAILED(hr)) {
                    Err = HRESULT_CODE(hr);
                    leave;
                }
            }
        }

        //
        // Retrieve the ClassGUID string from the version section,
        // if supplied
        //
        GuidString = pSetupGetVersionDatum(&(Inf->VersionBlock), pszClassGuid);
        if(GuidString) {

            if((Err = pSetupGuidFromString(GuidString, ClassGuid)) != NO_ERROR) {
                leave;
            }

            if(!ClassNameString) {
                //
                // Call SetupDiClassNameFromGuid to retrieve the class name
                // corresponding to this class GUID.
                //
                Err = GLE_FN_CALL(FALSE,
                                  SetupDiClassNameFromGuid(ClassGuid,
                                                           ClassName,
                                                           ClassNameSize,
                                                           RequiredSize)
                                 );

                if(Err != NO_ERROR) {

                    if(Err == ERROR_INVALID_CLASS) {
                        //
                        // Then this GUID represents a class that hasn't been
                        // installed yet, so simply set the ClassName to be an
                        // empty string.
                        //
                        if(RequiredSize) {
                            *RequiredSize = 1;
                        }

                        if(ClassNameSize < 1) {
                            Err = ERROR_INSUFFICIENT_BUFFER;
                            leave;
                        }

                        *ClassName = TEXT('\0');
                        Err = NO_ERROR;

                    } else {
                        leave;
                    }
                }
            }

        } else if(ClassNameString) {
            //
            // Since no ClassGUID was given, set the supplied GUID buffer to GUID_NULL.
            //
            CopyMemory(ClassGuid,
                       &GUID_NULL,
                       sizeof(GUID)
                      );
        } else {
            //
            // Neither the ClassGUID nor the Class version entries were provided,
            // so return an error.
            //
            Err = ERROR_NO_ASSOCIATED_CLASS;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(Inf) {
        FreeInfFile(Inf);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiClassNameFromGuidA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize   OPTIONAL
    )
{
    DWORD Err;

    //
    // Wrap call in try/except to catch stack overflow
    //
    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiClassNameFromGuidExA(ClassGuid,
                                                      ClassName,
                                                      ClassNameSize,
                                                      RequiredSize,
                                                      NULL,
                                                      NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}

BOOL
WINAPI
SetupDiClassNameFromGuid(
    IN  CONST GUID *ClassGuid,
    OUT PTSTR       ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize   OPTIONAL
    )
/*++

Routine Description:

    See SetupDiClassNameFromGuidEx for details.

--*/

{
    DWORD Err;

    //
    // Wrap call in try/except to catch stack overflow
    //
    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiClassNameFromGuidEx(ClassGuid,
                                                     ClassName,
                                                     ClassNameSize,
                                                     RequiredSize,
                                                     NULL,
                                                     NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiClassNameFromGuidExA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize,  OPTIONAL
    IN  PCSTR       MachineName,   OPTIONAL
    IN  PVOID       Reserved
    )
{
    WCHAR UnicodeClassName[MAX_CLASS_NAME_LEN];
    DWORD LocalRequiredSize;
    PSTR AnsiClassName = NULL;
    DWORD rc;
    PCWSTR UnicodeMachineName = NULL;
    HRESULT hr;

    try {

        if(MachineName) {
            rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiClassNameFromGuidExW(ClassGuid,
                                                     UnicodeClassName,
                                                     SIZECHARS(UnicodeClassName),
                                                     &LocalRequiredSize,
                                                     UnicodeMachineName,
                                                     Reserved)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        if(AnsiClassName = pSetupUnicodeToAnsi(UnicodeClassName)) {

            LocalRequiredSize = lstrlenA(AnsiClassName) + 1;

            if(RequiredSize) {
                *RequiredSize = LocalRequiredSize;
            }

            if (!ClassName && (ClassNameSize == 0)) {
                //
                // If the caller passed in a NULL ClassName and 0 for 
                // ClassNameSize then they simply wanted to know the
                // required size.
                //
                rc = ERROR_INSUFFICIENT_BUFFER;

            } else {
    
                hr = StringCchCopyA(ClassName,
                                    (size_t)ClassNameSize,
                                    AnsiClassName
                                    );
    
                if(FAILED(hr)) {
                    rc = HRESULT_CODE(hr);
                }
            }

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(AnsiClassName) {
        MyFree(AnsiClassName);
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiClassNameFromGuidEx(
    IN  CONST GUID *ClassGuid,
    OUT PTSTR       ClassName,
    IN  DWORD       ClassNameSize,
    OUT PDWORD      RequiredSize,  OPTIONAL
    IN  PCTSTR      MachineName,   OPTIONAL
    IN  PVOID       Reserved
    )
/*++

Routine Description:

    This API retrieves the class name associated with the class GUID.  It does this
    by searching through all installed classes in the PnP Class branch of the registry.

Arguments:

    ClassGuid - Supplies the class GUID for which the class name is to be retrieved.

    ClassName - Receives the name of the class for the specified GUID.

    ClassNameSize - Supplies the size, in characters, of the ClassName buffer.

    RequiredSize - Optionally, receives the number of characters required to store
        the class name (including terminating NULL).  This will always be less
        than MAX_CLASS_NAME_LEN.

    MachineName - Optionally, supplies the name of the remote machine where the specified
        class is installed.  If this parameter is not supplied, the local machine is
        used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    CONFIGRET cr;
    DWORD Err;
    HMACHINE hMachine = NULL;

    try {
        //
        // Make sure the caller didn't pass us anything in the Reserved parameter.
        //
        if(Reserved) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // If the caller specified a remote machine name, connect to that machine now.
        //
        if(MachineName) {
            cr = CM_Connect_Machine(MachineName, &hMachine);
            if(cr != CR_SUCCESS) {
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                hMachine = NULL; // don't assume this was left untouched
                leave;
            }
        }

        //
        // Get the class name associated with this GUID.
        //
        cr = CM_Get_Class_Name_Ex((LPGUID)ClassGuid,
                                  ClassName,
                                  &ClassNameSize,
                                  0,
                                  hMachine
                                 );

        if((RequiredSize) && ((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL))) {
            *RequiredSize = ClassNameSize;
        }

        if(cr == CR_SUCCESS) {
            Err = NO_ERROR;
        } else {
            Err = (cr == CR_BUFFER_SMALL) ? ERROR_INSUFFICIENT_BUFFER
                                          : ERROR_INVALID_CLASS;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiClassGuidsFromNameA(
    IN  PCSTR  ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    )
{
    PWSTR UnicodeClassName = NULL;
    DWORD rc;

    try {

        rc = pSetupCaptureAndConvertAnsiArg(ClassName, &UnicodeClassName);

        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiClassGuidsFromNameExW(UnicodeClassName,
                                                      ClassGuidList,
                                                      ClassGuidListSize,
                                                      RequiredSize,
                                                      NULL,
                                                      NULL)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(UnicodeClassName) {
        MyFree(UnicodeClassName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiClassGuidsFromName(
    IN  PCTSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    )
/*++

Routine Description:

    See SetupDiClassGuidsFromNameEx for details.

--*/

{
    DWORD Err;

    //
    // Wrap call in try/except to catch stack overflow
    //
    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiClassGuidsFromNameEx(ClassName,
                                                      ClassGuidList,
                                                      ClassGuidListSize,
                                                      RequiredSize,
                                                      NULL,
                                                      NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiClassGuidsFromNameExA(
    IN  PCSTR  ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCSTR  MachineName,       OPTIONAL
    IN  PVOID  Reserved
    )
{
    PCWSTR UnicodeClassName = NULL;
    PCWSTR UnicodeMachineName = NULL;
    DWORD rc;

    try {

        rc = pSetupCaptureAndConvertAnsiArg(ClassName, &UnicodeClassName);
        if(rc != NO_ERROR) {
            leave;
        }

        if(MachineName) {
            rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiClassGuidsFromNameExW(UnicodeClassName,
                                                      ClassGuidList,
                                                      ClassGuidListSize,
                                                      RequiredSize,
                                                      UnicodeMachineName,
                                                      Reserved)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(UnicodeClassName) {
        MyFree(UnicodeClassName);
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiClassGuidsFromNameEx(
    IN  PCTSTR ClassName,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCTSTR MachineName,       OPTIONAL
    IN  PVOID  Reserved
    )
/*++

Routine Description:

    This API retrieves the GUID(s) associated with the specified class name.
    This list is built up based on what classes are currently installed on
    the system.

Arguments:

    ClassName - Supplies the class name for which to retrieve associated class GUIDs.

    ClassGuidList - Supplies a pointer to an array of GUIDs that will receive the
        list of GUIDs associated with the specified class name.

    ClassGuidListSize - Supplies the number of GUIDs in the ClassGuidList buffer.

    RequiredSize - Supplies a pointer to the variable that recieves the number of GUIDs
        associated with the class name.  If there are more GUIDs than there is room in
        the ClassGuidList buffer, then this value indicates how big the list must be in
        order to store all of the GUIDs.

    MachineName - Optionally, supplies the name of the remote machine where the specified
        class name is to be 'looked up' (i.e., where one or more classes are installed that
        have this name).  If this parameter is not specified, the local machine is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    BOOL MoreToEnum;
    DWORD Err;
    CONFIGRET cr;
    ULONG i, CurClassNameLen, GuidMatchCount = 0;
    GUID CurClassGuid;
    TCHAR CurClassName[MAX_CLASS_NAME_LEN];
    HMACHINE hMachine = NULL;

    try {
        //
        // Make sure the caller specified the class name, and didn't pass us anything in the
        // Reserved parameter.
        //
        if(!ClassName || Reserved) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // If the caller specified a remote machine name, connect to that machine now.
        //
        if(MachineName) {
            cr = CM_Connect_Machine(MachineName, &hMachine);
            if(cr != CR_SUCCESS) {
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                hMachine = NULL; // don't assume this was left untouched
                leave;
            }
        }

        Err = NO_ERROR;

        //
        // Enumerate all the installed classes.
        //
        for(i = 0, MoreToEnum = TRUE; MoreToEnum; i++) {

            if((cr = CM_Enumerate_Classes_Ex(i, &CurClassGuid, 0, hMachine)) != CR_SUCCESS) {
                //
                // For any failure other than no-more-to-enum (or some kind of RPC error),
                // we simply want to go on to the next class.
                //
                switch(cr) {

                    case CR_INVALID_MACHINENAME :
                    case CR_REMOTE_COMM_FAILURE :
                    case CR_MACHINE_UNAVAILABLE :
                    case CR_NO_CM_SERVICES :
                    case CR_ACCESS_DENIED :
                    case CR_CALL_NOT_IMPLEMENTED :
                    case CR_REGISTRY_ERROR :
                        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        //
                        // Fall through to 'no more values' case to terminate loop.
                        //
                    case CR_NO_SUCH_VALUE :
                        MoreToEnum = FALSE;
                        break;

                    default :
                        //
                        // Nothing to do.
                        //
                        break;

                }
                continue;
            }

            //
            // Now, retrieve the class name associated with this class GUID.
            //
            CurClassNameLen = SIZECHARS(CurClassName);
            if(CM_Get_Class_Name_Ex(&CurClassGuid,
                                    CurClassName,
                                    &CurClassNameLen,
                                    0,
                                    hMachine) != CR_SUCCESS) {
                continue;
            }

            //
            // See if the current class name matches the class we're interested in.
            //
            if(!lstrcmpi(ClassName, CurClassName)) {

                if(GuidMatchCount < ClassGuidListSize) {
                    CopyMemory(&(ClassGuidList[GuidMatchCount]), &CurClassGuid, sizeof(GUID));
                }

                GuidMatchCount++;
            }
        }

        if(Err == NO_ERROR) {

            *RequiredSize = GuidMatchCount;

            if(GuidMatchCount > ClassGuidListSize) {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetClassDescriptionA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize          OPTIONAL
    )
{
    DWORD Err;

    //
    // Wrap call in try/except to catch stack overflow
    //
    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiGetClassDescriptionExA(ClassGuid,
                                                        ClassDescription,
                                                        ClassDescriptionSize,
                                                        RequiredSize,
                                                        NULL,
                                                        NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}

BOOL
WINAPI
SetupDiGetClassDescription(
    IN  CONST GUID *ClassGuid,
    OUT PTSTR       ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize          OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the class description associated with the specified
    class GUID.

Arguments:

    ClassGuid - Specifies the class GUID to retrieve the description for.

    ClassDescription - Supplies the address of the character buffer that is to receive
        the textual description of the class.

    ClassDescriptionSize - Supplies the size, in characters, of the ClassDescription buffer.

    RequiredSize - Optionally, receives the number of characters required to store
        the class description (including terminating NULL).  This will always be less
        than LINE_LEN.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err;

    //
    // Wrap call in try/except to catch stack overflow
    //
    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiGetClassDescriptionEx(ClassGuid,
                                                       ClassDescription,
                                                       ClassDescriptionSize,
                                                       RequiredSize,
                                                       NULL,
                                                       NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetClassDescriptionExA(
    IN  CONST GUID *ClassGuid,
    OUT PSTR        ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize,         OPTIONAL
    IN  PCSTR       MachineName,          OPTIONAL
    IN  PVOID       Reserved
    )
{
    WCHAR UnicodeClassDescription[LINE_LEN];
    PSTR AnsiClassDescription = NULL;
    DWORD LocalRequiredSize;
    DWORD rc;
    PCWSTR UnicodeMachineName = NULL;
    HRESULT hr;

    try {

        if(MachineName) {
            rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiGetClassDescriptionExW(
                             ClassGuid,
                             UnicodeClassDescription,
                             SIZECHARS(UnicodeClassDescription),
                             &LocalRequiredSize,
                             UnicodeMachineName,
                             Reserved)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        if(AnsiClassDescription = pSetupUnicodeToAnsi(UnicodeClassDescription)) {

            LocalRequiredSize = lstrlenA(AnsiClassDescription) + 1;

            if(RequiredSize) {
                *RequiredSize = LocalRequiredSize;
            }

            if (!ClassDescription && (ClassDescriptionSize == 0)) {
                //
                // If the caller passed in a NULL ClassDescription and 0 for 
                // ClassDescriptionSize then they simply wanted to know the
                // required size.
                //
                rc = ERROR_INSUFFICIENT_BUFFER;
            
            } else {
    
                hr = StringCchCopyA(ClassDescription,
                                    (size_t)ClassDescriptionSize,
                                    AnsiClassDescription
                                    );
    
                if(FAILED(hr)) {
                    rc = HRESULT_CODE(hr);
                }
            }

        } else {
            rc = ERROR_NOT_ENOUGH_MEMORY;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(AnsiClassDescription) {
        MyFree(AnsiClassDescription);
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiGetClassDescriptionEx(
    IN  CONST GUID *ClassGuid,
    OUT PTSTR       ClassDescription,
    IN  DWORD       ClassDescriptionSize,
    OUT PDWORD      RequiredSize,         OPTIONAL
    IN  PCTSTR      MachineName,          OPTIONAL
    IN  PVOID       Reserved
    )
/*++

Routine Description:

    This routine retrieves the class description associated with the specified
    class GUID.

Arguments:

    ClassGuid - Specifies the class GUID to retrieve the description for.

    ClassDescription - Supplies the address of the character buffer that is to receive
        the textual description of the class.

    ClassDescriptionSize - Supplies the size, in characters, of the ClassDescription buffer.

    RequiredSize - Optionally, receives the number of characters required to store
        the class description (including terminating NULL).  This will always be less
        than LINE_LEN.

    MachineName - Optionally, supplies the name of the remote machine where the class
        whose name we're retrieving is installed.  If this parameter is not supplied,
        the local machine is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err = NO_ERROR;
    LONG l;
    TCHAR NullChar = TEXT('\0');
    CONFIGRET cr;
    HKEY hk = INVALID_HANDLE_VALUE;
    DWORD ValueType, BufferSize;
    BOOL DescFound = FALSE;
    HMACHINE hMachine = NULL;

    try {
        //
        // Make sure the caller didn't pass us anything in the Reserved parameter.
        //
        if(Reserved) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // If the caller specified a remote machine name, connect to that machine now.
        //
        if(MachineName) {
            cr = CM_Connect_Machine(MachineName, &hMachine);
            if(cr != CR_SUCCESS) {
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                hMachine = NULL; // don't assume this was left untouched
                leave;
            }
        }

        if(CM_Open_Class_Key_Ex((LPGUID)ClassGuid,
                                NULL,
                                KEY_READ,
                                RegDisposition_OpenExisting,
                                &hk,
                                CM_OPEN_CLASS_KEY_INSTALLER,
                                hMachine) != CR_SUCCESS) {

            Err = ERROR_INVALID_CLASS;
            hk = INVALID_HANDLE_VALUE;
            leave;
        }

        //
        // Retrieve the class description from the opened key.  This is an (optional)
        // unnamed REG_SZ value.
        //
        BufferSize = ClassDescriptionSize * sizeof(TCHAR);
        l = RegQueryValueEx(hk,
                            &NullChar,  // retrieved the unnamed value
                            NULL,
                            &ValueType,
                            (LPBYTE)ClassDescription,
                            &BufferSize
                           );
        if((l == ERROR_SUCCESS) || (l == ERROR_MORE_DATA)) {
            //
            // Verify that the data type is correct.
            //
            if(ValueType == REG_SZ) {
                DescFound = TRUE;
                BufferSize /= sizeof(TCHAR);    // we need this in characters
                //
                // Be careful here, because the user may have passed in a NULL
                // pointer for the ClassDescription buffer (ie, they just wanted
                // to know what size they needed).  RegQueryValueEx would return
                // ERROR_SUCCESS in this case, but we want to return
                // ERROR_INSUFFICIENT_BUFFER.
                //
                if((l == ERROR_MORE_DATA) || !ClassDescription) {
                    Err = ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }

        if(!DescFound) {
            //
            // Then we simply retrieve the class name associated with this GUID--in
            // this case it serves as both name and description.
            //
            BufferSize = ClassDescriptionSize;
            cr = CM_Get_Class_Name_Ex((LPGUID)ClassGuid,
                                      ClassDescription,
                                      &BufferSize,
                                      0,
                                      hMachine
                                     );
            switch(cr) {

                case CR_BUFFER_SMALL :
                    Err = ERROR_INSUFFICIENT_BUFFER;
                    //
                    // Allow to fall through to CR_SUCCESS case.
                    //
                case CR_SUCCESS :
                    DescFound = TRUE;
                    break;

                case CR_REGISTRY_ERROR :
                    Err = ERROR_INVALID_CLASS;
                    break;

                default :
                    Err = ERROR_INVALID_PARAMETER;
            }
        }

        //
        // Store the required size in the output parameter, if supplied.
        //
        if(DescFound && RequiredSize) {
            *RequiredSize = BufferSize;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiBuildClassInfoList(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize
    )
/*++

Routine Description:

    See SetupDiBuildClassInfoListEx for details.

--*/

{
    DWORD Err;

    //
    // Wrap call in try/except to catch stack overflow
    //
    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiBuildClassInfoListEx(Flags,
                                                      ClassGuidList,
                                                      ClassGuidListSize,
                                                      RequiredSize,
                                                      NULL,
                                                      NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiBuildClassInfoListExA(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCSTR  MachineName,       OPTIONAL
    IN  PVOID  Reserved
    )
{
    PCWSTR UnicodeMachineName = NULL;
    DWORD rc;

    try {

        if(MachineName) {
            rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiBuildClassInfoListExW(Flags,
                                                      ClassGuidList,
                                                      ClassGuidListSize,
                                                      RequiredSize,
                                                      UnicodeMachineName,
                                                      Reserved)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}


BOOL
WINAPI
SetupDiBuildClassInfoListEx(
    IN  DWORD  Flags,
    OUT LPGUID ClassGuidList,
    IN  DWORD  ClassGuidListSize,
    OUT PDWORD RequiredSize,
    IN  PCTSTR MachineName,       OPTIONAL
    IN  PVOID  Reserved
    )
/*++

Routine Description:

    This routine returns a list of class GUIDs representing every class installed
    on the user's system. (NOTE: Classes that have a 'NoUseClass' value entry in
    their registry branch will be excluded from this list.)

Arguments:

    Flags - Supplies flags used to control exclusion of classes from the list.  If
        no flags are specified, then all classes are included.  The flags may be a
        combination of the following:

        DIBCI_NOINSTALLCLASS - Exclude a class if it has the value entry
                               'NoInstallClass' in its registry key.
        DIBCI_NODISPLAYCLASS - Exclude a class if it has the value entry
                               'NoDisplayClass' in its registry key.

    ClassGuidList - Supplies the address of an array of GUIDs that will receive the
        GUID list.

    ClassGuidListSize - Supplies the number of GUIDs in the ClassGuidList array.

    RequiredSize - Supplies the address of a variable that will receive the number
        of GUIDs returned.  If this number is greater than the size of the ClassGuidList,
        then this number will specify how large the array needs to be in order to contain
        the list.

    MachineName - Optionally, supplies the name of a remote machine to retrieve installed
        classes from.  If this parameter is not specified, the local machine is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err, ClassGuidCount = 0;
    CONFIGRET cr;
    BOOL MoreToEnum;
    ULONG i;
    HKEY hk = INVALID_HANDLE_VALUE;
    GUID CurClassGuid;
    HMACHINE hMachine = NULL;

    try {
        //
        // Make sure the caller didn't pass us anything in the Reserved parameter.
        //
        if(Reserved) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // If the caller specified a remote machine name, connect to that machine now.
        //
        if(MachineName) {
            cr = CM_Connect_Machine(MachineName, &hMachine);
            if(cr != CR_SUCCESS) {
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                hMachine = NULL; // don't assume this was left untouched
                leave;
            }
        }

        Err = NO_ERROR;

        //
        // Enumerate through the list of all installed classes.
        //
        for(i = 0, MoreToEnum = TRUE; MoreToEnum; i++) {

            cr = CM_Enumerate_Classes_Ex(i,
                                         &CurClassGuid,
                                         0,
                                         hMachine
                                        );
            if(cr != CR_SUCCESS) {
                //
                // For any failure other than no-more-to-enum (or some kind of RPC error),
                // we simply want to go on to the next class.
                //
                switch(cr) {

                    case CR_INVALID_MACHINENAME :
                    case CR_REMOTE_COMM_FAILURE :
                    case CR_MACHINE_UNAVAILABLE :
                    case CR_NO_CM_SERVICES :
                    case CR_ACCESS_DENIED :
                    case CR_CALL_NOT_IMPLEMENTED :
                    case CR_REGISTRY_ERROR :
                        Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                        //
                        // Fall through to 'no more values' case to terminate loop.
                        //
                    case CR_NO_SUCH_VALUE :
                        MoreToEnum = FALSE;
                        break;

                    default :
                        //
                        // Nothing to do.
                        //
                        break;
                }
                continue;
            }

            //
            // Open the key for this class.
            //
            if(CM_Open_Class_Key_Ex(&CurClassGuid,
                                    NULL,
                                    KEY_READ,
                                    RegDisposition_OpenExisting,
                                    &hk,
                                    CM_OPEN_CLASS_KEY_INSTALLER,
                                    hMachine) != CR_SUCCESS) {

                hk = INVALID_HANDLE_VALUE;
                continue;
            }

            //
            // First, check for the presence of the value entry "NoUseClass"
            // If this value is present, then we will skip this class.
            //
            if(RegQueryValueEx(hk, pszNoUseClass, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
                goto LoopNext;
            }

            //
            // Check for special exclusion flags.
            //
            if(Flags & DIBCI_NOINSTALLCLASS) {
                if(RegQueryValueEx(hk, pszNoInstallClass, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
                    goto LoopNext;
                }
            }

            if(Flags & DIBCI_NODISPLAYCLASS) {
                if(RegQueryValueEx(hk, pszNoDisplayClass, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
                    goto LoopNext;
                }
            }

            if(ClassGuidCount < ClassGuidListSize) {
                CopyMemory(&(ClassGuidList[ClassGuidCount]), &CurClassGuid, sizeof(GUID));
            }

            ClassGuidCount++;

LoopNext:
            RegCloseKey(hk);
            hk = INVALID_HANDLE_VALUE;
        }

        if(Err == NO_ERROR) {

            *RequiredSize = ClassGuidCount;

            if(ClassGuidCount > ClassGuidListSize) {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devdrv.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devdrv.c

Abstract:

    Device Installer routines dealing with driver information lists

Author:

    Lonny McMichael (lonnym) 5-July-1995

Revision History:


    Jamie Hunter (JamieHun) July-19-2002
            Reviewed "unsafe" functions

--*/

#include "precomp.h"
#pragma hdrstop

//
// Global list containing nodes for each HDEVINFO currently involved in building
// a driver list.
//
DRVSEARCH_INPROGRESS_LIST GlobalDrvSearchInProgressList;



typedef struct _DRVLIST_TO_APPEND {
    PDRIVER_NODE DriverHead;
    PDRIVER_NODE DriverTail;
    UINT         DriverCount;
} DRVLIST_TO_APPEND, *PDRVLIST_TO_APPEND;

//
// Private function prototypes
//
BOOL
DrvSearchCallback(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR InfName,
    IN PLOADED_INF pInf,
    IN BOOL PnfWasUsed,
    IN PVOID Context
    );

BOOL
pSetupFillInHardwareAndCompatIds(
    PDEVINFO_ELEM DevInfoElem,
    HMACHINE hMachine,
    PDRVSEARCH_CONTEXT DrvSearchContext,
    PSETUP_LOG_CONTEXT LogContext
    );

LONG
pSetupGetInstalledDriverInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    PDRVSEARCH_CONTEXT  DrvSearchContext
    );

BOOL
pSetupTestIsInstalledDriver(
    IN PLOADED_INF        Inf,
    IN PINF_LINE          InfLine,
    IN PCTSTR             Description,
    IN PCTSTR             MfgName,
    IN PCTSTR             ProviderName,
    IN PCTSTR             InfSection,
    IN PCTSTR             InfSectionExt,
    IN PDRVSEARCH_CONTEXT Context
    );

UINT
pSetupTestDevCompat(
    IN  PLOADED_INF        Inf,
    IN  PINF_LINE          InfLine,
    IN  PDRVSEARCH_CONTEXT Context,
    OUT PLONG              MatchIndex
    );

BOOL
pSetupGetDeviceIDs(
    IN OUT PDRIVER_NODE DriverNode,
    IN     PLOADED_INF  Inf,
    IN     PINF_LINE    InfLine,
    IN OUT PVOID        StringTable,
    IN     PINF_SECTION CtlFlagsSection OPTIONAL
    );

BOOL
pSetupShouldDevBeExcluded(
    IN  PCTSTR       DeviceId,
    IN  PLOADED_INF  Inf,
    IN  PINF_SECTION CtlFlagsSection,
    OUT PBOOL        ArchitectureSpecificExclude OPTIONAL
    );

BOOL
pSetupDoesInfContainDevIds(
    IN PLOADED_INF        Inf,
    IN PDRVSEARCH_CONTEXT Context
    );

VOID
pSetupMergeDriverNode(
    IN OUT PDRVSEARCH_CONTEXT Context,
    IN     PDRIVER_NODE       NewDriverNode,
    OUT    PBOOL              InsertedAtHead
    );

DWORD
BuildCompatListFromClassList(
    IN     PDRIVER_NODE       ClassDriverList,
    IN OUT PDRVSEARCH_CONTEXT Context
    );

BOOL
pSetupCalculateRankMatch(
    IN  LONG  DriverHwOrCompatId,
    IN  UINT  InfFieldIndex,
    IN  LONG  DevIdList[2][MAX_HCID_COUNT+1], // Must be same dimension as in DRVSEARCH_CONTEXT!!!
    OUT PUINT Rank
    );

BOOL
pSetupIsSimilarDriver(
    IN  PCTSTR              DriverHwOrCompatId,
    IN  UINT                InfFieldIndex,
    IN  PDRVSEARCH_CONTEXT  Context
    );

BOOL
pSetupExcludeId(
    IN PSETUP_LOG_CONTEXT   LogContext,
    IN PLOADED_INF          Inf,
    IN PCTSTR               InfName,
    IN PCTSTR               InfSection,
    IN PDRVSEARCH_CONTEXT   Context
    );

PDRIVER_NODE
DuplicateDriverNode(
    IN PDRIVER_NODE DriverNode
    );

BOOL
ExtractDrvSearchInProgressNode(
    PDRVSEARCH_INPROGRESS_NODE Node
    );


//
// Define Flags(Ex) bitmask that are inherited along with a class driver list.
//
#define INHERITED_FLAGS   ( DI_ENUMSINGLEINF     \
                          | DI_DIDCLASS          \
                          | DI_MULTMFGS          \
                          | DI_COMPAT_FROM_CLASS )

#define INHERITED_FLAGSEX ( DI_FLAGSEX_DIDINFOLIST              \
                          | DI_FLAGSEX_FILTERCLASSES            \
                          | DI_FLAGSEX_USEOLDINFSEARCH          \
                          | DI_FLAGSEX_DRIVERLIST_FROM_URL      \
                          | DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS \
                          | DI_FLAGSEX_FILTERSIMILARDRIVERS     \
                          | DI_FLAGSEX_INSTALLEDDRIVER          )

BOOL
WINAPI
SetupDiBuildDriverInfoList(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN     DWORD            DriverType
    )
/*++

Routine Description:

    This routine builds a list of drivers associated with a specified device
    instance (or with the device information set's global class driver list).
    These drivers may be either class drivers or device drivers.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set that will
        contain the driver information list (either globally for all members,
        or specifically for a single member).

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for the device information element to build a driver list
        for.  If this parameter is NULL, then the list will be associated
        with the device information set itself, and not with any particular
        device information element.  This is only for driver lists of type
        SPDIT_CLASSDRIVER.

        If the class of this device is updated as a result of building a
        compatible driver list, then the ClassGuid field of this structure
        will be updated upon return.

    DriverType - Specifies what type of driver list should be built.  Must be
        one of the following values:

        SPDIT_CLASSDRIVER  -- Build a list of class drivers.
        SPDIT_COMPATDRIVER -- Build a list of compatible drivers for this device.
                              DeviceInfoData must be specified if this value is
                              used.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    After this API has built the specified driver list, its constituent elements
    may be enumerated via SetupDiEnumDriverInfo.

    If the driver list is associated with a device instance (i.e., DeviceInfoData
    is specified), the resulting list will be composed of drivers that have the
    same class as the device instance with which they are associated.  If this
    is a global class driver list (i.e., DriverType is SPDIT_CLASSDRIVER and
    DeviceInfoData is not specified), then the class that will be used in
    building the list will be the class associated with the device information
    set itself.  If there is no associated class, then drivers of all classes
    will be used in building the list.

    Another thread may abort the building of a driver list by calling
    SetupDiCancelDriverInfoSearch().

    Building a driver info list invalidates and merging it with an existing list
    (e.g., via the DI_FLAGSEX_APPENDDRIVERLIST flag) invalidates the drivernode
    enumeration hint for that driver list.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, i;
    PDEVINFO_ELEM DevInfoElem = NULL;
    HWND hwndParent;
    PDWORD pFlags, pFlagsEx;
    PTSTR TempBuffer = NULL;  // also holds other strings, but this value is largest
    ULONG TempBufferLen;
    ULONG TempBufferSize = REGSTR_VAL_MAX_HCID_LEN;
    PTSTR InfPath = NULL;
    PDRVSEARCH_CONTEXT DrvSearchContext = NULL;
    LPGUID ClassGuid;
    PDRIVER_NODE DriverNode, NextDriverNode;
    LONG MfgNameId, InfPathId = -1;
    PDRIVER_LIST_OBJECT ClassDriverListObject = NULL;
    BOOL HasDrvSearchInProgressLock = FALSE;
    DRVSEARCH_INPROGRESS_NODE DrvSearchInProgressNode;
    BOOL PartialDrvListCleanUp = FALSE;
    HKEY hKey;
    BOOL AppendingDriverLists;
    DRVLIST_TO_APPEND DrvListToAppend;
    BOOL DriverNodeInsertedAtHead;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    HINSTANCE hInstanceCDM = NULL;
    HANDLE hCDMContext = NULL;
    HSPFILEQ UserFileQ;
    SPFUSIONINSTANCE spFusionInstance;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    DrvSearchInProgressNode.SearchCancelledEvent = NULL;
    hKey = INVALID_HANDLE_VALUE;
    AppendingDriverLists = FALSE;

    TempBuffer = MyMalloc(TempBufferSize*sizeof(TCHAR));
    if(!TempBuffer) {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto final;
    }

    DrvSearchContext = MyMalloc(sizeof(DRVSEARCH_CONTEXT));
    if(DrvSearchContext) {
        ZeroMemory(DrvSearchContext, sizeof(DRVSEARCH_CONTEXT));
    } else {
        Err = ERROR_NOT_ENOUGH_MEMORY;
        goto final;
    }

    Err = NO_ERROR;

    try {
        //
        // Build the driver list using a duplicate of the string table for the
        // device information set.  That way, if the driver search is cancelled
        // part-way through, we can restore the original string table, without
        // all the additional (unused) strings hanging around.
        //
        if(!(DrvSearchContext->StringTable = pStringTableDuplicate(pDeviceInfoSet->StringTable))) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        //
        // Store the pointer to the devinfo set in the context structure.  We
        // need this, so that we can add INF class GUIDs to the set's GUID
        // table.
        //
        DrvSearchContext->DeviceInfoSet = pDeviceInfoSet;

        if(DeviceInfoData) {
            //
            // Then we're working with a driver list for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        } else {

            //
            // If the caller did not pass in a DeviceInfoData then we can't get
            // the currently installed driver since we don't know the device.
            //
            if(pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_INSTALLEDDRIVER) {

                Err = ERROR_INVALID_FLAGS;
                goto clean0;
            }
        }

        LogContext = DevInfoElem ?
                            DevInfoElem->InstallParamBlock.LogContext :
                            pDeviceInfoSet->InstallParamBlock.LogContext;

        SetLogSectionName(LogContext, TEXT("Driver Install"));

        //
        // Now, fill in the rest of our context structure based on what type of
        // driver list we're creating.
        //
        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    //
                    // Retrieve the list for a particular device.
                    //
                    if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) {

                        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_APPENDDRIVERLIST) {

                            AppendingDriverLists = TRUE;

                            //
                            // Merging a new driver list into an existing list
                            // invalidates our drivernode enumeration hint.
                            //
                            DevInfoElem->ClassDriverEnumHint = NULL;
                            DevInfoElem->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

                        } else {
                            //
                            // We already have a driver list, and we've not
                            // been asked to append to it, so we're done.
                            //
                            goto clean0;
                        }

                    } else {
                        //
                        // We don't have a class driver list--we'd better not
                        // have a drivernode enumeration hint.
                        //
                        MYASSERT(DevInfoElem->ClassDriverEnumHint == NULL);
                        MYASSERT(DevInfoElem->ClassDriverEnumHintIndex == INVALID_ENUM_INDEX);

                        DrvSearchContext->pDriverListHead = &(DevInfoElem->ClassDriverHead);
                        DrvSearchContext->pDriverListTail = &(DevInfoElem->ClassDriverTail);
                        DrvSearchContext->pDriverCount    = &(DevInfoElem->ClassDriverCount);
                    }

                    pFlags   = &(DevInfoElem->InstallParamBlock.Flags);
                    pFlagsEx = &(DevInfoElem->InstallParamBlock.FlagsEx);

                    UserFileQ = DevInfoElem->InstallParamBlock.UserFileQ;

                    ClassGuid = &(DevInfoElem->ClassGuid);
                    InfPathId = DevInfoElem->InstallParamBlock.DriverPath;

                    //
                    // Retrieve the list of Hardware IDs (index 0) and
                    // Compatible IDs (index 1) from the device's registry properties.
                    //
                    if (!pSetupFillInHardwareAndCompatIds(DevInfoElem,
                                                          pDeviceInfoSet->hMachine,
                                                          DrvSearchContext,
                                                          LogContext
                                                          )) {
                        goto clean0;
                    }

                    //
                    // Set DRVSRCH_FILTERSIMILARDRIVERS flag if the
                    // DI_FLAGSEX_FILTERSIMILARDRIVERS FlagsEx is set.  This will
                    // cause us only to add 'similar' drivers to the class list.  A
                    // 'similar' driver is one where one of the hardware or
                    // compatible Ids in the INF partially match one of the
                    // hardware or compatible Ids of the hardware.
                    //
                    if (*pFlagsEx & DI_FLAGSEX_FILTERSIMILARDRIVERS) {

                        DrvSearchContext->Flags |= DRVSRCH_FILTERSIMILARDRIVERS;

                        //
                        // If no hardware id or compatible ids found, nothing is compatible.
                        //
                        if ((DrvSearchContext->IdList[0][0] == -1) &&
                            (DrvSearchContext->IdList[1][0] == -1)) {

                            goto clean1;
                        }
                    }

                } else {
                    //
                    // Retrieve the list for the device information set itself (globally)
                    //
                    if(pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDINFOLIST) {

                        if(pDeviceInfoSet->InstallParamBlock.FlagsEx & DI_FLAGSEX_APPENDDRIVERLIST) {

                            AppendingDriverLists = TRUE;

                            //
                            // Merging a new driver list into an existing list
                            // invalidates our drivernode enumeration hint.
                            //
                            pDeviceInfoSet->ClassDriverEnumHint = NULL;
                            pDeviceInfoSet->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;

                        } else {
                            //
                            // We already have a driver list, and we've not been asked to append
                            // to it, so we're done.
                            //
                            goto clean0;
                        }

                    } else {
                        //
                        // We don't have a class driver list--we'd better not
                        // have a drivernode enumeration hint.
                        //
                        MYASSERT(pDeviceInfoSet->ClassDriverEnumHint == NULL);
                        MYASSERT(pDeviceInfoSet->ClassDriverEnumHintIndex == INVALID_ENUM_INDEX);

                        DrvSearchContext->pDriverListHead = &(pDeviceInfoSet->ClassDriverHead);
                        DrvSearchContext->pDriverListTail = &(pDeviceInfoSet->ClassDriverTail);
                        DrvSearchContext->pDriverCount    = &(pDeviceInfoSet->ClassDriverCount);
                    }

                    pFlags   = &(pDeviceInfoSet->InstallParamBlock.Flags);
                    pFlagsEx = &(pDeviceInfoSet->InstallParamBlock.FlagsEx);

                    UserFileQ = pDeviceInfoSet->InstallParamBlock.UserFileQ;

                    ClassGuid = &(pDeviceInfoSet->ClassGuid);
                    InfPathId = pDeviceInfoSet->InstallParamBlock.DriverPath;
                }

                if(AppendingDriverLists) {
                    ZeroMemory(&DrvListToAppend, sizeof(DrvListToAppend));
                    DrvSearchContext->pDriverListHead = &(DrvListToAppend.DriverHead);
                    DrvSearchContext->pDriverListTail = &(DrvListToAppend.DriverTail);
                    DrvSearchContext->pDriverCount    = &(DrvListToAppend.DriverCount);
                }

                DrvSearchContext->BuildClassDrvList = TRUE;

                //
                // Class driver lists are always filtered on class.
                //
                DrvSearchContext->Flags |= DRVSRCH_FILTERCLASS;

                //
                // Set the DRVSRCH_NO_CLASSLIST_NODE_MERGE flag in the DrvSearchContext
                // if the caller set the DI_FLAGSEX_NO_CLASSLIST_NODE_MERGE.  If this
                // flag is set then we will not remove/merge identical driver nodes.
                //
                if (*pFlagsEx & DI_FLAGSEX_NO_CLASSLIST_NODE_MERGE) {

                    DrvSearchContext->Flags |= DRVSRCH_NO_CLASSLIST_NODE_MERGE;
                }

                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {

                    if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_DIDCOMPATINFO) {

                        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_APPENDDRIVERLIST) {

                            AppendingDriverLists = TRUE;

                            //
                            // Merging a new driver list into an existing list
                            // invalidates our drivernode enumeration hint.
                            //
                            DevInfoElem->CompatDriverEnumHint = NULL;
                            DevInfoElem->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;

                        } else {
                            //
                            // We already have a driver list, and we've not been asked to append
                            // to it, so we're done.
                            //
                            goto clean0;
                        }

                    } else {
                        //
                        // We don't have a compatible driver list--we'd better
                        // not have a drivernode enumeration hint.
                        //
                        MYASSERT(DevInfoElem->CompatDriverEnumHint == NULL);
                        MYASSERT(DevInfoElem->CompatDriverEnumHintIndex == INVALID_ENUM_INDEX);
                    }

                    //
                    // NOTE: The following variables must be set before retrieving the
                    // hardware/compatible ID lists, as execution may transfer to the
                    // 'clean1' label, that relies on these values.
                    //
                    pFlags   = &(DevInfoElem->InstallParamBlock.Flags);
                    pFlagsEx = &(DevInfoElem->InstallParamBlock.FlagsEx);

                    UserFileQ = DevInfoElem->InstallParamBlock.UserFileQ;

                    DrvSearchContext->BuildClassDrvList = FALSE;

                    //
                    // We're building a compatible driver list--retrieve the list of Hardware IDs
                    // (index 0) and Compatible IDs (index 1) from the device's registry properties.
                    //
                    if (!pSetupFillInHardwareAndCompatIds(DevInfoElem,
                                                          pDeviceInfoSet->hMachine,
                                                          DrvSearchContext,
                                                          LogContext
                                                          )) {
                        goto clean0;
                    }

                    //
                    // If no hardware id or compatible ids found, nothing is compatible.
                    //
                    if ((DrvSearchContext->IdList[0][0] == -1) &&
                        (DrvSearchContext->IdList[1][0] == -1)) {

                        goto clean1;
                    }

                    //
                    // Compatible driver lists are filtered on class only if the
                    // DI_FLAGSEX_USECLASSFORCOMPAT flag is set.
                    //
                    DrvSearchContext->Flags |= (*pFlagsEx & DI_FLAGSEX_USECLASSFORCOMPAT)
                                                 ? DRVSRCH_FILTERCLASS : 0;

                    ClassGuid = &(DevInfoElem->ClassGuid);

                    if(AppendingDriverLists) {
                        ZeroMemory(&DrvListToAppend, sizeof(DrvListToAppend));
                        DrvSearchContext->pDriverListHead   = &(DrvListToAppend.DriverHead);
                        DrvSearchContext->pDriverListTail   = &(DrvListToAppend.DriverTail);
                        DrvSearchContext->pDriverCount      = &(DrvListToAppend.DriverCount);
                    } else {
                        DrvSearchContext->pDriverListHead   = &(DevInfoElem->CompatDriverHead);
                        DrvSearchContext->pDriverListTail   = &(DevInfoElem->CompatDriverTail);
                        DrvSearchContext->pDriverCount      = &(DevInfoElem->CompatDriverCount);
                    }

                    if(*pFlags & DI_COMPAT_FROM_CLASS) {

                        PDRIVER_LIST_OBJECT TempDriverListObject;

                        //
                        // The caller wants to build the compatible driver list based on an
                        // existing class driver list--first make sure that there _is_ a class
                        // driver list.
                        //
                        if(!(*pFlagsEx & DI_FLAGSEX_DIDINFOLIST)) {
                            Err = ERROR_NO_CLASS_DRIVER_LIST;
                            goto clean0;
                        } else if(!(DevInfoElem->ClassDriverHead)) {
                            //
                            // Then the class driver list is empty.  There's no need to do
                            // any more work, just say that we succeeded.
                            //
                            Err = NO_ERROR;
                            goto clean1;
                        }

                        //
                        // When we're building a compatible driver list from an existing class
                        // driver list, we don't do any checking on INF class (i.e., to update
                        // the device's class if the most-compatible driver is of a different
                        // device class).  Because of this, we must ensure that (a) the class
                        // driver list was built for a particular class, and that (b) that class
                        // matches the current class for this device.
                        //
                        TempDriverListObject = GetAssociatedDriverListObject(
                                                   pDeviceInfoSet->ClassDrvListObjectList,
                                                   DevInfoElem->ClassDriverHead,
                                                   NULL
                                                  );

                        MYASSERT(TempDriverListObject);

                        //
                        // Everything's in order--go search through the existing
                        // class driver list for compatible drivers.
                        //
                        if((Err = BuildCompatListFromClassList(DevInfoElem->ClassDriverHead,
                                                               DrvSearchContext)) == NO_ERROR) {
                            goto clean2;
                        } else {
                            goto clean0;
                        }

                    } else {
                        InfPathId = DevInfoElem->InstallParamBlock.DriverPath;
                    }

                    break;
                }
                //
                // If no device instance specified, let fall through to error.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        if(IsEqualGUID(ClassGuid, &GUID_NULL)) {
            //
            // If there is no class GUID, then don't try to filter on it.
            //
            DrvSearchContext->Flags &= ~DRVSRCH_FILTERCLASS;
        } else {
            //
            // Copy the class GUID to the ClassGuid field in our context structure.
            //
            CopyMemory(&(DrvSearchContext->ClassGuid),
                       ClassGuid,
                       sizeof(GUID)
                      );
            DrvSearchContext->Flags |= DRVSRCH_HASCLASSGUID;

            //
            // If we are building a class list, and filtering is requested,
            // then make sure that the class doesn't have NoUseClass value
            // entries in its registry key.
            //
            // Also exclude NoInstallClass unless the
            // DI_FLAGSEX_ALLOWEXCLUDEDDRVS flag is set.
            //
            if(DrvSearchContext->BuildClassDrvList &&
               (*pFlagsEx & DI_FLAGSEX_FILTERCLASSES)) {

                if(ShouldClassBeExcluded(&(DrvSearchContext->ClassGuid), !(*pFlagsEx & DI_FLAGSEX_ALLOWEXCLUDEDDRVS))) {

                    //
                    // If the class has been filtered out, simply return success.
                    //
                    goto clean1;
                }
            }

            //
            // If we're going to be filtering on this class, then store its
            // string representation in the context structure as well, as an
            // optimization for PreprocessInf().
            //
            if(DrvSearchContext->Flags & DRVSRCH_FILTERCLASS) {
                pSetupStringFromGuid(ClassGuid,
                                     DrvSearchContext->ClassGuidString,
                                     SIZECHARS(DrvSearchContext->ClassGuidString)
                                    );
            }
        }

        //
        // If we're supposed to do our driver search based on an alternate
        // (i.e., non-native) platform, then store that information away in our
        // context structure.
        //
        if(*pFlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {
            //
            // We must have a user-supplied file queue.
            //
            MYASSERT(*pFlags & DI_NOVCP);
            MYASSERT(UserFileQ && (UserFileQ != INVALID_HANDLE_VALUE));

            if((((PSP_FILE_QUEUE)UserFileQ)->Signature != SP_FILE_QUEUE_SIG) ||
               !(((PSP_FILE_QUEUE)UserFileQ)->Flags & FQF_USE_ALT_PLATFORM)) {

                Err = ERROR_INVALID_PARAMETER;

                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_WARNING,
                    MSG_LOG_NO_QUEUE_FOR_ALTPLATFORM_DRVSEARCH,
                    NULL
                   );

                goto clean0;
            }

            DrvSearchContext->AltPlatformInfo =
                &(((PSP_FILE_QUEUE)UserFileQ)->AltPlatformInfo);

        } else {
            //
            // We're not doing a non-native driver search...
            //
            DrvSearchContext->AltPlatformInfo = NULL;
        }

        if(DrvSearchContext->BuildClassDrvList) {
            //
            // Allocate a new driver list object to store the class driver list in once
            // we've created it.  (Don't do this if we're appending driver lists.)
            //
            if(!AppendingDriverLists) {
                if(!(ClassDriverListObject = MyMalloc(sizeof(DRIVER_LIST_OBJECT)))) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            }
        }

        //
        // Only include ExcludeFromSelect devices and NoInstallClass classes
        // if the DI_FLAGSEX_ALLOWEXCLUDEDDRVS flag is set.
        //
        if (*pFlagsEx & DI_FLAGSEX_ALLOWEXCLUDEDDRVS) {

            DrvSearchContext->Flags |= DRVSRCH_ALLOWEXCLUDEDDRVS;
        }

        //
        // If the caller just wants us to get the currently installed driver then
        // we need to get the INF path of the currently installed driver.
        //
        if (*pFlagsEx & DI_FLAGSEX_INSTALLEDDRIVER) {

            DrvSearchContext->Flags |= DRVSRCH_INSTALLEDDRIVER;

            InfPathId = pSetupGetInstalledDriverInfo(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     DrvSearchContext
                                                     );

            //
            // If the InfPathId is -1 then we were unable to get the InfPath
            // for this device.  This is most likely because this is a new
            // device or the device doesn't currently have a driver installed
            // on it.  In any case there is nothing to do here so just return
            // success.
            //
            if (InfPathId == -1) {
                Err = NO_ERROR;
                goto clean1;
            }
        }

        //
        // Set up a "Driver Search In-Progress" node in the global list, that will be
        // used in case some other thread wants us to abort part-way through.
        //
        if(LockDrvSearchInProgressList(&GlobalDrvSearchInProgressList)) {

            HasDrvSearchInProgressLock = TRUE;

            if(DrvSearchInProgressNode.SearchCancelledEvent = CreateEvent(NULL, TRUE, FALSE, NULL)) {
                DrvSearchInProgressNode.CancelSearch = FALSE;
                DrvSearchInProgressNode.DeviceInfoSet = DeviceInfoSet;
                DrvSearchInProgressNode.Next = GlobalDrvSearchInProgressList.DrvSearchHead;
                GlobalDrvSearchInProgressList.DrvSearchHead = &DrvSearchInProgressNode;
                Err = NO_ERROR;
            } else {
                Err = GetLastError();
            }

            UnlockDrvSearchInProgressList(&GlobalDrvSearchInProgressList);
            HasDrvSearchInProgressLock = FALSE;

            if(Err != NO_ERROR) {
                goto clean0;
            }

        } else {
            //
            // The only reason this should happen is if we're in the middle of DLL_PROCESS_DETACH,
            // and the list has already been destroyed.
            //
            Err = ERROR_INVALID_DATA;
            goto clean0;
        }

        //
        // Now store away a pointer to the 'CancelSearch' flag in our context structure, so that
        // we can check it periodically while building the driver list (specifically, we check it
        // before examining each INF).
        //
        DrvSearchContext->CancelSearch = &(DrvSearchInProgressNode.CancelSearch);

        PartialDrvListCleanUp = TRUE;   // after this point, clean-up is necessary upon exception.

        //
        // First see if we need to get the driver package from the Internet
        //
        if (*pFlagsEx & DI_FLAGSEX_DRIVERLIST_FROM_URL) {

            //
            // Currently this is not supported, but in the future we might allow
            // alternate Internet servers were users can get driver updates.
            //
            if (InfPathId != -1) {

                //
                // No InfPath was specified so we will go to the Microsoft Windows
                // Update server.
                //
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;

            } else {

                DOWNLOADINFO DownloadInfo;
                TCHAR CDMPath[MAX_PATH];
                TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
                ULONG BufferLen;
                OPEN_CDM_CONTEXT_PROC pfnOpenCDMContext;
                CLOSE_CDM_CONTEXT_PROC pfnCloseCDMContext;
                DOWNLOAD_UPDATED_FILES_PROC pfnDownloadUpdatedFiles;

                //
                // Search Windows Update.
                //
                spFusionEnterContext(NULL,&spFusionInstance);

                if(hInstanceCDM = LoadLibrary(TEXT("CDM.DLL"))) {

                    if((pfnOpenCDMContext =
                        (OPEN_CDM_CONTEXT_PROC)GetProcAddress(hInstanceCDM, "OpenCDMContext")) &&
                       (pfnCloseCDMContext =
                        (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hInstanceCDM, "CloseCDMContext")) &&
                       (pfnDownloadUpdatedFiles =
                        (DOWNLOAD_UPDATED_FILES_PROC)GetProcAddress(hInstanceCDM, "DownloadUpdatedFiles"))) {

                        if (hCDMContext = pfnOpenCDMContext(DevInfoElem->InstallParamBlock.hwndParent)) {

                            //
                            // Fill In the DOWNLOADINFO structure to pass to CDM.DLL
                            //
                            ZeroMemory(&DownloadInfo, sizeof(DOWNLOADINFO));
                            DownloadInfo.dwDownloadInfoSize = sizeof(DOWNLOADINFO);
                            DownloadInfo.lpFile = NULL;

                            if(CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                                                DeviceInstanceId,
                                                sizeof(DeviceInstanceId)/sizeof(TCHAR),
                                                0,
                                                pDeviceInfoSet->hMachine
                                                ) != CR_SUCCESS) {
                                //
                                // This should never happen!
                                //
                                Err = ERROR_NO_SUCH_DEVINST;
                            } else {
                                DownloadInfo.lpDeviceInstanceID = (LPCWSTR)DeviceInstanceId;


                                GetVersionEx((OSVERSIONINFOW *)&DownloadInfo.OSVersionInfo);

                                //
                                // Set dwArchitecture to PROCESSOR_ARCHITECTURE_UNKNOWN, this
                                // causes Windows Update to check get the architecture of the
                                // machine itself.  You only need to explictly set the value if
                                // you want to download drivers for a different architecture then
                                // the machine this is running on.
                                //
                                DownloadInfo.dwArchitecture = PROCESSOR_ARCHITECTURE_UNKNOWN;
                                DownloadInfo.dwFlags = 0;
                                DownloadInfo.dwClientID = 0;
                                DownloadInfo.localid = 0;

                                CDMPath[0] = TEXT('\0');

                                //
                                // Tell CDM.DLL to download any driver packages it has that match the
                                // Hardware or Compatible IDs for this device.
                                //
                                if ((pfnDownloadUpdatedFiles(hCDMContext,
                                                            DevInfoElem->InstallParamBlock.hwndParent,
                                                            &DownloadInfo,
                                                            CDMPath,
                                                            sizeof(CDMPath),
                                                            &BufferLen)) &&

                                    (CDMPath[0] != TEXT('\0'))) {

                                    //
                                    // Windows Update found a driver package so enumerate all of
                                    // the INFs in the specified directory
                                    //
                                    DrvSearchContext->Flags |= (DRVSRCH_FROM_INET | DRVSRCH_CLEANUP_SOURCE_PATH);

                                    spFusionLeaveContext(&spFusionInstance);
                                    Err = EnumDrvInfsInDirPathList(CDMPath,
                                                                INFINFO_INF_PATH_LIST_SEARCH,
                                                                DrvSearchCallback,
                                                                TRUE,
                                                                LogContext,
                                                                (PVOID)DrvSearchContext
                                                               );
                                    spFusionEnterContext(NULL,&spFusionInstance);
                                }
                            }
                            pfnCloseCDMContext(hCDMContext);
                            hCDMContext = NULL;
                        }
                    }

                    FreeLibrary(hInstanceCDM);
                    hInstanceCDM = NULL;
                }
                spFusionLeaveContext(&spFusionInstance);
            }

        }

        //
        // Now, retrieve the driver list.
        //
        else if((*pFlagsEx & DI_FLAGSEX_USEOLDINFSEARCH) || (InfPathId != -1)) {

            //
            // If this driver came from the Internet then set the
            // DRVSRCH_FROM_INET flag
            //
            if (*pFlagsEx & DI_FLAGSEX_INET_DRIVER) {

                DrvSearchContext->Flags |= DRVSRCH_FROM_INET;
            }

            InfPath = pStringTableStringFromId(DrvSearchContext->StringTable,
                                               InfPathId
                                               );


            if((*pFlags & DI_ENUMSINGLEINF) ||
               (*pFlagsEx & DI_FLAGSEX_INSTALLEDDRIVER)) {
                if(InfPath) {

                    Err = NO_ERROR;

                    if(InfPath == pSetupGetFileTitle(InfPath)) {
                        //
                        // The specified INF path is a simple filename.
                        // Search for it in the directories listed in the
                        // DevicePath search list.  The most likely scenario
                        // here is that the caller is trying to build a driver
                        // list based on the INF used previously to install
                        // the device.  In that case, they would've retrieved
                        // the InfPath value from the device's driver key, and
                        // this value is a simple filename.  INFs are always
                        // placed into the Inf directory when they're used to
                        // install a device, so the only valid place to look for
                        // this INF is in %windir%\Inf.
                        //
                        if(!MYVERIFY(SUCCEEDED(StringCchCopy(TempBuffer,TempBufferSize,InfDirectory))
                                     && pSetupConcatenatePaths(TempBuffer,
                                                               InfPath,
                                                               TempBufferSize,
                                                               NULL
                                                               ))) {
                            //
                            // temp buffer overflowed - shouldn't happen
                            //
                            Err = ERROR_BUFFER_OVERFLOW;
                        }

                        DrvSearchContext->Flags |= DRVSRCH_TRY_PNF;

                    } else {

                        PTSTR DontCare;

                        //
                        // The specified INF filename contains more than just
                        // a filename.  Assume it's an absolute path.
                        //
                        // (We need to get the fully-qualified form of this path,
                        // because that's what EnumSingleDrvInf expects.)
                        //
                        TempBufferLen = GetFullPathName(InfPath,
                                                        TempBufferSize,
                                                        TempBuffer,
                                                        &DontCare
                                                       );

                        if(!TempBufferLen) {
                            Err = GetLastError();
                        } else if(!MYVERIFY(TempBufferLen < TempBufferSize)) {
                            Err = ERROR_BUFFER_OVERFLOW;
                        }
                    }

                    if(Err == NO_ERROR) {

                        WIN32_FIND_DATA InfFileData;

                        if (FileExists(TempBuffer, &InfFileData)) {

                            Err = EnumSingleDrvInf(TempBuffer,
                                                &InfFileData,
                                                INFINFO_INF_NAME_IS_ABSOLUTE,
                                                DrvSearchCallback,
                                                LogContext,
                                                (PVOID)DrvSearchContext
                                               );
                        } else {
                            Err = GetLastError();
                        }
                    }

                } else {
                    Err = ERROR_NO_INF;
                }

            } else {
                Err = EnumDrvInfsInDirPathList(InfPath,
                                            INFINFO_INF_PATH_LIST_SEARCH,
                                            DrvSearchCallback,
                                            TRUE,
                                            LogContext,
                                            (PVOID)DrvSearchContext
                                           );
            }

        } else {
            //
            // On Win95, this code path uses an INF index scheme.  Since the Setup APIs
            // utilize precompiled INFs instead, this 'else' clause is really no different
            // than the 'if' part.  However, if in the future we decide to do indexing a`la
            // Win95, then this is the place where we'd put a call such as:
            //
            // Err = BuildDrvListFromInfIndex();
            //
            DrvSearchContext->Flags |= DRVSRCH_TRY_PNF;

            //
            // If the caller wants to exclude existing (old) Internet
            // drivers then set the DRVSRCH_EXCLUDE_OLD_INET_DRIVERS flag.
            //
            if (*pFlagsEx & DI_FLAGSEX_EXCLUDE_OLD_INET_DRIVERS) {

                DrvSearchContext->Flags |= DRVSRCH_EXCLUDE_OLD_INET_DRIVERS;
            }

            Err = EnumDrvInfsInDirPathList(NULL,
                                        INFINFO_INF_PATH_LIST_SEARCH,
                                        DrvSearchCallback,
                                        TRUE,
                                        LogContext,
                                        (PVOID)DrvSearchContext
                                       );
        }

        //
        // Extract our node from the "Driver Search In-Progress" list, and signal the waiting
        // threads if an abort is pending.
        //
        if(ExtractDrvSearchInProgressNode(&DrvSearchInProgressNode)) {
            Err = ERROR_CANCELLED;
        }

        if(Err != NO_ERROR) {

            if(Err == ERROR_CANCELLED) {
                //
                // Clean up the partial list we built.
                //
                DestroyDriverNodes(*(DrvSearchContext->pDriverListHead), pDeviceInfoSet);
                *(DrvSearchContext->pDriverListHead) = *(DrvSearchContext->pDriverListTail) = NULL;
                *(DrvSearchContext->pDriverCount) = 0;
            }

            goto clean0;
        }

clean2:
        if(DrvSearchContext->BuildClassDrvList) {

            if(AppendingDriverLists) {

                DriverNode = *(DrvSearchContext->pDriverListHead);

                //
                // Now 'fix up' the driver search context so that it points to the
                // real class list fields.  That way when we merge the new driver nodes
                // into the list, everything will be updated properly.
                //
                if(DevInfoElem) {
                    DrvSearchContext->pDriverListHead = &(DevInfoElem->ClassDriverHead);
                    DrvSearchContext->pDriverListTail = &(DevInfoElem->ClassDriverTail);
                    DrvSearchContext->pDriverCount    = &(DevInfoElem->ClassDriverCount);
                } else {
                    DrvSearchContext->pDriverListHead = &(pDeviceInfoSet->ClassDriverHead);
                    DrvSearchContext->pDriverListTail = &(pDeviceInfoSet->ClassDriverTail);
                    DrvSearchContext->pDriverCount    = &(pDeviceInfoSet->ClassDriverCount);
                }

                //
                // Merge our newly-built driver list with the already-existing one.
                //
                while(DriverNode) {
                    //
                    // Store a pointer to the next driver node before merging, because
                    // the driver node we're working with may be destroyed because it's
                    // a duplicate of a driver node already in the list.
                    //
                    NextDriverNode = DriverNode->Next;
                    pSetupMergeDriverNode(DrvSearchContext, DriverNode, &DriverNodeInsertedAtHead);
                    DriverNode = NextDriverNode;
                }
            }

            if(DriverNode = *(DrvSearchContext->pDriverListHead)) {
                //
                // Look through the class driver list we just built, and see if
                // all drivers are from the same manufacturer.  If not, set the
                // DI_MULTMFGS flag.
                //
                MfgNameId = DriverNode->MfgName;

                for(DriverNode = DriverNode->Next;
                    DriverNode;
                    DriverNode = DriverNode->Next) {

                    if(DriverNode->MfgName != MfgNameId) {
                        *pFlags |= DI_MULTMFGS;
                        break;
                    }
                }
            }

        } else {

            if(AppendingDriverLists) {

                DriverNode = *(DrvSearchContext->pDriverListHead);

                //
                // Now 'fix up' the driver search context so that it points to the
                // real compatible list fields.
                //
                DrvSearchContext->pDriverListHead = &(DevInfoElem->CompatDriverHead);
                DrvSearchContext->pDriverListTail = &(DevInfoElem->CompatDriverTail);
                DrvSearchContext->pDriverCount    = &(DevInfoElem->CompatDriverCount);

                //
                // Check the rank of the best-matching driver node in our new list, and see
                // if it's better than the one at the front of the previously-existing list.
                // If so, then we'll want to update the class of this devinfo element to reflect
                // this new class.
                //
                if(DriverNode && DrvSearchContext->Flags & DRVSRCH_HASCLASSGUID) {

                    if(DevInfoElem->CompatDriverHead &&
                       (DriverNode->Rank >= DevInfoElem->CompatDriverHead->Rank)) {
                        //
                        // There was already a compatible driver with a better rank match
                        // in the list, so don't update the class.
                        //
                        DrvSearchContext->Flags &= ~DRVSRCH_HASCLASSGUID;

                    } else {
                        //
                        // The head of the new driver list is a better match than any of the
                        // entries in the existing list.  Make sure that the class of this new
                        // driver node 'fits' into the devinfo set/element.  (We do this before
                        // the actual list merging, so that we don't mess up the original list
                        // in case of error).
                        //
                        if(pDeviceInfoSet->HasClassGuid &&
                           !IsEqualGUID(ClassGuid, &(DrvSearchContext->ClassGuid))) {

                            Err = ERROR_CLASS_MISMATCH;

                            //
                            // Clean up the partial list we built.
                            //
                            DestroyDriverNodes(DriverNode, pDeviceInfoSet);

                            goto clean0;
                        }
                    }
                }

                //
                // OK, if we get to here, then it's safe to go ahead and merge the new compatible
                // driver list in with our existing one.
                //
                while(DriverNode) {
                    //
                    // Store a pointer to the next driver node before merging, because
                    // the driver node we're working with may be destroyed because it's
                    // a duplicate of a driver node already in the list.
                    //
                    NextDriverNode = DriverNode->Next;
                    pSetupMergeDriverNode(DrvSearchContext, DriverNode, &DriverNodeInsertedAtHead);
                    DriverNode = NextDriverNode;
                }
            }

            //
            // Update the class of the device information element based on the
            // class of the most-compatible driver node we retrieved.  Don't do
            // this, however, if the device already has a selected driver.
            //
            if(!DevInfoElem->SelectedDriver &&
               (DrvSearchContext->Flags & DRVSRCH_HASCLASSGUID) &&
               !IsEqualGUID(ClassGuid, &(DrvSearchContext->ClassGuid))) {
                //
                // The class GUID for this device has changed.  We need to make sure
                // that the devinfo set doesn't have an associated class.  Otherwise,
                // we will introduce an inconsistency into the set, where a device
                // contained in the set is of a different class than the set itself.
                //
                // Also, make sure this isn't a remoted HDEVINFO set.  Since
                // changing a device's class requires invoking class-/co-installers
                // (and we don't support that remotely), we have to fail the call.
                //
                if(pDeviceInfoSet->HasClassGuid) {
                    Err = ERROR_CLASS_MISMATCH;
                } else if(pDeviceInfoSet->hMachine) {
                    Err = ERROR_REMOTE_REQUEST_UNSUPPORTED;
                } else {
                    Err = InvalidateHelperModules(DeviceInfoSet, DeviceInfoData, 0);
                }

                if(Err != NO_ERROR) {
                    //
                    // Clean up the partial list we built.
                    //
                    DestroyDriverNodes(*(DrvSearchContext->pDriverListHead), pDeviceInfoSet);
                    *(DrvSearchContext->pDriverListHead) = *(DrvSearchContext->pDriverListTail) = NULL;
                    *(DrvSearchContext->pDriverCount) = 0;

                    goto clean0;
                }

                //
                // We need to clean up any existing software keys associated
                // with this device instance before changing its class, or
                // otherwise we'll have orphaned registry keys.
                //
                pSetupDeleteDevRegKeys(DevInfoElem->DevInst,
                                       DICS_FLAG_GLOBAL | DICS_FLAG_CONFIGSPECIFIC,
                                       (DWORD)-1,
                                       DIREG_DRV,
                                       TRUE,
                                       pDeviceInfoSet->hMachine // must be NULL
                                      );

                //
                // Update the device's class GUID, and also update the caller-supplied
                // SP_DEVINFO_DATA structure to reflect the device's new class.
                //
                CopyMemory(ClassGuid,
                           &(DrvSearchContext->ClassGuid),
                           sizeof(GUID)
                          );

                CopyMemory(&(DeviceInfoData->ClassGuid),
                           &(DrvSearchContext->ClassGuid),
                           sizeof(GUID)
                          );

                //
                // Finally, update the device's ClassGUID registry property.  Also, if the
                // INF specified a class name, update that too, since this may be a class
                // that hasn't yet been installed, thus no class name would be known.
                //
                pSetupStringFromGuid(ClassGuid, TempBuffer, TempBufferSize);
                CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                 CM_DRP_CLASSGUID,
                                                 (PVOID)TempBuffer,
                                                 GUID_STRING_LEN * sizeof(TCHAR),
                                                 0,
                                                 pDeviceInfoSet->hMachine);

                if(*DrvSearchContext->ClassName) {

                    CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                                     CM_DRP_CLASS,
                                                     (PBYTE)DrvSearchContext->ClassName,
                                                     (lstrlen(DrvSearchContext->ClassName) + 1) * sizeof(TCHAR),
                                                     0,
                                                     pDeviceInfoSet->hMachine);
                }
            }
        }

clean1:
        //
        // Replace our existing string table with the new one containing the additional strings
        // used by the new driver nodes.
        //
        pStringTableDestroy(pDeviceInfoSet->StringTable);
        pDeviceInfoSet->StringTable = DrvSearchContext->StringTable;
        DrvSearchContext->StringTable = NULL;

        //
        // Set the flags to indicate that the driver list was built successfully.
        //
        *pFlagsEx |= (DriverType == SPDIT_CLASSDRIVER) ? DI_FLAGSEX_DIDINFOLIST
                                                       : DI_FLAGSEX_DIDCOMPATINFO;
        //
        // Since we aren't using partial information via a separate index, we build
        // the driver list with both basic and detailed information.
        //
        // NOTE:  If we ever use indexing like Win95, then the following flags should
        //        no longer be set here, and should only be set when the detailed
        //        driver information is actually retrieved from the INF.
        //
        *pFlags |= (DriverType == SPDIT_CLASSDRIVER) ? DI_DIDCLASS
                                                     : DI_DIDCOMPAT;

        //
        // If we built a non-empty class driver list, then create a driver list object
        // for it, and store it in the device information set's list of class driver lists.
        // (Don't worry that we're ignoring this if the list is empty--the memory allocated
        // for ClassDriverListObject will get cleaned up later.)
        //
        // (If we're merely appending to an existing class driver list, then don't create
        // a new driver list object.)
        //
        if(DrvSearchContext->BuildClassDrvList && !AppendingDriverLists &&
           (DriverNode = *(DrvSearchContext->pDriverListHead))) {

            ClassDriverListObject->RefCount = 1;
            ClassDriverListObject->ListCreationFlags   = *pFlags & INHERITED_FLAGS;
            ClassDriverListObject->ListCreationFlagsEx = *pFlagsEx & INHERITED_FLAGSEX;
            ClassDriverListObject->ListCreationDriverPath = InfPathId;
            ClassDriverListObject->DriverListHead = DriverNode;

            CopyMemory(&(ClassDriverListObject->ClassGuid), ClassGuid, sizeof(GUID));

            //
            // Now add this to the devinfo set's list, and clear the pointer, so that we won't
            // try to free it.
            //
            ClassDriverListObject->Next = pDeviceInfoSet->ClassDrvListObjectList;
            pDeviceInfoSet->ClassDrvListObjectList = ClassDriverListObject;

            ClassDriverListObject = NULL;
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Err = ERROR_INVALID_PARAMETER;

        if(HasDrvSearchInProgressLock) {
            UnlockDrvSearchInProgressList(&GlobalDrvSearchInProgressList);
        }

        ExtractDrvSearchInProgressNode(&DrvSearchInProgressNode);

        //
        // Clean up any driver nodes we may have created.
        //
        if(PartialDrvListCleanUp) {
            DestroyDriverNodes(*(DrvSearchContext->pDriverListHead), pDeviceInfoSet);
            *(DrvSearchContext->pDriverListHead) = *(DrvSearchContext->pDriverListTail) = NULL;
            *(DrvSearchContext->pDriverCount) = 0;
            //
            // Clean up any flags that may have been set.
            //
            if(!AppendingDriverLists && pFlags && pFlagsEx) {
                if(DriverType == SPDIT_CLASSDRIVER) {
                    *pFlags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                    *pFlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;
                } else {
                    *pFlags   &= ~DI_DIDCOMPAT;
                    *pFlagsEx &= ~DI_FLAGSEX_DIDCOMPATINFO;
                }
            }
        }

        if(hKey != INVALID_HANDLE_VALUE) {
            RegCloseKey(hKey);
        }

        //
        // Access the following variables so that the compiler will respect our statement ordering
        // w.r.t. these values.
        //
        ClassDriverListObject = ClassDriverListObject;
        DrvSearchContext->StringTable = DrvSearchContext->StringTable;
    }

final:

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(ClassDriverListObject) {
        MyFree(ClassDriverListObject);
    }

    if(DrvSearchInProgressNode.SearchCancelledEvent) {
        CloseHandle(DrvSearchInProgressNode.SearchCancelledEvent);
    }

    //
    // Close the CDM context and free cdm.dll if we haven't already.
    //
    if (hInstanceCDM) {

        spFusionEnterContext(NULL,&spFusionInstance);

        if (hCDMContext) {

            CLOSE_CDM_CONTEXT_PROC pfnCloseCDMContext;

            if (pfnCloseCDMContext =  (CLOSE_CDM_CONTEXT_PROC)GetProcAddress(hInstanceCDM,
                            "CloseCDMContext")) {

                pfnCloseCDMContext(hCDMContext);
            }
        }

        FreeLibrary(hInstanceCDM);

        spFusionLeaveContext(&spFusionInstance);
    }

    if(TempBuffer) {
        MyFree(TempBuffer);
    }

    if(DrvSearchContext) {

        if(DrvSearchContext->StringTable) {
            pStringTableDestroy(DrvSearchContext->StringTable);
        }

        //
        // Free any context handles that may have been allocated during the
        // driver search.
        //
        pSetupFreeVerifyContextMembers(&(DrvSearchContext->VerifyContext));

        MyFree(DrvSearchContext);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
DrvSearchCallback(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN PCTSTR InfName,
    IN PLOADED_INF Inf,
    IN BOOL PnfWasUsed,
    IN PVOID pContext
    )
/*++

Routine Description:

    This routine is a callback function for the INF enumeration routines
    (EnumSingleDrvInf, EnumDrvInfsInSearchPath).  It performs
    some action on the INF it's called for, then returns TRUE to continue
    enumeration, or FALSE to abort it.

Arguments:

    LogContext - Supplies information for logging purposes

    InfName - Supplies the fully-qualified pathname of the INF.

    pInf - Supplies pointer to the already loaded INF

    pContext - Supplies a pointer to an input/output storage buffer for use
        by the callback.  For this callback, this pointer supplies the address
        of a DRVSEARCH_CONTEXT structure.

Return Value:

    To continue enumeration, the function should return TRUE, otherwise, it
    should return FALSE.

Remarks:

    We never abort enumeration in case of failure, even if that
    failure is due to an out-of-memory condition!

--*/
{
    PDRVSEARCH_CONTEXT Context = (PDRVSEARCH_CONTEXT)pContext;
    PCTSTR Provider, ClassName;
    PTSTR CurMfgName, CurMfgSecName, DevDesc, InstallSecName, DrvDesc, MatchedHwID;
    PINF_SECTION MfgListSection, CurMfgSection, OptionsTextOrCtlFlagsSection;
    PINF_LINE MfgListLine, CurMfgLine, DrvDescLine;
    UINT MfgListIndex, CurMfgIndex, TempUint;
    TCHAR TempStringBuffer[MAX_SECT_NAME_LEN + MAX_INFSTR_STRKEY_LEN];
    UINT Rank;
    PDRIVER_NODE NewDriverNode;
    GUID InfClassGuid;
    BOOL InsertedAtHead;
    TCHAR OptionsTextSectionName[64];
    PCTSTR LanguageName;
    LONG MatchIndex;
    LONG InfClassGuidIndex;
    TCHAR InfSectionWithExt[MAX_SECT_NAME_LEN];
    DWORD InfSectionWithExtLength;
    PTSTR InfSectionExtension;
    BOOL InfIsDigitallySigned = FALSE;
    BOOL InfIsAuthenticodeSigned = FALSE;
    BOOL InfWasVerified = FALSE;
    BOOL CurMfgSecIsDecorated;
    TCHAR CurMfgSecWithExt[MAX_SECT_NAME_LEN];
    SYSTEMTIME SysTime; // we use this for logging
    TCHAR VersionText[50];  // we use this for logging
    HRESULT hr;

    //
    // caller must pass in valid data
    //
    MYASSERT(InfName);
    MYASSERT(Inf);
    MYASSERT(Context);

    //
    // Before we do anything else, check to see whether some other thread has told us
    // to abort.
    //
    if(*(Context->CancelSearch)) {
        SetLastError(ERROR_CANCELLED);
        return FALSE;
    }

    NewDriverNode = NULL;
    try {

        //
        // Skip this INF if it was from the Internet and we don't want Internet INFs
        //
        if ((Context->Flags & DRVSRCH_EXCLUDE_OLD_INET_DRIVERS) &&
            (Inf->InfSourceMediaType == SPOST_URL)) {
            goto clean0;
        }

        //
        // Only handle WIN4 INF's
        //
        if(Inf->Style & INF_STYLE_WIN4) {
            //
            // If we're building a compatible driver list, then we only care about this INF
            // if it contains the hardware/compatible IDs we're searching for.
            // Generally we wont get called unless we have any such ID's
            // sometimes we may, so an easy check to make up-front is to determine whether
            // any of the IDs exist in the loaded INF's string table.  If not, then we can
            // skip this file right now, and save a lot of time.
            //
            if((!Context->BuildClassDrvList) && (!pSetupDoesInfContainDevIds(Inf, Context))) {
                goto clean0;
            }

            //
            // Get the class GUID for this INF.
            //
            if(!ClassGuidFromInfVersionNode(&(Inf->VersionBlock), &InfClassGuid)) {
                goto clean0;
            }

            //
            // If we are building a class driver list, and there is an associated
            // class GUID, then check to see if this INF is of the same class.
            //
            if(Context->BuildClassDrvList && (Context->Flags & DRVSRCH_HASCLASSGUID)) {
                if(!IsEqualGUID(&(Context->ClassGuid), &InfClassGuid)) {
                    goto clean0;
                }
            }

            //
            // Don't allow a class that should be excluded (NoUseClass or NoDisplayClass) and the
            // DRVSRCH_ALLOWEXCLUDEDDRVS flag is not set.
            //
            if (Context->BuildClassDrvList && ShouldClassBeExcluded(&InfClassGuid, !(Context->Flags & DRVSRCH_ALLOWEXCLUDEDDRVS))) {
                goto clean0;
            }

            //
            // Retrieve the name of the provider for this INF file.
            //
            Provider = pSetupGetVersionDatum(&(Inf->VersionBlock), pszProvider);

            if(!(MfgListSection = InfLocateSection(Inf, pszManufacturer, NULL))) {
                //
                // No [Manufacturer] section--skip this INF.
                //
                WriteLogEntry(
                    LogContext,
                    DRIVER_LOG_VERBOSE,  // VERBOSE since otherwise it will always log GUID-0 inf's for full iteration
                    MSG_LOG_NO_MANUFACTURER_SECTION,
                    NULL,
                    InfName);

                goto clean0;
            }

            //
            // OK, we are likely going to add some driver nodes to our list in the code below.
            // Add this INF's class GUID to our GUID table.
            //
            InfClassGuidIndex = AddOrGetGuidTableIndex(Context->DeviceInfoSet, &InfClassGuid, TRUE);
            if(InfClassGuidIndex == -1) {
                goto clean0;
            }

            //
            // Find the [ControlFlags] section (if there is one), so that we can use it
            // later to determine whether particular devices should be excluded (via
            // 'ExcludeFromSelect').
            //
            OptionsTextOrCtlFlagsSection = InfLocateSection(Inf, pszControlFlags, NULL);

            Rank = 0;  // Initialize this value for case where we're building a class driver list.

            for(MfgListIndex = 0;
                InfLocateLine(Inf, MfgListSection, NULL, &MfgListIndex, &MfgListLine);
                MfgListIndex++) {

                //
                // Initially, assume the current manufacturer has no
                // per-os-version TargetDecoration entries
                //
                CurMfgSecIsDecorated = FALSE;

                if(!(CurMfgName = InfGetField(Inf, MfgListLine, 0, NULL))) {
                    continue;
                }

                if(!(CurMfgSecName = InfGetField(Inf, MfgListLine, 1, NULL))) {
                    //
                    // Lines with a single entry are considered to contain both
                    // a field 0 and a field 1 (i.e., both key and single
                    // value).  As such, this test should never fire.  If we
                    // have a line with no key and multiple values, we
                    // should've failed above when we tried to retrieve field
                    // zero.  Note that the code that builds the INF cache
                    // relies on this observation (i.e., it doesn't care about
                    // the manufacturer's name, so it always just retrieves
                    // field 1).
                    //
                    MYASSERT(CurMfgSecName);
                    continue;

                } else {
                    //
                    // Check to see if there is an applicable TargetDecoration
                    // entry for this manufacturer's models section (if so, the
                    // models section name will be appended with that
                    // decoration).
                    //
                    if(GetDecoratedModelsSection(LogContext,
                                                 Inf,
                                                 MfgListLine,
                                                 Context->AltPlatformInfo,
                                                 CurMfgSecWithExt)) {
                        //
                        // From here on, use the decorated models section...
                        //
                        CurMfgSecName = CurMfgSecWithExt;
                        CurMfgSecIsDecorated = TRUE;
                    }
                }

                if(!(CurMfgSection = InfLocateSection(Inf, CurMfgSecName, NULL))) {
                    continue;
                }

                //
                // We have the manufacturer's section--now process all entries in it.
                //
                for(CurMfgIndex = 0;
                    InfLocateLine(Inf, CurMfgSection, NULL, &CurMfgIndex, &CurMfgLine);
                    CurMfgIndex++) {

                    MatchIndex = -1;    // initialized for case when BuildClassDrvList is TRUE, to help with logging

                    if((Context->BuildClassDrvList  && !(Context->Flags & DRVSRCH_FILTERSIMILARDRIVERS)) ||
                       (Rank = pSetupTestDevCompat(Inf, CurMfgLine, Context, &MatchIndex)) != RANK_NO_MATCH) {
                        //
                        // Get the device description.
                        //
                        if(!(DevDesc = InfGetField(Inf, CurMfgLine, 0, NULL))) {
                            continue;
                        }

                        //
                        // Get the install section name.
                        //
                        if(!(InstallSecName = InfGetField(Inf, CurMfgLine, 1, NULL))) {
                            continue;
                        }

                        //
                        // Get the actual (i.e., potentially decorated) install
                        // section name.
                        //
                        if(!SetupDiGetActualSectionToInstallEx(
                                Inf,
                                InstallSecName,
                                Context->AltPlatformInfo,
                                InfSectionWithExt,
                                SIZECHARS(InfSectionWithExt),
                                NULL,
                                &InfSectionExtension,
                                NULL)) {
                            //
                            // Should never fail, but...
                            //
                            continue;
                        }

                        //
                        // Check to see if we only want the installed driver.
                        //
                        if ((Context->Flags & DRVSRCH_INSTALLEDDRIVER) &&
                            (!pSetupTestIsInstalledDriver(Inf, 
                                                          CurMfgLine,
                                                          DevDesc,
                                                          CurMfgName,
                                                          Provider,
                                                          InstallSecName,
                                                          InfSectionExtension,
                                                          Context))) {
                            //
                            // If we are looking only for the currently installed
                            // driver and this is not it, then skip this driver
                            // node.
                            //
                            continue;
                        }

                        //
                        // Check to see if this hardware is excluded by being
                        // in a ExcludeId field.
                        //
                        if (pSetupExcludeId(LogContext,
                                            Inf,
                                            InfName,
                                            InfSectionWithExt,
                                            Context)) {
                            //
                            // Don't create a driver node for this INF match
                            // because this hardware is excluded from this match.
                            //
                            continue;
                        }

                        //
                        // Check to see if the INF is digitally signed (if we
                        // haven't already)
                        //
                        if(!InfWasVerified) {
                            //
                            // We only want to check each INF once
                            //
                            InfWasVerified = TRUE;

                            if(PnfWasUsed && !Context->AltPlatformInfo) {
                                //
                                // Check the Inf Flags to see if this was
                                // digitally signed.
                                //
                                if(Inf->Flags & LIF_INF_DIGITALLY_SIGNED) {
                                    InfIsDigitallySigned = TRUE;
                                }

                                if (Inf->Flags & LIF_INF_AUTHENTICODE_SIGNED) {
                                    InfIsAuthenticodeSigned = TRUE;
                                }

                            } else {

                                DWORD SigErr;

                                //
                                // Either:
                                //
                                // (a) This INF is in a 3rd-party location
                                //     (hence it has no PNF), or
                                // (b) We've been supplied with alternate
                                //     platform information, thus we must
                                //     disregard the cached "INF is signed"
                                //     flag in the PNF
                                //
                                // In either case, we must now call
                                // WinVerifyTrust (potentially with the
                                // appropriate alternate platform parameters)
                                // to ascertain whether the INF should be
                                // considered signed.
                                //
                                // (Woe be unto those who wouldst call this for
                                // every INF in %windir%\Inf, for great would
                                // be the delay therein.)
                                //
                                SigErr = VerifyDeviceInfFile(
                                             LogContext,
                                             &(Context->VerifyContext),
                                             InfName,
                                             Inf,
                                             Context->AltPlatformInfo,
                                             NULL,
                                             NULL,
                                             NULL,
                                             0,
                                             NULL
                                             );

                                if(SigErr == NO_ERROR) {

                                    InfIsDigitallySigned = TRUE;

                                } else if(SigErr != ERROR_SIGNATURE_OSATTRIBUTE_MISMATCH) {
                                    //
                                    // INF failed to validate via driver
                                    // signing policy (and it's not a valid
                                    // driver signing catalog that simply
                                    // doesn't have a relevant osattribute).
                                    //
                                    // Now let's check to see if it validates
                                    // via Authenticode policy.  For the
                                    // purposes of ranking (and the
                                    // SelectDevice UI), we'll consider an
                                    // Authenticode-signed INF to be valid,
                                    // regardless of whether the publisher is
                                    // in the TrustedPublisher store.
                                    // 
                                    SigErr = VerifyDeviceInfFile(
                                                 LogContext,
                                                 &(Context->VerifyContext),
                                                 InfName,
                                                 Inf,
                                                 Context->AltPlatformInfo,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 VERIFY_INF_USE_AUTHENTICODE_CATALOG,
                                                 NULL
                                                 );

                                    if((SigErr == ERROR_AUTHENTICODE_TRUSTED_PUBLISHER) ||
                                       (SigErr == ERROR_AUTHENTICODE_TRUST_NOT_ESTABLISHED)) {

                                        InfIsDigitallySigned = TRUE;
                                        InfIsAuthenticodeSigned = TRUE;
                                    }
                                }
                            }
                        }

                        //
                        // If we're building a compatible driver list (hence
                        // ranking is important), then we need to adjust the
                        // rank values if the INF is (a) unsigned and (b)
                        // undecorated (hence calling into question whether or
                        // not the INF was even meant to be used on NT)...
                        //
                        if(!Context->BuildClassDrvList) {

                            if(!InfIsDigitallySigned) {
                                //
                                // INF isn't signed, thus the match is untrusted
                                //
                                Rank |= DRIVER_UNTRUSTED_RANK;

                                if(!CurMfgSecIsDecorated && !InfSectionExtension) {
                                    //
                                    // Not only is the INF unsigned, but there
                                    // are also no NT-specific decorations that
                                    // give us a hint that this INF was intended
                                    // for use on NT.  Thus, we have reason to
                                    // be suspicious that this INF is for
                                    // Windows 9x platforms only...
                                    //
                                    Rank |= DRIVER_W9X_SUSPECT_RANK;
                                }
                            }
                        }

                        //
                        // Form the driver description.  It is of the form,
                        // "<InstallSection>.DriverDesc", and appears in the
                        // [strings] section (if present).  (NOTE: We don't have
                        // to search for this section, since it's always the
                        // first section in the INF's SectionBlock list.
                        //
                        // If no driver description is present, use the device
                        // description.
                        //
                        hr = StringCchPrintf(TempStringBuffer,
                                             SIZECHARS(TempStringBuffer),
                                             pszDrvDescFormat,
                                             InstallSecName);
                        if(!MYVERIFY(SUCCEEDED(hr))) {
                            continue;
                        }

                        TempUint = 0;
                        if(!Inf->HasStrings ||
                           !InfLocateLine(Inf, Inf->SectionBlock, TempStringBuffer,
                                          &TempUint, &DrvDescLine) ||
                           !(DrvDesc = InfGetField(Inf, DrvDescLine, 1, NULL))) {

                            DrvDesc = DevDesc;
                        }

                        if(CreateDriverNode(Rank,
                                            DevDesc,
                                            DrvDesc,
                                            Provider,
                                            CurMfgName,
                                            &(Inf->VersionBlock.LastWriteTime),
                                            Inf->VersionBlock.Filename,
                                            InstallSecName,
                                            Context->StringTable,
                                            InfClassGuidIndex,
                                            &NewDriverNode) != NO_ERROR) {
                            continue;
                        }

                        //
                        // Get which hardware ID we matched with.
                        //
                        if(!(MatchedHwID = InfGetField(Inf, CurMfgLine, MatchIndex+3, NULL))) {
                            MatchedHwID = TEXT("");
                        }

                        //
                        // Log that a driver node was created.
                        //
                        WriteLogEntry(
                            LogContext,
                            Context->BuildClassDrvList ? DRIVER_LOG_INFO1 : DRIVER_LOG_INFO,
                            MSG_LOG_FOUND_1,
                            NULL,
                            MatchedHwID,                // hardware ID
                            InfName,                    // filename
                            DevDesc,                    // Device description
                            DrvDesc,                    // Driver description
                            Provider,                   // Provider name
                            CurMfgName,                 // Manufacturer name
                            InstallSecName              // Install section name
                            );

                        //
                        // If this is an untrusted compatible driver node, make
                        // an additional log entry about that
                        //
                        if(!Context->BuildClassDrvList
                            && (Rank & DRIVER_UNTRUSTED_RANK)) {

                            WriteLogEntry(LogContext,
                                          DRIVER_LOG_INFO,
                                          MSG_LOG_RANK_UNTRUSTED,
                                          NULL,
                                          Rank & ~DRIVER_W9X_SUSPECT_RANK,
                                          Rank
                                         );
                        }

                        if(pSetupGetDeviceIDs(NewDriverNode,
                                               Inf,
                                               CurMfgLine,
                                               Context->StringTable,
                                               OptionsTextOrCtlFlagsSection)) {
                            //
                            // If we're doing a non-native driver search, then
                            // we want to disregard any ExcludeFromSelect
                            // entries in the [ControlFlags] section, as they
                            // won't be relevant to our non-native driver node
                            // anyway.
                            //
                            if(Context->AltPlatformInfo) {
                                NewDriverNode->Flags &= ~DNF_EXCLUDEFROMLIST;
                            }

                        } else {
                            //
                            // We must've encountered an out-of-memory
                            // condition--time to bail!
                            //
                            DestroyDriverNodes(NewDriverNode, Context->DeviceInfoSet);
                            continue;
                        }

                        if(InfIsDigitallySigned) {
                            NewDriverNode->Flags |= DNF_INF_IS_SIGNED;
                        }

                        if (InfIsAuthenticodeSigned) {
                            NewDriverNode->Flags |= DNF_AUTHENTICODE_SIGNED;
                        }

                        //
                        // Look for the DriverVer date and version in the
                        // install section and if it is not there then look
                        // in the Version section
                        //
                        if (!pSetupGetDriverDate(Inf,
                                                 InfSectionWithExt,
                                                 &(NewDriverNode->DriverDate))) {

                            pSetupGetDriverDate(Inf,
                                                INFSTR_SECT_VERSION,
                                                &(NewDriverNode->DriverDate));
                        }

                        //
                        // Mark the driver node as coming from a user doing an
                        // F6 during textmode setup if that is where the INF is
                        // from.
                        //
                        if (Inf->Flags & LIF_OEM_F6_INF) {
                            NewDriverNode->Flags |= DNF_OEM_F6_INF;
                        }

                        //
                        // Get the DriverVersion from the INF.
                        //
                        if (!pSetupGetDriverVersion(Inf,
                                                    InfSectionWithExt,
                                                    &(NewDriverNode->DriverVersion))) {

                            pSetupGetDriverVersion(Inf,
                                                   INFSTR_SECT_VERSION,
                                                   &(NewDriverNode->DriverVersion));
                        }

                        if(!FileTimeToSystemTime(&NewDriverNode->DriverDate,&SysTime)) {
                            ZeroMemory(&SysTime, sizeof(SysTime));
                        }

                        pGetVersionText(VersionText, NewDriverNode->DriverVersion);

                        WriteLogEntry(
                            LogContext,
                            Context->BuildClassDrvList ? DRIVER_LOG_INFO1 : DRIVER_LOG_INFO,
                            MSG_LOG_FOUND_2,
                            NULL,
                            InfSectionWithExt,
                            Rank,
                            SysTime.wMonth,
                            SysTime.wDay,
                            SysTime.wYear,
                            VersionText);

                        if(!(Context->BuildClassDrvList)) {
                            //
                            // Store away the index of the matching device ID in this compatible
                            // driver node.
                            //
                            NewDriverNode->MatchingDeviceId = MatchIndex;
                        }

                        //
                        // If the INF from which this driver node was built has
                        // a corresponding PNF, then mark the driver node with
                        // the Win98-compatible DNF_INDEXED_DRIVER flag.
                        //
                        if(PnfWasUsed) {
                            NewDriverNode->Flags |= DNF_INDEXED_DRIVER;
                        }

                        //
                        // If the INF is from Windows Update (the Internet) then
                        // set the DNF_INET_DRIVER bit.
                        //
                        if (Context->Flags & DRVSRCH_FROM_INET) {

                            NewDriverNode->Flags |= DNF_INET_DRIVER;
                        }

                        //
                        // If we just downloade this driver from the Internet then we need to
                        // clean it up when we destroy the driver node
                        //
                        if (Context->Flags & DRVSRCH_CLEANUP_SOURCE_PATH) {

                            NewDriverNode->Flags |= PDNF_CLEANUP_SOURCE_PATH;
                        }

                        //
                        // If the InfSourceMediaType is SPOST_URL then the
                        // Inf that this driver came from came from the Internet
                        // but now lives in the INF directory.  You should never
                        // install a driver with the DNF_OLD_INET_DRIVER flag set
                        // because we no longer have access to the sources files.
                        //
                        if (Inf->InfSourceMediaType == SPOST_URL) {

                            NewDriverNode->Flags |= DNF_OLD_INET_DRIVER;
                        }

                        //
                        // Merge the new driver node into our existing list.
                        // NOTE: Do not dereference NewDriverNode after this call,
                        // since it may have been a duplicate, in which case it
                        // will be destroyed by this routine.
                        //
                        pSetupMergeDriverNode(Context, NewDriverNode, &InsertedAtHead);
                        NewDriverNode = NULL;

                        if(!Context->BuildClassDrvList && InsertedAtHead) {
                            //
                            // Update the device instance class to that of the new
                            // lowest-rank driver.
                            //
                            Context->ClassGuid = InfClassGuid;
                            Context->Flags |= DRVSRCH_HASCLASSGUID;
                            if(ClassName = pSetupGetVersionDatum(&(Inf->VersionBlock), pszClass)) {
                                MYVERIFY(SUCCEEDED(StringCchCopy(Context->ClassName,SIZECHARS(Context->ClassName) ,ClassName)));
                            } else {
                                *(Context->ClassName) = TEXT('\0');
                            }
                        }
                    }
                }
            }

        }
clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {

        if(NewDriverNode) {
            //
            // Make sure it didn't get partially linked into a list.
            //
            NewDriverNode->Next = NULL;
            DestroyDriverNodes(NewDriverNode, Context->DeviceInfoSet);
        }
    }

    return TRUE;
}


BOOL
pSetupFillInHardwareAndCompatIds(
    PDEVINFO_ELEM DevInfoElem,
    HMACHINE hMachine,
    PDRVSEARCH_CONTEXT DrvSearchContext,
    PSETUP_LOG_CONTEXT LogContext
    )
/*++

Routine Description:

    This routine fills in the PDRVSEARCH_CONTEXT->IdList with the string
    table Ids for all of the hardware and compatible Ids for the specified
    device.

Arguments:

    DevInfoElem - Supplies the address of a devinfo element.

    hMachine - Handle to the machine where the device resides that this
        API will get the hardware and compatbile Ids for.

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified INF line must be compatible.

    LogContext - Supplies information for logging purposes


Return Value:

    TRUE if no error is encountered, FALSE otherwise.

--*/
{
    DWORD Err, i;
    CONFIGRET cr;
    LONG NumIds[2];
    TCHAR TempBuffer[REGSTR_VAL_MAX_HCID_LEN];  // also holds other strings, but this value is largest
    LPTSTR TempBufferPos;                       // for character parsing
    ULONG TempBufferLen;

    Err = ERROR_SUCCESS;

    //
    // We're building a class driver list for similar drivers only--retrieve the list
    // of Hardware IDs (index 0) and Compatible IDs (index 1) from the device's
    // registry properties.
    //
    for(i = 0; i < 2; i++) {
        DWORD slot = AllocLogInfoSlot(LogContext,TRUE);

        TempBufferLen = sizeof(TempBuffer);
        cr = CM_Get_DevInst_Registry_Property_Ex(
                DevInfoElem->DevInst,
                (i ? CM_DRP_COMPATIBLEIDS : CM_DRP_HARDWAREID),
                NULL,
                TempBuffer,
                &TempBufferLen,
                0,
                hMachine);


        switch(cr) {

            case CR_BUFFER_SMALL :
                Err = ERROR_INVALID_DATA;
                goto clean0;

            case CR_INVALID_DEVINST :
                Err = ERROR_NO_SUCH_DEVINST;
                goto clean0;

            default :  ;  // Ignore any other return code.
        }

        //
        // If we retrieved a REG_MULTI_SZ buffer, add all the strings in it
        // to the device information set's string table.
        //
        if((cr == CR_SUCCESS) && (TempBufferLen > 2 * sizeof(TCHAR))) {

            if((NumIds[i] = AddMultiSzToStringTable(DrvSearchContext->StringTable,
                                                    TempBuffer,
                                                    DrvSearchContext->IdList[i],
                                                    MAX_HCID_COUNT,
                                                    FALSE,
                                                    NULL)) == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            //
            // Use a -1 end-of-list marker so that we don't have to store
            // the count in the context structure.
            //
            DrvSearchContext->IdList[i][ NumIds[i] ] = -1;

            //
            // Now that the data has been stored, it can be munged for
            // easy logging. In this, the NULLs between strings are
            // turned into commas.
            //
            for (TempBufferPos = TempBuffer; *TempBufferPos != 0; TempBufferPos = CharNext(TempBufferPos)) {
                //
                // we have a string, look for string terminator
                //
                while (*TempBufferPos != 0) {
                    TempBufferPos = CharNext(TempBufferPos);
                }
                //
                // peek to see if a non-Null character follows terminating NULL
                // can't use CharNext here, as it wont go past end of string
                // however terminating NULL always only takes up 1 TCHAR
                //
                if(*(TempBufferPos+1) != 0) {
                    //
                    // convert terminator into a comma unless last string
                    //
                    *TempBufferPos = TEXT(',');
                }
                //
                // onto next string
                //
            }

            WriteLogEntry(LogContext,
                slot,
                (i ? MSG_LOG_SEARCH_COMPATIBLE_IDS
                   : MSG_LOG_SEARCH_HARDWARE_IDS),
                NULL,
                TempBuffer);

        } else {
            NumIds[i] = 0;
            DrvSearchContext->IdList[i][0] = -1;
        }
    }

clean0:

    SetLastError(Err);
    return (Err == ERROR_SUCCESS);
}


LONG
pSetupGetInstalledDriverInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    PDRVSEARCH_CONTEXT  DrvSearchContext
    )
/*++

Routine Description:

    This routine determins the currently installed INF file for this device
    and adds it to the string table.  It will also retrieve the Description,
    MfgName, ProviderName of the currently installed driver and add those to
    the string table as well.  It will store these string table Ids in the
    appropriate entries in the DrvSearchContext parameter. It will return the
    StringTableId of the InfPath or -1 if there was an error or there wasn't
    an InfPat for this device.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure that
        this routine will get the Infpath for.

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified INF line must be compatible.

Return Value:

    This function returns the StringTableId of the InfPath that was added to the
    string table or -1 if there was an error.

--*/
{
    HKEY hKey;
    DWORD Err;
    DWORD RegDataType, RegDataLength;
    TCHAR TempBuffer[MAX_PATH];
    LONG InfPathId = -1;
    LONG StringTableId;

    //
    // Open the device's driver key and retrieve the INF from which the device was installed.
    //
    hKey = SetupDiOpenDevRegKey(DeviceInfoSet,
                                DeviceInfoData,
                                DICS_FLAG_GLOBAL,
                                0,
                                DIREG_DRV,
                                KEY_READ
                               );

    if(hKey == INVALID_HANDLE_VALUE) {
        return -1;
    }

    RegDataLength = sizeof(TempBuffer); // want in bytes, not chars
    Err = RegQueryValueEx(hKey,
                          REGSTR_VAL_INFPATH,
                          NULL,
                          &RegDataType,
                          (PBYTE)TempBuffer,
                          &RegDataLength
                         );

    if((Err == ERROR_SUCCESS) && (RegDataType != REG_SZ)) {
        goto clean0;
    }

    if(Err != ERROR_SUCCESS) {
        goto clean0;
    }

    //
    // We got the InfPath so add it to the string table
    //
    InfPathId = pStringTableAddString(DrvSearchContext->StringTable,
                                      TempBuffer,
                                      STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                      NULL,
                                      0
                                      );

    //
    // Now lets get the Provider from the driver key
    //
    RegDataLength = sizeof(TempBuffer);        // want in bytes, not chars
    Err = RegQueryValueEx(hKey,
                          REGSTR_VAL_PROVIDER_NAME,
                          NULL,
                          &RegDataType,
                          (PBYTE)TempBuffer,
                          &RegDataLength
                         );

    if ((Err == ERROR_SUCCESS) &&
        (RegDataType == REG_SZ)) {

        //
        // Add the provider to the string table.
        //
        DrvSearchContext->InstalledProviderName =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no provider specified.  If it turns out that the registry query
        // really failed for some other reason, then this will fail later on when we
        // compare this NULL provider to the real provider.
        //
        DrvSearchContext->InstalledProviderName = -1;
    }

    //
    // Now lets get the InfSection from the driver key
    //
    RegDataLength = sizeof(TempBuffer);        // want in bytes, not chars
    Err = RegQueryValueEx(hKey,
                          REGSTR_VAL_INFSECTION,
                          NULL,
                          &RegDataType,
                          (PBYTE)TempBuffer,
                          &RegDataLength
                         );

    if ((Err == ERROR_SUCCESS) &&
        (RegDataType == REG_SZ)) {

        //
        // Add the InfSection to the string table.
        //
        DrvSearchContext->InstalledInfSection =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no InfSection specified.  If it turns out that the registry query
        // really failed for some other reason, then this will fail later on when we
        // compare this NULL InfSection to the real InfSection.
        //
        DrvSearchContext->InstalledInfSection = -1;
    }

    //
    // Now lets get the InfSectionExt from the driver key
    //
    RegDataLength = sizeof(TempBuffer);        // want in bytes, not chars
    Err = RegQueryValueEx(hKey,
                          REGSTR_VAL_INFSECTIONEXT,
                          NULL,
                          &RegDataType,
                          (PBYTE)TempBuffer,
                          &RegDataLength
                         );

    if ((Err == ERROR_SUCCESS) &&
        (RegDataType == REG_SZ)) {

        //
        // Add the InfSection to the string table.
        //
        DrvSearchContext->InstalledInfSectionExt =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no InfSectionExt specified.  If it turns out that the registry query
        // really failed for some other reason, then this will fail later on when we
        // compare this NULL InfSectionExt to the real InfSectionExt.
        //
        DrvSearchContext->InstalledInfSectionExt = -1;
    }

    //
    // Next, retrieve the manufacturer (stored in the Mfg device property).
    //
    if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                        DeviceInfoData,
                                        SPDRP_MFG,
                                        NULL,      // datatype is guaranteed to always be REG_SZ.
                                        (PBYTE)TempBuffer,
                                        sizeof(TempBuffer),    // in bytes
                                        NULL)) {

        //
        // Add the manufacturer to the string table.
        //
        DrvSearchContext->InstalledMfgName =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no manufacturer specified.  If it turns out that the registry query
        // really failed for some other reason, then this will fail later on when we
        // compare this NULL manufacturer to the real manufacturer.
        //
        DrvSearchContext->InstalledMfgName = -1;
    }

    //
    // Finally, retrieve the device description (stored in the DeviceDesc device property).
    //
    if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                        DeviceInfoData,
                                        SPDRP_DEVICEDESC,
                                        NULL,      // datatype is guaranteed to always be REG_SZ.
                                        (PBYTE)TempBuffer,
                                        sizeof(TempBuffer),    // in bytes
                                        NULL)) {

        //
        // Add the device description to the string table.
        //
        DrvSearchContext->InstalledDescription =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no device description specified.  If it turns out that the
        // registry query really failed for some other reason, then this will fail later
        // on when we compare this NULL device description to the real device description.
        //
        DrvSearchContext->InstalledDescription = -1;
    }

    //
    // Now lets get the MatchingDeviceId from the driver key
    //
    RegDataLength = sizeof(TempBuffer);        // want in bytes, not chars
    Err = RegQueryValueEx(hKey,
                          pszMatchingDeviceId,
                          NULL,
                          &RegDataType,
                          (PBYTE)TempBuffer,
                          &RegDataLength
                         );

    if ((Err == ERROR_SUCCESS) &&
        (RegDataType == REG_SZ)) {

        //
        // Add the MatchingDeviceId to the string table.
        //
        DrvSearchContext->InstalledMatchingDeviceId =
            pStringTableAddString(DrvSearchContext->StringTable,
                                  TempBuffer,
                                  STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                  NULL,
                                  0
                                  );

    } else {
        //
        // Assume there is no MatchingDeviceId specified.  If it turns out that 
        // the registry query really failed for some other reason, then this 
        // will fail later on when we compare this NULL MatchingDeviceId to the  
        // real MatchingDeviceId.
        //
        DrvSearchContext->InstalledMatchingDeviceId = -1;
    }

clean0:

    RegCloseKey(hKey);

    return InfPathId;
}


BOOL
pSetupTestIsInstalledDriver(
    IN PLOADED_INF        Inf,
    IN PINF_LINE          InfLine,
    IN PCTSTR             Description,
    IN PCTSTR             MfgName,
    IN PCTSTR             ProviderName,
    IN PCTSTR             InfSection,
    IN PCTSTR             InfSectionExt,
    IN PDRVSEARCH_CONTEXT Context
    )
/*++

Routine Description:

    This routine tests a device entry in an INF to see if it matches
    the information of the currently installed driver for this device.

Arguments:

    Inf - Supplies a pointer to the INF containing the device entry
        to be checked to verify the MatchingDeviceId matches one
        of the device entry's hardware or compatible Ids.

    InfLine - Supplies a pointer to the line within the INF containing
        the device information to be checked to verify the MatchingDeviceId
        matches one of the device entry's hardware or compatible Ids.
        
    Description -
    
    MfgName -
    
    ProviderName -
    
    InfSection -
    
    InfSectionExt -        

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified driver node information must match.


Return Value:

    TRUE if this device entry matches all the information for the currently
    installed driver, FALSE otherwise.

--*/
{
    LONG StringId;
    BOOL bIsInstalledDriver = FALSE, bNoIds = TRUE;
    PTSTR String;
    UINT FieldIndex;
    PCTSTR DeviceIdString;

    //
    // First test the Description:
    // Make sure we have both Descriptions or that both are NULL.
    //
    if (((Context->InstalledDescription == -1) && Description) ||
        ((Context->InstalledDescription != -1) && !Description)) {
        goto clean0;
    }

    if (Context->InstalledDescription != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledDescription);

        if (!String || lstrcmpi(String, Description)) {
            //
            // Descriptions don't match
            //
            goto clean0;
        }
    }

    //
    // Next test the MfgName:
    // Make sure we have two MfgNames or that both are NULL.
    //
    if (((Context->InstalledMfgName == -1) && MfgName) ||
        ((Context->InstalledMfgName != -1) && !MfgName)) {
        goto clean0;
    }

    if (Context->InstalledMfgName != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledMfgName);

        if (!String || lstrcmpi(String, MfgName)) {
            //
            // MfgNames don't match
            //
            goto clean0;
        }
    }

    //
    // Next test the ProviderName:
    // Make sure we have two ProviderNames or that both are NULL.
    //
    if (((Context->InstalledProviderName == -1) && ProviderName) ||
        ((Context->InstalledProviderName != -1) && !ProviderName)) {
        goto clean0;
    }

    if (Context->InstalledProviderName != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledProviderName);

        if (!String || lstrcmpi(String, ProviderName)) {
            //
            // ProviderNames don't match
            //
            goto clean0;
        }
    }

    //
    // Next, test the InfSection:
    // Make sure we have two InfSections or that both are NULL.
    //
    if (((Context->InstalledInfSection == -1) && InfSection) ||
        ((Context->InstalledInfSection != -1) && !InfSection)) {
        goto clean0;
    }

    if (Context->InstalledInfSection != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledInfSection);

        if (!String || lstrcmpi(String, InfSection)) {
            //
            // InfSections don't match
            //
            goto clean0;
        }
    }

    //
    // Next, test the InfSectionExt:
    // Make sure we have two InfSections or that both are NULL.
    //
    if (((Context->InstalledInfSectionExt == -1) && InfSectionExt) ||
        ((Context->InstalledInfSectionExt != -1) && !InfSectionExt)) {
        goto clean0;
    }

    if (Context->InstalledInfSectionExt != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledInfSectionExt);

        if (!String || lstrcmpi(String, InfSectionExt)) {
            //
            // InfSectionExts don't match
            //
            goto clean0;
        }
    }

    //
    // Finally, test the MatchingDeviceId:
    // Make sure that one of the Hardware or Compatible Ids match the 
    // MatchingDeviceId, or that they all are NULL.
    // 
    if (Context->InstalledMatchingDeviceId != -1) {

        String = pStringTableStringFromId(Context->StringTable, Context->InstalledMatchingDeviceId);
    } else {

        String = NULL;
    }

    //
    // By default assume there are no ids in the list.
    //
    bNoIds = TRUE;

    for(FieldIndex = 2;
        DeviceIdString = InfGetField(Inf, InfLine, FieldIndex, NULL);
        FieldIndex++) {

        //
        // It's OK to hit an empty string for the hardware ID, but we need to
        // bail the first time we see an empty compat ID string.
        //
        if(!(*DeviceIdString) && (FieldIndex > 2)) {
            break;
        }

        if (*DeviceIdString) {
            //
            // Remeber that we found at least one Id in the list.
            //
            bNoIds = FALSE;

            if (String) {
                //
                // Compare the two Ids to see if they match.
                //
                if (!lstrcmpi(String, DeviceIdString)) {
                    //
                    // Everything matches so this must be the currently installed driver.
                    //
                    bIsInstalledDriver = TRUE;
                    break;
                }
            } else {
                //
                // If the MatchingDeviceId is NULL (or doesn't exist) and this device
                // entry is not NULL, then break out of the loop now because this 
                // is not a match.
                //
                break;
            }
        }
    }

    //
    // One last check is if there wasn't a MatchingDeviceId, and we didn't find
    // any Ids for the device entry, then this is also considered a match.
    //
    if (!String && bNoIds) {
        bIsInstalledDriver = TRUE;
    }


clean0:

    return bIsInstalledDriver;
}


UINT
pSetupTestDevCompat(
    IN  PLOADED_INF        Inf,
    IN  PINF_LINE          InfLine,
    IN  PDRVSEARCH_CONTEXT Context,
    OUT PLONG              MatchIndex
    )
/*++

Routine Description:

    This routine tests a device entry in an INF to see if it is
    compatible with the information supplied in the Context parameter.

Arguments:

    Inf - Supplies a pointer to the INF containing the device entry
        to be checked for compatibility.

    InfLine - Supplies a pointer to the line within the INF containing
        the device information to be checked for compatibility.

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified INF line must be compatible.

    MatchIndex - Supplies the address of a variable that receives the
        index of the driver node device ID that a match was found for
        (if this routine returns RANK_NO_MATCH, then this variable is
        not filled in).

        If a match was found for the INF's hardware ID, the index is -1,
        otherwise, it is the (zero-based) index into the compatible ID
        list that will be stored for this driver node.

Return Value:

    The return value is the rank of the match (0 is best, with rank
    increasing for each successive compatible ID and/or INF line string
    field searched).  If the specified entry is not a match, then the
    routine returns RANK_NO_MATCH.

--*/
{
    UINT Rank = RANK_NO_MATCH, CurrentRank, FieldIndex;
    UINT LastMatchFieldIndex = 0; // shut up preFast
    PCTSTR DeviceIdString;
    LONG DeviceIdVal;
    DWORD DeviceIdStringLength;
    TCHAR TempString[MAX_DEVICE_ID_LEN];

    for(FieldIndex = 2;
        DeviceIdString = InfGetField(Inf, InfLine, FieldIndex, NULL);
        FieldIndex++) {

        //
        // It's OK to hit an empty string for the hardware ID, but we need to
        // bail the first time we see an empty compat ID string.
        //
        if(!(*DeviceIdString) && (FieldIndex > 2)) {
            break;
        }

        if (Context->Flags & DRVSRCH_FILTERSIMILARDRIVERS) {

            if (pSetupIsSimilarDriver(DeviceIdString,
                                      FieldIndex,
                                      Context
                                      )) {

                return 0;
            }

        } else {

            //
            // First, retrieve the string ID corresponding to this device
            // ID in our string table.  If it's not in there, then there's
            // no need to waste any time on this ID.
            //
            if (FAILED(StringCchCopy(TempString, SIZECHARS(TempString), DeviceIdString))) {
                continue;
            }

            if((DeviceIdVal = pStringTableLookUpString(Context->StringTable,
                                                       TempString,
                                                       &DeviceIdStringLength,
                                                       NULL,
                                                       NULL,
                                                       STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                       NULL,0)) == -1) {
                continue;
            }

            //
            // The device ID is in our string table, so it _may_ be in
            // either our hardware id or compatible id list.
            //
            if(!pSetupCalculateRankMatch(DeviceIdVal,
                                         FieldIndex,
                                         Context->IdList,
                                         &CurrentRank)) {
                //
                // Then we had a match on a hardware ID--that's the best we're gonna get.
                //
                *MatchIndex = (LONG)FieldIndex - 3;
                return CurrentRank;

            } else if(CurrentRank < Rank) {
                //
                // This new rank is better than our current rank.
                //
                LastMatchFieldIndex = (LONG)FieldIndex - 3;
                Rank = CurrentRank;
            }
        }
    }

    if(Rank != RANK_NO_MATCH) {
        *MatchIndex = LastMatchFieldIndex;
    }

    return Rank;
}


BOOL
pSetupCalculateRankMatch(
    IN  LONG  DriverHwOrCompatId,
    IN  UINT  InfFieldIndex,
    IN  LONG  DevIdList[2][MAX_HCID_COUNT+1],
    OUT PUINT Rank
    )
/*++

Routine Description:

    This routine calculates the rank match ordinal for the specified driver
    hardware or compatible ID, if it matches one of the hardware or compatible
    IDs for a device.

Arguments:

    DriverHwOrCompatId - Supplies the string table ID for the ID we're trying to
        find a match for.

    InfFieldIndex - Supplies the index within the INF line where this ID was
        located (2 is hardware ID, 3 and greater is compatible ID).

    DevIdList - Supplies the address of a 2-dimensional array with 2 rows, each
        row containing a list of device IDs that the device has.  Each list is
        terminated by an entry containing -1.

        THIS MUST BE DIMENSIONED THE SAME AS THE 'IdList' FIELD OF THE DRVSEARCH_CONTEXT
        STRUCTURE!!!

    Rank - Supplies the address of a variable that receives the rank of the match,
        or RANK_NO_MATCH if there is no match.

Return Value:

    If there was a match on a hardware ID, then the return value is FALSE (i.e. no
    further searching is needed), otherwise it is TRUE.

--*/
{
    int i, j;

    MYASSERT(InfFieldIndex >= 2);

    for(i = 0; i < 2; i++) {

        for(j = 0; DevIdList[i][j] != -1; j++) {

            if(DevIdList[i][j] == DriverHwOrCompatId) {

                //
                // We have a match.
                //
                // The ranks are as follows:
                //
                // Device = HardwareID, INF = HardwareID        => 0x0000 - 0x0999
                // Device = HardwareID, INF = CompatID          => 0x1000 - 0x1999
                // Device = CompatID, INF = HardwareID          => 0x2000 - 0x2999
                // Device = CompatID, INF = CompatID            => 0x3000 - 0x????
                //
                if (i == 0) {

                    //
                    //We matched one of the device's HardwareIDs.
                    //
                    *Rank = ((InfFieldIndex == 2) ? RANK_HWID_INF_HWID_BASE : RANK_HWID_INF_CID_BASE) + j;

                } else {

                    //
                    //We matched one of the device's CompatibleIDs.
                    //
                    *Rank = ((InfFieldIndex == 2) ? RANK_CID_INF_HWID_BASE : RANK_CID_INF_CID_BASE + (RANK_CID_INF_CID_INC * (InfFieldIndex - 3))) + j;

                }


                return (BOOL)i;
            }
        }
    }

    //
    // No match was found.
    //
    *Rank = RANK_NO_MATCH;

    return TRUE;
}


BOOL
pSetupIsSimilarDriver(
    IN  PCTSTR              DriverHwOrCompatId,
    IN  UINT                InfFieldIndex,
    IN  PDRVSEARCH_CONTEXT  Context
    )
/*++

Routine Description:

    This routine calculates the rank match ordinal for the specified driver
    hardware or compatible ID, if it matches one of the hardware or compatible
    IDs for a device.

Arguments:

    DriverHwOrCompatId - Supplies the Hardware or Compatible ID we're trying to
        find a match for.

    InfFieldIndex - Supplies the index within the INF line where this ID was
        located (2 is hardware ID, 3 and greater is compatible ID).

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified INF line must be compatible.

Return Value:

    If there is a similar Hardware or Compatible Id match then return TRUE, otherwise
    return FALSE.

--*/
{
    int i, j;
    PTSTR String;

    MYASSERT(InfFieldIndex >= 2);

    for(i = 0; i < 2; i++) {

        for(j = 0; Context->IdList[i][j] != -1; j++) {

            String = pStringTableStringFromId(Context->StringTable, Context->IdList[i][j]);

            if (String &&
                _tcsnicmp(String, DriverHwOrCompatId, min(lstrlen(String), lstrlen(DriverHwOrCompatId))) == 0) {

                //
                // We have a match.
                //
                return TRUE;
            }
        }
    }

    //
    // No match was found.
    //
    return FALSE;
}

BOOL
pSetupExcludeId(
    IN PSETUP_LOG_CONTEXT   LogContext,
    IN PLOADED_INF          Inf,
    IN PCTSTR               InfName,
    IN PCTSTR               InfSection,
    IN PDRVSEARCH_CONTEXT   Context
    )
/*++

Routine Description:

    This routine looks in the decorated DDInstall section for ExcludeId values.
    If one of the ExcludeId values match one of the hardware or compatible Ids
    of this hardware then this API will return TRUE indicating that a driver
    node should not be created for this DDInstall section.

Arguments:

    LogContext - logging context

    Inf - Supplies the PLOADED_INF handle.

    InfName - name of the Inf file, used in logging.

    InfSection - Supplies the fully decorated DDInstall section.

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure
        containing information on the device instance with which
        the specified INF line must be compatible.

Return Value:

    If this inf section should be excluded based on the hardware/compatible Ids
    then return TRUE, otherwise return FALSE.

--*/
{
    BOOL bExcludeId = FALSE;
    INFCONTEXT ExcludeIdLineContext;
    DWORD FieldCount, FieldIndex;
    INT i, j;
    PCTSTR ExclDevId, DeviceId;

    //
    // If no hardware id or compatible ids then there is nothing to Exclude.
    //
    if ((Context->IdList[0][0] == -1) &&
        (Context->IdList[1][0] == -1)) {

        return FALSE;
    }


    if (SetupFindFirstLine(Inf,
                            InfSection,
                            SZ_KEY_EXCLUDEID,
                            &ExcludeIdLineContext
                            )) {

        do {

            FieldCount = SetupGetFieldCount(&ExcludeIdLineContext);
            for (FieldIndex = 1;
                 !bExcludeId && (FieldIndex <= FieldCount);
                 FieldIndex++) {

                ExclDevId = pSetupGetField(&ExcludeIdLineContext, FieldIndex);

                //
                // If the Id is NULL then don't bother going through the list
                // of IDs.
                //
                if (!ExclDevId) {
                    continue;
                }

                //
                // Enumerate through all of the hardware and compatible Ids for
                // this device and comapre them to the exclude id.
                //
                for(i = 0; !bExcludeId && (i < 2); i++) {

                    for(j = 0; Context->IdList[i][j] != -1; j++) {

                        DeviceId = pStringTableStringFromId(Context->StringTable,
                                                            Context->IdList[i][j]);

                        if(!lstrcmpi(ExclDevId, DeviceId)) {
                            //
                            // This Hardware/Compatible Id is an ExcludeId, so
                            // we will have the API return TRUE so we know
                            // to not create a driver node for this Id.
                            //
                            bExcludeId = TRUE;

                            WriteLogEntry(
                                LogContext,
                                DRIVER_LOG_WARNING,
                                MSG_LOG_INF_EXCLUDEID,
                                NULL,
                                InfName,
                                InfSection,
                                ExclDevId);

                            break;
                        }
                    }
                }
            }

        } while (!bExcludeId && SetupFindNextMatchLine(&ExcludeIdLineContext,
                                                       SZ_KEY_EXCLUDEID,
                                                       &ExcludeIdLineContext));
    }

    return bExcludeId;
}


BOOL
pSetupGetDeviceIDs(
    IN OUT PDRIVER_NODE DriverNode,
    IN     PLOADED_INF  Inf,
    IN     PINF_LINE    InfLine,
    IN OUT PVOID        StringTable,
    IN     PINF_SECTION CtlFlagsSection OPTIONAL
    )
/*++

Routine Description:

    This routine adds INF-defined hardware device ID and compatible
    device IDs to specified DRIVER_NODE.

Arguments:

    DriverNode - Supplies a pointer to the driver node to update.

    Inf - Supplies a pointer to the INF to retrieve the device IDs from.

    InfLine - Supplies a pointer to the INF line containing the device IDs.

    StringTable - Supplies the handle of a string table to be used for
        storing the device IDs.

    CtlFlagsSection - Optionally, supplies a pointer to the INF's [ControlFlags]
        section, that should be checked to determine whether this device is in
        an 'ExcludeFromSelect' list.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE (this will fail only if
    an out-of-memory condition is encountered).

--*/
{
    PCTSTR DeviceId;
    LONG i, NumCompatIds;
    TCHAR TempString[MAX_DEVICE_ID_LEN];
    PLONG TempIdList;
    HRESULT hr;

    //
    // If we already had a compatible ID list, free it now.
    //
    if(DriverNode->CompatIdList) {
        MyFree(DriverNode->CompatIdList);
        DriverNode->CompatIdList = NULL;
        DriverNode->NumCompatIds = 0;
    }

    //
    // Get the hardware ID.
    //
    if(!(DeviceId = InfGetField(Inf, InfLine, 2, NULL))) {

        DriverNode->HardwareId = -1;
        return TRUE;

    } else {

        hr = StringCchCopy(TempString,SIZECHARS(TempString),DeviceId);
        if(!MYVERIFY(SUCCEEDED(hr))) {
            SetLastError(ERROR_INVALID_DATA);
            return FALSE;
        }
        if((DriverNode->HardwareId = pStringTableAddString(StringTable,
                                                           TempString,
                                                           STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                           NULL,0)) == -1) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        } else {
            //
            // If this INF has a [ControlFlags] section, then check to see if this
            // hardware ID is marked for exclusion
            //
            if(CtlFlagsSection && pSetupShouldDevBeExcluded(DeviceId, Inf, CtlFlagsSection, NULL)) {
                DriverNode->Flags |= DNF_EXCLUDEFROMLIST;
            }
        }
    }

    //
    // Now get the compatible IDs.
    //
    MYASSERT(HASKEY(InfLine));
    NumCompatIds = InfLine->ValueCount - 4;
    if(NumCompatIds > 0) {

        if(!(DriverNode->CompatIdList = MyMalloc(NumCompatIds * sizeof(LONG)))) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        DriverNode->NumCompatIds = (DWORD)NumCompatIds;

        for(i = 0; i < NumCompatIds; i++) {

            if(!(DeviceId = InfGetField(Inf, InfLine, i + 3, NULL)) || !(*DeviceId)) {
                //
                // Just cut the list off here, and return.
                //
                DriverNode->NumCompatIds = i;
                if(i) {
                    //
                    // Resize the buffer (since we're sizing this down, it should never fail,
                    // but it's no big deal if it does).
                    //
                    if(TempIdList = MyRealloc(DriverNode->CompatIdList, i * sizeof(LONG))) {
                        DriverNode->CompatIdList = TempIdList;
                    }
                } else {
                    MyFree(DriverNode->CompatIdList);
                    DriverNode->CompatIdList = NULL;
                }
                return TRUE;

            } else {

                hr = StringCchCopy(TempString,SIZECHARS(TempString),DeviceId);
                if(!MYVERIFY(SUCCEEDED(hr))) {
                    MyFree(DriverNode->CompatIdList);
                    DriverNode->CompatIdList = NULL;
                    DriverNode->NumCompatIds = 0;
                    SetLastError(ERROR_INVALID_DATA);
                    return FALSE;
                }
                if((DriverNode->CompatIdList[i] = pStringTableAddString(
                                                        StringTable,
                                                        TempString,
                                                        STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                                        NULL,0)) == -1) {
                    MyFree(DriverNode->CompatIdList);
                    DriverNode->CompatIdList = NULL;
                    DriverNode->NumCompatIds = 0;
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}


BOOL
pSetupShouldDeviceBeExcluded(
    IN  PCTSTR DeviceId,
    IN  HINF   hInf,
    OUT PBOOL  ArchitectureSpecificExclude OPTIONAL
    )
/*++

Routine Description:

    This routine is a public wrapper to our private API, pSetupShouldDevBeExcluded.
    Refer to the documentation for that routine for a description of this API's
    behavior.

    WARNING!!  THIS ROUTINE DOES NOT HANDLE APPEND-LOADED INFS!!!

Arguments:

    DeviceId - Supplies the device ID to check for.  This string may
        be empty, in which case the device is excluded only if a wildcard
        ('*') is found.

    Inf - Supplies the handle of the INF to check in.

    ArchitectureSpecificExclude - Optionally, supplies the address of a variable
        that receives a boolean value indicating whether or not the exclusion was
        architecture-specific (e.g., ExcludeFromSelect.NT<Platform>).  If this
        routine returns FALSE, then the contents of this variable are undefined.

Return Value:

    Returns TRUE if the ID is in the list (i.e., it should be excluded),
    FALSE if it is not.

--*/
{
    BOOL IsExcluded;
    PINF_SECTION CtlFlagsSection;

    if(!LockInf((PLOADED_INF)hInf)) {
        return FALSE;
    }

    IsExcluded = FALSE;

    //
    // Now attempt to locate a [ControlFlags] section in this INF.
    //
    if(CtlFlagsSection = InfLocateSection((PLOADED_INF)hInf, pszControlFlags, NULL)) {
        //
        // This section is present--check to see if the specified device ID is marked
        // for exclusion.
        //
        IsExcluded = pSetupShouldDevBeExcluded(DeviceId,
                                               (PLOADED_INF)hInf,
                                               CtlFlagsSection,
                                               ArchitectureSpecificExclude
                                              );
    }

    UnlockInf((PLOADED_INF)hInf);

    return IsExcluded;
}


BOOL
pSetupShouldDevBeExcluded(
    IN  PCTSTR       DeviceId,
    IN  PLOADED_INF  Inf,
    IN  PINF_SECTION CtlFlagsSection,
    OUT PBOOL        ArchitectureSpecificExclude OPTIONAL
    )
/*++

Routine Description:

    This routine determines if a passed-in Device ID is in an
    'ExludeFromSelect' line in the specified INF's [ControlFlags] section.
    It also checks any lines of the form "ExcludeFromSelect.<OS>", where
    <OS> is either "Win" or "NT", depending on which OS we're running on
    (determined dynamically).  Finally, if we're running on NT, we append
    the platform type, and look for lines of the form
    "ExcludeFromSelect.NT<Platform>", where <Platform> is either "X86",
    "AMD64", or "IA64".

Arguments:

    DeviceId - Supplies the device ID to check for.  This string may
        be empty, in which case the device is excluded only if a wildcard
        ('*') is found.

    Inf - Supplies a pointer to the INF to check in.

    CtlFlagsSection - Supplies a pointer to the INF's [ControlFlags] section.

    ArchitectureSpecificExclude - Optionally, supplies the address of a variable
        that receives a boolean value indicating whether or not the exclusion was
        architecture-specific (e.g., ExcludeFromSelect.NT<Platform>).  If this
        routine returns FALSE, then the contents of this variable are undefined.

Return Value:

    Returns TRUE if the ID is in the list (i.e., it should be excluded),
    FALSE if it is not.

--*/
{
    PINF_LINE CtlFlagsLine;
    UINT CtlFlagsIndex, i, j, StringIdUb, PlatformSpecificIndex;
    PCTSTR ExclDevId;
    LONG StringIdList[3];
    LONG KeyStringId;
    DWORD StringLength;

    //
    // Retrieve the list of string IDs for the keys we should be looking for in the
    // [ControlFlags] section.
    //
    StringIdUb = 0;
    PlatformSpecificIndex = (UINT)-1; // initially, assume no "ExcludeFromSelect.NT<Platform>"

    for(i = 0; i < ExcludeFromSelectListUb; i++) {

        if((StringIdList[StringIdUb] = pStringTableLookUpString(
                                           Inf->StringTable,
                                           pszExcludeFromSelectList[i],
                                           &StringLength,
                                           NULL,
                                           NULL,
                                           STRTAB_CASE_INSENSITIVE | STRTAB_ALREADY_LOWERCASE,
                                           NULL,0)) != -1) {
            //
            // If the index is 2, then we've found architecture-specific exlude lines.
            // Record the resulting index of this element, so we can determine later
            // whether we were excluded because of what platform we're on.
            //
            if(i == 2) {
                PlatformSpecificIndex = StringIdUb;
            }
            StringIdUb++;
        }
    }

    if(StringIdUb) {
        //
        // There are some ExcludeFromSelect* lines--examine each line.
        //
        for(CtlFlagsIndex = 0;
            InfLocateLine(Inf, CtlFlagsSection, NULL, &CtlFlagsIndex, &CtlFlagsLine);
            CtlFlagsIndex++) {
            //
            // We can't use InfGetField() to retrieve the string ID of the line's key,
            // since it will give us the case-sensitive form, and we must use the
            // case-insensitive (i.e., lowercase) version for our fast matching scheme.
            //
            if((KeyStringId = pInfGetLineKeyId(Inf, CtlFlagsLine)) != -1) {
                //
                // Check the string ID of this line's key against the string IDs we're
                // interested in.
                //
                for(i = 0; i < StringIdUb; i++) {
                    if(KeyStringId == StringIdList[i]) {
                        break;
                    }
                }

                //
                // If we looked at all entries, and didn't find a match, then skip this
                // line and continue with the next one.
                //
                if(i >= StringIdUb) {
                    continue;
                }

                for(j = 1;
                    ExclDevId = InfGetField(Inf, CtlFlagsLine, j, NULL);
                    j++) {
                    //
                    // If we find a lone asterisk, treat it as a wildcard, and
                    // return TRUE.  Otherwise return TRUE only if the device IDs match.
                    //
                    if(((*ExclDevId == TEXT('*')) && (ExclDevId[1] == TEXT('\0'))) ||
                       !lstrcmpi(ExclDevId, DeviceId)) {
                        //
                        // This device ID is to be excluded.  If the caller requested it,
                        // store a boolean in their output variable indicating whether this
                        // was an architecture-specific exclusion.
                        //
                        if(ArchitectureSpecificExclude) {
                            *ArchitectureSpecificExclude = (i == PlatformSpecificIndex);
                        }
                        return TRUE;
                    }
                }
            }
        }
    }

    return FALSE;
}


VOID
pSetupMergeDriverNode(
    IN OUT PDRVSEARCH_CONTEXT Context,
    IN     PDRIVER_NODE       NewDriverNode,
    OUT    PBOOL              InsertedAtHead
    )
/*++

Routine Description:

    This routine merges a driver node into a driver node linked list.
    If the list is empty the passed in DRIVER_NODE will be inserted at the
    head of the list. If the list contains any DRIVER_NODEs, new node will
    be merged as follows:  The new node will be inserted in front of any
    nodes with a higher rank.  If the rank is the same, the new node will be
    grouped with other nodes having the same manufacturer.  The new node will
    be inserted at the end of the group.  If the node is an exact duplicate
    of an existing node, meaning that its rank, description, manufacturer,
    and provider are all the same, then the node will be deleted (unless the
    existing node is marked as excluded and the new node is not, in which case
    the existing node will be discarded instead).

Arguments:

    Context - Supplies a pointer to a DRVSEARCH_CONTEXT structure containing
        the list head, list tail, and list node count.

    NewDriverNode - Supplies a pointer to the driver node to be inserted.

    InsertedAtHead - Supplies a pointer to a variable that receives a flag
        indicating if the new driver was inserted at the head of the list.

Return Value:

    None.

--*/
{
    PDRIVER_NODE PrevDrvNode, CurDrvNode, DrvNodeToDelete;
    DWORD MatchFlags = 0;
    BOOL bDeleteNewDriverNode;
    PTSTR CurDrvNodeInfFile = NULL, NewDrvNodeInfFile = NULL;

    for(CurDrvNode = *(Context->pDriverListHead), PrevDrvNode = NULL;
        CurDrvNode;
        PrevDrvNode = CurDrvNode, CurDrvNode = CurDrvNode->Next) {

        if(NewDriverNode->MfgName != CurDrvNode->MfgName) {
            if(MatchFlags & 0x2) {
                break;
            }
        } else {
            MatchFlags |= 0x2;
            if(NewDriverNode->DevDescription != CurDrvNode->DevDescription) {
                if(MatchFlags & 0x4) {
                    break;
                }
            } else {
                MatchFlags |= 0x4;
                if(NewDriverNode->ProviderName != CurDrvNode->ProviderName) {
                    //
                    // We will only set the DNF_DUPDESC flags if both drivers do not
                    // have either the DNF_OLD_INET_DRIVER or the DNF_BAD_DRIVER
                    // flags set.
                    //
                    if (!(CurDrvNode->Flags & DNF_OLD_INET_DRIVER) &&
                        !(CurDrvNode->Flags & DNF_BAD_DRIVER) &&
                        !(NewDriverNode->Flags & DNF_OLD_INET_DRIVER) &&
                        !(NewDriverNode->Flags & DNF_BAD_DRIVER)) {

                        NewDriverNode->Flags |= DNF_DUPDESC;
                        CurDrvNode->Flags |= DNF_DUPDESC;
                    }

                    if (MatchFlags & 0x8) {
                        break;
                    }
                } else {
                    MatchFlags |=0x8;
                    if ((NewDriverNode->DriverDate.dwLowDateTime != CurDrvNode->DriverDate.dwLowDateTime) ||
                        (NewDriverNode->DriverDate.dwHighDateTime != CurDrvNode->DriverDate.dwHighDateTime) ||
                        (NewDriverNode->DriverVersion != CurDrvNode->DriverVersion)) {
                        //
                        // We will only set the DNF_DUPPROVIDER flags if both drivers do not
                        // have either the DNF_OLD_INET_DRIVER or the DNF_BAD_DRIVER
                        // flags set.
                        //
                        if (!(CurDrvNode->Flags & DNF_OLD_INET_DRIVER) &&
                            !(CurDrvNode->Flags & DNF_BAD_DRIVER) &&
                            !(NewDriverNode->Flags & DNF_OLD_INET_DRIVER) &&
                            !(NewDriverNode->Flags & DNF_BAD_DRIVER)) {

                            NewDriverNode->Flags |= DNF_DUPPROVIDER;
                            CurDrvNode->Flags |= DNF_DUPPROVIDER;
                        }

                        if (MatchFlags & 0x10) {
                            break;
                        }
                    } else {
                        MatchFlags |=0x10;
                        bDeleteNewDriverNode = TRUE;

                        if ((NewDriverNode->Rank != CurDrvNode->Rank) ||
                            (Context->Flags & DRVSRCH_NO_CLASSLIST_NODE_MERGE)) {
                            //
                            // The ranks are different, or the caller wants to
                            // include all INFs in the class list, so don't
                            // delete the new driver node.
                            //
                            bDeleteNewDriverNode = FALSE;

                        } else {
                            //
                            // In order to see if the INFs are identical first
                            // check if both INFs live in the same locations
                            // (meaning both live in the INF directory or both
                            // live in an Oem location). If so then we will just
                            // compare the filenames to see if the INFs are the
                            // same. If one INF lives in the INF directory and
                            // the other lives in an Oem location then do a
                            // binary compare on the INF files to see if they
                            // are identical.
                            //
                            BOOL bCurDrvNodeInOemDir, bNewDrvNodeInOemDir;

                            CurDrvNodeInfFile = pStringTableStringFromId(Context->StringTable,
                                                                         CurDrvNode->InfFileName
                                                                         );
                            bCurDrvNodeInOemDir = pSetupInfIsFromOemLocation(CurDrvNodeInfFile, TRUE);

                            NewDrvNodeInfFile = pStringTableStringFromId(Context->StringTable,
                                                                         NewDriverNode->InfFileName
                                                                         );
                            bNewDrvNodeInOemDir = pSetupInfIsFromOemLocation(NewDrvNodeInfFile, TRUE);


                            if ((bCurDrvNodeInOemDir && bNewDrvNodeInOemDir) ||
                                (!bCurDrvNodeInOemDir && !bNewDrvNodeInOemDir)) {
                                //
                                // Since both these INFs live in the same location
                                // the new INF will get deleted only the two
                                // INF paths are identical.
                                //
                                bDeleteNewDriverNode = (CurDrvNode->InfFileName ==
                                                        NewDriverNode->InfFileName);
                            } else {
                                //
                                // At least one of the INFs lives in the INF
                                // directory and the other lives in an Oem
                                // location so the new INF will get deleted only
                                //  if the two INFs are identical.
                                //
                                bDeleteNewDriverNode = pCompareFilesExact(CurDrvNodeInfFile,
                                                                          NewDrvNodeInfFile);
                            }
                        }

                        if (bDeleteNewDriverNode) {
                            //
                            // This is an exact match of description, rank,
                            // provider, DriverVer date, DriverVer version, and
                            // the Infs files.  Delete the node, unless
                            // the existing node is excluded, and this one is not,
                            // or the existing node is a bad driver and the new
                            // one is not.
                            //
                            if (((CurDrvNode->Flags & DNF_EXCLUDEFROMLIST) &&
                                  !(NewDriverNode->Flags & DNF_EXCLUDEFROMLIST)) ||
                                ((CurDrvNode->Flags & DNF_BAD_DRIVER) &&
                                  !(NewDriverNode->Flags & DNF_BAD_DRIVER))) {

                                //
                                // Remove the old driver node so we can replace it with
                                // the new one.  (Don't worry about updating the tail
                                // pointer--it will get fixed up later.)
                                //
                                // If this current node is from the Internet then do not
                                // delete it now because when we delete a driver node from
                                // the Internet we remove all of the files in the temp path
                                // and some other driver node might still need thos files.
                                //
                                if (!(CurDrvNode->Flags & DNF_INET_DRIVER)) {
                                    DrvNodeToDelete = CurDrvNode;
                                    CurDrvNode = CurDrvNode->Next;
                                    if(PrevDrvNode) {
                                        PrevDrvNode->Next = CurDrvNode;
                                    } else {
                                        *(Context->pDriverListHead) = CurDrvNode;
                                    }
                                    DrvNodeToDelete->Next = NULL;       // just want to delete this one.
                                    DestroyDriverNodes(DrvNodeToDelete, Context->DeviceInfoSet);
                                    (*(Context->pDriverCount))--;
                                }
                                break;

                            } else {

                                //
                                // Don't delete this new driver node, even though it is a dup,
                                // if if it is from the Internet
                                //
                                if (!(NewDriverNode->Flags & DNF_INET_DRIVER)) {
                                    NewDriverNode->Next = NULL;         // just want to delete this one.
                                    DestroyDriverNodes(NewDriverNode, Context->DeviceInfoSet);
                                    *InsertedAtHead = FALSE;
                                    return;
                                }
                            }
                        } else {
                            //
                            // We will only set the DNF_DUPDRIVERVER flag if the other driver
                            // node does not have either the DNF_OLD_INET_DRIVER or the
                            // DNF_BAD_DRIVER flag set.
                            //
                            if (!(CurDrvNode->Flags & DNF_OLD_INET_DRIVER) &&
                                !(CurDrvNode->Flags & DNF_BAD_DRIVER) &&
                                !(NewDriverNode->Flags & DNF_OLD_INET_DRIVER) &&
                                !(NewDriverNode->Flags & DNF_BAD_DRIVER)) {

                                NewDriverNode->Flags |= DNF_DUPDRIVERVER;
                                CurDrvNode->Flags |= DNF_DUPDRIVERVER;
                            }
                        }
                    }
                }
            }
        }
    }

    if(!(NewDriverNode->Next = CurDrvNode)) {
        *(Context->pDriverListTail) = NewDriverNode;
    }
    if(PrevDrvNode) {
        PrevDrvNode->Next = NewDriverNode;
        *InsertedAtHead = FALSE;
    } else {
        *(Context->pDriverListHead) = NewDriverNode;
        *InsertedAtHead = TRUE;
    }

    (*(Context->pDriverCount))++;
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiEnumDriverInfoA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN  DWORD              DriverType,
    IN  DWORD              MemberIndex,
    OUT PSP_DRVINFO_DATA_A DriverInfoData
    )
{
    BOOL b;
    DWORD rc;
    SP_DRVINFO_DATA_W driverInfoData;

    driverInfoData.cbSize = sizeof(SP_DRVINFO_DATA_W);

    b = SetupDiEnumDriverInfoW(
            DeviceInfoSet,
            DeviceInfoData,
            DriverType,
            MemberIndex,
            &driverInfoData
            );

    rc = GetLastError();

    if(b) {
        rc = pSetupDiDrvInfoDataUnicodeToAnsi(&driverInfoData,DriverInfoData);
        if(rc != NO_ERROR) {
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}


BOOL
WINAPI
SetupDiEnumDriverInfo(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN  DWORD            DriverType,
    IN  DWORD            MemberIndex,
    OUT PSP_DRVINFO_DATA DriverInfoData
    )
/*++

Routine Description:

    This routine enumerates the members of a driver information list.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        a driver info list to be enumerated.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure that contains a driver info list to be enumerated.  If this
        parameter is not specified, then the 'global' driver list owned by the
        device information set is used (this list will be of type
        SPDIT_CLASSDRIVER).

    DriverType - Specifies what type of driver list to enumerate.  Must be
        one of the following values:

        SPDIT_CLASSDRIVER  -- Enumerate a class driver list.
        SPDIT_COMPATDRIVER -- Enumerate a list of drivers for the specified
                              device.  DeviceInfoData must be specified if
                              this value is used.

    MemberIndex - Supplies the zero-based index of the driver information member
        to be retrieved.

    DriverInfoData - Supplies the address of a SP_DRVINFO_DATA structure that will
        receive information about the enumerated driver.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    To enumerate driver information members, an application should initialy call
    the SetupDiEnumDriverInfo function with the MemberIndex parameter set to zero.
    The application should then increment MemberIndex and call the SetupDiEnumDriverInfo
    function until there are no more values (i.e., the function fails, and GetLastError
    returns ERROR_NO_MORE_ITEMS).

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    UINT DriverCount, i;
    PDRIVER_NODE DriverNode;
    PDRIVER_NODE *DriverEnumHint;
    DWORD        *DriverEnumHintIndex;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to enumerate a driver list for a particular
            // device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        }

        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    //
                    // Enumerate class driver list for a particular device.
                    //
                    DriverCount = DevInfoElem->ClassDriverCount;
                    DriverNode = DevInfoElem->ClassDriverHead;

                    DriverEnumHint      = &(DevInfoElem->ClassDriverEnumHint);
                    DriverEnumHintIndex = &(DevInfoElem->ClassDriverEnumHintIndex);

                } else {
                    //
                    // Enumerate the global class driver list.
                    //
                    DriverCount = pDeviceInfoSet->ClassDriverCount;
                    DriverNode = pDeviceInfoSet->ClassDriverHead;

                    DriverEnumHint      = &(pDeviceInfoSet->ClassDriverEnumHint);
                    DriverEnumHintIndex = &(pDeviceInfoSet->ClassDriverEnumHintIndex);
                }
                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {

                    DriverCount = DevInfoElem->CompatDriverCount;
                    DriverNode = DevInfoElem->CompatDriverHead;

                    DriverEnumHint      = &(DevInfoElem->CompatDriverEnumHint);
                    DriverEnumHintIndex = &(DevInfoElem->CompatDriverEnumHintIndex);

                    break;
                }
                //
                // otherwise, let fall through for error condition.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        if(MemberIndex >= DriverCount) {
            Err = ERROR_NO_MORE_ITEMS;
            goto clean0;
        }

        //
        // Find the element corresponding to the specified index (using our
        // enumeration hint optimization, if possible)
        //
        if(*DriverEnumHintIndex <= MemberIndex) {
            MYASSERT(*DriverEnumHint);
            DriverNode = *DriverEnumHint;
            i = *DriverEnumHintIndex;
        } else {
            i = 0;
        }

        for(; i < MemberIndex; i++) {
            DriverNode = DriverNode->Next;
        }

        if(!DrvInfoDataFromDriverNode(pDeviceInfoSet,
                                      DriverNode,
                                      DriverType,
                                      DriverInfoData)) {

            Err = ERROR_INVALID_USER_BUFFER;
        }

        //
        // Remember this element as our new enumeration hint.
        //
        *DriverEnumHintIndex = MemberIndex;
        *DriverEnumHint = DriverNode;

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetSelectedDriverA(
    IN  HDEVINFO           DeviceInfoSet,
    IN  PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA_A DriverInfoData
    )
{
    DWORD rc;
    BOOL b;
    SP_DRVINFO_DATA_W driverInfoData;

    driverInfoData.cbSize = sizeof(SP_DRVINFO_DATA_W);
    b = SetupDiGetSelectedDriverW(DeviceInfoSet,DeviceInfoData,&driverInfoData);
    rc = GetLastError();

    if(b) {
        rc = pSetupDiDrvInfoDataUnicodeToAnsi(&driverInfoData,DriverInfoData);
        if(rc != NO_ERROR) {
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}

BOOL
WINAPI
SetupDiGetSelectedDriver(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    OUT PSP_DRVINFO_DATA DriverInfoData
    )
/*++

Routine Description:

    This routine retrieves the member of a driver list that has been selected
    as the controlling driver.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set to be queried.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for the device information element to retrieve the selected
        driver for.  If this parameter is NULL, then the selected class driver
        for the global class driver list will be retrieved.

    DriverInfoData - Supplies the address of a SP_DRVINFO_DATA structure that receives
        the currently selected driver.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.  If no driver has been selected yet, the
    error will be ERROR_NO_DRIVER_SELECTED.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, DriverType;
    PDEVINFO_ELEM DevInfoElem;
    PDRIVER_NODE DriverNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to retrieve the selected driver for a particular device.
            //
            if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                       DeviceInfoData,
                                                       NULL)) {

                DriverNode = DevInfoElem->SelectedDriver;
                DriverType = DevInfoElem->SelectedDriverType;

            } else {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

        } else {
            DriverNode = pDeviceInfoSet->SelectedClassDriver;
            DriverType = SPDIT_CLASSDRIVER;
        }

        if(DriverNode) {

            if(!DrvInfoDataFromDriverNode(pDeviceInfoSet,
                                          DriverNode,
                                          DriverType,
                                          DriverInfoData)) {

                Err = ERROR_INVALID_USER_BUFFER;
            }

        } else {
            Err = ERROR_NO_DRIVER_SELECTED;
        }

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiSetSelectedDriverA(
    IN     HDEVINFO           DeviceInfoSet,
    IN     PSP_DEVINFO_DATA   DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA_A DriverInfoData  OPTIONAL
    )
{
    SP_DRVINFO_DATA_W driverInfoData;
    DWORD rc;
    BOOL b;

    if(DriverInfoData) {
        rc = pSetupDiDrvInfoDataAnsiToUnicode(DriverInfoData,&driverInfoData);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return(FALSE);
        }
    }

    b = SetupDiSetSelectedDriverW(
            DeviceInfoSet,
            DeviceInfoData,
            DriverInfoData ? &driverInfoData : NULL
            );

    rc = GetLastError();

    if(b && DriverInfoData) {
        rc = pSetupDiDrvInfoDataUnicodeToAnsi(&driverInfoData,DriverInfoData);
        if(rc != NO_ERROR) {
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}

BOOL
WINAPI
SetupDiSetSelectedDriver(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN OUT PSP_DRVINFO_DATA DriverInfoData  OPTIONAL
    )
/*++

Routine Description:

    This routine sets the specified member of a driver list to be the currently
    selected driver.  It also allows the driver list to be reset, so that no
    driver is currently selected.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        driver is to be selected.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure for the device information element to select a driver for.
        If this parameter is NULL, then a class driver for the global class
        driver list will be selected.

        This is an IN OUT parameter because the class GUID for the device will be
        updated to reflect the class of the driver selected.

    DriverInfoData - If this parameter is specified, then it supplies the address
        of a driver information structure indicating the driver to be selected.
        If this parameter is NULL, then the driver list is to be reset (i.e., no
        driver selected).

        If the 'Reserved' field of this structure is 0, then this signifies that
        the caller is requesting a search for a driver node with the specified
        parameters (DriverType, Description, MfgName, and ProviderName).  If a
        match is found, then that driver node will be selected, otherwise, the API
        will fail, with GetLastError() returning ERROR_INVALID_PARAMETER.

        If the 'Reserved' field is 0, and a match is found, then the 'Reserved' field
        will be updated on output to reflect the actual driver node where the match
        was found.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDRIVER_NODE DriverListHead, DriverNode;
    PDRIVER_NODE *pSelectedDriver;
    PDWORD pSelectedDriverType;
    DWORD DriverType;
    TCHAR ClassGuidString[GUID_STRING_LEN];
    TCHAR OldClassGuidString[GUID_STRING_LEN];
    BOOL NoGuidUpdate = FALSE;
    DWORD PropType;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD slot_section = 0;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        Err = ERROR_INVALID_HANDLE;
        goto clean1;
    }
    LogContext = pDeviceInfoSet->InstallParamBlock.LogContext;

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then we are to select a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
            LogContext = DevInfoElem->InstallParamBlock.LogContext;
            pSelectedDriver = &(DevInfoElem->SelectedDriver);
            pSelectedDriverType = &(DevInfoElem->SelectedDriverType);
        } else {
            pSelectedDriver = &(pDeviceInfoSet->SelectedClassDriver);
            pSelectedDriverType = NULL;
        }

        if(!DriverInfoData) {
            //
            // Then the driver list selection is to be reset.
            //
            *pSelectedDriver = NULL;
            if(pSelectedDriverType) {
                *pSelectedDriverType = SPDIT_NODRIVER;
            }

        } else {
            //
            // Retrieve the driver type from the SP_DRVINFO_DATA structure
            // so we know which linked list to search.
            //
            if((DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) ||
               (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1))) {
                DriverType = DriverInfoData->DriverType;
            } else {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            switch(DriverType) {

                case SPDIT_CLASSDRIVER :

                    if(DeviceInfoData) {
                        DriverListHead = DevInfoElem->ClassDriverHead;
                    } else {
                        DriverListHead = pDeviceInfoSet->ClassDriverHead;
                    }
                    break;

                case SPDIT_COMPATDRIVER :

                    if(DeviceInfoData) {
                        DriverListHead = DevInfoElem->CompatDriverHead;
                        break;
                    }
                    //
                    // otherwise, let fall through for error condition.
                    //

                default :
                    Err = ERROR_INVALID_PARAMETER;
                    goto clean0;
            }

            //
            // Find the referenced driver node in the appropriate list.
            //
            if(DriverInfoData->Reserved) {

                if(!(DriverNode = FindAssociatedDriverNode(DriverListHead,
                                                           DriverInfoData,
                                                           NULL))) {
                    Err = ERROR_INVALID_PARAMETER;
                    goto clean0;
                }

            } else {
                //
                // The caller has requested that we search for a driver node
                // matching the criteria specified in this DriverInfoData.
                //
                if(!(DriverNode = SearchForDriverNode(pDeviceInfoSet->StringTable,
                                                      DriverListHead,
                                                      DriverInfoData,
                                                      NULL))) {
                    Err = ERROR_INVALID_PARAMETER;
                    goto clean0;
                }
            }

            //
            // If we're selecting a driver for a device information element, then update
            // that device's class to reflect the class of this new driver node.
            //
            if(DeviceInfoData) {
                if(slot_section == 0) {
                    //
                    // To aid in debugging, log inf/section for the newly selected node
                    //
                    PTSTR szInfFileName, szInfSectionName;

                    szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                             DriverNode->InfFileName
                                                            );

                    szInfSectionName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                                DriverNode->InfSectionName
                                                               );

                    slot_section = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_INFO,FALSE);
                    //
                    // Say what section is about to be installed.
                    //
                    WriteLogEntry(LogContext,
                        slot_section,
                        MSG_LOG_SETSELECTED_SECTION,
                        NULL,
                        szInfSectionName,
                        szInfFileName);
                }

                //
                // Get the INF class GUID for this driver node in string form, because
                // this property is stored as a REG_SZ.
                //
                pSetupStringFromGuid(&(pDeviceInfoSet->GuidTable[DriverNode->GuidIndex]),
                                     ClassGuidString,
                                     SIZECHARS(ClassGuidString)
                                    );

                if(SetupDiGetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_CLASSGUID,
                                                     &PropType,
                                                     (PBYTE)OldClassGuidString,
                                                     sizeof(OldClassGuidString),
                                                     NULL)) {
                    if(_tcscmp(ClassGuidString,OldClassGuidString)==0) {
                        NoGuidUpdate = TRUE;
                        WriteLogEntry(
                            LogContext,
                            DRIVER_LOG_INFO,
                            MSG_LOG_KEEPSELECTED_GUID,
                            NULL,
                            ClassGuidString);
                    }
                }
                if(!NoGuidUpdate) {
                    WriteLogEntry(
                        LogContext,
                        DRIVER_LOG_INFO,
                        MSG_LOG_SETSELECTED_GUID,
                        NULL,
                        ClassGuidString);
                }

                if(!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                     DeviceInfoData,
                                                     SPDRP_CLASSGUID,
                                                     (PBYTE)ClassGuidString,
                                                     sizeof(ClassGuidString))) {
                    Err = GetLastError();
                    goto clean0;
                }
            }

            *pSelectedDriver = DriverNode;
            if(pSelectedDriverType) {
                *pSelectedDriverType = DriverType;
            }

            if(!DriverInfoData->Reserved) {
                //
                // Update the caller-supplied DriverInfoData to reflect the driver node
                // where the match was found.
                //
                DriverInfoData->Reserved = (ULONG_PTR)DriverNode;
            }
        }

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

clean1:
    if (Err == NO_ERROR) {
        //
        // give a +ve affirmation of install
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_INFO,
            MSG_LOG_SETSELECTED,
            NULL);
    } else {
        //
        // indicate remove failed, display error
        //
        WriteLogEntry(
            LogContext,
            DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
            MSG_LOG_SETSELECTED_ERROR,
            NULL);
        WriteLogError(
            LogContext,
            DRIVER_LOG_ERROR,
            Err);
    }
    if (slot_section) {
        ReleaseLogInfoSlot(LogContext,slot_section);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDriverInfoDetailA(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA          DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA_A        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA_A DriverInfoDetailData,     OPTIONAL
    IN  DWORD                     DriverInfoDetailDataSize,
    OUT PDWORD                    RequiredSize              OPTIONAL
    )
{
    BOOL b;
    DWORD rc;
    DWORD UniRequiredSize;
    SP_DRVINFO_DATA_W driverInfoData;
    PSP_DRVINFO_DETAIL_DATA_W Details;
    PSTR AnsiMultiSz;
    DWORD AnsiRequiredSize;
    DWORD i;
    DWORD AnsiStringSize;
    DWORD CharCount;
    unsigned StringCount;
    UCHAR SectionName[2*LINE_LEN];
    UCHAR InfFileName[2*MAX_PATH];
    UCHAR DrvDescription[2*LINE_LEN];
    PUCHAR p;

    //
    // Check parameters.
    //
    rc = NO_ERROR;
    try {
        if(DriverInfoDetailData) {
            //
            // Check signature and make sure buffer is large enough
            // to hold fixed part and at least a valid empty multi_sz.
            //
            if((DriverInfoDetailData->cbSize != sizeof(SP_DRVINFO_DETAIL_DATA_A))
            || (DriverInfoDetailDataSize < (offsetof(SP_DRVINFO_DETAIL_DATA_A,HardwareID)+sizeof(CHAR)))) {

                rc = ERROR_INVALID_USER_BUFFER;
            }
        } else {
            //
            // Doesn't want data, size has to be 0.
            //
            if(DriverInfoDetailDataSize) {
                rc = ERROR_INVALID_USER_BUFFER;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_USER_BUFFER;
    }

    //
    // Convert the driver info data to unicode.
    //
    if(rc == NO_ERROR) {
        rc = pSetupDiDrvInfoDataAnsiToUnicode(DriverInfoData,&driverInfoData);
    }
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    //
    // The hardware id field in the DRVINFO_DETAIL_DATA is
    // variable length and has no maximum length.
    // We call SetupDiGetDriverInfoDetailW once to get the required
    // size and then again to actually get the data. Because
    // we're not calling CM APIs and thus not doing any really
    // slow RPC operations, etc, we hope this will be satisfactory.
    //
    b = SetupDiGetDriverInfoDetailW(
            DeviceInfoSet,
            DeviceInfoData,
            &driverInfoData,
            NULL,
            0,
            &UniRequiredSize
            );

    //
    // If it failed for a reason besides an insufficient buffer,
    // bail now. Last error remains set.
    //
    MYASSERT(!b);
    if(GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        return(FALSE);
    }

    //
    // Allocate a buffer to hold the details data and call the API
    // again.
    //
    Details = MyMalloc(UniRequiredSize);
    if(!Details) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    Details->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA_W);
    b = SetupDiGetDriverInfoDetail(
            DeviceInfoSet,
            DeviceInfoData,
            &driverInfoData,
            Details,
            UniRequiredSize,
            NULL
            );

    if(!b) {
        rc = GetLastError();
        MyFree(Details);
        SetLastError(rc);
        return(FALSE);
    }

    UniRequiredSize -= offsetof(SP_DRVINFO_DETAIL_DATA_W,HardwareID);
    UniRequiredSize/= sizeof(TCHAR);

    //
    // Now size up how big of an ANSI buffer is required
    // (this is for multi-sz)
    //

    AnsiStringSize = WideCharToMultiByte(CP_ACP,
                                   0,
                                   Details->HardwareID,
                                   UniRequiredSize,
                                   NULL,
                                   0,
                                   NULL,
                                   NULL);

    if(!AnsiStringSize) {
        rc = GetLastError();
        MyFree(Details);
        SetLastError(rc);
        return FALSE;
    }

    AnsiMultiSz = MyMalloc(AnsiStringSize);
    if(!AnsiMultiSz) {
        MyFree(Details);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    i = WideCharToMultiByte(CP_ACP,
                            0,
                            Details->HardwareID,
                            UniRequiredSize,
                            AnsiMultiSz,
                            AnsiStringSize,
                            NULL,
                            NULL);
    if(!MYVERIFY(i>0)) {
        rc = GetLastError();
        MyFree(Details);
        MyFree(AnsiMultiSz);
        SetLastError(rc);
        return FALSE;
    }
    if(!MYVERIFY(i<=AnsiStringSize)) {
        MyFree(Details);
        MyFree(AnsiMultiSz);
        SetLastError(ERROR_INVALID_DATA);
        return FALSE;
    }

    AnsiRequiredSize = offsetof(SP_DRVINFO_DETAIL_DATA_A,HardwareID) + AnsiStringSize;

    //
    // Now we finally know exactly how large we need the ansi structure to be
    // because we have the number of bytes in the ansi representation
    // of the multi_sz and we have the ansi representation itself
    //

    rc = NO_ERROR;
    try {
        if(RequiredSize) {
            *RequiredSize = AnsiRequiredSize;
        }

        if(DriverInfoDetailData) {
            //
            // We know the buffer is large enough to hold the fixed part
            // because we checked this at the start of the routine.
            //

            MYASSERT(offsetof(SP_DRVINFO_DETAIL_DATA_A,SectionName) == offsetof(SP_DRVINFO_DETAIL_DATA_W,SectionName));
            CopyMemory(DriverInfoDetailData,Details,offsetof(SP_DRVINFO_DETAIL_DATA_A,SectionName));

            DriverInfoDetailData->cbSize = sizeof(SP_DRVINFO_DETAIL_DATA_A);
            DriverInfoDetailData->HardwareID[0] = 0;

            //
            // Convert fixed strings and guard against overflow.
            //
            i = WideCharToMultiByte(
                    CP_ACP,0,
                    Details->SectionName,
                    -1,
                    SectionName,
                    sizeof(SectionName),
                    NULL,
                    NULL
                    );

            if(i) {
                i = WideCharToMultiByte(
                        CP_ACP,0,
                        Details->InfFileName,
                        -1,
                        InfFileName,
                        sizeof(InfFileName),
                        NULL,
                        NULL
                        );

                if(i) {
                    i = WideCharToMultiByte(
                            CP_ACP,0,
                            Details->DrvDescription,
                            -1,
                            DrvDescription,
                            sizeof(DrvDescription),
                            NULL,
                            NULL
                            );

                    if(!i) {
                        rc = GetLastError();
                    }
                } else {
                    rc = GetLastError();
                }
            } else {
                rc = GetLastError();
            }

            if(rc == NO_ERROR) {
                MYVERIFY(SUCCEEDED(StringCbCopyA(DriverInfoDetailData->SectionName,
                                                 sizeof(DriverInfoDetailData->SectionName),
                                                 SectionName)));
                MYVERIFY(SUCCEEDED(StringCbCopyA(DriverInfoDetailData->InfFileName,
                                                 sizeof(DriverInfoDetailData->InfFileName),
                                                 InfFileName)));
                MYVERIFY(SUCCEEDED(StringCbCopyA(DriverInfoDetailData->DrvDescription,
                                                 sizeof(DriverInfoDetailData->DrvDescription),
                                                 DrvDescription)));
                //
                // Finally, we need to transfer in as much of the ansi multi_sz
                // as will fit into the caller's buffer.
                //
                CharCount = DriverInfoDetailDataSize - offsetof(SP_DRVINFO_DETAIL_DATA_A,HardwareID);
                StringCount = 0;

                for(p=AnsiMultiSz; *p; p+=i) {

                    i = lstrlenA(p) + 1;

                    if(CharCount > i) {
                        MYVERIFY(SUCCEEDED(StringCbCopyA(DriverInfoDetailData->HardwareID+(p - AnsiMultiSz),
                                                         CharCount,
                                                         p)));
                        StringCount++;
                        CharCount -= i;
                    } else {
                        rc = ERROR_INSUFFICIENT_BUFFER;
                        break;
                    }
                }

                DriverInfoDetailData->HardwareID[p-AnsiMultiSz] = 0;

                //
                // Now fix up the compat ids fields in the caller's structure.
                // The first string is the hardware id and any additional ones
                // are compatible ids.
                //
                if(StringCount > 1) {
                    DriverInfoDetailData->CompatIDsOffset = lstrlenA(AnsiMultiSz)+1;
                    DriverInfoDetailData->CompatIDsLength = (DWORD)(p - AnsiMultiSz) + 1
                                                          - DriverInfoDetailData->CompatIDsOffset;
                } else {
                    DriverInfoDetailData->CompatIDsLength = 0;
                    DriverInfoDetailData->CompatIDsOffset = 0;
                }
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_USER_BUFFER;
    }

    MyFree(AnsiMultiSz);
    MyFree(Details);

    SetLastError(rc);
    return(rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiGetDriverInfoDetail(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,           OPTIONAL
    IN  PSP_DRVINFO_DATA        DriverInfoData,
    OUT PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData,     OPTIONAL
    IN  DWORD                   DriverInfoDetailDataSize,
    OUT PDWORD                  RequiredSize              OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves details about a particular driver.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        a driver information structure to retrieve details about.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure that contains a driver information structure to retrieve
        details about.  If this parameter is not specified, then the driver
        referenced will be a member of the 'global' class driver list owned
        by the device information set.

    DriverInfoData - Supplies the address of a SP_DRVINFO_DATA structure
        specifying the driver for whom details are to be retrieved.

    DriverInfoDetailData - Optionally, supplies the address of a
        SP_DRVINFO_DETAIL_DATA structure that will receive detailed information
        about the specified driver.  If this parameter is not specified, then
        DriverInfoDetailDataSize must be zero (this would be done if the caller
        was only interested in finding out how large of a buffer is required).
        If this parameter is specified, the cbSize field of this structure must
        be set to the size of the structure before calling this API. NOTE:
        The 'size of the structure' on input means sizeof(SP_DRVINFO_DETAIL_DATA).
        Note that this is essentially just a signature and is entirely separate
        from DriverInfoDetailDataSize. See below.

    DriverInfoDetailDataSize - Supplies the size, in bytes, of the
        DriverInfoDetailData buffer. To be valid this buffer must be at least
        sizeof(SP_DRVINFO_DETAIL_DATA)+sizeof(TCHAR) bytes, which allows
        storage of the fixed part of the structure and a single nul to
        terminate an empty multi_sz. (Depending on structure alignment,
        character width, and the data to be returned, this may actually be
        smaller than sizeof(SP_DRVINFO_DETAIL_DATA)).

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of bytes required to store the detailed driver information.
        This value includes both the size of the structure itself, and the
        additional number of bytes required for the variable-length character
        buffer at the end of it that holds the hardware ID and compatible IDs
        multi-sz list. (Depending on structure alignment, character width,
        and the data to be returned, this may actually be smaller than
        sizeof(SP_DRVINFO_DETAIL_DATA)).

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If the specified driver information member and the user-supplied buffer are
    both valid, then this function is guaranteed to fill in all static fields in
    the SP_DRVINFO_DETAIL_DATA structure, and as many IDs as possible in the
    variable-length buffer at the end (while still maintaining a multi-sz format).
    The function will return failure (FALSE) in this case, with GetLastError
    returning ERROR_INSUFFICIENT_BUFFER, and RequiredSize (if specified) will
    contain the total number of bytes required for the structure with _all_ IDs.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    DWORD DriverType;
    PDRIVER_NODE DriverListHead, DriverNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then this is a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        }

        //
        // Retrieve the driver type from the SP_DRVINFO_DATA structure
        // so we know which linked list to search.
        //
        if((DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) ||
           (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1))) {
            DriverType = DriverInfoData->DriverType;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // NOTE: If we ever decide to do indexed searching like setupx, we
        // will need to be careful here, because we may not always have detailed
        // information around like we do today.  The assertions below indicate our
        // current assumption.
        //
        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    MYASSERT(DevInfoElem->InstallParamBlock.Flags & DI_DIDCLASS);
                    DriverListHead = DevInfoElem->ClassDriverHead;
                } else {
                    MYASSERT(pDeviceInfoSet->InstallParamBlock.Flags & DI_DIDCLASS);
                    DriverListHead = pDeviceInfoSet->ClassDriverHead;
                }
                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {
                    MYASSERT(DevInfoElem->InstallParamBlock.Flags & DI_DIDCOMPAT);
                    DriverListHead = DevInfoElem->CompatDriverHead;
                    break;
                }
                //
                // otherwise, let fall through for error condition.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        //
        // Find the referenced driver node in the appropriate list.
        //
        if(!(DriverNode = FindAssociatedDriverNode(DriverListHead,
                                                   DriverInfoData,
                                                   NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        Err = DrvInfoDetailsFromDriverNode(pDeviceInfoSet,
                                           DriverNode,
                                           DriverInfoDetailData,
                                           DriverInfoDetailDataSize,
                                           RequiredSize
                                          );

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiDestroyDriverInfoList(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            DriverType
    )
/*++

Routine Description:

    This routine destroys a driver information list.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        the driver information list to be destroyed.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure that contains the driver information list to be destroyed.
        If this parameter is not specified, then the global class driver list
        will be destroyed.

    DriverType - Specifies what type of driver list to destroy.  Must be one of
        the following values:

        SPDIT_CLASSDRIVER  - Destroy a class driver list.
        SPDIT_COMPATDRIVER - Destroy a compatible driver list.  DeviceInfoData
                             must be specified if this value is used.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If the currently selected driver is a member of the list being destroyed,
    then the selection will be reset.

    If a class driver list is being destroyed, then the DI_FLAGSEX_DIDINFOLIST
    and DI_DIDCLASS flags will be reset for the corresponding device information
    set or device information element.  The DI_MULTMFGS flag will also be reset.

    If a compatible driver list is being destroyed, then the DI_FLAGSEX_DIDCOMPATINFO
    and DI_DIDCOMPAT flags will be reset for the corresponding device information
    element.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDRIVER_NODE DriverNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then this is a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            //
            // If the selected driver is in the list we're deleting, then
            // reset the selection.
            //
            if(DevInfoElem->SelectedDriverType == DriverType) {
                DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
                DevInfoElem->SelectedDriver = NULL;
            }

        } else {
            pDeviceInfoSet->SelectedClassDriver = NULL;
        }

        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    //
                    // Destroy class driver list for a particular device.
                    //
                    DriverNode = DevInfoElem->ClassDriverHead;
                    DevInfoElem->ClassDriverCount = 0;
                    DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                    DevInfoElem->ClassDriverEnumHint = NULL;
                    DevInfoElem->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;
                    DevInfoElem->InstallParamBlock.Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                    DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;

                } else {
                    //
                    // Destroy the global class driver list.
                    //
                    DriverNode = pDeviceInfoSet->ClassDriverHead;
                    pDeviceInfoSet->ClassDriverCount = 0;
                    pDeviceInfoSet->ClassDriverHead = pDeviceInfoSet->ClassDriverTail = NULL;
                    pDeviceInfoSet->ClassDriverEnumHint = NULL;
                    pDeviceInfoSet->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;
                    pDeviceInfoSet->InstallParamBlock.Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                    pDeviceInfoSet->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;
                }

                //
                // Dereference the class driver list.
                //
                DereferenceClassDriverList(pDeviceInfoSet, DriverNode);

                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {
                    DestroyDriverNodes(DevInfoElem->CompatDriverHead, pDeviceInfoSet);
                    DevInfoElem->CompatDriverCount = 0;
                    DevInfoElem->CompatDriverHead = DevInfoElem->CompatDriverTail = NULL;
                    DevInfoElem->CompatDriverEnumHint = NULL;
                    DevInfoElem->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;
                    DevInfoElem->InstallParamBlock.Flags   &= ~DI_DIDCOMPAT;
                    DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDCOMPATINFO;
                    break;
                }
                //
                // otherwise, let fall through for error condition.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDriverInstallParamsA(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_A    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
{
    DWORD rc;
    SP_DRVINFO_DATA_W driverInfoData;

    rc = pSetupDiDrvInfoDataAnsiToUnicode(DriverInfoData,&driverInfoData);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    return SetupDiGetDriverInstallParamsW(
                DeviceInfoSet,
                DeviceInfoData,
                &driverInfoData,
                DriverInstallParams
                );
}

BOOL
WINAPI
SetupDiGetDriverInstallParams(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA      DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
/*++

Routine Description:

    This routine retrieves installation parameters for the specified driver.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        a driver information structure to retrieve installation parameters for.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure that contains a driver information structure to retrieve
        installation parameters for.  If this parameter is not specified, then
        the driver referenced will be a member of the 'global' class driver list
        owned by the device information set.

    DriverInfoData - Supplies the address of a SP_DRVINFO_DATA structure
        specifying the driver for whom installation parameters are to be
        retrieved.

    DriverInstallParams - Supplies the address of a SP_DRVINSTALL_PARAMS structure
        that will receive the installation parameters for this driver.  The cbSize
        field of this structure must be set to the size, in bytes, of the
        structure before calling this API.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    DWORD DriverType;
    PDRIVER_NODE DriverListHead, DriverNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then this is a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        }

        //
        // Retrieve the driver type from the SP_DRVINFO_DATA structure
        // so we know which linked list to search.
        //
        if((DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) ||
           (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1))) {
            DriverType = DriverInfoData->DriverType;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    DriverListHead = DevInfoElem->ClassDriverHead;
                } else {
                    DriverListHead = pDeviceInfoSet->ClassDriverHead;
                }
                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {
                    DriverListHead = DevInfoElem->CompatDriverHead;
                    break;
                }
                //
                // otherwise, let fall through for error condition.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        //
        // Find the referenced driver node in the appropriate list.
        //
        if(!(DriverNode = FindAssociatedDriverNode(DriverListHead,
                                                   DriverInfoData,
                                                   NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // We have the driver node, now fill in the caller's buffer with
        // its installation parameters.
        //
        Err = GetDrvInstallParams(DriverNode,
                                  DriverInstallParams
                                 );

        if(Err == NO_ERROR) {
            //
            // Fill in the Win98-compatible DNF flags indicating whether this
            // driver node is from a compatible or class driver list.
            //
            DriverInstallParams->Flags |= (DriverType == SPDIT_CLASSDRIVER)
                                              ? DNF_CLASS_DRIVER
                                              : DNF_COMPATIBLE_DRIVER;

            //
            // Hide the private PDNF_xxx flags
            //
            DriverInstallParams->Flags &= ~PDNF_MASK;
        }

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiSetDriverInstallParamsA(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN  PSP_DRVINFO_DATA_A    DriverInfoData,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
{
    SP_DRVINFO_DATA_W driverInfoData;
    DWORD rc;

    rc = pSetupDiDrvInfoDataAnsiToUnicode(DriverInfoData,&driverInfoData);
    if(rc != NO_ERROR) {
        SetLastError(rc);
        return(FALSE);
    }

    return SetupDiSetDriverInstallParamsW(
                DeviceInfoSet,
                DeviceInfoData,
                &driverInfoData,
                DriverInstallParams
                );
}

BOOL
WINAPI
SetupDiSetDriverInstallParams(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DRVINFO_DATA      DriverInfoData,
    IN PSP_DRVINSTALL_PARAMS DriverInstallParams
    )
/*++

Routine Description:

    This routine sets installation parameters for the specified driver.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        a driver information structure to set installation parameters for.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure that contains a driver information structure to set
        installation parameters for.  If this parameter is not specified, then
        the driver referenced will be a member of the 'global' class driver list
        owned by the device information set.

    DriverInfoData - Supplies the address of a SP_DRVINFO_DATA structure
        specifying the driver for whom installation parameters are to be
        set.

    DriverInstallParams - Supplies the address of a SP_DRVINSTALL_PARAMS structure
        specifying what the new driver install parameters should be.  The cbSize
        field of this structure must be set to the size, in bytes, of the
        structure before calling this API.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    DWORD DriverType;
    PDRIVER_NODE DriverListHead, DriverNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoData) {
            //
            // Then this is a driver for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }
        }

        //
        // Retrieve the driver type from the SP_DRVINFO_DATA structure
        // so we know which linked list to search.
        //
        if((DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA)) ||
           (DriverInfoData->cbSize == sizeof(SP_DRVINFO_DATA_V1))) {
            DriverType = DriverInfoData->DriverType;
        } else {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        switch(DriverType) {

            case SPDIT_CLASSDRIVER :

                if(DeviceInfoData) {
                    DriverListHead = DevInfoElem->ClassDriverHead;
                } else {
                    DriverListHead = pDeviceInfoSet->ClassDriverHead;
                }
                break;

            case SPDIT_COMPATDRIVER :

                if(DeviceInfoData) {
                    DriverListHead = DevInfoElem->CompatDriverHead;
                    break;
                }
                //
                // otherwise, let fall through for error condition.
                //

            default :
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
        }

        //
        // Find the referenced driver node in the appropriate list.
        //
        if(!(DriverNode = FindAssociatedDriverNode(DriverListHead,
                                                   DriverInfoData,
                                                   NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // We have the driver node, now set its installation parameters
        // based on the caller-supplied buffer.
        //
        Err = SetDrvInstallParams(DriverInstallParams,
                                  DriverNode
                                 );

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
pSetupDoesInfContainDevIds(
    IN PLOADED_INF        Inf,
    IN PDRVSEARCH_CONTEXT Context
    )
/*++

Routine Description:

    This routine determines whether any of the hardware or compatible IDs contained
    in the context structure are in the specified INF.

Arguments:

    Inf - Supplies the address of the loaded INF structure to be searched.

    Context - Supplies the address of the context structure containing hardware ID
        and compatible ID lists.

Return Value:

    If the INF contains any of the IDs listed in the context structure, the return
    value is TRUE, otherwise, it is FALSE.

Remarks:

    This routine accesses the string table within the loaded INF structure, but
    _does not_ obtain the INF lock.  This routine should only be called if the INF
    lock has been obtained, or if there is no possibility of contention (e.g., from
    withing the driver search callback routine).

--*/
{
    PTSTR CurDevId;
    DWORD StringLength;
    LONG i;
    PLONG pDevIdNum;

    for(i = 0; i < 2; i++) {

        for(pDevIdNum = Context->IdList[i]; *pDevIdNum != -1; pDevIdNum++) {
            //
            // First, obtain the device ID string corresponding to our stored-away
            // string table ID.
            //
            CurDevId = pStringTableStringFromId(Context->StringTable, *pDevIdNum);

            //
            // Now, try to lookup this string in the INF's string table.  Since we
            // added the device IDs to our Context string table case-insensitively,
            // then we know that they're already lowercase, so we speed up the lookup
            // even further by passing the STRTAB_ALREADY_LOWERCASE flag.
            //
            MYASSERT(!(Inf->Next)); // We'd better only have one of these at this point.

            if(pStringTableLookUpString(Inf->StringTable,
                                        CurDevId,
                                        &StringLength,
                                        NULL,
                                        NULL,
                                        STRTAB_CASE_INSENSITIVE | STRTAB_ALREADY_LOWERCASE,
                                        NULL,0) != -1) {
                //
                // We found a match--return success.
                //
                return TRUE;
            }
        }
    }

    //
    // No matches found.
    //
    return FALSE;
}


DWORD
BuildCompatListFromClassList(
    IN     PDRIVER_NODE       ClassDriverList,
    IN OUT PDRVSEARCH_CONTEXT Context
    )
/*++

Routine Description:

    This routine builds a compatible driver list for the specified device
    information element based on an existing class driver list for that element.

Arguments:

    ClassDriverList - Pointer to the head of a linked list of class driver nodes.

    Context - Supplies the address of a context structure used in building the
        compatible driver list.

Return Value:

    If successful, the return code is NO_ERROR, otherwise, it is a Win32 error code.

--*/
{
    PDRIVER_NODE CompatDriverNode = NULL;
    DWORD Err = NO_ERROR;
    BOOL InsertedAtHead;
    UINT Rank, CurrentRank, i;

    try {
        //
        // Examine each node in the class driver list, and copy any compatible drivers
        // into the compatible driver list.
        //
        for(; ClassDriverList; ClassDriverList = ClassDriverList->Next) {

            if(ClassDriverList->HardwareId == -1) {
                //
                // If there's no HardwareId, then we know there are no compatible IDs,
                // we can skip this driver node
                //
                continue;
            }

            if(pSetupCalculateRankMatch(ClassDriverList->HardwareId,
                                        2,
                                        Context->IdList,
                                        &Rank)) {
                //
                // Then we didn't hit a hardware ID match, so check the compatible IDs.
                //
                for(i = 0; i < ClassDriverList->NumCompatIds; i++) {

                    if(!pSetupCalculateRankMatch(ClassDriverList->CompatIdList[i],
                                                 i + 3,
                                                 Context->IdList,
                                                 &CurrentRank)) {
                        //
                        // Then we had a match on a hardware ID--that's the best we're gonna get.
                        //
                        Rank = CurrentRank;
                        break;

                    } else if(CurrentRank < Rank) {
                        //
                        // This new rank is better than our current rank.
                        //
                        Rank = CurrentRank;
                    }
                }
            }

            if(Rank != RANK_NO_MATCH) {
                //
                // Make a copy of the class driver node for our new compatible driver node.
                //
                if(CompatDriverNode = DuplicateDriverNode(ClassDriverList)) {
                    //
                    // Update the rank of our new driver node to what we just calculated.
                    //
                    CompatDriverNode->Rank = Rank;

                    //
                    // Mask out the duplicate description flag--this will be re-computed below.
                    //
                    CompatDriverNode->Flags &= ~DNF_DUPDESC;

                } else {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }

                //
                // Merge the new driver node into our existing list.
                // NOTE: Do not dereference CompatDriverNode after this call,
                // since it may have been a duplicate, in which case it
                // will be destroyed by this routine.
                //
                pSetupMergeDriverNode(Context, CompatDriverNode, &InsertedAtHead);
                CompatDriverNode = NULL;

                if(InsertedAtHead) {
                    //
                    // Update the device instance class to that of the new lowest-rank driver.
                    //
                    CopyMemory(&(Context->ClassGuid),
                               &(Context->DeviceInfoSet->GuidTable[ClassDriverList->GuidIndex]),
                               sizeof(GUID)
                              );
                    Context->Flags |= DRVSRCH_HASCLASSGUID;
                    *(Context->ClassName) = TEXT('\0');
                }
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        Err = ERROR_INVALID_PARAMETER;

        if(CompatDriverNode) {
            //
            // Make sure it didn't get partially linked into a list.
            //
            CompatDriverNode->Next = NULL;
            DestroyDriverNodes(CompatDriverNode, Context->DeviceInfoSet);
        }
    }

    if(Err != NO_ERROR) {
        DestroyDriverNodes(*(Context->pDriverListHead), Context->DeviceInfoSet);
        *(Context->pDriverListHead) = *(Context->pDriverListTail) = NULL;
        *(Context->pDriverCount) = 0;
    }

    return Err;
}


PDRIVER_NODE
DuplicateDriverNode(
    IN PDRIVER_NODE DriverNode
    )
/*++

Routine Description:

    This routine makes a copy of the specified driver node.

Arguments:

    DriverNode - Supplies the address of the driver node to be copied.

Return Value:

    If successful, the return value is the address of the newly-allocated copy.
    If failure (due to out-of-memory), the return value is NULL.

--*/
{
    PDRIVER_NODE NewDriverNode;
    BOOL FreeCompatIdList;

    if(!(NewDriverNode = MyMalloc(sizeof(DRIVER_NODE)))) {
        return NULL;
    }

    FreeCompatIdList = FALSE;

    try {

        CopyMemory(NewDriverNode, DriverNode, sizeof(DRIVER_NODE));

        NewDriverNode->Next = NULL;

        if(DriverNode->NumCompatIds) {
            //
            // Then allocate an array to contain them.
            //
            if(NewDriverNode->CompatIdList = MyMalloc(DriverNode->NumCompatIds * sizeof(LONG))) {

                FreeCompatIdList = TRUE;

                CopyMemory(NewDriverNode->CompatIdList,
                           DriverNode->CompatIdList,
                           DriverNode->NumCompatIds * sizeof(LONG)
                          );

            } else {
                MyFree(NewDriverNode);
                NewDriverNode = NULL;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(FreeCompatIdList) {
            MyFree(NewDriverNode->CompatIdList);
        }
        MyFree(NewDriverNode);
        NewDriverNode = NULL;
    }

    return NewDriverNode;
}


BOOL
WINAPI
SetupDiCancelDriverInfoSearch(
    IN HDEVINFO DeviceInfoSet
    )
/*++

Routine Description:

    This routine cancels a driver list search that is currently underway in a
    different thread.  This call is synchronous, i.e., it does not return until
    the driver search thread responds to the abort request.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which
        a driver list is being built.

Return Value:

    If there was a driver list search currently underway for the specified set,
    it will be aborted, and this routine will return TRUE once the abort is
    confirmed.

    Otherwise, the return value is FALSE, and GetLastError() will return
    ERROR_INVALID_HANDLE.

--*/
{
    DWORD Err = ERROR_INVALID_HANDLE;
    PDRVSEARCH_INPROGRESS_NODE DrvSearchNode;
    HANDLE SearchCancelledEvent;

    if(!LockDrvSearchInProgressList(&GlobalDrvSearchInProgressList)) {
        //
        // Uh-oh!  We're going away!
        //
        goto clean0;
    }

    try {
        //
        // Step through the list, looking for a node that matches our HDEVINFO.
        //
        for(DrvSearchNode = GlobalDrvSearchInProgressList.DrvSearchHead;
            DrvSearchNode;
            DrvSearchNode = DrvSearchNode->Next) {

            if(DrvSearchNode->DeviceInfoSet == DeviceInfoSet) {
                //
                // We found the node--therefore, this devinfo set is currently
                // tied up with a driver list search.  Set the 'CancelSearch' flag,
                // to notify the other thread that it should abort.
                //
                DrvSearchNode->CancelSearch = TRUE;
                SearchCancelledEvent = DrvSearchNode->SearchCancelledEvent;
                Err = NO_ERROR;
                break;
            }
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_HANDLE;
    }

    //
    // Very important that we unlock this list _before_ waiting on the other thread
    // to respond!
    //
    UnlockDrvSearchInProgressList(&GlobalDrvSearchInProgressList);

    if(Err == NO_ERROR) {
        //
        // We've signalled the other thread to abort--now wait for it to respond.
        //
        WaitForSingleObject(SearchCancelledEvent, INFINITE);
    }

clean0:

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
InitDrvSearchInProgressList(
    VOID
    )
/*++

Routine Description:

    This routine initializes the global "Driver Search In-Progress" list, that is
    used to allow one thread to abort a driver search operation taking place in
    another thread.

Arguments:

    None

Return Value:

    If success, the return value is TRUE, otherwise, it is FALSE.

--*/
{
    ZeroMemory(&GlobalDrvSearchInProgressList, sizeof(DRVSEARCH_INPROGRESS_LIST));
    return InitializeSynchronizedAccess(&GlobalDrvSearchInProgressList.Lock);
}


BOOL
DestroyDrvSearchInProgressList(
    VOID
    )
/*++

Routine Description:

    This routine destroys the global "Driver Search In-Progress" list, that is
    used to allow one thread to abort a driver search operation taking place in
    another thread.

Arguments:

    None

Return Value:

    If success, the return value is TRUE, otherwise, it is FALSE.

--*/
{
    PDRVSEARCH_INPROGRESS_NODE DriverSearchNode;

    if(LockDrvSearchInProgressList(&GlobalDrvSearchInProgressList)) {
        //
        // We would hope that this list is empty, but that may not be the case.
        // We will traverse this list, and signal the event for each node we find.
        // That way, any threads still waiting for driver searches to abort can
        // continue on.  We do not free the memory associated with these nodes,
        // since it is 'owned' by the HDEVINFO, and that is where the responsibility
        // lies to free it.
        //
        try {
            for(DriverSearchNode = GlobalDrvSearchInProgressList.DrvSearchHead;
                DriverSearchNode;
                DriverSearchNode = DriverSearchNode->Next)
            {
                SetEvent(DriverSearchNode->SearchCancelledEvent);
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            ;   // nothing
        }

        DestroySynchronizedAccess(&GlobalDrvSearchInProgressList.Lock);
        return TRUE;
    }

    return FALSE;
}


BOOL
ExtractDrvSearchInProgressNode(
    PDRVSEARCH_INPROGRESS_NODE Node
    )
/*++

Routine Description:

    This routine extracts the specified node out of the global "Driver Search
    In-Progress" list, and if its 'CancelSearch' flag is set, then it signals
    all waiting threads that it has responded to their cancel request.

Arguments:

    Node - Supplies the address of the node to be extracted from the list.

Return Value:

    If the node was found in the list, and the 'CancelSearch' flag was set, then
    the return value is TRUE, otherwise, it is FALSE.

--*/
{
    PDRVSEARCH_INPROGRESS_NODE PrevNode, CurNode;
    BOOL b;

    if(!LockDrvSearchInProgressList(&GlobalDrvSearchInProgressList)) {
        //
        // This should only happen if we're in the middle of a DLL_PROCESS_DETACH.
        // In this case, the clean-up code in CommonProcessAttach(FALSE) will signal
        // all waiting threads, so there's nothing we need to do.
        //
        return FALSE;
    }

    b = FALSE;

    try {
        //
        // Search through the list, looking for our node.
        //
        for(CurNode = GlobalDrvSearchInProgressList.DrvSearchHead, PrevNode = NULL;
            CurNode;
            PrevNode = CurNode, CurNode = CurNode->Next) {

            if(CurNode == Node) {
                //
                // We've found the specified node in the global list.
                //
                break;
            }
        }

        if(!CurNode) {
            //
            // The node wasn't in the list--probably because some kind of exception occurred
            // before it could be linked in.  Since it wasn't in the list, no other thread
            // could be waiting on it, so again, there's nothing to do.
            //
            goto clean0;
        }

        if(CurNode->CancelSearch) {
            b = TRUE;
            SetEvent(CurNode->SearchCancelledEvent);
        }

        //
        // Remove this node from the linked list.
        //
        if(PrevNode) {
            PrevNode->Next = CurNode->Next;
        } else {
            GlobalDrvSearchInProgressList.DrvSearchHead = CurNode->Next;
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        //
        // Access the flag variable so the compiler will respect our statement ordering w.r.t.
        // this value.
        //
        b = b;
    }

    UnlockDrvSearchInProgressList(&GlobalDrvSearchInProgressList);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devicon.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devicon.c

Abstract:

    Device Installer routines dealing with retrieval/display of icons.

Author:

    Lonny McMichael (lonnym) 28-Aug--1995

Notes:

    You must include "basetyps.h" first.

--*/

#include "precomp.h"
#pragma hdrstop
#include <shellapi.h>


MINI_ICON_LIST GlobalMiniIconList;


/*++

    Class-to-Icon conversion tables exist in two places.  First, there
    is the built-in one defined below that is based on a hard-wired
    bitmap in the resource.  The second is a linked list of CLASSICON
    structures that is created every time a new class with an icon
    comes along.

    Check out resource\ilwinmsd.bmp to see the mini-icons.  The icons
    are referenced via their (zero-based) index (e.g., computer is 0,
    chip is 1, display is 2, etc.).  Today, the bitmap indexes look as follows:

        0 - computer
        1 - chip
        2 - display
        3 - network
        4 - windows
        5 - mouse
        6 - keyboard
        7 - phone
        8 - sound
        9 - drives
        10 - plugs
        11 - generic
        12 - check
        13 - uncheck
        14 - printer
        15 - nettrans
        16 - netclient
        17 - netservice
        18 - unknown
        19 - Fax machine
        20 - greyed check
        21 - dial up networking
        22 - direct cable connection
        23 - briefcase (filesync)
        24 - Exchange
        25 - partial check
        26 - Generic folder / Accessories
        27 - media (music)
        28 - Quick View
        29 - old MSN
        30 - calculator
        31 - FAT32 Converter
        32 - Document Templates
        33 - disk compression
        34 - Games
        35 - HyperTerminal
        36 - package
        37 - mspaint
        38 - Screensavers
        39 - WordPad
        40 - Clipboard Viewer
        41 - Accessibility Options
        42 - backup
        43 - Desktop Wallpaper
        44 - Character Map
        45 - Mouse Pointers
        46 - Net Watcher
        47 - phone dialer
        48 - resource monitor
        49 - Online User's Guide
        50 - Multilanguage Support
        51 - Audio Compression
        52 - CD player
        53 - Media Player
        54 - WAV sounds
        55 - Sample Sounds
        56 - Video Compression
        57 - Volume Control
        58 - Musica sound scheme
        59 - Jungle sound scheme
        60 - Robotz sound scheme
        61 - Utopia sound scheme
        62 - Eudcedit
        63 - Minesweeper
        64 - Pinball
        65 - Imaging
        66 - Clock
        67 - Infrared
        68 - MS Wallet
        69 - FrontPage Express (aka FrontPad)
        70 - MS Agent
        71 - Internet Tools
        72 - NetShow Player
        73 - Net Meeting
        74 - DVD Player
        75 - Freecell
        76 - Athena / Outlook Express / Internet Mail and News
        77 - Desktop Themes
        78 - Baseball theme
        79 - Dangerous Creatures theme
        80 - Inside your Computer theme
        81 - Jungle theme
        82 - Leonardo da Vinci theme
        83 - More Windows theme
        84 - Mystery theme
        85 - Nature theme
        86 - Science theme
        87 - Space theme
        88 - Sports theme
        89 - The 60's USA theme
        90 - The Golden Era theme
        91 - Travel theme
        92 - Underwater theme
        93 - Windows 95 theme
        94 - Personal Web Server
        95 - Real Audio
        96 - Web Publisher / WebPost
        97 - WaveTop
        98 - WebTV

--*/

CONST INT UnknownClassMiniIconIndex = 11;

CONST CLASSICON MiniIconXlate[] = { {&GUID_DEVCLASS_COMPUTER,      0, NULL},
                                    {&GUID_DEVCLASS_DISPLAY,       2, NULL},
                                    {&GUID_DEVCLASS_MOUSE,         5, NULL},
                                    {&GUID_DEVCLASS_KEYBOARD,      6, NULL},
                                    {&GUID_DEVCLASS_FDC,           9, NULL},
                                    {&GUID_DEVCLASS_HDC,           9, NULL},
                                    {&GUID_DEVCLASS_PORTS,        10, NULL},
                                    {&GUID_DEVCLASS_NET,          15, NULL},
                                    {&GUID_DEVCLASS_SYSTEM,        0, NULL},
                                    {&GUID_DEVCLASS_SOUND,         8, NULL},
                                    {&GUID_DEVCLASS_PRINTER,      14, NULL},
                                    {&GUID_DEVCLASS_MONITOR,       2, NULL},
                                    {&GUID_DEVCLASS_NETTRANS,      3, NULL},
                                    {&GUID_DEVCLASS_NETCLIENT,    16, NULL},
                                    {&GUID_DEVCLASS_NETSERVICE,   17, NULL},
                                    {&GUID_DEVCLASS_UNKNOWN,      18, NULL},
                                    {&GUID_DEVCLASS_LEGACYDRIVER, 11, NULL},
                                    {&GUID_DEVCLASS_MTD,           9, NULL}
                                  };

//
// ISSUE-2002/05/21-lonnym -- Mini-icon list uses hard-coded dimensions
// We must hard-code the dimensions of the mini-icons we store in our global
// mini-icon list.  This is tied to the size of the mini-icon images contained
// in the ilwinmsd.bmp "strip".
//
#define MINIX 16
#define MINIY 16

#define RGB_WHITE (RGB(255, 255, 255))
#define RGB_BLACK (RGB(0, 0, 0))
#define RGB_TRANSPARENT (RGB(0, 128, 128))


//
// Private function prototypes.
//
INT
NewMiniIcon(
    IN CONST GUID *ClassGuid,
    IN HICON       hIcon      OPTIONAL
    );


INT
WINAPI
SetupDiDrawMiniIcon(
    IN HDC   hdc,
    IN RECT  rc,
    IN INT   MiniIconIndex,
    IN DWORD Flags
    )
/*++

Routine Description:

    This routine draws the specified mini-icon at the requested location.

Arguments:

    hdc - Supplies the handle of the device context in which the mini-icon
        will be drawn.

    rc - Supplies the rectangle in the specified HDC to draw the icon in.

    MiniIconIndex - The index of the mini-icon, as retrieved from
        SetupDiLoadClassIcon or SetupDiGetClassBitmapIndex.  The following are
        pre-defined indices that may be used.

            0    Computer
            2    display
            5    mouse
            6    keyboard
            9    fdc
            9    hdc
            10   ports
            15   net
            0    system
            8    sound
            14   printer
            2    monitor
            3    nettrans
            16   netclient
            17   netservice
            18   unknown

    Flags - Controls the drawing operation.  The LOWORD contains the actual flags
        defined as follows:

        DMI_MASK - Draw the mini-icon's mask into HDC.

        DMI_BKCOLOR - Use the system color index specified in the HIWORD of Flags
            as the background color.  If not specified, COLOR_WINDOW is used.

        DMI_USERECT - If set, SetupDiDrawMiniIcon will use the supplied rect,
            stretching the icon to fit as appropriate.

Return Value:

    This function returns the offset from the left of rc where the string should
    start.

Remarks:

    By default, the icon will be centered vertically and butted against the left
    corner of the specified rectangle.

    If the specified mini-icon index falls outside the range of our mini-icon
    cache, the unknown class mini-icon will be drawn instead.

--*/
{
    HBITMAP hbmOld = NULL;
    COLORREF rgbBk = CLR_INVALID;
    COLORREF rgbText = CLR_INVALID;
    INT ret = 0;
    BOOL MiniIconListLocked = FALSE;
    DWORD Err = NO_ERROR;

    try {

        if(LockMiniIconList(&GlobalMiniIconList)) {
            MiniIconListLocked = TRUE;
        } else {
            leave;
        }

        CreateMiniIcons();

        if((MiniIconIndex >= 0) && ((UINT)MiniIconIndex >= GlobalMiniIconList.NumClassImages)) {
            MiniIconIndex = UnknownClassMiniIconIndex;
        }

        if(GlobalMiniIconList.hbmMiniImage) {
            //
            // Set the Foreground and  background color for the
            // conversion of the Mono Mask image
            //
            if(Flags & DMI_MASK) {
                rgbBk = SetBkColor(hdc, RGB_WHITE);
            } else {
                rgbBk = SetBkColor(hdc,
                                   GetSysColor(((int)(Flags & DMI_BKCOLOR
                                                          ? HIWORD(Flags)
                                                          : COLOR_WINDOW)))
                                  );
            }

            if(rgbBk == CLR_INVALID) {
                leave;
            }

            rgbText = SetTextColor(hdc, RGB_BLACK);

            if(rgbText == CLR_INVALID) {
                leave;
            }

            if(Flags & DMI_USERECT) {
                //
                // Copy the converted mask into the dest.  The transparent
                // areas will be drawn with the current window color.
                //
                hbmOld = SelectObject(GlobalMiniIconList.hdcMiniMem,
                                      GlobalMiniIconList.hbmMiniMask
                                     );
                if(!hbmOld) {
                    leave;
                }

                StretchBlt(hdc,
                           rc.left,
                           rc.top,
                           rc.right - rc.left,
                           rc.bottom - rc.top,
                           GlobalMiniIconList.hdcMiniMem,
                           MINIX * MiniIconIndex,
                           0,
                           MINIX,
                           MINIY,
                           SRCCOPY | NOMIRRORBITMAP);

                if(!(Flags & DMI_MASK)) {
                    //
                    // OR the image into the dest
                    //
                    SelectObject(GlobalMiniIconList.hdcMiniMem,
                                 GlobalMiniIconList.hbmMiniImage
                                );
                    StretchBlt(hdc,
                               rc.left,
                               rc.top,
                               rc.right - rc.left,
                               rc.bottom - rc.top,
                               GlobalMiniIconList.hdcMiniMem,
                               MINIX * MiniIconIndex,
                               0,
                               MINIX,
                               MINIY,
                               SRCPAINT | NOMIRRORBITMAP);
                }

            } else {
                //
                // Copy the converted mask into the dest.  The transparent
                // areas will be drawn with the current window color.
                //
                hbmOld = SelectObject(GlobalMiniIconList.hdcMiniMem,
                                      GlobalMiniIconList.hbmMiniMask
                                     );
                if(!hbmOld) {
                    leave;
                }

                BitBlt(hdc,
                       rc.left,
                       rc.top + (rc.bottom - rc.top - MINIY)/2,
                       MINIX,
                       MINIY,
                       GlobalMiniIconList.hdcMiniMem,
                       MINIX * MiniIconIndex,
                       0,
                       SRCCOPY | NOMIRRORBITMAP
                      );


                if(!(Flags & DMI_MASK)) {
                    //
                    // OR the image into the dest
                    //
                    SelectObject(GlobalMiniIconList.hdcMiniMem,
                                 GlobalMiniIconList.hbmMiniImage
                                );
                    BitBlt(hdc,
                           rc.left,
                           rc.top + (rc.bottom - rc.top - MINIY)/2,
                           MINIX,
                           MINIY,
                           GlobalMiniIconList.hdcMiniMem,
                           MINIX * MiniIconIndex,
                           0,
                           SRCPAINT | NOMIRRORBITMAP
                          );
                }
            }

            //
            // ISSUE-2002/05/21-lonnym -- String offset returned by SetupDiDrawMiniIcon assumes LTR reading
            // This may not work properly in an RTL reading configuration
            //
            if(Flags & DMI_USERECT) {
                ret = rc.right - rc.left + 2; // offset to string from left edge
            } else {
                ret = MINIX + 2;              // offset to string from left edge
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hbmOld) {
        SelectObject(GlobalMiniIconList.hdcMiniMem, hbmOld);
    }

    if(MiniIconListLocked) {
        UnlockMiniIconList(&GlobalMiniIconList);
    }

    if(rgbBk != CLR_INVALID) {
        SetBkColor(hdc, rgbBk);
    }

    if(rgbText != CLR_INVALID) {
        SetTextColor(hdc, rgbText);
    }

    return ((Err == NO_ERROR) ? ret : 0);
}


DWORD
pSetupDiLoadClassIcon(
    IN  CONST GUID *ClassGuid,
    OUT HICON      *LargeIcon,     OPTIONAL
    OUT HICON      *SmallIcon,     OPTIONAL
    OUT LPINT      MiniIconIndex   OPTIONAL
    )
/*++

Routine Description:

    This routine loads both the large and mini-icons for the specified class

Arguments:

    ClassGuid - Supplies the GUID of the class for which the icon(s) should
        be loaded.

    LargeIcon - Optionally, supplies a pointer to a variable that will receive
        a handle to the loaded large icon for the specified class.  If this
        parameter is not specified, the large icon will not be loaded.

        The caller must free this icon handle by calling DestroyIcon when they
        no longer need the icon.

    SmallIcon - Optionally, supplies a pointer to a variable that will receive
        a handle to the loaded small icon for the specified class.  If this
        parameter is not specified, the small icon will not be loaded.

        The caller must free this icon handle by calling DestroyIcon when they
        no longer need the icon.

    MiniIconIndex - Optionally, supplies a pointer to a variable that will
        receive the index of the mini-icon for the specified class.  The
        mini-icon is stored in the device installer's mini-icon cache.

Return Value:

    If the function succeeds, the return value is NO_ERROR.  Otherwise, it is
    a Win32 error code indicating the cause of failure.

Remarks:

    The icons of the class are either pre-defined, and loaded from the  device
    installer's internal cache, or they are loaded directly from the class
    installer's executable.  This function will query the registry value ICON in
    the specified class's section.  If this value is specified then it indicates
    what mini icon to load.  If the icon value is negative the absolute value
    represents a predefined icon.  See SetupDiDrawMiniIcon for a list of
    pre-defined mini icons.  If the icon value is positive it represents an icon
    in the class installer's executable, and will be extracted (the number one
    is reserved).  This function also uses the INSTALLER32 value first and
    ENUMPROPPAGES32 value second to determine what executable to extract the
    icon(s) from.

--*/
{
    HKEY hk = INVALID_HANDLE_VALUE;
    DWORD Err;
    HICON hRetLargeIcon = NULL;
    HICON hRetSmallIcon = NULL;
    INT ClassIconIndex;
    DWORD RegDataType, StringSize;
    PTSTR EndPtr;
    BOOL bGetMini = FALSE;
    TCHAR TempString[MAX_PATH];
    TCHAR FullPath[MAX_PATH];
    UINT  IconsExtracted;
    HRESULT hr;

    if(!LockMiniIconList(&GlobalMiniIconList)) {
        return ERROR_CANT_LOAD_CLASS_ICON;
    }

    try {

        if(MiniIconIndex) {
            *MiniIconIndex = -1;
        }

        if((hk = SetupDiOpenClassRegKey(ClassGuid, KEY_READ)) == INVALID_HANDLE_VALUE) {
            goto LoadIconFinalize;
        }

        StringSize = sizeof(TempString);
        Err = RegQueryValueEx(hk,
                              pszInsIcon,
                              NULL,
                              &RegDataType,
                              (PBYTE)TempString,
                              &StringSize
                              );

        if((Err == ERROR_SUCCESS) && (RegDataType == REG_SZ) && TempString[0]) {

            if((ClassIconIndex = _tcstol(TempString, &EndPtr, 10)) == 1) {
                //
                // Positive values indicate that we should access an icon
                // directly using its ID.  Since ExtractIconEx uses negative
                // values to indicate these IDs, and since the value -1 has
                // a special meaning to that API, we must disallow a
                // ClassIconIndex of +1.
                //
                goto LoadIconFinalize;
            }

        } else {
            //
            // Icon index not specified, so assume index is 0.
            //
            ClassIconIndex = 0;
        }

        if(MiniIconIndex) {
            //
            // If mini-icon is already around, then we're done with it.
            //
            if(!SetupDiGetClassBitmapIndex(ClassGuid, MiniIconIndex)) {
                //
                // mini-icon not around--set flag to show we didn't get it.
                //
                bGetMini = TRUE;
            }
        }

        if(ClassIconIndex < 0) {

            INT ClassIconIndexNeg = -ClassIconIndex;

            //
            // Icon index is negative.  This means that this class is one of
            // our special classes with icons in setupapi.dll.  We still want
            // to return copies of our icons (both large and small) in this
            // case, since:
            //
            //    (a) icon's origin is opaque to callers, and we want them to
            //        treat resultant HICONs consistently
            //
            //    (b) we don't want any back-door dependency created between
            //        these icons and the presence/absence of setupapi.dll
            //        (i.e., they should be able to unload setupapi.dll and the
            //        icon handle(s) should still be valid.
            //
            if(LargeIcon) {

                hRetLargeIcon = LoadImage(MyDllModuleHandle,
                                          MAKEINTRESOURCE(ClassIconIndexNeg),
                                          IMAGE_ICON,
                                          0,
                                          0,
                                          LR_DEFAULTSIZE
                                         );
            }

            if(bGetMini || SmallIcon) {
                //
                // Retrieve the small icon as well.  If the resource doesn't
                // have a small icon then the big one will get smushed, but
                // it's better than getting the default icon.
                //
                hRetSmallIcon = LoadImage(MyDllModuleHandle,
                                          MAKEINTRESOURCE(ClassIconIndexNeg),
                                          IMAGE_ICON,
                                          GetSystemMetrics(SM_CXSMICON),
                                          GetSystemMetrics(SM_CYSMICON),
                                          0
                                          );

                if(hRetSmallIcon && bGetMini) {
                    *MiniIconIndex = NewMiniIcon(ClassGuid, hRetSmallIcon);
                }
            }

        } else if(bGetMini || LargeIcon || SmallIcon) {
            //
            // Look for the binary containing the icon(s) first in the
            // "Installer32" entry, and if not found, then in the
            // "EnumPropPages32" entry.
            //
            hr = StringCchCopy(FullPath,
                               SIZECHARS(FullPath),
                               SystemDirectory
                               );

            if(FAILED(hr)) {
                goto LoadIconFinalize;
            }

            StringSize = sizeof(TempString);
            Err = RegQueryValueEx(hk,
                                  pszInstaller32,
                                  NULL,
                                  &RegDataType,
                                  (PBYTE)TempString,
                                  &StringSize
                                  );

            if((Err != ERROR_SUCCESS) || (RegDataType != REG_SZ) ||
               !TempString[0]) {

                StringSize = sizeof(TempString);
                Err = RegQueryValueEx(hk,
                                      pszEnumPropPages32,
                                      NULL,
                                      &RegDataType,
                                      (PBYTE)TempString,
                                      &StringSize
                                      );

                if((Err != ERROR_SUCCESS) || (RegDataType != REG_SZ) ||
                   !TempString[0]) {

                    goto LoadIconFinalize;
                }
            }

            //
            // Remove function name, if present, from installer name.
            //
            for(EndPtr = TempString + (lstrlen(TempString) - 1);
                EndPtr >= TempString;
                EndPtr--) {

                if(*EndPtr == TEXT(',')) {
                    *EndPtr = TEXT('\0');
                    break;
                }
                //
                // If we hit a double-quote mark, we terminate the search.
                //
                if(*EndPtr == TEXT('\"')) {
                    goto LoadIconFinalize;
                }
            }
            if(!pSetupConcatenatePaths(FullPath,
                                       TempString,
                                       SIZECHARS(FullPath),
                                       NULL)) {
                goto LoadIconFinalize;
            }

            IconsExtracted = ExtractIconEx(FullPath,
                                           -ClassIconIndex,
                                           LargeIcon ? &hRetLargeIcon : NULL,
                                           (bGetMini || SmallIcon) ? &hRetSmallIcon : NULL,
                                           1
                                          );
            if((IconsExtracted != (UINT)-1) && (IconsExtracted > 0)) {

                if(hRetSmallIcon && bGetMini) {
                    *MiniIconIndex = NewMiniIcon(ClassGuid, hRetSmallIcon);
                }
            }
        }

LoadIconFinalize:
        //
        // Assume success, unless we hit some really big problem below.
        //
        Err = NO_ERROR;

        if(LargeIcon && !hRetLargeIcon) {
            //
            // We didn't retrieve a large icon, so use a default.
            //
            Err = GLE_FN_CALL(NULL,
                              hRetLargeIcon = LoadImage(
                                                  MyDllModuleHandle,
                                                  MAKEINTRESOURCE(ICON_DEFAULT),
                                                  IMAGE_ICON,
                                                  0,
                                                  0,
                                                  LR_DEFAULTSIZE)
                             );

            if(Err != NO_ERROR) {
                leave;
            }
        }

        if(SmallIcon && !hRetSmallIcon) {
            //
            // We didn't retrieve a small icon, so use a default.
            //
            Err = GLE_FN_CALL(NULL,
                              hRetSmallIcon = LoadImage(
                                                  MyDllModuleHandle,
                                                  MAKEINTRESOURCE(ICON_DEFAULT),
                                                  IMAGE_ICON,
                                                  GetSystemMetrics(SM_CXSMICON),
                                                  GetSystemMetrics(SM_CYSMICON),
                                                  0)
                             );

            if(Err != NO_ERROR) {
                leave;
            }
        }

        if(LargeIcon) {
            *LargeIcon = hRetLargeIcon;
            hRetLargeIcon = NULL;       // so we won't try to destroy it later
        }

        if(SmallIcon) {
            *SmallIcon = hRetSmallIcon;
            hRetSmallIcon = NULL;       // so we won't try to destroy it later
        }

        if(MiniIconIndex && (*MiniIconIndex == -1)) {
            SetupDiGetClassBitmapIndex(NULL, MiniIconIndex);
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    UnlockMiniIconList(&GlobalMiniIconList);

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    if(hRetLargeIcon) {
        DestroyIcon(hRetLargeIcon);
    }

    if(hRetSmallIcon) {
        DestroyIcon(hRetSmallIcon);
    }

    return Err;
}


BOOL
WINAPI
SetupDiLoadClassIcon(
    IN  CONST GUID *ClassGuid,
    OUT HICON      *LargeIcon,     OPTIONAL
    OUT LPINT       MiniIconIndex  OPTIONAL
    )
/*++

Routine Description:

    This routine loads both the large and mini-icons for the specified class

Arguments:

    ClassGuid - Supplies the GUID of the class for which the icon(s) should
        be loaded.

    LargeIcon - Optionally, supplies a pointer to a variable that will receive
        a handle to the loaded large icon for the specified class.  If this
        parameter is not specified, the large icon will not be loaded.

        The caller must free this icon handle by calling DestroyIcon when they
        no longer need the icon.

    MiniIconIndex - Optionally, supplies a pointer to a variable that will
        receive the index of the mini-icon for the specified class.  The
        mini-icon is stored in the device installer's mini-icon cache.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    The icons of the class are either pre-defined, and loaded from the device
    installer's internal cache, or they are loaded directly from the class
    installer's executable.  This function will query the registry value ICON
    in the specified class's section.  If this value is specified then it
    indicates what mini icon to load.  If the icon value is negative the
    absolute value represents a predefined icon.  See SetupDiDrawMiniIcon for a
    list of pre-defined mini icons.  If the icon value is positive it
    represents an icon in the class installer's executable, and will be
    extracted (the number one is reserved).  This function also uses the
    INSTALLER32 value first and ENUMPROPPAGES32 value second to determine what
    executable to extract the icon(s) from.

--*/
{
    DWORD Err;

    //
    // Wrap call in try/except to catch stack overflow
    //
    try {

        Err = pSetupDiLoadClassIcon(ClassGuid,
                                    LargeIcon,
                                    NULL,
                                    MiniIconIndex
                                   );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiGetClassBitmapIndex(
    IN  CONST GUID *ClassGuid,    OPTIONAL
    OUT PINT        MiniIconIndex
    )
/*++

Routine Description:

    This routine retrieves the index of the mini-icon for the specified class.

Arguments:

    ClassGuid - Optionally, supplies the GUID of the class to get the mini-icon
        index for.  If this parameter is not specified, the index of the 'unknown'
        icon is returned.

    MiniIconIndex - Supplies a pointer to a variable that receives the index of
        the mini-icon for the specified class.  This buffer is always filled in,
        and receives the index of the unknown mini-icon if there is no mini-icon
        for the specified class (i.e., the return value is FALSE).

Return Value:

    If there was a mini-icon for the specified class, the return value is TRUE.

    If there was not a mini-icon for the specified class, or if no class was
    specified, the return value is FALSE (and GetLastError returns
    ERROR_NO_DEVICE_CLASS_ICON).  In this case, MiniIconIndex will contain the
    index of the unknown mini-icon.

--*/
{
    BOOL bRet = FALSE;  // assume not found
    int i;
    PCLASSICON pci;
    DWORD Err;
    BOOL MiniIconListLocked = FALSE;

    try {

        if(ClassGuid) {
            //
            // First check the built-in list.
            //
            for(i = 0; !bRet && (i < ARRAYSIZE(MiniIconXlate)); i++) {

                if(IsEqualGUID(MiniIconXlate[i].ClassGuid, ClassGuid)) {
                    *MiniIconIndex = MiniIconXlate[i].MiniBitmapIndex;
                    bRet = TRUE;
                }
            }

            //
            // Next check the "new stuff" list to see if it's there.
            //
            if(!bRet && LockMiniIconList(&GlobalMiniIconList)) {

                MiniIconListLocked = TRUE;

                for(pci = GlobalMiniIconList.ClassIconList;
                    !bRet && pci;
                    pci = pci->Next) {

                    if(IsEqualGUID(pci->ClassGuid, ClassGuid)) {
                        *MiniIconIndex = pci->MiniBitmapIndex;
                        bRet = TRUE;
                    }
                }
            }
        }

        //
        // If no match was found, snag the "unknown" class.
        //
        if(!bRet) {
            *MiniIconIndex = UnknownClassMiniIconIndex;
            Err = ERROR_NO_DEVICE_ICON;
        } else {
            Err = NO_ERROR;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(MiniIconListLocked) {
        UnlockMiniIconList(&GlobalMiniIconList);
    }

    SetLastError(Err);
    return bRet;
}


BOOL
CreateMiniIcons(
    VOID
    )
/*++

Routine Description:

    This routine loads the default bitmap of mini-icons and turns it into
    the image/mask pair that will be the cornerstone of mini-icon management.
    THIS FUNCTION ASSUMES THE MINI-ICON LOCK HAS ALREADY BEEN ACQUIRED!

Arguments:

    None.

Return Value:

    If the function succeeds, the return value is TRUE, otherwise it is FALSE.

--*/
{
    HDC hdc = NULL;
    HDC hdcMem = NULL;
    HBITMAP hbmOld = NULL;
    BITMAP bm;
    BOOL bRet = FALSE;          // assume failure

    if(GlobalMiniIconList.hdcMiniMem) {
        //
        // Then the mini-icon list has already been built, so
        // return success.
        //
        return TRUE;
    }

    try {

        hdc = GetDC(NULL);
        if(!hdc) {
            leave;
        }
        GlobalMiniIconList.hdcMiniMem = CreateCompatibleDC(hdc);
        if(!GlobalMiniIconList.hdcMiniMem) {
            leave;
        }

        hdcMem = CreateCompatibleDC(GlobalMiniIconList.hdcMiniMem);

        if(!hdcMem) {
            leave;
        }

        if(!(GlobalMiniIconList.hbmMiniImage = LoadBitmap(MyDllModuleHandle,
                                                          MAKEINTRESOURCE(BMP_DRIVERTYPES)))) {
            leave;
        }

        GetObject(GlobalMiniIconList.hbmMiniImage, sizeof(bm), &bm);

        if(!(GlobalMiniIconList.hbmMiniMask = CreateBitmap(bm.bmWidth,
                                                           bm.bmHeight,
                                                           1,
                                                           1,
                                                           NULL))) {
            leave;
        }

        hbmOld = SelectObject(hdcMem, GlobalMiniIconList.hbmMiniImage);
        if(!hbmOld) {
            leave;
        }

        SelectObject(GlobalMiniIconList.hdcMiniMem,
                     GlobalMiniIconList.hbmMiniMask
                    );

        //
        // make the mask.  white where transparent, black where opaque
        //
        SetBkColor(hdcMem, RGB_TRANSPARENT);
        BitBlt(GlobalMiniIconList.hdcMiniMem,
               0,
               0,
               bm.bmWidth,
               bm.bmHeight,
               hdcMem,
               0,
               0,
               SRCCOPY
              );

        //
        // black-out all of the transparent parts of the image, in preparation
        // for drawing.
        //
        SetBkColor(hdcMem, RGB_BLACK);
        SetTextColor(hdcMem, RGB_WHITE);
        BitBlt(hdcMem, 0, 0, bm.bmWidth, bm.bmHeight, GlobalMiniIconList.hdcMiniMem, 0, 0, SRCAND);

        SelectObject(GlobalMiniIconList.hdcMiniMem, hbmOld);

        GlobalMiniIconList.NumClassImages = bm.bmWidth/MINIX;
        bRet = TRUE;

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        bRet = FALSE;
    }

    if(hdc) {
        ReleaseDC(NULL, hdc);
    }

    if(hdcMem) {
        if(hbmOld) {
            SelectObject(hdcMem, hbmOld);
        }
        DeleteObject(hdcMem);
    }

    //
    // If failure, clean up anything we might have built
    //
    if(!bRet) {
        DestroyMiniIcons();
    }

    return bRet;
}


INT
NewMiniIcon(
    IN CONST GUID *ClassGuid,
    IN HICON       hIcon      OPTIONAL
    )
/*++

Routine Description:

    It's a new class, and we have a mini-icon for it, so let's add it
    to the mini-icon database.  First pull out the image and mask
    bitmaps.  Then add these to the mini-icon bitmap.  If this all
    works, add the new class to the list

    THIS FUNCTION ASSUMES THE MINI-ICON LOCK HAS ALREADY BEEN ACQUIRED!

Arguments:

    ClassGuid - Supplies a pointer to the class GUID for this mini-icon.

    hIcon - Optionally, supplies a handle to the mini-icon to be added to
        the database.  If this parameter is not specified, then the index
        for the "unknown class" icon will be returned.

Return Value:

    Index for class (set to "unknown class" if error)

--*/
{
    INT iBitmap = -1;
    ICONINFO ii;
    PCLASSICON pci = NULL;

    if(hIcon && GetIconInfo(hIcon, &ii)) {

        try {

            if((iBitmap = pSetupAddMiniIconToList(ii.hbmColor, ii.hbmMask)) != -1) {
                //
                // Allocate an extra GUID's worth of memory, so we can store
                // the class GUID in the same chunk of memory as the CLASSICON
                // node.
                //
                if(pci = (PCLASSICON)MyMalloc(sizeof(CLASSICON) + sizeof(GUID))) {

                    CopyMemory((PBYTE)pci + sizeof(CLASSICON),
                               ClassGuid,
                               sizeof(GUID)
                              );
                    pci->ClassGuid = (LPGUID)((PBYTE)pci + sizeof(CLASSICON));
                    pci->MiniBitmapIndex = iBitmap;

                    pci->Next = GlobalMiniIconList.ClassIconList;
                    GlobalMiniIconList.ClassIconList = pci;
                }
            }

        } except(pSetupExceptionFilter(GetExceptionCode())) {

            pSetupExceptionHandler(GetExceptionCode(),
                                   ERROR_INVALID_PARAMETER,
                                   NULL
                                  );

            if(pci) {
                MyFree(pci);
            }

            iBitmap = -1;
        }

        DeleteObject(ii.hbmColor);
        DeleteObject(ii.hbmMask);
    }

    if(iBitmap == -1) {
        SetupDiGetClassBitmapIndex(NULL, &iBitmap);
    }

    return iBitmap;
}


INT
pSetupAddMiniIconToList(
    IN HBITMAP hbmImage,
    IN HBITMAP hbmMask
    )
/*++

Routine Description:

    Given the image and mask bitmaps of a mini-icon, add these to the
    mini-icon bitmap.

    THIS FUNCTION ASSUMES THE MINI-ICON LOCK HAS ALREADY BEEN ACQUIRED!

Arguments:

    hbmImage - Supplies the handle of the bitmap for the mini-icon.

    hbmMask - Supplies the handle of the bitmap for the mini-icon's mask.

Return Value:

    If success, returns the index of the added mini-icon.
    If failure, returns -1.

--*/
{
    HBITMAP hbmNewImage = NULL, hbmNewMask = NULL;
    HBITMAP hbmOld;
    HDC     hdcMem = NULL;
    BITMAP  bm;
    BOOL    bSelectOldBitmap = FALSE;
    INT     iIcon = -1;  // assume failure

    if(!CreateMiniIcons()) {
        return iIcon;
    }

    MYASSERT(GlobalMiniIconList.hdcMiniMem);

    try {

        hdcMem = CreateCompatibleDC(GlobalMiniIconList.hdcMiniMem);

        if(!hdcMem) {
            leave;
        }

        //
        // Create a New global Bitmap for the minis
        //
        hbmOld = SelectObject(GlobalMiniIconList.hdcMiniMem,
                              GlobalMiniIconList.hbmMiniImage
                             );

        bSelectOldBitmap = TRUE;

        if(!(hbmNewImage = CreateCompatibleBitmap(
                               GlobalMiniIconList.hdcMiniMem,
                               MINIX * (GlobalMiniIconList.NumClassImages + 1),
                               MINIY))) {
            leave;
        }

        //
        // Copy the current Mini bitmap
        //
        SelectObject(hdcMem, hbmNewImage);
        BitBlt(hdcMem,
               0,
               0,
               MINIX * GlobalMiniIconList.NumClassImages,
               MINIY,
               GlobalMiniIconList.hdcMiniMem,
               0,
               0,
               SRCCOPY
              );

        //
        // Fit the New icon into ours. We need to stretch it to fit correctly.
        //
        SelectObject(GlobalMiniIconList.hdcMiniMem, hbmImage);
        GetObject(hbmImage, sizeof(bm), &bm);
        StretchBlt(hdcMem,
                   MINIX * GlobalMiniIconList.NumClassImages,
                   0,
                   MINIX,
                   MINIY,
                   GlobalMiniIconList.hdcMiniMem,
                   0,
                   0,
                   bm.bmWidth,
                   bm.bmHeight,
                   SRCCOPY
                  );

        SelectObject(GlobalMiniIconList.hdcMiniMem, hbmOld);
        bSelectOldBitmap = FALSE;

        //
        // Next, copy the mask.
        //
        hbmOld = SelectObject(GlobalMiniIconList.hdcMiniMem,
                              GlobalMiniIconList.hbmMiniMask
                             );

        bSelectOldBitmap = TRUE;

        if(!(hbmNewMask = CreateBitmap(MINIX * (GlobalMiniIconList.NumClassImages + 1),
                                       MINIY,
                                       1,
                                       1,
                                       NULL))) {
            leave;
        }

        SelectObject(hdcMem, hbmNewMask);
        BitBlt(hdcMem,
               0,
               0,
               MINIX * GlobalMiniIconList.NumClassImages,
               MINIY,
               GlobalMiniIconList.hdcMiniMem,
               0,
               0,
               SRCCOPY
              );

        SelectObject(GlobalMiniIconList.hdcMiniMem, hbmMask);
        GetObject(hbmMask, sizeof(bm), &bm);
        StretchBlt(hdcMem,
                   MINIX * GlobalMiniIconList.NumClassImages,
                   0,
                   MINIX,
                   MINIY,
                   GlobalMiniIconList.hdcMiniMem,
                   0,
                   0,
                   bm.bmWidth,
                   bm.bmHeight,
                   SRCCOPY
                  );

        SelectObject(GlobalMiniIconList.hdcMiniMem, hbmOld);
        bSelectOldBitmap = FALSE;

        //
        // Now that we've successfully constructed new image and mask bitmaps,
        // store those into our mini-icon list.
        //
        DeleteObject(GlobalMiniIconList.hbmMiniImage);
        GlobalMiniIconList.hbmMiniImage = hbmNewImage;
        hbmNewImage = NULL; // so we won't try to delete this later

        DeleteObject(GlobalMiniIconList.hbmMiniMask);
        GlobalMiniIconList.hbmMiniMask = hbmNewMask;
        hbmNewMask = NULL;  // so we won't try to delete this later

        iIcon = GlobalMiniIconList.NumClassImages;
        GlobalMiniIconList.NumClassImages++; // one more image in the list

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        iIcon = -1;
    }

    if(bSelectOldBitmap) {
        SelectObject(GlobalMiniIconList.hdcMiniMem, hbmOld);
    }

    if(hbmNewImage) {
        DeleteObject(hbmNewImage);
    }

    if(hbmNewMask) {
        DeleteObject(hbmNewMask);
    }

    if(hdcMem) {
        DeleteDC(hdcMem);
    }

    return iIcon;
}


VOID
DestroyMiniIcons(
    VOID
    )
/*++

Routine Description:

    This routine destroys the mini-icon bitmaps, if they exist.
    THIS FUNCTION ASSUMES THE MINI-ICON LOCK HAS ALREADY BEEN ACQUIRED!

Arguments:

    None.

Return Value:

    None.

--*/
{
    PCLASSICON pci;

    if(GlobalMiniIconList.hdcMiniMem) {
        DeleteDC(GlobalMiniIconList.hdcMiniMem);
        GlobalMiniIconList.hdcMiniMem = NULL;
    }

    if(GlobalMiniIconList.hbmMiniImage) {
        DeleteObject(GlobalMiniIconList.hbmMiniImage);
        GlobalMiniIconList.hbmMiniImage = NULL;
    }

    if(GlobalMiniIconList.hbmMiniMask) {
        DeleteObject(GlobalMiniIconList.hbmMiniMask);
        GlobalMiniIconList.hbmMiniMask = NULL;
    }

    GlobalMiniIconList.NumClassImages = 0;

    //
    // Free up any additional class icon guys that were created
    //
    while(GlobalMiniIconList.ClassIconList) {
        pci = GlobalMiniIconList.ClassIconList;
        GlobalMiniIconList.ClassIconList = pci->Next;
        MyFree(pci);
    }
}


BOOL
WINAPI
SetupDiGetClassImageList(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData
    )
/*++

Routine Description:

    See SetupDiGetClassImageListEx for details.

--*/
{
    DWORD Err;

    //
    // Wrap call in try/except to catch stack overflow
    //
    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiGetClassImageListEx(ClassImageListData,
                                                     NULL,
                                                     NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetClassImageListExA(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData,
    IN  PCSTR                   MachineName,        OPTIONAL
    IN  PVOID                   Reserved
    )
{
    PCWSTR UnicodeMachineName = NULL;
    DWORD rc;

    try {

        if(MachineName) {
            rc = pSetupCaptureAndConvertAnsiArg(MachineName,
                                                &UnicodeMachineName
                                               );
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiGetClassImageListExW(ClassImageListData,
                                                     UnicodeMachineName,
                                                     Reserved)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}


BOOL
WINAPI
SetupDiGetClassImageListEx(
    OUT PSP_CLASSIMAGELIST_DATA ClassImageListData,
    IN  PCTSTR                  MachineName,        OPTIONAL
    IN  PVOID                   Reserved
    )
/*++

Routine Description:

    This routine builds an image list containing bitmaps for every installed class,
    and returns a data structure containing the list.

Arguments:

    ClassImageListData - Supplies the address of a SP_CLASSIMAGELIST_DATA structure
        that will receive information regarding the class list (including a handle
        to the image list).  The cbSize field of this structure must be initialized
        with the size of the structure (in bytes) before calling this routine, or the
        API will fail.

    MachineName - Optionally, specifies the name of the remote machine whose installed
        classes are to be used in building the class image list.  If this parameter is
        not specified, the local machine is used.

        NOTE:  Presently, class-specific icons can only be displayed if the class is
               also present on the local machine.  Thus, if the remote machine has
               class x, but class x is not installed locally, then the generic (unknown)
               icon will be returned.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    The image list contained in structure filled in by this API should NOT be
    destroyed by calling ImageList_Destroy.  Instead, SetupDiDestroyClassImageList
    should be called, for proper clean-up to occur.

--*/
{
    DWORD   Err = NO_ERROR;
    int     cxMiniIcon, cyMiniIcon;
    int     MiniIconIndex = 0, DefaultIndex = 0;
    int     GuidCount, i;
    int     iIcon, iIndex;
    HDC     hDC = NULL, hMemImageDC = NULL;
    HBITMAP hbmMiniImage = NULL, hbmMiniMask = NULL, hbmOldImage = NULL;
    RECT    rc;
    CONST GUID *pClassGuid = NULL;
    BOOL    bUseBitmap, ComputerClassFound = FALSE;
    HICON   hiLargeIcon = NULL, hiSmallIcon = NULL;
    HICON   hIcon;
    HBRUSH  hOldBrush;
    PCLASSICON   pci = NULL;
    PCLASS_IMAGE_LIST ImageData = NULL;
    BOOL    DestroyLock = FALSE;
    HIMAGELIST ImageList = NULL;
    DWORD   dwLayout = 0;
    UINT    ImageListFlags = 0;

    //
    // Make sure the caller didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    try {

        if(ClassImageListData->cbSize != sizeof(SP_CLASSIMAGELIST_DATA)) {
            Err = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        //
        // Allocate and initialize the image list, including setting up the
        // synchronization lock.  Destroy it when done.
        //
        if(ImageData = MyMalloc(sizeof(CLASS_IMAGE_LIST))) {
            ZeroMemory(ImageData, sizeof(CLASS_IMAGE_LIST));
        } else {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        if(InitializeSynchronizedAccess(&ImageData->Lock)) {
            DestroyLock = TRUE;
        }

        //
        // Build the class image list. Create an Image List with no mask,
        // 1 image, and a growth factor of 1.
        //
        cxMiniIcon = GetSystemMetrics(SM_CXSMICON);
        cyMiniIcon = GetSystemMetrics(SM_CYSMICON);

        ImageListFlags = ILC_MASK;

        //
        // Check which color depth we are running in. Set the ILC_COLOR32
        // imagelist create flag if we are running at greate than 8bit (256)
        // color depth.
        //
        hDC = GetDC(NULL);
        if (hDC) {
            if (GetDeviceCaps(hDC, BITSPIXEL) > 8) {
                ImageListFlags |= ILC_COLOR32;
            }

            ReleaseDC(NULL, hDC);
            hDC = NULL;
        }

        //
        // If we are running on an RTL build then we need to set the ILC_MIRROR
        // flag when calling ImageList_Create to un-mirror the icons.  By
        // default the icons are mirrored.
        //
        if (GetProcessDefaultLayout(&dwLayout) &&
            (dwLayout & LAYOUT_RTL)) {
            ImageListFlags |= ILC_MIRROR;
        }

        if(!(ImageList = ImageList_Create(cxMiniIcon,
                                          cyMiniIcon,
                                          ImageListFlags,
                                          1,
                                          1)))
        {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        ImageList_SetBkColor(ImageList, GetSysColor(COLOR_WINDOW));

        //
        // Create a DC to draw the mini icons into.  This is needed
        // for the system defined Minis
        //
        if(!(hDC = GetDC(HWND_DESKTOP)) ||
           !(hMemImageDC = CreateCompatibleDC(hDC)))
        {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        //
        // Create a bitmap to draw the icons on.  Defer checking for creation
        // of bitmap until afer freeing DC, so it only has to be done once.
        //
        hbmMiniImage = CreateCompatibleBitmap(hDC, cxMiniIcon, cyMiniIcon);
        hbmMiniMask = CreateCompatibleBitmap(hDC, cxMiniIcon, cyMiniIcon);

        ReleaseDC(HWND_DESKTOP, hDC);
        hDC = NULL;

        //
        // Did the bitmap get created?
        //
        if (!hbmMiniImage || ! hbmMiniMask) {
            Err = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        //
        // Select our bitmap into the memory DC.
        //
        hbmOldImage = SelectObject(hMemImageDC, hbmMiniImage);

        //
        // Prepare to draw the mini icon onto the memory DC
        //
        rc.left   = 0;
        rc.top    = 0;
        rc.right  = cxMiniIcon;
        rc.bottom = cyMiniIcon;

        //
        // Get the Index of the Default mini icon.
        //
        SetupDiGetClassBitmapIndex(NULL, &DefaultIndex);

        //
        // Enumerate all classes, and for each class, draw its bitmap.
        //
        GuidCount = 32;  // reasonable sized list to start out with.

        ImageData->ClassGuidList = (LPGUID)MyMalloc(sizeof(GUID) * GuidCount);

        Err = GLE_FN_CALL(FALSE,
                          SetupDiBuildClassInfoListEx(0,
                                                      ImageData->ClassGuidList,
                                                      GuidCount,
                                                      &GuidCount,
                                                      MachineName,
                                                      NULL)
                         );


        if(Err == ERROR_INSUFFICIENT_BUFFER) {
            //
            // Realloc buffer and try again.
            //
            MyFree(ImageData->ClassGuidList);

            if(!(ImageData->ClassGuidList = MyMalloc(sizeof(GUID) * GuidCount))) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }

            Err = GLE_FN_CALL(FALSE,
                              SetupDiBuildClassInfoListEx(
                                  0,
                                  ImageData->ClassGuidList,
                                  GuidCount,
                                  &GuidCount,
                                  MachineName,
                                  NULL)
                             );
        }

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // Retrieve the icon for each class in the class list.
        //
        for(pClassGuid = ImageData->ClassGuidList, i = 0;
            i < GuidCount;
            pClassGuid++, i++) {

            Err = pSetupDiLoadClassIcon(pClassGuid,
                                        &hiLargeIcon,
                                        &hiSmallIcon,
                                        &MiniIconIndex
                                       );
            if(Err != NO_ERROR) {
                leave;
            }

            //
            // If the returned Mini Icon index is not the Default one, then
            // we use the MiniBitmap, since it is a pre-defined one in SETUPAPI.
            // If the Mini is not pre-defined, and there is no Class Installer
            // then we use the Mini, since it is a valid default.  If there
            // is no Mini, and there is a class installer, then we will use
            // the Class installer's big Icon, and have the Image list crunch
            // it for us.
            //
            bUseBitmap = FALSE;

            if(DefaultIndex != MiniIconIndex) {

                SetupDiDrawMiniIcon(hMemImageDC,
                                    rc,
                                    MiniIconIndex,
                                    DMI_USERECT);

                SelectObject(hMemImageDC, hbmMiniMask);

                SetupDiDrawMiniIcon(hMemImageDC,
                                    rc,
                                    MiniIconIndex,
                                    DMI_MASK | DMI_USERECT);
                bUseBitmap = TRUE;
            }

            //
            // Deselect the bitmap from our DC BEFORE calling ImageList
            // functions.
            //
            SelectObject(hMemImageDC, hbmOldImage);

            //
            // Add the image. Allocate a new PCI.
            //
            if(!(pci = (PCLASSICON)MyMalloc(sizeof(CLASSICON)))) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }

            if(hiSmallIcon) {
                pci->MiniBitmapIndex = (UINT)ImageList_AddIcon(ImageList, hiSmallIcon);
            } else if(bUseBitmap) {
                pci->MiniBitmapIndex = (UINT)ImageList_Add(ImageList, hbmMiniImage, hbmMiniMask);
            } else {
                pci->MiniBitmapIndex = (UINT)ImageList_AddIcon(ImageList, hiLargeIcon);
            }

            if(hiLargeIcon) {
                DestroyIcon(hiLargeIcon);
                hiLargeIcon = NULL;
            }

            if(hiSmallIcon) {
                DestroyIcon(hiSmallIcon);
                hiSmallIcon = NULL;
            }

            if(pci->MiniBitmapIndex == (UINT)-1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                MyFree(pci);
                pci = NULL;
                leave;
            }

            pci->ClassGuid = pClassGuid;

            //
            // Link it in.
            //
            pci->Next = ImageData->ClassIconList;
            ImageData->ClassIconList = pci;

            //
            // Reset pci to NULL so we won't try to free it later.
            //
            pci = NULL;

            //
            // Select our bitmap back for the next ICON.
            //
            SelectObject(hMemImageDC, hbmMiniImage);

            if(IsEqualGUID(pClassGuid, &GUID_DEVCLASS_UNKNOWN)) {
                ImageData->UnknownImageIndex = i;
            }

            //
            // Check to see if we've encountered the computer class.  This used
            // to be a special pseudo-class used solely by DevMgr to retrieve
            // the icon for the root of the device tree.  Now, we use this class
            // for specifying the 'drivers' for the computer itself (i.e., the
            // HALs and the appropriate versions of files that are different for
            // MP vs. UP.
            //
            // We should encounter this class GUID, but if we don't, then we
            // want to maintain the old behavior of adding this in manually
            // later on.
            //
            if(!ComputerClassFound && IsEqualGUID(pClassGuid, &GUID_DEVCLASS_COMPUTER)) {
                ComputerClassFound = TRUE;
            }
        }

        if(!ComputerClassFound) {
            //
            // Special Case for the Internal Class "Computer"
            //
            if(!(pci = (PCLASSICON)MyMalloc(sizeof(CLASSICON)))) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }

            pci->ClassGuid = &GUID_DEVCLASS_COMPUTER;
            SelectObject(hMemImageDC, hbmMiniImage);
            hOldBrush = SelectObject(hMemImageDC, GetSysColorBrush(COLOR_WINDOW));
            PatBlt(hMemImageDC, 0, 0, cxMiniIcon, cyMiniIcon, PATCOPY);
            SelectObject(hMemImageDC, hOldBrush);

            SetupDiGetClassBitmapIndex((LPGUID)pci->ClassGuid, &MiniIconIndex);

            SetupDiDrawMiniIcon(hMemImageDC,
                                rc,
                                MiniIconIndex,
                                DMI_USERECT);

            SelectObject(hMemImageDC, hbmMiniMask);
            SetupDiDrawMiniIcon(hMemImageDC,
                                rc,
                                MiniIconIndex,
                                DMI_MASK | DMI_USERECT);

            //
            // Deselect the bitmap from our DC BEFORE calling ImageList
            // functions.
            //
            SelectObject(hMemImageDC, hbmOldImage);

            pci->MiniBitmapIndex = ImageList_Add(ImageList, hbmMiniImage, hbmMiniMask);

            if(pci->MiniBitmapIndex == (UINT)-1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                MyFree(pci);
                pci = NULL;
                leave;
            }

            //
            // Link it in.
            //
            pci->Next = ImageData->ClassIconList;
            ImageData->ClassIconList = pci;

            //
            // Reset pci to NULL so we won't try to free it later.
            //
            pci = NULL;
        }

        //
        // Add the Overlay ICONs.
        //
        for(iIcon = IDI_CLASSICON_OVERLAYFIRST;
            iIcon <= IDI_CLASSICON_OVERLAYLAST;
            iIcon++) {

            Err = GLE_FN_CALL(NULL,
                              hIcon = LoadIcon(MyDllModuleHandle,
                                               MAKEINTRESOURCE(iIcon))
                             );

            if(Err != NO_ERROR) {
                leave;
            }

            iIndex = ImageList_AddIcon(ImageList, hIcon);

            if(iIndex == -1) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }

            if(!ImageList_SetOverlayImage(ImageList, iIndex, iIcon - IDI_CLASSICON_OVERLAYFIRST + 1)) {
                Err = ERROR_INVALID_DATA;
                leave;
            }
        }

        //
        // If we get to this point, then we've successfully constructed the entire
        // image list, and associated CLASSICON nodes.  Now, store this information
        // in the caller's SP_CLASSIMAGELIST_DATA buffer.
        //
        ClassImageListData->Reserved  = (ULONG_PTR)ImageData;
        ClassImageListData->ImageList = ImageList;

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_USER_BUFFER, &Err);
    }

    if(hiLargeIcon) {
        DestroyIcon(hiLargeIcon);
    }
    if(hiSmallIcon) {
        DestroyIcon(hiSmallIcon);
    }
    if(pci) {
        MyFree(pci);
    }
    if(hDC) {
        ReleaseDC(HWND_DESKTOP, hDC);
    }
    if(hbmMiniImage) {
        DeleteObject(hbmMiniImage);
    }
    if(hbmMiniMask) {
        DeleteObject(hbmMiniMask);
    }
    if(hMemImageDC) {
        DeleteDC(hMemImageDC);
    }

    if(Err != NO_ERROR) {

        if(ImageData) {
            if(DestroyLock) {
                DestroySynchronizedAccess(&ImageData->Lock);
            }
            if(ImageData->ClassGuidList) {
                MyFree(ImageData->ClassGuidList);
            }
            while(ImageData->ClassIconList) {
                pci = ImageData->ClassIconList;
                ImageData->ClassIconList = pci->Next;
                MyFree(pci);
            }
            MyFree(ImageData);
        }

        if(ImageList) {
            ImageList_Destroy(ImageList);
        }
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiDestroyClassImageList(
    IN PSP_CLASSIMAGELIST_DATA ClassImageListData
    )
/*++

Routine Description:

    This routine destroys a class image list built by a call to
    SetupDiGetClassImageList.

Arguments:

    ClassImageListData - Supplies the address of a SP_CLASSIMAGELIST_DATA
        structure containing the class image list to be destroyed.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    DWORD Err = NO_ERROR;
    PCLASS_IMAGE_LIST ImageData = NULL;
    PCLASSICON pci;

    try {

        if(ClassImageListData->cbSize != sizeof(SP_CLASSIMAGELIST_DATA)) {
            Err = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        if (ClassImageListData->Reserved == 0x0) {
            Err = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        ImageData = (PCLASS_IMAGE_LIST)ClassImageListData->Reserved;

        if (!LockImageList(ImageData)) {
            Err = ERROR_CANT_LOAD_CLASS_ICON;
            leave;
        }

        if (ClassImageListData->ImageList) {
            ImageList_Destroy(ClassImageListData->ImageList);
        }

        if (ImageData->ClassGuidList) {
            MyFree(ImageData->ClassGuidList);
        }

        while(ImageData->ClassIconList) {
            pci = ImageData->ClassIconList;
            ImageData->ClassIconList = pci->Next;
            MyFree(pci);
        }

        DestroySynchronizedAccess(&ImageData->Lock);
        MyFree(ImageData);
        ClassImageListData->Reserved = 0;

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_USER_BUFFER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiGetClassImageIndex(
    IN  PSP_CLASSIMAGELIST_DATA  ClassImageListData,
    IN  CONST GUID              *ClassGuid,
    OUT PINT                     ImageIndex
    )
/*++

Routine Description:

    This routine retrieves the index within the class image list of a specified
    class.

Arguments:

    ClassImageListData - Supplies the address of a SP_CLASSIMAGELIST_DATA
        structure containing the specified class's image.

    ClassGuid - Supplies the address of the GUID for the class whose index is
        to be retrieved.

    ImageIndex - Supplies the address of a variable that receives the index of
        the specified class's image within the class image list.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    DWORD Err = NO_ERROR;
    BOOL  bFound = FALSE, bLocked = FALSE;
    PCLASS_IMAGE_LIST ImageData = NULL;
    PCLASSICON pci;

    try {

        if(ClassImageListData->cbSize != sizeof(SP_CLASSIMAGELIST_DATA)) {
            Err = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        if(ClassImageListData->Reserved == 0x0) {
            Err = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        ImageData = (PCLASS_IMAGE_LIST)ClassImageListData->Reserved;

        if(!LockImageList(ImageData)) {
            Err = ERROR_CANT_LOAD_CLASS_ICON;
            leave;
        }
        bLocked = TRUE;

        if(ClassGuid) {
            //
            // check the "new stuff" list to see if it's there
            //
            for(pci = ImageData->ClassIconList;
                !bFound && pci;
                pci = pci->Next) {

                if(IsEqualGUID(pci->ClassGuid, ClassGuid)) {
                    *ImageIndex = pci->MiniBitmapIndex;
                    bFound = TRUE;
                }
            }
        }

        //
        // if no match was found, snag the "unknown" class
        //
        if(!bFound) {
            *ImageIndex = ImageData->UnknownImageIndex;
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_USER_BUFFER, &Err);
    }

    if(bLocked) {
        UnlockImageList(ImageData);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devinst.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devinst.c

Abstract:

    Device Installer routines.

Author:

    Lonny McMichael (lonnym) 1-Aug-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


//
// Private prototypes.
//
DWORD
pSetupDiGetCoInstallerList(
    IN     HDEVINFO                 DeviceInfoSet,     OPTIONAL
    IN     PSP_DEVINFO_DATA         DeviceInfoData,    OPTIONAL
    IN     CONST GUID              *ClassGuid,         OPTIONAL
    IN OUT PDEVINSTALL_PARAM_BLOCK  InstallParamBlock,
    IN OUT PVERIFY_CONTEXT          VerifyContext      OPTIONAL
    );


//
// Private logging data
// these must be mirrored from setupapi.h
//
static LPCTSTR pSetupDiDifStrings[] = {
    NULL, // no DIF code
    TEXT("DIF_SELECTDEVICE"),
    TEXT("DIF_INSTALLDEVICE"),
    TEXT("DIF_ASSIGNRESOURCES"),
    TEXT("DIF_PROPERTIES"),
    TEXT("DIF_REMOVE"),
    TEXT("DIF_FIRSTTIMESETUP"),
    TEXT("DIF_FOUNDDEVICE"),
    TEXT("DIF_SELECTCLASSDRIVERS"),
    TEXT("DIF_VALIDATECLASSDRIVERS"),
    TEXT("DIF_INSTALLCLASSDRIVERS"),
    TEXT("DIF_CALCDISKSPACE"),
    TEXT("DIF_DESTROYPRIVATEDATA"),
    TEXT("DIF_VALIDATEDRIVER"),
    TEXT("DIF_MOVEDEVICE"),  // obsolete
    TEXT("DIF_DETECT"),
    TEXT("DIF_INSTALLWIZARD"),
    TEXT("DIF_DESTROYWIZARDDATA"),
    TEXT("DIF_PROPERTYCHANGE"),
    TEXT("DIF_ENABLECLASS"),
    TEXT("DIF_DETECTVERIFY"),
    TEXT("DIF_INSTALLDEVICEFILES"),
    TEXT("DIF_UNREMOVE"),
    TEXT("DIF_SELECTBESTCOMPATDRV"),
    TEXT("DIF_ALLOW_INSTALL"),
    TEXT("DIF_REGISTERDEVICE"),
    TEXT("DIF_NEWDEVICEWIZARD_PRESELECT"),
    TEXT("DIF_NEWDEVICEWIZARD_SELECT"),
    TEXT("DIF_NEWDEVICEWIZARD_PREANALYZE"),
    TEXT("DIF_NEWDEVICEWIZARD_POSTANALYZE"),
    TEXT("DIF_NEWDEVICEWIZARD_FINISHINSTALL"),
    TEXT("DIF_UNUSED1"),
    TEXT("DIF_INSTALLINTERFACES"),
    TEXT("DIF_DETECTCANCEL"),
    TEXT("DIF_REGISTER_COINSTALLERS"),
    TEXT("DIF_ADDPROPERTYPAGE_ADVANCED"),
    TEXT("DIF_ADDPROPERTYPAGE_BASIC"),
    TEXT("DIF_RESERVED1"),  // aka, DIF_GETWINDOWSUPDATEINFO
    TEXT("DIF_TROUBLESHOOTER"),
    TEXT("DIF_POWERMESSAGEWAKE"),
    TEXT("DIF_ADDREMOTEPROPERTYPAGE_ADVANCED"),
    TEXT("DIF_UPDATEDRIVER_UI"),
    TEXT("DIF_RESERVED2")   // aka, DIF_INTERFACE_TO_DEVICE
    //
    // append new DIF codes here (don't forget comma's)
    //
};

DWORD FilterLevelOnInstallerError(
    IN DWORD PrevLevel,
    IN DWORD Err)
/*++

Routine Description:

    Allow downgrading of error level depending on returned error
    from class/co/default installer
    and current state

Arguments:

    PrevLevel - initial level
    Err       - error to check

Return Value:

    New level

--*/
{
    DWORD Level = PrevLevel;
    if(Level == DRIVER_LOG_ERROR) {
        switch(Err) {
            case ERROR_DUPLICATE_FOUND:
                //
                // not an error as such
                //
                Level = DRIVER_LOG_WARNING;
                break;

            case ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION:
                //
                // if returned during gui-setup
                // or during server-side setup
                // demote error to warning
                //
                if(GuiSetupInProgress ||
                              (GlobalSetupFlags & PSPGF_NONINTERACTIVE)) {

                    Level = DRIVER_LOG_WARNING;
                }
                break;
        }
    }
    return Level;
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDeviceInstallParamsA(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS_A DeviceInstallParams
    )
{
    SP_DEVINSTALL_PARAMS_W deviceInstallParams;
    DWORD rc;

    try {

        deviceInstallParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS_W);

        rc = GLE_FN_CALL(FALSE,
                         SetupDiGetDeviceInstallParamsW(DeviceInfoSet,
                                                        DeviceInfoData,
                                                        &deviceInstallParams)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        rc = pSetupDiDevInstParamsUnicodeToAnsi(&deviceInstallParams,
                                                DeviceInstallParams
                                               );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}


BOOL
WINAPI
SetupDiGetDeviceInstallParams(
    IN  HDEVINFO              DeviceInfoSet,
    IN  PSP_DEVINFO_DATA      DeviceInfoData,          OPTIONAL
    OUT PSP_DEVINSTALL_PARAMS DeviceInstallParams
    )
/*++

Routine Description:

    This routine retrieves installation parameters for a device information set
    (globally), or a particular device information element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        installation parameters to be retrieved.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure containing installation parameters to be retrieved.  If this
        parameter is not specified, then the installation parameters retrieved
        will be associated with the device information set itself (for the
        global class driver list).

    DeviceInstallParams - Supplies the address of a SP_DEVINSTALL_PARAMS
        structure that will receive the installation parameters.  The cbSize
        field of this structure must be set to the size, in bytes, of a
        SP_DEVINSTALL_PARAMS structure before calling this API.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    try {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        if(DeviceInfoData) {
            //
            // Then we are to retrieve installation parameters for a particular
            // device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
            } else {
                Err = GetDevInstallParams(pDeviceInfoSet,
                                          &(DevInfoElem->InstallParamBlock),
                                          DeviceInstallParams
                                         );
            }

        } else {
            //
            // Retrieve installation parameters for the global class driver list.
            //
            Err = GetDevInstallParams(pDeviceInfoSet,
                                      &(pDeviceInfoSet->InstallParamBlock),
                                      DeviceInstallParams
                                     );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetClassInstallParamsA(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK InstallParamBlock;
    DI_FUNCTION Function;
    DWORD Err;

    try {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        Err = NO_ERROR; // assume success

        if(DeviceInfoData) {
            //
            // Then we are to retrieve installation parameters for a particular
            // device.
            //
            if(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,DeviceInfoData,NULL)) {
                InstallParamBlock = &DevInfoElem->InstallParamBlock;
            } else {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }
        } else {
            //
            // Retrieve installation parameters for the global class driver
            // list.
            //
            InstallParamBlock = &pDeviceInfoSet->InstallParamBlock;
        }

        //
        // While we're in a try/except, go ahead and do some preliminary
        // validation on the caller-supplied buffer...
        //
        if(ClassInstallParams) {

            if((ClassInstallParamsSize < sizeof(SP_CLASSINSTALL_HEADER)) ||
               (ClassInstallParams->cbSize != sizeof(SP_CLASSINSTALL_HEADER))) {

                Err = ERROR_INVALID_USER_BUFFER;
                leave;
            }

        } else if(ClassInstallParamsSize) {
            Err = ERROR_INVALID_USER_BUFFER;
            leave;
        }

        MYASSERT(InstallParamBlock);

        if(InstallParamBlock->ClassInstallHeader) {
            Function = InstallParamBlock->ClassInstallHeader->InstallFunction;
        } else {
            Err = ERROR_NO_CLASSINSTALL_PARAMS;
            leave;
        }

        //
        // For DIF_SELECTDEVICE we need special processing since the structure
        // that goes with it is ansi/unicode specific.
        //
        if(Function == DIF_SELECTDEVICE) {

            SP_SELECTDEVICE_PARAMS_W SelectDeviceParams;

            SelectDeviceParams.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);

            Err = GLE_FN_CALL(FALSE,
                              SetupDiGetClassInstallParamsW(
                                  DeviceInfoSet,
                                  DeviceInfoData,
                                  (PSP_CLASSINSTALL_HEADER)&SelectDeviceParams,
                                  sizeof(SP_SELECTDEVICE_PARAMS_W),
                                  NULL)
                             );

            if(Err == NO_ERROR) {
                //
                // We successfully retrieved the Unicode form of the Select
                // Device parameters.  Store the required size for the ANSI
                // version in the output parameter (if requested).
                //
                if(RequiredSize) {
                    *RequiredSize = sizeof(SP_SELECTDEVICE_PARAMS_A);
                }

                if(ClassInstallParamsSize < sizeof(SP_SELECTDEVICE_PARAMS_A)) {
                    Err = ERROR_INSUFFICIENT_BUFFER;
                } else {
                    Err = pSetupDiSelDevParamsUnicodeToAnsi(
                              &SelectDeviceParams,
                              (PSP_SELECTDEVICE_PARAMS_A)ClassInstallParams
                              );
                }
            }

        } else {

            Err = GLE_FN_CALL(FALSE,
                              SetupDiGetClassInstallParamsW(
                                  DeviceInfoSet,
                                  DeviceInfoData,
                                  ClassInstallParams,
                                  ClassInstallParamsSize,
                                  RequiredSize)
                             );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiGetClassInstallParams(
    IN  HDEVINFO                DeviceInfoSet,
    IN  PSP_DEVINFO_DATA        DeviceInfoData,         OPTIONAL
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams,     OPTIONAL
    IN  DWORD                   ClassInstallParamsSize,
    OUT PDWORD                  RequiredSize            OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves class installer parameters for a device information
    set (globally), or a particular device information element.  These
    parameters are specific to a particular device installer function code
    (DI_FUNCTION) that will be stored in the ClassInstallHeader field located
    at the beginning of the parameter buffer.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        class installer parameters to be retrieved.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure containing class installer parameters to be retrieved.  If
        this parameter is not specified, then the class installer parameters
        retrieved will be associated with the device information set itself
        (for the global class driver list).

    ClassInstallParams - Optionally, supplies the address of a buffer
        containing a class install header structure.  This structure must have
        its cbSize field set to sizeof(SP_CLASSINSTALL_HEADER) on input, or the
        buffer is considered to be invalid.  On output, the InstallFunction
        field will be filled in with the DI_FUNCTION code for the class install
        parameters being retrieved, and if the buffer is large enough, it will
        receive the class installer parameters structure specific to that
        function code.

        If this parameter is not specified, then ClassInstallParamsSize must be
        zero.  This would be done if the caller simply wants to determine how
        large a buffer is required.

    ClassInstallParamsSize - Supplies the size, in bytes, of the
        ClassInstallParams buffer, or zero, if ClassInstallParams is not
        supplied.  If the buffer is supplied, it must be _at least_ as large as
        sizeof(SP_CLASSINSTALL_HEADER).

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of bytes required to store the class installer parameters.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    try {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        if(DeviceInfoData) {
            //
            // Then we are to retrieve installation parameters for a particular
            // device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
            } else {
                Err = GetClassInstallParams(&(DevInfoElem->InstallParamBlock),
                                            ClassInstallParams,
                                            ClassInstallParamsSize,
                                            RequiredSize
                                           );
            }
        } else {
            //
            // Retrieve installation parameters for the global class driver
            // list.
            //
            Err = GetClassInstallParams(&(pDeviceInfoSet->InstallParamBlock),
                                        ClassInstallParams,
                                        ClassInstallParamsSize,
                                        RequiredSize
                                       );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
_SetupDiSetDeviceInstallParams(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS DeviceInstallParams,
    IN BOOL                  MsgHandlerIsNativeCharWidth
    )
{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    try {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        if(DeviceInfoData) {
            //
            // Then we are to set installation parameters for a particular
            // device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
            } else {
                Err = SetDevInstallParams(pDeviceInfoSet,
                                          DeviceInstallParams,
                                          &(DevInfoElem->InstallParamBlock),
                                          MsgHandlerIsNativeCharWidth
                                         );
            }

        } else {
            //
            // Set installation parameters for the global class driver list.
            //
            Err = SetDevInstallParams(pDeviceInfoSet,
                                      DeviceInstallParams,
                                      &(pDeviceInfoSet->InstallParamBlock),
                                      MsgHandlerIsNativeCharWidth
                                     );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    return Err;
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiSetDeviceInstallParamsA(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS_A DeviceInstallParams
    )
{
    DWORD Err;
    SP_DEVINSTALL_PARAMS_W UnicodeDeviceInstallParams;

    try {

        Err = pSetupDiDevInstParamsAnsiToUnicode(DeviceInstallParams,
                                                 &UnicodeDeviceInstallParams
                                                );
        if(Err != NO_ERROR) {
            leave;
        }

        Err = _SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                             DeviceInfoData,
                                             &UnicodeDeviceInstallParams,
                                             FALSE
                                            );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiSetDeviceInstallParams(
    IN HDEVINFO              DeviceInfoSet,
    IN PSP_DEVINFO_DATA      DeviceInfoData,     OPTIONAL
    IN PSP_DEVINSTALL_PARAMS DeviceInstallParams
    )
/*++

Routine Description:

    This routine sets installation parameters for a device information set
    (globally), or a particular device information element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        installation parameters to be set.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure containing installation parameters to be set.  If this
        parameter is not specified, then the installation parameters set
        will be associated with the device information set itself (for the
        global class driver list).

    DeviceInstallParams - Supplies the address of a SP_DEVINSTALL_PARAMS
        structure containing the new values of the parameters.  The cbSize
        field of this structure must be set to the size, in bytes, of the
        structure before calling this API.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    All parameters will be validated before any changes are made, so a return
    status of FALSE indicates that no parameters were modified.

--*/

{
    DWORD Err;

    try {

        Err = _SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                             DeviceInfoData,
                                             DeviceInstallParams,
                                             TRUE
                                            );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiSetClassInstallParamsA(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    )
{
    DWORD Err;
    DI_FUNCTION Function;
    SP_SELECTDEVICE_PARAMS_W SelectParams;

    try {

        if(!ClassInstallParams) {
            //
            // Just pass it on to the unicode version since there's no thunking
            // to do. Note that the size must be 0.
            //
            if(ClassInstallParamsSize) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }

            Err = GLE_FN_CALL(FALSE,
                              SetupDiSetClassInstallParamsW(
                                  DeviceInfoSet,
                                  DeviceInfoData,
                                  ClassInstallParams,
                                  ClassInstallParamsSize)
                             );

        } else {

            if(ClassInstallParams->cbSize == sizeof(SP_CLASSINSTALL_HEADER)) {
                Function = ClassInstallParams->InstallFunction;
            } else {
                //
                // Structure is invalid.
                //
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }

            //
            // DIF_SELECTDEVICE is a special case since it has a structure that
            // needs to be translated from ansi to unicode.
            //
            // DIF_INTERFACE_TO_DEVICE has unicode structure but ansi not
            // supported (yet) - internal
            //
            // Others can just be passed on to the unicode version with no
            // changes to the parameters.
            //
            if(Function == DIF_SELECTDEVICE) {

                if(ClassInstallParamsSize >= sizeof(SP_SELECTDEVICE_PARAMS_A)) {

                    Err = pSetupDiSelDevParamsAnsiToUnicode(
                            (PSP_SELECTDEVICE_PARAMS_A)ClassInstallParams,
                            &SelectParams
                            );

                    if(Err != NO_ERROR) {
                        leave;
                    }

                    Err = GLE_FN_CALL(FALSE,
                                      SetupDiSetClassInstallParamsW(
                                          DeviceInfoSet,
                                          DeviceInfoData,
                                          (PSP_CLASSINSTALL_HEADER)&SelectParams,
                                          sizeof(SP_SELECTDEVICE_PARAMS_W))
                                     );
                } else {
                    Err = ERROR_INVALID_PARAMETER;
                    leave;
                }

            } else if(Function == DIF_INTERFACE_TO_DEVICE) {

                Err = ERROR_INVALID_PARAMETER;
                leave;

            } else {

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiSetClassInstallParamsW(
                                      DeviceInfoSet,
                                      DeviceInfoData,
                                      ClassInstallParams,
                                      ClassInstallParamsSize)
                                 );
            }
        }

        //
        // If we get to here, then we have called
        // SetupDiSetClassInstallParamsW, although the result (stored in Err)
        // may be success or failure.
        //

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiSetClassInstallParams(
    IN HDEVINFO                DeviceInfoSet,
    IN PSP_DEVINFO_DATA        DeviceInfoData,        OPTIONAL
    IN PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN DWORD                   ClassInstallParamsSize
    )
/*++

Routine Description:

    This routine sets (or clears) class installer parameters for a device
    information set (globally), or a particular device information element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        class installer parameters to be set.

    DeviceInfoData - Optionally, supplies the address of a SP_DEVINFO_DATA
        structure containing class installer parameters to be set.  If this
        parameter is not specified, then the class installer parameters to be
        set will be associated with the device information set itself (for the
        global class driver list).

    ClassInstallParams - Optionally, supplies the address of a buffer
        containing the class installer parameters to be used.    The
        SP_CLASSINSTALL_HEADER structure at the beginning of the buffer must
        have its cbSize field set to be sizeof(SP_CLASSINSTALL_HEADER), and the
        InstallFunction field must be set to the DI_FUNCTION code reflecting
        the type of parameters supplied in the rest of the buffer.

        If this parameter is not supplied, then the current class installer
        parameters (if any) will be cleared for the specified device
        information set or element.

        FUTURE-2002/06/17-lonnym -- Clearing class install params should be targeted
        ** Presently, we blindly clear _any_ class install params that have **
        ** been set, irrespective of their DIF code association.  There     **
        ** needs to be a way to clear class install params _only_ if the    **
        ** params are associated with a specified DIF code.                 **

    ClassInstallParamsSize - Supplies the size, in bytes, of the
        ClassInstallParams buffer.  If the buffer is not supplied (i.e., the
        class installer parameters are to be cleared), then this value must be
        zero.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    All parameters will be validated before any changes are made, so a return
    status of FALSE indicates that no parameters were modified.

    A side effect of setting class installer parameters is that the
    DI_CLASSINSTALLPARAMS flag is set.  If for some reason, it is desired to
    set the parameters, but disable their use, then this flag must be cleared
    via SetupDiSetDeviceInstallParams.

    If the class installer parameters are cleared, then the
    DI_CLASSINSTALLPARAMS flag is reset.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet = NULL;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;

    try {

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
            Err = ERROR_INVALID_HANDLE;
            leave;
        }

        if(DeviceInfoData) {
            //
            // Then we are to set class installer parameters for a particular device.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
            } else {
                Err = SetClassInstallParams(pDeviceInfoSet,
                                            ClassInstallParams,
                                            ClassInstallParamsSize,
                                            &(DevInfoElem->InstallParamBlock)
                                           );
            }

        } else {
            //
            // Set class installer parameters for the global class driver list.
            //
            Err = SetClassInstallParams(pDeviceInfoSet,
                                        ClassInstallParams,
                                        ClassInstallParamsSize,
                                        &(pDeviceInfoSet->InstallParamBlock)
                                       );
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiCallClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This routine calls the appropriate class installer with the specified
    installer function.

    Before calling the class installer, this routine will call any registered
    co-device installers (registration is either per-class or per-device;
    per-class installers are called first).  Any co-installer wishing to be
    called back once the class installer has finished installation may return
    ERROR_DI_POSTPROCESSING_REQUIRED.  Returning NO_ERROR will also allow
    installation to continue, but without a post-processing callback.
    Returning any other error code will cause the install action to be aborted
    (any co-installers already called that have requested post-processing will
    be called back, with InstallResult indicating the cause of failure).

    After the class installer has performed the installation (or we've done the
    default if ERROR_DI_DO_DEFAULT is returned), then we'll call any co-
    installers who have requested postprocessing.  The list of co-installers is
    treated like a stack, so the co-installers called last 'on the way in' are
    called first 'on the way out'.

Arguments:

    InstallFunction - Class installer function to call.  This can be one
        of the following values, or any other (class-specific) value:

        DIF_SELECTDEVICE - Select a driver to be installed.
        DIF_INSTALLDEVICE - Install the driver for the device.  (DeviceInfoData
            must be specified.)
        DIF_ASSIGNRESOURCES - ** PRESENTLY UNUSED ON WINDOWS NT **
        DIF_PROPERTIES - Display a properties dialog for the device.
            (DeviceInfoData must be specified.)
        DIF_REMOVE - Remove the device.  (DeviceInfoData must be specified.)
        DIF_FIRSTTIMESETUP - Perform first time setup initialization.  This
            is used only for the global class information associated with
            the device information set (i.e., DeviceInfoData not specified).
        DIF_FOUNDDEVICE - ** UNUSED ON WINDOWS NT **
        DIF_SELECTCLASSDRIVERS - Select drivers for all devices of the class
            associated with the device information set or element.
        DIF_VALIDATECLASSDRIVERS - Ensure all devices of the class associated
            with the device information set or element are ready to be
            installed.
        DIF_INSTALLCLASSDRIVERS - Install drivers for all devices of the
            class associated with the device information set or element.
        DIF_CALCDISKSPACE - Compute the amount of disk space required by
            drivers.
        DIF_DESTROYPRIVATEDATA - Destroy any private date referenced by
            the ClassInstallReserved installation parameter for the specified
            device information set or element.
        DIF_VALIDATEDRIVER - ** UNUSED ON WINDOWS NT **
        DIF_MOVEDEVICE - ** OBSOLETE **
        DIF_DETECT - Detect any devices of class associated with the device
            information set.
        DIF_INSTALLWIZARD - Add any pages necessary to the New Device Wizard
            for the class associated with the device information set or
            element.
            ** OBSOLETE--use DIF_NEWDEVICEWIZARD method instead **
        DIF_DESTROYWIZARDDATA - Destroy any private data allocated due to
            a DIF_INSTALLWIZARD message.
            ** OBSOLETE--not needed for DIF_NEWDEVICEWIZARD method **
        DIF_PROPERTYCHANGE - The device's properties are changing. The device
            is being enabled, disabled, or has had a resource change.
            (DeviceInfoData must be specified.)
        DIF_ENABLECLASS - ** UNUSED ON WINDOWS NT **
        DIF_DETECTVERIFY - The class installer should verify any devices it
            previously detected.  Non verified devices should be removed.
        DIF_INSTALLDEVICEFILES - The class installer should only install the
            driver files for the selected device.  (DeviceInfoData must be
            specified.)
        DIF_UNREMOVE - Unremoves a device from the system.  (DeviceInfoData
            mustbe specified.)
        DIF_SELECTBESTCOMPATDRV - Select the best driver from the device
            information element's compatible driver list.  (DeviceInfoData must
            be specified.)
        DIF_ALLOW_INSTALL - Determine whether or not the selected driver should
            be installed for the device.  (DeviceInfoData must be specified.)
        DIF_REGISTERDEVICE - The class installer should register the new,
            manually-installed, device information element (via
            SetupDiRegisterDeviceInfo) including, potentially, doing duplicate
            detection via the SPRDI_FIND_DUPS flag.  (DeviceInfoData must be
            specified.)
        DIF_NEWDEVICEWIZARD_PRESELECT - Allows class-/co-installers to supply
            wizard pages to be displayed before the Select Device page during
            "Add New Hardware" wizard.
        DIF_NEWDEVICEWIZARD_SELECT - Allows class-/co-installers to supply
            wizard pages to replace the default Select Device wizard page, as
            retrieved by SetupDiGetWizardPage(...SPWPT_SELECTDEVICE...)
        DIF_NEWDEVICEWIZARD_PREANALYZE - Allows class-/co-installers to supply
            wizard pages to be displayed before the analyze page.
        DIF_NEWDEVICEWIZARD_POSTANALYZE - Allows class-/co-installers to supply
            wizard pages to be displayed after the analyze page.
        DIF_NEWDEVICEWIZARD_FINISHINSTALL - Allows class-/co-installers
            (including device-specific co-installers) to supply wizard pages to
            be displayed after installation of the device has been performed
            (i.e., after DIF_INSTALLDEVICE has been processed), but prior to
            the wizard's finish page.  This message is sent not only for the
            "Add New Hardware" wizard, but also for the autodetection and "New
            Hardware Found" scenarios as well.
        DIF_UNUSED1 - ** PRESENTLY UNUSED ON WINDOWS NT **
        DIF_INSTALLINTERFACES - The class installer should create (and/or,
            potentially remove) device interfaces for this device information
            element.
        DIF_DETECTCANCEL - After the detection is stopped, if the class
            installer was invoked for DIF_DETECT, then it is invoked for
            DIF_DETECTCANCEL. This gives the class installer a chance to clean
            up anything it did during DIF_DETECT such as drivers setup to do
            detection at reboot, and private data. It is passed the same
            HDEVINFO as it was for DIF_DETECT.
        DIF_REGISTER_COINSTALLERS - Register device-specific co-installers so
            that they can be involved in the rest of the installation.
            (DeviceInfoData must be specified.)
        DIF_ADDPROPERTYPAGE_ADVANCED - Allows class-/co-installers to supply
            advanced property pages for a device.
        DIF_ADDPROPERTYPAGE_BASIC - Allows class-/co-installers to supply
            basic property pages for a device.
        DIF_TROUBLESHOOTER - Allows class-/co-installers to launch a
            troubleshooter for this device or to return CHM and HTM
            troubleshooter files that will get launched with a call to the
            HtmlHelp() API. If the class-/co-installer launches its own
            troubleshooter then it should return NO_ERROR, it should return
            ERROR_DI_DO_DEFAULT regardless of if it sets the CHM and HTM
            values.
        DIF_POWERMESSAGEWAKE - Allows class-/co-installers to specify text that
            will be displayed on the power tab in device manager. The class-/
            co-installer should return NO_ERROR if it specifies any text and
            ERROR_DI_DO_DEFAULT otherwise.
        DIF_ADDREMOTEPROPERTYPAGE_ADVANCED - Allows class-/co-installers to
            supply advanced proerty pages for a device that is on a remote
            machine.
        DIF_UPDATEDRIVER_UI - Allows a class-/co-installer to display their own
            UI when the user presses the update driver button in device
            manager.  The only real reason to do this is when the default
            update driver behavior could cause the device and/or machine not to
            work. We don't want IHVs providing their own UI for random reasons.
        DIF_INTERFACE_TO_DEVICE - For SWENUM device co-installers, get device
            for interface if it's different. Return NO_ERROR if handled
            ERROR_DI_DO_DEFAULT otherwise.

        (Note: remember to add new DIF_xxxx to pSetupDiDifStrings at start of
        file)

    DeviceInfoSet - Supplies a handle to the device information set to
        perform installation for.

    DeviceInfoData - Optionally, specifies a particular device information
        element whose class installer is to be called.  If this parameter
        is not specified, then the class installer for the device information
        set itself will be called (if the set has an associated class).

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This function will attempt to load and call the class installer and co-
    installers (if any) for the class associated with the device information
    element or set specified.  If there is no class installer, or the class
    installer returns ERR_DI_DO_DEFAULT, then this function will call a default
    procedure for the specified class installer function.

--*/

{
    DWORD Err;

    try {

        Err = _SetupDiCallClassInstaller(
                  InstallFunction,
                  DeviceInfoSet,
                  DeviceInfoData,
                  CALLCI_LOAD_HELPERS | CALLCI_CALL_HELPERS
                  );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
_SetupDiCallClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,      OPTIONAL
    IN DWORD            Flags
    )
/*++

Routine Description:

    Worker routine for SetupDiCallClassInstaller that allows the caller to
    control what actions are taken when handling this install request.  In
    addition to the first three parameters (refer to the documentation for
    SetupDiCallClassInstaller for details), the following flags may be
    specified in the Flags parameter:

    CALLCI_LOAD_HELPERS - If helper modules (class installer, co-installers)
        haven't been loaded, load them so they can participate in handling
        this install request.

    CALLCI_CALL_HELPERS - Call the class installer/co-installers to give them
        a chance to handle this install request.  If this flag is not
        specified, then only the default action will be taken.

    CALLCI_ALLOW_DRVSIGN_UI - If an unsigned class installer or co-installer is
        encountered, perform standard non-driver signing behavior.  (WHQL
        doesn't have a certification program for class-/co-installers!)

        NTRAID#NTBUG9-166000-2000/08/18-JamieHun -- Driver signing policy for class installers?
        (lonnym): We should probably employ driver signing policy
        (instead of non-driver signing policy) for class installers of
        WHQL-approved classes.  However, the user experience here is
        problematic (e.g., driver signing popup trying to uninstall an unsigned
        driver package).

Return Values:

    If this function succeeds, the return value is NO_ERROR.  Otherwise, it is
    a Win32 error code indicating the cause of failure.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    BOOL MustAbort;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDEVINSTALL_PARAM_BLOCK InstallParamBlock;
    HKEY hk;
    CONST GUID *ClassGuid;
    BOOL bRestoreDiQuietInstall;
    BOOL MuteError;
    PCOINSTALLER_INTERNAL_CONTEXT CoInstallerInternalContext;
    LONG i, CoInstallerCount;
    HWND hwndParent;
    TCHAR DescBuffer[LINE_LEN];
    PTSTR DeviceDesc;
    PSETUP_LOG_CONTEXT LogContext;
    DWORD slot_dif_code;
    BOOL ChangedThreadLogContext;
    PSETUP_LOG_CONTEXT SavedLogContext;
    DWORD LastErr;
    DWORD ErrorLevel;
    SPFUSIONINSTANCE spFusionInstance;
    VERIFY_CONTEXT VerifyContext;
    DWORD slot;
    CLASS_INSTALL_PROC ClassInstallerEntryPoint;
    HANDLE ClassInstallerFusionContext;
    BOOL UnlockDevInfoElem, UnlockDevInfoSet;

    ASSERT_HEAP_IS_VALID();

    //
    // DIF codes must be non-zero...
    //
    if(!InstallFunction) {
        return ERROR_INVALID_PARAMETER;
    }

#ifdef _X86_
    if(IsWow64) {
        //
        // This API not allowed in Wow64, class/co installers must/will be
        // native
        //
        return ERROR_IN_WOW64;
    }
#endif

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // Initialize some variables before entering the try/except block...
    //
    Err = ERROR_DI_DO_DEFAULT;
    CoInstallerInternalContext = NULL;
    i = 0;
    CoInstallerCount = -1;      // value indicating count hasn't been retrieved
    hk = INVALID_HANDLE_VALUE;
    slot = 0;
    bRestoreDiQuietInstall = FALSE;
    MuteError = FALSE;
    slot_dif_code = 0;
    ChangedThreadLogContext = FALSE;
    SavedLogContext = NULL;
    ErrorLevel = DRIVER_LOG_ERROR;
    UnlockDevInfoElem = UnlockDevInfoSet = FALSE;
    ZeroMemory(&VerifyContext, sizeof(VerifyContext));

    try {

        if(DeviceInfoData) {
            //
            // Then we are to call the class installer for a particular device.
            //
            DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                    DeviceInfoData,
                                                    NULL
                                                   );
            if(!DevInfoElem) {
                Err = ERROR_INVALID_PARAMETER;
                leave;
            }

            InstallParamBlock = &(DevInfoElem->InstallParamBlock);
            ClassGuid = &(DevInfoElem->ClassGuid);

            //
            // If the device information element isn't already locked, do so
            // now.  That will prevent it from being yanked out from under us
            // when calling a class-/co-installer.
            //
            if(!(DevInfoElem->DiElemFlags & DIE_IS_LOCKED)) {
                DevInfoElem->DiElemFlags |= DIE_IS_LOCKED;
                UnlockDevInfoElem = TRUE;
            }

        } else {

            DevInfoElem = NULL;
            InstallParamBlock = &(pDeviceInfoSet->InstallParamBlock);
            ClassGuid = pDeviceInfoSet->HasClassGuid
                          ? &(pDeviceInfoSet->ClassGuid)
                          : NULL;

            //
            // We don't have a device information element to lock, so we'll
            // lock the set itself...
            //
            if(!(pDeviceInfoSet->DiSetFlags & DISET_IS_LOCKED)) {
                pDeviceInfoSet->DiSetFlags |= DISET_IS_LOCKED;
                UnlockDevInfoSet = TRUE;
            }
        }

        //
        // Set the local log context before it gets used.
        //
        LogContext = InstallParamBlock->LogContext;

        //
        // If we are processing DIF_ALLOW_INSTALL then we need to make sure
        // that the DI_QUIETINSTALL flag is only set if we are doing a non-
        // interactive (server-side) install or we are in GUI mode setup.  In
        // any other case we need to remove the DI_QUIETINSTALL flag otherwise
        // class installers might think they can't display any UI and fail the
        // DIF_ALLOW_INSTALL.
        //
        if((InstallFunction == DIF_ALLOW_INSTALL) &&
           (InstallParamBlock->Flags & DI_QUIETINSTALL) &&
           !(InstallParamBlock->FlagsEx & DI_FLAGSEX_IN_SYSTEM_SETUP) &&
           !(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP))) {

            InstallParamBlock->Flags &= ~DI_QUIETINSTALL;
            bRestoreDiQuietInstall = TRUE;
        }

        if(Flags & CALLCI_LOAD_HELPERS) {
            //
            // Retrieve the parent window handle, as we may need it below if we
            // need to popup UI due to unsigned class-/co-installers.
            //
            if(hwndParent = InstallParamBlock->hwndParent) {
               if(!IsWindow(hwndParent)) {
                    hwndParent = NULL;
               }
            }

            //
            // Retrieve a device description to use in case we need to give a
            // driver signing warn/block popup.
            //
            if(GetBestDeviceDesc(DeviceInfoSet, DeviceInfoData, DescBuffer)) {
                DeviceDesc = DescBuffer;
            } else {
                DeviceDesc = NULL;
            }

            //
            // If the class installer has not been loaded, then load it and
            // get the function address for the ClassInstall function.
            //
            if(!InstallParamBlock->hinstClassInstaller) {

                if(ClassGuid &&
                   (hk = SetupDiOpenClassRegKey(ClassGuid, KEY_READ)) != INVALID_HANDLE_VALUE) {

                    slot = AllocLogInfoSlot(LogContext, FALSE);

                    WriteLogEntry(LogContext,
                                  slot,
                                  MSG_LOG_CI_MODULE,
                                  NULL,
                                  DeviceDesc ? DeviceDesc : TEXT("")
                                 );

                    try {
                        Err = GetModuleEntryPoint(hk,
                                                  pszInstaller32,
                                                  pszCiDefaultProc,
                                                  &(InstallParamBlock->hinstClassInstaller),
                                                  &((FARPROC)InstallParamBlock->ClassInstallerEntryPoint),
                                                  &(InstallParamBlock->ClassInstallerFusionContext),
                                                  &MustAbort,
                                                  LogContext,
                                                  hwndParent,
                                                  ClassGuid,
                                                  SetupapiVerifyClassInstProblem,
                                                  DeviceDesc,
                                                  DRIVERSIGN_NONE,
                                                  TRUE,
                                                  &VerifyContext
                                                 );

                    } except(pSetupExceptionFilter(GetExceptionCode())) {

                        pSetupExceptionHandler(GetExceptionCode(),
                                               ERROR_INVALID_CLASS_INSTALLER,
                                               &Err
                                              );

                        InstallParamBlock->ClassInstallerEntryPoint = NULL;

                    }

                    if(slot) {
                        ReleaseLogInfoSlot(LogContext, slot);
                        slot = 0;
                    }

                    RegCloseKey(hk);
                    hk = INVALID_HANDLE_VALUE;

                    if((Err != NO_ERROR) && (Err != ERROR_DI_DO_DEFAULT)) {

                        if(!(InstallParamBlock->FlagsEx & DI_FLAGSEX_CI_FAILED)) {

                            TCHAR ClassName[MAX_GUID_STRING_LEN];
                            TCHAR Title[MAX_TITLE_LEN];

                            if(!SetupDiClassNameFromGuid(ClassGuid,
                                                         ClassName,
                                                         SIZECHARS(ClassName),
                                                         NULL)) {
                                //
                                // Use the ClassName buffer to hold the class
                                // GUID string (it's better than nothin')
                                //
                                pSetupStringFromGuid(ClassGuid,
                                                     ClassName,
                                                     SIZECHARS(ClassName)
                                                    );
                            }

                            //
                            // Write out an event log entry about this.
                            //
                            WriteLogEntry(LogContext,
                                          DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                                          MSG_CI_LOADFAIL_ERROR,
                                          NULL,
                                          ClassName
                                         );

                            WriteLogError(LogContext, DRIVER_LOG_ERROR, Err);

                            MuteError = TRUE;

                            if(!(GlobalSetupFlags &
                                 (PSPGF_NONINTERACTIVE | PSPGF_UNATTENDED_SETUP))) {

                                if(!LoadString(MyDllModuleHandle,
                                               IDS_DEVICEINSTALLER,
                                               Title,
                                               SIZECHARS(Title))) {
                                    *Title = TEXT('\0');
                                }
                                FormatMessageBox(MyDllModuleHandle,
                                                 InstallParamBlock->hwndParent,
                                                 MSG_CI_LOADFAIL_ERROR,
                                                 Title,
                                                 MB_OK,
                                                 ClassName
                                                );
                            }

                            InstallParamBlock->FlagsEx |= DI_FLAGSEX_CI_FAILED;
                        }

                        Err = ERROR_INVALID_CLASS_INSTALLER;
                        leave;
                    }
                }
            }

            //
            // If we haven't retrieved a list of co-installers to call,
            // retrieve the list now.
            //
            if(InstallParamBlock->CoInstallerCount == -1) {

                slot = AllocLogInfoSlot(LogContext, FALSE);

                WriteLogEntry(LogContext,
                              slot,
                              MSG_LOG_COINST_MODULE,
                              NULL,
                              DeviceDesc
                             );

                Err = pSetupDiGetCoInstallerList(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 ClassGuid,
                                                 InstallParamBlock,
                                                 &VerifyContext
                                                );

                if(slot) {
                    ReleaseLogInfoSlot(LogContext, slot);
                    slot = 0;
                }

                if(Err != NO_ERROR) {
                    leave;
                }

                MYASSERT(InstallParamBlock->CoInstallerCount >= 0);
            }
        }

        slot_dif_code = AllocLogInfoSlotOrLevel(LogContext,
                                                DRIVER_LOG_VERBOSE1,
                                                FALSE
                                               );

        if(slot_dif_code) {
            //
            // this is skipped if we know we would never log anything
            //
            // pass a string which we may log with an error or will log at
            // VERBOSE1 level
            //
            if(InstallFunction >= (sizeof(pSetupDiDifStrings)/sizeof(pSetupDiDifStrings[0]))) {
                //
                // This is a user-defined DIF code...
                //
                WriteLogEntry(LogContext,
                              slot_dif_code,
                              MSG_LOG_DI_UNUSED_FUNC,
                              NULL,
                              InstallFunction
                             );
            } else {
                //
                // use the string version of the DIF code
                //
                WriteLogEntry(LogContext,
                              slot_dif_code,
                              MSG_LOG_DI_FUNC,
                              NULL,
                              pSetupDiDifStrings[InstallFunction]
                             );
            }
        }

        //
        // do any pre DIF cleanup
        //
        switch(InstallFunction) {

            case DIF_REGISTER_COINSTALLERS:
                //
                // NTRAID#NTBUG9-644874-2002/06/17-lonnym -- DIF_REGISTER_COINSTALLERS is destructive upon error
                //
                hk = SetupDiOpenDevRegKey(DeviceInfoSet,
                                          DeviceInfoData,
                                          DICS_FLAG_GLOBAL,
                                          0,
                                          DIREG_DRV,
                                          KEY_WRITE
                                         );

                if(hk != INVALID_HANDLE_VALUE) {
                    //
                    // Clean up device SW key:
                    //
                    //  remove CoInstallers32  - can introduce unwanted
                    //                           co-installers
                    //
                    //  remove EnumPropPages32 - can introduce unwanted
                    //                           property pages
                    //
                    RegDeleteValue(hk, pszCoInstallers32);
                    RegDeleteValue(hk, pszEnumPropPages32);

                    RegCloseKey(hk);
                    hk = INVALID_HANDLE_VALUE;
                }

                break;

            case DIF_INSTALLDEVICE:
                //
                // NTRAID#NTBUG9-644997-2002/06/17-lonnym -- DIF_INSTALLDEVICE is destructive upon error
                //
                SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_UPPERFILTERS,
                                                 NULL,
                                                 0
                                                );

                SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                                 DeviceInfoData,
                                                 SPDRP_LOWERFILTERS,
                                                 NULL,
                                                 0
                                                );
                break;

            default:

                break;
        }

        if(Flags & CALLCI_CALL_HELPERS) {
            //
            // Push log context as thread's default.  This will cause orphaned
            // log sections to be merged.
            //
            ChangedThreadLogContext = SetThreadLogContext(LogContext,
                                                          &SavedLogContext
                                                         );

            if(ChangedThreadLogContext) {
                //
                // Add one more ref to protect log context against thread
                // freeing DeviceInfoSet.
                //
                RefLogContext(LogContext);
            }

            //
            // Before we go and try to call any co-installers, first remember
            // the class installer entry point and fusion context, because
            // we'll need it below, and we don't want to wait until the devinfo
            // set has already been unlocked before retrieving this
            // information.
            //
            ClassInstallerEntryPoint =
                InstallParamBlock->ClassInstallerEntryPoint;

            ClassInstallerFusionContext =
                InstallParamBlock->ClassInstallerFusionContext;

            //
            // Store the co-installer count in a local variable for later use.
            // We don't trust accessing it from the install parameter block
            // because after we release the lock (prior to calling the
            // co-installers), the device information element could get deleted
            // out from under us!
            //
            CoInstallerCount = InstallParamBlock->CoInstallerCount;

            //
            // Note:  CoInstallerCount may still be -1 here, because we may
            // have been asked to only call previously-loaded helper modules,
            // and not load any new ones (e.g., if we're simply going to call
            // them to do clean-up in preparation for unload).
            //

            if(CoInstallerCount > 0) {
                //
                // Allocate an array of co-installer context structures to be
                // used when calling (and potentially, re-calling) the entry
                // points.
                //
                CoInstallerInternalContext = MyMalloc(sizeof(COINSTALLER_INTERNAL_CONTEXT) * CoInstallerCount);
                if(!CoInstallerInternalContext) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    leave;
                }

                ZeroMemory(CoInstallerInternalContext,
                           sizeof(COINSTALLER_INTERNAL_CONTEXT) * CoInstallerCount
                          );

                //
                // Loop through our list of co-installers, storing the
                // necessary information about each one into our context list.
                // We must do this because we've no guarantee that the list of
                // co-installers won't change as a result of processing this
                // DIF request.  (We do, however, know that the set/element
                // won't be yanked out from under us, since we locked these
                // down.)
                //
                for(i = 0; i < CoInstallerCount; i++) {

                    CoInstallerInternalContext[i].CoInstallerEntryPoint =
                        InstallParamBlock->CoInstallerList[i].CoInstallerEntryPoint;

                    CoInstallerInternalContext[i].CoInstallerFusionContext =
                        InstallParamBlock->CoInstallerList[i].CoInstallerFusionContext;

                }

                //
                // Call each co-installer.  We must unlock the devinfo set
                // first, to avoid deadlocks.
                //
                UnlockDeviceInfoSet(pDeviceInfoSet);
                pDeviceInfoSet = NULL;

                for(i = 0; i < CoInstallerCount; i++) {

                    WriteLogEntry(LogContext,
                                  DRIVER_LOG_TIME,
                                  MSG_LOG_COINST_START,
                                  NULL,
                                  i + 1,
                                  CoInstallerCount
                                 );

                    spFusionEnterContext(
                        CoInstallerInternalContext[i].CoInstallerFusionContext,
                        &spFusionInstance
                        );

                    try {
                        Err = CoInstallerInternalContext[i].CoInstallerEntryPoint(
                                  InstallFunction,
                                  DeviceInfoSet,
                                  DeviceInfoData,
                                  &(CoInstallerInternalContext[i].Context)
                                 );
                    } finally {
                        spFusionLeaveContext(&spFusionInstance);
                    }

                    ASSERT_HEAP_IS_VALID();

                    if((Err != NO_ERROR) && (Err != ERROR_DI_POSTPROCESSING_REQUIRED)) {

                        ErrorLevel = FilterLevelOnInstallerError(ErrorLevel,
                                                                 Err
                                                                );

                        WriteLogEntry(LogContext,
                                      ErrorLevel | SETUP_LOG_BUFFER,
                                      MSG_LOG_COINST_END_ERROR,
                                      NULL,
                                      i + 1,
                                      CoInstallerCount
                                     );

                        WriteLogError(LogContext, ErrorLevel, Err);

                        MuteError = TRUE; // already logged it
                        leave;

                    } else {

                        WriteLogEntry(LogContext,
                                      DRIVER_LOG_VERBOSE1,
                                      MSG_LOG_COINST_END,
                                      NULL,
                                      i + 1,
                                      CoInstallerCount
                                     );

                        if(Err == ERROR_DI_POSTPROCESSING_REQUIRED) {
                            CoInstallerInternalContext[i].DoPostProcessing = TRUE;
                        }
                    }
                }
            }

            //
            // If there is a class installer entry point, then call it.
            //
            if(ClassInstallerEntryPoint) {
                //
                // Make sure we don't have the HDEVINFO locked.
                //
                if(pDeviceInfoSet) {
                    UnlockDeviceInfoSet(pDeviceInfoSet);
                    pDeviceInfoSet = NULL;
                }

                WriteLogEntry(LogContext,
                              DRIVER_LOG_TIME,
                              MSG_LOG_CI_START,
                              NULL
                             );

                spFusionEnterContext(ClassInstallerFusionContext,
                                     &spFusionInstance
                                    );

                try {
                    Err = ClassInstallerEntryPoint(InstallFunction,
                                                   DeviceInfoSet,
                                                   DeviceInfoData
                                                  );
                } finally {
                    spFusionLeaveContext(&spFusionInstance);
                }

                ASSERT_HEAP_IS_VALID();

                if((Err != NO_ERROR) && (Err != ERROR_DI_DO_DEFAULT)) {

                    ErrorLevel = FilterLevelOnInstallerError(ErrorLevel, Err);

                    WriteLogEntry(LogContext,
                                  ErrorLevel | SETUP_LOG_BUFFER,
                                  MSG_LOG_CI_END_ERROR,
                                  NULL
                                 );

                    WriteLogError(LogContext, ErrorLevel, Err);

                    MuteError = TRUE; // already logged it

                } else {

                    WriteLogEntry(LogContext,
                                  DRIVER_LOG_VERBOSE1,
                                  MSG_LOG_CI_END,
                                  NULL
                                 );
                }

                if(Err != ERROR_DI_DO_DEFAULT) {
                    //
                    // class installer handled
                    //
                    leave;
                }

            } else {
                Err = ERROR_DI_DO_DEFAULT;
            }
        }

        if(InstallParamBlock->Flags & DI_NODI_DEFAULTACTION) {
            //
            // We shouldn't provide a default action--just return the class
            // installer result.
            //
            leave;
        }

        Err = NO_ERROR;

        //
        // Make sure the devinfo set is unlocked before calling the appropriate
        // default handler routine...
        //
        if(pDeviceInfoSet) {
            UnlockDeviceInfoSet(pDeviceInfoSet);
            pDeviceInfoSet = NULL;
        }

        WriteLogEntry(LogContext,
                      DRIVER_LOG_VERBOSE1,
                      MSG_LOG_CI_DEF_START,
                      NULL
                     );

        switch(InstallFunction) {

            case DIF_SELECTDEVICE :

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiSelectDevice(DeviceInfoSet,
                                                      DeviceInfoData)
                                 );
                break;

            case DIF_SELECTBESTCOMPATDRV :

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiSelectBestCompatDrv(DeviceInfoSet,
                                                             DeviceInfoData)
                                 );

                if(Err == ERROR_NO_COMPAT_DRIVERS) {
                    ErrorLevel = DRIVER_LOG_WARNING;
                }
                break;

            case DIF_INSTALLDEVICE :

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiInstallDevice(DeviceInfoSet,
                                                       DeviceInfoData)
                                 );
                break;

            case DIF_INSTALLDEVICEFILES :

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiInstallDriverFiles(DeviceInfoSet,
                                                            DeviceInfoData)
                                 );
                break;

            case DIF_INSTALLINTERFACES :

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiInstallDeviceInterfaces(
                                      DeviceInfoSet,
                                      DeviceInfoData)
                                 );
                break;

            case DIF_REGISTER_COINSTALLERS :

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiRegisterCoDeviceInstallers(
                                      DeviceInfoSet,
                                      DeviceInfoData)
                                 );
                break;

            case DIF_REMOVE :

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiRemoveDevice(DeviceInfoSet,
                                                      DeviceInfoData)
                                 );
                break;

            case DIF_UNREMOVE :

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiUnremoveDevice(DeviceInfoSet,
                                                        DeviceInfoData)
                                 );
                break;

            case DIF_MOVEDEVICE :
                //
                // This device install action has been deprecated.
                //
                Err = ERROR_DI_FUNCTION_OBSOLETE;
                break;

            case DIF_PROPERTYCHANGE :

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiChangeState(DeviceInfoSet,
                                                     DeviceInfoData)
                                 );
                break;

            case DIF_REGISTERDEVICE :

                Err = GLE_FN_CALL(FALSE,
                                  SetupDiRegisterDeviceInfo(DeviceInfoSet,
                                                            DeviceInfoData,
                                                            0,
                                                            NULL,
                                                            NULL,
                                                            NULL)
                                 );
                break;

            //
            // FUTURE-2002/06/18-lonnym -- End-of-life old Win9x netdi DIF codes
            //
            // These are Win9x messages for class installers such as the
            // Network, where the class installer will do all of the work.  If
            // no action is taken, ie, the class installer returns
            // ERROR_DI_DO_DEFAULT, then we return OK, since there is no
            // default action for these cases.
            //
            case DIF_SELECTCLASSDRIVERS:
            case DIF_VALIDATECLASSDRIVERS:
            case DIF_INSTALLCLASSDRIVERS:
                //
                // Let fall through to default handling...
                //

            default :
                //
                // If the DIF request didn't have a default handler, then let
                // the caller deal with it...
                //
                Err = ERROR_DI_DO_DEFAULT;
                break;
        }

        if(!MuteError) {

            if((Err != NO_ERROR) && (Err != ERROR_DI_DO_DEFAULT)) {

                ErrorLevel = FilterLevelOnInstallerError(ErrorLevel, Err);

                WriteLogEntry(LogContext,
                              ErrorLevel | SETUP_LOG_BUFFER,
                              MSG_LOG_CI_DEF_END_ERROR,
                              NULL
                             );

                WriteLogError(LogContext, ErrorLevel, Err);

                MuteError = TRUE; // already logged it

            } else {

                WriteLogEntry(LogContext,
                              DRIVER_LOG_VERBOSE1,
                              MSG_LOG_CI_DEF_END,
                              NULL
                             );
            }
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hk != INVALID_HANDLE_VALUE) {
        RegCloseKey(hk);
    }

    if(slot) {
        ReleaseLogInfoSlot(LogContext, slot);
    }

    //
    // Free any context handles that may have been allocated while verifying/
    // loading the class installer and co-installers.
    //
    pSetupFreeVerifyContextMembers(&VerifyContext);

    ASSERT_HEAP_IS_VALID();

    //
    // Do a post-processing callback to any of the co-installers that requested
    // one.
    //
    for(i--; i >= 0; i--) {

        if(CoInstallerInternalContext[i].DoPostProcessing) {
            //
            // If we get to here, the HDEVINFO shouldn't be locked...
            //
            MYASSERT(!pDeviceInfoSet);

            CoInstallerInternalContext[i].Context.PostProcessing = TRUE;
            CoInstallerInternalContext[i].Context.InstallResult = Err;
            LastErr = Err;

            try {

                WriteLogEntry(LogContext,
                              DRIVER_LOG_TIME,
                              MSG_LOG_COINST_POST_START,
                              NULL,
                              i + 1
                             );

                spFusionEnterContext(
                    CoInstallerInternalContext[i].CoInstallerFusionContext,
                    &spFusionInstance
                    );

                try {
                    Err = CoInstallerInternalContext[i].CoInstallerEntryPoint(
                              InstallFunction,
                              DeviceInfoSet,
                              DevInfoElem ? DeviceInfoData : NULL,
                              &(CoInstallerInternalContext[i].Context)
                              );
                } finally {
                    spFusionLeaveContext(&spFusionInstance);
                }

                ASSERT_HEAP_IS_VALID();

                if((Err != LastErr) &&
                   ((LastErr != ERROR_DI_DO_DEFAULT) || (Err != NO_ERROR))) {
                    //
                    // If error status has changed (even to success)
                    // log this as an error
                    //
                    if(((LastErr == NO_ERROR) || (LastErr == ERROR_DI_DO_DEFAULT))
                        && (Err != NO_ERROR) && (Err != ERROR_DI_DO_DEFAULT)) {
                        WriteLogEntry(
                                  LogContext,
                                  ErrorLevel | SETUP_LOG_BUFFER,
                                  MSG_LOG_COINST_POST_END_ERROR,
                                  NULL,
                                  i+1);

                        WriteLogError(LogContext, ErrorLevel, Err);
                    } else {
                        WriteLogEntry(
                                  LogContext,
                                  DRIVER_LOG_WARNING | SETUP_LOG_BUFFER,
                                  MSG_LOG_COINST_POST_CHANGE_ERROR,
                                  NULL,
                                  i+1);

                        WriteLogError(LogContext, DRIVER_LOG_WARNING, Err);
                    }
                } else {
                    WriteLogEntry(
                              LogContext,
                              DRIVER_LOG_VERBOSE1,
                              MSG_LOG_COINST_POST_END,
                              NULL,
                              i+1);
                }

            } except(pSetupExceptionFilter(GetExceptionCode())) {

                pSetupExceptionHandler(GetExceptionCode(),
                                       ERROR_INVALID_PARAMETER,
                                       NULL
                                      );

                //
                // Ignore any co-installer that generates an exception during
                // post-processing.
                //
            }
        }
    }

    //
    // If we need to restore any state on the devinfo set or element, do that
    // now (we may need to re-acquire the lock before doing so)...
    //
    if(bRestoreDiQuietInstall
       || UnlockDevInfoElem
       || UnlockDevInfoSet) {

        if(!pDeviceInfoSet) {

            pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet);

            //
            // Since we had the set/element "pinned", we should've been able to
            // re-acquire the lock...
            //
            MYASSERT(pDeviceInfoSet);
        }

        try {
            //
            // Since we had the set/element "pinned", then our devinfo element,
            // and the pointer to the install parameter block should be the
            // same...
            //
#if ASSERTS_ON
            if(DevInfoElem) {

                MYASSERT(DevInfoElem == FindAssociatedDevInfoElem(
                                            pDeviceInfoSet,
                                            DeviceInfoData,
                                            NULL));

                MYASSERT(InstallParamBlock == &(DevInfoElem->InstallParamBlock));

            } else {
                MYASSERT(InstallParamBlock == &(pDeviceInfoSet->InstallParamBlock));
            }
#endif

            if(UnlockDevInfoElem) {
                MYASSERT(DevInfoElem);
                MYASSERT(DevInfoElem->DiElemFlags & DIE_IS_LOCKED);
                DevInfoElem->DiElemFlags &= ~DIE_IS_LOCKED;
            } else if(UnlockDevInfoSet) {
                MYASSERT(pDeviceInfoSet->DiSetFlags & DISET_IS_LOCKED);
                pDeviceInfoSet->DiSetFlags &= ~DISET_IS_LOCKED;
            }

            if(bRestoreDiQuietInstall) {
                InstallParamBlock->Flags |= DI_QUIETINSTALL;
            }

        } except(pSetupExceptionFilter(GetExceptionCode())) {
            pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, NULL);
        }
    }

    if(pDeviceInfoSet) {
        UnlockDeviceInfoSet(pDeviceInfoSet);
    }

    if(CoInstallerInternalContext) {
        MyFree(CoInstallerInternalContext);
    }

    //
    // If we just did a DIF_REGISTER_COINSTALLERS, then we invalidated our
    // current list of co-installers.  Clear our list, so it will be retrieved
    // next time.  (NOTE:  Normally, the default action will be taken (i.e.,
    // SetupDiRegisterCoDeviceInstallers), which will have already invalidated
    // the list.  The class installer may have handled this themselves,
    // however, so we'll invalidate the list here as well just to be safe.)
    //
    if(InstallFunction == DIF_REGISTER_COINSTALLERS) {
        InvalidateHelperModules(DeviceInfoSet, DeviceInfoData, IHM_COINSTALLERS_ONLY);
    }

    if(!MuteError && (Err != NO_ERROR) && (Err != ERROR_DI_DO_DEFAULT)) {

        ErrorLevel = FilterLevelOnInstallerError(ErrorLevel, Err);

        WriteLogEntry(LogContext,
                      ErrorLevel | SETUP_LOG_BUFFER,
                      MSG_LOG_CCI_ERROR,
                      NULL,
                      i + 1
                     );

        WriteLogError(LogContext, ErrorLevel, Err);
    }

    if(slot_dif_code) {
        ReleaseLogInfoSlot(LogContext, slot_dif_code);
    }

    if(ChangedThreadLogContext) {
        //
        // restore thread log context
        //
        SetThreadLogContext(SavedLogContext, NULL);
        DeleteLogContext(LogContext); // counter RefLogContext
    }

    return Err;
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiInstallClassExA(
    IN HWND        hwndParent,         OPTIONAL
    IN PCSTR       InfFileName,        OPTIONAL
    IN DWORD       Flags,
    IN HSPFILEQ    FileQueue,          OPTIONAL
    IN CONST GUID *InterfaceClassGuid, OPTIONAL
    IN PVOID       Reserved1,
    IN PVOID       Reserved2
    )
{
    PCWSTR UnicodeInfFileName = NULL;
    DWORD rc;

    try {

        if(InfFileName) {
            rc = pSetupCaptureAndConvertAnsiArg(InfFileName,
                                                &UnicodeInfFileName
                                               );
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiInstallClassExW(hwndParent,
                                                UnicodeInfFileName,
                                                Flags,
                                                FileQueue,
                                                InterfaceClassGuid,
                                                Reserved1,
                                                Reserved2)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(UnicodeInfFileName) {
        MyFree(UnicodeInfFileName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiInstallClassEx(
    IN HWND        hwndParent,         OPTIONAL
    IN PCTSTR      InfFileName,        OPTIONAL
    IN DWORD       Flags,
    IN HSPFILEQ    FileQueue,          OPTIONAL
    IN CONST GUID *InterfaceClassGuid, OPTIONAL
    IN PVOID       Reserved1,
    IN PVOID       Reserved2
    )
/*++

Routine Description:

    This routine either:

        a) Installs a class installer by running the [ClassInstall32] section
           of the specified INF, or
        b) Installs an interface class specified in the InterfaceClassGuid
           parameter, running the install section for this class as listed in
           the [InterfaceInstall32] of the specified INF (if there is no entry,
           then installation simply involves creating the interface class
           subkey under the DeviceClasses key.

    If the InterfaceClassGuid parameter is specified, then we're installing an
    interface class (case b), otherwise, we're installing a class installer
    (case a).

Arguments:

    hwndParent - Optionally, supplies the handle of the parent window for any
        UI brought up as a result of installing this class.

    InfFileName - Optionally, supplies the name of the INF file containing a
        [ClassInstall32] section (if we're installing a class installer), or
        an [InterfaceInstall32] section with an entry for the specified
        interface class (if we're installing an interface class).  If
        installing a class installer, this parameter _must_ be supplied.

    Flags - Flags that control the installation.  May be a combination of the
        following:

        DI_NOVCP - This flag should be specified if HSPFILEQ is supplied.  This
            instructs SetupInstallFromInfSection to not create a queue of its
            own, and instead to use the caller-supplied one.  If this flag is
            specified, then no file copying will be done.

        DI_NOBROWSE - This flag should be specified if no file browsing should
            be allowed in the event a copy operation cannot find a specified
            file.  If the user supplies their own file queue, then this flag is
            ignored.

        DI_FORCECOPY - This flag should be specified if the files should always
            be copied, even if they're already present on the user's machine
            (i.e., don't ask the user if they want to keep their existing
            files).  If the user supplies their own file queue, then this flag
            is ignored.

        DI_QUIETINSTALL - This flag should be specified if UI should be
            suppressed unless absolutely necessary (i.e., no progress dialog).
            If the user supplies their own queue, then this flag is ignored.

            (NOTE:  During GUI-mode setup on Windows NT, quiet-install behavior
            is always employed in the absence of a user-supplied file queue.)

    FileQueue - If the DI_NOVCP flag is specified, then this parameter supplies
        a handle to a file queue where file operations are to be queued (but
        not committed).

    InterfaceClassGuid - Optionally, specifies the interface class to be
        installed.  If this parameter is not specified, then we are installing
        a class installer whose class is the class of the INF specified by
        InfFileName.

    Reserved1, Reserved2 - Reserved for future use.  Must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This API is generally called by the "New Hardware Found" process when it
    installs a device of a new device setup class.

    Class installers may also use this API to install new interface classes.
    Note that interface class installation can also happen automatically as a
    result of installing device interfaces for a device instance (via
    SetupDiInstallDeviceInterfaces).

--*/

{
    HINF hInf = INVALID_HANDLE_VALUE;
    DWORD Err, ScanQueueResult;
    TCHAR ClassInstallSectionName[MAX_SECT_NAME_LEN];
    DWORD ClassInstallSectionNameLen;
    GUID ClassGuid;
    BOOL ClassGuidIsValid = FALSE;
    TCHAR ClassGuidStringBuffer[GUID_STRING_LEN];
    HKEY hKey = INVALID_HANDLE_VALUE;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext = NULL;
    BOOL KeyNewlyCreated = FALSE;
    PCTSTR ClassName;
    BOOL CloseFileQueue = FALSE;
    PTSTR SectionExtension;
    INFCONTEXT InterfaceClassInstallLine;
    PCTSTR UndecoratedInstallSection;
    DWORD InstallFlags;
    REGMOD_CONTEXT RegContext;
    BOOL NoProgressUI;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    TCHAR szNewName[MAX_PATH];
    BOOL OemInfFileToCopy = FALSE;
    BOOL NullDriverInstall;
    HRESULT hr;

    try {
        //
        // Validate the flags.
        //
        if(Flags & ~(DI_NOVCP | DI_NOBROWSE | DI_FORCECOPY | DI_QUIETINSTALL)) {
            Err = ERROR_INVALID_FLAGS;
            leave;
        }

        //
        // If the caller didn't specify an interface class GUID (i.e., we're
        // installing a class installer), then they'd better have supplied us
        // with an INF filename.  Also, they have to pass NULL for the Reserved
        // arguments.
        //
        if((!InterfaceClassGuid && !InfFileName) || Reserved1 || Reserved2) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // Make sure that the caller supplied us with a file queue, if
        // necessary.
        //
        if((Flags & DI_NOVCP) && (!FileQueue || (FileQueue == INVALID_HANDLE_VALUE))) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(hwndParent && !IsWindow(hwndParent)) {
            hwndParent = NULL;
        }

        if(InfFileName) {
            //
            // Open the INF, and ensure that the same logging context is used
            // for all operations.
            //
            Err = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                              hInf = SetupOpenInfFile(InfFileName,
                                                      NULL,
                                                      INF_STYLE_WIN4,
                                                      NULL)
                             );

            if(Err != NO_ERROR) {
                leave;
            }

            Err = InheritLogContext(((PLOADED_INF)hInf)->LogContext,
                                    &LogContext
                                   );
            if(Err != NO_ERROR) {
                //
                // Since we're using log context inheritance to create a log
                // context, this failure must be considered critical.
                //
                leave;
            }

        } else {
            //
            // No INF to worry about--just need a log context for the stuff
            // we're doing directly.
            //
            Err = CreateLogContext(NULL, TRUE, &LogContext);

            if(Err != NO_ERROR) {
                leave;
            }
        }

        if(InterfaceClassGuid) {
            //
            // Copy this GUID into our ClassGuid variable, which is used for
            // both installer and device interface classes.
            //
            CopyMemory(&ClassGuid, InterfaceClassGuid, sizeof(ClassGuid));
            ClassGuidIsValid = TRUE;

            //
            // Legacy (compatibility) class name is not needed for device
            // interface classes.
            //
            ClassName = NULL;

            pSetupStringFromGuid(&ClassGuid,
                                 ClassGuidStringBuffer,
                                 SIZECHARS(ClassGuidStringBuffer)
                                );

            WriteLogEntry(LogContext,
                          DRIVER_LOG_INFO,
                          MSG_LOG_DO_INTERFACE_CLASS_INSTALL,
                          NULL,       // text message
                          ClassGuidStringBuffer
                         );

        } else {

            PCTSTR pInfGuidString;

            //
            // Retrieve the class GUID from the INF.  If it has no class GUID,
            // then we can't install from it (even if it specifies the class
            // name).
            //
            if(!(pInfGuidString = pSetupGetVersionDatum(
                                      &((PLOADED_INF)hInf)->VersionBlock,
                                      pszClassGuid))
               || (pSetupGuidFromString(pInfGuidString, &ClassGuid) != NO_ERROR)) {

                Err = ERROR_INVALID_CLASS;
                leave;
            }

            ClassGuidIsValid = TRUE;

            if(!MYVERIFY(SUCCEEDED(StringCchCopy(ClassGuidStringBuffer,
                                                 SIZECHARS(ClassGuidStringBuffer),
                                                 pInfGuidString
                                                 )))) {
                //
                // "will never fail"
                // but if it does, fail securely
                //
                Err = ERROR_INVALID_CLASS;
                leave;
            }

            //
            // We'll need to get the class name out of the INF as well.
            //
            if(!(ClassName = pSetupGetVersionDatum(&((PLOADED_INF)hInf)->VersionBlock,
                                                   pszClass))) {
                Err = ERROR_INVALID_CLASS;
                leave;
            }

            WriteLogEntry(LogContext,
                          DRIVER_LOG_INFO,
                          MSG_LOG_DO_CLASS_INSTALL,
                          NULL,       // text message
                          ClassGuidStringBuffer,
                          ClassName
                         );
        }

        //
        // First, attempt to open the key (i.e., not create it).  If that
        // fails, then we'll try to create it.  That way, we can keep track of
        // whether clean-up is required if an error occurs.
        //
        if(CR_SUCCESS != CM_Open_Class_Key_Ex(&ClassGuid,
                                              ClassName,
                                              KEY_READ | KEY_WRITE,
                                              RegDisposition_OpenExisting,
                                              &hKey,
                                              InterfaceClassGuid ? CM_OPEN_CLASS_KEY_INTERFACE
                                                                 : CM_OPEN_CLASS_KEY_INSTALLER,
                                              NULL))
        {
            CONFIGRET cr;

            //
            // The key doesn't already exist--we've got to create it.
            //
            cr = CM_Open_Class_Key_Ex(&ClassGuid,
                                      ClassName,
                                      KEY_READ | KEY_WRITE,
                                      RegDisposition_OpenAlways,
                                      &hKey,
                                      (InterfaceClassGuid ? CM_OPEN_CLASS_KEY_INTERFACE
                                                          : CM_OPEN_CLASS_KEY_INSTALLER),
                                      NULL
                                     );

            if(cr != CR_SUCCESS) {
                hKey = INVALID_HANDLE_VALUE; // ensure key handle still invalid
                Err = CR_TO_SP(cr, ERROR_INVALID_DATA);
                leave;
            }

            KeyNewlyCreated = TRUE;
        }

        if(hInf == INVALID_HANDLE_VALUE) {
            //
            // We've done all we need to do to install this device interface.
            //
            leave;

        } else {
            //
            // Append the layout INF, if necessary.
            //
            SetupOpenAppendInfFile(NULL, hInf, NULL);
        }

        if(InterfaceClassGuid) {
            //
            // Look for an entry for this interface class in the
            // [InterfaceInstall32] section of the INF.
            //
            if(!SetupFindFirstLine(hInf,
                                   pszInterfaceInstall32,
                                   ClassGuidStringBuffer,
                                   &InterfaceClassInstallLine)) {
                //
                // No install entry in this INF--we're done.
                //
                leave;
            }

            //
            // Make sure the Flags field is zero.
            //
            if(SetupGetIntField(&InterfaceClassInstallLine, 2, (PINT)&InstallFlags) && InstallFlags) {
                Err = ERROR_BAD_INTERFACE_INSTALLSECT;
                leave;
            }

            if((!(UndecoratedInstallSection = pSetupGetField(&InterfaceClassInstallLine, 1)))
               || !(*UndecoratedInstallSection))
            {
                //
                // No install section was given--we're done.
                //
                leave;
            }

        } else {

            UndecoratedInstallSection = pszClassInstall32;

            ZeroMemory(&RegContext, sizeof(RegContext));
            RegContext.Flags |= INF_PFLAG_CLASSPROP;
            RegContext.ClassGuid = &ClassGuid;

            //
            // Leave RegContext.hMachine as NULL, since we don't support
            // remote installation of either device setup or device interface
            // classes.
            //
        }

        //
        // Get the 'real' (potentially OS/architecture-specific) class install
        // section name.
        //
        Err = GLE_FN_CALL(FALSE,
                          SetupDiGetActualSectionToInstall(
                              hInf,
                              UndecoratedInstallSection,
                              ClassInstallSectionName,
                              SIZECHARS(ClassInstallSectionName),
                              &ClassInstallSectionNameLen,
                              &SectionExtension)
                         );

        if(Err == NO_ERROR) {
            MYASSERT(ClassInstallSectionNameLen > 1);
            ClassInstallSectionNameLen--;   // don't want this to include null
        } else {
            leave;
        }

        //
        // Also say what section is about to be installed.
        //
        WriteLogEntry(LogContext,
                      DRIVER_LOG_VERBOSE,
                      MSG_LOG_CLASS_SECTION,
                      NULL,
                      ClassInstallSectionName
                     );

        //
        // If this is the undecorated name, then make sure that the section
        // actually exists.
        //
        if(!SectionExtension && (SetupGetLineCount(hInf, ClassInstallSectionName) == -1)) {

            Err = ERROR_SECTION_NOT_FOUND;

            WriteLogEntry(LogContext,
                          DRIVER_LOG_ERROR,
                          MSG_LOG_NOSECTION,
                          NULL,
                          ClassInstallSectionName
                         );
            leave;
        }

        if(!(Flags & DI_NOVCP)) {
            //
            // Since we may need to check the queued files to determine whether
            // file copy is necessary, we have to open our own queue, and
            // commit it ourselves.
            //
            Err = GLE_FN_CALL(INVALID_HANDLE_VALUE,
                              FileQueue = SetupOpenFileQueue()
                             );

            if(Err == NO_ERROR) {
                CloseFileQueue = TRUE;
            } else {
                leave;
            }

            NoProgressUI = (GuiSetupInProgress ||
                            (GlobalSetupFlags & PSPGF_NONINTERACTIVE) ||
                            (Flags & DI_QUIETINSTALL));

            if(!(MsgHandlerContext = SetupInitDefaultQueueCallbackEx(
                                         hwndParent,
                                         (NoProgressUI ? INVALID_HANDLE_VALUE : NULL),
                                         0,
                                         0,
                                         NULL))) {
                //
                // This routine doesn't set last error, but the only reason it
                // can fail is due to insufficient memory...
                //
                Err = ERROR_NOT_ENOUGH_MEMORY;
                leave;
            }

            MsgHandler = SetupDefaultQueueCallback;
        }

        //
        // Replace the file queue's log context with current, if it's never
        // been used.  Failure to inherit is OK, because we know the file queue
        // has its own log context.  Thus, the worst that can happen is the log
        // entries go to two different sections.
        //
        InheritLogContext(LogContext, &((PSP_FILE_QUEUE)FileQueue)->LogContext);

        Err = pSetupInstallFiles(hInf,
                                 NULL,
                                 ClassInstallSectionName,
                                 NULL,
                                 NULL,
                                 NULL,
                                 SP_COPY_NEWER_OR_SAME | SP_COPY_LANGUAGEAWARE |
                                     ((Flags & DI_NOBROWSE) ? SP_COPY_NOBROWSE : 0),
                                 NULL,
                                 FileQueue,
                                 //
                                 // This flag is ignored by pSetupInstallFiles
                                 // because we don't pass a callback here and we
                                 // pass a user-defined file queue. (In other words
                                 // we're not committing the queue so there's no
                                 // callback function to deal with, and the callback
                                 // would be the guy who would care about ansi vs unicode.)
                                 //
                                 TRUE
                                );

        if(CloseFileQueue && (Err == NO_ERROR)) {
            //
            // Call _SetupVerifyQueuedCatalogs separately (i.e., don't let it
            // happen automatically as a result of scanning/committing the
            // queue that happens below).  We do this beforehand so that we
            // know what unique name was generated when an OEM INF was
            // installed into %windir%\Inf (in case we need to delete the
            // INF/PNF/CAT files later if we encounter an error).
            //
            WriteLogEntry(LogContext,
                          DRIVER_LOG_TIME,
                          MSG_LOG_BEGIN_INSTCLASS_VERIFY_CAT_TIME,
                          NULL // text message
                         );

            //
            // (NOTE: We don't have the context in this routine to determine
            // whether or not the INF is from the internet.  For now, just
            // assume it isn't.)
            //
            Err = _SetupVerifyQueuedCatalogs(
                      hwndParent,
                      FileQueue,
                      VERCAT_INSTALL_INF_AND_CAT,
                      szNewName,
                      &OemInfFileToCopy
                     );

            WriteLogEntry(LogContext,
                          DRIVER_LOG_TIME,
                          MSG_LOG_END_INSTCLASS_VERIFY_CAT_TIME,
                          NULL // text message
                         );

            if(Err == NO_ERROR) {
                //
                // We successfully queued up the file operations--now we need
                // to commit the queue.  First off, though, we should check to
                // see if the files are already there.  (If the 'force copy'
                // flag is set, then we don't care if the files are already
                // there--we always need to copy them in that case.)
                //
                if(Flags & DI_FORCECOPY) {
                    //
                    // always copy the files.
                    //
                    ScanQueueResult = 0;

                } else {
                    //
                    // Determine whether the queue actually needs to be
                    // committed.
                    //
                    // ScanQueueResult can have 1 of 3 values:
                    //
                    // 0: Some files were missing or invalid (i.e., digital
                    //    signatures weren't verified;
                    //    Must commit queue.
                    //
                    // 1: All files to be copied are already present/valid, and
                    //    the queue is empty;
                    //    Can skip committing queue.
                    //
                    // 2: All files to be copied are already present/valid, but
                    //    del/ren queues not empty.  Must commit queue. The
                    //    copy queue will have been emptied, so only del/ren
                    //    functions will be performed.
                    //
                    if(!SetupScanFileQueue(FileQueue,
                                           SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                                           hwndParent,
                                           NULL,
                                           NULL,
                                           &ScanQueueResult)) {
                        //
                        // SetupScanFileQueue should really never
                        // fail when you don't ask it to call a
                        // callback routine, but if it does, just
                        // go ahead and commit the queue.
                        //
                        ScanQueueResult = 0;
                    }
                }

                if(ScanQueueResult != 1) {
                    //
                    // Copy enqueued files. In this case the callback is
                    // SetupDefaultQueueCallback, so we know it's native char
                    // width.
                    //
                    Err = GLE_FN_CALL(FALSE,
                                      _SetupCommitFileQueue(hwndParent,
                                                            FileQueue,
                                                            MsgHandler,
                                                            MsgHandlerContext,
                                                            TRUE)
                                     );
                }
            }
        }

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // If we get to here, then the file copying was successful--now we can
        // perform the rest of the installation. We don't pass a callback so we
        // don't worry about ansi vs unicode issues here.
        //
        Err = GLE_FN_CALL(FALSE,
                          _SetupInstallFromInfSection(
                              NULL,
                              hInf,
                              ClassInstallSectionName,
                              SPINST_INIFILES
                              | SPINST_REGISTRY
                              | SPINST_INI2REG
                              | SPINST_BITREG
                              | SPINST_REGSVR
                              | SPINST_UNREGSVR
                              | SPINST_PROFILEITEMS,
                              hKey,
                              NULL,
                              0,
                              NULL,
                              NULL,
                              INVALID_HANDLE_VALUE,
                              NULL,
                              TRUE,
                              (InterfaceClassGuid ? NULL : &RegContext))
                         );

        if(Err != NO_ERROR) {
            leave;
        }

        //
        // The class installer might want to install a Services section.  This
        // allows device setup class registration to include installation of a
        // class-wide driver.
        //
        WriteLogEntry(LogContext,
                      DRIVER_LOG_TIME,
                      MSG_LOG_BEGIN_SERVICE_TIME,
                      NULL // text message
                     );

        //
        // The install section name is of the form:
        //
        //     ClassInstall32[.<ext>].Services
        //
        hr = StringCchCopy(
                 &(ClassInstallSectionName[ClassInstallSectionNameLen]),
                 SIZECHARS(ClassInstallSectionName) - ClassInstallSectionNameLen,
                 pszServicesSectionSuffix
                 );

        if(FAILED(hr)) {
            Err = HRESULT_CODE(hr);
            leave;
        }

        Err = InstallNtService(NULL,
                               hInf,
                               InfFileName,
                               ClassInstallSectionName,
                               NULL,
                               SPSVCINST_NO_DEVINST_CHECK,
                               &NullDriverInstall
                              );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hKey != INVALID_HANDLE_VALUE) {

        RegCloseKey(hKey);

        //
        // NTRAID#NTBUG9-660148-2002/07/05-lonnym - need to clean up interface keys too!
        //
        if((Err != NO_ERROR) && KeyNewlyCreated && !InterfaceClassGuid) {
            //
            // We hit an error, and the class installer key didn't previously
            // exist, so we want to remove it.
            //
            CM_Delete_Class_Key_Ex(&ClassGuid,
                                   CM_DELETE_CLASS_SUBKEYS,
                                   NULL
                                   );
        }
    }

    if(CloseFileQueue) {
        SetupCloseFileQueue(FileQueue);
    }

    if(MsgHandlerContext) {
        SetupTermDefaultQueueCallback(MsgHandlerContext);
    }

    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }

    if(Err == NO_ERROR) {
        //
        // If we're >= DRIVER_LOG_INFO, give a +ve affirmation of install.
        //
        WriteLogEntry(LogContext,
                      DRIVER_LOG_INFO,
                      MSG_LOG_CLASS_INSTALLED,
                      NULL,
                      NULL
                     );
    } else {
        //
        // Log an error about the failure encountered.
        //
        WriteLogEntry(LogContext,
                      DRIVER_LOG_ERROR | SETUP_LOG_BUFFER,
                      MSG_LOG_CLASS_ERROR_ENCOUNTERED,
                      NULL,
                      (ClassGuidIsValid ? ClassGuidStringBuffer : TEXT("*"))
                     );

        WriteLogError(LogContext, DRIVER_LOG_ERROR, Err);

        //
        // If we copied the OEM INF into the INF directory under a
        // newly-generated name, delete it now.
        //
        if(OemInfFileToCopy) {
            pSetupUninstallOEMInf(szNewName,
                                  LogContext,
                                  SUOI_FORCEDELETE,
                                  NULL
                                 );
        }
    }

    if(LogContext) {
        DeleteLogContext(LogContext);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiInstallClassA(
    IN HWND     hwndParent,  OPTIONAL
    IN PCSTR    InfFileName,
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue    OPTIONAL
    )
{
    PCWSTR UnicodeInfFileName = NULL;
    DWORD rc;

    try {

        rc = pSetupCaptureAndConvertAnsiArg(InfFileName, &UnicodeInfFileName);
        if(rc != NO_ERROR) {
            leave;
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiInstallClassExW(hwndParent,
                                                UnicodeInfFileName,
                                                Flags,
                                                FileQueue,
                                                NULL,
                                                NULL,
                                                NULL)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(UnicodeInfFileName) {
        MyFree(UnicodeInfFileName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiInstallClass(
    IN HWND     hwndParent,  OPTIONAL
    IN PCTSTR   InfFileName,
    IN DWORD    Flags,
    IN HSPFILEQ FileQueue    OPTIONAL
    )
/*++

Routine Description:

    This routine installs the [ClassInstall32] section of the specified INF.

Arguments:

    hwndParent - Optionally, supplies the handle of the parent window for any
        UI brought up as a result of installing this class.

    InfFileName - Supplies the name of the INF file containing a
        [ClassInstall32] section.

    Flags - Flags that control the installation.  May be a combination of the
        following:

        DI_NOVCP - This flag should be specified if HSPFILEQ is supplied.  This
            instructs SetupInstallFromInfSection to not create a queue of its
            own, and instead to use the caller-supplied one.  If this flag is
            specified, then no file copying will be done.

        DI_NOBROWSE - This flag should be specified if no file browsing should
            be allowed in the event a copy operation cannot find a specified
            file.  If the user supplies their own file queue, then this flag is
            ignored.

        DI_FORCECOPY - This flag should be specified if the files should always
            be copied, even if they're already present on the user's machine
            (i.e., don't ask the user if they want to keep their existing
            files).  If the user supplies their own file queue, then this flag
            is ignored.

        DI_QUIETINSTALL - This flag should be specified if UI should be
            suppressed unless absolutely necessary (i.e., no progress dialog).
            If the user supplies their own queue, then this flag is ignored.

            (NOTE:  During GUI-mode setup on Windows NT, quiet-install behavior
            is always employed in the absence of a user-supplied file queue.)

    FileQueue - If the DI_NOVCP flag is specified, then this parameter supplies
        a handle to a file queue where file operations are to be queued (but
        not committed).

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    This API is generally called by the "New Hardware Found" process when it
    installs a device of a new device setup class.

--*/
{
    DWORD Err;

    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiInstallClassEx(hwndParent,
                                                InfFileName,
                                                Flags,
                                                FileQueue,
                                                NULL,
                                                NULL,
                                                NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameA(
    IN  DWORD  HwProfile,
    OUT PSTR   FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
{
    DWORD Err;

    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiGetHwProfileFriendlyNameExA(
                              HwProfile,
                              FriendlyName,
                              FriendlyNameSize,
                              RequiredSize,
                              NULL,
                              NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}

BOOL
WINAPI
SetupDiGetHwProfileFriendlyName(
    IN  DWORD  HwProfile,
    OUT PTSTR  FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize      OPTIONAL
    )
/*++

Routine Description:

    See SetupDiGetHwProfileFriendlyNameEx for details.

--*/

{
    DWORD Err;

    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiGetHwProfileFriendlyNameEx(
                              HwProfile,
                              FriendlyName,
                              FriendlyNameSize,
                              RequiredSize,
                              NULL,
                              NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameExA(
    IN  DWORD  HwProfile,
    OUT PSTR   FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize,     OPTIONAL
    IN  PCSTR  MachineName,      OPTIONAL
    IN  PVOID  Reserved
    )
{
    WCHAR UnicodeName[MAX_PROFILE_LEN];
    PSTR AnsiName = NULL;
    DWORD rc;
    DWORD LocalRequiredSize;
    PCWSTR UnicodeMachineName = NULL;
    HRESULT hr;

    try {
        //
        // If you pass a NULL buffer pointer, the size had better be zero!
        //
        if(!FriendlyName && FriendlyNameSize) {
            rc = ERROR_INVALID_PARAMETER;
            leave;
        }

        if(MachineName) {
            rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiGetHwProfileFriendlyNameExW(
                             HwProfile,
                             UnicodeName,
                             SIZECHARS(UnicodeName),
                             &LocalRequiredSize,
                             UnicodeMachineName,
                             Reserved)
                        );

        if(rc != NO_ERROR) {
            leave;
        }

        AnsiName = pSetupUnicodeToAnsi(UnicodeName);

        if(!AnsiName) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            leave;
        }

        LocalRequiredSize = lstrlenA(AnsiName) + 1;

        if(RequiredSize) {
            *RequiredSize = LocalRequiredSize;
        }

        if(!FriendlyName) {
            rc = ERROR_INSUFFICIENT_BUFFER;
            leave;
        }

        hr = StringCchCopyA(FriendlyName,
                            (size_t)FriendlyNameSize,
                            AnsiName
                           );

        if(FAILED(hr)) {
            rc = HRESULT_CODE(hr);
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(AnsiName) {
        MyFree(AnsiName);
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiGetHwProfileFriendlyNameEx(
    IN  DWORD  HwProfile,
    OUT PTSTR  FriendlyName,
    IN  DWORD  FriendlyNameSize,
    OUT PDWORD RequiredSize,     OPTIONAL
    IN  PCTSTR MachineName,      OPTIONAL
    IN  PVOID  Reserved
    )
/*++

Routine Description:

    This routine retrieves the friendly name associated with a hardware profile
    ID.

Arguments:

    HwProfile - Supplies the hardware profile ID whose friendly name is to be
        retrieved.  If this parameter is 0, then the friendly name for the
        current hardware profile is retrieved.

    FriendlyName - Supplies the address of a character buffer that receives the
        friendly name of the hardware profile.

    FriendlyNameSize - Supplies the size, in characters, of the FriendlyName
        buffer.

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of characters required to store the friendly name (including
        terminating NULL).

    MachineName - Optionally, supplies the name of the remote machine
        containing the hardware profile whose friendly name is to be retrieved.
        If this parameter is not specified, the local machine is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err = ERROR_INVALID_HWPROFILE;
    HWPROFILEINFO HwProfInfo;
    ULONG i;
    CONFIGRET cr;
    size_t NameLen;
    HMACHINE hMachine = NULL;
    HRESULT hr;

    try {
        //
        // If you pass a NULL buffer pointer, the size had better be zero!
        //
        if(!FriendlyName && FriendlyNameSize) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // Make sure the caller didn't pass us anything in the Reserved
        // parameter.
        //
        if(Reserved) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // If the caller specified a remote machine name, connect to that
        // machine.
        //
        if(MachineName) {
            cr = CM_Connect_Machine(MachineName, &hMachine);
            if(cr != CR_SUCCESS) {
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                leave;
            }
        }

        //
        // If a hardware profile ID of 0 is specified, then retrieve
        // information about the current hardware profile, otherwise, enumerate
        // the hardware profiles, looking for the one specified.
        //
        if(HwProfile) {
            i = 0;
        } else {
            i = 0xFFFFFFFF;
        }

        do {

            if((cr = CM_Get_Hardware_Profile_Info_Ex(i, &HwProfInfo, 0, hMachine)) == CR_SUCCESS) {
                //
                // Hardware profile info retrieved--see if it's what we're
                // looking for.
                //
                if(!HwProfile || (HwProfInfo.HWPI_ulHWProfile == HwProfile)) {

                    hr = StringCchLength(HwProfInfo.HWPI_szFriendlyName,
                                         SIZECHARS(HwProfInfo.HWPI_szFriendlyName),
                                         &NameLen
                                        );

                    if(FAILED(hr)) {
                        //
                        // CM API gave us garbage!!!
                        //
                        MYASSERT(FALSE);
                        Err = ERROR_INVALID_DATA;
                        leave;
                    }

                    NameLen++;  // include terminating null char

                    if(RequiredSize) {
                        *RequiredSize = (DWORD)NameLen;
                    }

                    if((DWORD)NameLen > FriendlyNameSize) {
                        Err = ERROR_INSUFFICIENT_BUFFER;
                    } else {
                        Err = NO_ERROR;
                        CopyMemory(FriendlyName,
                                   HwProfInfo.HWPI_szFriendlyName,
                                   NameLen * sizeof(TCHAR)
                                  );
                    }

                    break;
                }
                //
                // This wasn't the profile we wanted--go on to the next one.
                //
                i++;

            } else if(!HwProfile || (cr != CR_NO_SUCH_VALUE)) {
                //
                // We should abort on any error other than CR_NO_SUCH_VALUE,
                // otherwise we might loop forever!
                //
                Err = ERROR_INVALID_DATA;
                break;
            }

        } while(cr != CR_NO_SUCH_VALUE);

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiGetHwProfileList(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves a list of all currently-defined hardware profile
    IDs.

Arguments:

    HwProfileList - Supplies the address of an array of DWORDs that will
        receive the list of currently defined hardware profile IDs.

    HwProfileListSize - Supplies the number of DWORDs in the HwProfileList
        array.

    RequiredSize - Supplies the address of a variable that receives the number
        of hardware profiles currently defined.  If this number is larger than
        HwProfileListSize, then the list will be truncated to fit the array
        size, and this value will indicate the array size that would be
        required to store the entire list (the function will fail, with
        GetLastError returning ERROR_INSUFFICIENT_BUFFER in that case).

    CurrentlyActiveIndex - Optionally, supplies the address of a variable that
        receives the index within the HwProfileList array of the currently
        active hardware profile.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err;

    try {

        Err = GLE_FN_CALL(FALSE,
                          SetupDiGetHwProfileListEx(HwProfileList,
                                                    HwProfileListSize,
                                                    RequiredSize,
                                                    CurrentlyActiveIndex,
                                                    NULL,
                                                    NULL)
                         );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetHwProfileListExA(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex, OPTIONAL
    IN  PCSTR  MachineName,          OPTIONAL
    IN  PVOID  Reserved
    )
{
    PCWSTR UnicodeMachineName = NULL;
    DWORD rc;

    try {

        if(MachineName) {
            rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
            if(rc != NO_ERROR) {
                leave;
            }
        }

        rc = GLE_FN_CALL(FALSE,
                         SetupDiGetHwProfileListExW(HwProfileList,
                                                    HwProfileListSize,
                                                    RequiredSize,
                                                    CurrentlyActiveIndex,
                                                    UnicodeMachineName,
                                                    Reserved)
                        );

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &rc);
    }

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiGetHwProfileListEx(
    OUT PDWORD HwProfileList,
    IN  DWORD  HwProfileListSize,
    OUT PDWORD RequiredSize,
    OUT PDWORD CurrentlyActiveIndex, OPTIONAL
    IN  PCTSTR MachineName,          OPTIONAL
    IN  PVOID  Reserved
    )
/*++

Routine Description:

    This routine retrieves a list of all currently-defined hardware profile
    IDs.

Arguments:

    HwProfileList - Supplies the address of an array of DWORDs that will
        receive the list of currently defined hardware profile IDs.

    HwProfileListSize - Supplies the number of DWORDs in the HwProfileList
        array.

    RequiredSize - Supplies the address of a variable that receives the number
        of hardware profiles currently defined.  If this number is larger than
        HwProfileListSize, then the list will be truncated to fit the array
        size, and this value will indicate the array size that would be
        required to store the entire list (the function will fail, with
        GetLastError returning ERROR_INSUFFICIENT_BUFFER in that case).

    CurrentlyActiveIndex - Optionally, supplies the address of a variable that
        receives the index within the HwProfileList array of the currently
        active hardware profile.

    MachineName - Optionally, specifies the name of the remote machine to
        retrieve a list of hardware profiles for.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    DWORD Err = NO_ERROR;
    DWORD CurHwProfile;
    HWPROFILEINFO HwProfInfo;
    ULONG i;
    CONFIGRET cr = CR_SUCCESS;
    HMACHINE hMachine = NULL;

    try {
        //
        // Make sure the caller didn't pass us anything in the Reserved
        // parameter.
        //
        if(Reserved) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // If the caller specified a null buffer pointer, its size had better
        // be zero.
        //
        if(!HwProfileList && HwProfileListSize) {
            Err = ERROR_INVALID_PARAMETER;
            leave;
        }

        //
        // If the caller specified a remote machine name, connect to that
        // machine now.
        //
        if(MachineName) {
            cr = CM_Connect_Machine(MachineName, &hMachine);
            if(cr != CR_SUCCESS) {
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                leave;
            }
        }

        //
        // First retrieve the currently active hardware profile ID, so we'll
        // know what to look for when we're enumerating all profiles (only need
        // to do this if the user wants the index of the currently active
        // hardware profile).
        //
        if(CurrentlyActiveIndex) {

            if((cr = CM_Get_Hardware_Profile_Info_Ex(0xFFFFFFFF, &HwProfInfo, 0, hMachine)) == CR_SUCCESS) {
                //
                // Store away the hardware profile ID.
                //
                CurHwProfile = HwProfInfo.HWPI_ulHWProfile;

            } else {
                Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                leave;
            }
        }

        //
        // Enumerate the hardware profiles, retrieving the ID for each.
        //
        i = 0;
        do {

            if((cr = CM_Get_Hardware_Profile_Info_Ex(i, &HwProfInfo, 0, hMachine)) == CR_SUCCESS) {
                if(i < HwProfileListSize) {
                    HwProfileList[i] = HwProfInfo.HWPI_ulHWProfile;
                }
                if(CurrentlyActiveIndex && (HwProfInfo.HWPI_ulHWProfile == CurHwProfile)) {
                    *CurrentlyActiveIndex = i;
                    //
                    // Clear the CurrentlyActiveIndex pointer, so we once we find the
                    // currently active profile, we won't have to keep comparing.
                    //
                    CurrentlyActiveIndex = NULL;
                }
                i++;
            }

        } while(cr == CR_SUCCESS);

        if(cr == CR_NO_MORE_HW_PROFILES) {
            //
            // Then we enumerated all hardware profiles.  Now see if we had
            // enough buffer to hold them all.
            //
            *RequiredSize = i;
            if(i > HwProfileListSize) {
                Err = ERROR_INSUFFICIENT_BUFFER;
            }
        } else {
            //
            // Something else happened (probably a key not present).
            //
            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
        }

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_PARAMETER, &Err);
    }

    if(hMachine) {
        CM_Disconnect_Machine(hMachine);
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
pSetupDiGetCoInstallerList(
    IN     HDEVINFO                 DeviceInfoSet,     OPTIONAL
    IN     PSP_DEVINFO_DATA         DeviceInfoData,    OPTIONAL
    IN     CONST GUID              *ClassGuid,         OPTIONAL
    IN OUT PDEVINSTALL_PARAM_BLOCK  InstallParamBlock,
    IN OUT PVERIFY_CONTEXT          VerifyContext      OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the list of co-installers (both class- and
    device-specific) and stores the entry points and module handles in
    the supplied install param block.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set to retrieve
        co-installers into.  If DeviceInfoSet is not specified, then the
        InstallParamBlock specified below will be that of the set itself.

    DeviceInfoData - Optionally, specifies the device information element
        for which a list of co-installers is to be retrieved.

    ClassGuid - Optionally, supplies the address of the device setup class GUID
        for which class-specific co-installers are to be retrieved.

    InstallParamBlock - Supplies the address of the install param block where
        the co-installer list is to be stored.  This will either be the param
        block of the set itself (if DeviceInfoData isn't specified), or of
        the specified device information element.
            
    VerifyContext - optionally, supplies the address of a structure that caches
        various verification context handles.  These handles may be NULL (if
        not previously acquired, and they may be filled in upon return (in
        either success or failure) if they were acquired during the processing
        of this verification request.  It is the caller's responsibility to
        free these various context handles when they are no longer needed by
        calling pSetupFreeVerifyContextMembers.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise it is
    a Win32 error code indicating the cause of failure.

--*/
{
    HKEY hk[2] = {INVALID_HANDLE_VALUE, INVALID_HANDLE_VALUE};
    DWORD Err, RegDataType, KeyIndex;
    LONG i;
    PTSTR CoInstallerBuffer;
    DWORD CoInstallerBufferSize;
    PTSTR CurEntry;
    PCOINSTALLER_NODE CoInstallerList, TempCoInstallerList;
    DWORD CoInstallerListSize;
    TCHAR GuidString[GUID_STRING_LEN];
    TCHAR DescBuffer[LINE_LEN];
    PTSTR DeviceDesc;
    HWND hwndParent;
    BOOL MustAbort;

    MYASSERT(sizeof(GuidString) == sizeof(pszGuidNull));

    //
    // If there is already a list, then return success immediately.
    //
    if(InstallParamBlock->CoInstallerCount != -1) {
        return NO_ERROR;
    }

    //
    // Retrieve the parent window handle, as we may need it below if we need to
    // popup UI due to unsigned class-/co-installers.
    //
    if(hwndParent = InstallParamBlock->hwndParent) {
       if(!IsWindow(hwndParent)) {
            hwndParent = NULL;
       }
    }

    //
    // Retrieve a device description to use in case we need to give a driver
    // signing warn/block popup.
    //
    if(GetBestDeviceDesc(DeviceInfoSet, DeviceInfoData, DescBuffer)) {
        DeviceDesc = DescBuffer;
    } else {
        DeviceDesc = NULL;
    }

    //
    // Get the string form of the class GUID, because that will be the name of
    // the multisz value entry under HKLM\System\CCS\Control\CoDeviceInstallers
    // where class-specific co-installers will be registered
    //
    if(ClassGuid) {

        pSetupStringFromGuid(ClassGuid, GuidString, SIZECHARS(GuidString));

    } else {

        CopyMemory(GuidString, pszGuidNull, sizeof(pszGuidNull));
    }

    CoInstallerBuffer = NULL;
    CoInstallerBufferSize = 256 * sizeof(TCHAR);    // start out with 256-character buffer
    CoInstallerList = NULL;
    i = 0;

    try {
        //
        // Open the CoDeviceInstallers key, as well as the device's driver key (if
        // a devinfo element is specified).
        //
        Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           pszPathCoDeviceInstallers,
                           0,
                           KEY_READ,
                           &(hk[0])
                          );

        if(Err != ERROR_SUCCESS) {
            hk[0] = INVALID_HANDLE_VALUE;
        }

        if(DeviceInfoData) {

            hk[1] = SetupDiOpenDevRegKey(DeviceInfoSet,
                                         DeviceInfoData,
                                         DICS_FLAG_GLOBAL,
                                         0,
                                         DIREG_DRV,
                                         KEY_READ
                                        );

        } else {
            hk[1] = INVALID_HANDLE_VALUE;
        }

        for(KeyIndex = 0; KeyIndex < 2; KeyIndex++) {
            //
            // If we couldn't open a key for this location, move on to the next
            // one.
            //
            if(hk[KeyIndex] == INVALID_HANDLE_VALUE) {
                continue;
            }

            //
            // Retrieve the multi-sz value containing the co-installer entries.
            //
            while(TRUE) {

                if(!CoInstallerBuffer) {
                    if(!(CoInstallerBuffer = MyMalloc(CoInstallerBufferSize))) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                }

                Err = RegQueryValueEx(hk[KeyIndex],
                                      (KeyIndex ? pszCoInstallers32
                                                : GuidString),
                                      NULL,
                                      &RegDataType,
                                      (PBYTE)CoInstallerBuffer,
                                      &CoInstallerBufferSize
                                     );

                if(Err == ERROR_MORE_DATA) {
                    //
                    // Buffer wasn't large enough--free current one and try again with new size.
                    //
                    MyFree(CoInstallerBuffer);
                    CoInstallerBuffer = NULL;
                } else {
                    break;
                }
            }

            //
            // Only out-of-memory errors are treated as fatal here.
            //
            if(Err == ERROR_NOT_ENOUGH_MEMORY) {
                leave;
            } else if(Err == ERROR_SUCCESS) {
                //
                // Make sure the buffer we got back looks valid.
                //
                if((RegDataType != REG_MULTI_SZ) || (CoInstallerBufferSize < sizeof(TCHAR))) {
                    Err = ERROR_INVALID_COINSTALLER;
                    leave;
                }

                //
                // Count the number of entries in this multi-sz list.
                //
                for(CoInstallerListSize = 0, CurEntry = CoInstallerBuffer;
                    *CurEntry;
                    CoInstallerListSize++, CurEntry += (lstrlen(CurEntry) + 1)
                   );

                if(!CoInstallerListSize) {
                    //
                    // List is empty, move on to next one.
                    //
                    continue;
                }

                //
                // Allocate (or reallocate) an array large enough to hold this
                // many co-installer entries.
                //
                if(CoInstallerList) {
                    TempCoInstallerList = MyRealloc(CoInstallerList,
                                                    (CoInstallerListSize + i) * sizeof(COINSTALLER_NODE)
                                                   );
                } else {
                    MYASSERT(i == 0);
                    TempCoInstallerList = MyMalloc(CoInstallerListSize * sizeof(COINSTALLER_NODE));
                }

                if(TempCoInstallerList) {
                    CoInstallerList = TempCoInstallerList;
                } else {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    leave;
                }

                //
                // Now loop through the list and get the co-installer for each
                // entry.
                //
                for(CurEntry = CoInstallerBuffer; *CurEntry; CurEntry += (lstrlen(CurEntry) + 1)) {
                    //
                    // Initialize the hinstance to NULL, so we'll know whether
                    // or not we need to free the module if we hit an exception
                    // here.
                    //
                    CoInstallerList[i].hinstCoInstaller = NULL;

                    Err = GetModuleEntryPoint(INVALID_HANDLE_VALUE,
                                              CurEntry,
                                              pszCoInstallerDefaultProc,
                                              &(CoInstallerList[i].hinstCoInstaller),
                                              &((FARPROC)CoInstallerList[i].CoInstallerEntryPoint),
                                              &(CoInstallerList[i].CoInstallerFusionContext),
                                              &MustAbort,
                                              InstallParamBlock->LogContext,
                                              hwndParent,
                                              ClassGuid,
                                              SetupapiVerifyCoInstProblem,
                                              DeviceDesc,
                                              DRIVERSIGN_NONE,
                                              TRUE,
                                              VerifyContext
                                             );

                    if(Err == NO_ERROR) {
                        i++;
                    } else {
                        //
                        // If the error we encountered above causes us to abort
                        // (e.g., due to a driver signing problem), then get
                        // out now.  Otherwise, just skip this failed entry and
                        // move on to the next.
                        //
                        if(MustAbort) {
                            leave;
                        }
                    }
                }
            }
            if(CoInstallerBuffer) {
                MyFree(CoInstallerBuffer);
                CoInstallerBuffer = NULL;
            }
        }

        //
        // If we get to here then we've successfully retrieved the co-installer
        // list(s)
        //
        Err = NO_ERROR;

    } except(pSetupExceptionFilter(GetExceptionCode())) {
        pSetupExceptionHandler(GetExceptionCode(), ERROR_INVALID_COINSTALLER, &Err);
    }

    if(CoInstallerBuffer) {
        MyFree(CoInstallerBuffer);
    }

    for(KeyIndex = 0; KeyIndex < 2; KeyIndex++) {
        if(hk[KeyIndex] != INVALID_HANDLE_VALUE) {
            RegCloseKey(hk[KeyIndex]);
        }
    }

    if(Err == NO_ERROR) {
        InstallParamBlock->CoInstallerList  = CoInstallerList;
        InstallParamBlock->CoInstallerCount = i;
    } else if(CoInstallerList) {
        MyFree(CoInstallerList);
    }

    return Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devinst.h ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devinst.h

Abstract:

    Private header file for setup device installation routines.

Author:

    Lonny McMichael (lonnym) 10-May-1995

Revision History:

--*/


//
// For now, define the size (in characters) of a GUID string,
// including terminating NULL.
//
#define GUID_STRING_LEN (39)

//
// Define the maximum number of IDs that may be present in an ID list
// (either HardwareID or CompatibleIDs).
//
#define MAX_HCID_COUNT (64)

//
// ISSUE: 2001/10/24-JamieHun REGSTR_VAL_SVCPAKCACHEPATH needs to be moved to regstr.h
// defined here for SP fixes so we don't affect public headers
//
#define REGSTR_VAL_SVCPAKCACHEPATH      TEXT("ServicePackCachePath")


//
// Global strings used by device installer routines.  Sizes are included
// so that we can do sizeof() instead of lstrlen() to determine string
// length.
//
// The content of the following strings is defined in regstr.h:
//
extern CONST TCHAR pszNoUseClass[SIZECHARS(REGSTR_VAL_NOUSECLASS)],
                   pszNoInstallClass[SIZECHARS(REGSTR_VAL_NOINSTALLCLASS)],
                   pszNoDisplayClass[SIZECHARS(REGSTR_VAL_NODISPLAYCLASS)],
                   pszDeviceDesc[SIZECHARS(REGSTR_VAL_DEVDESC)],
                   pszDevicePath[SIZECHARS(REGSTR_VAL_DEVICEPATH)],
                   pszPathSetup[SIZECHARS(REGSTR_PATH_SETUP)],
                   pszKeySetup[SIZECHARS(REGSTR_KEY_SETUP)],
                   pszPathRunOnce[SIZECHARS(REGSTR_PATH_RUNONCE)],
                   pszSourcePath[SIZECHARS(REGSTR_VAL_SRCPATH)],
                   pszSvcPackPath[SIZECHARS(REGSTR_VAL_SVCPAKSRCPATH)],
                   pszSvcPackCachePath[SIZECHARS(REGSTR_VAL_SVCPAKCACHEPATH)],
                   pszDriverCachePath[SIZECHARS(REGSTR_VAL_DRIVERCACHEPATH)],
                   pszBootDir[SIZECHARS(REGSTR_VAL_BOOTDIR)],
                   pszInsIcon[SIZECHARS(REGSTR_VAL_INSICON)],
                   pszInstaller32[SIZECHARS(REGSTR_VAL_INSTALLER_32)],
                   pszEnumPropPages32[SIZECHARS(REGSTR_VAL_ENUMPROPPAGES_32)],
                   pszInfPath[SIZECHARS(REGSTR_VAL_INFPATH)],
                   pszInfSection[SIZECHARS(REGSTR_VAL_INFSECTION)],
                   pszDrvDesc[SIZECHARS(REGSTR_VAL_DRVDESC)],
                   pszHardwareID[SIZECHARS(REGSTR_VAL_HARDWAREID)],
                   pszCompatibleIDs[SIZECHARS(REGSTR_VAL_COMPATIBLEIDS)],
                   pszDriver[SIZECHARS(REGSTR_VAL_DRIVER)],
                   pszConfigFlags[SIZECHARS(REGSTR_VAL_CONFIGFLAGS)],
                   pszMfg[SIZECHARS(REGSTR_VAL_MFG)],
                   pszService[SIZECHARS(REGSTR_VAL_SERVICE)],
                   pszProviderName[SIZECHARS(REGSTR_VAL_PROVIDER_NAME)],
                   pszFriendlyName[SIZECHARS(REGSTR_VAL_FRIENDLYNAME)],
                   pszServicesRegPath[SIZECHARS(REGSTR_PATH_SERVICES)],
                   pszInfSectionExt[SIZECHARS(REGSTR_VAL_INFSECTIONEXT)],
                   pszDeviceClassesPath[SIZECHARS(REGSTR_PATH_DEVICE_CLASSES)],
                   pszDeviceInstance[SIZECHARS(REGSTR_VAL_DEVICE_INSTANCE)],
                   pszDefault[SIZECHARS(REGSTR_VAL_DEFAULT)],
                   pszControl[SIZECHARS(REGSTR_KEY_CONTROL)],
                   pszLinked[SIZECHARS(REGSTR_VAL_LINKED)],
                   pszDeviceParameters[SIZECHARS(REGSTR_KEY_DEVICEPARAMETERS)],
                   pszLocationInformation[SIZECHARS(REGSTR_VAL_LOCATION_INFORMATION)],
                   pszCapabilities[SIZECHARS(REGSTR_VAL_CAPABILITIES)],
                   pszUiNumber[SIZECHARS(REGSTR_VAL_UI_NUMBER)],
                   pszRemovalPolicyOverride[SIZECHARS(REGSTR_VAL_REMOVAL_POLICY)],
                   pszUpperFilters[SIZECHARS(REGSTR_VAL_UPPERFILTERS)],
                   pszLowerFilters[SIZECHARS(REGSTR_VAL_LOWERFILTERS)],
                   pszMatchingDeviceId[SIZECHARS(REGSTR_VAL_MATCHINGDEVID)],
                   pszBasicProperties32[SIZECHARS(REGSTR_VAL_BASICPROPERTIES_32)],
                   pszCoInstallers32[SIZECHARS(REGSTR_VAL_COINSTALLERS_32)],
                   pszPathCoDeviceInstallers[SIZECHARS(REGSTR_PATH_CODEVICEINSTALLERS)],
                   pszSystem[SIZECHARS(REGSTR_KEY_SYSTEM)],
                   pszDrvSignPath[SIZECHARS(REGSTR_PATH_DRIVERSIGN)],
                   pszNonDrvSignPath[SIZECHARS(REGSTR_PATH_NONDRIVERSIGN)],
                   pszDrvSignPolicyPath[SIZECHARS(REGSTR_PATH_DRIVERSIGN_POLICY)],
                   pszNonDrvSignPolicyPath[SIZECHARS(REGSTR_PATH_NONDRIVERSIGN_POLICY)],
                   pszDrvSignPolicyValue[SIZECHARS(REGSTR_VAL_POLICY)],
                   pszDrvSignBehaviorOnFailedVerifyDS[SIZECHARS(REGSTR_VAL_BEHAVIOR_ON_FAILED_VERIFY)],
                   pszDriverDate[SIZECHARS(REGSTR_VAL_DRIVERDATE)],
                   pszDriverDateData[SIZECHARS(REGSTR_VAL_DRIVERDATEDATA)],
                   pszDriverVersion[SIZECHARS(REGSTR_VAL_DRIVERVERSION)],
                   pszDevSecurity[SIZECHARS(REGSTR_VAL_DEVICE_SECURITY_DESCRIPTOR)],
                   pszDevType[SIZECHARS(REGSTR_VAL_DEVICE_TYPE)],
                   pszExclusive[SIZECHARS(REGSTR_VAL_DEVICE_EXCLUSIVE)],
                   pszCharacteristics[SIZECHARS(REGSTR_VAL_DEVICE_CHARACTERISTICS)],
                   pszUiNumberDescFormat[SIZECHARS(REGSTR_VAL_UI_NUMBER_DESC_FORMAT)],
                   pszReinstallPath[SIZECHARS(REGSTR_PATH_REINSTALL)],
                   pszReinstallDeviceInstanceIds[SIZECHARS(REGSTR_VAL_REINSTALL_DEVICEINSTANCEIDS)],
                   pszReinstallDisplayName[SIZECHARS(REGSTR_VAL_REINSTALL_DISPLAYNAME)],
                   pszReinstallString[SIZECHARS(REGSTR_VAL_REINSTALL_STRING)];


//
// Other misc. global strings:
//
#define DISTR_INF_WILDCARD                (TEXT("*.inf"))
#define DISTR_OEMINF_WILDCARD             (TEXT("oem*.inf"))
#define DISTR_CI_DEFAULTPROC              (TEXT("ClassInstall"))
#define DISTR_UNIQUE_SUBKEY               (TEXT("\\%04u"))
#define DISTR_OEMINF_GENERATE             (TEXT("%s\\oem%d.inf"))
#define DISTR_OEMINF_DEFAULTPATH          (TEXT("A:\\"))
#define DISTR_DEFAULT_SERVICE             (TEXT("Default Service"))
#define DISTR_GUID_NULL                   (TEXT("{00000000-0000-0000-0000-000000000000}"))
#define DISTR_EVENTLOG                    (TEXT("\\EventLog"))
#define DISTR_GROUPORDERLIST_PATH         (REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\GroupOrderList"))
#define DISTR_SERVICEGROUPORDER_PATH      (REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\ServiceGroupOrder"))
#define DISTR_OPTIONS                     (TEXT("Options"))
#define DISTR_OPTIONSTEXT                 (TEXT("OptionsText"))
#define DISTR_LANGUAGESSUPPORTED          (TEXT("LanguagesSupported"))
#define DISTR_RUNONCE_EXE                 (TEXT("runonce"))
#define DISTR_GRPCONV                     (TEXT("grpconv -o"))
#define DISTR_GRPCONV_NOUI                (TEXT("grpconv -u"))
#define DISTR_DEFAULT_SYSPART             (TEXT("C:\\"))
#define DISTR_BASICPROP_DEFAULTPROC       (TEXT("BasicProperties"))
#define DISTR_ENUMPROP_DEFAULTPROC        (TEXT("EnumPropPages"))
#define DISTR_CODEVICEINSTALL_DEFAULTPROC (TEXT("CoDeviceInstall"))
#define DISTR_DRIVER_OBJECT_PATH_PREFIX   (TEXT("\\DRIVER\\"))      // must be uppercase!
#define DISTR_DRIVER_SIGNING_CLASSES      (TEXT("DriverSigningClasses"))
#define DISTR_PATH_EMBEDDED_NT_SECURITY   (TEXT("Software\\Microsoft\\EmbeddedNT\\Security"))
#define DISTR_VAL_MINIMIZE_FOOTPRINT      (TEXT("MinimizeFootprint"))
#define DISTR_VAL_DISABLE_SCE             (TEXT("DisableSCE"))

extern CONST TCHAR pszInfWildcard[SIZECHARS(DISTR_INF_WILDCARD)],
                   pszOemInfWildcard[SIZECHARS(DISTR_OEMINF_WILDCARD)],
                   pszCiDefaultProc[SIZECHARS(DISTR_CI_DEFAULTPROC)],
                   pszUniqueSubKey[SIZECHARS(DISTR_UNIQUE_SUBKEY)],
                   pszOemInfGenerate[SIZECHARS(DISTR_OEMINF_GENERATE)],
                   pszOemInfDefaultPath[SIZECHARS(DISTR_OEMINF_DEFAULTPATH)],
                   pszDefaultService[SIZECHARS(DISTR_DEFAULT_SERVICE)],
                   pszGuidNull[SIZECHARS(DISTR_GUID_NULL)],
                   pszEventLog[SIZECHARS(DISTR_EVENTLOG)],
                   pszGroupOrderListPath[SIZECHARS(DISTR_GROUPORDERLIST_PATH)],
                   pszServiceGroupOrderPath[SIZECHARS(DISTR_SERVICEGROUPORDER_PATH)],
                   pszOptions[SIZECHARS(DISTR_OPTIONS)],
                   pszOptionsText[SIZECHARS(DISTR_OPTIONSTEXT)],
                   pszLanguagesSupported[SIZECHARS(DISTR_LANGUAGESSUPPORTED)],
                   pszRunOnceExe[SIZECHARS(DISTR_RUNONCE_EXE)],
                   pszGrpConv[SIZECHARS(DISTR_GRPCONV)],
                   pszGrpConvNoUi[SIZECHARS(DISTR_GRPCONV_NOUI)],
                   pszDefaultSystemPartition[SIZECHARS(DISTR_DEFAULT_SYSPART)],
                   pszBasicPropDefaultProc[SIZECHARS(DISTR_BASICPROP_DEFAULTPROC)],
                   pszEnumPropDefaultProc[SIZECHARS(DISTR_ENUMPROP_DEFAULTPROC)],
                   pszCoInstallerDefaultProc[SIZECHARS(DISTR_CODEVICEINSTALL_DEFAULTPROC)],
                   pszDriverObjectPathPrefix[SIZECHARS(DISTR_DRIVER_OBJECT_PATH_PREFIX)],
                   pszDriverSigningClasses[SIZECHARS(DISTR_DRIVER_SIGNING_CLASSES)],
                   pszEmbeddedNTSecurity[SIZECHARS(DISTR_PATH_EMBEDDED_NT_SECURITY)],
                   pszMinimizeFootprint[SIZECHARS(DISTR_VAL_MINIMIZE_FOOTPRINT)],
                   pszDisableSCE[SIZECHARS(DISTR_VAL_DISABLE_SCE)];


//
// Global translation array for finding CM_DRP_* ordinal
// given property name or SPDRP_* value.
//
extern STRING_TO_DATA InfRegValToDevRegProp[];
extern STRING_TO_DATA InfRegValToClassRegProp[];

//
// Define a macro that does the DI-to-CM property translation
//
#define SPDRP_TO_CMDRP(i) (InfRegValToDevRegProp[(i)].Data)
//
// Class registry translation uses the same table
//
#define SPCRP_TO_CMCRP(i) (InfRegValToClassRegProp[(i)].Data)

//
// Define a value indicating a no-match ranking.
//
#define RANK_NO_MATCH (0xFFFFFFFF)

//
// Driver ranking bases. Lower Ranks are better.  Rank 0 is the best possible Rank.
// Any Rank less than 0x00001000 is a HardwareID match that is considered a good match.
//
#define RANK_HWID_INF_HWID_BASE 0x00000000      // For match with Hardware's HardwareID and INF's HardwareID
#define RANK_HWID_INF_CID_BASE  0x00001000      // For match with Hardware's HardwareID and INF's CompatibleID
#define RANK_CID_INF_HWID_BASE  0x00002000      // For match with Hardware's CompatibleID and INF's HardwareID
#define RANK_CID_INF_CID_BASE   0x00003000      // For match with Hardware's CompatibleID and INF's CompatibleID
#define RANK_CID_INF_CID_INC    0x00000100      // added to RANK_CID_INF_CID_BASE for each CompatID location

//
// Define special value used to indicate that one of our enumeration 'hint'
// indices is invalid.
//
#define INVALID_ENUM_INDEX  (0xFFFFFFFF)

//
// Define prototype of callback function supplied by class installers.
//
typedef DWORD (CALLBACK* CLASS_INSTALL_PROC) (
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData OPTIONAL
    );

//
// Define prototype of property sheet provider function--basically, an
// ExtensionPropSheetPageProc function with a (potentially) different name.
//
typedef BOOL (CALLBACK* PROPSHEET_PROVIDER_PROC) (
    IN PSP_PROPSHEETPAGE_REQUEST PropPageRequest,
    IN LPFNADDPROPSHEETPAGE lpfnAddPropSheetPageProc,
    IN LPARAM lParam
    );

//
// Define prototype of the co-installer function.
//
typedef DWORD (CALLBACK* COINSTALLER_PROC) (
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData, OPTIONAL
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    );


//
// Define structure for the internal representation of a single
// driver information node.
//
typedef struct _DRIVER_NODE {

    struct _DRIVER_NODE *Next;

    UINT Rank;

    FILETIME InfDate;

    LONG DrvDescription;

    //
    // Have to have both forms of the strings below because we must have both
    // case-insensitive (i.e., atom-like) behavior, and keep the original case
    // for display.
    //
    LONG DevDescription;
    LONG DevDescriptionDisplayName;

    LONG ProviderName;
    LONG ProviderDisplayName;

    LONG MfgName;
    LONG MfgDisplayName;

    LONG InfFileName;

    LONG InfSectionName;

    LONG HardwareId;

    DWORD NumCompatIds;

    PLONG CompatIdList;

    //
    // Store the index of the device ID that a compatible match was based on.  If
    // this was a HardwareId match, this value is -1, otherwise, it is the index
    // into the CompatIdList array of the device ID that matched.
    //
    LONG MatchingDeviceId;

    DWORD Flags;

    DWORD_PTR PrivateData;

    //
    // Store the GUID index INF's class from which this node came.  We need to do this,
    // in order to easily determine the class of the driver node (e.g., so that we
    // can change the device's class when a new driver node is selected).
    //
    LONG GuidIndex;

    FILETIME  DriverDate;
    DWORDLONG DriverVersion;

} DRIVER_NODE, *PDRIVER_NODE;


//
// Define structure to contain a co-installer entry.
//
typedef struct _COINSTALLER_NODE {
    HINSTANCE        hinstCoInstaller;
    COINSTALLER_PROC CoInstallerEntryPoint;
    HANDLE           CoInstallerFusionContext;
} COINSTALLER_NODE, *PCOINSTALLER_NODE;

//
// Define structure containing context information about co-installer
// callbacks for the duration of a DIF call.
//
typedef struct _COINSTALLER_INTERNAL_CONTEXT {
    COINSTALLER_CONTEXT_DATA Context;
    BOOL                     DoPostProcessing;
    COINSTALLER_PROC         CoInstallerEntryPoint;
    HANDLE                   CoInstallerFusionContext;
} COINSTALLER_INTERNAL_CONTEXT, *PCOINSTALLER_INTERNAL_CONTEXT;


//
// Define structure for the internal storage of device installation
// parameters.
//
typedef struct _DEVINSTALL_PARAM_BLOCK {

    //
    // Flags for controlling installation and UI functions.
    //
    DWORD Flags;
    DWORD FlagsEx;

    //
    // Specifies the window handle that will own UI related to this
    // installation.  MAY BE NULL.
    //
    HWND hwndParent;

    //
    // Installation message handling parameters.
    //
    PSP_FILE_CALLBACK InstallMsgHandler;
    PVOID             InstallMsgHandlerContext;
    BOOL              InstallMsgHandlerIsNativeCharWidth;

    //
    // Handle to a caller-supplied copy-queue.  If this handle is present,
    // then file copy/rename/delete operations will be queued to this handle
    // instead of being acted upon.  This will only happen if the DI_NOVCP
    // bit is set in the Flags field.
    // If no caller-supplied queue is present, this value is NULL
    // (_not_ INVALID_HANDLE_VALUE).
    //
    HSPFILEQ UserFileQ;

    //
    // Private DWORD reserved for Class Installer usage.
    //
    ULONG_PTR ClassInstallReserved;

    //
    // Specifies the string table index of an optional INF file
    // path.  If the string is not supplied, its index will be -1.
    //
    LONG DriverPath;

    //
    // Pointer to class installer parameters.  The first field of any class
    // installer parameter block is always a SP_CLASSINSTALL_HEADER structure.
    // The cbSize field of that structure gives the size, in bytes, of the header
    // (used for versioning), and the InstallFunction field gives the DI_FUNCTION
    // code that indicates how the parameter buffer is to be interpreted.
    // MAY BE NULL!
    //
    PSP_CLASSINSTALL_HEADER ClassInstallHeader;
    DWORD ClassInstallParamsSize;

    //
    // THE FOLLOWING PARAMETERS ARE NOT EXPOSED TO CALLERS (i.e., via
    // SetupDi(Get|Set)DeviceInstallParams).
    //

    HINSTANCE hinstClassInstaller;
    CLASS_INSTALL_PROC ClassInstallerEntryPoint;
    HANDLE             ClassInstallerFusionContext;

    HINSTANCE hinstClassPropProvider;
    PROPSHEET_PROVIDER_PROC ClassEnumPropPagesEntryPoint;
    HANDLE                  ClassEnumPropPagesFusionContext;

    HINSTANCE hinstDevicePropProvider;
    PROPSHEET_PROVIDER_PROC DeviceEnumPropPagesEntryPoint;
    HANDLE                  DeviceEnumPropPagesFusionContext;

    HINSTANCE hinstBasicPropProvider;
    PROPSHEET_PROVIDER_PROC EnumBasicPropertiesEntryPoint;
    HANDLE                  EnumBasicPropertiesFusionContext;

    //
    // Maintain a list of co-installers to be called along with the class installer.
    // The count will be -1 if the list hasn't been retrieved yet.
    //
    LONG CoInstallerCount;
    PCOINSTALLER_NODE CoInstallerList;

    //
    // Logging context -- this is only here because this struct is shared
    // by both DEVINFO_ELEM and DEVINFO_SET.
    //
    PSETUP_LOG_CONTEXT LogContext;

} DEVINSTALL_PARAM_BLOCK, *PDEVINSTALL_PARAM_BLOCK;


//
// Define structures used for associating lists of device interfaces with
// devinfo elements.
//
typedef struct _DEVICE_INTERFACE_NODE {

    struct _DEVICE_INTERFACE_NODE *Next;

    //
    // String table ID for this device interface's symbolic link name.
    //
    LONG SymLinkName;

    //
    // Store the interface class GUID index in each node.  We need to do this,
    // in order to easily determine the class of the node.
    //
    LONG GuidIndex;

    //
    // The Flags field contains the same flags as the client sees in their
    // SP_DEVICE_INTERFACE_DATA structure.
    //
    DWORD Flags;

    //
    // Store a back-pointer to the devinfo element, because device interfaces
    // may be enumerated outside the context of a device information element, 
    // and we need to know how to get back to the owning device instance.
    //
    struct _DEVINFO_ELEM *OwningDevInfoElem;

} DEVICE_INTERFACE_NODE, *PDEVICE_INTERFACE_NODE;

typedef struct _INTERFACE_CLASS_LIST {
    LONG                   GuidIndex;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;
    PDEVICE_INTERFACE_NODE DeviceInterfaceTruncateNode;  // used for rollback.
    DWORD                  DeviceInterfaceCount;
} INTERFACE_CLASS_LIST, *PINTERFACE_CLASS_LIST;


//
// Define flags for DiElemFlags field of DEVINFO_ELEM structure.
//
#define DIE_IS_PHANTOM      (0x00000001) // is this a phantom (not live) devinst?
#define DIE_IS_REGISTERED   (0x00000002) // has this devinst been registered?
#define DIE_IS_LOCKED       (0x00000004) // are we explicitly locked? (e.g.,
                                         // during some UI operation or nested
                                         // call into helper modules)

//
// Define structure for the internal representation of a single
// device information element.
//
typedef struct _DEVINFO_ELEM {
    //
    // Store the address of the containing devinfo set at the beginning of
    // this structure.  This is used for validation of a caller-supplied
    // SP_DEVINFO_DATA, and is more efficient than the previous method of
    // searching through all devinfo elements in the set to make sure the
    // specified element exists in the set.  This field should be zeroed
    // out when this element is destroyed.
    //
    struct _DEVICE_INFO_SET *ContainingDeviceInfoSet;

    //
    // Pointer to the next element in the set.
    //
    struct _DEVINFO_ELEM *Next;

    //
    // Specifies the device instance handle for this device.  This will
    // be a phantom device instance handle if DIE_IS_PHANTOM is set.
    //
    // This should always contain a handle, unless the device instance
    // handle could not be re-opened after a re-enumeration (in which case,
    // the DI_NEEDREBOOT flag will be set), or if the device information
    // element was globally removed or config-specific removed from the last
    // hardware profile.
    //
    DEVINST DevInst;

    //
    // Specifies the GUID for this device's class.
    //
    GUID ClassGuid;

    //
    // Specifies flags pertaining to this device information element.
    // These DIE_* flags are for internal use only.
    //
    DWORD DiElemFlags;

    //
    // List of class drivers for this element.
    //
    UINT          ClassDriverCount;
    PDRIVER_NODE  ClassDriverHead;
    PDRIVER_NODE  ClassDriverTail;

    //
    // class drivernode index 'hint' to speed up enumeration via
    // SetupDiEnumDriverInfo
    //
    PDRIVER_NODE ClassDriverEnumHint;       // may be NULL
    DWORD        ClassDriverEnumHintIndex;  // may be INVALID_ENUM_INDEX

    //
    // List of compatible drivers for this element.
    //
    UINT          CompatDriverCount;
    PDRIVER_NODE  CompatDriverHead;
    PDRIVER_NODE  CompatDriverTail;

    //
    // compatible drivernode index 'hint' to speed up enumeration via
    // SetupDiEnumDriverInfo
    //
    PDRIVER_NODE CompatDriverEnumHint;       // may be NULL
    DWORD        CompatDriverEnumHintIndex;  // may be INVALID_ENUM_INDEX

    //
    // Pointer to selected driver for this element (may be
    // NULL if none currently selected).  Whether this is a
    // class or compatible driver is specified by the
    // SelectedDriverType field.
    //
    PDRIVER_NODE  SelectedDriver;
    DWORD         SelectedDriverType;

    //
    // Installation parameter block.
    //
    DEVINSTALL_PARAM_BLOCK InstallParamBlock;

    //
    // Specifies the string table index of the device description.
    // If no description is known, this value will be -1.
    //
    // We store this string twice--once case-sensitively and once case-insensitively,
    // because we need it for displaying _and_ for fast lookup.
    //
    LONG DeviceDescription;
    LONG DeviceDescriptionDisplayName;

    //
    // Maintain an array of device interface lists.  These lists represent the 
    // device interfaces owned by this device instance (but only those that have 
    // been retrieved, e.g. by calling SetupDiGetClassDevs with the 
    // DIGCF_DEVICEINTERFACE flag).
    //
    // (This array pointer may be NULL.)
    //
    PINTERFACE_CLASS_LIST InterfaceClassList;
    DWORD                 InterfaceClassListSize;

    //
    // Extra (non-class installer) data associated with each device information element.
    // Only exposed via private API for use during GUI-mode setup.
    //
    DWORD Context;

} DEVINFO_ELEM, *PDEVINFO_ELEM;


//
// Structure containing dialog data for wizard pages.  (Amalgamation of
// DIALOGDATA structures defined in setupx and sysdm.)
//
typedef struct _SP_DIALOGDATA {

    INT             iBitmap;              // index into mini-icon bitmap

    HDEVINFO        DevInfoSet;           // DevInfo set we're working with
    PDEVINFO_ELEM   DevInfoElem;          // if DD_FLAG_USE_DEVINFO_ELEM flag set
    UINT            flags;

    HWND            hwndDrvList;          // window of the driver list
    HWND            hwndMfgList;          // window of the Manufacturer list

    BOOL            bShowCompat;

    BOOL            bKeeplpCompatDrvList;
    BOOL            bKeeplpClassDrvList;
    BOOL            bKeeplpSelectedDrv;

    LONG            iCurDesc;             // string table index for the description of currently
                                          // selected driver (or to-be-selected driver)

    BOOL            AuxThreadRunning;       // Is our class driver search thread still running?
    DWORD           PendingAction;          // What (if anything) should we do when it finishes?
    int             CurSelectionForSuccess; // If we have a pending successful return, what is the
                                            // listbox index for the successful selection?
    HIMAGELIST      hImageList;

    HFONT           hFontNormal;
    HFONT           hFontBold;

} SP_DIALOGDATA, *PSP_DIALOGDATA;

//
// Flags for SP_DIALOGDATA.flags:
//
#define DD_FLAG_USE_DEVINFO_ELEM   0x00000001
#define DD_FLAG_IS_DIALOGBOX       0x00000002
#define DD_FLAG_CLASSLIST_FAILED   0x00000004
#define DD_FLAG_SHOWSIMILARDRIVERS 0x00000008

//
// Pending Action codes used in the NEWDEVWIZ_DATA structure to indicate what
// should happen as soon as the auxilliary class driver search thread notifies us
// of its termination.
//
#define PENDING_ACTION_NONE             0
#define PENDING_ACTION_SELDONE          1
#define PENDING_ACTION_SHOWCLASS        2
#define PENDING_ACTION_CANCEL           3
#define PENDING_ACTION_OEM              4
#define PENDING_ACTION_WINDOWSUPDATE    5

//
// Icons that are associated with an item in the list view.
//
#define IMAGE_ICON_NOT_SIGNED           0
#define IMAGE_ICON_SIGNED               1
#define IMAGE_ICON_AUTHENTICODE_SIGNED  2

//
// Define structure used for internal state storage by Device Installer
// wizard pages.  (From NEWDEVWIZ_INSTANCE struct in Win95 sysdm.)
//
typedef struct _NEWDEVWIZ_DATA {

    SP_INSTALLWIZARD_DATA InstallData;

    SP_DIALOGDATA         ddData;

    BOOL                  bInit;
    UINT_PTR              idTimer;

} NEWDEVWIZ_DATA, *PNEWDEVWIZ_DATA;

//
// Define wizard page object structure used to ensure that wizard page
// buffer is kept as long as needed, and destroyed when no longer in use.
//
typedef struct _WIZPAGE_OBJECT {

    struct _WIZPAGE_OBJECT *Next;

    DWORD RefCount;

    PNEWDEVWIZ_DATA ndwData;

} WIZPAGE_OBJECT, *PWIZPAGE_OBJECT;


//
// Define driver list object structure used in the device information set
// to keep track of the various class driver lists that devinfo elements
// have referenced.
//
typedef struct _DRIVER_LIST_OBJECT {

    struct _DRIVER_LIST_OBJECT *Next;

    DWORD RefCount;

    //
    // We keep track of what parameters were used to create this driver
    // list, so that we can copy them to a new devinfo element during
    // inheritance.
    //
    DWORD ListCreationFlags;
    DWORD ListCreationFlagsEx;
    LONG ListCreationDriverPath;

    //
    // Also, keep track of what class this list was built for.  Although a
    // device's class may change, this GUID remains constant.
    //
    GUID ClassGuid;

    //
    // Actual driver list.  (This is also used as an ID used to find the
    // driver list object given a driver list head.  We can do this, since
    // we know that once a driver list is built, the head element never
    // changes.)
    //
    PDRIVER_NODE DriverListHead;

} DRIVER_LIST_OBJECT, *PDRIVER_LIST_OBJECT;


//
// Define node that tracks addition module handles to be unloaded when the
// device information set is destroyed.  This is used when a class installer,
// property page provider, or co-installer becomes invalid (e.g., as a result
// of a change in the device's class), but we can't unload the module yet.
//

typedef struct _MODULE_HANDLE_LIST_INSTANCE {
    HINSTANCE ModuleHandle;
    HANDLE    FusionContext;
} MODULE_HANDLE_LIST_INSTANCE,*PMODULE_HANDLE_LIST_INSTANCE;

typedef struct _MODULE_HANDLE_LIST_NODE {

    struct _MODULE_HANDLE_LIST_NODE *Next;

    DWORD ModuleCount;
    MODULE_HANDLE_LIST_INSTANCE ModuleList[ANYSIZE_ARRAY];

} MODULE_HANDLE_LIST_NODE, *PMODULE_HANDLE_LIST_NODE;

//
// Define flags for DiSetFlags field of DEVICE_INFO_SET structure.
//
#define DISET_IS_LOCKED (0x00000001) // Set is locked, and cannot be destroyed.

//
// Define structure for the internal representation of a
// device information set.
//
typedef struct _DEVICE_INFO_SET {

    //
    // Specifies whether there is a class GUID associated
    // with this set, and if so, what it is.
    //
    BOOL          HasClassGuid;
    GUID          ClassGuid;

    //
    // List of class drivers for this set.
    //
    UINT          ClassDriverCount;
    PDRIVER_NODE  ClassDriverHead;
    PDRIVER_NODE  ClassDriverTail;

    //
    // class drivernode index 'hint' to speed up enumeration via
    // SetupDiEnumDriverInfo
    //
    PDRIVER_NODE ClassDriverEnumHint;       // may be NULL
    DWORD        ClassDriverEnumHintIndex;  // may be INVALID_ENUM_INDEX

    //
    // Pointer to selected class driver for this device information
    // set (may be NULL if none currently selected).
    //
    PDRIVER_NODE  SelectedClassDriver;

    //
    // List of device information elements in the set.
    //
    UINT          DeviceInfoCount;
    PDEVINFO_ELEM DeviceInfoHead;
    PDEVINFO_ELEM DeviceInfoTail;

    //
    // devinfo element index 'hint' to speed up enumeration via
    // SetupDiEnumDeviceInfo
    //
    PDEVINFO_ELEM DeviceInfoEnumHint;       // may be NULL
    DWORD         DeviceInfoEnumHintIndex;  // may be INVALID_ENUM_INDEX

    //
    // Pointer to selected device for this device information set (may
    // be NULL if none currently selected).  This is used during
    // installation wizard.
    //
    PDEVINFO_ELEM SelectedDevInfoElem;

    //
    // Installation parameter block (for global class driver list, if
    // present).
    //
    DEVINSTALL_PARAM_BLOCK InstallParamBlock;

    //
    // Private string table.
    //
    PVOID StringTable;

    //
    // Maintain a list of currently-active wizard objects.  This allows us
    // to do the refcounting correctly for each object, and to keep the
    // set from being deleted until all wizard objects are destroyed.
    //
    PWIZPAGE_OBJECT WizPageList;

    //
    // Maintain a list of class driver lists that are currently being 
    // referenced by various devinfo elements, as well as by the device info 
    // set itself (i.e., for the current global class driver list.)
    //
    PDRIVER_LIST_OBJECT ClassDrvListObjectList;

    //
    // Maintain a reference count on how many times a thread has acquired
    // the lock on this device information set.  This indicates how deeply
    // nested we currently are in device installer calls.  The set can only
    // be deleted if this count is 1.
    //
    DWORD LockRefCount;

    //
    // Maintain a list of additional module handles we need to do a FreeLibrary
    // on when this device information set is destroyed.
    //
    PMODULE_HANDLE_LIST_NODE ModulesToFree;

    //
    // Maintain an array of class GUIDs for all driver nodes and device
    // interfaces used by members of this set.  (May be NULL.)
    //
    LPGUID GuidTable;
    DWORD  GuidTableSize;

    //
    // ConfigMgr machine name (string id) and handle, if this is a remote 
    // HDEVINFO set.
    //
    LONG     MachineName;   // -1 if local
    HMACHINE hMachine;      // NULL if local

    //
    // Maintain any applicable DISET_* flags for this HDEVINFO set.
    //
    DWORD DiSetFlags;

    //
    // Synchronization
    //
    MYLOCK Lock;

} DEVICE_INFO_SET, *PDEVICE_INFO_SET;

#define LockDeviceInfoSet(d)   BeginSynchronizedAccess(&((d)->Lock))

#define UnlockDeviceInfoSet(d)          \
                                        \
    ((d)->LockRefCount)--;              \
    EndSynchronizedAccess(&((d)->Lock))


//
// Define structures for global mini-icon storage.
//
typedef struct _CLASSICON {

    CONST GUID        *ClassGuid;
    UINT               MiniBitmapIndex;
    struct _CLASSICON *Next;

} CLASSICON, *PCLASSICON;

typedef struct _MINI_ICON_LIST {

    //
    // HDC for memory containing mini-icon bitmap
    //
    HDC hdcMiniMem;

    //
    // Handle to the bitmap image for the mini-icons
    //
    HBITMAP hbmMiniImage;

    //
    // Handle to the bitmap image for the mini-icon mask.
    //
    HBITMAP hbmMiniMask;

    //
    // Number of mini-icons in the bitmap
    //
    UINT NumClassImages;

    //
    // Head of list for installer-provided class icons.
    //
    PCLASSICON ClassIconList;

    //
    // Synchronization
    //
    MYLOCK Lock;

} MINI_ICON_LIST, *PMINI_ICON_LIST;

#define LockMiniIconList(d)   BeginSynchronizedAccess(&((d)->Lock))
#define UnlockMiniIconList(d) EndSynchronizedAccess(&((d)->Lock))

//
// Global mini-icon list.
//
extern MINI_ICON_LIST GlobalMiniIconList;




typedef struct _CLASS_IMAGE_LIST {

    //
    // Index of the "Unknown" class image
    //
    int         UnknownImageIndex;

    //
    // List of class guids
    //
    LPGUID      ClassGuidList;

    //
    // Head of linked list of class icons.
    //
    PCLASSICON  ClassIconList;

    //
    // Synchronization
    //
    MYLOCK      Lock;

} CLASS_IMAGE_LIST, *PCLASS_IMAGE_LIST;


#define LockImageList(d)   BeginSynchronizedAccess(&((d)->Lock))
#define UnlockImageList(d) EndSynchronizedAccess(&((d)->Lock))


typedef struct _DRVSEARCH_INPROGRESS_NODE {

    struct _DRVSEARCH_INPROGRESS_NODE *Next;

    //
    // Handle of device information set for which driver list is
    // currently being built.
    //
    HDEVINFO DeviceInfoSet;

    //
    // Flag indicating that the driver search should be aborted.
    //
    BOOL CancelSearch;

    //
    // Event handle that auxiliary thread waits on once it has set
    // the 'CancelSearch' flag (and once it has release the list
    // lock).  When the thread doing the search notices the cancel
    // request, it will signal the event, thus the waiting thread
    // can ensure that the search has been cancelled before it returns.
    //
    HANDLE SearchCancelledEvent;

} DRVSEARCH_INPROGRESS_NODE, *PDRVSEARCH_INPROGRESS_NODE;

typedef struct _DRVSEARCH_INPROGRESS_LIST {

    //
    // Head of linked list containing nodes for each device information
    // set for which a driver search is currently underway.
    //
    PDRVSEARCH_INPROGRESS_NODE DrvSearchHead;

    //
    // Synchronization
    //
    MYLOCK Lock;

} DRVSEARCH_INPROGRESS_LIST, *PDRVSEARCH_INPROGRESS_LIST;

#define LockDrvSearchInProgressList(d)   BeginSynchronizedAccess(&((d)->Lock))
#define UnlockDrvSearchInProgressList(d) EndSynchronizedAccess(&((d)->Lock))

//
// Global "Driver Search In-Progress" list.
//
extern DRVSEARCH_INPROGRESS_LIST GlobalDrvSearchInProgressList;


//
// Device Information Set manipulation routines
//
PDEVICE_INFO_SET
AllocateDeviceInfoSet(
    VOID
    );

VOID
DestroyDeviceInfoElement(
    IN HDEVINFO         hDevInfo,
    IN PDEVICE_INFO_SET pDeviceInfoSet,
    IN PDEVINFO_ELEM    DeviceInfoElement
    );

DWORD
DestroyDeviceInfoSet(
    IN HDEVINFO         hDevInfo,      OPTIONAL
    IN PDEVICE_INFO_SET pDeviceInfoSet
    );

PDEVICE_INFO_SET
AccessDeviceInfoSet(
    IN HDEVINFO DeviceInfoSet
    );

PDEVICE_INFO_SET
CloneDeviceInfoSet(
    IN HDEVINFO hDevInfo
    );

PDEVICE_INFO_SET
RollbackDeviceInfoSet(
    IN HDEVINFO hDevInfo,
    IN PDEVICE_INFO_SET ClonedDeviceInfoSet
    );

PDEVICE_INFO_SET
CommitDeviceInfoSet(
    IN HDEVINFO hDevInfo,
    IN PDEVICE_INFO_SET ClonedDeviceInfoSet
    );

PDEVINFO_ELEM
FindDevInfoByDevInst(
    IN  PDEVICE_INFO_SET  DeviceInfoSet,
    IN  DEVINST           DevInst,
    OUT PDEVINFO_ELEM    *PrevDevInfoElem OPTIONAL
    );

BOOL
DevInfoDataFromDeviceInfoElement(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PDEVINFO_ELEM    DevInfoElem,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    );

PDEVINFO_ELEM
FindAssociatedDevInfoElem(
    IN  PDEVICE_INFO_SET  DeviceInfoSet,
    IN  PSP_DEVINFO_DATA  DeviceInfoData,
    OUT PDEVINFO_ELEM    *PreviousElement OPTIONAL
    );


//
// Driver Node manipulation routines.
//
DWORD
CreateDriverNode(
    IN  UINT          Rank,
    IN  PCTSTR        DevDescription,
    IN  PCTSTR        DrvDescription,
    IN  PCTSTR        ProviderName,   OPTIONAL
    IN  PCTSTR        MfgName,
    IN  PFILETIME     InfDate,
    IN  PCTSTR        InfFileName,
    IN  PCTSTR        InfSectionName,
    IN  PVOID         StringTable,
    IN  LONG          InfClassGuidIndex,
    OUT PDRIVER_NODE *DriverNode
    );

PDRIVER_LIST_OBJECT
GetAssociatedDriverListObject(
    IN  PDRIVER_LIST_OBJECT  ObjectListHead,
    IN  PDRIVER_NODE         DriverListHead,
    OUT PDRIVER_LIST_OBJECT *PrevDriverListObject OPTIONAL
    );

VOID
DereferenceClassDriverList(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PDRIVER_NODE     DriverListHead OPTIONAL
    );

VOID
DestroyDriverNodes(
    IN PDRIVER_NODE DriverNode,
    IN PDEVICE_INFO_SET pDeviceInfoSet OPTIONAL
    );

BOOL
DrvInfoDataFromDriverNode(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PDRIVER_NODE     DriverNode,
    IN  DWORD            DriverType,
    OUT PSP_DRVINFO_DATA DriverInfoData
    );

PDRIVER_NODE
FindAssociatedDriverNode(
    IN  PDRIVER_NODE      DriverListHead,
    IN  PSP_DRVINFO_DATA  DriverInfoData,
    OUT PDRIVER_NODE     *PreviousNode    OPTIONAL
    );

PDRIVER_NODE
SearchForDriverNode(
    IN  PVOID             StringTable,
    IN  PDRIVER_NODE      DriverListHead,
    IN  PSP_DRVINFO_DATA  DriverInfoData,
    OUT PDRIVER_NODE     *PreviousNode    OPTIONAL
    );

DWORD
DrvInfoDetailsFromDriverNode(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDRIVER_NODE            DriverNode,
    OUT PSP_DRVINFO_DETAIL_DATA DriverInfoDetailData, OPTIONAL
    IN  DWORD                   BufferSize,
    OUT PDWORD                  RequiredSize          OPTIONAL
    );


//
// Installation parameter manipulation routines
//
DWORD
GetDevInstallParams(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    OUT PSP_DEVINSTALL_PARAMS   DeviceInstallParams
    );

DWORD
GetClassInstallParams(
    IN  PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    OUT PSP_CLASSINSTALL_HEADER ClassInstallParams, OPTIONAL
    IN  DWORD                   BufferSize,
    OUT PDWORD                  RequiredSize        OPTIONAL
    );

DWORD
SetDevInstallParams(
    IN OUT PDEVICE_INFO_SET        DeviceInfoSet,
    IN     PSP_DEVINSTALL_PARAMS   DeviceInstallParams,
    OUT    PDEVINSTALL_PARAM_BLOCK DevInstParamBlock,
    IN     BOOL                    MsgHandlerIsNativeCharWidth
    );

DWORD
SetClassInstallParams(
    IN OUT PDEVICE_INFO_SET        DeviceInfoSet,
    IN     PSP_CLASSINSTALL_HEADER ClassInstallParams,    OPTIONAL
    IN     DWORD                   ClassInstallParamsSize,
    OUT    PDEVINSTALL_PARAM_BLOCK DevInstParamBlock
    );

VOID
DestroyInstallParamBlock(
    IN HDEVINFO                hDevInfo,         OPTIONAL
    IN PDEVICE_INFO_SET        pDeviceInfoSet,
    IN PDEVINFO_ELEM           DevInfoElem,      OPTIONAL
    IN PDEVINSTALL_PARAM_BLOCK InstallParamBlock
    );

DWORD
GetDrvInstallParams(
    IN  PDRIVER_NODE          DriverNode,
    OUT PSP_DRVINSTALL_PARAMS DriverInstallParams
    );

DWORD
SetDrvInstallParams(
    IN  PSP_DRVINSTALL_PARAMS DriverInstallParams,
    OUT PDRIVER_NODE          DriverNode
    );


//
// String Table helper functions
//
LONG
AddMultiSzToStringTable(
    IN  PVOID   StringTable,
    IN  PTCHAR  MultiSzBuffer,
    OUT PLONG   StringIdList,
    IN  DWORD   StringIdListSize,
    IN  BOOL    CaseSensitive,
    OUT PTCHAR *UnprocessedBuffer    OPTIONAL
    );

LONG
LookUpStringInDevInfoSet(
    IN HDEVINFO DeviceInfoSet,
    IN PTSTR    String,
    IN BOOL     CaseSensitive
    );


//
// INF processing functions
//

typedef struct _DRVSEARCH_CONTEXT {
    PDRIVER_NODE           *pDriverListHead;
    PDRIVER_NODE           *pDriverListTail;
    PUINT                   pDriverCount;
    GUID                    ClassGuid;
    PDEVICE_INFO_SET        DeviceInfoSet;
    DWORD                   Flags;
    BOOL                    BuildClassDrvList;
    LONG                    IdList[2][MAX_HCID_COUNT+1]; // leave extra entry for '-1' end-of-list marker.
    PVOID                   StringTable;
    PBOOL                   CancelSearch;
    TCHAR                   ClassGuidString[GUID_STRING_LEN];
    TCHAR                   ClassName[MAX_CLASS_NAME_LEN];
    LONG                    InstalledDescription;
    LONG                    InstalledMfgName;
    LONG                    InstalledProviderName;
    LONG                    InstalledInfSection;
    LONG                    InstalledInfSectionExt;
    LONG                    InstalledMatchingDeviceId;
    PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo;        // may be NULL
    VERIFY_CONTEXT          VerifyContext;
} DRVSEARCH_CONTEXT, *PDRVSEARCH_CONTEXT;

//
// DRVSEARCH_CONTEXT.Flags
//
#define DRVSRCH_HASCLASSGUID             0x00000001
#define DRVSRCH_FILTERCLASS              0x00000002
#define DRVSRCH_TRY_PNF                  0x00000004
#define DRVSRCH_UNUSED1                  0x00000008 // obsolete DRVSRCH_USEOLDINFS flag
#define DRVSRCH_FROM_INET                0x00000010
#define DRVSRCH_CLEANUP_SOURCE_PATH      0x00000020
#define DRVSRCH_EXCLUDE_OLD_INET_DRIVERS 0x00000040
#define DRVSRCH_ALLOWEXCLUDEDDRVS        0x00000080
#define DRVSRCH_FILTERSIMILARDRIVERS     0x00000100
#define DRVSRCH_INSTALLEDDRIVER          0x00000200
#define DRVSRCH_NO_CLASSLIST_NODE_MERGE  0x00000400

DWORD
EnumSingleDrvInf(
    IN     PCTSTR                       InfName,
    IN OUT LPWIN32_FIND_DATA            InfFileData,
    IN     DWORD                        SearchControl,
    IN     InfCacheCallback             EnumInfCallback,
    IN     PSETUP_LOG_CONTEXT           LogContext,
    IN OUT PDRVSEARCH_CONTEXT           Context
    );

DWORD
EnumDrvInfsInDirPathList(
    IN     PCTSTR                       DirPathList, OPTIONAL
    IN     DWORD                        SearchControl,
    IN     InfCacheCallback             EnumInfCallback,
    IN     BOOL                         IgnoreNonCriticalErrors,
    IN     PSETUP_LOG_CONTEXT           LogContext,
    IN OUT PDRVSEARCH_CONTEXT           Context
    );

BOOL
GetDecoratedModelsSection(
    IN  PSETUP_LOG_CONTEXT      LogContext,            OPTIONAL
    IN  PLOADED_INF             Inf,
    IN  PINF_LINE               MfgListLine,
    IN  PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,       OPTIONAL
    OUT PTSTR                   DecoratedModelsSection OPTIONAL
    );

PTSTR
GetFullyQualifiedMultiSzPathList(
    IN PCTSTR PathList
    );

BOOL
pRemoveDirectory(
    PTSTR Path
    );

BOOL
ShouldClassBeExcluded(
    IN LPGUID ClassGuid,
    IN BOOL   ExcludeNoInstallClass
    );

BOOL
ClassGuidFromInfVersionNode(
    IN  PINF_VERSION_NODE VersionNode,
    OUT LPGUID            ClassGuid
    );

VOID
AppendLoadIncludedInfs(
    IN HINF   hDeviceInf,
    IN PCTSTR InfFileName,
    IN PCTSTR InfSectionName,
    IN BOOL   AppendLayoutInfs
    );

DWORD
InstallFromInfSectionAndNeededSections(
    IN HWND              Owner,             OPTIONAL
    IN HINF              InfHandle,
    IN PCTSTR            SectionName,
    IN UINT              Flags,
    IN HKEY              RelativeKeyRoot,   OPTIONAL
    IN PCTSTR            SourceRootPath,    OPTIONAL
    IN UINT              CopyFlags,
    IN PSP_FILE_CALLBACK MsgHandler,
    IN PVOID             Context,           OPTIONAL
    IN HDEVINFO          DeviceInfoSet,     OPTIONAL
    IN PSP_DEVINFO_DATA  DeviceInfoData,    OPTIONAL
    IN HSPFILEQ          UserFileQ          OPTIONAL
    );

DWORD
MarkQueueForDeviceInstall(
    IN HSPFILEQ QueueHandle,
    IN HINF     DeviceInfHandle,
    IN PCTSTR   DeviceDesc       OPTIONAL
    );


//
// Icon list manipulation functions.
//
BOOL
InitMiniIconList(
    VOID
    );

BOOL
DestroyMiniIconList(
    VOID
    );


//
// "Driver Search In-Progress" list functions.
//
BOOL
InitDrvSearchInProgressList(
    VOID
    );

BOOL
DestroyDrvSearchInProgressList(
    VOID
    );


//
// 'helper module' manipulation functions.
//
DWORD
GetModuleEntryPoint(
    IN     HKEY                    hk,                    OPTIONAL
    IN     LPCTSTR                 RegistryValue,
    IN     LPCTSTR                 DefaultProcName,
    OUT    HINSTANCE              *phinst,
    OUT    FARPROC                *pEntryPoint,
    OUT    HANDLE                 *pFusionContext,
    OUT    BOOL                   *pMustAbort,            OPTIONAL
    IN     PSETUP_LOG_CONTEXT      LogContext,            OPTIONAL
    IN     HWND                    Owner,                 OPTIONAL
    IN     CONST GUID             *DeviceSetupClassGuid,  OPTIONAL
    IN     SetupapiVerifyProblem   Problem,
    IN     LPCTSTR                 DeviceDesc,            OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   NoUI,
    IN OUT PVERIFY_CONTEXT         VerifyContext          OPTIONAL
    );

//
// Define flags for InvalidateHelperModules
//
#define IHM_COINSTALLERS_ONLY     0x00000001
#define IHM_FREE_IMMEDIATELY      0x00000002

DWORD
InvalidateHelperModules(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN DWORD            Flags
    );

//
// Define flags for _SetupDiCallClassInstaller
//
#define CALLCI_LOAD_HELPERS     0x00000001
#define CALLCI_CALL_HELPERS     0x00000002
#define CALLCI_ALLOW_DRVSIGN_UI 0x00000004

DWORD
_SetupDiCallClassInstaller(
    IN DI_FUNCTION      InstallFunction,
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,      OPTIONAL
    IN DWORD            Flags
    );


//
// OEM driver selection routines.
//
DWORD
SelectOEMDriver(
    IN HWND             hwndParent,     OPTIONAL
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData, OPTIONAL
    IN BOOL             IsWizard
    );


//
// Registry helper routines.
//
DWORD
pSetupDeleteDevRegKeys(
    IN DEVINST  DevInst,
    IN DWORD    Scope,
    IN DWORD    HwProfile,
    IN DWORD    KeyType,
    IN BOOL     DeleteUserKeys,
    IN HMACHINE hMachine        OPTIONAL
    );

VOID
GetRegSubkeysFromDeviceInterfaceName(
    IN OUT PTSTR  DeviceInterfaceName,
    OUT    PTSTR *SubKeyName
    );

LONG
OpenDeviceInterfaceSubKey(
    IN     HKEY   hKeyInterfaceClass,
    IN     PCTSTR DeviceInterfaceName,
    IN     REGSAM samDesired,
    OUT    PHKEY  phkResult,
    OUT    PTSTR  OwningDevInstName,    OPTIONAL
    IN OUT PDWORD OwningDevInstNameSize OPTIONAL
    );


//
// Guid table routines.
//
LONG
AddOrGetGuidTableIndex(
    IN PDEVICE_INFO_SET  DeviceInfoSet,
    IN CONST GUID       *ClassGuid,
    IN BOOL              AddIfNotPresent
    );


//
// Device interface routines.
//
PINTERFACE_CLASS_LIST
AddOrGetInterfaceClassList(
    IN PDEVICE_INFO_SET DeviceInfoSet,
    IN PDEVINFO_ELEM    DevInfoElem,
    IN LONG             InterfaceClassGuidIndex,
    IN BOOL             AddIfNotPresent
    );

BOOL
DeviceInterfaceDataFromNode(
    IN  PDEVICE_INTERFACE_NODE     DeviceInterfaceNode,
    IN  CONST GUID                *InterfaceClassGuid,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData
    );

PDEVINFO_ELEM
FindDevInfoElemForDeviceInterface(
    IN PDEVICE_INFO_SET          DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    );


//
// Service installation routines.
//
typedef struct _SVCNAME_NODE {
    struct _SVCNAME_NODE *Next;
    TCHAR Name[MAX_SERVICE_NAME_LEN];
    BOOL DeleteEventLog;
    TCHAR EventLogType[256];
    TCHAR EventLogName[256];
    DWORD Flags;
} SVCNAME_NODE, *PSVCNAME_NODE;

//
// Define an additional (private) SPSVCINST flag for
// InstallNtService.
//
#define SPSVCINST_NO_DEVINST_CHECK  (0x80000000)

DWORD
InstallNtService(
    IN  PDEVINFO_ELEM    DevInfoElem,        OPTIONAL
    IN  HINF             hDeviceInf,
    IN  PCTSTR                   InfFileName,            OPTIONAL
    IN  PCTSTR           szSectionName,      OPTIONAL
    OUT PSVCNAME_NODE   *ServicesToDelete,   OPTIONAL
    IN  DWORD            Flags,
    OUT PBOOL            NullDriverInstalled
    );

//
// Ansi/Unicode conversion routines.
//
DWORD
pSetupDiDevInstParamsAnsiToUnicode(
    IN  PSP_DEVINSTALL_PARAMS_A AnsiDevInstParams,
    OUT PSP_DEVINSTALL_PARAMS_W UnicodeDevInstParams
    );

DWORD
pSetupDiDevInstParamsUnicodeToAnsi(
    IN  PSP_DEVINSTALL_PARAMS_W UnicodeDevInstParams,
    OUT PSP_DEVINSTALL_PARAMS_A AnsiDevInstParams
    );

DWORD
pSetupDiSelDevParamsAnsiToUnicode(
    IN  PSP_SELECTDEVICE_PARAMS_A AnsiSelDevParams,
    OUT PSP_SELECTDEVICE_PARAMS_W UnicodeSelDevParams
    );

DWORD
pSetupDiSelDevParamsUnicodeToAnsi(
    IN  PSP_SELECTDEVICE_PARAMS_W UnicodeSelDevParams,
    OUT PSP_SELECTDEVICE_PARAMS_A AnsiSelDevParams
    );

DWORD
pSetupDiDrvInfoDataAnsiToUnicode(
    IN  PSP_DRVINFO_DATA_A AnsiDrvInfoData,
    OUT PSP_DRVINFO_DATA_W UnicodeDrvInfoData
    );

DWORD
pSetupDiDrvInfoDataUnicodeToAnsi(
    IN  PSP_DRVINFO_DATA_W UnicodeDrvInfoData,
    OUT PSP_DRVINFO_DATA_A AnsiDrvInfoData
    );

DWORD
pSetupDiDevInfoSetDetailDataUnicodeToAnsi(
    IN  PSP_DEVINFO_LIST_DETAIL_DATA_W UnicodeDevInfoSetDetails,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_A AnsiDevInfoSetDetails
    );

//
// Misc. utility routines
//
DWORD
MapCrToSpErrorEx(
    IN CONFIGRET CmReturnCode,
    IN DWORD     Default,
    IN BOOL      BackwardCompatible
    );

//
// Define a macro to perform the backward-compatible mapping.  New code should
// NOT use this macro, and should instead use the CR_TO_SP macro.
//
#define MapCrToSpError(CmReturnCode,Default) MapCrToSpErrorEx((CmReturnCode),(Default),TRUE)

//
// This macro should be used by all newly-added code to map CONFIGRET errors to
// their setupapi (Win32) counterparts.
//
#define CR_TO_SP(CmReturnCode,Default) MapCrToSpErrorEx((CmReturnCode),(Default),FALSE)


VOID
SetDevnodeNeedsRebootProblemWithArg2(
    IN PDEVINFO_ELEM DevInfoElem,
    IN PDEVICE_INFO_SET DevInfoSet,
    IN DWORD    Reason,                  OPTIONAL
    IN ULONG_PTR Arg1,                   OPTIONAL
    IN ULONG_PTR Arg2                    OPTIONAL
    );

#define SetDevnodeNeedsRebootProblemWithArg(DevInfoElem,DevInfoSet,Reason,Arg) SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,DevInfoSet,Reason,Arg,0)
#define SetDevnodeNeedsRebootProblem(DevInfoElem,DevInfoSet,Reason) SetDevnodeNeedsRebootProblemWithArg2(DevInfoElem,DevInfoSet,Reason,0,0)

BOOL
GetBestDeviceDesc(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,  OPTIONAL
    OUT PTSTR            DeviceDescBuffer
    );

DWORD
__inline
pSetupGetLastError(

#if ASSERTS_ON
    IN PCSTR Filename,
    IN DWORD Line
#else
    VOID
#endif

    )
/*++

Routine Description:

    This inline routine retrieves a Win32 error, and guarantees that the error
    isn't NO_ERROR.  This routine should not be called unless the preceding
    call failed, and GetLastError() is supposed to contain the problem's cause.

Arguments:

    If asserts are turned on, this function takes the (ANSI) Filename of the 
    source file that called the failing function, and also the DWORD Line
    number where the call was made.  This makes it much easier to debug
    scenarios where the failing function didn't set last error when it was
    supposed to.

Return Value:

    Win32 error code retrieved via GetLastError(), or ERROR_UNIDENTIFIED_ERROR
    if GetLastError() returned NO_ERROR.

--*/
{
    DWORD Err = GetLastError();

#if ASSERTS_ON
    if(Err == NO_ERROR) { 
        AssertFail(Filename,
                   Line,
                   "GetLastError() != NO_ERROR",
                   FALSE
                  ); 
    }
#endif

    return ((Err == NO_ERROR) ? ERROR_UNIDENTIFIED_ERROR : Err);
}


//
// Macro to simplify calling of a function that reports error status via
// GetLastError().  This macro allows the caller to specify what Win32 error
// code should be returned if the function reports success.  (If the default of
// NO_ERROR is desired, use the GLE_FN_CALL macro instead.)
//
// The "prototype" of this macro is as follows:
//
// DWORD
// GLE_FN_CALL_WITH_SUCCESS(
//     SuccessfulStatus, // Win32 error code to return if function succeeded
//     FailureIndicator, // value returned by function to indicate failure (e.g., FALSE, NULL, INVALID_HANDLE_VALUE)
//     FunctionCall      // actual call to the function
// );
//

#if ASSERTS_ON

#define GLE_FN_CALL_WITH_SUCCESS(SuccessfulStatus,         \
                                 FailureIndicator,         \
                                 FunctionCall)             \
                                                           \
            (SetLastError(NO_ERROR),                       \
             (((FunctionCall) != (FailureIndicator))       \
                 ? (SuccessfulStatus)                      \
                 : pSetupGetLastError(__FILE__, __LINE__)))
#else

#define GLE_FN_CALL_WITH_SUCCESS(SuccessfulStatus,         \
                                 FailureIndicator,         \
                                 FunctionCall)             \
                                                           \
            (SetLastError(NO_ERROR),                       \
             (((FunctionCall) != (FailureIndicator))       \
                 ? (SuccessfulStatus)                      \
                 : pSetupGetLastError()))
                 
#endif

//
// Macro to simplify calling of a function that reports error status via
// GetLastError().  If the function call is successful, NO_ERROR is returned.
// (To specify an alternate value returned upon success, use the
// GLE_FN_CALL_WITH_SUCCESS macro instead.)
//
// The "prototype" of this macro is as follows:
//
// DWORD
// GLE_FN_CALL(
//     FailureIndicator, // value returned by function to indicate failure (e.g., FALSE, NULL, INVALID_HANDLE_VALUE)
//     FunctionCall      // actual call to the function
// );
//

#define GLE_FN_CALL(FailureIndicator, FunctionCall)                           \
            GLE_FN_CALL_WITH_SUCCESS(NO_ERROR, FailureIndicator, FunctionCall)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devinfo.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devinfo.c

Abstract:

    Device Installer routines dealing with device information sets

Author:

    Lonny McMichael (lonnym) 10-May-1995

Revision History:

    Jamie Hunter (JamieHun) July-19-2002
            Reviewed "unsafe" functions

--*/

#include "precomp.h"
#pragma hdrstop

//
// Define the context structure used by the default device comparison
// callback (used by SetupDiRegisterDeviceInfo).
//
typedef struct _DEFAULT_DEVCMP_CONTEXT {

    PCS_RESOURCE NewDevCsResource;
    PCS_RESOURCE CurDevCsResource;
    ULONG        CsResourceSize;    // applies to both buffers.

} DEFAULT_DEVCMP_CONTEXT, *PDEFAULT_DEVCMP_CONTEXT;


//
// Private routine prototypes.
//
DWORD
pSetupOpenAndAddNewDevInfoElem(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  PCTSTR           DeviceInstanceId,
    IN  BOOL             AllowPhantom,
    IN  CONST GUID      *ClassGuid,              OPTIONAL
    IN  HWND             hwndParent,             OPTIONAL
    OUT PDEVINFO_ELEM   *DevInfoElem,
    IN  BOOL             CheckIfAlreadyThere,
    OUT PBOOL            AlreadyPresent,         OPTIONAL
    IN  BOOL             OpenExistingOnly,
    IN  ULONG            CmLocateFlags,
    IN  PDEVICE_INFO_SET ContainingDeviceInfoSet
    );

DWORD
pSetupAddNewDeviceInfoElement(
    IN  PDEVICE_INFO_SET DeviceInfoSet,
    IN  DEVINST          DevInst,
    IN  CONST GUID      *ClassGuid,
    IN  PCTSTR           Description,             OPTIONAL
    IN  HWND             hwndParent,              OPTIONAL
    IN  DWORD            DiElemFlags,
    IN  PDEVICE_INFO_SET ContainingDeviceInfoSet,
    OUT PDEVINFO_ELEM   *DeviceInfoElement
    );

DWORD
pSetupClassGuidFromDevInst(
    IN  DEVINST DevInst,
    IN  HMACHINE hMachine,
    OUT LPGUID  ClassGuid
    );

DWORD
pSetupDupDevCompare(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA NewDeviceData,
    IN PSP_DEVINFO_DATA ExistingDeviceData,
    IN PVOID            CompareContext
    );

DWORD
pSetupAddDeviceInterfaceToDevInfoElem(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDEVINFO_ELEM           DevInfoElem,
    IN  CONST GUID             *ClassGuid,
    IN  PTSTR                   DeviceInterfaceName,
    IN  BOOL                    IsActive,
    IN  BOOL                    IsDefault,
    IN  BOOL                    StoreTruncateNode,
    IN  BOOL                    OpenExistingOnly,
    OUT PDEVICE_INTERFACE_NODE *DeviceInterfaceNode  OPTIONAL
    );

DWORD
_SetupDiOpenDeviceInterface(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PTSTR                     DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    );

DWORD
pSetupGetDevInstNameAndStatusForDeviceInterface(
    IN  HKEY   hKeyInterfaceClass,
    IN  PCTSTR DeviceInterfaceName,
    OUT PTSTR  OwningDevInstName,     OPTIONAL
    IN  DWORD  OwningDevInstNameSize,
    OUT PBOOL  IsActive,              OPTIONAL
    OUT PBOOL  IsDefault              OPTIONAL
    );

BOOL
pSetupDiGetOrSetDeviceInfoContext(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            InContext,
    OUT PDWORD           OutContext      OPTIONAL
    );


HDEVINFO
WINAPI
SetupDiCreateDeviceInfoList(
    IN CONST GUID *ClassGuid, OPTIONAL
    IN HWND        hwndParent OPTIONAL
    )
/*++

Routine Description:

    This API creates an empty device information set that will contain device
    device information member elements.  This set may be associated with an
    optionally-specified class GUID.

Arguments:

    ClassGuid - Optionally, supplies a pointer to the class GUID that is to be
        associated with this set.

    hwndParent - Optionally, supplies the window handle of the top-level window
        to use for any UI related to installation of a class driver contained
        in this set's global class driver list (if it has one).

Return Value:

    If the function succeeds, the return value is a handle to an empty device
    information set.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

--*/
{
    return SetupDiCreateDeviceInfoListEx(ClassGuid, hwndParent, NULL, NULL);
}


//
// ANSI version
//
HDEVINFO
WINAPI
SetupDiCreateDeviceInfoListExA(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN HWND        hwndParent,  OPTIONAL
    IN PCSTR       MachineName, OPTIONAL
    IN PVOID       Reserved
    )
{
    PCWSTR UnicodeMachineName;
    DWORD rc;
    HDEVINFO hDevInfo;

    hDevInfo = INVALID_HANDLE_VALUE;

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName, &UnicodeMachineName);
    } else {
        UnicodeMachineName = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {

        hDevInfo = SetupDiCreateDeviceInfoListExW(ClassGuid,
                                                  hwndParent,
                                                  UnicodeMachineName,
                                                  Reserved
                                                 );
        rc = GetLastError();
        if(UnicodeMachineName) {
            MyFree(UnicodeMachineName);
        }
    }

    SetLastError(rc);
    return hDevInfo;
}

HDEVINFO
WINAPI
SetupDiCreateDeviceInfoListEx(
    IN CONST GUID *ClassGuid,   OPTIONAL
    IN HWND        hwndParent,  OPTIONAL
    IN PCTSTR      MachineName, OPTIONAL
    IN PVOID       Reserved
    )
/*++

Routine Description:

    This API creates an empty device information set that will contain device
    device information member elements.  This set may be associated with an
    optionally-specified class GUID.

Arguments:

    ClassGuid - Optionally, supplies a pointer to the class GUID that is to be
        associated with this set.

    hwndParent - Optionally, supplies the window handle of the top-level window
        to use for any UI related to installation of a class driver contained
        in this set's global class driver list (if it has one).

    MachineName - Optionally, supplies the name of the machine for which this
        device information set is to be related.  Only devices on that machine
        may be opened/created.  If this parameter is NULL, then the local machine
        is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is a handle to an empty device
    information set.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET DeviceInfoSet;
    DWORD Err = NO_ERROR;
    CONFIGRET cr;

    //
    // Make sure the user didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    if(DeviceInfoSet = AllocateDeviceInfoSet()) {

        try {
            //
            // If the user specified the name of a remote machine, connect to
            // that machine now.
            //
            if(MachineName) {

                if(CR_SUCCESS != (cr = CM_Connect_Machine(MachineName, &(DeviceInfoSet->hMachine)))) {
                    //
                    // Make sure hMachine is still NULL, so we won't try to disconnect later.
                    //
                    DeviceInfoSet->hMachine = NULL;
                    Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
                    goto clean0;
                }

                //
                // Store the machine name in the string table, so it can be
                // retrieved later via SetupDiGetDeviceInfoListDetail.
                //
                if(-1 == (DeviceInfoSet->MachineName = pStringTableAddString(DeviceInfoSet->StringTable,
                                                                             (PTSTR)MachineName,
                                                                             STRTAB_CASE_SENSITIVE,
                                                                             NULL,
                                                                             0))) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }
            }

            if(ClassGuid) {
                //
                // If a class GUID was specified, then store it away in
                // the device information set.
                //
                CopyMemory(&(DeviceInfoSet->ClassGuid),
                           ClassGuid,
                           sizeof(GUID)
                          );
                DeviceInfoSet->HasClassGuid = TRUE;
            }

            DeviceInfoSet->InstallParamBlock.hwndParent = hwndParent;

clean0:     ;   // nothing to do.

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_PARAMETER;
            //
            // Reference the following variable so the compiler will respect statement ordering
            // w.r.t. assignment.
            //
            DeviceInfoSet->hMachine = DeviceInfoSet->hMachine;
        }

        if(Err != NO_ERROR) {
            DestroyDeviceInfoSet(NULL, DeviceInfoSet);
        }

    } else {
        Err = ERROR_NOT_ENOUGH_MEMORY;
    }

    SetLastError(Err);

    return (Err == NO_ERROR) ? (HDEVINFO)DeviceInfoSet
                             : (HDEVINFO)INVALID_HANDLE_VALUE;
}


BOOL
WINAPI
SetupDiGetDeviceInfoListClass(
    IN  HDEVINFO DeviceInfoSet,
    OUT LPGUID   ClassGuid
    )
/*++

Routine Description:

    This API retrieves the class GUID associated with a device information
    set (if it has an associated class).

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set whose associated
        class is being queried.

    ClassGuid - Supplies a pointer to a variable that receives the GUID for the
        associated class.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.  If the set has no associated class, then
    GetLastError will return ERROR_NO_ASSOCIATED_CLASS.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(pDeviceInfoSet->HasClassGuid) {
            //
            // Copy the GUID to the user-supplied buffer.
            //
            CopyMemory(ClassGuid,
                       &(pDeviceInfoSet->ClassGuid),
                       sizeof(GUID)
                      );
        } else {
            Err = ERROR_NO_ASSOCIATED_CLASS;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDeviceInfoListDetailA(
    IN  HDEVINFO                       DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA_A DeviceInfoSetDetailData
    )
{
    DWORD rc;
    BOOL b;
    SP_DEVINFO_LIST_DETAIL_DATA_W UnicodeDevInfoSetDetails;

    UnicodeDevInfoSetDetails.cbSize = sizeof(SP_DEVINFO_LIST_DETAIL_DATA_W);

    b = SetupDiGetDeviceInfoListDetailW(DeviceInfoSet, &UnicodeDevInfoSetDetails);
    rc = GetLastError();

    if(b) {
        rc = pSetupDiDevInfoSetDetailDataUnicodeToAnsi(&UnicodeDevInfoSetDetails, DeviceInfoSetDetailData);
        if(rc != NO_ERROR) {
            b = FALSE;
        }
    }

    SetLastError(rc);
    return(b);
}

BOOL
WINAPI
SetupDiGetDeviceInfoListDetail(
    IN  HDEVINFO                       DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA   DeviceInfoSetDetailData
    )
/*++

Routine Description:

    This routine retrieves information about the specified device information set,
    such as its associated class (if any), and the remote machine it was opened for
    (if this is a remoted HDEVINFO).  This API supercedes SetupDiGetDeviceInfoListClass.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set to retrieve
        detailed information for.

    DeviceInfoSetDetailData - Supplies the address of a structure that receives
        information about the specified device information set.  This structure is
        defined as follows:

            typedef struct _SP_DEVINFO_LIST_DETAIL_DATA {
                DWORD  cbSize;
                GUID   ClassGuid;
                HANDLE RemoteMachineHandle;
                TCHAR  RemoteMachineName[SP_MAX_MACHINENAME_LENGTH];
            } SP_DEVINFO_LIST_DETAIL_DATA, *PSP_DEVINFO_LIST_DETAIL_DATA;

        where:

            ClassGuid specifies the class associated with the device information
                set, or GUID_NULL if there is no associated class.

            RemoteMachineHandle is the ConfigMgr32 machine handle used to access
                the remote machine, if this is a remoted HDEVINFO (i.e., a
                MachineName was specified when the set was created via
                SetupDiCreateDeviceInfoListEx or SetupDiGetClassDevsEx).  All
                DevInst handles stored in SP_DEVINFO_DATA structures for elements
                of this set are relative to this handle, and must be used in
                combination with this handle when calling any CM_*_Ex APIs.

                If this is not a device information set for a remote machine, this
                field will be NULL.

                NOTE:  DO NOT destroy this handle via CM_Disconnect_Machine.  This
                handle will be cleaned up when the device information set is destroyed
                via SetupDiDestroyDeviceInfoList.

            RemoteMachineName specifies the name used to connect to the remote
                machine whose handle is stored in RemoteMachineHandle.  If this is
                not a device information set for a remote machine, this will be an
                empty string.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    The cbSize field of the output structure must be set to
    sizeof(SP_DEVINFO_LIST_DETAIL_DATA) or the  call will fail with
    ERROR_INVALID_USER_BUFFER.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PCTSTR MachineName;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(DeviceInfoSetDetailData->cbSize != sizeof(SP_DEVINFO_LIST_DETAIL_DATA)) {
            Err = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }

        //
        // Store the set's associated class GUID, or GUID_NULL if there isn't one.
        //
        if(pDeviceInfoSet->HasClassGuid) {
            CopyMemory(&(DeviceInfoSetDetailData->ClassGuid),
                       &(pDeviceInfoSet->ClassGuid),
                       sizeof(GUID)
                      );
        } else {
            CopyMemory(&(DeviceInfoSetDetailData->ClassGuid), &GUID_NULL, sizeof(GUID));
        }

        DeviceInfoSetDetailData->RemoteMachineHandle = pDeviceInfoSet->hMachine;

        //
        // If this is a remoted HDEVINFO, store the machine name in the caller's buffer,
        // otherwise store an empty string.
        //
        if(pDeviceInfoSet->hMachine) {
            MYASSERT(pDeviceInfoSet->MachineName != -1);
            MachineName = pStringTableStringFromId(pDeviceInfoSet->StringTable, pDeviceInfoSet->MachineName);
            MYVERIFY(SUCCEEDED(StringCchCopy(DeviceInfoSetDetailData->RemoteMachineName,
                                             SIZECHARS(DeviceInfoSetDetailData->RemoteMachineName),
                                             MachineName
                                             )));
        } else {
            MYASSERT(pDeviceInfoSet->MachineName == -1);
            *(DeviceInfoSetDetailData->RemoteMachineName) = TEXT('\0');
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiDestroyDeviceInfoList(
    IN  HDEVINFO DeviceInfoSet
    )
/*++

Routine Description:

    This API destroys a device information set, freeing all associated memory.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set to be destroyed.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    DWORD Err;
    PDEVICE_INFO_SET pDeviceInfoSet;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    try {
        Err = DestroyDeviceInfoSet(DeviceInfoSet, pDeviceInfoSet);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_HANDLE;
    }

    SetLastError(Err);
    return (Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiCreateDeviceInfoA(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PCSTR             DeviceName,
    IN  CONST GUID       *ClassGuid,
    IN  PCSTR             DeviceDescription, OPTIONAL
    IN  HWND              hwndParent,        OPTIONAL
    IN  DWORD             CreationFlags,
    OUT PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    )
{
    PCWSTR deviceName,deviceDescription;
    DWORD rc;
    BOOL b;

    b = FALSE;
    rc = pSetupCaptureAndConvertAnsiArg(DeviceName,&deviceName);
    if(rc == NO_ERROR) {

        if(DeviceDescription) {
            rc = pSetupCaptureAndConvertAnsiArg(DeviceDescription,&deviceDescription);
        } else {
            deviceDescription = NULL;
        }

        if(rc == NO_ERROR) {

            b = SetupDiCreateDeviceInfoW(
                    DeviceInfoSet,
                    deviceName,
                    ClassGuid,
                    deviceDescription,
                    hwndParent,
                    CreationFlags,
                    DeviceInfoData
                    );

            rc = GetLastError();

            if(deviceDescription) {
                MyFree(deviceDescription);
            }
        }

        MyFree(deviceName);

    } else {
        //
        // The DeviceName parameter was bad--return the same error the unicode API does.
        //
        rc = ERROR_INVALID_DEVINST_NAME;
    }

    SetLastError(rc);
    return(b);
}

BOOL
WINAPI
SetupDiCreateDeviceInfo(
    IN  HDEVINFO          DeviceInfoSet,
    IN  PCTSTR            DeviceName,
    IN  CONST GUID       *ClassGuid,
    IN  PCTSTR            DeviceDescription, OPTIONAL
    IN  HWND              hwndParent,        OPTIONAL
    IN  DWORD             CreationFlags,
    OUT PSP_DEVINFO_DATA  DeviceInfoData     OPTIONAL
    )
/*++

Routine Description:

    This API creates a new device information element, and adds it as a new member
    to the specified set.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set to which this
        new device information element is to be added.

    DeviceName - Supplies either a full device instance ID (e.g., Root\*PNP0500\0000)
        or a Root-enumerated device ID, minus enumerator branch prefix and instance
        ID suffix (e.g., *PNP0500).  The latter may only be specified if the
        DICD_GENERATE_ID flag is specified in the CreationFlags parameter.

    ClassGuid - Supplies a pointer to the GUID for this device's class.  If the
        class is not yet known, this value should be GUID_NULL.

    DeviceDescription - Optionally, supplies a textual description of the device.

    hwndParent - Optionally, supplies the window handle of the top-level window
        to use for any UI related to installing the device.

    CreationFlags - Supplies flags controlling how the device information element
        is to be created.  May be a combination of the following values:

        DICD_GENERATE_ID -       If this flag is specified, then DeviceName contains only
                                 a Root-enumerated device ID, and needs to have a unique
                                 device instance key created for it.  This unique device
                                 instance key will be generated as:

                                     Enum\Root\<DeviceName>\<InstanceID>

                                 where <InstanceID> is a 4-digit, base-10 number that
                                 is unique among all subkeys under Enum\Root\<DeviceName>.
                                 The API, SetupDiGetDeviceInstanceId, may be called to
                                 find out what ID was generated for this device information
                                 element.

        DICD_INHERIT_CLASSDRVS - If this flag is specified, then the resulting device
                                 information element will inherit the class driver list (if any)
                                 associated with the device information set itself.  In addition,
                                 if there is a selected driver for the device information set,
                                 that same driver will be selected for the new device information
                                 element.

    DeviceInfoData - Optionaly, supplies a pointer to the variable that receives
        a context structure initialized for this new device information element.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If this device instance is being added to a set that has an associated class,
    then the device class must be the same, or the call will fail, and GetLastError
    will return ERROR_CLASS_MISMATCH.

    If the specified device instance is the same as an existing device instance key in
    the registry, the call will fail with ERROR_DEVINST_ALREADY_EXISTS.  (This only
    applies if DICD_GENERATE_ID is not specified.)

    The specified class GUID will be written out to the ClassGUID device instance
    value entry.  If the class name can be retrieved (via SetupDiClassNameFromGuid),
    then it will be written to the Class value entry as well.

    If the new device information element was successfully created, but the
    user-supplied DeviceInfoData buffer is invalid, this API will return FALSE, with
    GetLastError returning ERROR_INVALID_USER_BUFFER.  The device information element
    _will_ have been added as a new member of the set, however.

    Note that since new device information elements are always added at the end
    of the existing list, the enumeration ordering is preserved, thus we don't
    need to invalidate our enumeration hint.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, StringLen;
    PDEVINFO_ELEM DevInfoElem, PrevTailDevInfoElem;
    DEVINST DevInst, RootDevInst;
    CONFIGRET cr;
    ULONG CmFlags;
    TCHAR TempString[GUID_STRING_LEN];
    PDRIVER_LIST_OBJECT CurDrvListObject;

    //
    // We use the TempString buffer both for the string representation of
    // a Class GUID, and for the Class name.  The following assert ensures
    // that our assumptions about the relative lengths of these two strings
    // continues to be valid.
    //
    MYASSERT(GUID_STRING_LEN >= MAX_CLASS_NAME_LEN);

    if(CreationFlags & ~(DICD_GENERATE_ID | DICD_INHERIT_CLASSDRVS)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;
    DevInst = 0;
    DevInfoElem = NULL;

    try {
        //
        // Get a pointer to the current tail of the devinfo element list for this
        // set, so that we can easily lop off the new node if we encounter an error
        // after insertion.
        //
        PrevTailDevInfoElem = pDeviceInfoSet->DeviceInfoTail;

        //
        // Get a handle to the root device instance, to be used as the parent
        // for the phantom device instance we're about to create.
        //
        if(CM_Locate_DevInst_Ex(&RootDevInst, NULL, CM_LOCATE_DEVINST_NORMAL,
                                pDeviceInfoSet->hMachine) != CR_SUCCESS) {
            //
            // We're really hosed if we can't get a handle to the root device
            // instance!
            //
            Err = ERROR_INVALID_DATA;
            goto clean0;
        }

        //
        // Create a handle to a phantom device instance.
        //
        CmFlags = CM_CREATE_DEVINST_PHANTOM;

        if(CreationFlags & DICD_GENERATE_ID) {
            CmFlags |= CM_CREATE_DEVINST_GENERATE_ID;
        }

        if((cr = CM_Create_DevInst_Ex(&DevInst,
                                   (DEVINSTID)DeviceName,
                                   RootDevInst,
                                   CmFlags,
                                   pDeviceInfoSet->hMachine)) != CR_SUCCESS) {
            //
            // Make sure DevInst handle is still invalid, so we won't try to
            // delete it later.
            //
            DevInst = 0;
            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
            goto clean0;
        }

        if(NO_ERROR != (Err = pSetupAddNewDeviceInfoElement(pDeviceInfoSet,
                                                            DevInst,
                                                            ClassGuid,
                                                            DeviceDescription,
                                                            hwndParent,
                                                            DIE_IS_PHANTOM,
                                                            pDeviceInfoSet,
                                                            &DevInfoElem))) {
            //
            // Make sure DevInfoElem is still NULL, so we won't try to free it later.
            //
            DevInfoElem = NULL;
            goto clean0;
        }

        //
        // Now, set the Class and ClassGUID properties for the new device instance.
        //
        pSetupStringFromGuid(ClassGuid, TempString, SIZECHARS(TempString));
        CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                         CM_DRP_CLASSGUID,
                                         (PVOID)TempString,
                                         GUID_STRING_LEN * sizeof(TCHAR),
                                         0,pDeviceInfoSet->hMachine);


        if(!IsEqualGUID(ClassGuid, &GUID_NULL) &&
           SetupDiClassNameFromGuid(ClassGuid,
                                    TempString,
                                    SIZECHARS(TempString),
                                    &StringLen)) {

            CM_Set_DevInst_Registry_Property_Ex(DevInfoElem->DevInst,
                                             CM_DRP_CLASS,
                                             (PVOID)TempString,
                                             StringLen * sizeof(TCHAR),
                                             0,pDeviceInfoSet->hMachine);
        }

        //
        // If the caller wants the newly-created devinfo element to inherit the global
        // class driver list, do that now.
        //
        if((CreationFlags & DICD_INHERIT_CLASSDRVS) && (pDeviceInfoSet->ClassDriverHead)) {
            //
            // Find the global class driver list in the devinfo set's list of driver lists.
            //
            CurDrvListObject = GetAssociatedDriverListObject(pDeviceInfoSet->ClassDrvListObjectList,
                                                             pDeviceInfoSet->ClassDriverHead,
                                                             NULL
                                                            );
            MYASSERT(CurDrvListObject && (CurDrvListObject->RefCount > 0));

            //
            // We found the driver list object, now do the inheritance, and increment the refcount.
            //
            DevInfoElem->ClassDriverCount = pDeviceInfoSet->ClassDriverCount;
            DevInfoElem->ClassDriverHead  = pDeviceInfoSet->ClassDriverHead;
            DevInfoElem->ClassDriverTail  = pDeviceInfoSet->ClassDriverTail;

            if(DevInfoElem->SelectedDriver = pDeviceInfoSet->SelectedClassDriver) {
                DevInfoElem->SelectedDriverType = SPDIT_CLASSDRIVER;
            }

            DevInfoElem->InstallParamBlock.Flags   |= CurDrvListObject->ListCreationFlags;
            DevInfoElem->InstallParamBlock.FlagsEx |= CurDrvListObject->ListCreationFlagsEx;
            DevInfoElem->InstallParamBlock.DriverPath = CurDrvListObject->ListCreationDriverPath;

            CurDrvListObject->RefCount++;
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variables so the compiler will respect our statement ordering
        // w.r.t. assignment.
        //
        DevInst = DevInst;
        DevInfoElem = DevInfoElem;
        PrevTailDevInfoElem = PrevTailDevInfoElem;
    }

    if(Err == NO_ERROR) {

        if(DeviceInfoData) {
            //
            // The user supplied a buffer to receive a SP_DEVINFO_DATA
            // structure, so fill that in now.
            //
            try {

                if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                      DevInfoElem,
                                                      DeviceInfoData))) {
                    Err = ERROR_INVALID_USER_BUFFER;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {
                Err = ERROR_INVALID_USER_BUFFER;
            }
        }

    } else if(DevInst) {

        //
        // This should never fail.
        //
        cr = CM_Uninstall_DevInst(DevInst, 0);
        MYASSERT(cr == CR_SUCCESS);

        if(DevInfoElem) {
            //
            // An error occurred after we created the device information element--clean it up now.
            //
            try {

                MYASSERT(!DevInfoElem->Next);
                if(PrevTailDevInfoElem) {
                    MYASSERT(PrevTailDevInfoElem->Next == DevInfoElem);
                    PrevTailDevInfoElem->Next = NULL;
                    pDeviceInfoSet->DeviceInfoTail = PrevTailDevInfoElem;
                } else {
                    pDeviceInfoSet->DeviceInfoHead = pDeviceInfoSet->DeviceInfoTail = NULL;
                }

                MYASSERT(pDeviceInfoSet->DeviceInfoCount > 0);
                pDeviceInfoSet->DeviceInfoCount--;

                MyFree(DevInfoElem);

            } except(EXCEPTION_EXECUTE_HANDLER) {
                ;   // nothing to do.
            }
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiOpenDeviceInfoA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCSTR            DeviceInstanceId,
    IN  HWND             hwndParent,        OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData     OPTIONAL
    )
{
    PCWSTR deviceInstanceId;
    DWORD rc;
    BOOL b;

    rc = pSetupCaptureAndConvertAnsiArg(DeviceInstanceId,&deviceInstanceId);
    if(rc == NO_ERROR) {

        b = SetupDiOpenDeviceInfoW(
                DeviceInfoSet,
                deviceInstanceId,
                hwndParent,
                OpenFlags,
                DeviceInfoData
                );

        rc = GetLastError();

        MyFree(deviceInstanceId);

    } else {
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}

BOOL
WINAPI
SetupDiOpenDeviceInfo(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PCTSTR           DeviceInstanceId,
    IN  HWND             hwndParent,       OPTIONAL
    IN  DWORD            OpenFlags,
    OUT PSP_DEVINFO_DATA DeviceInfoData    OPTIONAL
    )
/*++

Routine Description:

    This API retrieves information about an existing device instance, and adds
    it to the specified device information set.  If a device information element
    already exists for this device instance, the existing element is returned.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set to which the
        opened device information element is to be added.

    DeviceInstanceId - Supplies the ID of the device instance.  This is the
        registry path (relative to the Enum branch) of the device instance key.
        (E.g., Root\*PNP0500\0000)

    hwndParent - Optionally, supplies the window handle of the top-level window
        to use for any UI related to installing the device.

    OpenFlags - Supplies flags controlling how the device information element
        is to be opened.  May be a combination of the following values:

        DIOD_INHERIT_CLASSDRVS - If this flag is specified, then the resulting device
                                 information element will inherit the class driver
                                 list (if any) associated with the device information
                                 set itself.  In addition, if there is a selected
                                 driver for the device information set, that same
                                 driver will be selected for the new device information
                                 element.

                                 If the device information element was already present,
                                 its class driver list (if any) will be replaced with
                                 this new, inherited, list.

        DIOD_CANCEL_REMOVE     - If this flag is set, a device that was marked for removal
                                 will be have its pending removal cancelled.

    DeviceInfoData - Optionally, supplies a pointer to the variable that receives
        a context structure initialized for the opened device information element.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If this device instance is being added to a set that has an associated class,
    then the device class must be the same, or the call will fail, and GetLastError
    will return ERROR_CLASS_MISMATCH.

    If the new device information element was successfully opened, but the
    user-supplied DeviceInfoData buffer is invalid, this API will return FALSE,
    with GetLastError returning ERROR_INVALID_USER_BUFFER.  The device information
    element _will_ have been added as a new member of the set, however.

    Note that since new device information elements are always added at the end
    of the existing list, the enumeration ordering is preserved, thus we don't
    need to invalidate our enumeration hint.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDRIVER_LIST_OBJECT CurDrvListObject;
    BOOL AlreadyPresent;

    if(OpenFlags & ~(DIOD_INHERIT_CLASSDRVS | DIOD_CANCEL_REMOVE)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        Err = pSetupOpenAndAddNewDevInfoElem(pDeviceInfoSet,
                                             DeviceInstanceId,
                                             TRUE,
                                             NULL,
                                             hwndParent,
                                             &DevInfoElem,
                                             TRUE,
                                             &AlreadyPresent,
                                             FALSE,
                                             ((OpenFlags & DIOD_CANCEL_REMOVE)
                                                 ? CM_LOCATE_DEVNODE_CANCELREMOVE : 0),
                                             pDeviceInfoSet
                                            );

        if(Err != NO_ERROR) {
            goto clean0;
        }

        //
        // If the caller wants the newly-opened devinfo element to inherit the global
        // class driver list, do that now.
        //
        if(OpenFlags & DIOD_INHERIT_CLASSDRVS) {
            //
            // If this devinfo element already existed, then it may already have a class
            // driver list.  Destroy that list before inheriting from the global class
            // driver list.
            //
            if(AlreadyPresent) {
                //
                // If the selected driver is a class driver, then reset the selection.
                //
                if(DevInfoElem->SelectedDriverType == SPDIT_CLASSDRIVER) {
                    DevInfoElem->SelectedDriverType = SPDIT_NODRIVER;
                    DevInfoElem->SelectedDriver = NULL;
                }

                //
                // Destroy the existing class driver list for this device.
                //
                DereferenceClassDriverList(pDeviceInfoSet, DevInfoElem->ClassDriverHead);
                DevInfoElem->ClassDriverCount = 0;
                DevInfoElem->ClassDriverHead = DevInfoElem->ClassDriverTail = NULL;
                DevInfoElem->InstallParamBlock.Flags   &= ~(DI_DIDCLASS | DI_MULTMFGS);
                DevInfoElem->InstallParamBlock.FlagsEx &= ~DI_FLAGSEX_DIDINFOLIST;
            }

            if(pDeviceInfoSet->ClassDriverHead) {
                //
                // Find the global class driver list in the devinfo set's list of driver lists.
                //
                CurDrvListObject = GetAssociatedDriverListObject(pDeviceInfoSet->ClassDrvListObjectList,
                                                                 pDeviceInfoSet->ClassDriverHead,
                                                                 NULL
                                                                );
                MYASSERT(CurDrvListObject && (CurDrvListObject->RefCount > 0));

                //
                // We found the driver list object, now increment its refcount, and do the
                // inheritance.
                //
                CurDrvListObject->RefCount++;

                DevInfoElem->ClassDriverCount = pDeviceInfoSet->ClassDriverCount;
                DevInfoElem->ClassDriverHead  = pDeviceInfoSet->ClassDriverHead;
                DevInfoElem->ClassDriverTail  = pDeviceInfoSet->ClassDriverTail;

                if(pDeviceInfoSet->SelectedClassDriver) {
                    DevInfoElem->SelectedDriver = pDeviceInfoSet->SelectedClassDriver;
                    DevInfoElem->SelectedDriverType = SPDIT_CLASSDRIVER;
                }

                DevInfoElem->InstallParamBlock.Flags   |= CurDrvListObject->ListCreationFlags;
                DevInfoElem->InstallParamBlock.FlagsEx |= CurDrvListObject->ListCreationFlagsEx;
                DevInfoElem->InstallParamBlock.DriverPath = CurDrvListObject->ListCreationDriverPath;
            }
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if((Err == NO_ERROR) && DeviceInfoData) {
        //
        // The user supplied a buffer to receive a SP_DEVINFO_DATA
        // structure, so fill that in now.
        //
        try {

            if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                  DevInfoElem,
                                                  DeviceInfoData))) {
                Err = ERROR_INVALID_USER_BUFFER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_USER_BUFFER;
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
HDEVINFO
WINAPI
SetupDiGetClassDevsA(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCSTR       Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    )
{
    PCWSTR enumerator;
    DWORD rc;
    HDEVINFO h;

    if(Enumerator) {
        rc = pSetupCaptureAndConvertAnsiArg(Enumerator,&enumerator);
        if(rc != NO_ERROR) {
            SetLastError(rc);
            return INVALID_HANDLE_VALUE;
        }
    } else {
        enumerator = NULL;
    }

    h = SetupDiGetClassDevsExW(ClassGuid,
                               enumerator,
                               hwndParent,
                               Flags,
                               NULL,
                               NULL,
                               NULL
                              );
    rc = GetLastError();

    if(enumerator) {
        MyFree(enumerator);
    }

    SetLastError(rc);
    return h;
}

HDEVINFO
WINAPI
SetupDiGetClassDevs(
    IN CONST GUID *ClassGuid,  OPTIONAL
    IN PCTSTR      Enumerator, OPTIONAL
    IN HWND        hwndParent, OPTIONAL
    IN DWORD       Flags
    )
/*++

Routine Description:

    See SetupDiGetClassDevsEx for details.

--*/
{
    return SetupDiGetClassDevsEx(ClassGuid,
                                 Enumerator,
                                 hwndParent,
                                 Flags,
                                 NULL,
                                 NULL,
                                 NULL
                                );
}


//
// ANSI version
//
HDEVINFO
WINAPI
SetupDiGetClassDevsExA(
    IN CONST GUID *ClassGuid,     OPTIONAL
    IN PCSTR       Enumerator,    OPTIONAL
    IN HWND        hwndParent,    OPTIONAL
    IN DWORD       Flags,
    IN HDEVINFO    DeviceInfoSet, OPTIONAL
    IN PCSTR       MachineName,   OPTIONAL
    IN PVOID       Reserved
    )
{
    PCWSTR UnicodeEnumerator, UnicodeMachineName;
    DWORD rc;
    HDEVINFO h;

    h = INVALID_HANDLE_VALUE;

    if(Enumerator) {
        rc = pSetupCaptureAndConvertAnsiArg(Enumerator, &UnicodeEnumerator);
        if(rc != NO_ERROR) {
            goto clean0;
        }
    } else {
        UnicodeEnumerator = NULL;
    }

    if(MachineName) {
        rc = pSetupCaptureAndConvertAnsiArg(MachineName,&UnicodeMachineName);
        if(rc != NO_ERROR) {
            goto clean1;
        }
    } else {
        UnicodeMachineName = NULL;
    }

    h = SetupDiGetClassDevsExW(ClassGuid,
                               UnicodeEnumerator,
                               hwndParent,
                               Flags,
                               DeviceInfoSet,
                               UnicodeMachineName,
                               Reserved
                              );
    rc = GetLastError();

    if(UnicodeMachineName) {
        MyFree(UnicodeMachineName);
    }

clean1:
    if(UnicodeEnumerator) {
        MyFree(UnicodeEnumerator);
    }

clean0:
    SetLastError(rc);
    return h;
}

HDEVINFO
WINAPI
SetupDiGetClassDevsEx(
    IN CONST GUID *ClassGuid,     OPTIONAL
    IN PCTSTR      Enumerator,    OPTIONAL
    IN HWND        hwndParent,    OPTIONAL
    IN DWORD       Flags,
    IN HDEVINFO    DeviceInfoSet, OPTIONAL
    IN PCTSTR      MachineName,   OPTIONAL
    IN PVOID       Reserved
    )
/*++

Routine Description:

    This routine returns a device information set containing all installed
    devices of the specified class.

Arguments:

    ClassGuid - Optionally, supplies the address of the class GUID to use
        when creating the list of devices.  If the DIGCF_ALLCLASSES flag is
        set, then this parameter is ignored, and the resulting list will
        contain all classes of devices (i.e., every installed device).

        If the DIGCF_DEVICEINTERFACE flag _is not_ set, then this class GUID
        represents a setup class.

        If the DIGCF_DEVICEINTERFACE flag _is_ set, then this class GUID
        represents an interface class.

    Enumerator - Optional parameter that filters the members of the returned
        device information set based on their enumerator (i.e., provider).

        If the DIGCF_DEVICEINTERFACE flag _is not_ set in the Flags parameter,
        then this string represents the name of the key under the Enum branch
        containing devices instances for which information is to be retrieved.
        If this parameter is not specified, then device information will be
        retrieved for all device instances in the entire Enum tree.

        If the DIGCF_DEVICEINTERFACE flag _is_ set, then this string represents
        the PnP name of a particular device for which interfaces are to be
        retrieved.  In this case, the resulting device information set will
        consist of a single device information element--the device whose name
        was specified as the enumerator.  The device interfaces provided by this
        PnP device can then be enumerated via SetupDiEnumDeviceInterface.

    hwndParent - Optionally, supplies the handle of the top-level window to be
        used for any UI relating to the members of this set.

    Flags - Supplies control options used in building the device information set.
        May be a combination of the following values:

        DIGCF_PRESENT         - Return only devices that are currently present.
        DIGCF_ALLCLASSES      - Return a list of installed devices for all classes.
                                If set, this flag will cause ClassGuid to be ignored.
        DIGCF_PROFILE         - Return only devices that are a part of the current
                                hardware profile.
        DIGCF_DEVICEINTERFACE - Return a list of all devices that expose interfaces
                                of the class specified by ClassGUID (NOTE: in this
                                context, ClassGuid is an interface class, _not_ a
                                setup class).  The device interfaces exposed by the
                                members of the resulting set may be enumerated via
                                SetupDiEnumDeviceInterface.
        DIGCF_DEFAULT         - When used with DIGCF_DEVICEINTERFACE, this flag
                                results in a list that contains only one device
                                information element.  Enumerating that device will
                                return exactly one device interface--the one that has
                                been marked as the system default device interface for
                                that particular interface class.  If there is no default
                                device interface for the specified class, the API will
                                fail, and GetLastError will return
                                ERROR_NO_DEFAULT_DEVICE_INTERFACE.

    DeviceInfoSet - Optionally, supplies the handle of an existing device
        information set into which these new device information elements (and,
        if DIGCF_DEVICEINTERFACE is specified, device interfaces) will be added.
        If this parameter is specified, then this same HDEVINFO will be returned
        upon success, with the retrieved device information/device interface
        elements added.  If this parameter is not specified, then a new device
        information set will be created, and its handle returned.

        NOTE: if this parameter is specified, then the associated class of this
        device information set (if any) must match the ClassGuid specified, if
        that class GUID is a setup class (i.e., the DIGCF_DEVICEINTERFACE flag
        isn't set).  If the DIGCF_DEVICEINTERFACE flag is set, then the device
        interfaces retrieved will be filtered based on whether or not their
        corresponding device's setup class matches that of the device
        information set.  This trick can be used, for example, to retrieve a
        list of device interfaces of a particular interface class, but only if
        those interfaces are exposed by devices of a particular setup class.
        E.g.,

            1.  Create a device information set (via SetupDiCreateDeviceInfoList)
                whose associated setup class is "Volume".
            2.  Call SetupDiGetClassDevsEx to retrieve a list of all device
                interfaces of interface class "mounted device", passing in the
                HDEVINFO retrieved in step 1.

        The result of the above steps would be a device information set
        containing all device interfaces of (interface) class "mounted device"
        that are exposed by devnodes of (setup) class "Volume".

        Note that retrieval of new device information elements into an existing
        HDEVINFO set doesn't invalidate our devinfo enumeration hint, since new
        devinfo elements are always added onto the end of the list.

    MachineName - Optionally, supplies the name of a remote machine for which a
        device information set is to be retrieved.  If this parameter is NULL,
        then the local machine is used.

    Reserved - Reserved for future use--must be NULL.

Return Value:

    If the function succeeds, the return value is a handle to a device
    information set containing all installed devices matching the specified
    parameters.

    If the function fails, the return value is INVALID_HANDLE_VALUE.  To get
    extended error information, call GetLastError.

--*/
{
    HDEVINFO hDevInfo;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    DWORD Err;
    CONFIGRET cr;
    PTCHAR DevIdBuffer;
    ULONG DevIdBufferLen, CSConfigFlags;
    PTSTR CurDevId, DeviceInstanceToOpen;
    HKEY hKeyDevClassRoot, hKeyCurDevClass;
    TCHAR InterfaceGuidString[GUID_STRING_LEN];
    BOOL GetInterfaceList, GetNextInterfaceClass;
    DWORD InterfaceClassKeyIndex;
    FILETIME LastWriteTime;
    GUID GuidBuffer;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    DWORD RegDataType, DataBufferSize;
    BOOL DevInfoAlreadyPresent, IsActive, IsDefault;
    SP_DEVINFO_DATA DeviceInfoData;
    CONST GUID * ExistingClassGuid;

    //
    // Make sure the user didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    //
    // Unless the caller wants a list of all classes, they'd better supply a class GUID.
    //
    if(!(Flags & DIGCF_ALLCLASSES) && !ClassGuid) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    //
    // DIGCF_DEFAULT can only be used in conjunction with DIGCF_DEVICEINTERFACE.
    //
    if((Flags & (DIGCF_DEFAULT | DIGCF_DEVICEINTERFACE)) == DIGCF_DEFAULT) {
        SetLastError(ERROR_INVALID_FLAGS);
        return INVALID_HANDLE_VALUE;
    }

    if(!DeviceInfoSet || (DeviceInfoSet == INVALID_HANDLE_VALUE)) {
        //
        // The caller didn't supply us with a device information set in which
        // to add our newly-retrieved elements, so we need to create our own.
        //
        if((hDevInfo = SetupDiCreateDeviceInfoListEx((Flags & (DIGCF_ALLCLASSES | DIGCF_DEVICEINTERFACE))
                                                          ? NULL
                                                          : ClassGuid,
                                                     hwndParent,
                                                     MachineName,
                                                     NULL)) == INVALID_HANDLE_VALUE) {
            //
            // Last error already set.
            //
            MYASSERT(GetLastError());
            return INVALID_HANDLE_VALUE;
        }

        if(!(pDeviceInfoSet = AccessDeviceInfoSet(hDevInfo))) {
            //
            // this should not happen
            //
            MYASSERT(pDeviceInfoSet);
            SetLastError(ERROR_INVALID_HANDLE);
            return INVALID_HANDLE_VALUE;
        }

    } else {
        //
        // The caller wants us to use an existing device information set.  Make
        // a copy of it, and work with that one, so that if something fails, we
        // haven't messed up the original one.
        //
        // NOTE:  DO NOT do anything with the DeviceInfoSet after this point,
        // as doing so will get the original out-of-sync with the current copy
        // we're working with.
        //
        hDevInfo = NULL;
        pDeviceInfoSet = CloneDeviceInfoSet(DeviceInfoSet);
        if(!pDeviceInfoSet) {
            SetLastError(ERROR_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }
    }

    Err = NO_ERROR;
    DevIdBuffer = NULL;
    hKeyDevClassRoot = hKeyCurDevClass = INVALID_HANDLE_VALUE;

    try {
        //
        // If the caller supplied us with a previously-existing devinfo set in
        // which to add new elements, we need to make sure that the setup class
        // GUID associated with this devinfo set (if any) matches the setup
        // class GUID that the caller supplied.
        //
        if(hDevInfo) {
            //
            // We always want the ExistingClassGuid pointer to be NULL when we
            // haven't been passed in a previously-existing device information
            // set.
            //
            ExistingClassGuid = NULL;

        } else {

            if(pDeviceInfoSet->HasClassGuid) {
                //
                // Remember the devinfo set's associated setup class GUID, to
                // be used later in filtering device interfaces based on the
                // setup class of their underlying devnode.
                //
                ExistingClassGuid = &(pDeviceInfoSet->ClassGuid);

                if(ClassGuid && !(Flags & (DIGCF_ALLCLASSES | DIGCF_DEVICEINTERFACE))) {

                    if(!IsEqualGUID(ExistingClassGuid, ClassGuid)) {
                        Err = ERROR_CLASS_MISMATCH;
                        goto clean0;
                    }
                }

            } else {
                //
                // The caller-supplied devinfo set had no associated setup
                // class.  Remember that fact, so that we won't try to filter
                // device interfaces based on the underlying devices' setup
                // class.
                //
                ExistingClassGuid = NULL;
            }
        }

        if(GetInterfaceList = (Flags & DIGCF_DEVICEINTERFACE)) {  // yes, we want an assignment here.
            //
            // Open the root of the DeviceClasses registry branch
            //
            hKeyDevClassRoot = SetupDiOpenClassRegKeyEx(NULL,
                                                        KEY_READ,
                                                        DIOCR_INTERFACE,
                                                        MachineName,
                                                        NULL
                                                       );

            if(hKeyDevClassRoot == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                goto clean0;
            }

            if(Flags & DIGCF_ALLCLASSES) {
                InterfaceClassKeyIndex = 0;
                ClassGuid = &GuidBuffer;
            }

            if(Flags & DIGCF_PRESENT) {
                //
                // Since we're only going to be retrieving a list of device
                // interfaces that are currently 'active', we can set the
                // 'IsActive' flag to always be TRUE.
                //
                IsActive = TRUE;
            }
        }

        //
        // As an optimization, start out with a 16K (character) buffer, in the hopes of avoiding
        // two scans through the hardware tree (once to get the size, and again to get the data).
        //
        DevIdBufferLen = 16384;

        do {

            if(GetInterfaceList) {

                if(Flags & DIGCF_ALLCLASSES) {
                    //
                    // We have to enumerate through all device interface classes, and retrieve
                    // a list of device interfaces for each one.
                    //
                    DataBufferSize = SIZECHARS(InterfaceGuidString);

                    switch(RegEnumKeyEx(hKeyDevClassRoot,
                                        InterfaceClassKeyIndex,
                                        InterfaceGuidString,
                                        &DataBufferSize,
                                        NULL,
                                        NULL,
                                        NULL,
                                        &LastWriteTime)) {

                        case ERROR_SUCCESS :
                            GetNextInterfaceClass = TRUE;
                            InterfaceClassKeyIndex++;
                            break;

                        case ERROR_NO_MORE_ITEMS :
                            //
                            // We've processed all of the interface class GUIDs--we're done.
                            //
                            GetNextInterfaceClass = FALSE;
                            continue;

                        default :
                            //
                            // Some other error occurred.  Skip this subkey, and continue
                            // with the next one.
                            //
                            GetNextInterfaceClass = TRUE;
                            InterfaceClassKeyIndex++;
                            continue;
                    }

                    //
                    // Convert the GUID string retrieved above into its binary form, for use
                    // below.
                    //
                    if(pSetupGuidFromString(InterfaceGuidString, &GuidBuffer) != NO_ERROR) {
                        //
                        // The subkey we enumerated is not a valid GUID string--skip this
                        // subkey, and continue on with the next one.
                        //
                        continue;
                    }

                } else {
                    //
                    // We're just retrieving devices for a single interface class (which the
                    // caller specified).  All we need to do is initialize the GUID string
                    // buffer with the textual form of the GUID.
                    //
                    pSetupStringFromGuid(ClassGuid,
                                         InterfaceGuidString,
                                         SIZECHARS(InterfaceGuidString)
                                        );
                    //
                    // We only need to go through this list once.
                    //
                    GetNextInterfaceClass = FALSE;
                }

                //
                // We'll be using the same character buffer to store each device instance ID
                // we're opening below.
                //
                DeviceInstanceToOpen = DeviceInstanceId;

            } else {
                //
                // We're not retrieving a list of device interfaces, so we'll never go through
                // this loop more than once.
                //
                GetNextInterfaceClass = FALSE;
            }

            //
            // Retrieve a list of device names.
            //
            while(TRUE) {

                if(!DevIdBuffer) {

                    if(!(DevIdBuffer = MyMalloc(DevIdBufferLen * sizeof(TCHAR)))) {
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }
                }

                if(GetInterfaceList) {
                    cr = CM_Get_Device_Interface_List_Ex((LPGUID)ClassGuid,
                                                         (DEVINSTID)Enumerator,
                                                         DevIdBuffer,
                                                         DevIdBufferLen,
                                                         (Flags & DIGCF_PRESENT)
                                                             ? CM_GET_DEVICE_INTERFACE_LIST_PRESENT
                                                             : CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES,
                                                         pDeviceInfoSet->hMachine
                                                        );
                } else {
                    cr = CM_Get_Device_ID_List_Ex(Enumerator,
                                                  DevIdBuffer,
                                                  DevIdBufferLen,
                                                  Enumerator ? CM_GETIDLIST_FILTER_ENUMERATOR
                                                             : CM_GETIDLIST_FILTER_NONE,
                                                  pDeviceInfoSet->hMachine
                                                 );
                }

                if(cr == CR_SUCCESS) {
                    //
                    // Device list successfully retrieved!
                    //
                    break;

                } else {
                    //
                    // Free the current buffer before determining what error occurred.
                    //
                    MyFree(DevIdBuffer);
                    DevIdBuffer = NULL;

                    if(cr == CR_BUFFER_SMALL) {
                        //
                        // OK, so our buffer wasn't big enough--just how big
                        // does it need to be?
                        //
                        if(GetInterfaceList) {

                            if(CM_Get_Device_Interface_List_Size_Ex(&DevIdBufferLen,
                                                                    (LPGUID)ClassGuid,
                                                                    (DEVINSTID)Enumerator,
                                                                    (Flags & DIGCF_PRESENT)
                                                                        ? CM_GET_DEVICE_INTERFACE_LIST_PRESENT
                                                                        : CM_GET_DEVICE_INTERFACE_LIST_ALL_DEVICES,
                                                                    pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                                //
                                // Couldn't retrieve the list size--this should
                                // never happen.
                                //
                                Err = ERROR_INVALID_DATA;
                                goto clean0;
                            }

                        } else {

                            if(CM_Get_Device_ID_List_Size_Ex(&DevIdBufferLen,
                                                          Enumerator,
                                                          Enumerator ? CM_GETIDLIST_FILTER_ENUMERATOR
                                                                     : CM_GETIDLIST_FILTER_NONE,
                                                          pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                                //
                                // Couldn't retrieve the list size--this should
                                // never happen.
                                //
                                Err = ERROR_INVALID_DATA;
                                goto clean0;
                            }
                        }

                    } else {
                        //
                        // An error occurred, and it wasn't because we supplied
                        // too small a buffer.
                        //
                        Err = ERROR_INVALID_DATA;
                        goto clean0;
                    }
                }
            }

            //
            // We have now retrieved a list of all the specified devices.  If
            // these are device interfaces, we need to open the key for this
            // interface class underneath the DeviceClasses key.
            //
            if(GetInterfaceList) {

                if(RegOpenKeyEx(hKeyDevClassRoot,
                                InterfaceGuidString,
                                0,
                                KEY_READ,
                                &hKeyCurDevClass) != ERROR_SUCCESS) {
                    //
                    // Make sure hKeyCurDevClass is still set to
                    // INVALID_HANDLE_VALUE, so that we'll know not to close it.
                    //
                    hKeyCurDevClass = INVALID_HANDLE_VALUE;

                    //
                    // Skip this interface class.
                    //
                    continue;
                }
            }

            //
            // Now create device information elements from the members of this
            // list.
            //
            for(CurDevId = DevIdBuffer;
                *CurDevId;
                CurDevId += lstrlen(CurDevId) + 1) {

                //
                // If this is a device interface, we must retrieve the
                // associated device instance name.
                //
                if(GetInterfaceList) {

                    if(NO_ERROR != pSetupGetDevInstNameAndStatusForDeviceInterface(
                                       hKeyCurDevClass,
                                       CurDevId,
                                       DeviceInstanceId,
                                       SIZECHARS(DeviceInstanceId),
                                       (Flags & DIGCF_PRESENT) ? NULL : &IsActive,
                                       &IsDefault)) {
                        //
                        // Couldn't retrieve the name of the owning device
                        // instance--skip this device interface.
                        //
                        continue;
                    }

                    if ((Flags & DIGCF_DEFAULT) && !IsDefault) {
                        //
                        // The caller only wants the default device interface.
                        // Since CM_Get_Device_Interface_List places the default
                        // device interface first in the list (if there is one),
                        // and we stop searching the list when we find it, we
                        // know that if we get here, there is no default device
                        // interface for this interface class.
                        //
                        Err = ERROR_NO_DEFAULT_DEVICE_INTERFACE;
                        goto clean0;
                    }

                } else {
                    DeviceInstanceToOpen = CurDevId;
                }

                if(Flags & DIGCF_PROFILE) {
                    //
                    // Verify that this device instance is part of the current
                    // hardware profile.
                    //
                    if(CM_Get_HW_Prof_Flags_Ex(DeviceInstanceToOpen,
                                               0,
                                               &CSConfigFlags,
                                               0,
                                               pDeviceInfoSet->hMachine) == CR_SUCCESS) {

                        if(CSConfigFlags & CSCONFIGFLAG_DO_NOT_CREATE) {
                            continue;
                        }
                    }
                }

                //
                // Note the last parameter in the following call to
                // pSetupOpenAndAddNewDevInfoElem--in the case where we're
                // adding to an existing caller-supplied HDEVINFO set (i.e.,
                // hDevInfo is NULL), we cast the HDEVINFO to a DEVICE_INFO_SET
                // pointer, since that's what ends up getting stored in the
                // ContainingDeviceInfoSet field of a devinfo element structure.
                // That field is used for quick validation that a caller-
                // supplied device information element is valid.
                //
                // If we ever decide to change the internal implementation of
                // how an HDEVINFO translates into its underlying
                // DEVICE_INFO_SET, then we'll need to update the code below
                // accordingly.  (See also the comments under
                // AccessDeviceInfoSet, CloneDeviceInfoSet, and
                // RollbackDeviceInfoSet.)
                //
                Err = pSetupOpenAndAddNewDevInfoElem(pDeviceInfoSet,
                                                     DeviceInstanceToOpen,
                                                     !(Flags & DIGCF_PRESENT),
                                                     ((Flags & (DIGCF_ALLCLASSES | DIGCF_DEVICEINTERFACE))
                                                        ? ExistingClassGuid
                                                        : ClassGuid),
                                                     hwndParent,
                                                     &DevInfoElem,
                                                     (GetInterfaceList || !hDevInfo),
                                                     &DevInfoAlreadyPresent,
                                                     FALSE,
                                                     0,
                                                     (hDevInfo ? pDeviceInfoSet : (PDEVICE_INFO_SET)DeviceInfoSet)
                                                    );

                if(Err != NO_ERROR) {

                    if(Err == ERROR_NOT_ENOUGH_MEMORY) {
                        goto clean0;
                    }

                    Err = NO_ERROR;
                    continue;
                }

                if(GetInterfaceList) {
                    //
                    // Now that we've successfully opened up the device instance that 'owns'
                    // this device interface, add a new device interface node onto this
                    // devinfo element's list.
                    //
                    if(NO_ERROR != (Err = pSetupAddDeviceInterfaceToDevInfoElem(pDeviceInfoSet,
                                                                                DevInfoElem,
                                                                                ClassGuid,
                                                                                CurDevId,
                                                                                IsActive,
                                                                                IsDefault,
                                                                                !hDevInfo,
                                                                                FALSE,
                                                                                NULL))) {
                        //
                        // The only error we should be getting back from this routine is
                        // out-of-memory, which is always a fatal error.
                        //
                        goto clean0;
                    }

                    if ((Flags & DIGCF_DEFAULT) && IsDefault) {
                        //
                        // The caller only wants the default device interface,
                        // and this is it.
                        //
                        if ((Flags & DIGCF_PRESENT) && !IsActive) {
                            //
                            // The caller doesn't want to know about a
                            // non-present default device interface.
                            //
                            Err = ERROR_NO_DEFAULT_DEVICE_INTERFACE;
                        }
                        RegCloseKey(hKeyCurDevClass);
                        hKeyCurDevClass = INVALID_HANDLE_VALUE;
                        goto clean0;
                    }
                }
            }

            //
            // If we're working with device interfaces, we need to close the interface
            // class key we opened above.
            //
            if(GetInterfaceList) {
                RegCloseKey(hKeyCurDevClass);
                hKeyCurDevClass = INVALID_HANDLE_VALUE;
            }

        } while(GetNextInterfaceClass);

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;

        if(hKeyCurDevClass != INVALID_HANDLE_VALUE) {
            RegCloseKey(hKeyCurDevClass);
        }

        //
        // Access the following variables, so the compiler will respect
        // the statement ordering in the try clause.
        //
        DevIdBuffer = DevIdBuffer;
        hKeyDevClassRoot = hKeyDevClassRoot;
    }

    if(DevIdBuffer) {
        MyFree(DevIdBuffer);
    }

    if(hKeyDevClassRoot != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyDevClassRoot);
    }

    if(Err != NO_ERROR) {
        if(hDevInfo) {
            DestroyDeviceInfoSet(hDevInfo, pDeviceInfoSet);
        } else {
            if(!(pDeviceInfoSet = RollbackDeviceInfoSet(DeviceInfoSet, pDeviceInfoSet))) {
                MYASSERT(pDeviceInfoSet);
            } else {
                UnlockDeviceInfoSet(pDeviceInfoSet);
            }
        }
        SetLastError(Err);
        hDevInfo = INVALID_HANDLE_VALUE;
    } else {
        if(!hDevInfo) {
            //
            // We retrieved additional elements into an existing device
            // information set.  Replace the existing device information set
            // with the new one (i.e., into the same handle), and return the
            // same HDEVINFO handle that the caller passed in as the
            // DeviceInfoSet parameter.
            //
            pDeviceInfoSet = CommitDeviceInfoSet(DeviceInfoSet, pDeviceInfoSet);
            MYASSERT(pDeviceInfoSet);

            //
            // Set hDevInfo to be the same as the DeviceInfoSet handle we were
            // passed in, so that we can return it to the caller.
            //
            hDevInfo = DeviceInfoSet;
            MYASSERT(hDevInfo);
        }
        if (pDeviceInfoSet) {
            UnlockDeviceInfoSet(pDeviceInfoSet);
        }
        MYASSERT(hDevInfo != INVALID_HANDLE_VALUE);
    }

    return hDevInfo;
}


BOOL
WINAPI
SetupDiSetDeviceInterfaceDefault(
    IN HDEVINFO DeviceInfoSet,
    IN OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData,
    IN DWORD Flags,
    IN PVOID Reserved
    )
/*++

Routine Description:

    This routine sets the specified device interface as the default device
    interface for its class.

Arguments:

    DeviceInfoSet - Points to the device information set containing the device
        interface for which to set as the default device interface. This handle
        is typically returned by SetupDiGetClassDevs.

    DeviceInterfaceData - Points to a structure that identifies the device
        interface within the device information set. This pointer is typically
        returned by SetupDiEnumDeviceInterfaces.  If successful, this routine
        will update the information contained in this structure.

    Flags - Not used, must be zero.

    Reserved - Reserved for future use, must be NULL.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    The caller must have the appropriate permission to set the default device
    interface.

--*/
{
    DWORD Err;
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;
    PCTSTR MachineName, DeviceInterfaceName;
    HKEY hKeyInterfaceClass = INVALID_HANDLE_VALUE;
    BOOL IsActive, IsDefault;


    //
    // Make sure the user didn't pass us anything in the Reserved parameter.
    //
    if(Reserved) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(Flags & ~(0x0)) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // First, find the devinfo element that owns this device interface (for validation).
        //
        if(!(DevInfoElem = FindDevInfoElemForDeviceInterface(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }


        //
        // Retrieve the name of the machine associated with this DeviceInfoSet.
        //
        if(pDeviceInfoSet->hMachine) {
            MYASSERT(pDeviceInfoSet->MachineName != -1);
            MachineName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                   pDeviceInfoSet->MachineName);
        } else {
            MachineName = NULL;
        }

        //
        // The Reserved field contains a pointer to the underlying device interface node.
        //
        DeviceInterfaceNode = (PDEVICE_INTERFACE_NODE)(DeviceInterfaceData->Reserved);

        //
        // Retrieve the device path (symbolic link name) for this device interface.
        //
        DeviceInterfaceName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                       DeviceInterfaceNode->SymLinkName);

        //
        // Open this interface class key under the DeviceClasses registry branch.
        //
        hKeyInterfaceClass = SetupDiOpenClassRegKeyEx(&DeviceInterfaceData->InterfaceClassGuid,
                                                      KEY_READ | KEY_WRITE,
                                                      DIOCR_INTERFACE,
                                                      MachineName,
                                                      NULL);
        if(hKeyInterfaceClass == INVALID_HANDLE_VALUE) {
            Err = GetLastError();
            goto clean0;
        }

        //
        // Get the current status of this device interface.
        //
        Err = pSetupGetDevInstNameAndStatusForDeviceInterface(hKeyInterfaceClass,
                                                              DeviceInterfaceName,
                                                              NULL,
                                                              0,
                                                              &IsActive,
                                                              &IsDefault);
        if (Err != NO_ERROR) {
            goto clean0;
        }

        //
        // If this interface is already the default, then we're done.
        //
        if (IsDefault) {
            goto clean1;
        }

        //
        // Set the "Default" value under this interface class key to this device
        // interface.
        //
        Err = RegSetValueEx(hKeyInterfaceClass,
                            pszDefault,
                            0,
                            REG_SZ,
                            (PBYTE)DeviceInterfaceName,
                            (lstrlen(DeviceInterfaceName) + 1) * sizeof(TCHAR));
        if (Err != NO_ERROR) {
            goto clean0;
        }

        //
        // This interface was successfully set as the default device interface
        // for this interface class.
        //
        IsDefault = TRUE;

    clean1:
        //
        // Update the flags for this interface.
        //
        DeviceInterfaceNode->Flags = (DeviceInterfaceNode->Flags & ~SPINT_ACTIVE)  | (IsActive  ? SPINT_ACTIVE  : 0);
        DeviceInterfaceNode->Flags = (DeviceInterfaceNode->Flags & ~SPINT_DEFAULT) | (IsDefault ? SPINT_DEFAULT : 0);

        //
        // Finally, update the flags in the caller-supplied buffer to indicate the new status
        // of this device interface.
        //
        DeviceInterfaceData->Flags = DeviceInterfaceNode->Flags;

    clean0:

        if(hKeyInterfaceClass != INVALID_HANDLE_VALUE) {
            RegCloseKey(hKeyInterfaceClass);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}


DWORD
pSetupAddNewDeviceInfoElement(
    IN  PDEVICE_INFO_SET pDeviceInfoSet,
    IN  DEVINST          DevInst,
    IN  CONST GUID      *ClassGuid,
    IN  PCTSTR           Description,             OPTIONAL
    IN  HWND             hwndParent,              OPTIONAL
    IN  DWORD            DiElemFlags,
    IN  PDEVICE_INFO_SET ContainingDeviceInfoSet,
    OUT PDEVINFO_ELEM   *DeviceInfoElement
    )
/*++

Routine Description:

    This routine creates a new device information element based on the
    supplied information, and adds it to the specified device information set.
    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    pDeviceInfoSet - Device information set to add this new element to.

    DevInst - Supplies the device instance handle of the element to be added.

    ClassGuid - Class GUID of the element to be added.

    Description - Optionally, supplies the description of the element to
        be added.

    hwndParent - Optionally, supplies the handle to the top level window for
        UI relating to this element.

    DiElemFlags - Specifies flags pertaining to the device information element
        being created.

    ContainingDeviceInfoSet - Supplies a pointer to the device information set
        structure with which this element is to be associated.  This may be
        different from the pDeviceInfoSet parameter if we're working against a
        cloned devinfo set (i.e., to facilitate rollback).

    DeviceInfoElement - Supplies the address of the variable that receives a
        pointer to the newly-allocated device information element.

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise the
    ERROR_* code is returned.

Remarks:

    Since the new element is added onto the end of the existing list, our
    enumeration hint isn't invalidated.

--*/
{
    DWORD Err = NO_ERROR;
    TCHAR TempString[LINE_LEN];

    *DeviceInfoElement = NULL;


    try {
        //
        // If there is a class associated with this device information set,
        // verify that it is the same as that of the new element.
        //
        if(pDeviceInfoSet->HasClassGuid &&
           !IsEqualGUID(&(pDeviceInfoSet->ClassGuid), ClassGuid)) {

            Err = ERROR_CLASS_MISMATCH;
            goto clean0;

        }

        //
        // Allocate storage for the element.
        //
        if(!(*DeviceInfoElement = MyMalloc(sizeof(DEVINFO_ELEM)))) {

            Err = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }

        ZeroMemory(*DeviceInfoElement, sizeof(DEVINFO_ELEM));

        //
        // Store the address of the containing devinfo set in the structure
        // for this element.  This is used for efficient validation of a
        // caller-supplied SP_DEVINFO_DATA.
        //
        (*DeviceInfoElement)->ContainingDeviceInfoSet = ContainingDeviceInfoSet;

        //
        // Initialize the element with the specified information
        //
        CopyMemory(&((*DeviceInfoElement)->ClassGuid),
                   ClassGuid,
                   sizeof(GUID)
                  );
        (*DeviceInfoElement)->InstallParamBlock.hwndParent = hwndParent;

        if(Description) {
            //
            // Set the device instance's DeviceDesc property to the specified
            // description.
            //
            CM_Set_DevInst_Registry_Property_Ex(DevInst,
                                             CM_DRP_DEVICEDESC,
                                             Description,
                                             (lstrlen(Description) + 1) * sizeof(TCHAR),
                                             0,
                                             pDeviceInfoSet->hMachine);

            //
            // Store two versions of the description--one case-sensitive (for display)
            // and the other case-insensitive (for fast lookup).
            //
            MYVERIFY(SUCCEEDED(StringCchCopy(TempString, SIZECHARS(TempString), Description)));

            if((((*DeviceInfoElement)->DeviceDescriptionDisplayName =
                      pStringTableAddString(pDeviceInfoSet->StringTable,
                                            TempString,
                                            STRTAB_CASE_SENSITIVE,
                                            NULL,0)) == -1) ||
               (((*DeviceInfoElement)->DeviceDescription =
                      pStringTableAddString(pDeviceInfoSet->StringTable,
                                            TempString,
                                            STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                            NULL,0)) == -1)) {

                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

        } else {
            (*DeviceInfoElement)->DeviceDescription =
                (*DeviceInfoElement)->DeviceDescriptionDisplayName = -1;
        }

        (*DeviceInfoElement)->DevInst = DevInst;
        (*DeviceInfoElement)->DiElemFlags = DiElemFlags;
        (*DeviceInfoElement)->InstallParamBlock.DriverPath = -1;
        (*DeviceInfoElement)->InstallParamBlock.CoInstallerCount = -1;

        //
        // If we're in GUI-mode setup on Windows NT, we'll automatically set
        // the DI_FLAGSEX_IN_SYSTEM_SETUP flag in the devinstall parameter
        // block for this devinfo element.
        //
        if(GuiSetupInProgress) {
            (*DeviceInfoElement)->InstallParamBlock.FlagsEx |= DI_FLAGSEX_IN_SYSTEM_SETUP;
        }

        //
        // If we're in non-interactive mode, set the "be quiet" bits.
        //
        if(GlobalSetupFlags & (PSPGF_NONINTERACTIVE|PSPGF_UNATTENDED_SETUP)) {
            (*DeviceInfoElement)->InstallParamBlock.Flags   |= DI_QUIETINSTALL;
            (*DeviceInfoElement)->InstallParamBlock.FlagsEx |= DI_FLAGSEX_NOUIONQUERYREMOVE;
        }

        //
        // Initialize our enumeration 'hints'
        //
        (*DeviceInfoElement)->ClassDriverEnumHintIndex = INVALID_ENUM_INDEX;
        (*DeviceInfoElement)->CompatDriverEnumHintIndex = INVALID_ENUM_INDEX;

        //
        // Create a log context separate from the parent.
        //
        if(NO_ERROR != CreateLogContext(NULL,
                                        FALSE,
                                        &((*DeviceInfoElement)->InstallParamBlock.LogContext))) {
            //
            // If it failed, we will inherit the log context, since it's better
            // than nothing.  In theory, this should never happen, or if it
            // does, other things will fail too...
            //
            Err = InheritLogContext(
                      pDeviceInfoSet->InstallParamBlock.LogContext,
                      &(*DeviceInfoElement)->InstallParamBlock.LogContext
                      );

            if(Err != NO_ERROR) {
                //
                // If we can't get a log context at all, then we gotta bail...
                //
                goto clean0;
            }
        }

        //
        // Now, insert the new element at the end of the device
        // information set's list of elements.
        //
        if(pDeviceInfoSet->DeviceInfoHead) {
            pDeviceInfoSet->DeviceInfoTail->Next = *DeviceInfoElement;
            pDeviceInfoSet->DeviceInfoTail = *DeviceInfoElement;
        } else {
            pDeviceInfoSet->DeviceInfoHead =
            pDeviceInfoSet->DeviceInfoTail = *DeviceInfoElement;
        }
        pDeviceInfoSet->DeviceInfoCount++;

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    if((Err != NO_ERROR) && *DeviceInfoElement) {

        MyFree(*DeviceInfoElement);
        *DeviceInfoElement = NULL;
    }

    return Err;
}


DWORD
pSetupClassGuidFromDevInst(
    IN  DEVINST DevInst,
    IN  HMACHINE hMachine,
    OUT LPGUID  ClassGuid
    )
/*++

Routine Description:

    This routine attempts to retrieve the class GUID for the specified device
    instance from its device registry key.  If it cannot retrieve one, it
    returns GUID_NULL.

Arguments:

    DevInst - Supplies the handle of the device instance whose class GUID is
        to be retrieved.

        hMachine - Machine context to operate in

    ClassGuid - Supplies the address of the variable that receives the class
        GUID, or GUID_NULL if no class GUID can be retrieved.

Return Value:

    If the function succeeds, the return value is NO_ERROR.
    If the function fails, an ERROR_* code is returned.  (Presently, the only
    failure condition returned is ERROR_NOT_ENOUGH_MEMORY.)

--*/
{
    DWORD NumGuids;
    TCHAR TempString[GUID_STRING_LEN];
    DWORD StringSize;

    StringSize = sizeof(TempString);
    if(CM_Get_DevInst_Registry_Property_Ex(DevInst,
                                        CM_DRP_CLASSGUID,
                                        NULL,
                                        TempString,
                                        &StringSize,
                                        0,
                                        hMachine) == CR_SUCCESS) {
        //
        // We retrieved the class GUID (in string form) for this device
        // instance--now, convert it into its binary representation.
        //
        return pSetupGuidFromString(TempString, ClassGuid);
    }

    //
    // We couldn't retrieve a ClassGUID--let's see if there's a Class name we can
    // work with.
    //
    StringSize = sizeof(TempString);
    if(CM_Get_DevInst_Registry_Property_Ex(DevInst,
                                        CM_DRP_CLASS,
                                        NULL,
                                        TempString,
                                        &StringSize,
                                        0,
                                        hMachine) == CR_SUCCESS) {
        //
        // OK, we found out the class name.  Now see if we can find a
        // single class GUID to match it.
        //
        if(SetupDiClassGuidsFromName(TempString, ClassGuid, 1, &NumGuids) && NumGuids) {
            //
            // We found exactly one, so we're happy.
            //
            return NO_ERROR;
        }
    }

    //
    // We have no idea what class of device this is, so use GUID_NULL.
    //
    CopyMemory(ClassGuid, &GUID_NULL, sizeof(GUID));

    return NO_ERROR;
}


BOOL
WINAPI
SetupDiDeleteDeviceInfo(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This routine deletes a member from the specified device information set.
    THIS DOES NOT DELETE ACTUAL DEVICES!

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device information element to be deleted.

    DeviceInfoData - Supplies a pointer to the SP_DEVINFO_DATA structure for
        the device information element to be deleted.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If the specified device information element is explicitly in use by a wizard
    page, then the call will fail, and GetLastError will return
    ERROR_DEVINFO_DATA_LOCKED.  This will happen if a handle to a wizard page was
    retrieved via SetupDiGetWizardPage, and this element was specified, along with
    the DIWP_FLAG_USE_DEVINFO_DATA flag.  In order to be able to delete this element,
    the wizard HPROPSHEETPAGE handle must be closed (either explicitly, or after a
    call to PropertySheet() completes).

    Since we don't track where this devinfo element lives in relation to our
    current enumeration hint, we just invalidate the hint, so that next
    enumeration must scan from the beginning of the list.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM ElemToDelete, PrevElem, NextElem;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element we are to delete.
        //
        ElemToDelete = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                 DeviceInfoData,
                                                 &PrevElem
                                                );
        if(ElemToDelete) {
            //
            // Make sure that this element isn't currently locked by
            // a wizard page.
            //
            if(ElemToDelete->DiElemFlags & DIE_IS_LOCKED) {
                Err = ERROR_DEVINFO_DATA_LOCKED;
                goto clean0;
            }

            NextElem = ElemToDelete->Next;

            //
            // Destroy the devinfo element.  We need to do this before
            // altering the list, because we will be calling the class
            // installer with DIF_DESTROYPRIVATEDATA, and it needs to
            // be able to access this element (obviously).
            //
            DestroyDeviceInfoElement(DeviceInfoSet, pDeviceInfoSet, ElemToDelete);

            //
            // Now remove the element from the list.
            //
            if(PrevElem) {
                PrevElem->Next = NextElem;
            } else {
                pDeviceInfoSet->DeviceInfoHead = NextElem;
            }

            if(!NextElem) {
                pDeviceInfoSet->DeviceInfoTail = PrevElem;
            }

            MYASSERT(pDeviceInfoSet->DeviceInfoCount > 0);
            pDeviceInfoSet->DeviceInfoCount--;

            //
            // If this element was the currently selected device for this
            // set, then reset the device selection.
            //
            if(pDeviceInfoSet->SelectedDevInfoElem == ElemToDelete) {
                pDeviceInfoSet->SelectedDevInfoElem = NULL;
            }

            //
            // Invalidate our enumeration hint for this devinfo element list.
            //
            pDeviceInfoSet->DeviceInfoEnumHint = NULL;
            pDeviceInfoSet->DeviceInfoEnumHintIndex = INVALID_ENUM_INDEX;

        } else {
            Err = ERROR_INVALID_PARAMETER;
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiEnumDeviceInfo(
    IN  HDEVINFO         DeviceInfoSet,
    IN  DWORD            MemberIndex,
    OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    This API enumerates the members of the specified device information set.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set whose members
        are to be enumerated.

    MemberIndex - Supplies the zero-based index of the device information member
        to be retreived.

    DeviceInfoData - Supplies a pointer to a SP_DEVINFO_DATA structure that will
        receive information about this member.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    To enumerate device information members, an application should initially call
    the SetupDiEnumDeviceInfo function with the MemberIndex parameter set to zero.
    The application should then increment MemberIndex and call the
    SetupDiEnumDeviceInfo function until there are no more values (i.e., the
    function fails, and GetLastError returns ERROR_NO_MORE_ITEMS).

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, i;
    PDEVINFO_ELEM DevInfoElem;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {

        if(MemberIndex >= pDeviceInfoSet->DeviceInfoCount) {
            Err = ERROR_NO_MORE_ITEMS;
            goto clean0;
        }

        //
        // Find the element corresponding to the specified index (using our
        // enumeration hint optimization, if possible)
        //
        if(pDeviceInfoSet->DeviceInfoEnumHintIndex <= MemberIndex) {
            MYASSERT(pDeviceInfoSet->DeviceInfoEnumHint);
            DevInfoElem = pDeviceInfoSet->DeviceInfoEnumHint;
            i = pDeviceInfoSet->DeviceInfoEnumHintIndex;
        } else {
            DevInfoElem = pDeviceInfoSet->DeviceInfoHead;
            i = 0;
        }
        for(; i < MemberIndex; i++) {
            DevInfoElem = DevInfoElem->Next;
        }

        if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                              DevInfoElem,
                                              DeviceInfoData))) {
            Err = ERROR_INVALID_USER_BUFFER;
        }

        //
        // Remember this element as our new enumeration hint.
        //
        pDeviceInfoSet->DeviceInfoEnumHintIndex = MemberIndex;
        pDeviceInfoSet->DeviceInfoEnumHint = DevInfoElem;

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiRegisterDeviceInfo(
    IN     HDEVINFO           DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA   DeviceInfoData,
    IN     DWORD              Flags,
    IN     PSP_DETSIG_CMPPROC CompareProc,      OPTIONAL
    IN     PVOID              CompareContext,   OPTIONAL
    OUT    PSP_DEVINFO_DATA   DupDeviceInfoData OPTIONAL
    )
/*++

Routine Description:

    This API registers a device instance with the Plug & Play Manager.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set that contains
        the device information element for this device instance.

    DeviceInfoData - Supplies a pointer to the SP_DEVINFO_DATA structure for the
        device instance being registered.  This is an IN OUT parameter, since the
        DevInst field of the structure may be updated with a new handle value upon
        return.

    Flags - Controls how the device is to be registered.  May be a combination of
        the following values:

            SPRDI_FIND_DUPS - Search for a previously-existing device instance
                              corresponding to this device information.  If this
                              flag is not specified, the device instance will be
                              registered, regardless of whether a device instance
                              already exists for it.

    CompareProc - Optionally, supplies a comparison callback function to be used in
        duplicate detection.  If specified, the function will be called for each
        device instance that is of the same class as the device instance being
        registered.  The prototype of the callback function is as follows:

            typedef DWORD (CALLBACK* PSP_DETSIG_CMPPROC)(
                IN HDEVINFO         DeviceInfoSet,
                IN PSP_DEVINFO_DATA NewDeviceData,
                IN PSP_DEVINFO_DATA ExistingDeviceData,
                IN PVOID            CompareContext      OPTIONAL
                );

        The compare function must return ERROR_DUPLICATE_FOUND if it finds the two
        devices to be duplicates of each other, and NO_ERROR otherwise.  If some
        other error (e.g., out-of-memory) is encountered, the callback should return
        the appropriate ERROR_* code indicating the failure that occurred.

        If a CompareProc is not supplied, and duplicate detection is requested, then a
        default comparison behavior will be used.  (See pSetupDupDevCompare for details.)

    CompareContext - Optionally, supplies the address of a caller-supplied context
        buffer that will be passed into the compare callback routine.  This parameter
        is ignored if CompareProc is not supplied.

    DupDeviceInfoData - Optionally, supplies a pointer to a device information
        element that will be initialized for the duplicate device instance, if any,
        discovered as a result of attempting to register this device.  This will
        be filled in if the function returns FALSE, and GetLastError returns
        ERROR_DUPLICATE_FOUND.  This device information element will be added as
        a member of the specified DeviceInfoSet (if it wasn't already a member).
        If DupDeviceInfoData is not supplied, then the duplicate WILL NOT be added
        to the device information set.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    After registering a device information element, the caller should refresh any
    stored copies of the devinst handle associated with this device, as the handle
    value may have changed during registration.  The caller need not re-retrieve
    the SP_DEVINFO_DATA structure, because the devinst field of the DeviceInfoData
    structure will be updated to reflect the current handle value.

    This API may invalidate our devinfo element enumeration hint.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem, CurDevInfoElem;
    CONFIGRET cr;
    ULONG DevIdBufferLen, ulStatus, ulProblem;
    PTCHAR DevIdBuffer = NULL;
    PTSTR CurDevId;
    DEVINST ParentDevInst;
    BOOL AlreadyPresent;
    SP_DEVINFO_DATA CurDevInfoData;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    DEFAULT_DEVCMP_CONTEXT DevCmpContext;
    LOG_CONF NewDevLogConfig;
    RES_DES NewDevResDes;

    if(Flags & ~SPRDI_FIND_DUPS) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    //
    // Initialize the following variables so we'll know whether we need to free any of their
    // associated resources.
    //
    ZeroMemory(&DevCmpContext, sizeof(DevCmpContext));
    NewDevLogConfig = (LOG_CONF)NULL;
    NewDevResDes = (RES_DES)NULL;

    try {

        DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                DeviceInfoData,
                                                NULL
                                               );
        if(!DevInfoElem) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        } else if(DevInfoElem->DiElemFlags & DIE_IS_REGISTERED) {
            //
            // Nothing to do--it's already been registered.
            //
            goto clean0;
        }

        //
        // If the caller requested duplicate detection then retrieve
        // all device instances of this class, and compare each one
        // with the device instance being registered.
        //
        if(Flags & SPRDI_FIND_DUPS) {

            do {

                if(CM_Get_Device_ID_List_Size_Ex(&DevIdBufferLen, NULL, CM_GETIDLIST_FILTER_NONE,
                                                 pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
                } else if(!DevIdBufferLen) {
                    break;
                }

                if(!(DevIdBuffer = MyMalloc(DevIdBufferLen * sizeof(TCHAR)))) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }

                cr = CM_Get_Device_ID_List_Ex(NULL,
                                           DevIdBuffer,
                                           DevIdBufferLen,
                                           CM_GETIDLIST_FILTER_NONE,
                                           pDeviceInfoSet->hMachine);
                if(cr == CR_BUFFER_SMALL) {
                    //
                    // This will only happen if a device instance was added between
                    // the time that we calculated the size, and when we attempted
                    // to retrieve the list.  In this case, we'll simply retrieve
                    // the size again, and re-attempt to retrieve the list.
                    //
                    MyFree(DevIdBuffer);
                    DevIdBuffer = NULL;
                } else if(cr != CR_SUCCESS) {
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
                }

            } while(cr == CR_BUFFER_SMALL);

            if(!DevIdBufferLen) {
                goto NoDups;
            }

            //
            // Initialize the structure to be used during duplicate comparison callback.
            //
            CurDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);

            //
            // We have retrieved a list of every device instance in the system--now
            // do the comparison for each one that matches the class of the device
            // being registered.
            //

            if(!CompareProc) {
                //
                // We are supposed to do the comparisons, so set up to do our default comparison.
                //
                if((cr = CM_Get_First_Log_Conf_Ex(&NewDevLogConfig,
                                               DevInfoElem->DevInst,
                                               BOOT_LOG_CONF,
                                               pDeviceInfoSet->hMachine)) != CR_SUCCESS) {
                    //
                    // Ensure that our NewDevLogConfig handle is still NULL, so we won't try
                    // to free it.
                    //
                    NewDevLogConfig = (LOG_CONF)NULL;

                    if(cr == CR_INVALID_DEVINST) {
                        Err = ERROR_INVALID_PARAMETER;
                        goto clean0;
                    } else {
                        //
                        // The only value we should get here is CR_NO_MORE_LOG_CONF.
                        // In this case, there is no comparison data, so we assume there is
                        // no possibility of duplication.
                        //
                        goto NoDups;
                    }
                }

                if(CM_Get_Next_Res_Des_Ex(&NewDevResDes,
                                       NewDevLogConfig,
                                       ResType_ClassSpecific,
                                       NULL,
                                       0,
                                       pDeviceInfoSet->hMachine) != CR_SUCCESS) {
                    //
                    // Ensure that our NewDevResDes is still NULL, so we won't try to free it.
                    //
                    NewDevResDes = (RES_DES)NULL;

                    //
                    // Since we can't retrieve the ResDes handle, assume there are no duplicates.
                    //
                    goto NoDups;
                }

                //
                // Now retrieve the actual data for the ResDes.
                //
                do {

                    if((CM_Get_Res_Des_Data_Size_Ex(&DevCmpContext.CsResourceSize,
                                                 NewDevResDes,
                                                 0,
                                                 pDeviceInfoSet->hMachine) != CR_SUCCESS) ||
                       !DevCmpContext.CsResourceSize) {
                        //
                        // Can't find out the size of the data, or there is none--assume no dups.
                        //
                        goto NoDups;
                    }

                    if(DevCmpContext.NewDevCsResource = MyMalloc(DevCmpContext.CsResourceSize)) {

                        if((cr = CM_Get_Res_Des_Data_Ex(NewDevResDes,
                                                     DevCmpContext.NewDevCsResource,
                                                     DevCmpContext.CsResourceSize,
                                                     0,
                                                     pDeviceInfoSet->hMachine)) != CR_SUCCESS) {

                            if(cr == CR_BUFFER_SMALL) {
                                //
                                // Then someone increased the size of the resource data before we
                                // got a chance to read it.  Free our buffer and try again.
                                //
                                MyFree(DevCmpContext.NewDevCsResource);
                                DevCmpContext.NewDevCsResource = NULL;
                            } else {
                                //
                                // Some other error occurred (highly unlikely).  Assume no dups.
                                //
                                goto NoDups;
                            }
                        }

                    } else {
                        //
                        // not enough memory--this is bad enough for us to abort.
                        //
                        Err = ERROR_NOT_ENOUGH_MEMORY;
                        goto clean0;
                    }

                } while(cr != CR_SUCCESS);

                //
                // We have successfully retrieved the class-specific resource data for the new
                // device's boot LogConfig.  Now allocate a buffer of the same size to store the
                // corresponding resource data for each device instance we're comparing against.
                // We don't have to worry about devices whose resource data is larger, because
                // CM_Get_Res_Des_Data_Ex will do a partial fill to a buffer that's not large enough
                // to contain the entire structure.  Since our default comparison only compares
                // the PnP detect signature (i.e., it ignores the legacy data at the very end of
                // the buffer, we're guaranteed that we have enough data to make the determination.
                //
                if(!(DevCmpContext.CurDevCsResource = MyMalloc(DevCmpContext.CsResourceSize))) {
                    Err = ERROR_NOT_ENOUGH_MEMORY;
                    goto clean0;
                }

                CompareProc = pSetupDupDevCompare;
                CompareContext = &DevCmpContext;
            }

            for(CurDevId = DevIdBuffer;
                *CurDevId;
                CurDevId += lstrlen(CurDevId) + 1) {

                Err = pSetupOpenAndAddNewDevInfoElem(pDeviceInfoSet,
                                                     CurDevId,
                                                     TRUE,
                                                     &(DevInfoElem->ClassGuid),
                                                     pDeviceInfoSet->InstallParamBlock.hwndParent,
                                                     &CurDevInfoElem,
                                                     TRUE,
                                                     &AlreadyPresent,
                                                     FALSE,
                                                     0,
                                                     pDeviceInfoSet
                                                    );

                if(Err == ERROR_NOT_ENOUGH_MEMORY) {
                    //
                    // Out-of-memory error is the only one bad enough to get us to abort.
                    //
                    goto clean0;
                } else if(Err != NO_ERROR) {
                    //
                    // Just ignore this device instance, and move on to the next.
                    //
                    Err = NO_ERROR;
                    continue;
                }

                DevInfoDataFromDeviceInfoElement(pDeviceInfoSet, CurDevInfoElem, &CurDevInfoData);

                //
                // We now have the possible duplicate in our set.  Call the comparison callback
                // routine.
                //
                Err = CompareProc(DeviceInfoSet, DeviceInfoData, &CurDevInfoData, CompareContext);

                //
                // If the device instance was created temporarily for the comparison, then it
                // may need to be destroyed.  It should be destroyed if it wasn't a duplicate,
                // or if the duplicate output parameter wasn't supplied.
                //
                if(!AlreadyPresent) {
                    if((Err != ERROR_DUPLICATE_FOUND) || !DupDeviceInfoData) {
                        SetupDiDeleteDeviceInfo(DeviceInfoSet, &CurDevInfoData);
                    }
                }

                if(Err != NO_ERROR) {
                    goto clean0;
                }
            }
        }

NoDups:

        //
        // To turn this phantom device instance into a 'live' device instance, we simply call
        // CM_Create_DevInst_Ex, which does the right thing (without reenumerating the whole
        // hardware tree!).
        //
        if(CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                         DeviceInstanceId,
                         SIZECHARS(DeviceInstanceId),
                         0,
                         pDeviceInfoSet->hMachine) != CR_SUCCESS) {
            //
            // This should never happen!
            //
            Err = ERROR_NO_SUCH_DEVINST;
        } else if(CM_Get_Parent_Ex(&ParentDevInst, DevInfoElem->DevInst, 0,pDeviceInfoSet->hMachine) != CR_SUCCESS) {
            //
            // This should never happen!
            //
            Err = ERROR_NO_SUCH_DEVINST;
        } else if(CM_Create_DevInst_Ex(&(DevInfoElem->DevInst),
                             DeviceInstanceId,
                             ParentDevInst,
                             CM_CREATE_DEVINST_NORMAL |
                             CM_CREATE_DEVINST_DO_NOT_INSTALL,
                             pDeviceInfoSet->hMachine) == CR_SUCCESS) {
            //
            // Device is no longer a phantom!
            //
            DevInfoElem->DiElemFlags &= ~DIE_IS_PHANTOM;
        } else {
            //
            // This should never happen!
            //
            Err = ERROR_NO_SUCH_DEVINST;
            goto clean0;
        }

        DevInfoElem->DiElemFlags |= DIE_IS_REGISTERED;

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Access the following variables so the compiler will respect our statement
        // ordering in the try clause.
        //
        DevIdBuffer = DevIdBuffer;
        DevCmpContext.NewDevCsResource = DevCmpContext.NewDevCsResource;
        DevCmpContext.CurDevCsResource = DevCmpContext.CurDevCsResource;
        NewDevLogConfig = NewDevLogConfig;
        NewDevResDes = NewDevResDes;
    }

    if(DevIdBuffer) {
        MyFree(DevIdBuffer);
    }

    if(DevCmpContext.NewDevCsResource) {
        MyFree(DevCmpContext.NewDevCsResource);
    }

    if(DevCmpContext.CurDevCsResource) {
        MyFree(DevCmpContext.CurDevCsResource);
    }

    if(NewDevResDes) {
        CM_Free_Res_Des_Handle(NewDevResDes);
    }

    if(NewDevLogConfig) {
        CM_Free_Log_Conf_Handle(NewDevLogConfig);
    }

    if((Err == ERROR_DUPLICATE_FOUND) && DupDeviceInfoData) {
        //
        // The user supplied a buffer to receive the SP_DEVINFO_DATA
        // structure for the duplicate.
        //
        try {

            if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                  CurDevInfoElem,
                                                  DupDeviceInfoData))) {
                Err = ERROR_INVALID_USER_BUFFER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_USER_BUFFER;
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


DWORD
pSetupOpenAndAddNewDevInfoElem(
    IN  PDEVICE_INFO_SET pDeviceInfoSet,
    IN  PCTSTR           DeviceInstanceId,
    IN  BOOL             AllowPhantom,
    IN  CONST GUID      *ClassGuid,              OPTIONAL
    IN  HWND             hwndParent,             OPTIONAL
    OUT PDEVINFO_ELEM   *DevInfoElem,
    IN  BOOL             CheckIfAlreadyPresent,
    OUT PBOOL            AlreadyPresent,         OPTIONAL
    IN  BOOL             OpenExistingOnly,
    IN  ULONG            CmLocateFlags,
    IN  PDEVICE_INFO_SET ContainingDeviceInfoSet
    )
/*++

Routine Description:

    This routine opens a DEVINST handle to an existing device instance, and
    creates a new device information element for it.  This element is added
    to the specified device information set.
    ASSUMES THAT THE CALLING ROUTINE HAS ALREADY ACQUIRED THE LOCK!

Arguments:

    DeviceInfoSet - Device information set to add the new element to.

    DeviceInstanceId - Supplies the name of the device instance to be opened.

    AllowPhantom - Specifies whether or not phantom device instances should be
        allowed.  If this flag is not set, and the specified device instance is
        not currently active, then the routine will fail with ERROR_NO_SUCH_DEVINST.

    ClassGuid - Optionally, supplies the class that the specified device instance
        must be in order to be added to the set.  If the device instance is found
        to be of some class other than the one specified, then the call will fail with
        ERROR_CLASS_MISMATCH.  If this parameter is not specified, then the only check
        that will be done on the device's class is to make sure that it matches the
        class of the set (if the set has an associated class).

    hwndParent - Optionally, supplies the handle to the top level window for
        UI relating to this element.

    DevInfoElem - Optionally, supplies the address of the variable that
        receives a pointer to the newly-allocated device information element.

    CheckIfAlreadyPresent - Specifies whether this routine should check to see whether
        the device instance is already in the specified devinfo set.

    AlreadyPresent - Optionally, supplies the address of a boolean variable
        that is set to indicate whether or not the specified device instance
        was already in the device information set.  If CheckIfAlreadyThere is FALSE,
        then this parameter is ignored.

    OpenExistingOnly - If this flag is non-zero, then only succeed if the device
        information element is already in the set.  If this flag is TRUE, then
        the CheckIfAlreadyPresent flag must also be TRUE.

    CmLocateFlags - Supplies additional flags to be passed to CM_Locate_DevInst.

    ContainingDeviceInfoSet - Supplies a pointer to the device information set
        structure with which this element is to be associated.  This may be
        different from the pDeviceInfoSet parameter if we're working against a
        cloned devinfo set (i.e., to facilitate rollback).

Return Value:

    If the function succeeds, the return value is NO_ERROR, otherwise the
    ERROR_* code is returned.

Remarks:

    Note that since new device information elements are always added at the end
    of the existing list, the enumeration ordering is preserved, thus we don't
    need to invalidate our enumeration hint.

--*/
{
    CONFIGRET cr;
    DEVINST DevInst;
    DWORD Err, DiElemFlags;
    GUID GuidBuffer;

    if((cr = CM_Locate_DevInst_Ex(&DevInst,
                                 (DEVINSTID)DeviceInstanceId,
                                 CM_LOCATE_DEVINST_NORMAL | CmLocateFlags,
                                 pDeviceInfoSet->hMachine)) == CR_SUCCESS) {

        DiElemFlags = DIE_IS_REGISTERED;

    } else {

        if(cr == CR_INVALID_DEVICE_ID) {
            return ERROR_INVALID_DEVINST_NAME;
        } else if(!AllowPhantom) {
            return ERROR_NO_SUCH_DEVINST;
        }

        //
        // It could be that the device instance is present in the registry, but
        // not currently 'live'.  If this is the case, we'll be able to get a
        // handle to it by locating it as a phantom device instance.
        //
        if(CM_Locate_DevInst_Ex(&DevInst,
                                (DEVINSTID)DeviceInstanceId,
                                CM_LOCATE_DEVINST_PHANTOM | CmLocateFlags,
                                pDeviceInfoSet->hMachine) != CR_SUCCESS) {

            return ERROR_NO_SUCH_DEVINST;
        }

        DiElemFlags = DIE_IS_REGISTERED | DIE_IS_PHANTOM;
    }

    //
    // If requested, search through the current list of device information elements
    // to see if this element already exists.
    //
    if(CheckIfAlreadyPresent) {

        if(*DevInfoElem = FindDevInfoByDevInst(pDeviceInfoSet, DevInst, NULL)) {
            //
            // Make sure that this device instance is of the proper class, if a class GUID
            // filter was supplied.
            //
            if(ClassGuid && !IsEqualGUID(ClassGuid, &((*DevInfoElem)->ClassGuid))) {
                return ERROR_CLASS_MISMATCH;
            }

            if(AlreadyPresent) {
                *AlreadyPresent = TRUE;
            }
            return NO_ERROR;

        } else if(AlreadyPresent) {
            *AlreadyPresent = FALSE;
            if(OpenExistingOnly) {
                //
                // The requested device information element isn't in the set,
                // so we must fail the call.
                //
                return ERROR_NO_SUCH_DEVICE_INTERFACE;
            }
        }
    }

    //
    // Retrieve the class GUID for this device instance.
    //
    if((Err = pSetupClassGuidFromDevInst(DevInst, pDeviceInfoSet->hMachine,&GuidBuffer)) != NO_ERROR) {
        return Err;
    }

    //
    // If a class GUID filter was specified, then make sure that it matches the
    // class GUID for this device instance.
    //
    if(ClassGuid && !IsEqualGUID(ClassGuid, &GuidBuffer)) {
        return ERROR_CLASS_MISMATCH;
    }

    return pSetupAddNewDeviceInfoElement(pDeviceInfoSet,
                                         DevInst,
                                         &GuidBuffer,
                                         NULL,
                                         hwndParent,
                                         DiElemFlags,
                                         ContainingDeviceInfoSet,
                                         DevInfoElem
                                        );
}


DWORD
pSetupDupDevCompare(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA NewDeviceData,
    IN PSP_DEVINFO_DATA ExistingDeviceData,
    IN PVOID            CompareContext
    )
/*++

Routine Description:

    This routine is the default comparison routine for SetupDiRegisterDeviceInfo.
    It is used to determine whether the new device (i.e., the one being registered) is
    a duplicate of an existing device.

    The current algorithm for duplicate detection is as follows:

        Compare the BOOT_LOG_CONF logical configurations for the two devices.  Two
        resource types are used in this comparison--ResType_IO and ResType_ClassSpecific.
        The IO ranges, if any, for the two devices will be compared to see if they're
        identical.  Also, if the devices have a class-specific resource, then the
        CSD_ClassGuid, and the Plug&Play detect signature in CSD_Signature will be
        binary-compared.

        (lonnym): presently, the LogConfig only supports the class-specific resource,
        so I/O resource comparison is not done.

Arguments:

    DeviceInfoSet - Supplies the handle of the device information set containing both devices
        being compared.

    NewDeviceData - Supplies the address of the SP_DEVINFO_DATA for the device being registered.

    ExistingDeviceData - Supplies the address of the SP_DEVINFO_DATA for the existing device with
        which the new device is being compared.

    CompareContext - Supplies the address of a context buffer used during the comparison.  This
        buffer is actually a DEFAULT_DEVCMP_CONTEXT structure, defined as follows:

            typedef struct _DEFAULT_DEVCMP_CONTEXT {

                PCS_RESOURCE NewDevCsResource;
                PCS_RESOURCE CurDevCsResource;
                ULONG        CsResourceSize;

            } DEFAULT_DEVCMP_CONTEXT, *PDEFAULT_DEVCMP_CONTEXT;

        NewDevCsResource points to the class-specific resource buffer for the new device.
        CurDevCsResource points to a working buffer that should be used to retrieve the
            class-specific resource for the existing device.
        CsResourceSize supplies the size in bytes of these two buffers (they're both the
            same size).

Return Value:

    If the two devices are not duplicates of each other, the return value is NO_ERROR.
    If the two devices are duplicates of each other, the return value is ERROR_DUPLICATE_FOUND.

--*/
{
    LOG_CONF ExistingDeviceLogConfig;
    RES_DES ExistingDeviceResDes;
    CONFIGRET cr;
    PDEFAULT_DEVCMP_CONTEXT DevCmpContext;
    PCS_DES NewCsDes, ExistingCsDes;
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    HMACHINE hMachine;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    hMachine = pDeviceInfoSet->hMachine;

    UnlockDeviceInfoSet(pDeviceInfoSet);


    //
    // First, retrieve the boot LogConfig for the existing device.
    //
    if(CM_Get_First_Log_Conf_Ex(&ExistingDeviceLogConfig,
                             ExistingDeviceData->DevInst,
                             BOOT_LOG_CONF,
                             hMachine) != CR_SUCCESS) {
        //
        // Couldn't get the boot LogConfig--assume this device isn't a duplicate.
        //
        return NO_ERROR;
    }

    //
    // Assume there are no duplicates.
    //
    Err = NO_ERROR;

    //
    // Now, retrieve the the ResDes handle for the class-specific resource.
    //
    if(CM_Get_Next_Res_Des_Ex(&ExistingDeviceResDes,
                           ExistingDeviceLogConfig,
                           ResType_ClassSpecific,
                           NULL,
                           0,
                           hMachine) != CR_SUCCESS) {
        //
        // Couldn't get the class-specific ResDes handle--assume this device isn't a duplicate
        //
        goto clean0;
    }

    //
    // Now, retrieve the actual data associated with this ResDes.  Note that we don't care if
    // we get a CR_BUFFER_SMALL error, because we are guaranteed that we got back at least the
    // amount of data that we have for the new device.  That's all we need to do our comparison.
    //
    DevCmpContext = (PDEFAULT_DEVCMP_CONTEXT)CompareContext;

    cr = CM_Get_Res_Des_Data_Ex(ExistingDeviceResDes,
                             DevCmpContext->CurDevCsResource,
                             DevCmpContext->CsResourceSize,
                             0,
                             hMachine);

    if((cr == CR_SUCCESS) || (cr == CR_BUFFER_SMALL)) {
        //
        // We got _at least_ enough of the buffer to do the comparison.
        //
        NewCsDes = &(DevCmpContext->NewDevCsResource->CS_Header);
        ExistingCsDes = &(DevCmpContext->CurDevCsResource->CS_Header);

        //
        //  First, see if the Plug&Play detect signatures are both the same size.
        //
        if(NewCsDes->CSD_SignatureLength == ExistingCsDes->CSD_SignatureLength) {
            //
            // See if the class GUIDs are the same.
            //
            if(IsEqualGUID(&(NewCsDes->CSD_ClassGuid), &(ExistingCsDes->CSD_ClassGuid))) {
                //
                // Finally, see if the PnP detect signatures are identical
                //
                if(!memcmp(NewCsDes->CSD_Signature,
                           ExistingCsDes->CSD_Signature,
                           NewCsDes->CSD_SignatureLength)) {
                    //
                    // We have ourselves a duplicate!
                    //
                    Err = ERROR_DUPLICATE_FOUND;
                }
            }
        }
    }

    CM_Free_Res_Des_Handle(ExistingDeviceResDes);

clean0:
    CM_Free_Log_Conf_Handle(ExistingDeviceLogConfig);

    return Err;
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDeviceInstanceIdA(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PSTR             DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    )
{
    WCHAR deviceInstanceId[MAX_DEVICE_ID_LEN];
    PSTR deviceInstanceIdA;
    DWORD AnsiLength;
    BOOL b;
    DWORD rc;
    DWORD requiredSize;

    b = SetupDiGetDeviceInstanceIdW(
            DeviceInfoSet,
            DeviceInfoData,
            deviceInstanceId,
            MAX_DEVICE_ID_LEN,
            &requiredSize
            );

    if(!b) {
        return(FALSE);
    }

    rc = GetLastError();

    if(deviceInstanceIdA = pSetupUnicodeToAnsi(deviceInstanceId)) {

        AnsiLength = lstrlenA(deviceInstanceIdA) + 1;

        if(RequiredSize) {
            try {
                *RequiredSize = AnsiLength;
            } except(EXCEPTION_EXECUTE_HANDLER) {
                rc = ERROR_INVALID_PARAMETER;
                b = FALSE;
            }
        }

        if(DeviceInstanceIdSize >= AnsiLength) {

            if (FAILED(StringCchCopyA(DeviceInstanceId, DeviceInstanceIdSize, deviceInstanceIdA))) {
                //
                // caller's buffer invalid
                //
                rc = ERROR_INVALID_USER_BUFFER;
                b = FALSE;
            }
        } else {
            rc = ERROR_INSUFFICIENT_BUFFER;
            b = FALSE;
        }

        MyFree(deviceInstanceIdA);

    } else {
        rc = ERROR_NOT_ENOUGH_MEMORY;
        b = FALSE;
    }

    SetLastError(rc);
    return(b);
}

BOOL
WINAPI
SetupDiGetDeviceInstanceId(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PTSTR            DeviceInstanceId,
    IN  DWORD            DeviceInstanceIdSize,
    OUT PDWORD           RequiredSize          OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the device instance ID associated with a device
    information element.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device information element whose ID is to be retrieved.

    DeviceInfoData - Supplies a pointer to the SP_DEVINFO_DATA structure for
        the device information element whose ID is to be retrieved.

    DeviceInstanceId - Supplies the address of a character buffer that will
        receive the ID for the specified device information element.

    DeviceInstanceIdSize - Supplies the size, in characters, of the DeviceInstanceId
        buffer.

    RequiredSize - Optionally, supplies the address of a variable that receives the
        number of characters required to store the device instance ID.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    CONFIGRET cr;
    ULONG ulLen;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }


    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the element whose ID we are to retrieve.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Find out how large the buffer needs to be.  We always have to
        // make this call first, because CM_Get_Device_ID_Ex doesn't return
        // a CR_BUFFER_SMALL error if there isn't room for the terminating
        // NULL.
        //
        if((cr = CM_Get_Device_ID_Size_Ex(&ulLen,
                                       DevInfoElem->DevInst,
                                       0,
                                       pDeviceInfoSet->hMachine)) == CR_SUCCESS) {
            //
            // The size returned from CM_Get_Device_ID_Size doesn't include
            // the terminating NULL.
            //
            ulLen++;

        } else {

            Err = (cr == CR_INVALID_DEVINST) ? ERROR_NO_SUCH_DEVINST
                                             : ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        if(RequiredSize) {
            *RequiredSize = ulLen;
        }

        if(DeviceInstanceIdSize < ulLen) {
            Err = ERROR_INSUFFICIENT_BUFFER;
            goto clean0;
        }

        //
        // Now retrieve the ID.
        //
        if((cr = CM_Get_Device_ID_Ex(DevInfoElem->DevInst,
                                  DeviceInstanceId,
                                  DeviceInstanceIdSize,
                                  0,
                                  pDeviceInfoSet->hMachine)) != CR_SUCCESS) {
            switch(cr) {

                case CR_INVALID_POINTER :
                    Err = ERROR_INVALID_USER_BUFFER;
                    break;

                default :
                    //
                    // Should never hit this!
                    //
                    Err = ERROR_INVALID_DATA;
            }
        }

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


DWORD
pSetupAddDeviceInterfaceToDevInfoElem(
    IN  PDEVICE_INFO_SET        DeviceInfoSet,
    IN  PDEVINFO_ELEM           DevInfoElem,
    IN  CONST GUID             *InterfaceClassGuid,
    IN  PTSTR                   DeviceInterfaceName,
    IN  BOOL                    IsActive,
    IN  BOOL                    IsDefault,
    IN  BOOL                    StoreTruncateNode,
    IN  BOOL                    OpenExistingOnly,
    OUT PDEVICE_INTERFACE_NODE *DeviceInterfaceNode  OPTIONAL
    )
/*++

Routine Description:

    This routine adds the specified device interface onto a device information
    element's list of device interfaces.

Arguments:

    DeviceInfoSet - Supplies a pointer to the device information set
        containing the specified element.

    DevInfoElem - Supplies a pointer to the DEVINFO_ELEM structure whose
        device interface list is being added to.

    InterfaceClassGuid - Supplies a pointer to a GUID representing the class
        that this device interface is a member of.

    DeviceInterfaceName - Supplies the symbolic link name of the device interface
        being added.

    IsActive - Specifies whether or not the device interface is presently active.

    IsDefault - Specifies whether or not the device interface is presently the
        default device interface for this device interface class.

    StoreTruncateNode - If non-zero, then store the address of this device
        interface node (if newly-added) when this is the first such node added
        to the device information elements device interface node list (i.e.,
        the interface class list's DeviceInterfaceTruncateNode field is NULL).

    OpenExistingOnly - If non-zero, then only succeed if the requested device
        interface is already in the device information set.

    DeviceInterfaceNode - Optionally, supplies the address of a device interface
        node pointer to be filled in with the node created for this device interface.

Return Value:

    If success, the return value is NO_ERROR.
    If failure, the return value is ERROR_NOT_ENOUGH_MEMORY.

--*/
{
    LONG GuidIndex;
    PINTERFACE_CLASS_LIST InterfaceClassList;
    PDEVICE_INTERFACE_NODE NewDeviceInterfaceNode, CurDeviceInterface, PrevDeviceInterface;
    LONG SymLinkNameId;

    //
    // First, get a reference (i.e., pointer) to this interface class guid (create one
    // if it's not already present for this set).
    //
    GuidIndex = AddOrGetGuidTableIndex(DeviceInfoSet, InterfaceClassGuid, TRUE);

    if(GuidIndex == -1) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now, get the interface class list for this class from the relevant
    // devinfo element (again, we will create a new (empty) list if it doesn't
    // already exist).
    //
    if(!(InterfaceClassList = AddOrGetInterfaceClassList(DeviceInfoSet,
                                                         DevInfoElem,
                                                         GuidIndex,
                                                         TRUE))) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Now we will add a new device interface node to this list (making sure
    // that the node isn't already there).
    //
    SymLinkNameId = pStringTableAddString(DeviceInfoSet->StringTable,
                                          DeviceInterfaceName,
                                          STRTAB_CASE_INSENSITIVE | STRTAB_BUFFER_WRITEABLE,
                                          NULL,
                                          0
                                         );

    if(SymLinkNameId == -1) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for(CurDeviceInterface = InterfaceClassList->DeviceInterfaceNode, PrevDeviceInterface = NULL;
        CurDeviceInterface;
        PrevDeviceInterface = CurDeviceInterface, CurDeviceInterface = CurDeviceInterface->Next) {

        if(CurDeviceInterface->SymLinkName == SymLinkNameId) {
            //
            // The node is already in our list, we don't want to add it again.
            // Update the flags for this device interface to reflect whether
            // the device is presently active, and whether it is the default
            // interface for this class.
            //
            CurDeviceInterface->Flags = (CurDeviceInterface->Flags & ~SPINT_ACTIVE) | (IsActive ? SPINT_ACTIVE : 0);
            CurDeviceInterface->Flags = (CurDeviceInterface->Flags & ~SPINT_DEFAULT) | (IsDefault ? SPINT_DEFAULT : 0);

            //
            // Return this node to the caller.
            //
            if(DeviceInterfaceNode) {
                *DeviceInterfaceNode = CurDeviceInterface;
            }
            return NO_ERROR;
        }
    }

    //
    // The device interface node wasn't already in our list--add it (unless
    // we've been told not to)
    //
    if(OpenExistingOnly) {
        return ERROR_NO_SUCH_DEVICE_INTERFACE;
    }

    if(!(NewDeviceInterfaceNode = MyMalloc(sizeof(DEVICE_INTERFACE_NODE)))) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory(NewDeviceInterfaceNode, sizeof(DEVICE_INTERFACE_NODE));

    NewDeviceInterfaceNode->SymLinkName = SymLinkNameId;

    if(PrevDeviceInterface) {
        PrevDeviceInterface->Next = NewDeviceInterfaceNode;
    } else {
        InterfaceClassList->DeviceInterfaceNode = NewDeviceInterfaceNode;
    }
    InterfaceClassList->DeviceInterfaceCount++;

    //
    // If this is the first device interface node added to this list, then
    // remember it so we can truncate the list at this point if we later find
    // that we need to rollback (because we encountered some error).
    //
    if(StoreTruncateNode && !InterfaceClassList->DeviceInterfaceTruncateNode) {
        InterfaceClassList->DeviceInterfaceTruncateNode = NewDeviceInterfaceNode;
    }

    //
    // Store the interface class GUID index in the node, so that we can easily
    // determine the class of the node later.
    //
    NewDeviceInterfaceNode->GuidIndex = GuidIndex;

    //
    // Setup the flags for this device interface (these are the same flags that
    // the caller sees in the SP_DEVICE_INTERFACE_DATA structure).
    //
    NewDeviceInterfaceNode->Flags = IsActive ? SPINT_ACTIVE : 0;
    NewDeviceInterfaceNode->Flags |= IsDefault ? SPINT_DEFAULT : 0;

    //
    // Store a back-pointer in the device interface node, so that we can get
    // back to the devinfo element that owns it (there are circumstances when
    // we will be given a device interface data buffer outside of the context
    // of any devinfo element).
    //
    NewDeviceInterfaceNode->OwningDevInfoElem = DevInfoElem;

    if(DeviceInterfaceNode) {
        *DeviceInterfaceNode = NewDeviceInterfaceNode;
    }

    return NO_ERROR;
}


BOOL
WINAPI
SetupDiEnumDeviceInterfaces(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,     OPTIONAL
    IN  CONST GUID                *InterfaceClassGuid,
    IN  DWORD                      MemberIndex,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData
    )
/*++

Routine Description:

    This API enumerates device interfaces of the specified class that are
    contained in the devinfo set (optionally, filtered based on DeviceInfoData).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        device interfaces to be enumerated.

    DeviceInfoData - Optionally, supplies a pointer to a device information
        element for whom device interfaces are to be enumerated.

    InterfaceClassGuid - Supplies a pointer to the interface class GUID whose
        members are to be enumerated.

    MemberIndex - Supplies the zero-based index of the device interface to be
        retrieved.  If DeviceInfoData is specified, then this is relative to
        all device interfaces of the specified class owned by that device
        information element.  If DeviceInfoData is not specified, then this
        index is relative to all device interfaces contained in the device
        information set.

    DeviceInterfaceData - Supplies a pointer to a device interface data buffer
        that receives information about the specified device interface.  The
        cbSize field of this structure must be filled in with
        sizeof(SP_DEVICE_INTERFACE_DATA), or the buffer is considered invalid.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    To enumerate device interface members, an application should initially call
    the SetupDiEnumDeviceInterfaces function with the MemberIndex parameter set
    to zero.  The application should then increment MemberIndex and call the
    SetupDiEnumDeviceInterfaces function until there are no more values (i.e.,
    the function fails, and GetLastError returns ERROR_NO_MORE_ITEMS).

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, i;
    PDEVINFO_ELEM DevInfoElem;
    LONG InterfaceClassGuidIndex;
    PINTERFACE_CLASS_LIST InterfaceClassList;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Retrieve the index of this interface class GUID.
        //
        if((InterfaceClassGuidIndex = AddOrGetGuidTableIndex(pDeviceInfoSet,
                                                             InterfaceClassGuid,
                                                             FALSE)) == -1) {
            Err = ERROR_NO_MORE_ITEMS;
            goto clean0;
        }

        //
        // Find the requested device interface.
        //
        if(DeviceInfoData) {
            //
            // Then we're enumerating only those device interfaces that are owned
            // by a particular devinfo element.
            //
            if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                         DeviceInfoData,
                                                         NULL))) {
                Err = ERROR_INVALID_PARAMETER;
                goto clean0;
            }

            if(!(InterfaceClassList = AddOrGetInterfaceClassList(pDeviceInfoSet,
                                                                 DevInfoElem,
                                                                 InterfaceClassGuidIndex,
                                                                 FALSE))
               || (MemberIndex >= InterfaceClassList->DeviceInterfaceCount))
            {
                Err = ERROR_NO_MORE_ITEMS;
                goto clean0;
            }

        } else {
            //
            // We're enumerating across all devinfo elements. Find the appropriate devinfo
            // element, and adjust the member index accordingly.
            //
            for(DevInfoElem = pDeviceInfoSet->DeviceInfoHead;
                DevInfoElem;
                DevInfoElem = DevInfoElem->Next) {

                if(InterfaceClassList = AddOrGetInterfaceClassList(pDeviceInfoSet,
                                                                   DevInfoElem,
                                                                   InterfaceClassGuidIndex,
                                                                   FALSE)) {

                    if(MemberIndex < InterfaceClassList->DeviceInterfaceCount) {
                        //
                        // We've found the devinfo element containing the device
                        // interface we're looking for.
                        //
                        break;

                    } else {
                        //
                        // The device interface we're looking for isn't associated with
                        // this devinfo element.  Adjust our index to eliminate the
                        // device interfaces for this element, and continue searching.
                        //
                        MemberIndex -= InterfaceClassList->DeviceInterfaceCount;
                    }
                }
            }

            if(!DevInfoElem) {
                //
                // Then the specified index was higher than the count of device
                // interfaces in this devinfo set.
                //
                Err = ERROR_NO_MORE_ITEMS;
                goto clean0;
            }
        }

        //
        // If we reach this point, we've found the devinfo element that contains the requested
        // device interface, and we have a pointer to the relevant interface class list.  Now
        // all we need to do is retrieve the correct member of this list, and fill in the caller's
        // device interface data buffer with the appropriate information.
        //
        DeviceInterfaceNode = InterfaceClassList->DeviceInterfaceNode;

        for(i = 0; i < MemberIndex; i++) {
            DeviceInterfaceNode = DeviceInterfaceNode->Next;
        }

        if(!DeviceInterfaceDataFromNode(DeviceInterfaceNode, InterfaceClassGuid, DeviceInterfaceData)) {
            Err = ERROR_INVALID_USER_BUFFER;
        }

clean0:
        ; // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiGetDeviceInterfaceDetailA(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA_A DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    )
{
    //
    // Since the maximum length for both the symbolic link and refstring components
    // of the device interface name is 255 characters (excluding NULL), the maximum
    // length of the entire device interface name is 512 characters
    // (255 + 255 + 1 backslash + 1 NULL character).
    //
    // Thus, we will retrieve the unicode form of this information using a maximally-
    // sized buffer, then convert it to ANSI, and store it in the caller's buffer, if
    // the caller's buffer is large enough.
    //
    BYTE UnicodeBuffer[offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA_W, DevicePath) + (512 * sizeof(WCHAR))];
    PCHAR AnsiBuffer = NULL;
    PSP_DEVICE_INTERFACE_DETAIL_DATA_W UnicodeDetailData;
    DWORD rc, UnicodeRequiredSize, ReturnBufferRequiredSize;
    int AnsiStringSize;

    //
    // Check parameters.
    //
    rc = NO_ERROR;
    try {
        if(DeviceInterfaceDetailData) {
            //
            // Check signature and make sure buffer is large enough
            // to hold fixed part and at least a valid empty string.
            //
            if((DeviceInterfaceDetailData->cbSize != sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_A))
            || (DeviceInterfaceDetailDataSize < (offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA_A,DevicePath)+sizeof(CHAR)))) {

                rc = ERROR_INVALID_USER_BUFFER;
            }
        } else {
            //
            // Doesn't want data, size has to be 0.
            //
            if(DeviceInterfaceDetailDataSize) {
                rc = ERROR_INVALID_USER_BUFFER;
            }
        }
    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_USER_BUFFER;
    }

    if(rc != NO_ERROR) {
        SetLastError(rc);
        return FALSE;
    }

    UnicodeDetailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA_W)UnicodeBuffer;
    UnicodeDetailData->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA_W);

    if(!SetupDiGetDeviceInterfaceDetailW(DeviceInfoSet,
                                         DeviceInterfaceData,
                                         UnicodeDetailData,
                                         sizeof(UnicodeBuffer),
                                         &UnicodeRequiredSize,
                                         DeviceInfoData)) {
        return FALSE;
    }

    //
    // We successfully retrieved the (unicode) device interface details.  Now convert it
    // to ANSI, and store it in the caller's buffer.
    //
    UnicodeRequiredSize -= offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA_W, DevicePath);
    UnicodeRequiredSize /= sizeof(WCHAR);

    try {

        AnsiBuffer = pSetupUnicodeToAnsi(UnicodeDetailData->DevicePath);
        if(!AnsiBuffer) {
            rc = ERROR_NOT_ENOUGH_MEMORY;
            goto clean0;
        }
        AnsiStringSize = lstrlenA(AnsiBuffer)+1;

        ReturnBufferRequiredSize = AnsiStringSize + offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA_A, DevicePath);

        if(RequiredSize) {
            *RequiredSize = ReturnBufferRequiredSize;
        }

        if(ReturnBufferRequiredSize > DeviceInterfaceDetailDataSize) {
            rc = ERROR_INSUFFICIENT_BUFFER;
            goto clean0;
        }

        //
        // OK, so we've determined that the caller's buffer is big enough.  Now, copy the
        // ANSI data into their buffer.
        //
        CopyMemory(DeviceInterfaceDetailData->DevicePath,
                   AnsiBuffer,
                   AnsiStringSize
                  );

clean0:
        ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        rc = ERROR_INVALID_USER_BUFFER;
    }

    if(AnsiBuffer) {
        MyFree(AnsiBuffer);
    }

    SetLastError(rc);
    return (rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiGetDeviceInterfaceDetail(
    IN  HDEVINFO                           DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA          DeviceInterfaceData,
    OUT PSP_DEVICE_INTERFACE_DETAIL_DATA   DeviceInterfaceDetailData,     OPTIONAL
    IN  DWORD                              DeviceInterfaceDetailDataSize,
    OUT PDWORD                             RequiredSize,                  OPTIONAL
    OUT PSP_DEVINFO_DATA                   DeviceInfoData                 OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves details about a particular device interface (i.e., what
    it's "name" is that you can do a CreateFile on).

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing
        a device interface to retrieve details about.

    DeviceInterfaceData - Supplies a device interface information structure
        for which details are to be retrieved.

    DeviceInterfaceDetailData - Optionally, supplies the address of a device
        interface detail data structure that will receive additional information
        about the specified device interface.  If this parameter is not specified,
        then DeviceInterfaceDetailDataSize must be zero (this would be done if the
        caller was only interested in finding out how large of a buffer is required).
        If this parameter is specified, the cbSize field of this structure must
        be set to the size of the structure before calling this API. NOTE:
        The 'size of the structure' on input means sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA).
        Note that this is essentially just a signature and is entirely separate
        from DeviceInterfaceDetailDataSize.  See below.

    DeviceInterfaceDetailDataSize - Supplies the size, in bytes, of the
        DeviceInterfaceDetailData buffer. To be valid this buffer must be at least
        offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA, DevicePath) + sizeof(TCHAR) bytes,
        which allows storage of the fixed part of the structure and a single nul to
        terminate an empty multi_sz. (Depending on structure alignment,
        character width, and the data to be returned, this may actually be
        smaller than sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA).

    RequiredSize - Optionally, supplies the address of a variable that receives
        the number of bytes required to store the detailed device interface
        information.  This value includes both the size of the structure itself,
        and the additional number of bytes required for the variable-length
        character buffer at the end of it that holds the device path.

    DeviceInfoData - Optionally, supplies a pointer to a SP_DEVINFO_DATA structure
        that will receive information about the device information element that
        owns this device interface.  Callers that only want to retrieve this parameter
        may pass NULL for DeviceInterfaceDetailData, and pass 0 for
        DeviceInterfaceDetailDataSize.  Assuming the specified device interface is
        valid, the API will fail, with GetLastError returning ERROR_INSUFFICIENT_BUFFER.
        However, DeviceInfoData will have been correctly filled in with the
        associated device information element.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;
    PCTSTR DevicePath;
    DWORD DevicePathLength, BufferLengthNeeded;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // First, find the devinfo element that owns this device interface.  This
        // is used as a form of validation, and also may be needed later on, if the
        // user supplied us with a DeviceInfoData buffer to be filled in.
        //
        if(!(DevInfoElem = FindDevInfoElemForDeviceInterface(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // The Reserved field contains a pointer to the underlying device interface node.
        //
        DeviceInterfaceNode = (PDEVICE_INTERFACE_NODE)(DeviceInterfaceData->Reserved);

        DevicePath = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                              DeviceInterfaceNode->SymLinkName
                                             );

        DevicePathLength = (lstrlen(DevicePath) + 1) * sizeof(TCHAR);

        //
        // Before attempting to store the device path in the caller's buffer, check to see
        // whether they requested that the associated devinfo element be returned.  If so,
        // do that first.
        //
        if(DeviceInfoData) {

            if(!(DevInfoDataFromDeviceInfoElement(pDeviceInfoSet,
                                                  DevInfoElem,
                                                  DeviceInfoData))) {
                Err = ERROR_INVALID_USER_BUFFER;
                goto clean0;
            }
        }

        //
        // Validate the caller's buffer.
        //
        if(DeviceInterfaceDetailData) {

            if((DeviceInterfaceDetailDataSize <
                (offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA, DevicePath) + sizeof(TCHAR))) ||
               (DeviceInterfaceDetailData->cbSize != sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA))) {

                Err = ERROR_INVALID_USER_BUFFER;
                goto clean0;
            }

        } else if(DeviceInterfaceDetailDataSize) {
            Err = ERROR_INVALID_USER_BUFFER;
            goto clean0;
        }

        //
        // Compute the buffer size required.
        //
        BufferLengthNeeded = offsetof(SP_DEVICE_INTERFACE_DETAIL_DATA, DevicePath) + DevicePathLength;

        if(RequiredSize) {
            *RequiredSize = BufferLengthNeeded;
        }

        if(BufferLengthNeeded > DeviceInterfaceDetailDataSize) {
            Err = ERROR_INSUFFICIENT_BUFFER;
            goto clean0;
        }

        CopyMemory(DeviceInterfaceDetailData->DevicePath, DevicePath, DevicePathLength);

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiOpenDeviceInterfaceA(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCSTR                     DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    )
{
    PCWSTR UnicodeDevicePath;
    DWORD rc;

    rc = pSetupCaptureAndConvertAnsiArg(DevicePath, &UnicodeDevicePath);
    if(rc == NO_ERROR) {

        rc = _SetupDiOpenDeviceInterface(DeviceInfoSet,
                                         (PWSTR)UnicodeDevicePath,
                                         OpenFlags,
                                         DeviceInterfaceData
                                        );

        MyFree(UnicodeDevicePath);

    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}

BOOL
WINAPI
SetupDiOpenDeviceInterface(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PCTSTR                    DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    )
/*++

Routine Description:

    This routine opens up the device information element that exposes the
    specified device interface (if it's not already in the device information
    set), and then adds this device interface to the set.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set into which this
        new device interface element is to be opened.

        NOTE:  The class of the underlying device instance must match the class
        of the set (or the set should have no associated class).  If this is not
        the case, the call will fail, and GetLastError will return ERROR_CLASS_MISMATCH.

    DevicePath - Supplies the name of the device interface to be opened.  This name
        is a Win32 device path of the form "\\?\<DeviceInterfaceName>[\<RefString>]",
        and is returned via a previous enumeration of device interface (i.e., via
        SetupDiGetClassDevs(...DIGCF_DEVICEINTERFACE) or by notification via
        RegisterDeviceNotification).

    OpenFlags - Supplies flags controlling how the device interface element is
        to be opened.  May be a combination of the following values:

        DIODI_NO_ADD - Only succeed the call (and optionally return the device
                       interface data) if the device interface already exists
                       in the device information set.  This flag may be used to
                       get a device interface data context buffer back given a
                       device interface name, without causing that interface to
                       be opened if it's not already in the set.

                       This is useful, for example, when an app receives a
                       device interface removal notification.  Such an app will
                       want to remove the corresponding device interface data
                       from the device information they're using as a container,
                       but they wouldn't want to open up a device interface
                       element not already in the set just so they can close it.

    DeviceInterfaceData - Optionally, supplies a pointer to a device interface data
        buffer that receives information about the specified device interface.  The
        cbSize field of this structure must be filled in with sizeof(SP_DEVICE_INTERFACE_DATA)
        or the buffer is considered invalid.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If the new device interface was successfully opened, but the user-supplied
    DeviceInterfaceData buffer is invalid, this API will return FALSE, with
    GetLastError returning ERROR_INVALID_USER_BUFFER.  The device interface
    element _will_ have been added as a new member of the set, however.

    If the device interface already exists in the set, the flags will be updated
    to reflect the current state of the device.  Thus, for example, if a device
    was not active when originally opened into the set, but has since become
    active, this API may be used to 'refresh' the flags on that device interface
    element, so that the SPINT_ACTIVE bit is once again in sync with reality.

    Note that since new device information elements are always added at the end
    of the existing list, the enumeration ordering is preserved, thus we don't
    need to invalidate our enumeration hint.

--*/
{
    PCTSTR WritableDevicePath;
    DWORD rc;

    rc = CaptureStringArg(DevicePath, &WritableDevicePath);
    if(rc == NO_ERROR) {

        rc = _SetupDiOpenDeviceInterface(DeviceInfoSet,
                                         (PTSTR)WritableDevicePath,
                                         OpenFlags,
                                         DeviceInterfaceData
                                        );

        MyFree(WritableDevicePath);
    }

    SetLastError(rc);
    return(rc == NO_ERROR);
}


DWORD
_SetupDiOpenDeviceInterface(
    IN  HDEVINFO                  DeviceInfoSet,
    IN  PTSTR                     DevicePath,
    IN  DWORD                     OpenFlags,
    OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData OPTIONAL
    )
/*++

Routine Description:

    Worker routine for SetupDiOpenDeviceInterface(A|W).  This is a separate routine
    so that both A and W versions can capture their DevicePath argument into a
    writable buffer, because we need this for adding the case-insensitive form to
    the string table.

Arguments:

    See SetupDiOpenDeviceInterface for details.

Return Value:

    If the function succeeds, the return value is NO_ERROR.  Otherwise, it is a
    Win32 error code.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, DevicePathLen;
    PCTSTR p;
    TCHAR InterfaceGuidString[GUID_STRING_LEN];
    GUID InterfaceGuid;
    HKEY hKey;
    TCHAR DeviceInstanceId[MAX_DEVICE_ID_LEN];
    PCTSTR MachineName;
    BOOL DevInfoAlreadyPresent, IsActive, IsDefault;
    PDEVINFO_ELEM DevInfoElem;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode = NULL;

    if(OpenFlags & ~DIODI_NO_ADD) {
        return ERROR_INVALID_FLAGS;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        return ERROR_INVALID_HANDLE;
    }

    Err = NO_ERROR;
    hKey = INVALID_HANDLE_VALUE;
    DevInfoElem = NULL;

    try {
        //
        // Retrieve the interface class of this device.  Since the device path is of
        // the form "\\?\MungedDevInstName#{InterfaceClassGuid}[\RefString]", we can
        // retrieve the GUID from the name.
        //
        // NOTE: The algorithm about how this name is generated must be kept in sync
        // with the kernel-mode implementation of IoRegisterDeviceClassAssocation, et. al.
        //
        DevicePathLen = lstrlen(DevicePath);

        //
        // Move past "\\?\" prefix (also allow "\\.\" until Memphis fixes their code)
        //
        if((DevicePathLen < 4) ||
           (DevicePath[0] != TEXT('\\')) ||
           (DevicePath[1] != TEXT('\\')) ||
           ((DevicePath[2] != TEXT('?')) && (DevicePath[2] != TEXT('.'))) ||
           (DevicePath[3] != TEXT('\\')))
        {
            Err = ERROR_BAD_PATHNAME;
            goto clean0;
        }

        p = _tcschr(&(DevicePath[4]), TEXT('\\'));

        if(!p) {
            //
            // This name has no refstring--set the pointer to the end of the string
            //
            p = DevicePath + DevicePathLen;
        }

        //
        // Make sure there are enough characters preceding the current position for a
        // GUID to fit.
        //
        if(p < (DevicePath + 3 + GUID_STRING_LEN)) {
            Err = ERROR_BAD_PATHNAME;
            goto clean0;
        }

        MYVERIFY(SUCCEEDED(StringCchCopyN(InterfaceGuidString,
                                          SIZECHARS(InterfaceGuidString),
                                          p - (GUID_STRING_LEN - 1),
                                          GUID_STRING_LEN - 1)));

        if(pSetupGuidFromString(InterfaceGuidString, &InterfaceGuid) != NO_ERROR) {
            Err = ERROR_BAD_PATHNAME;
            goto clean0;
        }

        //
        // Retrieve the name of the machine associated with this DeviceInfoSet.
        //
        if(pDeviceInfoSet->hMachine) {
            MYASSERT(pDeviceInfoSet->MachineName != -1);
            MachineName = pStringTableStringFromId(pDeviceInfoSet->StringTable, pDeviceInfoSet->MachineName);
        } else {
            MachineName = NULL;
        }

        //
        // OK, now we know that we retrieved a valid GUID from an (apparently) valid device path.
        // Go open up this device interface key under the DeviceClasses registry branch.
        //
        hKey = SetupDiOpenClassRegKeyEx(&InterfaceGuid,
                                        KEY_READ,
                                        DIOCR_INTERFACE,
                                        MachineName,
                                        NULL
                                       );

        if(hKey == INVALID_HANDLE_VALUE) {
            Err = GetLastError();
            goto clean0;
        }

        if(NO_ERROR != (Err = pSetupGetDevInstNameAndStatusForDeviceInterface(
                                  hKey,
                                  DevicePath,
                                  DeviceInstanceId,
                                  SIZECHARS(DeviceInstanceId),
                                  &IsActive,
                                  &IsDefault)))
        {
            goto clean0;
        }

        if(NO_ERROR != (Err = pSetupOpenAndAddNewDevInfoElem(pDeviceInfoSet,
                                                             DeviceInstanceId,
                                                             TRUE,
                                                             NULL,
                                                             NULL,
                                                             &DevInfoElem,
                                                             TRUE,
                                                             &DevInfoAlreadyPresent,
                                                             (OpenFlags & DIODI_NO_ADD),
                                                             0,
                                                             pDeviceInfoSet)))
        {
            //
            // Make sure DevInfoElem is still NULL, so we won't try to delete it.
            //
            DevInfoElem = NULL;

            goto clean0;
        }

        //
        // Now that we've successfully opened up the device instance that 'owns'
        // this device interface, add a new device interface node onto this
        // devinfo element's list.
        //
        if((NO_ERROR == (Err = pSetupAddDeviceInterfaceToDevInfoElem(pDeviceInfoSet,
                                                                     DevInfoElem,
                                                                     &InterfaceGuid,
                                                                     DevicePath,
                                                                     IsActive,
                                                                     IsDefault,
                                                                     FALSE,
                                                                     (OpenFlags & DIODI_NO_ADD),
                                                                     &DeviceInterfaceNode)))
           || DevInfoAlreadyPresent)
        {
            //
            // Either we successfully added the device interface or the owning devinfo element
            // was already in the set.  In either case, we want to reset the DevInfoElem pointer
            // to NULL so we won't try to delete it from the set.
            //
            DevInfoElem = NULL;
        }

clean0: ; // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variables so the compiler will respect statement ordering
        // w.r.t. assignment.
        //
        DevInfoElem = DevInfoElem;
        hKey = hKey;
    }

    if(hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    if(Err != NO_ERROR) {

        if(DevInfoElem) {

            SP_DEVINFO_DATA DeviceInfoData;

            DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
            DevInfoDataFromDeviceInfoElement(pDeviceInfoSet, DevInfoElem, &DeviceInfoData);
            SetupDiDeleteDeviceInfo(DeviceInfoSet, &DeviceInfoData);
        }

    } else if(DeviceInterfaceData) {

        try {

            if(!DeviceInterfaceDataFromNode(DeviceInterfaceNode, &InterfaceGuid, DeviceInterfaceData)) {
                Err = ERROR_INVALID_USER_BUFFER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_USER_BUFFER;
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    return Err;
}


BOOL
WINAPI
SetupDiGetDeviceInterfaceAlias(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData,
    IN  CONST GUID                *AliasInterfaceClassGuid,
    OUT PSP_DEVICE_INTERFACE_DATA  AliasDeviceInterfaceData
    )
/*++

Routine Description:

    This routine retrieves the device interface of a particular class that 'aliases'
    the specified device interface.  Two device interfaces are considered aliases of
    each other if the following to criteria are met:

        1.  Both device interfaces are exposed by the same device instance.
        2.  Both device interfaces share the same RefString.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing the
        device interface for which an alias is to be retrieved.

    DeviceInterfaceData - Specifies the device interface whose alias is to be
        retrieved.

    AliasInterfaceClassGuid - Supplies a pointer to the GUID representing the interface
        class for which the alias is to be retrieved.

    AliasDeviceInterfaceData - Supplies a pointer to a device interface data buffer
        that receives information about the alias device interface.  The cbSize field
        of this structure must be filled in with sizeof(SP_DEVICE_INTERFACE_DATA) or
        the buffer is considered invalid.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

    Remarks:

    If the alias device interface was successfully opened, but the user-supplied
    AliasDeviceInterfaceData buffer is invalid, this API will return FALSE, with
    GetLastError returning ERROR_INVALID_USER_BUFFER.  The alias device interface
    element _will_ have been added as a new member of the set, however.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem, DevInfoElem2;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;
    PCTSTR DevicePath;
    PTSTR AliasPath;
    ULONG AliasPathLength;
    CONFIGRET cr;
    SP_DEVICE_INTERFACE_DATA TempInterfaceDevData;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;
    AliasPath = NULL;

    try {
        //
        // First, find the devinfo element that owns this device interface (for validation).
        //
        if(!(DevInfoElem = FindDevInfoElemForDeviceInterface(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // The Reserved field contains a pointer to the underlying device interface node.
        //
        DeviceInterfaceNode = (PDEVICE_INTERFACE_NODE)(DeviceInterfaceData->Reserved);

        //
        // Get the device path for this device interface.
        //
        DevicePath = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                              DeviceInterfaceNode->SymLinkName
                                             );

        //
        // Choose a buffer size that should always be large enough (we know this is the
        // case today, but since there is no defined maximum length on this path, we leave
        // the capability for it to grow in the future).
        //
        AliasPathLength = 512;

        while(TRUE) {

            if(!(AliasPath = MyMalloc(AliasPathLength * sizeof(TCHAR)))) {
                Err = ERROR_NOT_ENOUGH_MEMORY;
                goto clean0;
            }

            //
            // Now retrieve the name of this device interface's alias in the specified class.
            //
            cr = CM_Get_Device_Interface_Alias_Ex(DevicePath,
                                               (LPGUID)AliasInterfaceClassGuid,
                                               AliasPath,
                                               &AliasPathLength,
                                               0,
                                               pDeviceInfoSet->hMachine);

            if(cr == CR_SUCCESS) {
                break;
            } else {
                //
                // If our buffer was too small, then free it, and try again with a larger buffer.
                //
                if(cr == CR_BUFFER_SMALL) {
                    MyFree(AliasPath);
                    AliasPath = NULL;
                } else {
                    Err = MapCrToSpError(cr, ERROR_NO_SUCH_DEVICE_INTERFACE);
                    goto clean0;
                }
            }
        }

        //
        // If we get to here then we've successfully retrieved the alias name.  Now open this
        // device interface in our device information set.
        //
        TempInterfaceDevData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
        if(!SetupDiOpenDeviceInterface(DeviceInfoSet,
                                       AliasPath,
                                       0,
                                       &TempInterfaceDevData)) {
            //
            // This should never happen.
            //
            Err = GetLastError();
            goto clean0;
        }

        //
        // Retrieve the device information element for this alias device interface (this has to succeed).
        //
        DevInfoElem2 = FindDevInfoElemForDeviceInterface(pDeviceInfoSet, DeviceInterfaceData);

        //
        // Since these two device interfaces are aliases of each other, they'd better be owned by
        // the same devinfo element!
        //
        MYASSERT(DevInfoElem == DevInfoElem2);

        DeviceInterfaceNode = (PDEVICE_INTERFACE_NODE)(TempInterfaceDevData.Reserved);

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variable so the compiler will respect our statement ordering
        // w.r.t. assignment.
        //
        AliasPath = AliasPath;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    if(AliasPath) {
        MyFree(AliasPath);
    }

    if(Err == NO_ERROR) {

        try {

            if(!DeviceInterfaceDataFromNode(DeviceInterfaceNode,
                                            AliasInterfaceClassGuid,
                                            AliasDeviceInterfaceData)) {

                Err = ERROR_INVALID_USER_BUFFER;
            }

        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_USER_BUFFER;
        }
    }

    SetLastError(Err);
    return(Err == NO_ERROR);

}


DWORD
pSetupGetDevInstNameAndStatusForDeviceInterface(
    IN  HKEY   hKeyInterfaceClass,
    IN  PCTSTR DeviceInterfaceName,
    OUT PTSTR  OwningDevInstName,     OPTIONAL
    IN  DWORD  OwningDevInstNameSize,
    OUT PBOOL  IsActive,              OPTIONAL
    OUT PBOOL  IsDefault              OPTIONAL
    )
/*++

Routine Description:

    This routine retrieves the name of the device instance that exposes the specified
    device interface and whether or not that device interface is currently active,
    or is the default interface for the interface class to which it belongs.

Arguments:

    hKeyInterfaceClass - Supplies a handle to the registry key for the interface class
        of which this device interface is a member.  E.g.,

        HKLM\SYSTEM\CurrentControlSet\Control\DeviceClasses\{InterfaceClassGuid}

    DeviceInterfaceName - Supplies the name of the device interface.

    OwningDevInstName - Optionally, supplies the address of a character buffer that
        receives the name of the device instance that exposes this device interface.
        This buffer should be at least MAX_DEVICE_ID_LEN characters long.

    OwningDevInstNameSize - Supplies the size, in characters, of the OwningDevInstName
        buffer.

    IsActive - Optionally, supplies the address of a boolean variable that is set upon
        return to indicate whether this interface is presently exposed.

    IsDefault - Optionally, supplies the address of a boolean variable that is set upon
        return to indicate whether this interface is presently the default
        device interface for its device class.

Return Value:

    If the function succeeds, the return value is NO_ERROR.  Otherwise, it is a Win32
    error code.

--*/
{
    DWORD Err, DataBufferSize, RegDataType, TmpVal;
    HKEY hKeyDeviceInterface, hKeyControl;
    TCHAR InterfaceClassDefault[(2 * MAX_PATH) + 1];  // 2 max-sized regkey names + terminating NULL.

    hKeyDeviceInterface = hKeyControl = INVALID_HANDLE_VALUE;

    try {

        DataBufferSize = OwningDevInstNameSize * sizeof(TCHAR);

        Err = OpenDeviceInterfaceSubKey(hKeyInterfaceClass,
                                        DeviceInterfaceName,
                                        KEY_READ,
                                        &hKeyDeviceInterface,
                                        OwningDevInstName,
                                        &DataBufferSize
                                       );

        if(Err != ERROR_SUCCESS) {
            //
            // Make sure the key handle is still invalid, so we'll know not to
            // close it.
            //
            hKeyDeviceInterface = INVALID_HANDLE_VALUE;
            goto clean0;
        }

        if(IsActive) {
            //
            // The user wants to find out whether this device interface is currently active.
            // Check the 'Linked' value entry under the volatile 'Control' subkey to find
            // this out.
            //
            *IsActive = FALSE;

            if(ERROR_SUCCESS == RegOpenKeyEx(hKeyDeviceInterface,
                                             pszControl,
                                             0,
                                             KEY_READ,
                                             &hKeyControl)) {

                DataBufferSize = sizeof(TmpVal);
                if (ERROR_SUCCESS != RegQueryValueEx(hKeyControl,
                                                     pszLinked,
                                                     NULL,
                                                     NULL,
                                                     (PBYTE)&TmpVal,
                                                     &DataBufferSize)) {
                    *IsActive = FALSE;
                } else {
                    *IsActive = TmpVal ? TRUE : FALSE;
                }
            }
        }

        if(IsDefault) {
            //
            // The user wants to find out whether this device interface is the
            // default device interface for its device class.  Check the
            // 'Default' value entry under the interface class key to find this
            // out.
            //
            *IsDefault = FALSE;

            DataBufferSize = sizeof(InterfaceClassDefault);
            if (ERROR_SUCCESS == RegQueryValueEx(hKeyInterfaceClass,
                                                 pszDefault,
                                                 NULL,
                                                 NULL,
                                                 (PBYTE)InterfaceClassDefault,
                                                 &DataBufferSize)) {
                if (_tcsicmp(InterfaceClassDefault, DeviceInterfaceName) == 0) {
                    *IsDefault = TRUE;
                }
            }
        }

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variables so the compiler will respect statement
        // ordering w.r.t. assignment.
        //
        hKeyDeviceInterface = hKeyDeviceInterface;
        hKeyControl = hKeyControl;
    }

    if(hKeyControl != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyControl);
    }

    if(hKeyDeviceInterface != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKeyDeviceInterface);
    }

    return Err;
}


//
// ANSI version
//
BOOL
WINAPI
SetupDiCreateDeviceInterfaceA(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,
    IN  CONST GUID                *InterfaceClassGuid,
    IN  PCSTR                      ReferenceString,    OPTIONAL
    IN  DWORD                      CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData OPTIONAL
    )
{
    PCWSTR UnicodeRefString;
    DWORD rc;
    BOOL b;

    b = FALSE;

    if(ReferenceString) {
        rc = pSetupCaptureAndConvertAnsiArg(ReferenceString, &UnicodeRefString);
    } else {
        UnicodeRefString = NULL;
        rc = NO_ERROR;
    }

    if(rc == NO_ERROR) {

        b = SetupDiCreateDeviceInterfaceW(DeviceInfoSet,
                                          DeviceInfoData,
                                          InterfaceClassGuid,
                                          UnicodeRefString,
                                          CreationFlags,
                                          DeviceInterfaceData
                                         );
        rc = GetLastError();

        if(UnicodeRefString) {
            MyFree(UnicodeRefString);
        }
    }

    SetLastError(rc);
    return(b);
}

BOOL
WINAPI
SetupDiCreateDeviceInterface(
    IN  HDEVINFO                   DeviceInfoSet,
    IN  PSP_DEVINFO_DATA           DeviceInfoData,
    IN  CONST GUID                *InterfaceClassGuid,
    IN  PCTSTR                     ReferenceString,    OPTIONAL
    IN  DWORD                      CreationFlags,
    OUT PSP_DEVICE_INTERFACE_DATA  DeviceInterfaceData OPTIONAL
    )
/*++

Routine Description:

    This API creates (registers) a device interface for the specified device
    information element, and adds this device interface to the device information
    set.

Arguments:

    DeviceInfoSet - Supplies a handle to a device information set containing the
        device information element for which a new device interface is being added.

    DeviceInfoData - Supplies the device information element for whom a device
        interface is being added.

    InterfaceClassGuid - Supplies the address of a GUID containing the class
        for this new device interface.

    ReferenceString - Optionally, supplies the reference string to be passed to the
        driver when opening this device interface.  This string becomes part of the
        device interface's name (as an additional path component).

    CreationFlags - Reserved for future use, must be set to 0.

    DeviceInterfaceData - Optionally, supplies a pointer to a device interface data
        buffer that receives information about the newly-created device interface.
        The cbSize field of this structure must be filled in with sizeof(SP_DEVICE_INTERFACE_DATA)
        or the buffer is considered invalid.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If the new device interface was successfully created, but the user-supplied
    DeviceInterfaceData buffer is invalid, this API will return FALSE, with
    GetLastError returning ERROR_INVALID_USER_BUFFER.  The device interface
    element _will_ have been added as a new member of the set, however.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    TCHAR DeviceInterfaceName[(2 * MAX_PATH) + 1];  // 2 max-sized regkey names + terminating NULL.
    ULONG DeviceInterfaceNameSize;
    PCTSTR MachineName;
    CONFIGRET cr;
    BOOL IsActive, IsDefault;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;
    HKEY hKey;

    if(CreationFlags) {
        SetLastError(ERROR_INVALID_FLAGS);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;
    hKey = INVALID_HANDLE_VALUE;

    try {
        //
        // Get a pointer to the device information element we're registering a
        // device interface for.
        //
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Register the device interface.
        //
        DeviceInterfaceNameSize = SIZECHARS(DeviceInterfaceName);
        cr = CM_Register_Device_Interface_Ex(DevInfoElem->DevInst,
                                          (LPGUID)InterfaceClassGuid,
                                          ReferenceString,
                                          DeviceInterfaceName,
                                          &DeviceInterfaceNameSize,
                                          0,
                                          pDeviceInfoSet->hMachine);

        if(cr != CR_SUCCESS) {
            Err = MapCrToSpError(cr, ERROR_INVALID_DATA);
            goto clean0;
        }

        //
        // Retrieve the name of the machine associated with this DeviceInfoSet.
        //
        if(pDeviceInfoSet->hMachine) {
            MYASSERT(pDeviceInfoSet->MachineName != -1);
            MachineName = pStringTableStringFromId(pDeviceInfoSet->StringTable, pDeviceInfoSet->MachineName);
        } else {
            MachineName = NULL;
        }

        //
        // This device interface might have already been registered, in which case it
        // could already be active.  We must check the 'Linked' registry value to see
        // whether this device is active.
        //
        hKey = SetupDiOpenClassRegKeyEx(InterfaceClassGuid,
                                        KEY_READ,
                                        DIOCR_INTERFACE,
                                        MachineName,
                                        NULL
                                       );

        if(hKey != INVALID_HANDLE_VALUE) {

            if(NO_ERROR != pSetupGetDevInstNameAndStatusForDeviceInterface(
                               hKey,
                               DeviceInterfaceName,
                               NULL,
                               0,
                               &IsActive,
                               &IsDefault))
            {
                //
                // This shouldn't fail, but if it does, then just assume that the
                // device interface's status is non-active, and it is not the default.
                //
                IsActive = FALSE;
                IsDefault = FALSE;
            }

        } else {
            //
            // This should never happen--if it does, assume that the device
            // interface isn't active.
            //
            IsActive = FALSE;
            IsDefault = FALSE;
        }

        //
        // The device interface was successfully registered, now add it to the list of
        // device interfaces associated with this device information element.
        //
        Err = pSetupAddDeviceInterfaceToDevInfoElem(pDeviceInfoSet,
                                                    DevInfoElem,
                                                    InterfaceClassGuid,
                                                    DeviceInterfaceName,
                                                    IsActive,
                                                    IsDefault,
                                                    FALSE,
                                                    FALSE,
                                                    &DeviceInterfaceNode
                                                   );

clean0: ;   // nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
        //
        // Reference the following variable so the compiler will respect statement
        // ordering w.r.t. assignment.
        //
        hKey = hKey;
    }

    if(hKey != INVALID_HANDLE_VALUE) {
        RegCloseKey(hKey);
    }

    if((Err == NO_ERROR) && DeviceInterfaceData) {

        try {
            if(!DeviceInterfaceDataFromNode(DeviceInterfaceNode, InterfaceClassGuid, DeviceInterfaceData)) {
                Err = ERROR_INVALID_USER_BUFFER;
            }
        } except(EXCEPTION_EXECUTE_HANDLER) {
            Err = ERROR_INVALID_USER_BUFFER;
        }
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return (Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiDeleteDeviceInterfaceData(
    IN HDEVINFO                  DeviceInfoSet,
    IN PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    )
/*++

Routine Description:

    This API deletes the specified device interface element from the device
    information set.  It _does not_ remove (unregister) the device interface
    from the system (to do that, use SetupDiRemoveDeviceInterface).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        device interface to be deleted.

    DeviceInterfaceData - Specifies the device interface to be deleted.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    After a device interface is deleted, the device interface enumeration index
    is invalid, and enumeration should be re-started at index 0.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode, CurDeviceInterfaceNode, PrevDeviceInterfaceNode;
    PINTERFACE_CLASS_LIST InterfaceClassList;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // First, find the devinfo element that owns this device interface.
        //
        if(!(DevInfoElem = FindDevInfoElemForDeviceInterface(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // The Reserved field contains a pointer to the underlying device interface node.
        //
        DeviceInterfaceNode = (PDEVICE_INTERFACE_NODE)(DeviceInterfaceData->Reserved);

        //
        // Find this devinfo element's device interface list for this class.
        //
        if(!(InterfaceClassList = AddOrGetInterfaceClassList(pDeviceInfoSet,
                                                             DevInfoElem,
                                                             DeviceInterfaceNode->GuidIndex,
                                                             FALSE)))
        {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // Find this device interface node in the list of device interfaces for this device
        // information element.
        //
        for(CurDeviceInterfaceNode = InterfaceClassList->DeviceInterfaceNode, PrevDeviceInterfaceNode = NULL;
            CurDeviceInterfaceNode;
            PrevDeviceInterfaceNode = CurDeviceInterfaceNode, CurDeviceInterfaceNode = CurDeviceInterfaceNode->Next)
        {
            if(CurDeviceInterfaceNode == DeviceInterfaceNode) {
                break;
            }
        }

        if(!CurDeviceInterfaceNode) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        MYASSERT(InterfaceClassList->DeviceInterfaceCount);

        if(PrevDeviceInterfaceNode) {
            PrevDeviceInterfaceNode->Next = CurDeviceInterfaceNode->Next;
        } else {
            InterfaceClassList->DeviceInterfaceNode = CurDeviceInterfaceNode->Next;
        }

        MyFree(DeviceInterfaceNode);
        InterfaceClassList->DeviceInterfaceCount--;

clean0: ;   // Nothing to do.

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
WINAPI
SetupDiRemoveDeviceInterface(
    IN     HDEVINFO                  DeviceInfoSet,
    IN OUT PSP_DEVICE_INTERFACE_DATA DeviceInterfaceData
    )
/*++

Routine Description:

    This API removes (unregisters) the specified device interface.  It _does not_
    delete the device interface element from the device information set (thus
    enumeration is not affected).  Instead, it marks the device interface element
    as invalid, so that it cannot be used in any subsequent API calls except
    SetupDiDeleteDeviceInterfaceData.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        device interface to be removed.

    DeviceInterfaceData - Specifies the device interface to be removed.  All
        traces of this device will be removed from the registry.

        Upon return, the Flags field of this structure will be updated to reflect
        the new state of this device interface.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    There is no way to unregister a device interface while it is active.  Thus,
    this API will fail with ERROR_DEVICE_INTERFACE_ACTIVE in this case.  If this
    happens, you can do one of the following things in an attempt to remove the
    device interface:

        1.  If there is some defined mechanism of communication to the device
            interface/underlying device instance (e.g., an IOCTL) that causes the
            driver to un-expose the device interface, then this method may be used,
            and _then_ SetupDiRemoveDeviceInterface may be called.

        2.  If there is no mechanism as described in method (1), then the owning
            device instance must be stopped (e.g., via SetupDiChangeState), which
            will cause all device interfaces owned by that device instance to go
            inactive.  After that is done, then SetupDiRemoveDeviceInterface may
            be called.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err;
    PDEVINFO_ELEM DevInfoElem;
    PDEVICE_INTERFACE_NODE DeviceInterfaceNode;
    PCTSTR DevicePath, MachineName;
    TCHAR InterfaceClassDefault[(2 * MAX_PATH) + 1];  // 2 max-sized regkey names + terminating NULL.
    DWORD DataBufferSize;
    HKEY hKeyInterfaceClass;
    CONFIGRET cr;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        //
        // Get a pointer to the device information element for the specified
        // device interface.
        //
        if(!(DevInfoElem = FindDevInfoElemForDeviceInterface(pDeviceInfoSet, DeviceInterfaceData))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // The Reserved field contains a pointer to the underlying device interface node.
        //
        DeviceInterfaceNode = (PDEVICE_INTERFACE_NODE)(DeviceInterfaceData->Reserved);

        //
        // OK, now open the device interface's root storage key.
        //
        DevicePath = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                              DeviceInterfaceNode->SymLinkName
                                             );

        cr = CM_Unregister_Device_Interface_Ex(DevicePath, 0,pDeviceInfoSet->hMachine);

        if(cr != CR_SUCCESS) {

            switch(cr) {

                case CR_NO_SUCH_DEVICE_INTERFACE :
                    //
                    // The device interface was deleted after it was enumerated/opened
                    // by this client.  In this case, we'll go ahead and succeed this
                    // call.
                    //
                    break;

                case CR_DEVICE_INTERFACE_ACTIVE :
                    Err = ERROR_DEVICE_INTERFACE_ACTIVE;
                    //
                    // If our SPINT_ACTIVE flag isn't set, then that means that the device
                    // wasn't active the last time we looked.  Update our flag to indicate
                    // the device's new state.
                    //
                    DeviceInterfaceNode->Flags |= SPINT_ACTIVE;
                    goto clean1;

                default :
                    Err = ERROR_INVALID_DATA;
                    goto clean0;
            }
        }

        //
        // The device interface was successfully removed.  Now, mark the device
        // interface node to reflect that it's now invalid.
        //
        DeviceInterfaceNode->Flags |= SPINT_REMOVED;

        //
        // Also, clear the SPINT_ACTIVE flag, in case it's set.  It's possible that we thought
        // the device was active, even though it was deactivated since the last time we looked.
        //
        DeviceInterfaceNode->Flags &= ~SPINT_ACTIVE;


        //
        // Retrieve the name of the machine associated with this DeviceInfoSet.
        //
        if(pDeviceInfoSet->hMachine) {
            MYASSERT(pDeviceInfoSet->MachineName != -1);
            MachineName = pStringTableStringFromId(pDeviceInfoSet->StringTable, pDeviceInfoSet->MachineName);
        } else {
            MachineName = NULL;
        }

        //
        // Open this interface class key under the DeviceClasses registry
        // branch.
        //
        hKeyInterfaceClass = SetupDiOpenClassRegKeyEx(&DeviceInterfaceData->InterfaceClassGuid,
                                                      KEY_READ | KEY_WRITE,
                                                      DIOCR_INTERFACE,
                                                      MachineName,
                                                      NULL);
        if(hKeyInterfaceClass == INVALID_HANDLE_VALUE) {
            goto clean1;
        }

        //
        // Check if this interface is specified in the registry as the default
        // device interface.
        //
        DataBufferSize = sizeof(InterfaceClassDefault);
        if (ERROR_SUCCESS == RegQueryValueEx(hKeyInterfaceClass,
                                             pszDefault,
                                             NULL,
                                             NULL,
                                             (PBYTE)InterfaceClassDefault,
                                             &DataBufferSize)) {
            if (lstrcmpi(InterfaceClassDefault, DevicePath) == 0) {
                //
                // Delete the "Default" value under this interface class key.
                //
                if(ERROR_SUCCESS == RegDeleteValue(hKeyInterfaceClass,
                                                   pszDefault)) {
                    //
                    // This interface has been successfully removed as the
                    // "Default" interface for this class.  Clear the
                    // SPINT_DEFAULT flag.
                    //
                    DeviceInterfaceNode->Flags &= ~SPINT_DEFAULT;
                }
            } else {
                //
                // This interface is not listed in the registry as the
                // current default device interface for this class, so clear
                // the SPINT_DEFAULT flag.
                //
                DeviceInterfaceNode->Flags &= ~SPINT_DEFAULT;
            }
        } else {
            //
            // We could not retrieve the "Default" value, but we should still
            // make sure to clear the SPINT_DEFAULT flag on this interface.
            //
            DeviceInterfaceNode->Flags &= ~SPINT_DEFAULT;
        }

        RegCloseKey(hKeyInterfaceClass);

clean1:
        //
        // Finally, updated the flags in the caller-supplied buffer to indicate the new status
        // of this device interface.
        //
        DeviceInterfaceData->Flags = DeviceInterfaceNode->Flags;

clean0: ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}


BOOL
pSetupDiSetDeviceInfoContext(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD            Context
    )
/*++

Routine Description:

    This API stores a context value into the specified device information element
    for later retrieval via pSetupDiGetDeviceInfoContext.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device information element with which the context data is to be
        associated.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure indicating
        which element the context data should be associated with.

    Context - Specifies the data value to be stored for this device information element.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    return pSetupDiGetOrSetDeviceInfoContext(DeviceInfoSet,
                                             DeviceInfoData,
                                             Context,
                                             NULL
                                            );
}


BOOL
pSetupDiGetDeviceInfoContext(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    OUT PDWORD           Context
    )
/*++

Routine Description:

    This API retrieves a context value from the specified device information element
    (stored there via pSetupDiSetDeviceInfoContext).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device information element with which the context data is associated.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure indicating
        which element the context data is associated with.

    Context - Supplies the address of a variable that receives the context value
        stored for the device information element in a prior call to
        pSetupDiSetDeviceInfoContext.  If no context data has previously been stored
        for this element, this variable will be filled in with zero upon return.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    //
    // If we let a NULL context pointer go through to the worker routine, it will
    // think this is a 'set' instead of a 'get'.  Make sure that doesn't happen.
    //
    if(!Context) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return pSetupDiGetOrSetDeviceInfoContext(DeviceInfoSet,
                                             DeviceInfoData,
                                             0,               // ignored
                                             Context
                                            );
}


BOOL
pSetupDiGetOrSetDeviceInfoContext(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD            InContext,
    OUT PDWORD           OutContext      OPTIONAL
    )
/*++

Routine Description:

    This API retrieves or sets a context value from the specified device information
    element (stored there via pSetupDiSetDeviceInfoContext).

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set containing
        the device information element with which the context data is associated.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure indicating
        which element the context data is associated with.

    InContext - Specifies the data value to be stored for this device information element.
        If OutContext is specified, then this is a 'get' instead of a 'set', and
        this parameter is ignored.

    OutContext - Optionally, supplies the address of a variable that receives the
        context value stored for the device information element in a prior call to
        pSetupDiSetDeviceInfoContext.  If no context data has previously been stored
        for this element, this variable will be filled in with zero upon return.

Return Value:

    If the function succeeds, the return value is TRUE.

    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/
{
    PDEVICE_INFO_SET pDeviceInfoSet;
    PDEVINFO_ELEM DevInfoElem;
    DWORD Err;

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR; // assume success.

    try {

        DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                DeviceInfoData,
                                                NULL
                                               );
        if(!DevInfoElem) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        if(OutContext) {
            //
            // Store the context in the caller-supplied buffer.
            //
            *OutContext = DevInfoElem->Context;
        } else {
            //
            // Set the context to the caller-supplied value.
            //
            DevInfoElem->Context = InContext;
        }

clean0:
        ;   // nothing to do

    } except(EXCEPTION_EXECUTE_HANDLER) {
        Err = ERROR_INVALID_PARAMETER;
    }

    UnlockDeviceInfoSet(pDeviceInfoSet);

    SetLastError(Err);
    return(Err == NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\pnp\setupapi\devinstd.c ===
/*++

Copyright (c) Microsoft Corporation.  All rights reserved.

Module Name:

    devinstd.c

Abstract:

    Default install handlers for SetupDiCallClassInstaller DIF_* functions.

Author:

    Lonny McMichael (lonnym) 1-Aug-1995

Revision History:

    Jamie Hunter (jamiehun) 20-January-1998 Added backup functionality in
        _SetupDiInstallDevice - DI_FLAGSEX_BACKUPOLDFILES

--*/

#include "precomp.h"
#pragma hdrstop

//
// Global strings for use inside this file only.
//
CONST TCHAR pszDisplayName[]    = INFSTR_KEY_DISPLAYNAME,
            pszServiceType[]    = INFSTR_KEY_SERVICETYPE,
            pszStartType[]      = INFSTR_KEY_STARTTYPE,
            pszErrorControl[]   = INFSTR_KEY_ERRORCONTROL,
            pszServiceBinary[]  = INFSTR_KEY_SERVICEBINARY,
            pszLoadOrderGroup[] = INFSTR_KEY_LOADORDERGROUP,
            pszDependencies[]   = INFSTR_KEY_DEPENDENCIES,
            pszStartName[]      = INFSTR_KEY_STARTNAME,
            pszSystemRoot[]     = TEXT("%SystemRoot%\\"),
            pszSecurity[]       = INFSTR_KEY_SECURITY,
            pszDescription[]    = INFSTR_KEY_DESCRIPTION;


//
// Define the various copy scenarios that can be returned from GetNewInfName().
//
typedef enum _NEWINF_COPYTYPE {
    NewInfCopyYes,       // new INF placeholder created--need to copy real INF
    NewInfCopyNo,        // no need to copy--INF already present in destination
    NewInfCopyZeroLength // previously-existing zero-length INF match found
} NEWINF_COPYTYPE, *PNEWINF_COPYTYPE;


//
// Define a list node to hold an interface class to be installed.
//
typedef struct _INTERFACE_CLASS_TO_INSTALL {

    struct _INTERFACE_CLASS_TO_INSTALL *Next;

    GUID  InterfaceGuid;
    DWORD Flags;
    TCHAR InstallSection[MAX_SECT_NAME_LEN];

} INTERFACE_CLASS_TO_INSTALL, *PINTERFACE_CLASS_TO_INSTALL;


//
// Define a list node to hold an INF that has been newly-installed during
// SetupDiInstallDevice, hence must be cleaned up if SetupDiInstallDevice
// subsequently encounters a failure.
//
typedef struct _INSTALLED_INF_CLEANUP {
    struct _INSTALLED_INF_CLEANUP *Next;
    TCHAR InfName[MAX_PATH];
} INSTALLED_INF_CLEANUP, *PINSTALLED_INF_CLEANUP;


//
// Private function prototypes
//
BOOL
_SetupDiInstallDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     BOOL             DoFullInstall
    );

DWORD
InstallHW(
    IN  HDEVINFO         DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  HINF             hDeviceInf,
    IN  PCTSTR           szSectionName,
    OUT PBOOL            DeleteDevKey
    );

BOOL
AssociateDevInstWithDefaultService(
    IN     PDEVINFO_ELEM DevInfoElem,
    OUT    PTSTR         ServiceName,
    IN OUT PDWORD        ServiceNameSize
    );

BOOL
CheckIfDevStarted(
    IN PDEVINFO_ELEM DevInfoElem,
    IN PDEVICE_INFO_SET pDeviceInfoSet
    );

DWORD
pSetupAddService(
    IN  PINFCONTEXT        LineContext,
    OUT PSVCNAME_NODE *    SvcListHead,
    IN  DWORD              Flags,
    IN  DEVINST            DevInst,            OPTIONAL
    OUT PBOOL              NullDriverInstalled,
    IN  PSETUP_LOG_CONTEXT LogContext
    );

DWORD
pSetupDeleteService(
    IN PINFCONTEXT         LineContext,
    IN DWORD               Flags,
    IN PSETUP_LOG_CONTEXT  LogContext
    );

DWORD
DeleteServicesInList(
    IN PSVCNAME_NODE ServicesToDelete,
    IN PSETUP_LOG_CONTEXT  LogContext
    );

BOOL
IsDevRemovedFromAllHwProfiles(
    IN PCTSTR DeviceInstanceId,
    IN HMACHINE hMachine
    );

DWORD
GetDevInstConfigFlags(
    IN DEVINST DevInst,
    IN DWORD   Default,
    IN HMACHINE hMachine
    );

PTSTR
pSetupCmdLineAppendString(
    IN     PTSTR  CmdLine,
    IN     PCTSTR Key,
    IN     PCTSTR Value,   OPTIONAL
    IN OUT PUINT  StrLen,
    IN OUT PUINT  BufSize
    );

BOOL
_SetupDiInstallDeviceInterfaces(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOL             DoFullInstall,
    IN HINF             hDeviceInf,     OPTIONAL
    IN HSPFILEQ         UserFileQ       OPTIONAL
    );

BOOL
_SetupDiRegisterCoDeviceInstallers(
    IN HDEVINFO         DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN BOOL             DoFullInstall,
    IN HINF             hDeviceInf,     OPTIONAL
    IN HSPFILEQ         UserFileQ       OPTIONAL
    );

BOOL
RetrieveAllDevNodesSharingDriversWithDevice(
    IN  PDEVINFO_ELEM  DevInfoElem,
    OUT PTSTR          *Drivers,
    OUT PDEVNODE       *DevNodes,
    OUT ULONG          *NumberOfDevNodes,
    IN  HMACHINE       hMachine
    );

VOID
RestartSingleDevice(
    IN  PDEVINFO_ELEM       DevInfoElem,
    IN  PDEVICE_INFO_SET    pDeviceInfoSet,
    IN  BOOL                NullDriverInstall,
    IN  PSETUP_LOG_CONTEXT  LogContext
    );

VOID
RestartAllDevicesUsingDrivers(
    IN  PDEVINFO_ELEM       DevInfoElem,
    IN  PDEVICE_INFO_SET    pDeviceInfoSet,
    IN  BOOL                NullDriverInstall,
    IN  PSETUP_LOG_CONTEXT  LogContext
    );

DWORD
GetNewInfName(
    IN     HWND                    Owner,                     OPTIONAL
    IN     PCTSTR                  OemInfName,
    IN     PCTSTR                  OemInfOriginalName,
    IN     PCTSTR                  OemInfCatName,             OPTIONAL
    OUT    PTSTR                   NewInfName,
    IN     DWORD                   NewInfNameSize,
    OUT    PDWORD                  RequiredSize,
    OUT    PNEWINF_COPYTYPE        CopyNeeded,
    IN     BOOL                    ReplaceOnly,
    IN     PCTSTR                  DeviceDesc,                OPTIONAL
    IN     DWORD                   DriverSigningPolicy,
    IN     DWORD                   Flags,
    IN     PCTSTR                  AltCatalogFile,            OPTIONAL
    IN     PSP_ALTPLATFORM_INFO_V2 AltPlatformInfo,           OPTIONAL
    OUT    PDWORD                  DriverSigningError,        OPTIONAL
    OUT    PTSTR                   CatalogFilenameOnSystem,
    IN     PSETUP_LOG_CONTEXT      LogContext,
    IN OUT PVERIFY_CONTEXT         VerifyContext,             OPTIONAL
    OUT    HANDLE                 *hWVTStateData              OPTIONAL
    );

VOID
_WriteVetoLogEntry(
    IN PSETUP_LOG_CONTEXT LogContext,
    IN DWORD              Level,
    IN DWORD              MessageId,
    IN PCTSTR             szDevID,
    IN PCTSTR             szVetoName,
    IN PNP_VETO_TYPE      dwVetoType
    )
{
    static LPCTSTR VetoMap[] = {
        TEXT("PNP_VetoTypeUnknown"),
        TEXT("PNP_VetoLegacyDevice"),
        TEXT("PNP_VetoPendingClose"),
        TEXT("PNP_VetoWindowsApp"),
        TEXT("PNP_VetoWindowsService"),
        TEXT("PNP_VetoOutstandingOpen"),
        TEXT("PNP_VetoDevice"),
        TEXT("PNP_VetoDriver"),
        TEXT("PNP_VetoIllegalDeviceRequest"),
        TEXT("PNP_VetoInsufficientPower"),
        TEXT("PNP_VetoNonDisableable"),
        TEXT("PNP_VetoLegacyDriver"),
        TEXT("PNP_VetoInsufficientRights")
    };
    MYASSERT(dwVetoType < ARRAYSIZE(VetoMap));

    WriteLogEntry(
        LogContext,
        Level,
        MessageId,
        NULL,
        szDevID,
        szVetoName,
        dwVetoType,
        dwVetoType < ARRAYSIZE(VetoMap) ? VetoMap[dwVetoType] : TEXT("????")
        );
}

LPCTSTR
_MapCmProbToString(
    IN DWORD prob
    )
{

#define PROBLEM_MAP_SIZE    0x33
#if PROBLEM_MAP_SIZE != NUM_CM_PROB
#error Add new problem code to ProbMap and update PROBLEM_MAP_SIZE.
#endif

    static LPCTSTR ProbMap [PROBLEM_MAP_SIZE] = {
        NULL,
        TEXT("CM_PROB_NOT_CONFIGURED"),
        TEXT("CM_PROB_DEVLOADER_FAILED"),
        TEXT("CM_PROB_OUT_OF_MEMORY"),
        TEXT("CM_PROB_ENTRY_IS_WRONG_TYPE"),
        TEXT("CM_PROB_LACKED_ARBITRATOR"),
        TEXT("CM_PROB_BOOT_CONFIG_CONFLICT"),
        TEXT("CM_PROB_FAILED_FILTER"),
        TEXT("CM_PROB_DEVLOADER_NOT_FOUND"),
        TEXT("CM_PROB_INVALID_DATA"),
        TEXT("CM_PROB_FAILED_START"),
        TEXT("CM_PROB_LIAR"),
        TEXT("CM_PROB_NORMAL_CONFLICT"),
        TEXT("CM_PROB_NOT_VERIFIED"),
        TEXT("CM_PROB_NEED_RESTART"),
        TEXT("CM_PROB_REENUMERATION"),
        TEXT("CM_PROB_PARTIAL_LOG_CONF"),
        TEXT("CM_PROB_UNKNOWN_RESOURCE"),
        TEXT("CM_PROB_REINSTALL"),
        TEXT("CM_PROB_REGISTRY"),
        NULL,
        TEXT("CM_PROB_WILL_BE_REMOVED"),
        TEXT("CM_PROB_DISABLED"),
        TEXT("CM_PROB_DEVLOADER_NOT_READY"),
        TEXT("CM_PROB_DEVICE_NOT_THERE"),
        TEXT("CM_PROB_MOVED"),
        TEXT("CM_PROB_TOO_EARLY"),
        TEXT("CM_PROB_NO_VALID_LOG_CONF"),
        TEXT("CM_PROB_FAILED_INSTALL"),
        TEXT("CM_PROB_HARDWARE_DISABLED"),
        TEXT("CM_PROB_CANT_SHARE_IRQ"),
        TEXT("CM_PROB_FAILED_ADD"),
        TEXT("CM_PROB_DISABLED_SERVICE"),
        TEXT("CM_PROB_TRANSLATION_FAILED"),
        TEXT("CM_PROB_NO_SOFTCONFIG"),
        TEXT("CM_PROB_BIOS_TABLE"),
        TEXT("CM_PROB_IRQ_TRANSLATION_FAILED"),
        TEXT("CM_PROB_FAILED_DRIVER_ENTRY"),
        TEXT("CM_PROB_DRIVER_FAILED_PRIOR_UNLOAD"),
        TEXT("CM_PROB_DRIVER_FAILED_LOAD"),
        TEXT("CM_PROB_DRIVER_SERVICE_KEY_INVALID"),
        TEXT("CM_PROB_LEGACY_SERVICE_NO_DEVICES"),
        TEXT("CM_PROB_DUPLICATE_DEVICE"),
        TEXT("CM_PROB_FAILED_POST_START"),
        TEXT("CM_PROB_HALTED"),
        TEXT("CM_PROB_PHANTOM"),
        TEXT("CM_PROB_SYSTEM_SHUTDOWN"),
        TEXT("CM_PROB_HELD_FOR_EJECT"),
        TEXT("CM_PROB_DRIVER_BLOCKED"),
        TEXT("CM_PROB_REGISTRY_TOO_LARGE"),
        TEXT("CM_PROB_SETPROPERTIES_FAILED")
    };
    LPCTSTR ProbText = NULL;

    MYASSERT(ARRAYSIZE(ProbMap)==NUM_CM_PROB);
    MYASSERT(prob<NUM_CM_PROB);

    if(prob < ARRAYSIZE(ProbMap)) {
        ProbText = ProbMap[prob];
    }
    if(!ProbText) {
        ProbText = TEXT("????");
    }
    return ProbText;
}

LPCTSTR
_MapCmRetToString(
    IN DWORD cr
    )
{
    LPCTSTR RetText = NULL;
    static LPCTSTR RetMap [] = {
        TEXT("CR_SUCCESS"),
        TEXT("CR_DEFAULT"),
        TEXT("CR_OUT_OF_MEMORY"),
        TEXT("CR_INVALID_POINTER"),
        TEXT("CR_INVALID_FLAG"),
        TEXT("CR_INVALID_DEVNODE"),
        TEXT("CR_INVALID_RES_DES"),
        TEXT("CR_INVALID_LOG_CONF"),
        TEXT("CR_INVALID_ARBITRATOR"),
        TEXT("CR_INVALID_NODELIST"),
        TEXT("CR_DEVNODE_HAS_REQS"),
        TEXT("CR_INVALID_RESOURCEID"),
        TEXT("CR_DLVXD_NOT_FOUND"),
        TEXT("CR_NO_SUCH_DEVNODE"),
        TEXT("CR_NO_MORE_LOG_CONF"),
        TEXT("CR_NO_MORE_RES_DES"),
        TEXT("CR_ALREADY_SUCH_DEVNODE"),
        TEXT("CR_INVALID_RANGE_LIST"),
        TEXT("CR_INVALID_RANGE"),
        TEXT("CR_FAILURE"),
        TEXT("CR_NO_SUCH_LOGICAL_DEV"),
        TEXT("CR_CREATE_BLOCKED"),
        TEXT("CR_NOT_SYSTEM_VM"),
        TEXT("CR_REMOVE_VETOED"),
        TEXT("CR_APM_VETOED"),
        TEXT("CR_INVALID_LOAD_TYPE"),
        TEXT("CR_BUFFER_SMALL"),
        TEXT("CR_NO_ARBITRATOR"),
        TEXT("CR_NO_REGISTRY_HANDLE"),
        TEXT("CR_REGISTRY_ERROR"),
        TEXT("CR_INVALID_DEVICE_ID"),
        TEXT("CR_INVALID_DATA"),
        TEXT("CR_INVALID_API"),
        TEXT("CR_DEVLOADER_NOT_READY"),
        TEXT("CR_NEED_RESTART"),
        TEXT("CR_NO_MORE_HW_PROFILES"),
        TEXT("CR_DEVICE_NOT_THERE"),
        TEXT("CR_NO_SUCH_VALUE"),
        TEXT("CR_WRONG_TYPE"),
        TEXT("CR_INVALID_PRIORITY"),
        TEXT("CR_NOT_DISABLEABLE"),
        TEXT("CR_FREE_RESOURCES"),
        TEXT("CR_QUERY_VETOED"),
        TEXT("CR_CANT_SHARE_IRQ"),
        TEXT("CR_NO_DEPENDENT"),
        TEXT("CR_SAME_RESOURCES"),
        TEXT("CR_NO_SUCH_REGISTRY_KEY"),
        TEXT("CR_INVALID_MACHINENAME"),
        TEXT("CR_REMOTE_COMM_FAILURE"),
        TEXT("CR_MACHINE_UNAVAILABLE"),
        TEXT("CR_NO_CM_SERVICES"),
        TEXT("CR_ACCESS_DENIED"),
        TEXT("CR_CALL_NOT_IMPLEMENTED"),
        TEXT("CR_INVALID_PROPERTY"),
        TEXT("CR_DEVICE_INTERFACE_ACTIVE"),
        TEXT("CR_NO_SUCH_DEVICE_INTERFACE"),
        TEXT("CR_INVALID_REFERENCE_STRING"),
        TEXT("CR_INVALID_CONFLICT_LIST"),
        TEXT("CR_INVALID_INDEX"),
        TEXT("CR_INVALID_STRUCTURE_SIZE")
    };
    MYASSERT(ARRAYSIZE(RetMap)==NUM_CR_RESULTS);
    MYASSERT(cr<NUM_CR_RESULTS);

    if(cr < ARRAYSIZE(RetMap)) {
        RetText = RetMap[cr];
    }
    if(!RetText) {
        RetText = TEXT("????");
    }
    return RetText;
}

BOOL
WINAPI
SetupDiInstallDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
/*++

Routine Description:

    Default handler for DIF_INSTALLDEVICE

    This routine will install a device by performing a SetupInstallFromInfSection
    for the install section of the selected driver for the specified device
    information element.  The device will then be started (if possible).

    NOTE:  This API actually supports an OS/architecture-specific extension that
    may be used to specify multiple installation behaviors for a single device,
    based on the environment we're running under.  The algorithm is as follows:

    We take the install section name, as specified in the driver node (for this
    example, it's "InstallSec"), and attempt to find one of the following INF
    sections (searched for in the order specified):

    If we're running under Windows 95:

        1. InstallSec.Win
        2. InstallSec

    If we're running under Windows NT:

        1. InstallSec.NT<platform>  (platform is "x86", "AMD64", or "IA64")
        2. InstallSec.NT
        3. InstallSec

    The first section that we find is the one we'll use to do the installation.  This
    section name is also what we'll base our ".Hw" and ".Services" installation against.
    (E.g., if we match on "InstallSec.NTAmd64", then the service install section must be
    named "InstallSec.NTAmd64.Services".)

    The original install section name (i.e., the one specified in the driver node), will
    be written as-is to the driver key's "InfSection" value entry, just as it was in the
    past.  The extension that we use (if any) will be stored in the device's driver key
    as the REG_SZ value, "InfSectionExt".  E.g.,

        InfSection    : REG_SZ : "InstallSec"
        InfSectionExt : REG_SZ : ".NTMIPS"

    If we successfully install the device, we'll kick off RunOnce.  NOTE: We
    must do this _regardless_ of whether or not the device was dynamically
    brought on-line with its newly-installed driver/settings.  This is because,
    for server-side device installations, the RunOnce processing is done by the
    user-mode PnP manager.  We can't put this off until 'later'.  Also, since
    anyone can kick off a RunOnce at any time, you really would have no
    assurance that the RunOnce would be postponed until after reboot anyway.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        driver is to be installed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for which
        a driver is to be installed.  This is an IN OUT parameter, since the
        DevInst field of the structure may be updated with a new handle value upon
        return.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

Remarks:

    If no driver is selected for the specified device information element, then a
    NULL driver will be installed.

    Upon return, the install parameters Flags will indicate whether the system
    needs to be rebooted or restarted in order for the device to be started.

    During GUI-mode setup on Windows NT, quiet-install behavior is always
    employed in the absence of a user-supplied file queue, regardless of
    whether the device information element has the DI_QUIETINSTALL flag set.

--*/

{
    return _SetupDiInstallDevice(DeviceInfoSet, DeviceInfoData, TRUE);
}


BOOL
_SetupDiInstallDevice(
    IN     HDEVINFO         DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData,
    IN     BOOL             DoFullInstall
    )
/*++

Routine Description:

    Worker routine for both SetupDiInstallDevice and SetupDiInstallDriverFiles.

    See the description of SetupDiInstallDevice for more information.

    (jamiehun) If backups are enabled (DI_FLAGSEX_BACKUPOLDFILES or DI_FLAGSEX_BACKUPONREPLACE)
    then old inf file is backed up.

Arguments:

    DeviceInfoSet - Supplies a handle to the device information set for which a
        driver is to be installed.

    DeviceInfoData - Supplies the address of a SP_DEVINFO_DATA structure for which
        a driver is to be installed.  This is an IN OUT parameter, since the
        DevInst field of the structure may be updated with a new handle value upon
        return.

    DoFullInstall - If TRUE, then an entire device installation is performed,
        otherwise, only the driver files are copied.

Return Value:

    If the function succeeds, the return value is TRUE.
    If the function fails, the return value is FALSE.  To get extended error
    information, call GetLastError.

--*/

{
    PDEVICE_INFO_SET pDeviceInfoSet;
    DWORD Err, ScanQueueResult;
    PDEVINFO_ELEM DevInfoElem = NULL;
    PTSTR szInfFileName, szInfSectionName;
    PTSTR szInfSectionExt = NULL;
    TCHAR InfSectionWithExt[MAX_PATH];
    DWORD InfSectionWithExtLength;
    HINF hDeviceInf = INVALID_HANDLE_VALUE;
    HKEY hkDrv = INVALID_HANDLE_VALUE;
    PSP_FILE_CALLBACK MsgHandler;
    PVOID MsgHandlerContext;
    BOOL MsgHandlerIsNativeCharWidth;
    HSPFILEQ UserFileQ;
    INFCONTEXT InfContext;
    DWORD dwConfigFlags=0;
    ULONG cbData;
    PTSTR DevIdBuffer = NULL;
    PCTSTR TempString;
    ULONG ulStatus, ulProblem;
    DEVINST dnReenum = 0;
    TCHAR szNewName[MAX_PATH];
    BOOL OemInfFileToCopy = FALSE;
    BOOL InfFromOemPath = FALSE;
    BOOL DeleteDevKey = FALSE;
    PSVCNAME_NODE DeleteServiceList = NULL;
    BOOL FreeMsgHandlerContext = FALSE;
    BOOL CloseUserFileQ = FALSE;
    HWND hwndParent;
    BOOL DoFileCopying;
    DWORD DevInstCapabilities;
    TCHAR DeviceFullID[MAX_DEVICE_ID_LEN];
    DWORD BackupFlags = 0;
    BOOL NullDriverInstall = FALSE;
    PINSTALLED_INF_CLEANUP InfsToCleanUp = NULL;
    INT FileQueueNeedsReboot;
    PSETUP_LOG_CONTEXT LogContext = NULL;
    DWORD slot_deviceID = 0;
    DWORD slot_section = 0;
    DWORD FileQueueFlags;
    BOOL NoProgressUI;
    TCHAR className[MAX_CLASS_NAME_LEN];
    PSP_ALTPLATFORM_INFO_V2 ValidationPlatform = NULL;

#if MAX_SECT_NAME_LEN > MAX_PATH
#error MAX_SECT_NAME_LEN is larger than MAX_PATH--fix InfSectionWithExt!
#endif

    ASSERT_HEAP_IS_VALID();

    //
    // We can only install a device if a device was specified.
    //
    if(!DeviceInfoData) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if(!(pDeviceInfoSet = AccessDeviceInfoSet(DeviceInfoSet))) {
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    //
    // Make sure we're local
    //
    if(NULL != pDeviceInfoSet->hMachine ) {   //&& !g_ReadOnlyRemote ??
        //
        // hDevInfo may be valid, but it's not for this machine
        //
        UnlockDeviceInfoSet(pDeviceInfoSet);
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    Err = NO_ERROR;

    try {
        if(!(DevInfoElem = FindAssociatedDevInfoElem(pDeviceInfoSet,
                                                     DeviceInfoData,
                                                     NULL))) {
            Err = ERROR_INVALID_PARAMETER;
            goto clean0;
        }

        //
        // This routine can't install a non-native driver
        //
        if(DevInfoElem->InstallParamBlock.FlagsEx & DI_FLAGSEX_ALTPLATFORM_DRVSEARCH) {

            Err = ERROR_INVALID_FLAGS;
            goto clean0;
        }

        //
        // Make sure we only use the devinfo element's window if it's valid.
        //
        if(hwndParent = DevInfoElem->InstallParamBlock.hwndParent) {
           if(!IsWindow(hwndParent)) {
                hwndParent = NULL;
           }
        }

        //
        // set the local log context before it gets used.
        //
        LogContext = DevInfoElem->InstallParamBlock.LogContext;

        WriteLogEntry(
            LogContext,
            DRIVER_LOG_TIME,
            MSG_LOG_BEGIN_INSTALL_TIME,
            NULL);       // text message

        //
        // obtain the full id of the device we are (re)installing
        //
        if( CM_Get_Device_ID(DevInfoElem->DevInst,
                         DeviceFullID,
                         SIZECHARS(DeviceFullID),
                         0
                        ) != CR_SUCCESS ) {
                Err = ERROR_INVALID_HANDLE;
                goto clean0;
        }

        //
        // If we are installing a driver, then the selected driver pointer will be
        // non-NULL, otherwise we are actually removing the driver (i.e., installing the
        // NULL driver)
        //
        if(DevInfoElem->SelectedDriver) {
            if(DoFullInstall) {
                if(slot_deviceID == 0) {
                    slot_deviceID = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_INFO,FALSE);
                }
                WriteLogEntry(
                    LogContext,
                    slot_deviceID,
                    MSG_LOG_DO_FULL_INSTALL,
                    NULL,       // text message
                    DeviceFullID);
                //
                // Create the Driver Reg Key.
                //
                if((hkDrv = SetupDiCreateDevRegKey(DeviceInfoSet,
                                                   DeviceInfoData,
                                                   DICS_FLAG_GLOBAL,
                                                   0,
                                                   DIREG_DRV,
                                                   NULL,
                                                   NULL)) == INVALID_HANDLE_VALUE) {
                    Err = GetLastError();
                    goto clean0;
                }

            } else {
                DWORD slot = slot_deviceID;
                if(slot_deviceID == 0) {
                    if(DevInfoElem->InstallParamBlock.Flags & DI_NOVCP) {
                        slot = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_VERBOSE,TRUE); // may be being copied for someone else - keep this around
                    } else {
                        slot_deviceID = slot = AllocLogInfoSlotOrLevel(LogContext,DRIVER_LOG_INFO,FALSE); // we do copy ourselves
                    }
                }
                WriteLogEntry(
                    LogContext,
                    slot,
                    MSG_LOG_DO_COPY_INSTALL,
                    NULL,       // text message
                    DeviceFullID);
            }

            szInfFileName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                     DevInfoElem->SelectedDriver->InfFileName
                                                    );

            szInfSectionName = pStringTableStringFromId(pDeviceInfoSet->StringTable,
                                                        DevInfoElem->SelectedDriver->InfSectionName
                                                       );

            if((hDeviceInf = SetupOpenInfFile(szInfFileName,
                                              NULL,
                                              INF_STYLE_WIN4,
                                              NULL)) == INVALID_HANDLE_VALUE) {
                Err = GetLastError();
                goto clean0;
            }

            //
            // Give the INF whatever the local log context is.
            //
            InheritLogContext(LogContext, &((PLOADED_INF) hDeviceInf)->LogContext);
            SetLogSectionName(LogContext, TEXT("Driver Install"));

            //
            // Figure out whether we need to copy files. (Ignore the DI_NOFILECOPY flag if we're
            // doing a copy-only installation--that's what setupx does.)
            //
            DoFileCopying = (!(DevInfoElem->InstallParamBlock.Flags & DI_NOFILECOPY) || !DoFullInstall);

            //
            // Find out the 'real' install section we should be using (i.e.,
            // the potentially OS/architecture-specific one.
            //
            if(!SetupDiGetActualSectionToInstall(hDeviceInf,
                                                 szInfSectionName,
                                                 InfSectionWithExt,
                                                 SIZECHARS(InfSectionWithExt),
                                                 &InfSectionWithExtLength,
                                                 &szInfSectionExt
                                                 )) {
                Err = GetLastError();
                goto clean0;
            }

            //
            // Append the layout INF, if necessary.
            //
            if(DoFileCopying) {
                SetupOpenAppendInfFile(NULL, hDeviceInf, NULL);
            }

            //
            // Append-load any included INFs specified in an "include=" line in our
            // install section.
            //
            AppendLoadIncludedInfs(hDeviceInf, szInfFileName, InfSectionWithExt, DoFileCopying);

            ASSERT_HEAP_IS_VALID();

            //
            // Now perform file installation activities...
            //
            if(!DoFileCopying) {
                //
                // We're not supposed to do any file copying,  In this case, we
                // still need to have the INF copied to the INF directory
                // (along with its associated catalog, if any).
                //
                if(pSetupInfIsFromOemLocation(szInfFileName, TRUE)) {

                    TCHAR CatalogName[MAX_PATH];
                    TCHAR OriginalInfName[MAX_PATH];
                    TCHAR CatalogFilenameOnSystem[MAX_PATH];
                    BOOL DifferentOriginalName, UseOriginalInfName;
                    DWORD PolicyToUse;

                    //
                    // Retrieve (potentially decorated) CatalogFile= entry, if
                    // present, from [version] section.
                    //
                    // Note: We're safe in casting our INF handle straight to a
                    // PLOADED_INF (without even locking it), since this INF
                    // handle will never be seen outside of this routine.
                    //
                    Err = pGetInfOriginalNameAndCatalogFile(
                              (PLOADED_INF)hDeviceInf,
                              NULL,
                              &DifferentOriginalName,
                              OriginalInfName,
                              SIZECHARS(OriginalInfName),
                              CatalogName,
                              SIZECHARS(CatalogName),
                              NULL // always native OS/arch (ver doesn't matter for CatalogFile=)
                             );

                    if(Err == NO_ERROR) {
                        if(*CatalogName) {
                            TempString = CatalogName;
                        } else {
                            TempString = NULL;
                        }
                    } else {
                        goto clean0;
                    }

                    PolicyToUse = GetCodeSigningPolicyForInf(LogContext,
                                                             hDeviceInf,
                                                             &ValidationPlatform,
                                                             &UseOriginalInfName
                                                            );

                    //
                    // An exception INF can't be used in a device installation!
                    //
                    if(UseOriginalInfName) {
                        Err = ERROR_INVALID_CLASS;
                        goto clean0;
                    }

                    //
                    // We aren't supposed to be copying files here, hence we
                    // want to fail if the INF doesn't already exist in th