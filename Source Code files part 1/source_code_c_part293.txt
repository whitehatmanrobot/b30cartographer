T_LOOP;

    for (x = n; x--;)
    {
        QIStruct[x].pItf = NULL;
        QIStruct[x].pIID = (IID *) &iid;
    }


    START_CLOCK;
    hr = CoCreateInstanceEx(
        clsid,
        NULL,
        ctxt,
        pServerInfo,
        n,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    for (x = 0; x < n; x++)
    {
        if (FAILED(QIStruct[x].hr))
        {
            printf("CoCreateInstanceEx returned 0x%x for interface %d\n",
                QIStruct[x].hr, x);
            fReturn = FALSE;
        }
        else
            QIStruct[x].pItf->Release();
    }
    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CGCOLocalEXE()
{
    IClassFactory * pClassFactory;
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoGetClassObject(
        CLSID_ActLocal,
        CLSCTX_LOCAL_SERVER,
        NULL,
        IID_IClassFactory,
        (void **) &pClassFactory );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoGetClassObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    hr = pClassFactory->CreateInstance( NULL,
                                        IID_IUnknown,
                                        (void **) &pUnknown );

    pClassFactory->Release();

    if ( FAILED(hr) )
    {
        printf("CreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}

#ifndef NO_DCOM
BOOL CGCOExplicitActivator()
{
    COSERVERINFO   ServerInfo;
    IClassFactory * pClassFactory;
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = wszServerName;

    START_LOOP;

    START_CLOCK;
    hr = CoGetClassObject(
        CLSID_ActLocal,
        CLSCTX_REMOTE_SERVER,
        &ServerInfo,
        IID_IClassFactory,
        (void **) &pClassFactory );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoGetClassObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    hr = pClassFactory->CreateInstance( NULL,
                                        IID_IUnknown,
                                        (void **) &pUnknown );

    pClassFactory->Release();

    if ( FAILED(hr) )
    {
        printf("CreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return TRUE;
}
#endif // NO_DCOM

#ifdef NO_DCOM
BOOL CILocalDLL()
{
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
        CLSID_ActInproc,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IUnknown,
        (void **) &pUnknown );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return TRUE;
}

BOOL CILocalEXE()
{
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
        CLSID_ActLocal,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IUnknown,
        (void **) &pUnknown );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}
#else
BOOL CILocalDLL()
{
    return GenericCITest(CLSID_ActInproc, IID_IUnknown, NULL, 1, CLSCTX_INPROC_SERVER);
}

BOOL CILocalEXE()
{
    return GenericCITest(CLSID_ActLocal, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitActivator()
{
    return GenericCITest(CLSID_ActLocal, IID_IUnknown, wszServerName, 1, CLSCTX_REMOTE_SERVER);
}
#endif // NO_DCOM

#ifdef NO_DCOM
// Pre-DCOM version of CI3LocalEXE which calls CoCreateInstance
// once followed by 2 calls to QueryInterface
// instead of calling CoCreateInstanceEx.
BOOL CI3LocalEXE()
{
    IUnknown * pUnknown;
    IUnknwon * punkHeld = NULL;
    IPersist * pPersist;
    IPersistFile * pPersistFile;

    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
            CLSID_ActLocal,
            NULL,
            CLSCTX_LOCAL_SERVER,
            IID_IUnknown,
            (void **) &pUnknown );

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->QueryInterface( IID_IPersist, (void **)&pPersist );
    pUnknown->QueryInterface( IID_IPersist, (void **)&pPersistFile );
    STOP_CLOCK;

    pUnknown->Release();
    pPersist->Release();
    pPersistFile->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}
#else // NO_DCOM

BOOL CI3LocalEXE()
{
    return GenericCITest(CLSID_ActLocal, IID_IPersist, NULL, 3, CLSCTX_LOCAL_SERVER);
    /*
    MULTI_QI QIStruct[3];
    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[1].pIID = (IID *)&IID_IPersist;
    QIStruct[2].pIID = (IID *)&IID_IPersistFile;
    QIStruct[0].pItf = NULL;
    QIStruct[1].pItf = NULL;
    QIStruct[2].pItf = NULL;
    */
}

BOOL CI3ExplicitActivator()
{
    return GenericCITest(CLSID_ActLocal, IID_IPersist, wszServerName, 3, CLSCTX_REMOTE_SERVER);
    /*
    MULTI_QI QIStruct[3];
    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[1].pIID = (IID *)&IID_IPersist;
    QIStruct[2].pIID = (IID *)&IID_IPersistFile;
    QIStruct[0].pItf = NULL;
    QIStruct[1].pItf = NULL;
    QIStruct[2].pItf = NULL;
    */
}

BOOL CGIFFLocalEXE()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    STGM_READWRITE,
                    wszLocalFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFExplicitActivator()
{
    COSERVERINFO   ServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = wszServerName;

    MULTI_QI QIStruct[1];

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    &ServerInfo,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    wszRemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFRegistryActivator()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;
    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActRemote,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    wszRemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFAtStorageActivator()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;
    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActAtStorage,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    wszRemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}
#endif // NO_DCOM

BOOL IMBLocalEXE()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszLocalFileName, CLSID_ActLocal))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(wszLocalFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

#ifndef NO_DCOM
BOOL IMBLocalService()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszLocalFileName, CLSID_ActService))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(wszLocalFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;
    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }
    pUnk->Release();

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageActivator()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszRemoteFileName, CLSID_ActAtStorage))
        return FALSE;

    hr = CreateFileMoniker(wszRemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageService()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszRemoteFileName, CLSID_ActService))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(wszRemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStoragePreCon()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszRemoteFileName, CLSID_ActPreConfig))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(wszRemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageUser()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(wszRemoteFileName, CLSID_ActRunAsLoggedOn))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(wszRemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CIFromStgLocalEXE()
{
    IStorage *  pStorage;
    MULTI_QI    QIStruct[10];
    IUnknown * punkHeld = NULL;

    pStorage = 0;

    DeleteFile( StorageName );

    HRESULT HResult = StgCreateDocfile(
                wszStorageName,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStorage );

    if ( FAILED(HResult) )
    {
        printf("StgCreateDocfile returned 0x%x\n", HResult);
        return FALSE;
    }

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HResult = CoGetInstanceFromIStorage(
                    NULL,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_SERVER,
                    pStorage,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromIStorage returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();
    QIStruct[0].pItf = 0;

    STOP_LOOP;

    pStorage->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CIFromStgActivator()
{
    IStorage *  pStorage;
    MULTI_QI    QIStruct[10];
    COSERVERINFO   ServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = wszServerName;

    pStorage = 0;

    DeleteFile( StorageName );

    HRESULT HResult = StgCreateDocfile(
                wszStorageName,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStorage );

    if ( FAILED(HResult) )
    {
        printf("StgCreateDocfile returned 0x%x\n", HResult);
        return FALSE;
    }

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HResult = CoGetInstanceFromIStorage(
                    &ServerInfo,
                    &CLSID_ActRemote,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    pStorage,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromIStorage returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();
    QIStruct[0].pItf = 0;

    STOP_LOOP;

    pStorage->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CICustomLocalDLL()
{
    IGoober *   pGoober;
    MULTI_QI    QIStruct[10];
    HRESULT     hr;
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IGoober;

    START_CLOCK;
    hr = CoCreateInstanceEx(
                    CLSID_ActInproc,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    NULL,
                    1,
                    QIStruct );
    STOP_CLOCK;

    pGoober = (IGoober *)QIStruct[0].pItf;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    START_CLOCK;
    hr = pGoober->Ping();
    STOP_CLOCK;

    if ( hr != S_OK )
    {
        printf("IGoober::Ping returned %d\n", hr);
        pGoober->Release();
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    pGoober->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CICustomLocalEXE()
{
    IGoober *   pGoober;
    MULTI_QI    QIStruct[10];
    HRESULT hr;
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IGoober;

    START_CLOCK;
    hr = CoCreateInstanceEx(
                    CLSID_ActLocal,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    NULL,
                    1,
                    QIStruct );
    STOP_CLOCK;

    pGoober = (IGoober *)QIStruct[0].pItf;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    START_CLOCK;
    hr = pGoober->Ping();
    STOP_CLOCK;

    if ( hr != S_OK )
    {
        printf("IGoober::Ping returned %d\n", hr);
        pGoober->Release();
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    pGoober->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CILocalPreCon()
{
    return GenericCITest(CLSID_ActPreConfig, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitPreCon()
{
    return GenericCITest(CLSID_ActPreConfig, IID_IUnknown, wszServerName, 1, CLSCTX_REMOTE_SERVER);
}

BOOL CILocalUser()
{
    return GenericCITest(CLSID_ActRunAsLoggedOn, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitUser()
{
    return GenericCITest(CLSID_ActRunAsLoggedOn, IID_IUnknown, wszServerName, 1, CLSCTX_REMOTE_SERVER);
}

BOOL CILocalService()
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    MULTI_QI QIStruct[1];
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IUnknown;

    START_CLOCK;
    hr = CoCreateInstanceEx(
        CLSID_ActService,
        NULL,
        CLSCTX_LOCAL_SERVER,
        NULL,
        1,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    if (FAILED(QIStruct[0].hr))
    {
        printf("CoCreateInstanceEx returned 0x%x\n",
            QIStruct[0].hr);
        fReturn = FALSE;
    }
    else
        QIStruct[0].pItf->Release();

    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CIExplicitService()
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = wszServerName;
    pServerInfo = &ServerInfo;

    MULTI_QI QIStruct[1];
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IUnknown;

    START_CLOCK;
    hr = CoCreateInstanceEx(
        CLSID_ActService,
        NULL,
        CLSCTX_REMOTE_SERVER,
        pServerInfo,
        1,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    if (FAILED(QIStruct[0].hr))
    {
        printf("CoCreateInstanceEx returned 0x%x\n",
            QIStruct[0].hr);
        fReturn = FALSE;
    }
    else
        QIStruct[0].pItf->Release();

    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CILocalPreConACL();
BOOL CIExplicitPreConACL();

#endif // NO_DCOM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\dllsrv\dllgco.cxx ===
/*
 * DllGCO.cxx
 * - DllGetClassObject implementation for inproc DLL
 */


#include "server.hxx"
#include "factory.hxx"

HANDLE hStopServiceEvent;
BOOL fStartedAsService = FALSE;

long ObjectCount = 0;

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv)
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = NULL;

    MyFactory * pClass  = new FactoryInproc();

    hr = pClass->QueryInterface( riid, ppv );

    return hr;
}


STDAPI  DllCanUnloadNow(void)
{
return S_FALSE;
}

void ShutDown()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\common\clsid.c ===
/*
 * clsid.cxx
 *
 * IMPORTANT:  Please DO NOT change these CLSIDs.  If you need to add
 *             to this list, add new CLSIDs at the END of the list.
 *
 *             The BVTs depend on these CLSIDs being defined as they are.
 */
#ifdef UNICODE
#define _UNICODE 1
#endif

#include "windows.h"
#include "tchar.h"

//
// This is the CLSID for the custom interface proxy, just to be different.
//
CLSID CLSID_GooberProxy = { /* 00000000-0000-0000-0000-000000000001 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1}
  };

//
// This one gets registered as LocalServer32.
//
CLSID CLSID_ActLocal = { /* 00000000-0000-0000-0000-000000000002 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2}
  };

//
// This one gets registered as LocalServer32 and has a Remote key on the
// client side.
//
CLSID CLSID_ActRemote = { /* 00000000-0000-0000-0000-000000000003 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3}
  };

//
// This one gets registered as LocalServer32 and has an AtStorage key on the
// client side.
//
CLSID CLSID_ActAtStorage = { /* 00000000-0000-0000-0000-000000000004 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4}
  };

//
// This one gets registered as InprocServer32.
//
CLSID CLSID_ActInproc = { /* 00000000-0000-0000-0000-000000000005 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x5}
  };

//
// This one gets registered as InprocServer32.
// It has an AtStorage key on the client side.
// It is configured to run in Pre-Configured user mode on the server side.
//
CLSID CLSID_ActPreConfig = { /* 00000000-0000-0000-0000-000000000006 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x6}
  };

//
// Configured with RemoteServerName on client and as
// RunAs Logged On User on the server.
//
CLSID CLSID_ActRunAsLoggedOn = { /* 00000000-0000-0000-0000-000000000007 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7}
  };

//
// This one gets registered as an AtStorage service.
//
CLSID CLSID_ActService = { /* 00000000-0000-0000-0000-000000000008 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8}
  };

//
// This CLSID is registered only in the server's registry.  Tests default
// ActivateAtStorage on the client.
//
CLSID CLSID_ActServerOnly = { /* 00000000-0000-0000-0000-000000000009 */
    0x00000000,
    0x0000,
    0x0000,
    {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x9}
  };

typedef unsigned short wchar_t;

TCHAR * ClsidGoober32String = TEXT("{00000000-0000-0000-0000-000000000001}");
TCHAR * ClsidActLocalString = TEXT("{00000000-0000-0000-0000-000000000002}");
TCHAR * ClsidActRemoteString = TEXT("{00000000-0000-0000-0000-000000000003}");
TCHAR * ClsidActAtStorageString = TEXT("{00000000-0000-0000-0000-000000000004}");
TCHAR * ClsidActInprocString = TEXT("{00000000-0000-0000-0000-000000000005}");
TCHAR * ClsidActPreConfigString = TEXT("{00000000-0000-0000-0000-000000000006}");
TCHAR * ClsidActRunAsLoggedOnString = TEXT("{00000000-0000-0000-0000-000000000007}");
TCHAR * ClsidActServiceString = TEXT("{00000000-0000-0000-0000-000000000008}");
TCHAR * ClsidActServerOnlyString = TEXT("{00000000-0000-0000-0000-000000000009}");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\common\reg.c ===
//
// reg.c
//
// Common registry manipulation routines.
//

#ifdef UNICODE
#define _UNICODE 1
#endif

#include <windows.h>
#include <ole2.h>
#include "acttest.h"
#include "tchar.h"
#ifndef CHICO
#include <subauth.h>
#include <ntlsa.h>
#endif

void DeleteSubTree( TCHAR * pszClsid, TCHAR * SubTree )
{
    HKEY        hClsidRoot;
    HKEY        hClsid;
    long        RegStatus;
    TCHAR       szKeyName[256]; 
    DWORD       KeyNameSize;
    FILETIME    FileTime;
    int         SubKey;

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              SubTree,
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidRoot );

    if ( RegStatus != ERROR_SUCCESS )
        return;

    RegStatus = RegOpenKeyEx( hClsidRoot,
                              pszClsid,
                              0,
                              KEY_ALL_ACCESS,
                              &hClsid );

    if ( RegStatus != ERROR_SUCCESS )
        return;

    for ( SubKey = 0; ; SubKey++ )
    {
        KeyNameSize = sizeof(szKeyName);

        RegStatus = RegEnumKeyEx(
                        hClsid,
                        SubKey,
                        szKeyName,
                        &KeyNameSize,
                        0,
                        NULL,
                        NULL,
                        &FileTime );

        if ( RegStatus != ERROR_SUCCESS )
            break;

        RegStatus = RegDeleteKey( hClsid, szKeyName );
    }

    RegCloseKey( hClsid );
    RegDeleteKey( hClsidRoot, pszClsid );
    RegCloseKey( hClsidRoot );
}


void DeleteClsidKey( TCHAR * pwszClsid )
{

    // Note that we also delete the corresponding AppID entries

    DeleteSubTree( pwszClsid, TEXT("CLSID"));
    DeleteSubTree( pwszClsid, TEXT("AppID"));
}

long SetAppIDSecurity( TCHAR * pszAppID )
{
    HKEY        hActKey;
    HKEY        hAppIDKey;
    BYTE        SecurityDescriptor[2000];
    LONG        RegStatus;
    SECURITY_INFORMATION        SI;
    DWORD       dwSize = sizeof( SecurityDescriptor );
    DWORD       Disposition;

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("AppID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hAppIDKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    pszAppID,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;
#ifndef CHICO
    RegStatus  = RegGetKeySecurity( hActKey, 
                                    OWNER_SECURITY_INFORMATION 
                                        | GROUP_SECURITY_INFORMATION 
                                        | DACL_SECURITY_INFORMATION,
                                    &SecurityDescriptor,
                                    &dwSize );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;
#endif
    RegStatus  = RegSetValueEx(
                    hActKey,
                    TEXT("LaunchPermission"),
                    0,
                    REG_BINARY,
                    SecurityDescriptor,
                    dwSize );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hActKey,
                    TEXT("AccessPermission"),
                    0,
                    REG_BINARY,
                    SecurityDescriptor,
                    dwSize );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegCloseKey(hActKey);

    // make the key for the exe
    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    TEXT("ActSrv.Exe"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hActKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (BYTE*) pszAppID,
                    (_tcslen(pszAppID) + 1) * sizeof(TCHAR) );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegCloseKey(hActKey);
    RegCloseKey(hAppIDKey);

    return ERROR_SUCCESS;
}



int SetAccountRights(const TCHAR *szUser, TCHAR *szPrivilege)
{
#ifndef CHICO
    int                   err;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES objAtt;
    DWORD                 cbSid = 1;
    TCHAR                 szDomain[128];
    DWORD                 cbDomain = 128;
    PSID                  pSid = NULL;
    SID_NAME_USE          snu;
    LSA_UNICODE_STRING    privStr;

    // Get a policy handle
    memset(&objAtt, 0, sizeof(LSA_OBJECT_ATTRIBUTES));
    if (!NT_SUCCESS(LsaOpenPolicy(NULL,
                                  &objAtt,
                                  POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                                  &hPolicy)))
    {
        return GetLastError();
    }

    // Fetch the SID for the specified user
    LookupAccountName(NULL, szUser, pSid, &cbSid, szDomain, &cbDomain, &snu);
    if ((err = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
    {
        return err;
    }
    pSid = (PSID*) malloc(cbSid);
    if (pSid == NULL)
    {
        return ERROR_OUTOFMEMORY;
    }
    if (!LookupAccountName(NULL, szUser, pSid, &cbSid,
                          szDomain, &cbDomain, &snu))
    {
        return GetLastError();
    }

    // Set the specified privilege on this account
    privStr.Length = _tcslen(szPrivilege) * sizeof(WCHAR);
    privStr.MaximumLength = privStr.Length + sizeof(WCHAR);
    privStr.Buffer = szPrivilege;
    if (!NT_SUCCESS(LsaAddAccountRights(hPolicy, pSid, &privStr, 1)))
    {
        return GetLastError();
    }

    // We're done
    free( pSid );
    LsaClose(hPolicy);
#endif
    return ERROR_SUCCESS;
}

int AddBatchPrivilege(const TCHAR *szUser)
{
#ifndef CHICO
    return !SetAccountRights( szUser, SE_BATCH_LOGON_NAME );
#else
    return(TRUE);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\srvcore\classes.cxx ===
/*
 *  classes.cxx
 */

#include "server.hxx"
#include "classes.hxx"

//
// MyObject implementation.
//

MyObject::MyObject( int ActType ) :
    Refs(0),
    ActivationType(ActType),
    PersistFileObj(this),
    PersistStorageObj(this),
    GooberObj(this)
{
}

MyObject::~MyObject()
{
}

//
// MyObject IUnknown.
//

HRESULT STDMETHODCALLTYPE
MyObject::QueryInterface (
    REFIID  iid,
    void ** ppv )
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = 0;

    if ( memcmp(&iid, &IID_IUnknown, sizeof(IID)) == 0 )
        *ppv = this;
    else if ( (memcmp(&iid, &IID_IPersist, sizeof(IID)) == 0) ||
              (memcmp(&iid, &IID_IPersistFile, sizeof(IID)) == 0) )
        *ppv = &PersistFileObj;
    else if ( memcmp(&iid, &IID_IPersistStorage, sizeof(IID)) == 0 )
        *ppv = &PersistStorageObj;
    else if ( memcmp(&iid, &IID_IGoober, sizeof(IID)) == 0 )
        *ppv = &GooberObj;
    else
        return E_NOINTERFACE;

    ((IUnknown *)(*ppv))->AddRef();
    return S_OK;
}

ULONG STDMETHODCALLTYPE
MyObject::AddRef()
{
    Refs++;
    return Refs;
}

ULONG STDMETHODCALLTYPE
MyObject::Release()
{
    unsigned long   Count;

    Count = --Refs;

    if ( Count == 0 )
    {
	    delete this;

	    // Decrement the object count.
        if ( --ObjectCount == 0 )
            ShutDown();
    }

    return Count;
}

//
// PersistFile implementation.
//

PersistFile::PersistFile( MyObject * pObj ) :
    pObject(pObj)
{
}

//
// PersistFile IUnknown.
//
IUnknownMETHODS( PersistFile )

//
// PersistFile IPersist.
//

HRESULT STDMETHODCALLTYPE
PersistFile::GetClassID(
    CLSID * pClassID )
{
    if ( pObject->GetActivationType() == LOCAL )
        memcpy( pClassID, &CLSID_ActLocal, sizeof(IID) );
    else if ( pObject->GetActivationType() == REMOTE )
        memcpy( pClassID, &CLSID_ActRemote, sizeof(IID) );
    else if (pObject->GetActivationType() == ATBITS )
        memcpy( pClassID, &CLSID_ActAtStorage, sizeof(IID) );
    else if (pObject->GetActivationType() == INPROC )
        memcpy( pClassID, &CLSID_ActInproc, sizeof(IID) );
    return S_OK;
}

//
// PersistFile IPersistFile
//

HRESULT STDMETHODCALLTYPE
PersistFile::IsDirty()
{
    return S_FALSE;
}

HRESULT STDMETHODCALLTYPE
PersistFile::Load(
    LPCOLESTR   pszFileName,
    DWORD       dwMode )
{
    /** Doesn't work until we have security stuff...

    HANDLE  hFile;

    //
    // Verify that we can open the file.
    //

    hFile = CreateFile(
                pszFileName,
                dwMode,
                0,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL );

    if ( hFile == INVALID_HANDLE_VALUE )
        return HRESULT_FROM_WIN32( GetLastError() );

    CloseHandle( hFile );

    **/

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistFile::Save(
    LPCOLESTR   pszFileName,
    BOOL        fRemember )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistFile::SaveCompleted(
    LPCOLESTR   pszFileName )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistFile::GetCurFile(
    LPOLESTR *  ppszFileName )
{
    *ppszFileName = 0;
    return S_OK;
}

//
// PersistStorage implementation.
//

PersistStorage::PersistStorage( MyObject * pObj ) :
    pObject(pObj)
{
}

//
// PersistStorage IUnknown.
//
IUnknownMETHODS( PersistStorage )

//
// PersistStorage IPersist.
//

HRESULT STDMETHODCALLTYPE
PersistStorage::GetClassID(
    CLSID * pClassID )
{
    if ( pObject->GetActivationType() == LOCAL )
        memcpy( pClassID, &CLSID_ActLocal, sizeof(IID) );
    else if ( pObject->GetActivationType() == REMOTE )
        memcpy( pClassID, &CLSID_ActRemote, sizeof(IID) );
    else if (pObject->GetActivationType() == ATBITS )
        memcpy( pClassID, &CLSID_ActAtStorage, sizeof(IID) );
    else if (pObject->GetActivationType() == INPROC )
        memcpy( pClassID, &CLSID_ActInproc, sizeof(IID) );
    return S_OK;
}

//
// PersistStorage IPersistStorage
//

HRESULT STDMETHODCALLTYPE
PersistStorage::IsDirty()
{
    return S_FALSE;
}

HRESULT STDMETHODCALLTYPE
PersistStorage::InitNew(
    IStorage *  pStg )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistStorage::Load(
    IStorage *  pStg )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistStorage::Save(
    IStorage *  pStgSave,
    BOOL        fSameAsLoad )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistStorage::SaveCompleted(
    IStorage *  pStgNew )
{
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
PersistStorage::HandsOffStorage()
{
    return S_OK;
}

//
// Goober implementation
//
Goober::Goober( MyObject * pObj ) :
    pObject(pObj)
{
}

//
// Goober IUnknown.
//
IUnknownMETHODS( Goober )

//
// Goober IGoober.
//
HRESULT STDMETHODCALLTYPE
Goober::Ping()
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\server\server.cxx ===
/*
 * server.cxx
 */

#ifdef UNICODE
#define _UNICODE 1
#endif

#include "server.hxx"
#include "factory.hxx"
#include "tchar.h"

long ObjectCount = 0;

TCHAR * AtStorageFileName = TEXT("c:\\tmp\\atbits.dat");

#ifdef USERPCPERFDOMAIN
TCHAR * UserName = TEXT("rpcperf\\oleuser");
#else
TCHAR * UserName = TEXT("redmond\\oleuser");
#endif
TCHAR * Password = TEXT("TwoFor1");
TCHAR * ServiceName = TEXT("ActTestService");
TCHAR * ServiceDisplayName = TEXT("ActTestService");
BOOL fStartedAsService = FALSE;
HANDLE hStopServiceEvent;
#ifdef FREETHREADED
HANDLE hFreeThreadEvent;
#endif
SERVICE_STATUS SStatus;
SERVICE_STATUS_HANDLE hService;
BOOL InstallService(TCHAR * );

HKEY    ghClsidRootKey = 0;
HKEY    ghAppIDRootKey = 0;

DWORD       RegHandleLocal;
DWORD       RegHandleRemote;
DWORD       RegHandleAtStorage;
DWORD       RegHandlePreConfig;
DWORD       RegHandleRunAsLoggedOn;
DWORD       RegHandleService;
DWORD       RegHandleServerOnly;
unsigned    uClassIndex = 0;

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   main entry point for SCM
//
//  History:    1-18-96   stevebl   Created
//
//----------------------------------------------------------------------------
void _cdecl RealMain( int argc, char ** argv )
{
    HRESULT     hr;
    MSG         msg;

    if ( (argc > 1) &&
         ((strcmp(argv[1],"-?") == 0) || (strcmp(argv[1],"/?") == 0)) )
        PrintUsageAndExit();

    if ( (argc > 1) && (strcmp(argv[1],"-r") == 0) )
    {
        DebuggerType    eDebug = same_debugger;
        int             n;

        n = 2;

        if ( n < argc )
        {
            if (strcmp(argv[n],"-d") == 0)
                eDebug = windbg_debugger;
            else if (strcmp(argv[n],"-n") == 0 )
                eDebug = ntsd_debugger;
            else if (strcmp(argv[n],"-x") == 0 )
                eDebug = clear_debugger;
        }

        if ( hr = InitializeRegistry( eDebug ) )
            printf("InitializeRegistry failed with %08x\n", hr);
        else
            printf("Registry updated successfully.\n");

        return;
    }

    // Started manually.  Don't go away.
    if ( (argc == 1) && ! fStartedAsService )
        ObjectCount = 1;

    if ( ! fStartedAsService )
    {
        if ( (argc >= 3 && strcmp(argv[2], "-Embedding") == 0) )
            uClassIndex = argv[1][0] - '0';
        else
            uClassIndex = 0;
    }

    if ( fStartedAsService )
    {
        uClassIndex = 8;

#ifdef NT351
        hr = E_FAIL;
#else
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#endif
    }
    else
    {
#ifdef FREETHREADED
        hFreeThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        hr = CoInitializeEx(NULL,COINIT_MULTITHREADED);
#else
        hr = CoInitialize(NULL);
#endif
    }

    if ( FAILED(hr) )
    {
        printf( "Server: CoInitialize failed(%x)\n", hr );
        return;
    }

    if (0 == uClassIndex || 2 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActLocal,
    				(IUnknown *)new FactoryLocal(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleLocal );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            CoUninitialize();
            return;
        }
    }

    if (0 == uClassIndex || 3 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActRemote,
    				(IUnknown *)new FactoryRemote(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleRemote );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            if (0 == uClassIndex)
            {
                CoRevokeClassObject( RegHandleLocal );
            }
            CoUninitialize();
            return;
        }
    }

    if (0 == uClassIndex || 4 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActAtStorage,
    				(IUnknown *)new FactoryAtStorage(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleAtStorage );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            if (0 == uClassIndex)
            {
                CoRevokeClassObject( RegHandleLocal );
                CoRevokeClassObject( RegHandleRemote );
            }
            CoUninitialize();
            return;
        }
    }

    if (0 == uClassIndex || 6 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActPreConfig,
    				(IUnknown *)new FactoryAtStorage(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandlePreConfig );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            if (0 == uClassIndex)
            {
                CoRevokeClassObject( RegHandleLocal );
                CoRevokeClassObject( RegHandleRemote );
                CoRevokeClassObject( RegHandleAtStorage );
            }
            CoUninitialize();
            return;
        }
    }

    if (0 == uClassIndex || 7 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActRunAsLoggedOn,
    				(IUnknown *)new FactoryAtStorage(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleRunAsLoggedOn );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            if (0 == uClassIndex)
            {
                CoRevokeClassObject( RegHandleLocal );
                CoRevokeClassObject( RegHandleRemote );
                CoRevokeClassObject( RegHandleAtStorage );
                CoRevokeClassObject( RegHandlePreConfig );
            }
            CoUninitialize();
            return;
        }
    }

    if (0 == uClassIndex || 9 == uClassIndex)
    {
        hr = CoRegisterClassObject( CLSID_ActServerOnly,
    				(IUnknown *)new FactoryAtStorage(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleServerOnly );

        if ( FAILED(hr) )
        {
            printf("Server: CoRegisterClassObject failed %x\n", hr);
            if (0 == uClassIndex)
            {
                CoRevokeClassObject( RegHandleLocal );
                CoRevokeClassObject( RegHandleRemote );
                CoRevokeClassObject( RegHandleAtStorage );
                CoRevokeClassObject( RegHandlePreConfig );
                CoRevokeClassObject( RegHandleRunAsLoggedOn );
            }
            CoUninitialize();
            return;
        }
    }

    if (fStartedAsService)
    {
        hr = CoRegisterClassObject( CLSID_ActService,
    				(IUnknown *)new FactoryAtStorage(),
    				CLSCTX_LOCAL_SERVER,
    				REGCLS_MULTIPLEUSE,
    				&RegHandleService );

        if ( FAILED(hr) )
        {
            CoUninitialize();
            return;
        }

        WaitForSingleObject(hStopServiceEvent, INFINITE);
    }
    else
    {
#ifdef FREETHREADED
        WaitForSingleObject(hFreeThreadEvent, INFINITE);
        //
        // Make sure the thread who signaled the event executes for a while
        // before we exit.
        //
        Sleep(100);
#else
        // Only do message loop if apartment threaded non-service.
        while (GetMessage(&msg, NULL, 0, 0))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
#endif
    }

    CoUninitialize();

    return;
}

int gargc;
char * gargv[100];

BOOL UpdateStatus(DWORD dwState)
{
    if (SERVICE_RUNNING == SStatus.dwCurrentState  &&
        SERVICE_START_PENDING == dwState)
    {
        return(TRUE);
    }

    SStatus.dwCurrentState = dwState;
    if (SERVICE_START_PENDING == dwState ||
        SERVICE_STOP_PENDING == dwState)
    {
        SStatus.dwCheckPoint++;
        SStatus.dwWaitHint = 1;
    }
    else
    {
        SStatus.dwCheckPoint = 0;
        SStatus.dwWaitHint = 0;
    }

    return(SetServiceStatus(hService, &SStatus));
}

DWORD StartMyMain(void * pArg)
{
    // reconstruct the command line args and call the real main
    RealMain(gargc, gargv);
    UpdateStatus(SERVICE_STOPPED);
    return(0);
}

void Handler(DWORD fdwControl)
{
    switch (fdwControl)
    {
    case SERVICE_CONTROL_STOP:
        UpdateStatus(SERVICE_STOP_PENDING);
        SetEvent(hStopServiceEvent);
        break;
    case SERVICE_CONTROL_INTERROGATE:
        UpdateStatus(SERVICE_RUNNING);
        break;
    default:
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ServiceMain
//
//  Synopsis:   main entry point for service
//
//  History:    1-18-96   stevebl   Created
//
//----------------------------------------------------------------------------

void ServiceMain(DWORD argc, LPTSTR * argv)
{
    fStartedAsService = TRUE;

    // register the service handler
    hService = RegisterServiceCtrlHandler(ServiceName, Handler);

    if (!hService)
        return;

    SStatus.dwServiceType               = SERVICE_WIN32_OWN_PROCESS |
                                          SERVICE_INTERACTIVE_PROCESS,
    SStatus.dwControlsAccepted          = SERVICE_CONTROL_STOP |
                                          SERVICE_CONTROL_INTERROGATE;
    SStatus.dwWin32ExitCode             = NO_ERROR;
    SStatus.dwServiceSpecificExitCode   = 0;
    SStatus.dwCheckPoint                = 0;
    SStatus.dwWaitHint                  = 0;

    if (!UpdateStatus(SERVICE_START_PENDING))
        return;

    // create an event to signal when the service is to stop
    hStopServiceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!hStopServiceEvent)
    {
        return;
    }

    UpdateStatus(SERVICE_RUNNING);

    StartMyMain( NULL );
}

void _cdecl main( int argc, char ** argv)
{
    if (argc > 1 && strcmp(argv[1], "8") == 0)
    {
        gargc = argc;

        // save the command line arguments
        gargc = (int) argc;
        if (gargc > 100)
        {
            gargc = 100;
        }
        for (int k = 1; k <= gargc; k++)
        {
            gargv[k-1] = (char *) malloc(strlen(argv[k-1]) + 1);
            strcpy(gargv[k-1], argv[k-1]);
        }

        // Start as a service
        SERVICE_TABLE_ENTRY ServiceStart[2];
        ServiceStart[0].lpServiceName = ServiceName;
        ServiceStart[0].lpServiceProc = ServiceMain;
        ServiceStart[1].lpServiceName = NULL;
        ServiceStart[1].lpServiceProc = NULL;

        if (!StartServiceCtrlDispatcher (ServiceStart))
        {
            ExitProcess(GetLastError());
        }
        ExitProcess(0);
    }
    else
    {
        // start as a regular app
        RealMain(argc, argv);
    }
}


long InitializeRegistry( DebuggerType eDebugServer )
{
    long    RegStatus;
    ulong   Disposition;
    HKEY    hActKey;
    HKEY    hDebugKey;
    HANDLE  hFile;
    TCHAR   Path[256];
    TCHAR * pwszServerExe;
    TCHAR * pwszDebuggerName;
    DWORD   DebugFlags;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return ERROR_BAD_PATHNAME;

    hFile = CreateFile( AtStorageFileName,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        0,
                        0 );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        printf("Couldn't create file %ws\n", AtStorageFileName );
        return GetLastError();
    }

    CloseHandle( hFile );

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &ghClsidRootKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("APPID"),
                              0,
                              KEY_ALL_ACCESS,
                              &ghAppIDRootKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    DeleteClsidKey( ClsidGoober32String );
    DeleteClsidKey( ClsidActLocalString );
    DeleteClsidKey( ClsidActRemoteString );
    DeleteClsidKey( ClsidActAtStorageString );
    DeleteClsidKey( ClsidActInprocString );
    DeleteClsidKey( ClsidActPreConfigString );
    DeleteClsidKey( ClsidActRunAsLoggedOnString );
    DeleteClsidKey( ClsidActServiceString );
    DeleteClsidKey( ClsidActServerOnlyString );

    //
    // Local CLSID entries.
    //

    _tcscat(Path, TEXT(" 2"));

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActLocalString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActLocalString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Remote CLSID entries.
    //

    Path[_tcslen(Path)-1] = TEXT('3');

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActRemoteString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRemoteString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // AtStorage CLSID entries.
    //

    Path[_tcslen(Path)-1] = TEXT('4');

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActAtStorageString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActAtStorageString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // RunAs CLSID entries.'
    //

    Path[_tcslen(Path)-1] = TEXT('6');

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActPreConfigString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDRegKeyAndNamedValue(
                    ClsidActPreConfigString,
                    TEXT("RunAs"),
                    UserName,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;


    RegStatus = SetAppIDSecurity( ClsidActPreConfigString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if (!SetPassword(ClsidActPreConfigString, Password))
        return(FALSE);

    if (!AddBatchPrivilege( UserName ) )
        return(FALSE);

    //
    // RunAs logged on user CLSID entries.
    //

    Path[_tcslen(Path)-1] = TEXT('7');

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActRunAsLoggedOnString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDRegKeyAndNamedValue(
                    ClsidActRunAsLoggedOnString,
                    TEXT("RunAs"),
                    TEXT("Interactive User"),
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRunAsLoggedOnString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Service CLSID entries.
    //

    RegStatus = SetAppIDRegKeyAndNamedValue(
                    ClsidActServiceString,
                    TEXT("LocalService"),
                    ServiceName,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActServiceString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // Get the services key
    HKEY hServices;
    RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\CurrentControlSet\\Services"),
                              0,
                              KEY_READ | KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                              &hServices );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    Path[_tcslen(Path)-1] = TEXT('8');


    if (!InstallService(Path))
        return TRUE;

    //
    // Server only CLSID entry.
    //

    Path[_tcslen(Path)-1] = TEXT('9');

    RegStatus = SetClsidRegKeyAndStringValue(
                    ClsidActServerOnlyString,
                    TEXT("LocalServer32"),
                    Path,
                    NULL,
                    NULL );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActServerOnlyString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;


    //
    // Add entries to launch server in debugger.
    //

    if ( eDebugServer == same_debugger )
        return ERROR_SUCCESS;

    Path[_tcslen(Path)-2] = 0;
    pwszServerExe = Path + _tcslen(Path);
    while ( (pwszServerExe > Path) && (pwszServerExe[-1] != TEXT('\\')) )
        pwszServerExe--;

    RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),
                    0,
                    KEY_ALL_ACCESS,
                    &hDebugKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hDebugKey,
                    TEXT("Image File Execution Options"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hDebugKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( eDebugServer == clear_debugger )
    {
        RegDeleteKey( hDebugKey, pwszServerExe );
        return ERROR_SUCCESS;
    }

    RegStatus  = RegCreateKeyEx(
                    hDebugKey,
                    pwszServerExe,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hDebugKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( eDebugServer == ntsd_debugger )
    {
        pwszDebuggerName = TEXT("ntsd.exe -d");
    }
    else
    {
        pwszDebuggerName = TEXT("windbg.exe");
    }

    DebugFlags = 0x10f0;

    RegStatus =  RegSetValueEx(
                    hDebugKey,
                    TEXT("Debugger"),
                    0,
                    REG_SZ,
                    (const BYTE *)pwszDebuggerName,
                    (_tcslen(pwszDebuggerName) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hDebugKey,
                    TEXT("GlobalFlag"),
                    0,
                    REG_DWORD,
                    (const BYTE *)&DebugFlags,
                    sizeof(DWORD) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

long SetClsidRegKeyAndStringValue(
    TCHAR * pwszClsid,
    TCHAR * pwszKey,
    TCHAR * pwszValue,
    HKEY *  phClsidKey,
    HKEY *  phNewKey )
{
    long    RegStatus;
    DWORD   Disposition;
    HKEY    hClsidKey;

    if ( phClsidKey )
        *phClsidKey = 0;

    if ( phNewKey )
        *phNewKey = 0;

    RegStatus  = RegCreateKeyEx(
                    ghClsidRootKey,
                    pwszClsid,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( phClsidKey )
        *phClsidKey = hClsidKey;

    return SetRegKeyAndStringValue(
                hClsidKey,
                pwszKey,
                pwszValue,
                phNewKey );
}

long SetAppIDRegKeyAndNamedValue(
    TCHAR * pwszAppID,
    TCHAR * pwszKey,
    TCHAR * pwszValue,
    HKEY *  phClsidKey )
{
    long    RegStatus;
    DWORD   Disposition;
    HKEY    hClsidKey;

    if ( phClsidKey )
        *phClsidKey = 0;

    // first, make sure the clsid has appid={appid}
    RegStatus  = RegCreateKeyEx(
                    ghClsidRootKey,
                    pwszAppID,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  SetNamedStringValue(
                hClsidKey,
                TEXT("AppID"),
                pwszAppID );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    ghAppIDRootKey,
                    pwszAppID,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( phClsidKey )
        *phClsidKey = hClsidKey;

    return SetNamedStringValue(
                hClsidKey,
                pwszKey,
                pwszValue );
}

long SetNamedStringValue(
    HKEY    hKey,
    TCHAR * pwszKey,
    TCHAR * pwszValue )
{
    long    RegStatus;
    DWORD   Disposition;

    RegStatus =  RegSetValueEx(
                    hKey,
                    pwszKey,
                    0,
                    REG_SZ,
                    (const BYTE *)pwszValue,
                    (_tcslen(pwszValue) + 1) * sizeof(TCHAR) );

    return RegStatus;
}

long SetRegKeyAndStringValue(
    HKEY    hKey,
    TCHAR * pwszKey,
    TCHAR * pwszValue,
    HKEY *  phNewKey )
{
    long    RegStatus;
    DWORD   Disposition;
    HKEY    hNewKey;

    if ( phNewKey )
        *phNewKey = 0;

    RegStatus  = RegCreateKeyEx(
                    hKey,
                    pwszKey,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hNewKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hNewKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)pwszValue,
                    (_tcslen(pwszValue) + 1) * sizeof(TCHAR) );

    if ( phNewKey )
        *phNewKey = hNewKey;

    return RegStatus;
}

BOOL InstallService(TCHAR * Path)
{
#ifndef CHICO
    SC_HANDLE hManager = OpenSCManager(
                                NULL,
                                NULL,
                                SC_MANAGER_ALL_ACCESS);
    if (NULL == hManager)
    {
        printf("OpenSCManager returned %d\n",GetLastError());
        return(FALSE);
    }

    SC_HANDLE hService = OpenService(
                                hManager,
                                ServiceName,
                                SERVICE_ALL_ACCESS);

    if (NULL != hService)
    {
        if (!ChangeServiceConfig(
                            hService,
                            SERVICE_WIN32_OWN_PROCESS |
                                SERVICE_INTERACTIVE_PROCESS,
                            SERVICE_DEMAND_START,
                            SERVICE_ERROR_NORMAL,
                            Path,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            ServiceDisplayName
                                )
            )
        {
            printf("ChangeService returned %d\n",GetLastError());
            CloseServiceHandle(hService);
            CloseServiceHandle(hManager);
            return(FALSE);
        }
        return(TRUE);
    }

    hService = CreateService(
                    hManager,
                    ServiceName,
                    ServiceDisplayName,
                    SERVICE_ALL_ACCESS,
                    SERVICE_WIN32_OWN_PROCESS |
                        SERVICE_INTERACTIVE_PROCESS,
                    SERVICE_DEMAND_START,
                    SERVICE_ERROR_NORMAL,
                    Path,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
    if (NULL == hService)
    {
        printf("CreateService returned %d\n",GetLastError());
        CloseServiceHandle(hManager);
        return(FALSE);
    }

    CloseServiceHandle(hService);
    CloseServiceHandle(hManager);
#endif
    return(TRUE);
}

void PrintUsageAndExit()
{
    printf("Usage : actsrv [-r [-d | -n | -x]]\n");
    printf("\t-r : Make necessary registry changes.\n");
    printf("\t-d : Register server to start in windbg.\n");
    printf("\t-n : Register server to start with ntsd -d.\n");
    printf("\t-x : Register server and clear debugger.\n");

    ExitProcess(0);
}

void ShutDown()
{
    // The last object has been destroyed.
    if (fStartedAsService)
    {
        CoRevokeClassObject( RegHandleService );
    }

    switch( uClassIndex )
    {
    case 0 :
        CoRevokeClassObject( RegHandleLocal );
        CoRevokeClassObject( RegHandleRemote );
        CoRevokeClassObject( RegHandleAtStorage );
        CoRevokeClassObject( RegHandlePreConfig );
        CoRevokeClassObject( RegHandleRunAsLoggedOn );
        CoRevokeClassObject( RegHandleServerOnly );
        break;
    case 2:
        CoRevokeClassObject( RegHandleLocal );
        break;
    case 3:
        CoRevokeClassObject( RegHandleRemote );
        break;
    case 4:
        CoRevokeClassObject( RegHandleAtStorage );
        break;
    case 6:
        CoRevokeClassObject( RegHandlePreConfig );
        break;
    case 7 :
        CoRevokeClassObject( RegHandleRunAsLoggedOn );
        break;
    case 9 :
        CoRevokeClassObject( RegHandleServerOnly );
        break;
    }

    if (fStartedAsService)
    {
        SetEvent(hStopServiceEvent);
    }
    else
    {
#ifdef FREETHREADED 
        SetEvent(hFreeThreadEvent);
#else
        PostQuitMessage(0);
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\client\reg.cxx ===
//
// reg.cxx
//

#include "client.hxx"

BOOL SetPassword(TCHAR * szCID, TCHAR * szPw);

TCHAR * ServiceName = TEXT("ActTestService");
TCHAR * ServiceDisplayName = TEXT("ActTestService");
#ifdef USERPCPERFDOMAIN
TCHAR * UserName = TEXT("rpcperf\\oleuser");
#else
TCHAR * UserName = TEXT("redmond\\oleuser");
#endif
TCHAR * Password = TEXT("TwoFor1");

long InitializeRegistryForLocal()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    TCHAR       Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActLocalString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    TEXT("LocalServer32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("actsrv.exe 2") );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (_tcslen(Path) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActLocalString,
                    (_tcslen(ClsidActLocalString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActLocalString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

long InitializeRegistryForInproc()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    TCHAR       Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActInprocString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    TEXT("InprocServer32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("actsrvd.dll") );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (_tcslen(Path) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT("ThreadingModel"),
                    0,
                    REG_SZ,
                    (const BYTE *)TEXT("Both"),
                    (_tcslen(TEXT("Both")) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

TCHAR * StringIidIGoober = TEXT("{ffffffff-0000-0000-0000-000000000000}");

long InitializeRegistryForCustom()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    TCHAR       Path[256];

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("Interface"),
                              0,
                              KEY_ALL_ACCESS,
                              &hInterface );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hInterface,
                    StringIidIGoober,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hInterface,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hInterface,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)TEXT("IGoober"),
                    (_tcslen(TEXT("IGoober")) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hInterface,
                    TEXT("ProxyStubClsid32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hInterface,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hInterface,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)ClsidGoober32String,
                    (_tcslen(ClsidGoober32String) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidGoober32String,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    TEXT("InProcServer32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("goober.dll") );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (_tcslen(Path) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

long InitializeRegistryForRemote()
{
    long    RegStatus;
    ulong   Disposition;
    HKEY    hClsidKey;
    HKEY    hAppIDKey;
    HKEY    hThisClsidKey;
    HKEY    hActKey;
    HKEY    hActValueKey;
    TCHAR   Path[256];

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActRemote
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActRemoteString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hThisClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActRemoteString,
                    (_tcslen(ClsidActRemoteString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRemoteString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    HKEY_CLASSES_ROOT,
                    TEXT("AppID"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hAppIDKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActRemoteString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( *ServerName )
       RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("RemoteServerName"),
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (_tcslen(ServerName) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActAtStorage
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActAtStorageString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hThisClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActAtStorageString,
                    (_tcslen(ClsidActAtStorageString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActAtStorageString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActAtStorageString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("ActivateAtStorage"),
                    0,
                    REG_SZ,
                    (const BYTE *)TEXT("Y"),
                    (_tcslen(TEXT("Y")) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActRunAsLoggedOnUser
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActRunAsLoggedOnString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRunAsLoggedOnString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hThisClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActRunAsLoggedOnString,
                    (_tcslen(ClsidActRunAsLoggedOnString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActRunAsLoggedOnString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( *ServerName )
       RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("RemoteServerName"),
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (_tcslen(ServerName) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hThisClsidKey,
                    TEXT("LocalServer32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("actsrv.exe 7") );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (_tcslen(Path) + 1) * sizeof(TCHAR) );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("RunAs"),
                    0,
                    REG_SZ,
                    (const BYTE *)TEXT("Interactive User"),
                    (_tcslen(TEXT("Interactive User")) + 1) * sizeof(TCHAR) );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // RunAs CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActPreConfigString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hThisClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActPreConfigString,
                    (_tcslen(ClsidActPreConfigString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActPreConfigString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActPreConfigString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( *ServerName )
       RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("RemoteServerName"),
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (_tcslen(ServerName) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hThisClsidKey,
                    TEXT("LocalServer32"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("actsrv.exe 6") );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    TEXT(""),
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (_tcslen(Path) + 1) * sizeof(TCHAR) );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("RunAs"),
                    0,
                    REG_SZ,
                    (const BYTE *)UserName,
                    (_tcslen(UserName) + 1) * sizeof(TCHAR) );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if (!SetPassword(ClsidActPreConfigString, Password))
        return(FALSE);

    if (AddBatchPrivilege( UserName ) )
        return(FALSE);

    return ERROR_SUCCESS;
}

long InitializeRegistryForService()
{
    long    RegStatus;
    ulong   Disposition;
    HKEY    hClsidKey;
    HKEY    hAppIDKey;
    HKEY    hThisClsidKey;
    HKEY    hActKey;
    HKEY    hActValueKey;
    HKEY    hServices;
    TCHAR   Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              TEXT("CLSID"),
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    HKEY_CLASSES_ROOT,
                    TEXT("AppID"),
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hAppIDKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
		    hClsidKey,
                    ClsidActServiceString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActServiceString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx(
                    hThisClsidKey,
                    TEXT("AppID"),
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActServiceString,
                    (_tcslen(ClsidActServiceString)+1)*sizeof(TCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActServiceString,
                    0,
                    TEXT("REG_SZ"),
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _tcslwr( Path );
    _tcscpy( _tcsstr( Path, TEXT("actclt") ), TEXT("actsrv.exe 8") );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("LocalService"),
                    0,
                    REG_SZ,
                    (const BYTE *)ServiceName,
                    (_tcslen(ServiceName) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    TEXT("ActivateAtStorage"),
                    0,
                    REG_SZ,
                    (const BYTE *)TEXT("Y"),
                    (_tcslen(TEXT("Y")) + 1) * sizeof(TCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              TEXT("SYSTEM\\CurrentControlSet\\Services"),
                              0,
                              KEY_READ,
                              &hServices );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return InstallService(Path);
}

DWORD InstallService( TCHAR * Path )
{
#ifndef CHICO
    SC_HANDLE hManager;
    SC_HANDLE hService;

    hManager = OpenSCManager( NULL,
                              NULL,
                              SC_MANAGER_ALL_ACCESS );

    if ( ! hManager )
    {
        printf( "OpenSCManager returned %d\n", GetLastError() );
        return GetLastError();
    }

    hService = OpenService( hManager,
                            ServiceName,
                            SERVICE_ALL_ACCESS );

    if ( ! hService )
    {
        hService = CreateService(
                        hManager,
                        ServiceName,
                        ServiceDisplayName,
                        SERVICE_ALL_ACCESS,
                        SERVICE_WIN32_OWN_PROCESS,
                        SERVICE_DEMAND_START,
                        SERVICE_ERROR_NORMAL,
                        Path,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);
    }

    if ( ! hService )
    {
        printf( "CreateService returned %d\n", GetLastError() );
        CloseServiceHandle(hManager);
        return GetLastError();
    }

    CloseServiceHandle(hService);
    CloseServiceHandle(hManager);
#endif
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\server\pswrd.cxx ===
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}
#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>
#include <stdio.h>

BOOL SetPassword(TCHAR * szCID, TCHAR * pszPw)
{
#ifndef CHICO
    WCHAR * szPw = pszPw;
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    LSA_HANDLE hPolicy;
    LSA_UNICODE_STRING sKey;
    LSA_UNICODE_STRING sPassword;
    WCHAR szKey[256];
    swprintf(szKey, L"SCM:%s", szCID);
    sKey.Length = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.MaximumLength = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.Buffer = szKey;
    sPassword.Length = (wcslen(szPw) + 1) * sizeof(WCHAR);
    sPassword.MaximumLength = 80 * sizeof(WCHAR);
    sPassword.Buffer = szPw;

    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);

    // open the local security policy
    if (!NT_SUCCESS(
            LsaOpenPolicy(
                NULL,
                &sObjAttributes,
                POLICY_CREATE_SECRET,
                &hPolicy)))
    {
        printf("LsaOpenPolicy failed with %d\n",GetLastError());
        return(FALSE);
    }

    // store private data
    if (!NT_SUCCESS(
            LsaStorePrivateData(hPolicy, &sKey, &sPassword)))
    {
        printf("LsaStorePrivateData failed with %d\n",GetLastError());
        return(FALSE);
    }

    LsaClose(hPolicy);
#else
    WCHAR szPw[256];
    MultiByteToWideChar( CP_ACP,
                     0,
                     pszPw,
                     -1,
                     szPw,
                     sizeof(szPw) / sizeof(WCHAR) );
#endif
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\srvcore\factory.cxx ===
/*
 *  factory.cxx
 */

#include "server.hxx"
#include "factory.hxx"
#include "classes.hxx"

//
// MyFactory methods.
//
MyFactory::MyFactory()
{
    Refs = 0;
}

MyFactory::~MyFactory()
{
}

HRESULT STDMETHODCALLTYPE
MyFactory::QueryInterface (
    REFIID  iid,
    void ** ppv )
{
    HRESULT hr = E_NOINTERFACE;

    *ppv = 0;

    if ((memcmp(&iid, &IID_IUnknown, sizeof(IID)) == 0) ||
        (memcmp(&iid, &IID_IClassFactory, sizeof(IID)) == 0))
    {
        *ppv = this;
	AddRef();
	hr = S_OK;
    }

    return hr;
}

ULONG STDMETHODCALLTYPE
MyFactory::AddRef()
{
    Refs++;
    return Refs;
}

ULONG STDMETHODCALLTYPE
MyFactory::Release()
{
    unsigned long   Count;

    Count = --Refs;

    if ( Count == 0 )
    {
        delete this;
    }

    return Count;
}

HRESULT STDMETHODCALLTYPE
MyFactory::CreateInstance(
    IUnknown *  punkOuter,
    REFIID      riid,
    void **     ppv )
{
    // Should never be called.
    *ppv = 0;
    return E_FAIL;
}

HRESULT STDMETHODCALLTYPE
MyFactory::LockServer(
    BOOL    fLock )
{
    return S_OK;
}

//
// FactoryLocal methods.
//
HRESULT STDMETHODCALLTYPE
FactoryLocal::CreateInstance(
    IUnknown *  punkOuter,
    REFIID      riid,
    void **     ppv )
{
    HRESULT hr = E_OUTOFMEMORY;
    MyObject *  pObject;

    *ppv = 0;

    pObject = new MyObject( LOCAL );

    if ( ! pObject )
        return hr;

    //
    // Increment the object count.
    // The object count will keep this process alive until all objects are released.
    //

    ObjectCount++;
    hr = pObject->QueryInterface(riid, ppv);

    return hr;
}

//
// FactoryRemote methods.
//
HRESULT STDMETHODCALLTYPE
FactoryRemote::CreateInstance(
    IUnknown *  punkOuter,
    REFIID      riid,
    void **     ppv )
{
    HRESULT hr = E_OUTOFMEMORY;
    MyObject *  pObject;

    *ppv = 0;

    pObject = new MyObject( REMOTE );

    if ( ! pObject )
        return hr;

    //
    // Increment the object count.
    // The object count will keep this process alive until all objects are released.
    //

    ObjectCount++;
    hr = pObject->QueryInterface(riid, ppv);

    return hr;
}

//
// FactoryRemote methods.
//
HRESULT STDMETHODCALLTYPE
FactoryAtStorage::CreateInstance(
    IUnknown *  punkOuter,
    REFIID      riid,
    void **     ppv )
{
    HRESULT hr = E_OUTOFMEMORY;
    MyObject *  pObject;

    *ppv = 0;

    pObject = new MyObject( ATBITS );

    if ( ! pObject )
        return hr;

    //
    // Increment the object count.
    // The object count will keep this process alive until all objects are released.
    //

    ObjectCount++;
    hr = pObject->QueryInterface(riid, ppv);

    return hr;
}

//
// FactoryInproc methods.
//
HRESULT STDMETHODCALLTYPE
FactoryInproc::CreateInstance(
    IUnknown *  punkOuter,
    REFIID      riid,
    void **     ppv )
{
    HRESULT hr = E_OUTOFMEMORY;
    MyObject *  pObject;

    *ppv = 0;

    pObject = new MyObject( INPROC );

    if ( ! pObject )
        return hr;

    //
    // Increment the object count.
    // The object count will keep this process alive until all objects are released.
    //

    ObjectCount++;
    hr = pObject->QueryInterface(riid, ppv);

    return hr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\assert\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\assert\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//              w4vprintf
//              w4dprintf
//              w4vdprintf
//              
//  History:    18-Oct-91   vich        Created
//      
//----------------------------------------------------------------------------

#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN32
int _cdecl w4printf(const char *format, ...);
int _cdecl w4vprintf(const char *format, va_list arglist);
#endif

int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\assert\printf.c ===
/***
*printf.c - print formatted to stdout
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4printf() - print formatted data to stdout
*	defines w4vprintf() - print formatted output to stdout, get data
*			      from an argument ptr instead of explicit args.
*******************************************************************************/

#ifdef FLAT
#include "dprintf.h"		// function prototypes

#define _W4PRINTF_
#include "printf.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\tstsvc\pswrd.cxx ===
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
}
#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>
#include <stdio.h>

BOOL SetPassword(WCHAR * szCID, WCHAR * szPw)
{
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    LSA_HANDLE hPolicy;
    LSA_UNICODE_STRING sKey;
    LSA_UNICODE_STRING sPassword;
    WCHAR szKey[256];

    swprintf(szKey, L"SCM:%s", szCID);
    sKey.Length = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.MaximumLength = (wcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.Buffer = szKey;
    sPassword.Length = (wcslen(szPw) + 1) * sizeof(WCHAR);
    sPassword.MaximumLength = 80 * sizeof(WCHAR);
    sPassword.Buffer = szPw;

    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);

    // open the local security policy
    if (!NT_SUCCESS(
            LsaOpenPolicy(
                NULL,
                &sObjAttributes,
                POLICY_CREATE_SECRET,
                &hPolicy)))
    {
        printf("LsaOpenPolicy failed with %d\n",GetLastError());
        return(FALSE);
    }

    // store private data
    if (!NT_SUCCESS(
            LsaStorePrivateData(hPolicy, &sKey, &sPassword)))
    {
        printf("LsaStorePrivateData failed with %d\n",GetLastError());
        return(FALSE);
    }

    LsaClose(hPolicy);
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\assert\sprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4sprintf() - print formatted data to string
*	defines w4vsprintf() - print formatted output to a string, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#define _W4SPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\assert\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*/

#if defined(M_I386) || defined(WIN32)
#  ifndef WIN32
#    define WIN32
#  endif
#elif !defined(M_I86LM)
#  error Must be FLAT or LARGE model.
#endif

#ifndef NULL
#  define NULL 0
#endif

struct w4io
{
    union
    {
        struct
        {
            wchar_t *_pwcbuf;   // wchar_t output buffer
            wchar_t *_pwcstart;
        } wc;
        struct
        {
            char *_pchbuf;      // char output buffer
            char *_pchstart;
        } ch;
    } buf ;
    unsigned int cchleft;       // output buffer character count
    void (_cdecl *writechar)(int ch,
                             int num,
                             struct w4io *f,
                             int *pcchwritten);
};

#define pwcbuf          buf.wc._pwcbuf
#define pwcstart        buf.wc._pwcstart
#define pchbuf          buf.ch._pchbuf
#define pchstart        buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\tstsvc\client.cxx ===
/*
 * client.cxx
 */

#include "client.hxx"

#define MIN_TEST_NUMBER         1
#define MAX_TEST_NUMBER         27

BOOL UnimplementedTest();
BOOL UnsupportedTest();
BOOL GenericCITest(REFCLSID clsid, REFIID iid, WCHAR * szServerName, int n, DWORD ctxt);

BOOL CGCOLocalEXE();
BOOL CGCOExplicitActivator();
BOOL CILocalDLL();
BOOL CILocalEXE();
BOOL CIExplicitActivator();
BOOL CI3LocalEXE();
BOOL CI3ExplicitActivator();
BOOL CGIFFLocalEXE();
BOOL CGIFFExplicitActivator();
BOOL CGIFFRegistryActivator();
BOOL CGIFFAtStorageActivator();
BOOL IMBLocalEXE();
BOOL IMBLocalService();
BOOL IMBAtStorageActivator();
BOOL IMBAtStorageService();
BOOL IMBAtStoragePreCon();
BOOL IMBAtStorageUser();
BOOL CIFromStgLocalEXE();
BOOL CIFromStgActivator();
BOOL CICustomLocalDLL();
BOOL CICustomLocalEXE();
BOOL CILocalPreCon();
BOOL CIExplicitPreCon();
BOOL CILocalUser();
BOOL CIExplicitUser();
BOOL CILocalPreConACL();
BOOL CIExplicitPreConACL();
BOOL CILocalService();
BOOL CIExplicitService();

BOOL MyStartService(WCHAR * wszServiceName, WCHAR *pwszRegServiceArgs);
BOOL MyStopService(WCHAR * wszServiceName);

#ifdef NO_DCOM
LPTESTFUNC rgTest[] =
    {
        NULL,
        CGCOLocalEXE,
        UnsupportedTest,
        CILocalDLL,
        CILocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest
/* New tests
        UnsupportedTest,
        UnsupportedTest,
end new tests */
        CI3LocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        IMBLocalEXE,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        UnsupportedTest,
        NULL
    };
#else
LPTESTFUNC rgTest[] =
    {
        NULL,
        CGCOLocalEXE,
        CGCOExplicitActivator,
        CILocalDLL,
        CILocalEXE,
        CIExplicitActivator,
        CILocalPreCon,
        CIExplicitPreCon,
        CILocalUser,
        CIExplicitUser,
        CILocalService,
        CIExplicitService,
/* new tests
        CILocalPreConACL,
        CIExplicitPreConACL,
end new tests */
        CI3LocalEXE,
        CI3ExplicitActivator,
        CICustomLocalDLL,
        CICustomLocalEXE,
        CGIFFLocalEXE,
        CGIFFExplicitActivator,
        CGIFFRegistryActivator,
        CGIFFAtStorageActivator,
        IMBLocalEXE,
        IMBLocalService,
        IMBAtStorageActivator,
        IMBAtStorageService,
        IMBAtStoragePreCon,
        IMBAtStorageUser,
        CIFromStgLocalEXE,
        CIFromStgActivator,
        NULL
    };
#endif // NO_DCOM

char *  TestName[] =
        {
            NULL,
           "CoGetClassObject                    local       EXE",
           "CoGetClassObject                    explicit    activator",
           "CoCreateInstance                    local       DLL",
           "CoCreateInstance                    local       EXE",
           "CoCreateInstance                    explicit    activator",
           "CoCreateInstance                    local       pre-configured",
           "CoCreateInstance                    explicit    pre-configured",
           "CoCreateInstance                    local       user",
           "CoCreateInstance                    explicit    user",
           "CoCreateInstance                    local       service",
           "CoCreateInstance                    explicit    service",
/* new tests
           "CoCreateInstance                    local       pre-configured ACL",
           "CoCreateInstance                    explicit    pre-configured ACL",
end new tests */
           "CoCreateInstance (3 IIDs)           local       EXE",
           "CoCreateInstance (3 IIDs)           explicit    activator",
           "CoCreateInstance from custom itf.   local       DLL",
           "CoCreateInstance from custom itf.   local       EXE",
           "CoGetInstanceFromFile               local       EXE",
           "CoGetInstanceFromFile               explicit    activator",
           "CoGetInstanceFromFile               registry    activator",
           "CoGetInstanceFromFile               AtStorage   activator",
           "IMoniker::BindToObject              local       EXE",
           "IMoniker::BindToObject              local       service",
           "IMoniker::BindToObject              AtStorage   activator",
           "IMoniker::BindToObject              AtStorage   service",
           "IMoniker::BindToObject              AtStorage   pre-configured",
           "IMoniker::BindToObject              AtStorage   user",
           "CoGetInstanceFromIStorage           local       EXE",
           "CoGetInstanceFromIStorage           explicit    activator",
           NULL
        };

char    RunTest[] =
        {
            -1,
            // CoGetClassObject
            YES,
            YES,
            // CoCreateInstance
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
/* new tests
            YES,
            YES,
end new tests */
            // CoCreateInstance (3 IIDs)
            YES,
            YES,
            // CoGetInstanceFromFile
            YES,
            YES,
            YES,
            YES,
            // IMoniker:Bind
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            YES,
            -1
         };

char    RunLocalTest[] =
        {
            -1,
            // CoGetClassObject
            YES,
            NO,
            // CreateInstance
            YES,
            YES,
            NO,
            YES,
            NO,
            YES,
            NO,
            YES,
            NO,
/* new tests
            YES,
            NO,
end new tests */
            // CreateInstance (3 IIDs)
            YES,
            NO,
            // CreateInstance from custom Itf.
            YES,
            YES,
            // CoGetInstanceFromFile
            YES,
            NO,
            NO,
            NO,
            // IMoniker:Bind
            YES,
            YES,
            NO,
            NO,
            NO,
            NO,
            // CoGetInstanceFromIStorage
            YES,
            NO,
            -1
         };

WCHAR ServerName[32];

WCHAR RemoteFileName[256];
WCHAR * LocalFileName = L"c:\\acttest.dat";
WCHAR * StorageName = L"c:\\acttest.stg";

LARGE_INTEGER liPerfFreq;
LARGE_INTEGER liStart;
LARGE_INTEGER liStop;
LARGE_INTEGER liElapsedTime;

#define RESET_CLOCK liElapsedTime.LowPart = liElapsedTime.HighPart = 0
#define START_CLOCK QueryPerformanceCounter(&liStart)
#define STOP_CLOCK      QueryPerformanceCounter(&liStop); \
                        liElapsedTime.QuadPart += liStop.QuadPart - liStart.QuadPart
#define DUMP_CLOCK DisplayElapsedTime()
#define START_LOOP for (unsigned sl_n = uIterations+1; sl_n--;){
#define STOP_LOOP if (uIterations == sl_n ) RESET_CLOCK;}
#define SLEEP_IF_LOOPING if (sl_n && !gfHoldServer) Sleep(1000)

unsigned uIterations = 0;

BOOL    gfRegister = TRUE;
BOOL    gfHoldServer = FALSE;
BOOL    gfLocal = FALSE;
BOOL    gfNolocal = FALSE;
BOOL    gfSpecificTest = FALSE;

DWORD dwWaitHint = 0;

void DisplayElapsedTime(void)
{
    LONGLONG    MicroPerIter;

    liElapsedTime.QuadPart /= uIterations;

    MicroPerIter = liElapsedTime.QuadPart * 1000000;
    MicroPerIter /= liPerfFreq.QuadPart;

    printf( "Time: %d microseconds per iteration", (DWORD) MicroPerIter );
}

BOOL AllLocal()
{
    for (int x = MIN_TEST_NUMBER; x<= MAX_TEST_NUMBER; x++)
    {
        if (RunTest[x]  &&  !RunLocalTest[x])
            return(FALSE);
    }
    return(TRUE);
}

extern WCHAR ServiceName[];

void _cdecl main( int argc, char ** argv )
{
    HRESULT         HResult;
    HANDLE          hFile;
    int             n;
    BOOL f;

    if (argc > 1)
    {
        if (argc == 3 && (!strcmp(argv[1], "-t")))
        {
            dwWaitHint = atoi(argv[2]);
        }
        else
        {
            printf("usage: %s [-t #]\n    #   number of milliseconds between QueryServiceStatus calls\n", argv[0]);
            return;
        }
    }
    if ((!QueryPerformanceFrequency(&liPerfFreq)) && uIterations > 0)
    {
        printf("No high performance counter.\nTests cannot be timed.\nAborting.\n");
        return;
    }

    uIterations = 1;

    printf("Starting service...\n");
    RESET_CLOCK;
    START_CLOCK;
    f = MyStartService(L"ActTestService", L"");
    STOP_CLOCK;
    if (f)
        printf("succeeded - ");
    else
        printf("failed - ");
    DUMP_CLOCK;
    printf("\n");

    printf("Stopping service...\n");
    RESET_CLOCK;
    START_CLOCK;
    f = MyStopService(L"ActTestService");
    STOP_CLOCK;
    if (f)
        printf("succeeded - ");
    else
        printf("failed - ");
    DUMP_CLOCK;
    printf("\n");

    return;
#ifndef NO_DCOM
    if ( argc == 1 )
        PrintUsageAndExit( FALSE );
#endif // NO_DCOM

    if ( argc > 1 && strcmp(argv[1],"-?") == 0 )
        PrintUsageAndExit( TRUE );

    n = 1;

    while ( (n < argc) && (*argv[n] == '-') )
    {
        if ( (n < argc) && strcmp(argv[n],"-local") == 0 )
        {
            if (gfLocal | gfNolocal)
            {
                PrintUsageAndExit( FALSE );
            }
            gfLocal = TRUE;
            memcpy(RunTest, RunLocalTest, MAX_TEST_NUMBER + MIN_TEST_NUMBER);
            n++;
        }

        if ( (n < argc) && strcmp(argv[n],"-nolocal") == 0 )
        {
            if (gfLocal | gfNolocal)
            {
                PrintUsageAndExit( FALSE );
            }
            gfNolocal = TRUE;
            for (int x = MIN_TEST_NUMBER; x<= MAX_TEST_NUMBER; x++)
            {
                RunTest[x] = !RunLocalTest[x];
            }
            n++;
        }

        if ( (n < argc) && strcmp(argv[n],"-noreg") == 0 )
        {
            gfRegister = FALSE;
            n++;
            continue;
        }

        if ( (n < argc) && strcmp(argv[n],"-hold") == 0 )
        {
            gfHoldServer = TRUE;
            n++;
            continue;
        }

        if ( (n < argc) && strcmp(argv[n],"-n") == 0 )
        {
            if ( ++n >= argc )
                PrintUsageAndExit(FALSE);

            uIterations = atoi(argv[n++]);
        }

        if ( (n < argc) && strcmp(argv[n],"-t") == 0 )
        {
            long    TestNum1, TestNum2;

            if ( ++n >= argc )
                PrintUsageAndExit(FALSE);

            TestNum1 = atoi(argv[n++]);

            if ( (n < argc) && ((TestNum2 = atoi(argv[n])) != 0) )
                n++;
            else
                TestNum2 = TestNum1;

            if ( (TestNum1 < MIN_TEST_NUMBER) || (TestNum2 > MAX_TEST_NUMBER) )
            {
                printf( "Test number(s) must be between %d and %d.\n",
                        MIN_TEST_NUMBER,
                        MAX_TEST_NUMBER );
                return;
            }

            if ( TestNum1 > TestNum2 )
            {
                printf( "Second test number must be greater than the first.\n" );
                return;
            }

            if (!gfSpecificTest)
            {
                gfSpecificTest = TRUE;
                // only do this the first time -t is found on the command line
                memset(RunTest,NO,sizeof(RunTest));
            }
            memset(&RunTest[TestNum1],YES,sizeof(char)*(TestNum2-TestNum1+1));
        }
    }

#ifndef NO_DCOM
    if ( n != argc - 1  && !AllLocal())
    {
        printf("ERROR - Selected tests require a server name.\n");
        ExitThread(0);
    }

    if ( n < argc )
    {
        MultiByteToWideChar( CP_ACP,
                             0,
                             argv[n],
                             -1,
                             ServerName,
                             sizeof(ServerName) / sizeof(WCHAR) );
    }
    else
        ServerName[0] = 0;
#endif // NO_DCOM

    hFile = CreateFile(
                LocalFileName,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                0,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                0 );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        printf("CreateFile failed while creating local file: %d\n", GetLastError());
        return;
    }

    CloseHandle( hFile );

#ifndef NO_DCOM
    if ( ServerName[0] != 0 )
    {
        RemoteFileName[0] = 0;

        if ( ServerName[0] != L'\\' )
            wcscat( RemoteFileName, L"\\\\" );

        wcscat( RemoteFileName, ServerName );
        wcscat( RemoteFileName, L"\\c$\\acttest.dat" );

        hFile = CreateFile(
                    RemoteFileName,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    0,
                    OPEN_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    0 );

        if ( hFile == INVALID_HANDLE_VALUE )
        {
            printf("CreateFile failed while creating remote file: %d\n", GetLastError());
            return;
        }

        CloseHandle( hFile );
    }
#endif // NO_DCOM

    HResult = CoInitialize(NULL);

    if( FAILED(HResult) )
    {
        printf( "Client CoInitialize failed Ox%x!\n", HResult );
        return;
    }

    if ((!QueryPerformanceFrequency(&liPerfFreq)) && uIterations > 0)
    {
        printf("No high performance counter.\nTests cannot be timed.\nAborting.\n");
    }
    else
    {
        if ( ! Tests() )
            printf("\nTests FAILED\n");
        else
            printf("\nTests SUCCEEDED\n");
    }

    CoUninitialize();

    DeleteFile( LocalFileName );
#ifndef NO_DCOM
    DeleteFile( RemoteFileName );
#endif // NO_DCOM
}

BOOL Tests()
{
    HRESULT         HResult;
    long            RegStatus;

    if (gfRegister)
    {
        DeleteClsidKey( ClsidGoober32String );
        DeleteClsidKey( ClsidActLocalString );
        DeleteClsidKey( ClsidActRemoteString );
        DeleteClsidKey( ClsidActAtStorageString );
        DeleteClsidKey( ClsidActInprocString );
        DeleteClsidKey( ClsidActPreConfigString );
        DeleteClsidKey( ClsidActRunAsLoggedOnString );
        DeleteClsidKey( ClsidActServiceString );
        DeleteClsidKey( ClsidActServerOnlyString );

        if ( (RegStatus = InitializeRegistryForInproc()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForInproc failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForLocal()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForLocal failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForCustom()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForCustom failed %d.\n", RegStatus);
            return FALSE;
        }
    #ifndef NO_DCOM
        if ( (RegStatus = InitializeRegistryForRemote()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForRemote failed %d.\n", RegStatus);
            return FALSE;
        }

        if ( (RegStatus = InitializeRegistryForService()) != ERROR_SUCCESS )
        {
            printf("InitializeRegistryForService failed %d.\n", RegStatus);
            return FALSE;
        }
    #endif // NO_DCOM
    }
    BOOL fAllTests = TRUE;

    for (int x = MIN_TEST_NUMBER; x <= MAX_TEST_NUMBER; x++)
    {
        if (RunTest[x])
        {
            printf("\nTest %2d: %s\n",x, TestName[x]);
            // prime the system once to ensure the test is fully cached
            if (rgTest[x]())
            {
                printf("PASSED");
                if (uIterations)
                {
                    printf(" - ");
                    DUMP_CLOCK;
                }
                printf("\n");
            }
            else
            {
                printf("FAILED\n");
                fAllTests = FALSE;
            }

        }
    }

    return(fAllTests);
}

void PrintUsageAndExit( BOOL bListTests )
{
#ifdef NO_DCOM
    printf("Usage : %s [-hold] [-noreg] [-n #] [-t # [#]]\n", "actclt");
    printf("\t-n #     : Run specific number of timed iterations (default is 0).\n");
    printf("\t-noreg   : Don't update registry\n");
    printf("\t-t #     : Run specific test number or a range of tests.\n");
    printf("\t-?       : Print usage plus test descriptions.\n");
#else
    printf("Usage : %s [-hold] [-noreg] [[-local] | [-nolocal]] [-n #] [-t # [#]] [server_name]\n", "actclt");
    printf("\t-hold    : Hold the server up during all iterations.\n");
    printf("\t-local   : Run only local activation tests.\n");
    printf("\t-n #     : Run specific number of timed iterations (default is 0).\n");
    printf("\t-nolocal : Run only remote activation tests.\n");
    printf("\t-noreg   : Don't update registry\n");
    printf("\t-t #     : Run specific test number or a range of tests.\n");
    printf("\t-?       : Print usage plus test descriptions.\n");
#endif // NO_DCOM

    if ( bListTests )
    {
        long    n;

        printf("\nTests :\n");
        printf("\t # Method                              Location    Security\n");
        printf("\t-- ----------------------------------- ----------- --------------\n");

        for ( n = MIN_TEST_NUMBER; n <= MAX_TEST_NUMBER; n++ )
        {
            printf("\t%2d %s\n", n, TestName[n]);
        }
    }

    ExitThread(0);
}

void * __RPC_API
MIDL_user_allocate(size_t len)
{
    return malloc(len);
}

void __RPC_API
MIDL_user_free(void * vp)
{
    free(vp);
}

BOOL StampFileWithCLSID(WCHAR * szFilename, CLSID & clsid)
{
    HRESULT hr;
    IStorage * pStg;

    hr = StgCreateDocfile(
                szFilename,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStg);

    if (FAILED (hr))
    {
        printf("StgCreateDocfile returned 0x%x\n", hr);
        return(FALSE);
    }

    hr = WriteClassStg(pStg, clsid);

    pStg->Release();

    if (FAILED (hr))
    {
        printf("WriteClassStg returned 0x%x\n", hr);
        return(FALSE);
    }

    return(TRUE);
}

//
// Test Procedures:
//

BOOL UnimplementedTest()
{
    printf("Not implemented at this time.\n");
    return(TRUE);
}

BOOL UnsupportedTest()
{
    printf("Not supported by this version.\n");
    return(TRUE);
}

BOOL GenericCITest(REFCLSID clsid, REFIID iid, WCHAR * szServerName, int n, DWORD ctxt)
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    if (szServerName)
    {
        memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
        ServerInfo.pwszName = szServerName;
        pServerInfo = &ServerInfo;
    }
    else
    {
        pServerInfo = NULL;
    }

    MULTI_QI QIStruct[10];
    int x;
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    for (x = n; x--;)
    {
        QIStruct[x].pItf = NULL;
        QIStruct[x].pIID = (IID *) &iid;
    }


    START_CLOCK;
    hr = CoCreateInstanceEx(
        clsid,
        NULL,
        ctxt,
        pServerInfo,
        n,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    for (x = 0; x < n; x++)
    {
        if (FAILED(QIStruct[x].hr))
        {
            printf("CoCreateInstanceEx returned 0x%x for interface %d\n",
                QIStruct[x].hr, x);
            fReturn = FALSE;
        }
        else
            QIStruct[x].pItf->Release();
    }
    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CGCOLocalEXE()
{
    IClassFactory * pClassFactory;
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoGetClassObject(
        CLSID_ActLocal,
        CLSCTX_LOCAL_SERVER,	
        NULL,
        IID_IClassFactory,
        (void **) &pClassFactory );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoGetClassObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    hr = pClassFactory->CreateInstance( NULL,
                                        IID_IUnknown,
                                        (void **) &pUnknown );

    pClassFactory->Release();

    if ( FAILED(hr) )
    {
        printf("CreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}

#ifndef NO_DCOM
BOOL CGCOExplicitActivator()
{
    COSERVERINFO   ServerInfo;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = ServerName;

    IClassFactory * pClassFactory;
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoGetClassObject(
        CLSID_ActLocal,
        CLSCTX_REMOTE_SERVER,	
        &ServerInfo,
        IID_IClassFactory,
        (void **) &pClassFactory );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoGetClassObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    hr = pClassFactory->CreateInstance( NULL,
                                        IID_IUnknown,
                                        (void **) &pUnknown );

    pClassFactory->Release();

    if ( FAILED(hr) )
    {
        printf("CreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return TRUE;
}
#endif // NO_DCOM

#ifdef NO_DCOM
BOOL CILocalDLL()
{
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
        CLSID_ActInproc,
        NULL,
        CLSCTX_INPROC_SERVER,	
        IID_IUnknown,
        (void **) &pUnknown );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return TRUE;
}

BOOL CILocalEXE()
{
    IUnknown * pUnknown;
    IUnknown * punkHeld = NULL;
    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
        CLSID_ActLocal,
        NULL,
        CLSCTX_LOCAL_SERVER,
        IID_IUnknown,
        (void **) &pUnknown );
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}
#else
BOOL CILocalDLL()
{
    return GenericCITest(CLSID_ActInproc, IID_IUnknown, NULL, 1, CLSCTX_INPROC_SERVER);
}

BOOL CILocalEXE()
{
    return GenericCITest(CLSID_ActLocal, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitActivator()
{
    return GenericCITest(CLSID_ActLocal, IID_IUnknown, ServerName, 1, CLSCTX_REMOTE_SERVER);
}
#endif // NO_DCOM

#ifdef NO_DCOM
// Pre-DCOM version of CI3LocalEXE which calls CoCreateInstance
// once followed by 2 calls to QueryInterface
// instead of calling CoCreateInstanceEx.
BOOL CI3LocalEXE()
{
    IUnknown * pUnknown;
    IUnknwon * punkHeld = NULL;
    IPersist * pPersist;
    IPersistFile * pPersistFile;

    HRESULT hr;

    START_LOOP;

    START_CLOCK;
    hr = CoCreateInstance(
            CLSID_ActLocal,
            NULL,
            CLSCTX_LOCAL_SERVER,
            IID_IUnknown,
            (void **) &pUnknown );

    if ( FAILED(hr) )
    {
        printf("CoCreateInstance returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnknown;
        punkHeld->AddRef();
    }

    pUnknown->QueryInterface( IID_IPersist, (void **)&pPersist );
    pUnknown->QueryInterface( IID_IPersist, (void **)&pPersistFile );
    STOP_CLOCK;

    pUnknown->Release();
    pPersist->Release();
    pPersistFile->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return TRUE;
}
#else // NO_DCOM

BOOL CI3LocalEXE()
{
    return GenericCITest(CLSID_ActLocal, IID_IPersist, NULL, 3, CLSCTX_LOCAL_SERVER);
    /*
    MULTI_QI QIStruct[3];
    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[1].pIID = (IID *)&IID_IPersist;
    QIStruct[2].pIID = (IID *)&IID_IPersistFile;
    QIStruct[0].pItf = NULL;
    QIStruct[1].pItf = NULL;
    QIStruct[2].pItf = NULL;
    */
}

BOOL CI3ExplicitActivator()
{
    return GenericCITest(CLSID_ActLocal, IID_IPersist, ServerName, 3, CLSCTX_REMOTE_SERVER);
    /*
    MULTI_QI QIStruct[3];
    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[1].pIID = (IID *)&IID_IPersist;
    QIStruct[2].pIID = (IID *)&IID_IPersistFile;
    QIStruct[0].pItf = NULL;
    QIStruct[1].pItf = NULL;
    QIStruct[2].pItf = NULL;
    */
}

BOOL CGIFFLocalEXE()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    STGM_READWRITE,
                    LocalFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFExplicitActivator()
{
    COSERVERINFO   ServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = ServerName;

    MULTI_QI QIStruct[1];

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    &ServerInfo,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    RemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFRegistryActivator()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;
    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActRemote,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    RemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CGIFFAtStorageActivator()
{
    MULTI_QI QIStruct[1];
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;
    START_CLOCK;
    HRESULT HResult = CoGetInstanceFromFile(
                    NULL,
                    &CLSID_ActAtStorage,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    STGM_READWRITE,
                    RemoteFileName,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromFile returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}
#endif // NO_DCOM

BOOL IMBLocalEXE()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(LocalFileName, CLSID_ActLocal))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(LocalFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

#ifndef NO_DCOM
BOOL IMBLocalService()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(LocalFileName, CLSID_ActService))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(LocalFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;
    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }
    pUnk->Release();

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageActivator()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(RemoteFileName, CLSID_ActAtStorage))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(RemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageService()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(RemoteFileName, CLSID_ActService))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(RemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStoragePreCon()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(RemoteFileName, CLSID_ActPreConfig))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(RemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL IMBAtStorageUser()
{
    IBindCtx * pBc;
    IUnknown * pUnk;
    IUnknown * punkHeld = NULL;
    HRESULT hr;
    IMoniker *pMon;

    if (!StampFileWithCLSID(RemoteFileName, CLSID_ActRunAsLoggedOn))
    {
        return(FALSE);
    }

    hr = CreateFileMoniker(RemoteFileName, &pMon);

    if (FAILED(hr))
    {
        printf("CreateFileMoniker returned 0x%x\n", hr);
    }

    hr = CreateBindCtx(0, &pBc);

    if (FAILED(hr))
    {
        printf("CreateBindCtx returned 0x%x\n", hr);
        pMon->Release();
        return(FALSE);
    }

    START_LOOP;

    START_CLOCK;
    hr = pMon->BindToObject(
                pBc,
                NULL,
                IID_IUnknown,
                (void **) &pUnk);
    STOP_CLOCK;

    if (FAILED(hr))
    {
        printf("IMoniker::BindToObject returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return(FALSE);
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = pUnk;
        punkHeld->AddRef();
    }

    pUnk->Release();

    STOP_LOOP;

    pMon->Release();
    pBc->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CIFromStgLocalEXE()
{
    IStorage *  pStorage;
    MULTI_QI    QIStruct[10];
    IUnknown * punkHeld = NULL;

    pStorage = 0;

    DeleteFile( StorageName );

    HRESULT HResult = StgCreateDocfile(
                StorageName,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStorage );

    if ( FAILED(HResult) )
    {
        printf("StgCreateDocfile returned 0x%x\n", HResult);
        return FALSE;
    }

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HResult = CoGetInstanceFromIStorage(
                    NULL,
                    &CLSID_ActLocal,
                    NULL,
                    CLSCTX_SERVER,
                    pStorage,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromIStorage returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();
    QIStruct[0].pItf = 0;

    STOP_LOOP;

    pStorage->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CIFromStgActivator()
{
    IStorage *  pStorage;
    MULTI_QI    QIStruct[10];
    COSERVERINFO   ServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = ServerName;

    pStorage = 0;

    DeleteFile( StorageName );

    HRESULT HResult = StgCreateDocfile(
                StorageName,
                STGM_READWRITE | STGM_DIRECT | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                0,
                &pStorage );

    if ( FAILED(HResult) )
    {
        printf("StgCreateDocfile returned 0x%x\n", HResult);
        return FALSE;
    }

    START_LOOP;

    QIStruct[0].pIID = (IID *)&IID_IUnknown;
    QIStruct[0].pItf = NULL;

    START_CLOCK;
    HResult = CoGetInstanceFromIStorage(
                    &ServerInfo,
                    &CLSID_ActRemote,
                    NULL,
                    CLSCTX_REMOTE_SERVER,
                    pStorage,
                    1,
                    QIStruct );
    STOP_CLOCK;

    if ( FAILED(HResult) )
    {
        printf("CoGetInstanceFromIStorage returned 0x%x\n", HResult);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    QIStruct[0].pItf->Release();
    QIStruct[0].pItf = 0;

    STOP_LOOP;

    pStorage->Release();

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CICustomLocalDLL()
{
    IGoober *   pGoober;
    MULTI_QI    QIStruct[10];
    HRESULT     hr;
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IGoober;

    START_CLOCK;
    hr = CoCreateInstanceEx(
                    CLSID_ActInproc,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    NULL,
                    1,
                    QIStruct );
    STOP_CLOCK;

    pGoober = (IGoober *)QIStruct[0].pItf;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    START_CLOCK;
    hr = pGoober->Ping();
    STOP_CLOCK;

    if ( hr != S_OK )
    {
        printf("IGoober::Ping returned %d\n", hr);
        pGoober->Release();
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    pGoober->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CICustomLocalEXE()
{
    IGoober *   pGoober;
    MULTI_QI    QIStruct[10];
    HRESULT hr;
    IUnknown * punkHeld = NULL;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IGoober;

    START_CLOCK;
    hr = CoCreateInstanceEx(
                    CLSID_ActLocal,
                    NULL,
                    CLSCTX_LOCAL_SERVER,
                    NULL,
                    1,
                    QIStruct );
    STOP_CLOCK;

    pGoober = (IGoober *)QIStruct[0].pItf;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld)
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    START_CLOCK;
    hr = pGoober->Ping();
    STOP_CLOCK;

    if ( hr != S_OK )
    {
        printf("IGoober::Ping returned %d\n", hr);
        pGoober->Release();
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    pGoober->Release();

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();
    return(TRUE);
}

BOOL CILocalPreCon()
{
    return GenericCITest(CLSID_ActPreConfig, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitPreCon()
{
    return GenericCITest(CLSID_ActPreConfig, IID_IUnknown, ServerName, 1, CLSCTX_REMOTE_SERVER);
}

BOOL CILocalUser()
{
    return GenericCITest(CLSID_ActRunAsLoggedOn, IID_IUnknown, NULL, 1, CLSCTX_LOCAL_SERVER);
}

BOOL CIExplicitUser()
{
    return GenericCITest(CLSID_ActRunAsLoggedOn, IID_IUnknown, ServerName, 1, CLSCTX_REMOTE_SERVER);
}

BOOL CILocalService()
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    MULTI_QI QIStruct[1];
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IUnknown;

    START_CLOCK;
    hr = CoCreateInstanceEx(
        CLSID_ActService,
        NULL,
        CLSCTX_LOCAL_SERVER,
        NULL,
        1,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    if (FAILED(QIStruct[0].hr))
    {
        printf("CoCreateInstanceEx returned 0x%x\n",
            QIStruct[0].hr);
        fReturn = FALSE;
    }
    else
        QIStruct[0].pItf->Release();

    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CIExplicitService()
{
    COSERVERINFO   ServerInfo;
    COSERVERINFO   *pServerInfo;
    IUnknown * punkHeld = NULL;

    memset( &ServerInfo, 0, sizeof(COSERVERINFO) );
    ServerInfo.pwszName = ServerName;
    pServerInfo = &ServerInfo;

    MULTI_QI QIStruct[1];
    HRESULT hr;
    BOOL fReturn = TRUE;

    START_LOOP;

    QIStruct[0].pItf = NULL;
    QIStruct[0].pIID = (IID *) &IID_IUnknown;

    START_CLOCK;
    hr = CoCreateInstanceEx(
        CLSID_ActService,
        NULL,
        CLSCTX_REMOTE_SERVER,
        pServerInfo,
        1,
        QIStruct);
    STOP_CLOCK;

    if ( FAILED(hr) )
    {
        printf("CoCreateInstanceEx returned 0x%x\n", hr);
        if (punkHeld)
            punkHeld->Release();
        return FALSE;
    }

    if (gfHoldServer && NULL == punkHeld && SUCCEEDED(QIStruct[0].hr))
    {
        punkHeld = QIStruct[0].pItf;
        punkHeld->AddRef();
    }

    if (FAILED(QIStruct[0].hr))
    {
        printf("CoCreateInstanceEx returned 0x%x\n",
            QIStruct[0].hr);
        fReturn = FALSE;
    }
    else
        QIStruct[0].pItf->Release();

    if (!fReturn)
    {
        if (punkHeld)
            punkHeld->Release();
        return(fReturn);
    }

    SLEEP_IF_LOOPING;

    STOP_LOOP;

    if (punkHeld)
        punkHeld->Release();

    return fReturn;
}

BOOL CILocalPreConACL();
BOOL CIExplicitPreConACL();

#define MAX_SERVICE_ARGS 10

BOOL MyStartService(WCHAR * wszServiceName, WCHAR *pwszRegServiceArgs)
{
    SC_HANDLE hSCManager;
    SC_HANDLE hService;
    WCHAR    *pwszServiceArgs = NULL;
    ULONG     cArgs = 0;
    WCHAR    *apwszArgs[MAX_SERVICE_ARGS];

    // Get a handle to the Service Control Manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_EXECUTE | SERVICE_QUERY_STATUS ))
    {
        // Open a handle to the requested service
        if (hService = OpenService(hSCManager, wszServiceName, GENERIC_EXECUTE | SERVICE_QUERY_STATUS ))
        {
            // Close the service manager's database
            CloseServiceHandle(hSCManager);

            // Formulate the arguments (if any)
            if (pwszRegServiceArgs)
            {
                UINT   k = 0;

                // Make a copy of the service arguments
                pwszServiceArgs = new WCHAR[(lstrlenW(pwszRegServiceArgs) + 1)];
                if (pwszServiceArgs == NULL)
                {
                    CloseServiceHandle(hService);
                    return FALSE;
                }
                lstrcpyW(pwszServiceArgs, pwszRegServiceArgs);

                // Scan the arguments
                do
                {
                    // Scan to the next non-whitespace character
                    while(pwszServiceArgs[k]  &&
                          (pwszServiceArgs[k] == L' '  ||
                           pwszServiceArgs[k] == L'\t'))
                    {
                        k++;
                    }

                    // Store the next argument
                    if (pwszServiceArgs[k])
                    {
                        apwszArgs[cArgs++] = &pwszServiceArgs[k];
                    }

                    // Scan to the next whitespace char
                    while(pwszServiceArgs[k]          &&
                          pwszServiceArgs[k] != L' '  &&
                          pwszServiceArgs[k] != L'\t')
                    {
                        k++;
                    }

                    // Null terminate the previous argument
                    if (pwszServiceArgs[k])
                    {
                        pwszServiceArgs[k++] = L'\0';
                    }
                } while(pwszServiceArgs[k]);
            }

            // Start the service
            if (StartService(hService, cArgs,
                               cArgs > 0 ? (LPCTSTR  *) apwszArgs : NULL))
            {
                SERVICE_STATUS ss;
                do
                {
                    QueryServiceStatus(hService, &ss);
                    if (dwWaitHint)
                    {
                        Sleep(dwWaitHint);
                    }
                    else
                        Sleep(ss.dwWaitHint);
                } while (ss.dwCurrentState == SERVICE_START_PENDING);

                CloseServiceHandle(hService);
                delete [] pwszServiceArgs;
                return TRUE;
            }
            else
            {
                CloseServiceHandle(hService);
                delete [] pwszServiceArgs;
            }
        }
        else
        {
            CloseServiceHandle(hSCManager);
        }
    }

    DWORD err = GetLastError();
    return FALSE;
}

BOOL MyStopService(WCHAR * wszServiceName)
{
    SC_HANDLE hSCManager;
    SC_HANDLE hService;
    SERVICE_STATUS ss;

    // Get a handle to the Service Control Manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_EXECUTE | SERVICE_QUERY_STATUS ))
    {
        // Open a handle to the requested service
        if (hService = OpenService(hSCManager, wszServiceName, GENERIC_EXECUTE | SERVICE_QUERY_STATUS ))
        {
            // Close the service manager's database
            CloseServiceHandle(hSCManager);

            // Stop the service
            if (ControlService(hService, SERVICE_CONTROL_STOP, &ss))
            {

                while (ss.dwCurrentState == SERVICE_STOP_PENDING)
                {
                    if (dwWaitHint)
                    {
                        Sleep(dwWaitHint);
                    }
                    else
                        Sleep(ss.dwWaitHint);
                    QueryServiceStatus(hService, &ss);
                };

                CloseServiceHandle(hService);
                return TRUE;
            }
            else
            {
                CloseServiceHandle(hService);
            }
        }
        else
        {
            CloseServiceHandle(hSCManager);
        }
    }

    DWORD err = GetLastError();
    return FALSE;
}

#endif // NO_DCOM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\tstsvc\reg.cxx ===
//
// reg.cxx
//

#include "client.hxx"

BOOL SetPassword(WCHAR * szCID, WCHAR * szPw);

WCHAR * ServiceName = L"ActTestService";
WCHAR * ServiceDisplayName = L"ActTestService";
WCHAR * UserName = L"redmond\\oleuser";
WCHAR * Password = L"stocksplit";

long InitializeRegistryForLocal()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    WCHAR       Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActLocalString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    L"LocalServer32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"actsrv.exe 2" );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (wcslen(Path) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActLocalString,
                    (wcslen(ClsidActLocalString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActLocalString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

long InitializeRegistryForInproc()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    WCHAR       Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActInprocString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    L"InprocServer32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"actsrvd.dll" );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (wcslen(Path) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"ThreadingModel",
                    0,
                    REG_SZ,
                    (const BYTE *)L"Both",
                    (wcslen(L"Both") + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

WCHAR * StringIidIGoober = L"{ffffffff-0000-0000-0000-000000000000}";

long InitializeRegistryForCustom()
{
    SYSTEM_INFO SystemInfo;
    long        RegStatus;
    ulong       Disposition;
    HKEY        hInterface;
    HKEY        hClsidKey;
    HKEY        hActKey;
    HKEY        hActValueKey;
    WCHAR       Path[256];

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"Interface",
                              0,
                              KEY_ALL_ACCESS,
                              &hInterface );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hInterface,
                    StringIidIGoober,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hInterface,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hInterface,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)L"IGoober",
                    (wcslen(L"IGoober") + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hInterface,
                    L"ProxyStubClsid32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hInterface,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hInterface,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)ClsidGoober32String,
                    (wcslen(ClsidGoober32String) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidGoober32String,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hActKey,
                    L"InProcServer32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"goober.dll" );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (wcslen(Path) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return ERROR_SUCCESS;
}

long InitializeRegistryForRemote()
{
    long    RegStatus;
    ulong   Disposition;
    HKEY    hClsidKey;
    HKEY    hAppIDKey;
    HKEY    hThisClsidKey;
    HKEY    hActKey;
    HKEY    hActValueKey;
    WCHAR   Path[256];

    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActRemote
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActRemoteString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hThisClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActRemoteString,
                    (wcslen(ClsidActRemoteString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRemoteString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    HKEY_CLASSES_ROOT,
                    L"AppID",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hAppIDKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActRemoteString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"RemoteServerName",
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (wcslen(ServerName) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActAtStorage
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActAtStorageString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hThisClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActAtStorageString,
                    (wcslen(ClsidActAtStorageString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActAtStorageString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActAtStorageString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"ActivateAtStorage",
                    0,
                    REG_SZ,
                    (const BYTE *)L"Y",
                    (wcslen(L"Y") + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // CLSID_ActRunAsLoggedOnUser
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActRunAsLoggedOnString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActRunAsLoggedOnString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hThisClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActRunAsLoggedOnString,
                    (wcslen(ClsidActRunAsLoggedOnString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActRunAsLoggedOnString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"RemoteServerName",
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (wcslen(ServerName) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;
    
    RegStatus  = RegCreateKeyEx(
                    hThisClsidKey,
                    L"LocalServer32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"actsrv.exe 7" );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (wcslen(Path) + 1) * sizeof(WCHAR) );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"RunAs",
                    0,
                    REG_SZ,
                    (const BYTE *)L"Interactive User",
                    (wcslen(L"Interactive User") + 1) * sizeof(WCHAR) );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // RunAs CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
                    hClsidKey,
                    ClsidActPreConfigString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hThisClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActPreConfigString,
                    (wcslen(ClsidActPreConfigString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActPreConfigString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActPreConfigString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"RemoteServerName",
                    0,
                    REG_SZ,
                    (const BYTE *)ServerName,
                    (wcslen(ServerName) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    hThisClsidKey,
                    L"LocalServer32",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActValueKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"actsrv.exe 6" );

    RegStatus =  RegSetValueEx(
                    hActValueKey,
                    L"",
                    0,
                    REG_SZ,
                    (const BYTE *)Path,
                    (wcslen(Path) + 1) * sizeof(WCHAR) );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"RunAs",
                    0,
                    REG_SZ,
                    (const BYTE *)UserName,
                    (wcslen(UserName) + 1) * sizeof(WCHAR) );


    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if (!SetPassword(ClsidActPreConfigString, Password))
        return(FALSE);

    return ERROR_SUCCESS;
}

long InitializeRegistryForService()
{
    long    RegStatus;
    ulong   Disposition;
    HKEY    hClsidKey;
    HKEY    hAppIDKey;
    HKEY    hThisClsidKey;
    HKEY    hActKey;
    HKEY    hActValueKey;
    HKEY    hServices;
    WCHAR   Path[256];

    //
    // Get CLASSES_ROOT.
    //
    RegStatus = RegOpenKeyEx( HKEY_CLASSES_ROOT,
                              L"CLSID",
                              0,
                              KEY_ALL_ACCESS,
                              &hClsidKey );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegCreateKeyEx(
                    HKEY_CLASSES_ROOT,
                    L"AppID",
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hAppIDKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    //
    // Local CLSID entries.
    //

    RegStatus  = RegCreateKeyEx(
		    hClsidKey,
                    ClsidActServiceString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hThisClsidKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = SetAppIDSecurity( ClsidActServiceString );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus  = RegSetValueEx( 
                    hThisClsidKey,
                    L"AppID",
                    0,
                    REG_SZ,
                    (const BYTE *) ClsidActServiceString,
                    (wcslen(ClsidActServiceString)+1)*sizeof(WCHAR));

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    // if ( Disposition == REG_OPENED_EXISTING_KEY )
    //    return TRUE;

    RegStatus  = RegCreateKeyEx(
                    hAppIDKey,
                    ClsidActServiceString,
                    0,
                    L"REG_SZ",
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hActKey,
                    &Disposition );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    if ( ! GetModuleFileName( 0, Path, sizeof(Path) ) )
        return RegStatus;

    _wcslwr( Path );
    wcscpy( wcsstr( Path, L"actclt" ), L"actsrv.exe 8" );

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"LocalService",
                    0,
                    REG_SZ,
                    (const BYTE *)ServiceName,
                    (wcslen(ServiceName) + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus =  RegSetValueEx(
                    hActKey,
                    L"ActivateAtStorage",
                    0,
                    REG_SZ,
                    (const BYTE *)L"Y",
                    (wcslen(L"Y") + 1) * sizeof(WCHAR) );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    RegStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              L"SYSTEM\\CurrentControlSet\\Services",
                              0,
                              KEY_READ,
                              &hServices );

    if ( RegStatus != ERROR_SUCCESS )
        return RegStatus;

    return InstallService(Path);
}

DWORD InstallService( WCHAR * Path )
{
    SC_HANDLE hManager;
    SC_HANDLE hService;

    hManager = OpenSCManager( NULL,
                              NULL,
                              SC_MANAGER_ALL_ACCESS );

    if ( ! hManager )
    {
        printf( "OpenSCManager returned %d\n", GetLastError() );
        return GetLastError();
    }

    hService = OpenService( hManager,
                            ServiceName,
                            SERVICE_ALL_ACCESS );

    if ( ! hService )
    {
        hService = CreateService(
                        hManager,
                        ServiceName,
                        ServiceDisplayName,
                        SERVICE_ALL_ACCESS,
                        SERVICE_WIN32_OWN_PROCESS,
                        SERVICE_DEMAND_START,
                        SERVICE_ERROR_NORMAL,
                        Path,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        NULL);
    }

    if ( ! hService )
    {
        printf( "CreateService returned %d\n", GetLastError() );
        CloseServiceHandle(hManager);
        return GetLastError();
    }

    CloseServiceHandle(hService);
    CloseServiceHandle(hManager);
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\assert\wsprintf.c ===
/***
*sprintf.c - print formatted to string
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4wcsprintf() - print formatted data to wide character string
*	defines w4vwcsprintf() - print formatted output to a wide character
*				 string, get data from argument ptr instead
*				 of explicit args.
*******************************************************************************/

#define _W4WCSPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\assert\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       assert.cxx
//
//  Contents:   Debugging output routines for idsmgr.dll
//
//  Functions:  Assert
//              PopUpError
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//              30-Sep-93   KyleP       DEVL obsolete
//
//----------------------------------------------------------------------------

#pragma hdrstop

//
// This one file **always** uses debugging options
//

#if DBG == 1

// needed for CT TOM assert events trapping
#include <assert.hxx>

#include <stdarg.h>
#include <stdio.h>


# include <dprintf.h>            // w4printf, w4dprintf prototypes
# include <debnot.h>
# ifdef FLAT
#   include <sem.hxx>
#   include <dllsem.hxx>
# endif // FLAT

extern "C"
{

# ifdef FLAT
#  undef FAR
#  undef NEAR
# else
#  define MessageBoxA MessageBox
# endif

# include <windows.h>
}


extern BOOL gfService = FALSE;

unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:    12-Jul-91       AlexT   Created.
//              05-Sep-91       AlexT   Catch Throws and Catches
//              19-Oct-92       HoiV    Added events for TOM
//
//----------------------------------------------------------------------------


STDAPI_(void) Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage)
{
#if defined( FLAT )
    //
    // This code is for the CT Lab only.  When running in the lab,
    // all assert popups will be trapped and notifications will
    // be sent to the manager.  If running in the office (non-lab
    // mode), the event CTTOMTrapAssertEvent will not exist and
    // consequently, no event will be pulsed.
    //

    HANDLE hTrapAssertEvent,
           hThreadStartEvent;

    if (hTrapAssertEvent = OpenEvent(EVENT_ALL_ACCESS,
                                     FALSE,
                                     CAIRO_CT_TOM_TRAP_ASSERT_EVENT))
    {
        SetEvent(hTrapAssertEvent);

        //
        // This event is to allow TOM Manager time to perform
        // a CallBack to the dispatcher.
        //
        if (hThreadStartEvent = OpenEvent(EVENT_ALL_ACCESS,
                                          FALSE,
                                          CAIRO_CT_TOM_THREAD_START_EVENT))
        {
            //
            // Wait until it's ok to popup or until timed-out
            //
            WaitForSingleObject(hThreadStartEvent, TWO_MINUTES);
        }
    }
#endif

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
# ifdef FLAT
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
# else  // FLAT
        _asdprintf("%s File: %s Line: %u\n", szMessage, szFile, iLine);
# endif // FLAT
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
#ifdef FLAT
            DebugBreak();
#else
            _asm int 3;
#endif
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
#ifdef FLAT
        DebugBreak();
#else
        _asm int 3;
#endif
    }

}


//+------------------------------------------------------------
// Function:    SetWin4InfoLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global info level for debugging output
// Returns:     Old info level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4InfoLevel;
    Win4InfoLevel = ulNewLevel;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4InfoMask(unsigned long ulNewMask)
//
// Synopsis:    Sets the global info mask for debugging output
// Returns:     Old info mask
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4InfoMask(
    unsigned long ulNewMask)
{
    unsigned long ul;

    ul = Win4InfoMask;
    Win4InfoMask = ulNewMask;
    return(ul);
}


//+------------------------------------------------------------
// Function:    _SetWin4AssertLevel(unsigned long ulNewLevel)
//
// Synopsis:    Sets the global assert level for debugging output
// Returns:     Old assert level
//
//-------------------------------------------------------------

EXPORTIMP unsigned long APINOT
SetWin4AssertLevel(
    unsigned long ulNewLevel)
{
    unsigned long ul;

    ul = Win4AssertLevel;
    Win4AssertLevel = ulNewLevel;
    return(ul);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

STDAPI_(int) PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile)
{

    int id;
    static char szAssertCaption[128];
    static char szModuleName[128];

    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();
    char * pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }

    sprintf(szAssertCaption,"Process: %s File: %s line %u, thread id %d.%d",
        pszModuleName, szFile, iLine, pid, tid);


    DWORD dwMessageFlags = MB_SETFOREGROUND | MB_TASKMODAL |
                           MB_ICONEXCLAMATION | MB_OKCANCEL;

#ifndef _CHICAGO_
                     //  Since this code is also used by SCM.EXE, we pass
                     //  in the following flag which causes Service pop ups
                     //  to appear on the desktop correctly

    if (gfService)
    {
        dwMessageFlags |= MB_SERVICE_NOTIFICATION | MB_DEFAULT_DESKTOP_ONLY;
    }
#endif // _CHICAGO_

    id = MessageBoxA(NULL,(char *) szMsg, (LPSTR) szAssertCaption,
                     dwMessageFlags);

    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).  Oh well.

    return id;
}

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

//
// This semaphore is *outside* vdprintf because the compiler isn't smart
// enough to serialize access for construction if it's function-local and
// protected by a guard variable.
//
//    KyleP - 20 May, 1993
//

static CDLLStaticMutexSem mxs;

STDAPI_(void) vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs)
{
    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
#if defined( FLAT )
        mxs.Request();
        DWORD tid = GetCurrentThreadId();
        DWORD pid = GetCurrentProcessId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
#endif // FLAT
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
#ifdef FLAT
#if defined(_CHICAGO_)
                //
                //  Hex Process/Thread ID's are better for Chicago since both
                //  actually memory addresses.
                //
                w4dprintf( "%08x.%08x> ", pid, tid );
#else
                w4dprintf( "%d.%03d> ", pid, tid );
#endif
#endif // FLAT
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

#if defined( FLAT )
        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        mxs.Release();
#endif // FLAT
    }
}

#else

int assertDontUseThisName(void)
{
    return 1;
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\assert\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#if PTR_IS_INT
    #define get_ptr_arg(x) (void *)get_int_arg(x)
#elif PTR_IS_LONG
    #define get_ptr_arg(x) (void *)get_long_arg(x)
#else
    #error Size of pointer must be same as size of int or long
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x30, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif


/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd;         /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags;          /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth;       /* selected field with -- 0 means default */
    int fwide;
    int precision;      /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen;      /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output;      /* non-zero = prodcue no output for this specifier */
    char *text;         /* pointer text to be printed, not zero terminated */
    int textlen;        /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
            case 'L':
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
                break;
#endif

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    textlen = strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int)(pwc - (wchar_t *) text);  /* length of string */
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int)(p - text);    /* length of the string */
                }
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;


#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_LONG;       /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */

                /* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int)((char *)&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif



/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\act\tstsvc\service.cxx ===
BOOL TimeStartService(WCHAR * wszServiceName, WCHAR *pwszRegServiceArgs, HANDLE *phProcess)
{
    SC_HANDLE hSCManager;
    SC_HANDLE hService;
    WCHAR    *pwszServiceArgs = NULL;
    ULONG     cArgs = 0;
    WCHAR    *apwszArgs[MAX_SERVICE_ARGS];

    *phProcess = NULL;

    // Get a handle to the Service Control Manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_EXECUTE))
    {
        // Open a handle to the requested service
        if (hService = OpenService(hSCManager, wszServiceName, GENERIC_EXECUTE))
        {
            // Close the service manager's database
            CloseServiceHandle(hSCManager);

            // Formulate the arguments (if any)
            if (pwszRegServiceArgs)
            {
                UINT   k = 0;

                // Make a copy of the service arguments
                pwszServiceArgs = (WCHAR *) PrivMemAlloc(
                        (lstrlenW(pwszRegServiceArgs) + 1) * sizeof(WCHAR));
                if (pwszServiceArgs == NULL)
                {
                    CloseServiceHandle(hService);
                    return FALSE;
                }
                lstrcpyW(pwszServiceArgs, pwszRegServiceArgs);

                // Scan the arguments
                do
                {
                    // Scan to the next non-whitespace character
                    while(pwszServiceArgs[k]  &&
                          (pwszServiceArgs[k] == L' '  ||
                           pwszServiceArgs[k] == L'\t'))
                    {
                        k++;
                    }

                    // Store the next argument
                    if (pwszServiceArgs[k])
                    {
                        apwszArgs[cArgs++] = &pwszServiceArgs[k];
                    }

                    // Scan to the next whitespace char
                    while(pwszServiceArgs[k]          &&
                          pwszServiceArgs[k] != L' '  &&
                          pwszServiceArgs[k] != L'\t')
                    {
                        k++;
                    }

                    // Null terminate the previous argument
                    if (pwszServiceArgs[k])
                    {
                        pwszServiceArgs[k++] = L'\0';
                    }
                } while(pwszServiceArgs[k]);
            }

            // Start the service
            if (StartService(hService, cArgs,
                               cArgs > 0 ? (LPCTSTR  *) apwszArgs : NULL))
            {
                CloseServiceHandle(hService);
                PrivMemFree(pwszServiceArgs);
                return TRUE;
            }
            else
            {
                CloseServiceHandle(hService);
                PrivMemFree(pwszServiceArgs);
            }
        }
        else
        {
            CloseServiceHandle(hSCManager);
        }
    }

    DWORD err = GetLastError();
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\cairo.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

MAJORCOMP   = oletest
MINORCOMP   = com

OLEDIR=       $(BASEDIR)\private\ole32
OLEUTESTDIR=  $(BASEDIR)\private\oleutest

INCLUDES=     ..\;($BASEDIR)\cinc;$(OLEUTESTDIR)\oleprx32\proxy
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\common

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
	      -DUNICODE 	    \
              -D_UNICODE            \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
	      -DWIN32=300	    \
              -D_NT1X_=100          \
	      -DCAIROLE_DOWNLEVEL   \
	      -D_CAIRO_=300	    \
	      -D_DCOM_		    \
	      -DTHREADING_SUPPORT   \
              $(TRACELOG)

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

CAIRO_PRODUCT=1

USE_MSVCRT=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\chicago.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=200           \
              -D_CHICAGO_=200       \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -DCAIROLE_DOWNLEVEL   \
              $(TRACELOG)

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

USE_MSVCRT=1

OLEDIR=       $(BASEDIR)\private\ole32
OLEUTESTDIR=  $(BASEDIR)\private\oleutest
OLEBALLSDIR=  $(BASEDIR)\private\oleutest\balls
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\assert\printf.h ===
/***
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 WIN32
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*
*******************************************************************************/

#include <windows.h>
#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include "w4io.h"

#if defined(_W4PRINTF_)
    static HANDLE fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy = 0;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == INVALID_HANDLE_VALUE)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = GetStdHandle(ldummy)) == 0 || fh == INVALID_HANDLE_VALUE)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef WIN32
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if (cch = (int)(f->pchbuf - f->pchstart))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugString(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\daytona.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=100           \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE            \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -DCAIROLE_DOWNLEVEL   \
              $(TRACELOG)

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

USE_MSVCRT=1

OLEDIR=       $(BASEDIR)\private\ole32
OLEUTESTDIR=  $(BASEDIR)\private\oleutest
OLEBALLSDIR=  $(BASEDIR)\private\oleutest\balls
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\types.inc ===
MAJORCOMP=cairo
MINORCOMP=types

PASS0_HEADERDIR = $(BASEDIR)\public\sdk\inc
PASS0_SOURCEDIR = ..\oleprx32\proxy
MIDL_UUIDDIR = ..\oleprx32\uuid

C_DEFINES= -DWIN32=300 -D_CAIRO_=300

TARGETPATH=obj
TARGETTYPE=NOTARGET

SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the general build options for this subtree.

!ENDIF

MAJORCOMP   = oletest
MINORCOMP   = com

!include      ..\..\..\daytona.inc

INCLUDES=     ;..;$(OLEBALLSDIR)\common;
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\daytona

UMTYPE=       windows
UMENTRY=      winmain
UMAPPL=
UMTEST=

UMLIBS=       $(OLEBALLSDIR)\common\daytona\$(O)\servers.lib	\
	      $(OLEUTESTDIR)\balls\oleprx32\uuid\daytona\$(O)\uuid.lib	   \
	      $(OLEDIR)\common\daytona\$(O)\common.lib	   \
	      $(SDK_LIB_PATH)\uuid.lib	   \
	      $(SDK_LIB_PATH)\ole32.lib	   \
              $(SDK_LIB_PATH)\rpcrt4.lib       \
              $(SDK_LIB_PATH)\rpcns4.lib       \
              $(SDK_LIB_PATH)\mpr.lib          \
              $(SDK_LIB_PATH)\netapi32.lib     \
              $(SDK_LIB_PATH)\kernel32.lib     \
	      $(SDK_LIB_PATH)\user32.lib	   \
	      $(SDK_LIB_PATH)\gdi32.lib	   \
	      $(SDK_LIB_PATH)\advapi32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\cfrace\cfrace.h ===
#ifndef __CFRACE_H__
#define __CFRACE_H__

BOOL TestCFRace(void);

#endif // __CFRACE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\cfrace\main.cxx ===
//+------------------------------------------------------------------
//
// File:	main.cxx
//
// Contents:	common entry point for test drivers.
//
//--------------------------------------------------------------------
#include    <tstmain.hxx>
#include    <cfrace.h>

//+-------------------------------------------------------------------
//
//  Function:	main
//
//  Synopsis:	Entry point to EXE
//
//  Returns:    TRUE
//
//  History:	21-Nov-92  Rickhi	Created
//
//  Just delegates to a <main> subroutine that is common for all test
//  drivers.
//
//--------------------------------------------------------------------
int _cdecl main(int argc, char **argv)
{
    return DriverMain(argc, argv, "Class Factory Race", &TestCFRace);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\makefile.inc ===
############################################################################
#
#   Microsoft Windows
#   Copyright (C) Microsoft Corporation, 1991 - 1992.
#
#   File:       makefile.inc
#
#   Contents:   Main project makefile
#
#   History:
#
#
############################################################################

#**     Make include file
#
#       Definitions for compiler
#
#       GCFLAGS - additional flags for the C compiler, intended only
#                 to be used for global changes.  DONT EVER PUT THIS
#                 IN A MAKEFILE.
#       GAFLAGS - Same as GCFLAGS, but for the assembler.
#
#
# -------------------- Build Type Control ------------------------------------
#
# The "build type" determines what kind of internal checking is done.
# Turning on checking allows for catching more internal
# consistency errors, but slows the system down.
#
# Mechanically, one changes the build type the makefile is set for by
# editing the makefile to comment in or out the OBFLAGS line of interest.
# (Separate entry points cannot easily be used for this, this is a failing
#  of make.  That's why you have to edit the makefile.)
#
#

############################################################################
#
#   Default target is "all"
#

default: all

############################################################################
#
#   Suffixes for inference rules
#

.SUFFIXES:
.SUFFIXES: .idl .tdl .tlb .dll .h .inc .exe .obj .lst .cod .cxx .cpp
.SUFFIXES: .c .s  .lrf .lnk .map .sym .rc .lib .def .res .dgn .rtf .y .mc
.SUFFIXES: .i .ico .bmp .dlg .cur .cx2 .c2 .rc2  .hxx .pas .for .cbl .bas

##################################################
#       TGTDIR, OBJDIR selection
#
# Each build type stores obj files and built binaries in a different
# directory below the source or distribution tree.  Current directory
# naming convention is:
#
#    TGTDIR=OBJ<p><o><b>
#    OBJDIR=OBJ<p><o><b>
#
#    <p>:  i = i386
#          m = MIPS
#          a = ALPHA
#          2 = i286
#
#    <o>:  d = DOS
#          1 = NT 1.x
#          n = NT 2.0 (Cairo)
#          o = OS/2
#          w = Win16 (used when targeting Win32s)
#
#    <b>:  r = Retail
#          d = Debug
#          p = Profile (Retail with debug info)
#          <Nothing> = Release
#
# TGTEXT/RDEXT selection for MULTIDEPEND != ""
# Each build type stores depend.mk files with a different last character
# in the extension, as in "mk?".  Current extension convention is:
#    <1>:  NT 2.0 x86
#    <3>:  Chicago
#    <5>:  NT 2.0 MIPS
#    <7>:  NT 2.0 Alpha
#    <9>:  Win 3.1
#    <a>:  Dos 5.0
#    <c>:  OS/2 1.x
#    <e>:  NTKERNEL x86
#    <g>:  NTKERNEL MIPS
#    <h>:  NTKERNEL Alpha
#    <j>:  Win32s
#    <k>:  NT 1.x x86
#    <l>:  NT 1.x MIPS
#    <m>:  NT 1.x Alpha
#
# As you can see the scheme gets a bit cumbersome, so if you define
# MULTIDEPEND == MERGED then similar systems use the same letter, so:
#    <1>:  NT 2.0 all
#    <3>:  NT 1.x all, Chicago, Win32s
#    <9>:  Win 3.1
#    <a>:  Dos 5.0
#    <c>:  OS/2 1.x
#    <e>:  NTKERNEL all

OBJDIR=
TGTDIR=
TGTEXT=
RDEXT=

# set BUILDTYPE based on NTDEBUG setting
# bugbug need to base on settings in makefile.def
#

!if "$(NTDEBUG)" == "retail"
BUILDTYPE=RELEASE
!else
!if "$(NTDEBUG)" == "ntsdnodbg"
BUILDTYPE=RELEASE
!else
BUILDTYPE=DEBUG
!endif
!endif

!ifndef _NTROOT
_NTROOT=\nt
!endif

!ifndef BASEDIR
BASEDIR=$(_NTDRIVE)$(_NTROOT)
!endif

!if   "$(OPSYS)"==""
OPSYS=NT
!endif

!if     "$(PROCESSOR_ARCHITECTURE)" == "x86"
PLAT = i
PLATFORM=I386
!elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"
PLAT = m
PLATFORM=MIPS
!elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
PLAT = a
PLATFORM=ALPHA
!else
!error Unknown PROCESSOR_ARCHITECTURE setting "$(PROCESSOR_ARCHITECTURE)"
!endif

!if     "$(BUILDTYPE)" == "DEBUG"
BLDT = d
!elseif "$(BUILDTYPE)" == "RETAIL"
BLDT = r
!elseif "$(BUILDTYPE)" == "PROFILE"
BLDT = p
!elseif "$(BUILDTYPE)" == "RELEASE"
BLDT =
!else
!error Unknown BUILDTYPE setting "$(BUILDTYPE)"
!endif

# DavidBak hack
!if     "$(PERFSNAP)" == "1"
BLDT = p
!endif

!if     "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
OPST = n
!elseif "$(OPSYS)" == "DOS"
OPST = d
!elseif "$(OPSYS)" == "DOS5"
OPST = 5
!elseif "$(OPSYS)" == "OS2"
OPST = o
!elseif "$(OPSYS)" == "WIN16"
OPST = w
!elseif "$(OPSYS)" == "NT1X"
OPST = 1
!else
!error Unknown OPSYS setting "$(OPSYS)"
!endif

OBJDIR = OBJ\$(PLATFORM)
TGTDIR = OBJ\$(PLATFORM)

!if "$(MULTIDEPEND)" == "MERGED"
! if     "$(OPSYS)" == "NT"
DEXT = 1
! endif
!else # !MERGED
! if "$(OPSYS)" == "NT"
PLATDIR=DAYTONA
!  if     "$(PROCESSOR_ARCHITECTURE)" == "x86"
DEXT = 1
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"
DEXT = 5
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
DEXT = 7
!  endif
! elseif "$(OPSYS)" == "NTKERNEL"
!  if     "$(PROCESSOR_ARCHITECTURE)" == "x86"
DEXT = e
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"
DEXT = g
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
DEXT = h
!  endif
! elseif "$(OPSYS)" == "DOS" && "$(PROCESSOR_ARCHITECTURE)" == "i286"
DEXT = 9
! elseif "$(OPSYS)" == "DOS5"
DEXT = a
! elseif "$(OPSYS)" == "OS2"
DEXT = c
! elseif "$(OPSYS)" == "NT1X"
PLATDIR=DAYTONA
!  if     "$(PROCESSOR_ARCHITECTURE)" == "x86"
DEXT = k
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"
DEXT = l
!  elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
DEXT = m
!  endif
! elseif "$(PROCESSOR_ARCHITECTURE)" == "x86" && "$(OPSYS)" == "WIN16"
DEXT = j
! elseif "$(PROCESSOR_ARCHITECTURE)" == "x86" && "$(OPSYS)" == "DOS"
DEXT = 3
! endif
!endif

#bugbug, what about chicago platform

RDEXT  = $(DEXT)
TGTEXT = $(DEXT)

####################################################################################
#
#
#
#

RELEASE_BIN=

!IFDEF NTDBGFILES
!   IF "$(PROCESSOR_ARCHITECTURE)" == "x86"
BINPLACE_FLAGS=-s $(_NT386TREE)\Symbols
!   ELSE
!   IF "$(PROCESSOR_ARCHITECTURE)" == "MIPS"
BINPLACE_FLAGS=-s $(_NTMIPSTREE)\Symbols
!       ELSE
!   IF "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
BINPLACE_FLAGS=-s $(_NTALPHATREE)\Symbols
!           ENDIF
!       ENDIF
!   ENDIF
!ELSE
BINPLACE_FLAGS=
!ENDIF

# The xxxTREE macros are set in the razzle cmd window.
# for cairo builds cairoxxxxxx macros will be set.

!ifdef CAIRO_PRODUCT
!ifdef _CAIROMIPSTREE
_NTMIPSTREE=$(_CAIROMIPSTREE)
!endif

!ifdef _CAIRO386TREE
_NT386TREE=$(_CAIRO386TREE)
!endif

!ifdef _CAIROALPHATREE
_NTALPHATREE=$(_CAIROALPHATREE)
!endif
!endif

!ifdef _NTMIPSTREE
RELEASE_BIN=TRUE
!endif

!ifdef _NT386TREE
RELEASE_BIN=TRUE
!endif

!ifdef _NTALPHATREE
RELEASE_BIN=TRUE
!endif

!ifndef BUILDDETAIL
BUILDDETAIL = quiet
!endif

!if "$(BUILDDETAIL)" == "FULL" || "$(BUILDDETAIL)" == "full"
COMPLOGO =
COMPRESP = KEEP
LINKLOGO =
LINKRESP = KEEP
!endif

!if "$(BUILDDETAIL)" == "KEEPCOMP" || "$(BUILDDETAIL)" == "keepcomp"
COMPLOGO =
COMPRESP = KEEP
LINKLOGO = -nologo
LINKRESP = NOKEEP
!endif

!if "$(BUILDDETAIL)" == "KEEPLINK" || "$(BUILDDETAIL)" == "keeplink"
COMPLOGO = -nologo
COMPRESP = NOKEEP
LINKLOGO =
LINKRESP = KEEP
!endif

!if "$(BUILDDETAIL)" == "QUIET" || "$(BUILDDETAIL)" == "quiet"
COMPLOGO = -nologo
COMPRESP = NOKEEP
LINKLOGO = -nologo
LINKRESP = NOKEEP
!endif

!if "$(NOLOGOS)" != ""
COMPLOGO = -nologo
LINKLOGO = -nologo
!endif

######################################################################
#       Destination for messages

!ifdef NOTIME
TIMESTR=
ATSTR=
!else
TIMESTR=/H:M:S
ATSTR=at
!endif

!ifndef OUTPUT
! ifdef BUILDQUIET
OUTPUT=    >nul
! else
OUTPUT=
! endif
!endif

#
# DOS doesn't let us redirect stderr output, so we use the following define
# to unify our output.
#

!if "$(HOST)" != "DOS"
OUTNUL= 1>nul 2>nul
!else
OUTNUL=
!endif

!ifndef OUTFIX
OUTFIX = $(OUTNUL)
!endif

######################################################################
#
# Set location to locate tools

# Empty toolpath so it can be used to check for invalid host type
TOOLPATH=
SDKTOOLPATH=

!if "$(HOST)" == ""
HOST = NT
!endif

HOSTBIN  = .

######################################################################
#
# Set location to copy include files

HCOPY= ..\oleprx32\daytona
LIBCP=
SEDHCOPY= ..\oleprx32\daytona

######################################################################
#
# Misc tool defines

AWK=      awk.exe
CAT=      cat.exe
CHMODE=   chmode.exe
CLASSGEN= classgen
CMP=      fcom.exe
COFF=     link32
COPY=     copy /v
CP=       $(COPY)
CTCOPY=   xcopy /v /i
CVPACK=   cvpack.exe
DEL=      del
CVTRES=   cvtres.exe
DOCGEN=   docgen.exe
ECH=      ech.exe
ECHOTIME= echotime
FLEX=     flex.exe
GENLRF=   genlrf.exe
GENORD=   genord.exe
IN=       $(SLMTOOLS)\in.exe
INCLUDES= includes.exe
MAPSYM=   mapsym.exe
MC=       mc.exe
MIDL=	  midl
MKHEADER= mkheader
MKTMPLAT= mktmplat
MKTYPLIB= mktyplib
MUNGE=    munge.exe
OUT=      out.exe
RC=       rc
REGTLB=   regtlb.exe
SED=      sed.exe
SIFTTOOL= sifttool.exe
SORT=     sort.exe
SPLITSYM= splitsym.exe
TOUCH=    touch.exe
UNIQ=     uniq.exe
UNREGTLB= unregtlb.exe
YACC=     yacc.exe

IMPORTNT = $(SDK_PATH)


TYPESDIR = $(BASEDIR)\private\oleutest\balls
SCRIPTS =  $(BASEDIR)\private\oleutest\balls

CAIROINC = $(BASEDIR)\private\cinc

BASEINC  =$(TYPESDIR)\idl

PROXYINC =$(TYPESDIR)\oleprx32\$(PLATDIR)

############################################################################
#
#   Object files and resource files
#

CXX_OBJS=$(CXXFILES:.cxx=.obj)
CXX_OBJS=$(CXX_OBJS) $(CPPFILES:.cpp=.obj)
C_OBJS=$(CFILES:.c=.obj)
RESFILES = $(RCFILES:.rc=.res)
TYPELIBS = $(TDLFILES:.tdl=.tlb)
MKHDR_H_FILES = $(TDLFILES:.tdl=.h)
MKHDR_C_FILES = $(TDLFILES:.tdl=.c)
MIDL_INCS=$(IDLFILES:.idl=.h)
MIDL_PROXYS=$(IDLFILES:.idl=.h)

#   Hack alert:
#
#   We want to use $(OBJDIR) in the replacement string, like this:
#
#       CXX_OBJS = $(CXX_OBJS:.\=$(OBJDIR)\)
#
#   Unfortunately, nmake wants no part of it.  As a workaround, we test for
#   each known value of $(OBJDIR) and perform the individual substitution
#   for each.

!if "$(MKHEADER_OUT_DIR)"==""
MKHEADER_OUT_DIR=$(TYPESDIR)\oleprx32\$(PLATDIR)\
!endif

!if "$(MIDL_OUT_DIR)"==""
MIDL_PROXYS=$(MIDL_PROXYS:.\=..\oleprx32\daytona\)
MIDL_INCS=$(MIDL_INCS:.\=..\oleprx32\daytona\)
MKHDR_H_FILES=$(MKHDR_H_FILES:.\=..\oleprx32\daytona\)
MKHDR_C_FILES=$(MKHDR_C_FILES:.\=..\oleprx32\daytona\)
MIDL_HDR_OUT_DIR=..\oleprx32\daytona
!else
MIDL_INCS=$(MIDL_INCS:.\=..\oleprx32\daytona\)
MIDL_HDR_OUT_DIR=..\oleprx32\daytona
!endif

!if "$(MIDL_OUT_DIR)"==""
MIDL_OUT_DIR=..\oleprx32\$(PLATDIR)
MIDL_HDR_OUT_DIR=..\oleprx32\daytona
!endif

!if "$(OBJDIR)" == "OBJ\I386"
CXX_OBJS = $(CXX_OBJS:.\=.\OBJ\I386\)
C_OBJS   = $(C_OBJS:.\=.\OBJ\I386\)
RESFILES = $(RESFILES:.\=OBJ\I386\)
TYPELIBS = $(TYPELIBS:.\=.\OBJ\i386\)

! elseif "$(OBJDIR)" == "OBJ\MIPS"
CXX_OBJS = $(CXX_OBJS:.\=.\OBJ\MIPS\)
C_OBJS   = $(C_OBJS:.\=.\OBJ\MIPS\)
RESFILES = $(RESFILES:.\=OBJ\MIPS\)
TYPELIBS = $(TYPELIBS:.\=.\OBJ\MIPS\)

! elseif "$(OBJDIR)" == "OBJ\ALPHA"
CXX_OBJS = $(CXX_OBJS:.\=.\OBJ\ALPHA\)
C_OBJS   = $(C_OBJS:.\=.\OBJ\ALPHA\)
RESFILES = $(RESFILES:.\=OBJ\ALPHA\)
TYPELIBS = $(TYPELIBS:.\=.\OBJ\ALPHA\)

! else
! error Unknown object directory: $(OBJDIR)

!endif  # $(OBJDIR)

############################################################################
#       Rules for generating .h, and .rc files from .mc files.
#
#
#
#

# bugbug, what about chicago builds?
# bugbug, maybe we should use other variable besides
# MIDL_OUT_DIR to determine which directory to generate
# message flies in.

!if "$(MESSAGE_FILES)" != ""

MCRESOURCE=$(MESSAGE_FILES:.mc=.rc)

MESSAGE_H_FILES=$(MESSAGE_FILES:.mc=.h)

!if "$(PLATDIR)" == "DAYTONA"
MESSAGE_H_FILES=$(MESSAGE_H_FILES:.\=..\..\..\..\public\sdk\inc\)
MC_OUT_DIR=..\..\..\..\public\sdk\inc
!endif

!if "$(OBJDIR)" == "OBJ\I386"
MCRESOURCE = $(MCRESOURCE:.\=.\OBJ\I386\)
!elseif "$(OBJDIR)"== "OBJ\MIPS"
MCRESOURCE = $(MCRESOURCE:.\=.\OBJ\MIPS\)
!elseif "$(OBJDIR)"== "OBJ\ALPHA"
MCRESOURCE = $(MCRESOURCE:.\=.\OBJ\ALPHA\)
!else
!error Uknown object directory : $(OBJDIR)
!endif

MCBIN= $(OBJDIR)\msg00001.bin

all: $(MESSAGE_H_FILES)

.mc{$(MC_OUT_DIR)}.h:
    @echo Building $< $(OUTPUT)
    @-md $(OBJDIR) $(OUTNUL)
    $(MC) $(MCFLAGS) $<  -h $(HCOPY) $(OUTPUT)
!if "$(OPSYS)"=="NT1X" && "$(NORELEASE_CHICAGO)"==""
    @-md $(HCOPY)\chicago $(OUTNUL)
    @echo Build_Status Releasing $(@B).h files to $(HCOPY)\chicago
    $(COPY) $(HCOPY)\$(@B).h  $(HCOPY)\chicago $(OUTNUL)
!endif

clean:  cleancomp
        -$(DEL)   $(MESSAGE_H_FILES:.mc=.h)  $(MCRESOURCE)  $(MCBIN) $(OUTNUL)

!endif

############################################################################
#
#       Rules for generating .tlb, .hxx and .cxx files from .tdl files
#       These should be before any target rules, to force code
#       generation before compiling.
#

!if "$(TDLFILES)" != ""

all: $(TYPELIBS)

.tdl{$(OBJDIR)}.tlb:
        @-md $(OBJDIR) $(OUTNUL)
        $(MKTYPLIB) $(MKTYPLIBFLAGS) $(CINC) $(TLBDIRS) -tlb$@ $<
        $(MKHEADER) $(MKHEADERFLAGS) -o $(HCOPY)\$(@B).h -u $(MKHEADER_OUT_DIR)\$(@B).c -x $(@)
        $(REGTLB) $@

$(TDLFILES): $(IDLFILES)

DEPENDFILES = $(TYPELIBS) $(MKHDR_H_FILES) $(MKHDR_C_FILES) $(DEPENDFILES)

TYPELIBS = $(TYPELIBS:.\=)

CLEANFILES = $(CLEANFILES) $(TYPELIBS) $(MKHDR_H_FILES) $(MKHDR_C_FILES)

!endif

############################################################################
#
#   Generate .h and .c files from .idl files
#                  1

# NOTE: this rule should appear before any target rules, to force
# idl-to-h translation to happen first.

!if "$(IDLFILES)" != ""

all: $(MIDL_INCS)

clean: cleanidl

#
# Due to command line limitations (yes, even NT has them), we write a script
#  to delete the idl output files.
#

cleanidl:
    @type << | $(SED) -f << > idlclean.bat
$(MIDL_INCS:.h=.h
)
$(MIDL_PROXYS:.h=_?.c
)
$(MIDL_PROXYS:.h=_?.cxx
)
$(MIDL_PROXYS:.h=_?.h
)
$(MIDL_PROXYS:.h=_?.hxx
)
<<NOKEEP
1i\
\@echo off \
\@echo Build_Status Deleting MIDL output files...
/\./!d
s/^/del /g
s/$$/ $(OUTNUL)/g
<<NOKEEP
    @-idlclean.bat
    @-$(DEL) idlclean.bat $(OUTNUL)

DEPENDFILES = $(DEPENDFILES) $(MIDL_INCS)

!endif # IDLFILES

##################################################################
#
# Rules to build the composite .h file from midl generated files                                                                                                                                                                                      #
#
#

!if "$(ITFS_BASE)" !=  "" && "$(ITFS_DIR)" != ""
ITFS_H = $(ITFS_BASE).h

all: $(ITFS_DIR)\$(ITFS_H)

$(ITFS_DIR)\$(ITFS_H): $(MIDL_INCS) $(ITFS_BASE).x $(ITFS_BASE).y
     @echo Build_Status Building $(ITFS_DIR)\$(ITFS_H) ...
     @del $(ITFS_DIR)\$(ITFS_H) $(OUTNUL)
#
#  Add the file header and base #includes.
#

     @type $(ITFS_BASE).x >> $(ITFS_DIR)\$(ITFS_H)
     @echo @echo off > copyall.cmd
     @echo cd $(ITFS_DIR)\  >> copyall.cmd
     @type << | $(SED) -f << >> copyall.cmd
$(BASE_HFILES: =
)
<<NOKEEP
/\./!d
s/\.\\//g
s/^/\@sed -e \"\/^\#include\/d\" -e \"\/\\\/\\\/  File\\\:\/d" /g
s/$$/ \>\> $(ITFS_H)/g
<<NOKEEP
     @echo cd $(MAKEDIR) >> copyall.cmd
     @copyall.cmd
     @del copyall.cmd
#
#  Copy the initial forward declarations from all the derived h files.
#
     @type << >> $(ITFS_DIR)\$(ITFS_H)

// Forward declarations for typedefs in this file
<<NOKEEP
     @type << > $(ITFS_DIR)\forward.sed
/\/\* Forward Declarations \*\// {
N
s/\/\* Forward Declarations \*\/\ntypedef/xtypedef/
}
/xtypedef/!d
s/xtypedef/typedef/
<<NOKEEP

     @echo @echo off > forward.cmd
     @echo cd  $(ITFS_DIR) >> forward.cmd
     @type << | $(SED) -f << >> forward.cmd
$(DERIVED_HFILES: =
)
<<NOKEEP
/\./!d
s/\.\\//g
s/^/\@sed -f forward.sed /g
s/$$/ \>\> $(ITFS_H)/g
<<NOKEEP
     @echo cd $(MAKEDIR) >> forward.cmd
     @forward.cmd
     @del forward.cmd
     @del $(ITFS_DIR)\forward.sed $(OUTNUL)
#
#  Copy the derived h files in.  Strip off any #includes along the way.
#

     @echo @echo off > copyall.cmd
     @echo cd $(ITFS_DIR)\  >> copyall.cmd
     @type << | $(SED) -f << >> copyall.cmd
$(DERIVED_HFILES: =
)
<<NOKEEP
/\./!d
s/\.\\//g
s/^/\@sed -e \"\/^\#include\/d\" -e \"\/\\\/\\\/  File\\\:\/d" /g
s/$$/ \>\> $(ITFS_H)/g
<<NOKEEP
     @echo cd $(MAKEDIR) >> copyall.cmd
     @copyall.cmd
     @del copyall.cmd
#
#  Append API prototypes to the end of the file
#
     @type $(ITFS_BASE).y >> $(ITFS_DIR)\$(ITFS_H)
#
#  Finally, close the file #ifdef
#

     @type << >> $(ITFS_DIR)\$(ITFS_H)
#ifndef RC_INVOKED
#pragma pack()
#endif // RC_INVOKED
#endif     // __$(ITFS_BASE)_H__
<<NOKEEP

!if "$(OPSYS)"=="NT1X" && "$(NORELEASE_CHICAGO)" == ""
     @echo "Releaseing composite .h file for Chicago" $(OUTPUT)
     $(COPY) $(ITFS_DIR)\$(ITFS_BASE).h  $(HCOPY)\chicago
!endif
!endif # ITFS_BASE

##################################################################
#
# Rules to build the composite .h file from mc generated files                                                                                                                                                                                      #
#
#

!if "$(MCERRS_BASE)" !=  "" && "$(MCERRS_DIR)" != ""
MCERRS_H = $(MCERRS_BASE).h

all: $(MCERRS_DIR)\$(MCERRS_H)

$(MCERRS_DIR)\$(MCERRS_H): $(MESSAGE_FILES)
     @echo Build_Status Building $(MCERRS_DIR)\$(MCERRS_H) ...
     @del $(MCERRS_DIR)\$(MCERRS_H) $(OUTNUL)
#
#  Add the file header and base #includes.
#

     @echo @echo off > copyall.cmd
     @echo cd $(MCERRS_DIR)\  >> copyall.cmd
     @type << | $(SED) -f << >> copyall.cmd
$(MESSAGE_FILES:.mc=.h
)
<<NOKEEP
/\./!d
s/\.\\//g
s/^/\@sed  -e \"\/\\\/\\\/      File\\\:\/d" /g
s/$$/ \>\> $(MCERRS_H)/g
<<NOKEEP
     @echo cd $(MAKEDIR) >> copyall.cmd
     @copyall.cmd
     @del copyall.cmd

!if "$(OPSYS)"=="NT1X" && "$(NORELEASE_CHICAGO)" == ""
     @echo "Releaseing composite .h file for Chicago" $(OUTPUT)
     $(COPY) $(MCERRS_DIR)\$(MCERRS_BASE).h  $(HCOPY)\chicago
!endif

cleancomp:
     @del $(MCERRS_DIR)\$(MCERRS_H)

!endif

############################################################################
#
#   Determine target type (DLL, EXE, or LIB)
#

!ifdef TARGET

TARGET = $(TARGET:.\=)

CLEANTARGET=    $(CLEANTARGET) $(TGTDIR)\$(TARGET)

#
#   Is it a DLL?
#

TARGETBASE=$(TARGET:.dll=)
! if "$(TARGETBASE)" != "$(TARGET)"
all: $(YACCFILES:.y=.h) $(TGTDIR)\$(TARGET) copy
TARGETTYPE=dll
DLLFILES=       $(DLLFILES) $(TGTDIR)\$(TARGET)
! else

#
#   Is it an EXE?
#

TARGETBASE=$(TARGET:.exe=)
!  if "$(TARGETBASE)" != "$(TARGET)"
all: $(YACCFILES:.y=.h) $(TGTDIR)\$(TARGET) copy
TARGETTYPE=exe
EXEFILES=       $(EXEFILES) $(TGTDIR)\$(TARGET)
!  else

#
#   Is it a LIB?
#

TARGETBASE=$(TARGET:.lib=)
!   if "$(TARGETBASE)" != "$(TARGET)"
all: $(YACCFILES:.y=.h) $(OBJDIR)\$(TARGET) copy
TARGETTYPE=lib
!    if "$(DEFFILE)" == ""
NO_IMPLIB= TRUE
!    endif
!   else

#
#   This is a special target used when we have files to RELEASE
#   but nothing to actually build.
#

!       if "$(TARGET)" == "RELEASE"
all:
!       else

#
#   We don't know what it is.
#

!        error Unrecognized target type: $(TARGET)
!       endif  # !RELEASE
!   endif  # !.lib
!  endif  # !.exe
! endif  # !.dll
!endif  # TARGET
#
#   If no name was given for a DEF file, make one up.
#

DEFEXT = f

!ifndef DEFBASE
DEFBASE = $(TARGETBASE)
!endif

!ifndef DEFFILE
DEFFILE=$(DEFBASE).def
!endif

!if "$(NO_IMPLIB)" == ""
DEFFILELIB = $(OBJDIR)\$(DEFBASE).lib
DEFFILEEXP = $(OBJDIR)\$(DEFBASE).exp
!endif


######################################################################
#       Make sure INCLUDE and LIB are null.

INCLUDE=
LIB=

######################################################################
#       Independent definitions for C compiler,  LINK

CFLAGS=  $(CFLAGS) -D_WINDOWS -ZB64

# The 16 bit OLE DOCFILE libraries do not want UNICODE defined.

!ifndef NO_UNICODE
! if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NT1X" || "$(OPSYS)" == "NTKERNEL"
CFLAGS = $(CFLAGS) -DUNICODE -D_UNICODE
! endif
!endif

CINC=    -I. $(CINC)

CINC=	 $(CINC) -I$(TYPESDIR)\oleprx32\$(PLATDIR)
CINC=    $(CINC) -I$(CAIROINC) -I$(BASEINC)


######################################################################
#       Debug/Retail definitions
#
# These are hardware independant debug/retail flags
#

# NOTE:  NT kernel include files require that DBG be defined.
!if "$(BUILDTYPE)" == "DEBUG"
CDEBUGFLAGS = $(CDEBUGFLAGS) -DDBG=1 -DDEVL=1
!elseif "$(BUILDTYPE)" == "RETAIL"
CDEBUGFLAGS = $(CDEBUGFLAGS) -DDBG=0 -DDEVL=1
!else
CDEBUGFLAGS = $(CDEBUGFLAGS) -DDBG=0 -DDEVL=0
!endif

CFLAGS = $(CFLAGS) $(CDEBUGFLAGS)

######################################################################
#
#       Generic Definitions
#

COMMON_LIBS = $(SDK_LIB_DEST)\$(PLATFORM)

CAIROLIB    = $(COMMON_LIBS)\commnot.lib\
              $(COMMON_LIBS)\compob32.lib\
              $(COMMON_LIBS)\storag32.lib\
              $(COMMON_LIBS)\propset.lib\
              $(COMMON_LIBS)\ole232.lib\
              $(COMMON_LIBS)\lnktrack.lib\
              $(TYPESDIR)\oleprx32\$(PLATDIR)\$(OBJDIR)\uuid.lib\
              $(COMMON_LIBS)\change.lib\
              $(COMMON_LIBS)\events.lib\
              $(COMMON_LIBS)\dsys.lib \
              $(SDK_LIB_PATH)\ntdll.lib

######################################################################
#
#       Win32 (NT 1.x/NT 2.0/Chicago/Win32s) Definitions
#

!if "$(PROCESSOR_ARCHITECTURE)" == "x86" || \
    "$(PROCESSOR_ARCHITECTURE)" == "MIPS" || \
    "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
! if "$(PROCESSOR_ARCHITECTURE)" == "x86"

#--------------------------------------
#        X86 Specific Flags
#--------------------------------------

CC=  cl386
BUILD_EXE_COMPFLAG= cl386
BUILD_EXE_PROCTYPE=i386

CPLATFORM= -Di386=1 -D_X86_=1

CFLAGS   = $(CFLAGS) -G4f -Zl -Bbb1

# Chicago doesn't have Unicode API's
!  if "$(OPSYS)" == "DOS" || "$(OPSYS)" == "WIN16"
CFLAGS   = $(CFLAGS) -UUNICODE -U_UNICODE
!  endif

!if "$(CALLCONV)" == ""
!  ifndef 386_STDCALL
386_STDCALL = TRUE
!  endif

!  if "$(386_STDCALL)" == "TRUE"
CFLAGS = $(CFLAGS) -Gz
!  else
CFLAGS = $(CFLAGS) -Gd
!  endif
!else
CFLAGS = $(CFLAGS) $(CALLCONV)
!endif

#
#  Disable FPO for now.  If/when we determine if the debuggers can handle
#  it, and the CriticalSection code isn't dependent on the stack frame, and
#  the Stack walk-back code is updated, we should turn it back on...
#

!  ifndef OPTFLAGS
!   if "$(BUILDTYPE)" == "DEBUG" || "$(BUILDTYPE)" == "RETAIL"
OPTFLAGS = -Ogit -Oy-
!   elseif "$(BUILDTYPE)" == "RELEASE" || "$(BUILDTYPE)" == "PROFILE"
OPTFLAGS = -Owx  -Oy- -Ob1
!   endif
!  endif

# Make sure intrinsics are always on.

OPTFLAGS = $(OPTFLAGS) -Oi

# Hack to workaround cvpack types limit when building ole2prxy.dll in
#  common\types.  s/b revisted once the linker and cvpack are one.
#  BryanT  8/10/93

!if "$(NO_DEBUG)" == "1"
NTDEBUGTYPE = ntsd
!else
NTDEBUGTYPE = windbg
!endif

DLLENTRY    = @12
DRIVERENTRY = @8

#
#  (To be moved to NT section when the MIPS linker understands this flag)
#

LFLAGS = $(LFLAGS) -merge:.CRT=.data

#
#  The CUDA Linker requires this if there is no entrypoint (resource only DLL)
#

! ifdef NOEXPORTS
DLLSTARTUP=     -NOENTRY
! endif

LFLAGS   = $(LFLAGS) -NODEFAULTLIB -OPT:REF  -RELEASE

OBJFILES = $(OBJFILES) $(X86_OBJFILES)

! elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"

#--------------------------------------
#        MIPS Specific Flags
#--------------------------------------

CC=  mcl
BUILD_EXE_COMPFLAG= ClMips
BUILD_EXE_PROCTYPE=mips

CPLATFORM= -DMIPS=1 -D_MIPS_=1 -DR4000=1

CFLAGS   = $(CFLAGS) -QmipsOb2000 -QmipsG2

!  ifndef OPTFLAGS
!   if "$(BUILDTYPE)" == "DEBUG" || "$(BUILDTYPE)" == "RETAIL"
OPTFLAGS = -Oglt
!   elseif "$(BUILDTYPE)" == "RELEASE" || "$(BUILDTYPE)" == "PROFILE"
OPTFLAGS = -Owx  -Ob1
!   endif
!  endif

DLLENTRY =
DRIVERENTRY =

!  if "$(TARGETTYPE)" == "exe"
LFLAGS   =  $(LFLAGS) -GPSIZE:32
!  endif

!ifdef NEW_LINKER

!  ifdef NOEXPORTS
DLLSTARTUP=     -NOENTRY
!  endif

LFLAGS   = $(LFLAGS) -NODEFAULTLIB -OPT:REF -RELEASE

!  if "$(NO_DEBUG)" == "1"
NTDEBUGTYPE = ntsd
!  else
NTDEBUGTYPE = windbg
!  endif

!else

#
#  The MIPS Linker doesn't use a special switch to disable the entrypoint.
#

!  ifdef NOEXPORTS
DLLSTARTUP=
!  endif

LFLAGS   =  $(LFLAGS) -IGNORE:505

#
#  The MIPS Linker doesn't understand the nologo switch... Disable it for now.
#

LINKLOGO =

!endif

#  BUGBUG: For GPSIZE to really be useful, the compiler switches should include
#          -Gt32 and we should add libm.lib to the LIBS macros.  However, I'm
#          pretty sure Steve (shanson) and Sundeep haven't implemented the
#          necessary code for it to work with DLL's...  So for now, we just add
#          if to the exe link flags in case some library we link with was built
#          with -Gt...  BryanT  6/20/93

OBJFILES = $(OBJFILES) $(MIPS_OBJFILES)

! elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"

#--------------------------------------
#        ALPHA Specific Flags
#--------------------------------------

CC=  claxp
BUILD_EXE_COMPFLAG= ClAlpha
BUILD_EXE_PROCTYPE=alpha

CPLATFORM= -DALPHA=1 -D_ALPHA_=1 -DJENSEN

!  ifndef OPTFLAGS
!   if "$(BUILDTYPE)" == "DEBUG" || "$(BUILDTYPE)" == "RETAIL"
OPTFLAGS = -Oglt
!   elseif "$(BUILDTYPE)" == "RELEASE" || "$(BUILDTYPE)" == "PROFILE"
OPTFLAGS = -Owx  -Ob1
!   endif
!  endif

DLLENTRY =
DRIVERENTRY =

#
#  The ALPHA Linker doesn't use a special switch to disable the entrypoint.
#

! ifdef NOEXPORTS
DLLSTARTUP=
! endif

LFLAGS   =  $(LFLAGS) -IGNORE:505

#
#  The ALPHA Linker doesn't understand the nologo switch... Disable it for now.
#

LINKLOGO =

OBJFILES = $(OBJFILES) $(ALPHA_OBJFILES)

! endif   # PROCESSOR_ARCHITECTURE == x86 / MIPS / ALPHA

#--------------------------------------
#        NT/Chicago(DOS) Specific Flags
#--------------------------------------

CPLATFORM = $(CPLATFORM) -DFLAT

CFLAGS   = $(CFLAGS) -Zp8 -Ze -Gys -W3 -FI$(BASEDIR)\private\cinc\warning.h

!if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
CFLAGS = $(CFLAGS) -DCAIROLE_BUILD
!endif

# WIN32 ==  50 -> Win32s
# WIN32 == 100 -> NT version 1.0
# WIN32 == 200 -> Chicago version 1.0
# WIN32 == 300 -> Cairo (NT version 2.0)

!if "$(OPSYS)" == "WIN16"
CPLATFORM = $(CPLATFORM) -DWIN32=50 -D_WIN32S_=50
!elseif "$(OPSYS)" == "NT1X"
CPLATFORM = $(CPLATFORM) -DWIN32=100 -D_NT1X_=100
!elseif "$(OPSYS)" == "DOS"
CPLATFORM = $(CPLATFORM) -DWIN32=200 -D_CHICAGO_=200
!elseif "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
CPLATFORM = $(CPLATFORM) -DWIN32=300 -D_CAIRO_=300
!else
!error Unknown OPSYS: $(OPSYS)
!endif

!ifdef PERFSNAP
CFLAGS = $(CFLAGS) -DPERFSNAP=1
!endif

!ifdef NO_OLE
INCLUDES_FLAGS = $(INCLUDES_FLAGS) -nole2.h
CFLAGS = $(CFLAGS) -DNOOLETYPES
!else
CFLAGS = $(CFLAGS) -DINC_OLE2
!endif

IDLFLAGS   = $(IDLFLAGS) -Zp8

NO_SPLITSYM = TRUE   # Reenable when commnot understands .dbg files

IMAGE_TYPE_COFF = TRUE

!  if "$(BUILDTYPE)" == "RELEASE"
DBGFLAGS  =
!  else
DBGFLAGS  = -Z7
!  endif

!  if "$(NO_STRICT)" == ""
CFLAGS = $(CFLAGS) -DSTRICT
!  else
CFLAGS = $(CFLAGS) -DNO_STRICT
!  endif

CFLAGS = $(CFLAGS) $(OPTFLAGS) $(DBGFLAGS) $(CPLATFORM)

! if "$(TARGETTYPE)" != "sys" && !defined(USE_STDCRT)
USE_MSVCRT=TRUE
! endif

! ifdef USE_MSVCRT
CFLAGS=   $(CFLAGS) -D_MT -D_DLL
MTHREAD=  1
! else
!  if "$(TARGETTYPE)" == "dll" || "$(MTHREAD)" == "1"
CFLAGS=   $(CFLAGS) -D_MT
!  endif
! endif

WILDCARDOBJ = $(RTLIBDIR)\setargv.obj

! ifdef WILDCARDS
OBJFILES = $(OBJFILES) $(WILDCARDOBJ)
! endif

AFLAGS=         $(AFLAGS) -Ml -W2 -Zi -t

CRTINC=         $(OSINC)\crt

RTLIBDIR=       $(OSLIBDIR)

! if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
RTLIBST=        $(RTLIBDIR)\cairost.lib  $(RTLIBDIR)\libc.lib
RTLIBMT=        $(RTLIBDIR)\cairomt.lib  $(RTLIBDIR)\libcmt.lib
RTLIBCRTDLL=    $(RTLIBDIR)\crtdll.lib
RTLIBSYS=       $(RTLIBDIR)\cairoker.lib $(RTLIBDIR)\libcnt.lib
! else
RTLIBST=        $(RTLIBDIR)\libc.lib
RTLIBMT=        $(RTLIBDIR)\libcmt.lib
RTLIBSYS=       $(RTLIBDIR)\libcnt.lib
RTLIBCRTDLL=    $(RTLIBDIR)\crtdll.lib
! endif

RTLIBEXE=       $(RTLIBST)
RTLIBEXEQ=
RTLIBEXEFP=
RTLIBEXEFPMT=

! ifdef USE_MSVCRT
RTLIBEXEMT=     $(RTLIBCRTDLL)
RTLIBDLL=       $(RTLIBCRTDLL)
! else
RTLIBEXEMT=     $(RTLIBMT)
RTLIBDLL=       $(RTLIBMT)
! endif

RPCLIBDIR=      $(OSLIBDIR)

RPCNDRLIB=
RPCRTLIB=       $(RPCLIBDIR)\RpcRt4.lib
RPCLIBS=        $(RPCRTLIB) $(RPCLIBDIR)\ntdll.lib

! if "$(SUBSYSTEMVER)" == ""
SUBSYSTEMVER = 3.10
! endif

! if "$(NO_WINMAIN)" == ""
EXESTARTUP=     -ENTRY:WinMainCRTStartup
SUBSYSTEM=      WINDOWS,$(SUBSYSTEMVER)
! else
EXESTARTUP=     -ENTRY:mainCRTStartup
!  if "$(SUBSYSTEM)" == ""
SUBSYSTEM=      CONSOLE,$(SUBSYSTEMVER)
!  else  # Make sure the subsystem version is set
!   if "$(SUBSYSTEM)" == "$(SUBSYSTEM:,=x)"
SUBSYSTEM=  $(SUBSYSTEM),$(SUBSYSTEMVER)
!   endif
!  endif # allows override of subsystem
! endif

#
# For a perfsnap build, we use a modified version of dllentr2.obj
#

!if "$(PERFSNAP)" == "1"
STARTUPFILE=dllpsnap.obj
!else
STARTUPFILE=dllentr2.obj
!endif

#
# BugBug, what do we do about the DllEntryPoint for Daytona builds?
# now we jus link with dllentr2.obj.

! ifndef NOEXPORTS
!  ifdef USE_MSVCRT
!   if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
DLLSTARTUP=     -ENTRY:DllEntryPoint$(DLLENTRY)
!   else
DLLSTARTUP=     -ENTRY:DllEntryPoint$(DLLENTRY)
!   endif
!  else
DLLSTARTUP=     -ENTRY:DllEntryPoint$(DLLENTRY)
!  endif
! endif

SYSSTARTUP=     -ENTRY:DriverEntry$(DRIVERENTRY)

!ifdef USE_OLE_MC
MCFLAGS= -r $(OBJDIR) -o
!else
MCFLAGS= -r $(OBJDIR)
!endif

RCFLAGS=        $(RCFLAGS) -r $(CDEBUGFLAGS) $(CPLATFORM) $(CINC) -fo
RCEXEFLAGS=     $(RCEXEFLAGS)

LINK=           $(COFF) -link $(LINKLOGO)
LIBUTIL=        $(COFF) -lib $(LINKLOGO)

LFLAGS=         $(LFLAGS) \
                -MACHINE:$(PLATFORM) \
                -MAP:$(OBJDIR)\$(TARGETBASE).map \
!if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NTKERNEL"
                -VERSION:2.0 \
!else
                -VERSION:1.0 \
!endif
                -SECTION:.rsrc,r \
                -SECTION:.guids,r

! if "$(BUILDTYPE)" == "RELEASE"
LFLAGS=         $(LFLAGS) -DEBUG:none
! else
!  if "$(TARGETTYPE)" == "sys"
!   if "$(PROCESSOR_ARCHITECTURE)" == "x86"
LFLAGS=         $(LFLAGS) -DEBUG:notmapped,full -DEBUGTYPE:both,fixup
NTDEBUGTYPE=windbg
!   else
LFLAGS=         $(LFLAGS) -DEBUG:notmapped,full -DEBUGTYPE:coff
NTDEBUGTYPE=ntsd
!   endif
!  else
!   if "$(NTDEBUGTYPE)" == "windbg"
!    if "$(PROCESSOR_ARCHITECTURE)" == "x86"
LFLAGS=         $(LFLAGS) -DEBUG:mapped,full -DEBUGTYPE:both,fixup
!    else
LFLAGS=         $(LFLAGS) -DEBUG:mapped,full -DEBUGTYPE:both
!    endif
!   else
LFLAGS=         $(LFLAGS) -DEBUG:mapped,full -DEBUGTYPE:coff
!   endif
!  endif
! endif

LFLAGSEXE=      $(LFLAGS)             -ALIGN:0x1000 -SUBSYSTEM:$(SUBSYSTEM)
LFLAGSDLL=      $(LFLAGS) -DLL        -ALIGN:0x1000 -SUBSYSTEM:$(SUBSYSTEM)
LFLAGSSYS=      $(LFLAGS) -DLL:system -ALIGN:0x200

# Chicago and Win32s need relocations
!if "$(OPSYS)" != "DOS" && "$(OPSYS)" != "WIN16"
LFLAGSEXE=      $(LFLAGSEXE) -FIXED
!endif

LIBFLAGS=       -MACHINE:$(PLATFORM) -DEBUGTYPE:BOTH

! ifndef IMAGEBASE
!  if "$(TARGETTYPE)" == "sys"
IMAGEBASE = 0x10000
!  elseif "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "cpl"
!   ifdef COFFBASE
IMAGEBASE=      @$(TYPESDIR)\coffbase.txt,$(COFFBASE)
!   else
!    if "$(RELEASE)" != ""
!error *** BUILD ERROR - Cannot set RELEASE w/o a COFFBASE setting ***
!    endif
!   endif
!  else
IMAGEBASE=      @$(TYPESDIR)\coffbase.txt,usermode
!  endif
! endif

IMAGEBASE=      -BASE:$(IMAGEBASE)

SPLITSYMFLAGS=  -v

!endif  # $(PROCESSOR_ARCHITECTURE) == x86/MIPS/ALPHA

##################################################
#       OS dependent Definitions for C compiler
#
# These are definitions which will change for each flavor of Win32
# supported (NT, DOS)
#

!if "$(PROCESSOR_ARCHITECTURE)" == "x86" || "$(PROCESSOR_ARCHITECTURE)" == "MIPS" || "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"

!if "$(OPSYS)" == "NT" || "$(OPSYS)" == "NT1X"
OSLIBDIR= $(IMPORTNT)\lib\$(PLATFORM)
OSINC=    $(IMPORTNT)\inc

!if "$(OPSYS)" == "NT"
CAIROOSINC=$(IMPORTNT)\inc
!elseif "$(OPSYS)" == "NT1X"
CAIROOSINC=$(IMPORTNT)\inc
!endif

RPCINC=   $(IMPORTNT)\inc

!else
!error Unknown OPSYS: $(OPSYS)
!endif

OSLIBEXE= $(OSLIBDIR)\gdi32.lib  $(OSLIBDIR)\kernel32.lib \
          $(OSLIBDIR)\user32.lib $(OSLIBDIR)\advapi32.lib

OSLIBEXE= $(OSLIBEXE) $(EXTRAOSLIBS)

! if "$(PROFILE)" == "TRUE"
OSLIBEXE= $(OSLIBEXE) $(OSLIBDIR)\cap.lib
! endif  # "$(PROFILE)" == "TRUE"

OSLIBDLL= $(OSLIBEXE)
OSLIBSYS= $(OSLIBDIR)\ntoskrnl.lib $(OSLIBDIR)\hal.lib $(EXTRAOSLIBS)

! if "$(IDLBASE)" != ""
OSLIBEXE= $(OSLIBEXE) $(RPCNDRLIB)
OSLIBDLL= $(OSLIBDLL) $(RPCNDRLIB)
! endif

!endif      # PROCESSOR_ARCHITECTURE == x86/MIPS/ALPHA

CINC=     $(CINC) -I$(CRTINC) -I$(CAIROOSINC) -I$(OSINC) -I$(RPCINC)

####################################################################
#
#  Defines for the SDK Tools.
#

MKHEADERFLAGS   = $(MKHEADERFLAGS)
MKTYPLIBFLAGS   = $(MKTYPLIBFLAGS) -cpp_cmd $(CC)
MKTMPLATFLAGS   = $(MKTMPLATFLAGS)

# update TLBDIRS to point to the location of the master winole
# type library. Currently this is in $(BASEINC)\$(OBJDIR)
TLBDIRS         = $(TLBDIRS) -L$(BASEINC)\$(OBJDIR)

######################################################################
#
#       Generic rules to build OBJs from C, and CXX files.
#

CLOBJ=  $(CC) $(CFLAGS) $(OCFLAGS) $(CINC) $(GCFLAGS) -c

ALLCFLAGS = $(CFLAGS) $(OCFLAGS) $(GCFLAGS) -c

IDLMIDLFLAGS = $(MIDLFLAGS) $(IDLFLAGS)

#####################################################################
#
#   Rules for generating precompiled headers
#
#   BUGBUG: This business with adding a dummy function to the end of the pch
#           is necessitated by the compiler not doing it for us.  By doing
#           it, we force the linker to add the module to the library.  We
#           also create a .lic (Link Include) file that will follow the library
#           around and force the module to be linked in to the final image
#           so cvpack can find the types data.  4-14-93  BryanT
#
#  Define NEW_PCH_BUILD to eliminate this problem.  Instead of generating
#  a dummy function and the .lic file, we use -Yl on the compile line with
#  the name of the target.  This causes the compiler to add a special
#  symbol to the pch file.  Not turned on for the full build because
#  Centaur doesn't support it yet.  9-24-93  BryanT
#

!if "$(PCHDIR)" == ""
PCHDIR       = $(MAKEDIR)
!endif

CINC         = -I$(PCHDIR) $(CINC)

PCH_SECRET_NAME = __@@_PchDebugInfoLibrary

DUMFUNC      = $(PCH_SECRET_NAME)_$(TARGETBASE)_$(TARGETTYPE)
! if "$(PROCESSOR_ARCHITECTURE)" == "x86"
DUMINCLUDE   = -INCLUDE:_$(DUMFUNC)
! else
DUMINCLUDE   = -INCLUDE:$(DUMFUNC)
! endif
PCHOBJDIR    = $(PCHDIR)\$(OBJDIR)

# ---------------------------  PXXFILE Support  ------------------------

#bugbug
#work around for precompiled header problem.
!if "$(NTNOPCH)"!=""
PXXFILE=
!endif

!if "$(PXXFILE)" != ""

PXXFILE      = $(PXXFILE:.\=)
PXXSOURCE    = $(PCHDIR)\$(PXXFILE)
PXXHEADER    = $(PCHOBJDIR)\$(PXXFILE:.cxx=.pxh)
PRECOMPXXOBJ = $(PCHOBJDIR)\$(PXXFILE:.cxx=.obj)
PXXLIC       = $(PCHOBJDIR)\$(PXXFILE:.cxx=.lxp)
PCH_CXX_OPT  = -Yu -Fp$(PXXHEADER)
!if "$(PROCESSOR_ARCHITECTURE)" == "MIPS" || "$(PROCESSOR_ARCHITECTURE)" == "x86" || "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
PCH_CXX_NAME = -Yl$(TARGETBASE)_$(TARGETTYPE)
!else
PCH_CXX_NAME =
!endif

! ifndef NEW_PCH_BUILD
$(PXXHEADER) $(PXXLIC): $(PXXSOURCE)
!  if "$(PCHDIR)" == "$(MAKEDIR)"
      @-md $(OBJDIR) $(OUTNUL)
      $(CC) $(COMPLOGO) @<<$(OBJDIR)\$(PXXFILE:.cxx=.rsp)
$(ALLCFLAGS: =
)
$(CINC: =
)
-Yc
$(PCH_CXX_NAME)
-Fp$(PXXHEADER)
-Fo$(PRECOMPXXOBJ)
-Tp$(PXXSOURCE)
<<$(COMPRESP)
      @echo $(DUMINCLUDE) > $(PXXLIC)
!  else
      @-cd $(PCHDIR)
      @-$(MAKE) -$(MAKEFLAGS)
      @-cd $(MAKEDIR)
!  endif
! else   # NEW_PCH_BUILD

$(PXXHEADER): $(PXXSOURCE)
!  if "$(PCHDIR)" == "$(MAKEDIR)"
      @-md $(OBJDIR) $(OUTNUL)
      $(CC) $(COMPLOGO) @<<$(OBJDIR)\$(PXXFILE:.cxx=.rsp)
$(ALLCFLAGS: =
)
$(CINC: =
)
-Yc
$(PCH_CXX_NAME)
-Fp$(PXXHEADER)
-Fo$(PRECOMPXXOBJ)
-Tp$(PXXSOURCE)
<<$(COMPRESP)
!  else
      @-cd $(PCHDIR)
      @-$(MAKE) -$(MAKEFLAGS)
      @-cd $(MAKEDIR)
!  endif
! endif  # NEW_PCH_BUILD
!else    # PXXFILE == ""

PCH_CXX_OPT  =
PRECOMPXXOBJ =

!endif

# ----------------------------  PFILE Support  -------------------------

!if "$(PFILE)" != ""

PFILE      = $(PFILE:.\=)
PSOURCE    = $(PCHDIR)\$(PFILE)
PHEADER    = $(PCHOBJDIR)\$(PFILE:.c=.ph)
PRECOMPOBJ = $(PCHOBJDIR)\$(PFILE:.c=.obj)
PLIC       = $(PCHOBJDIR)\$(PFILE:.c=.lp)
PCH_C_OPT  = -Yu -Fp$(PHEADER)
!if "$(PROCESSOR_ARCHITECTURE)" == "MIPS" || "$(PROCESSOR_ARCHITECTURE)" == "x86" || "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
PCH_C_NAME = -Yl$(TARGETBASE)_$(TARGETTYPE)
!else
PCH_C_NAME =
!endif

! ifndef NEW_PCH_BUILD
$(PHEADER) $(PLIC): $(PSOURCE)
      @-md $(OBJDIR) $(OUTNUL)
      $(CC) $(COMPLOGO) @<<$(OBJDIR)\$(PFILE:.c=.rsp)
$(ALLCFLAGS: =
)
$(CINC: =
)
-Yc
$(PCH_C_NAME)
-Fp$(PHEADER)
-Fo$(PRECOMPOBJ)
-Tc$(PSOURCE)
<<$(COMPRESP)
      @echo $(DUMINCLUDE) > $(PLIC)

! else  # NEW_PCH_BUILD

$(PHEADER): $(PSOURCE)
      @-md $(OBJDIR) $(OUTNUL)
      $(CC) $(COMPLOGO) @<<$(OBJDIR)\$(PFILE:.c=.rsp)
$(ALLCFLAGS: =
)
$(CINC: =
)
-Yc
$(PCH_C_NAME)
-Fp$(PHEADER)
-Fo$(PRECOMPOBJ)
-Tc$(PSOURCE)
<<$(COMPRESP)
! endif   # NEW_PCH_BUILD
!else    # PFILE == ""

PCH_C_OPT  =
PRECOMPOBJ =

!endif

!ifndef NEW_PCH_BUILD
# -----------------------  Library .LIC Support  ------------------------

!if "$(TARGETTYPE)" == "lib" && ("$(PXXFILE)" != "" || "$(PFILE)" != "")

$(TGTDIR)\$(TARGET): $(TGTDIR)\$(TARGETBASE).lic

$(TGTDIR)\$(TARGETBASE).lic: $(PXXLIC) $(PLIC)
      @-md $(OBJDIR) $(OUTNUL)
      @-$(DEL) $@ $(OUTNUL)
      @for %i in ($**) do @type %i >> $@

!endif

!endif  # NEW_PCH_BUILD

#####################################################################
#
#   Rules for c files
#

.c{$(OBJDIR)}.obj:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $< $(CC) $(COMPLOGO) @$*.rsp
        @$(CC) $(COMPLOGO) @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_C_OPT: =
)
-Fo$(MAKEDIR)\$*.obj
$(MAKEDIR)\$<
<<$(COMPRESP)
!ifdef SIFTBUILD
        $(SIFTTOOL) $(SIFTFLAGS) $*.obj
!endif

.c{$(OBJDIR)}.lst:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $< $(CC) $(COMPLOGO) -Fc$*.lst @$*.rsp
        @$(CC) $(COMPLOGO) -Fc$*.lst @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_C_OPT: =
)
-Fo$(MAKEDIR)\$*.obj
$(MAKEDIR)\$<
<<$(COMPRESP)

#####################################################################
#
#   Rules for cxx files
#

!if "$(PROCESSOR_ARCHITECTURE)" == "x86"

CFFLAGS     = +L +m7 +H63
!elseif "$(PROCESSOR_ARCHITECTURE)" == "MIPS"

CFFLAGS     = +L +m7 +H63 +E$(IMPORTNT)\h\sdk\mipsxcpt.tab +M
!elseif "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"

CFFLAGS     = +L +m7 +H63 +E$(IMPORTNT)\h\sdk\alphxcpt.tab +M
!endif

.cxx{$(OBJDIR)}.obj:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $< $(CC) $(COMPLOGO) @$*.rsp
        @$(CC) $(COMPLOGO) @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_CXX_OPT: =
)
-Fo$(MAKEDIR)\$*.obj
-Tp$(MAKEDIR)\$<
<<$(COMPRESP)
!ifdef SIFTBUILD
        $(SIFTTOOL) $(SIFTFLAGS) $*.obj
!endif

.cxx{$(OBJDIR)}.lst:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $<  $(CC) $(COMPLOGO) -Fc$*.lst @$*.rsp
        @$(CC) $(COMPLOGO) -Fc$*.lst @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_CXX_OPT: =
)
-Fo$*.obj
-Tp$(MAKEDIR)\$<
<<$(COMPRESP)

.cpp{$(OBJDIR)}.obj:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $<  $(CC) $(COMPLOGO) @$*.rsp
        @$(CC) $(COMPLOGO) @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_CXX_OPT: =
)
-Fo$(MAKEDIR)\$*.obj
-Tp$(MAKEDIR)\$<
<<$(COMPRESP)
!ifdef SIFTBUILD
        $(SIFTTOOL) $(SIFTFLAGS) $*.obj
!endif

.cpp{$(OBJDIR)}.lst:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @echo $(BUILD_EXE_COMPFLAG) $<  $(CC) $(COMPLOGO) -Fc$*.lst @$*.rsp
        @$(CC) $(COMPLOGO) -Fc$*.lst @<<$*.rsp
$(ALLCFLAGS: =
)
$(CINC: =
)
$(PCH_CXX_OPT: =
)
-Fo$*.obj
-Tp$(MAKEDIR)\$<
<<$(COMPRESP)


############################################################################
#
#   Build a Version resource (NT only) for every image in the build.
#
#   The user has the choice of either defining their own version resource
#  script or letting the build make one for them on the fly.  If the user
#  defines their own, set VERSION_RC in filelist.mk to point to a valid .rc
#  file (with the same format as $(VERSION_RC), below) and don't add that
#  file to the RCFILES macro in filelist.mk.  If the user does not define
#  VERSION_RC, build a default file by using TARGET_DESCRIPTION and
#  (optionally) TARGET_INTERNAL_NAME to the internal name (By default, the
#  target name minus the extension).
#

!ifdef IMAGE_TYPE_COFF
! if "$(OPSYS)" != "DOS"  #  BUGBUG: Chicago seems to fail on version resources  BryanT 9/28/93
! if "$(TARGETTYPE)" != "lib" && "$(TARGET)" != "RELEASE" && "$(TARGET)" != ""
!  if "$(VERSION_RC)" == ""
VERSION_RC = $(OBJDIR)\$(TARGETBASE).rc1

!   ifndef TARGET_DESCRIPTION
!    if "$(RELEASE)" != ""
!error *** BUILD ERROR - TARGET_DESCRIPTION not set.  Aborting. ***
!    endif
!   endif

!   if "$(TARGET_INTERNAL_NAME)" == ""
TARGET_INTERNAL_NAME = "$(TARGETBASE)"
!   endif

#  Set the major file type to one of DRV, APP, DLL, STATIC LIB, or UNKNOWN.

!   if "$(TARGETTYPE)" == "dll"
VFT_TYPE = VFT_DLL
!   elseif "$(TARGETTYPE)" == "exe"
VFT_TYPE = VFT_APP
!   elseif "$(TARGETTYPE)" == "lib"
VFT_TYPE = VFT_STATIC_LIB
!   else
VFT_TYPE = VFT_UNKNOWN
!   endif       # if "$(TARGETTYPE)" == "sys"

#  The Minor file type distinguishes the type of driver.  All DRV's in Cairo
#  are currently SYSTEM drivers.

!   if "$(TARGETTYPE)" == "sys"
VFT_TYPE2 = VFT2_DRV_SYSTEM
!   else
VFT_TYPE2 = VFT2_UNKNOWN
!   endif

all: $(VERSION_RC)

$(VERSION_RC): $(TYPESDIR)\makefile.inc
    @-md $(OBJDIR) $(OUTNUL)
    type << > $@
#include <windows.h>
#include <ntverp.h>
#define VER_FILETYPE              $(VFT_TYPE)
#define VER_FILESUBTYPE           $(VFT_TYPE2)
#define VER_FILEDESCRIPTION_STR   $(TARGET_DESCRIPTION)
#define VER_INTERNALNAME_STR      $(TARGET_INTERNAL_NAME)
#include <common.ver>
<<NOKEEP

!  endif        # if "$(VERSION_RC)" == ""

RCFILES    = $(VERSION_RC) $(RCFILES)

!else   # TARGETTYPE != lib && TARGET != RELEASE

VERSION_RC =

! endif  # TARGETTYPE != lib && TARGET != RELEASE
!endif  # OPSYS == DOS   BUGBUG: Chicago
!endif  # IMAGE_TYPE_COFF

######################################################################
#
#       Rule to build RES from RC file.
#
#       Note:  we mess with PATH because RC is not real clever about
#       finding RCPP (it's sub-component EXE).  It looks along PATH,
#       so we limit PATH here in order to guarantee that RCPATH is
#       in PATH, and also to avoid invoking a non-compatible RCPP that
#       might just be in the user's private toolset.
#
#       In the case of an NT build, COFF can't handle more than one
#       resource obj.  So, we build a single .rc2 file that #include's
#       all the component RCFILES.
#

!ifdef IMAGE_TYPE_COFF
! if "$(RCFILES)" != ""

$(OBJDIR)\$(TARGETBASE).rc2: $(RCFILES)
        @echo $(RCFILES) --^> $@ $(OUTPUT)
        type << | $(SED) -f $(SCRIPTS)\rcfiles.sed > $@
$(RCFILES: =
)
<<NOKEEP

$(OBJDIR)\$(TARGETBASE).res: $(OBJDIR)\$(TARGETBASE).rc2

{$(OBJDIR)}.rc2{$(OBJDIR)}.res:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        $(RC) $(ORCFLAGS) -I$(OBJDIR) $(RCFLAGS) $(MAKEDIR)\$(<R).tmp $(MAKEDIR)\$<
        $(CVTRES) -$(PLATFORM) -o $*.res $(MAKEDIR)\$(<R).tmp
! endif

!else

.rc{$(OBJDIR)}.res:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        @set oldpath=%%PATH%%
        @set path=$(RCPATH)
        $(RC) $(ORCFLAGS) $(RCFLAGS) $*.res $(MAKEDIR)\$<
        @set path=%%oldpath%%
        @set oldpath=

!endif

######################################################################
#
#       Rule for building .lib files from .lrf files

.lrf{$(OBJDIR)}.lib:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        -$(DEL) $*.lib $(OUTNUL)
        @echo lib32 -out:@$< $(BUILD_EXE_PROCTYPE)
        @$(LIBUTIL) $(LIBFLAGS) @$<

.lrf.lib:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        if exist $*.lib $(DEL) $*.lib $(OUTNUL)
        @echo lib32 -out:@$< $(BUILD_EXE_PROCTYPE)
        $(LIBUTIL) $(LIBFLAGS) @$*.lrf


##################################################
#
#       Rules for generating .h and .c files from .idl files
#

##
## IDLUSE == none --> generate header file only
##

.idl{$(MIDL_HDR_OUT_DIR)}.h:
    @echo $< --^> $@ $(OUTPUT)
!ifdef IMAGE_TYPE_COFF
    $(MIDL) @<<$*.rsp $<
$(IDLMIDLFLAGS)
$(CINC)
-no_format_opt
-no_warn
-char unsigned
-mode c_port
-proxy $(MIDL_OUT_DIR)\$(@B)_p.c
-iid            $(MIDL_OUT_DIR)\$(@B)_i.c
-header         $(MIDL_HDR_OUT_DIR)\$(@B).h
-caux           $(MIDL_OUT_DIR)\$(@B)_x.c
-saux           $(MIDL_OUT_DIR)\$(@B)_y.c
-cpp_cmd
$(CC)
-cpp_opt "$(COMPLOGO) -DMIDL_PASS $(CPLATFORM) $(OCFLAGS) $(CINC) -E -Tc"
<<$(COMPRESP)
!else
    $(MIDL) $(CINC) -char unsigned -mode c_port -header $@ -cpp_cmd $(CC) -cpp_opt "$(COMPLOGO) @<<$*.rsp -Tc" $<
-DMIDL_PASS
-D$(PLATFORM)
$(OCFLAGS)
$(CINC)
-D$(PLATFORM)=1
-E
<<$(COMPRESP)
!if "$(OPSYS)"=="NT1X" && "$(NORELEASE_CHICAGO)"==""
        @echo Build_Status Releasing Midl generated  $(@B).h files to $(HCOPY)\chicago
        copy $(MIDL_HDR)OUT_DIR)\$(@B).h $(HCOPY)\chicago
!endif
!endif

#-proxy		$(MIDL_OUT_DIR)\$(@B)_p.c

##################################################
#       Provide some includes prefixes

INCLUDES_PREFIX= -L$$(OBJDIR) -S$$(OBJDIR)

INCLUDES_ROOTS=  $(INCLUDES_ROOTS) \
                 -P$$(BASEDIR)=$(BASEDIR)


OBJS=$(CXX_OBJS) \
     $(C_OBJS)   \
     $(PRECOMPOBJ) \
     $(PRECOMPXXOBJ) \
     $(OBJFILES)

############################################################################
#
#   Build a Link Include file.
#   Basically, every library we call that has a precompiled header needs
#   to have that header obj forced into the final image.  The .lic file built
#   with the pch provides that for us.  We just make a simple one with
#   NODEFAULTLIB and append any others we can find.  BryanT 4/14/93
#

!ifdef IMAGE_TYPE_COFF
! ifndef NEW_PCH_BUILD
TARGETLICS = $(TGTDIR)\$(TARGETBASE).tlc

$(TARGETLICS): $(OBJS) $(LIBS)
    @-md $(TGTDIR) $(OUTNUL)
    @echo -NODEFAULTLIB > KTx14J.lic
    @echo @echo off > $*.cmd
    @$(SED) -f $(SCRIPTS)\licfiles.sed << >> $*.cmd
$(LIBS: =
)
$(OBJS: =
)
<<NOKEEP
    @-$*.cmd
    @-$(DEL) $@  $(OUTNUL)
    @for %%i in (*.lic) do @type %i >> $@
    @-$(DEL) *.lic  $(OUTNUL)
! else

TARGETLICS =

! endif  # NEW_PCH_BUILD

!else

TARGETLICS =

!endif

############################################################################
#
# HACK for NT COFF limitation of only 1 .res obj per image.
#
# We force a single resfile name and handle generating it with the
# .rc->.rc2->,res rules.
#

!ifdef IMAGE_TYPE_COFF
! if "$(RCFILES)" != ""

RESFILES = $(OBJDIR)\$(TARGETBASE).res

! endif
!endif

############################################################################
#
#   Build a DLL or CPL (Control Panel Applet)
#

#BUGBUG BuildDLL

!if "$(TARGETTYPE)" == "dll"

! ifdef NOEXPORTS
DLLDEF=
! else
DLLDEF=     $(DEFFILEEXP)
! endif
DLLOBJS=    $(OBJS)
! ifdef SIFTBUILD
DLLOBJS = $(DLLOBJS) $(SIFTOBJ)
! endif # SIFTBUILD
DLLLIBS=    $(LIBS) $(OSLIBDLL) $(RTLIBDLL)
DLLRES=     $(RESFILES)

! ifndef NEW_PCH_BUILD
TLRSPFILE = @$(TARGETLICS)
! else
TLRSPFILE =
! endif

#
#   Link the DLL.
#

$(TGTDIR)\$(TARGET): $(DLLOBJS) $(DLLLIBS) $(DLLRES) $(DLLDEF) $(TYPESDIR)\coffbase.txt $(TARGETLICS)
    @$(ECHOTIME) Linking $@ $(ATSTR) $(TIMESTR)...      $(OUTPUT)
    @-md $(TGTDIR) $(OUTNUL)
! ifdef IMAGE_TYPE_COFF
    @echo link32 -out:$@ $(BUILD_EXE_PROCTYPE)
    @$(LINK) @<<$*.lnk $(TLRSPFILE)
$(DLLDEF)
$(LFLAGSDLL: =
)
$(DLLSTARTUP)
-OUT:$@
$(IMAGEBASE)
$(DLLOBJS: =
)
$(DLLRES)
$(DLLLIBS: =
)
<<$(LINKRESP)
!  ifndef NO_SPLITSYM
    $(SPLITSYM) $(SPLITSYMFLAGS) $@
!  endif
!if  "$(RELEASE_BIN)" != ""
    binplace $(BINPLACE_FLAGS) $@
!endif
!if "$(NO_RELEASE_IMPORT_LIB)" == "" && "$(LIBCP)" != ""
    $(COPY) $*.lib $(LIBCP)
!endif


CLEANTARGET=    $(CLEANTARGET)\
                $(OBJDIR)\$(TARGETBASE).lib\
                $(OBJDIR)\$(TARGETBASE).exp

! else  # IMAGE_TYPE_COFF
    @echo link32 -out:$*.dll $(BUILD_EXE_PROCTYPE)
    @$(LINK) @<<$*.lnk
$(LFLAGSDLL) $(DLLSTARTUP) $(DLLOBJS: = +^
)
$*.dll
$*.map
$(DLLLIBS: = +^
)
$(DLLDEF)
<<$(LINKRESP)
    if exist $(DLLRES) $(RC) $(RCEXEFLAGS) -fe $*.dll $(DLLRES) $*.dll
    $(MAPSYM) $(MAPSYMFLAGS) $*.map

#
#   Generate the import library.
#

all: $(OBJDIR)\$(TARGETBASE).lib

$(OBJDIR)\$(TARGETBASE).lib: $(DLLDEF:.\=)

CLEANTARGET=    $(CLEANTARGET) $(OBJDIR)\$(TARGETBASE).lib

! endif # IMAGE_TYPE_COFF

!endif  # Build DLL

############################################################################
#
#   Build a LIB
#

!if "$(TARGETTYPE)" == "lib"

$(OBJDIR)\$(TARGETBASE).lib: $(OBJS) $(LIBS)
    @$(ECHOTIME) Building $@ $(ATSTR) $(TIMESTR)... $(OUTPUT)
    @-md $(OBJDIR) $(OUTNUL)
    -$(DEL) $@  $(OUTNUL)
! ifdef IMAGE_TYPE_COFF
    @echo lib32 -out:$@ $(BUILD_EXE_PROCTYPE)
    @$(LIBUTIL) @<<$*.lnb
$(LIBFLAGS: =
)
$(OBJS: =
)
$(LIBS: =
)
-OUT:$@
<<$(LINKRESP)

! else      # IMAGE_TYPE_COFF
    @echo lib32 -out:$@ $(BUILD_EXE_PROCTYPE)
    @$(LIBUTIL) $(LIBFLAGS) @<<$*.lnb
$(OBJDIR)\$(TARGET)
y
$(OBJS: = &^
)&
$(LIBS: = &^
)&

$*.lls
<<$(LINKRESP)

! endif     # IMAGE_TYPE_COFF

!endif  # Build LIB

############################################################################
#
#   Build an EXE
#

!if "$(TARGETTYPE)" == "exe"
! ifdef IMAGE_TYPE_COFF
EXEDEF=
! else
!  if "$(DEFFILE)" == ""
EXEDEF=
!  else
EXEDEF=         $(DEFFILEEXP)
!  endif
! endif
EXELIBS=        $(LIBS)\
! if "$(MTHREAD)" == "1"
                $(RTLIBEXEMT)\
! else
                $(RTLIBEXE)\
! endif
                $(OSLIBEXE)

EXEOBJS=        $(OBJS)

!ifdef SIFTBUILD
EXEOBJS = $(EXEOBJS) $(SIFTOBJ)
!endif  # SIFTBUILD

EXERES=         $(RESFILES)

#
#   Link the EXE.
#

! ifndef NEW_PCH_BUILD
TLRSPFILE = @$(TARGETLICS)
! else
TLRSPFILE =
! endif

#
#   Need WINSTUB.EXE to build WIN16 targets -- "DOS" "i286"
#

WINSTUB=$(RCPATH)\winstub.exe

$(TGTDIR)\$(TARGET): $(EXEOBJS) $(EXELIBS) $(EXERES) $(EXEDEF) $(TARGETLICS)
!if "$(OPSYS)" == "DOS" && "$(PROCESSOR_ARCHITECTURE)" == "i286"
    $(COPY) $(WINSTUB) .
!endif
    @$(ECHOTIME) Linking $@ $(ATSTR) $(TIMESTR)...    $(OUTPUT)
    @-md $(TGTDIR) $(OUTNUL)
! ifdef IMAGE_TYPE_COFF
    @echo link32 -out:$@ $(BUILD_EXE_PROCTYPE)
    @$(LINK) @<<$*.lnk $(TLRSPFILE)
$(LFLAGSEXE: =
)
$(EXESTARTUP)
$(EXEOBJS: =
)
$(EXELIBS: =
)
$(EXERES)
-OUT:$@
$(IMAGEBASE)
!  if "$(NTDEBUGTYPE)" == "windbg" && "$(PROCESSOR_ARCHITECTURE)" == "x86"
-nopack
!  endif
<<$(LINKRESP)
!  if "$(NTDEBUGTYPE)" == "windbg" && "$(PROCESSOR_ARCHITECTURE)" == "x86"
    $(CVPACK) -nologo $@
!  endif
!  ifndef NO_SPLITSYM
   $(SPLITSYM) $(SPLITSYMFLAGS) $@
!  endif
! else   # IMAGE_TYPE_COFF
    @echo link32 -out:$*.exe $(BUILD_EXE_PROCTYPE)
    @$(LINK) @<<$*.lnk
$(LFLAGSEXE) $(EXESTARTUP) +
$(EXEOBJS: = +^
)
$*.exe
$*.map
$(EXELIBS: = +^
)
$(EXEDEF)
<<$(LINKRESP)
!if "$(OPSYS)" == "DOS" && "$(PROCESSOR_ARCHITECTURE)" == "i286"
    if exist $(EXERES) $(RC) $(RCEXEFLAGS) -fe $*.exe $(EXERES) $*.exe
    -$(DEL) winstub.exe
!else
    if exist $(EXERES) $(RC) $(RCEXEFLAGS) -fo $*.exe $(EXERES) $*.exe
!endif
    $(MAPSYM) $(MAPSYMFLAGS) $*.map
! endif  # IMAGE_TYPE_COFF

!endif  # Build EXE

######################################################################
#       IMPLIB files (unlike their real lib counterparts)
#       live in the source directory, not in a version
#       specific subdirectory

!if "$(NO_IMPLIB)" == ""
! ifdef IMAGE_TYPE_COFF

$(DEFFILEEXP) $(DEFFILELIB): $(DEFFILE)
    @echo $(DEFFILE) --^> $@ $(OUTPUT)
    @-md $(OBJDIR) $(OUTNUL)
    $(CC) $(COMPLOGO) @<<$*.rsp 1>$*.def
$(CPLATFORM)
$(CDEBUGFLAGS)
$(CINC: =
)
-EP
-Tc $**
<<$(COMPRESP)
    $(LIBUTIL) @<<$*.lsp
$(LIBFLAGS)
-OUT:$(DEFFILELIB)
-DEF:$*.def
<<$(LINKRESP)

.def{$(OBJDIR)}.lib:
        @echo $< --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        $(CC) $(COMPLOGO) @<<$*.rsp 1>$(OBJDIR)\$<
$(CPLATFORM)
$(CDEBUGFLAGS)
$(CINC: =
)
-EP
-Tc $<
<<$(COMPRESP)
        $(LIBUTIL) @<<$*.lsp
$(LIBFLAGS)
-OUT:$@
-DEF:$(OBJDIR)\$<
<<$(LINKRESP)

! else    # IMAGE_TYPE_COFF

IMPFLAGS=-nologo -noignorecase

.def.lib:
        @echo $< --^> $@ $(OUTPUT)
        $(IMPLIB) $(IMPFLAGS) $@ $<

$(DEFFILEEXP): $(DEFFILE)
        @echo $(DEFFILE) --^> $@ $(OUTPUT)
        @-md $(OBJDIR) $(OUTNUL)
        $(CC) $(COMPLOGO) @<<$*.rsp  1>$(DEFFILEEXP)
$(ALLCFLAGS: =
)
$(CINC: =
)
-EP
-Tc $**
<<$(COMPRESP)

$(DEFFILELIB): $(DEFFILEEXP)
        @echo $(DEFFILEEXP) --^> $@ $(OUTPUT)
        $(IMPLIB) $(IMPFLAGS) $(DEFFILELIB) $(DEFFILEEXP)

! endif   # IMAGE_TYPE_COFF
!endif   # NO_IMPLIB

############################################################################
#
#   Cleanup
#

!if defined(TARGET) || defined(CLEANTARGET)

clean: cleanobj

cleanobj:
! if "$(HOST)" == "NT"
    -$(DEL) /q $(OBJDIR) $(OUTNUL)
! else
    -echo y | $(DEL) $(OBJDIR) $(OUTNUL)
! endif
    -rmdir $(OBJDIR) $(OUTNUL)

cleantarget:
! if "$(HOST)" == "NT"
    -$(DEL) /q $(CLEANTARGET) $(OUTNUL)
! else
    -echo y | $(DEL) $(CLEANTARGET) $(OUTNUL)
! endif

!endif

!ifdef CLEANFILES

clean: cleanclean

cleanclean:
    -$(DEL) $(CLEANFILES) $(OUTNUL)

!endif

!ifdef LIBCOPY
! if "$(TARGETTYPE)" == "lib" || "$(TARGETTYPE)" == "dll"

clean: cleanlibcopy

cleanlibcopy:
   -$(DEL) $(LIBCOPY)\$(TARGETBASE).lib $(OUTNUL)
   -$(DEL) $(LIBCOPY)\$(TARGETBASE).lic $(OUTNUL)
!if "$(OPSYS)"=="NT1X" && "$(NORELEASE_CHICAGO)" == ""
   -$(DEL) $(CHICAGOLIBCOPY)\$(TARGETBASE).lib $(OUTNUL)
   -$(DEL) $(CHICAGOLIBCOPY)\$(TARGETBASE).lic $(OUTNUL)
!endif

! endif
!endif

!ifdef DLLCOPY
! if "$(TARGETTYPE)" == "dll"

clean: cleandllcopy

cleandllcopy:
   -$(DEL) $(DLLCOPY)\$(TARGETBASE).dll $(OUTNUL)
   -$(DEL) $(DLLCOPY)\$(TARGETBASE).dbg $(OUTNUL)
! endif
!endif

!ifdef EXECOPY
! if "$(TARGETTYPE)" == "exe"

clean: cleanexecopy

cleanexecopy:
   -$(DEL) $(EXECOPY)\$(TARGETBASE).exe $(OUTNUL)
   -$(DEL) $(EXECOPY)\$(TARGETBASE).dbg $(OUTNUL)
! endif
!endif

!if "$(TLBCOPY)" != ""

clean: cleantlbcopy

cleantlbcopy:
        @echo WARNING - Can't clean Type Library copies in $(TLBCOPY).

!endif

############################################################################
#
#   Copy targets to other directories.
#
copy:

!ifdef LIBCOPY

! if "$(TARGETTYPE)" == "dll" || "$(TARGETTYPE)" == "lib"

copy: $(LIBCOPY)\$(TARGETBASE).lib

$(LIBCOPY)\$(TARGETBASE).lib: $(OBJDIR)\$(TARGETBASE).lib
    @echo Copying $(TARGETBASE).lib to $(LIBCOPY)... $(OUTPUT)
    @-md $(LIBCOPY) $(OUTNUL)
    @-$(CHMODE) -r $(LIBCOPY)\$(TARGETBASE).lib $(OUTNUL)
    @-$(CHMODE) -r $(LIBCOPY)\$(TARGETBASE).lic $(OUTNUL)
    $(COPY) $(OBJDIR)\$(TARGETBASE).lib $(LIBCOPY)\$(TARGETBASE).lib
    @-$(COPY) $(OBJDIR)\$(TARGETBASE).lic $(LIBCOPY)\$(TARGETBASE).lic $(OUTNUL)
!if "$(OPSYS)" == "NT1X" && "$(NORELEASE_CHICAGO)" == ""
    @echo Releasing  $(TARGETBASE).lib for Chicago...  $(OUTPUT)
    @-md $(CHICAGOLIBCOPY) $(OUTNUL)
    @-$(CHMODE) -r $(CHICAGOLIBCOPY)$(TARGETBASE).lib $(OUTNUL)
    @-$(CHMODE) -r $(CHICAGOLIBCOPY)$(TARGETBASE).lic $(OUTNUL)
    $(COPY) $(OBJDIR)\$(TARGETBASE).lib $(CHICAGOLIBCOPY)\$(TARGETBASE).lib
    @-$(COPY) $(OBJDIR)\$(TARGETBASE).lic $(CHICAGOLIBCOPY)\$(TARGETBASE).lic $(OUTNUL)
!endif

! endif # dll or lib

!endif # LIBCOPY

!ifdef DLLCOPY

! if "$(TARGETTYPE)" == "dll"

copy: $(DLLCOPY)\$(TARGETBASE).dll

$(DLLCOPY)\$(TARGETBASE).dll: $(TGTDIR)\$(TARGETBASE).dll
    @echo Copying $(TARGETBASE).dll to $(DLLCOPY)... $(OUTPUT)
    @-md $(DLLCOPY) $(OUTNUL)
    @-$(CHMODE) -r $(DLLCOPY)\$(TARGETBASE).dll $(OUTNUL)
    @-$(CHMODE) -r $(DLLCOPY)\$(TARGETBASE).dbg $(OUTNUL)
    $(COPY) $(TGTDIR)\$(TARGETBASE).dll $(DLLCOPY)\$(TARGETBASE).dll
    @-$(COPY) $(TGTDIR)\$(TARGETBASE).dbg $(DLLCOPY)\$(TARGETBASE).dbg $(OUTNUL)
! endif # dll

!endif # DLLCOPY

!ifdef EXECOPY

! if "$(TARGETTYPE)" == "exe"

copy: $(EXECOPY)\$(TARGETBASE).exe

$(EXECOPY)\$(TARGETBASE).exe: $(TGTDIR)\$(TARGETBASE).exe
    @echo Copying $(TARGETBASE).exe to $(EXECOPY)... $(OUTPUT)
    @-md $(EXECOPY) $(OUTNUL)
    @-$(CHMODE) -r $(EXECOPY)\$(TARGETBASE).exe $(OUTNUL)
    @-$(CHMODE) -r $(EXECOPY)\$(TARGETBASE).dbg $(OUTNUL)
    $(COPY) $(TGTDIR)\$(TARGETBASE).exe $(EXECOPY)\$(TARGETBASE).exe
    @-$(COPY) $(TGTDIR)\$(TARGETBASE).dbg $(EXECOPY)\$(TARGETBASE).dbg $(OUTNUL)

! endif # exe

!endif # EXECOPY

!if "$(TLBCOPY)" != "" && "$(TYPELIBS)" != ""

copy: copytlbfiles

copytlbfiles: $(TYPELIBS)
        @echo Build_Status Copying Type Libraries to "$(TLBCOPY)"... $(OUTPUT)
        @-md $(TLBCOPY) $(OUTNUL)
        !$(COPY) $** $(TLBCOPY)
        !$(UNREGTLB) $**
        !$(REGTLB) $(TLBCOPY)\$(**F)

!else

copytlbfiles:

!endif

############################################################################
#
#   Generate external header file
#

!ifdef HFILES

all: $(TARGETBASE).h

clean: cleanh

cleanh:
    -$(DEL) $(TARGETBASE).h $(OUTNUL)

$(TARGETBASE).h: $(HFILES)
    @echo Generating $(TARGETBASE).h $(OUTPUT)
    $(SED) -f $(SCRIPTS)\public.sed $(HFILES) >$(TMP)\$(TARGETBASE).h
    -$(CMP) -s $(TMP)\$(TARGETBASE).h $@ 2>nul || $(COPY) $(TMP)\$(TARGETBASE).h $@
    -$(DEL) $(TMP)\$(TARGETBASE).h $(OUTNUL)

DEPENDFILES = $(DEPENDFILES) $(TARGETBASE).h

!endif

############################################################################
#
#   Resource files dependencies
#

!if "$(RESFILES)" != ""
$(RESFILES): $(RCFILES) $(RCOBJECTS)
!endif

############################################################################
#
#   Dependencies
#

!if "$(DEPENDSRC)" == "" && \
    "$(CXXFILES)"  == "" && \
    "$(CPPFILES)"  == "" && \
    "$(CFILES)"    == "" && \
    "$(IDLFILES)"  == "" && \
    "$(TDLFILES)"  == ""

depend:

!else

! if "$(DEPENDSRC)" == "" && \
     "$(CXXFILES)"  == "" && \
     "$(CPPFILES)"  == "" && \
     "$(CFILES)"    == ""
DEPENDSRC=
! else
DEPENDSRC=$(DEPENDSRC) $(CXXFILES) $(CPPFILES) $(CFILES)
! endif

depend: dependfile

!ifdef MULTIDEPEND
DEPENDFILE=depend.mk$(RDEXT)
NEWDEPENDFILE=depend.ne$(RDEXT)
!else
DEPENDFILE=depend.mk
NEWDEPENDFILE=depend.new
!endif

OBJPATTERN=$(OBJDIR:\=\\)

#########################################################################
#
#  Here's where the dependencies are actually generated.  We break up
#  the CINC, INCLUDES_ROOTS, and src macros to put one command on each
#  to ensure no one line is over 1024 bytes in length.  The includes
#  tool reads in 1k bytes and get's confused if any one line is split.
#

INCLUDES_FLAGS = $(INCLUDES_FLAGS) -nntos.h -nzwapi.h -dos

!if "$(OPSYS)"=="NT1X"
INCLUDES_FLAGS =$(INCLUDES_FLAGS) -nole2.h
!endif

dependfile: $(DEPENDFILES)
    $(ECHOTIME) # ; # Built automatically ; # ; >$(NEWDEPENDFILE)
!if "$(DEPENDSRC)" != ""
#
#   Source file dependencies
#
    $(ECHOTIME) # ; # Source files ; # ; >>$(NEWDEPENDFILE)
    $(INCLUDES) @<< >>$(NEWDEPENDFILE)
-e
$(INCLUDES_FLAGS)
$(INCLUDES_PREFIX)
$(CINC:-I=
-I)
$(INCLUDES_ROOTS:-P=
-P)
$(DEPENDSRC:.\=
.\)
<<NOKEEP
!endif # DEPENDSRC

#
#   MIDL dependencies
#

!if "$(IDLFILES)" != ""
    $(ECHOTIME) # ; # MIDL Source files ; # ; >>$(NEWDEPENDFILE)
    $(INCLUDES) @<<idl.tmp >>$(NEWDEPENDFILE)
-e
$(INCLUDES_FLAGS)
$(CINC:-I=
-I)
$(INCLUDES_ROOTS:-P=
-P)
-sh
-S$$(MIDL_HDR_OUT_DIR)
$(IDLFILES:.\=
.\)
<<NOKEEP
!endif # IDLFILES

!if "$(TDLFILES)" != ""
    $(ECHOTIME) # ; # MkTypeLib Source files ; # ; >>$(NEWDEPENDFILE)
    $(INCLUDES) @<<tdl.tmp >>$(NEWDEPENDFILE)
-e
$(INCLUDES_FLAGS)
$(CINC:-I=
-I)
$(INCLUDES_ROOTS:-P=
-P)
-stlb
-S$$(OBJDIR)
$(TDLFILES:.\=
.\)
<<NOKEEP

!endif # IDLFILES

#
#   C++ PCH dependencies
#

!if "$(PXXFILE)" != ""
    $(ECHOTIME) # ; # Precompiled C++ header ; # ; ; !ifdef PXXFILE >>$(NEWDEPENDFILE)
#    if exist $(PXXSOURCE) $(INCLUDES) @<<  >>$(NEWDEPENDFILE)
    if exist $(PXXSOURCE) $(INCLUDES) $(INCLUDES_FLAGS) -e -S$$(PCHDIR)\$$(OBJDIR) \
        -L$$(PCHDIR)\$$(OBJDIR) -spxh $(CINC:-I=-I) $(INCLUDES_ROOTS:-P=-P)\
        $(PXXSOURCE) >>$(NEWDEPENDFILE)
#$(INCLUDES_FLAGS)
#-e
#-S$$(PCHDIR)\$$(OBJDIR)
#-L$$(PCHDIR)\$$(OBJDIR)
#-spxh
#$(CINC:-I=
#-I)
#$(INCLUDES_ROOTS:-P=
#-P)
#$(PXXSOURCE)
#<<NOKEEP
    $(SED) "s/$(OBJPATTERN)\(.*\)/$$(OBJDIR)\1 : \
$$(PCHDIR)\\$$(OBJDIR)\\$(PXXFILE:.cxx=.pxh)/" << >>$(NEWDEPENDFILE)
$(CXX_OBJS: =^
)
<<NOKEEP
    $(ECHOTIME) !endif # PXXFILE ; ;>>$(NEWDEPENDFILE)
!endif

#
#   C PCH dependencies
#

!if "$(PFILE)" != ""
    $(ECHOTIME) # ; # Precompiled C header ; # ; ; !ifdef PFILE >>$(NEWDEPENDFILE)
    if exist $(PSOURCE) $(INCLUDES) @<< >>$(NEWDEPENDFILE)
-e
$(INCLUDES_FLAGS)
-S$$(PCHDIR)\$$(OBJDIR)
-L$$(PCHDIR)\$$(OBJDIR)
-sph
$(CINC:-I=
-I)
$(INCLUDES_ROOTS:-P=
-P)
$(PSOURCE)
<<NOKEEP
    $(ECHOTIME) $(C_OBJS:.obj =.obj ; )| \
        $(SED) "s/$(OBJPATTERN)/$$(OBJDIR)/" | \
        $(SED) "s/\.obj/.obj : $$(PCHDIR)\\$$(OBJDIR)\\$(PFILE:.c=.ph)/" >>$(NEWDEPENDFILE)
    $(ECHOTIME) !endif # PFILE ; ;>>$(NEWDEPENDFILE)
!endif
    @$(CMP) -s $(NEWDEPENDFILE) $(DEPENDFILE) $(OUTNUL) || \
        $(COPY) $(NEWDEPENDFILE) $(DEPENDFILE) $(OUTNUL) || \
        (out -f -! $(DEPENDFILE) && $(ECHOTIME) $(DEPENDFILE) checked out... & $(COPY) $(NEWDEPENDFILE) $(DEPENDFILE) $(OUTNUL))
    $(DEL) $(NEWDEPENDFILE) $(OUTNUL)

!endif # DEPENDSRC

############################################################################
#
#   Special Rules for Building NT-like parts of the tree.  For instance,
#   OFS.  Defining RELEASE=NT causes the build to be performed 2 times for
#   this part of the tree.  Once with the current BUILDTYPE, once with the
#   opposite one.  In either case, we release under the current build in
#   either a CHECK\NT\... tree (for DEBUG BUILDTYPE) or FREE\NT\... tree
#   (for RETAIL BUILDTYPE).
#

!if ("$(RELEASE)" == "NT" && "$(BUILD_BOTH)" != "FALSE") || "$(BUILD_BOTH)" == "TRUE"

! if "$(BUILDTYPE)" == "DEBUG"
SECONDBUILDTYPE = RETAIL
! else
SECONDBUILDTYPE = DEBUG
! endif

all tree clean:
      @$(MAKE) -$(MAKEFLAGS) -L BUILDTYPE=$(SECONDBUILDTYPE) RELEASETREE=$(TGTDIR:OBJ=) BUILD_BOTH=FALSE $@

!endif   # RELEASE = NT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\dllhost\main.cxx ===
//+------------------------------------------------------------------
//
// File:	main.cxx
//
// Contents:	common entry point for test drivers.
//
//--------------------------------------------------------------------
#include    <tstmain.hxx>
#include    <tdllhost.h>

//+-------------------------------------------------------------------
//
//  Function:	main
//
//  Synopsis:	Entry point to EXE
//
//  Returns:    TRUE
//
//  History:	21-Nov-92  Rickhi	Created
//
//  Just delegates to a <main> subroutine that is common for all test
//  drivers.
//
//--------------------------------------------------------------------
int _cdecl main(int argc, char **argv)
{
    return DriverMain(argc, argv, "Dll Host", &TestDllHost);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\cfrace\cfrace.cxx ===
//+------------------------------------------------------------------
//
// File:	cfrace.cxx
//
// Contents:	test for class factory race condition
//
//--------------------------------------------------------------------
#include <tstmain.hxx>
#include "cfrace.h"
#include <iballs.h>

// BUGBUG: these should be in a public place somewhere.
DEFINE_OLEGUID(CLSID_Balls,	    0x0000013a, 1, 8);
DEFINE_OLEGUID(CLSID_Cubes,	    0x0000013b, 1, 8);
DEFINE_OLEGUID(CLSID_LoopSrv,	    0x0000013c, 1, 8);

DEFINE_OLEGUID(CLSID_QI,	    0x00000140, 0, 8);
const GUID CLSID_QI =
    {0x00000140,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

DWORD gdwSleepValue = 400;

LONG gcFails = 0;

void TEST_FAILED2(HRESULT hRes, CHAR *pszMsg)
{
    BOOL RetVal = TRUE;
    CHAR szMsg2[80];

    if (FAILED(hRes))
    {
	gcFails++;
	sprintf(szMsg2, "Error:%x %s", hRes, pszMsg);
    }

    TEST_FAILED(FAILED(hRes), (FAILED(hRes)) ? szMsg2 : pszMsg);
}

void TEST_FAILED3(ULONG cRefs, CHAR *pszMsg)
{
    BOOL RetVal = TRUE;
    CHAR szMsg2[80];

    if (cRefs != 0)
    {
	gcFails++;
	sprintf(szMsg2, "cRefs:%x %s", cRefs, pszMsg);
    }

    TEST_FAILED(cRefs != 0, (cRefs != 0) ? szMsg2 : pszMsg);
}

// ----------------------------------------------------------------------
//
//	TestCFRace - main test driver. read the ini file to determine
//		     which tests to run.
//
// ----------------------------------------------------------------------
BOOL TestCFRace(void)
{
    BOOL RetVal = TRUE;
    CHAR szMsg[80];
    LONG cLoops = 0;

    while (1)
    {
	IClassFactory	*pICF	 = NULL;
	IBalls		*pIBalls = NULL;
	ULONG		cRefs	 = 0;

	// get the class object
	HRESULT hRes = CoGetClassObject(CLSID_Balls, CLSCTX_LOCAL_SERVER, NULL,
					IID_IClassFactory, (void **)&pICF);

	TEST_FAILED2(hRes, "CoGetClassObject failed\n");

	if (SUCCEEDED(hRes))
	{
	    // lock server
	    hRes = pICF->LockServer(TRUE);
	    TEST_FAILED2(hRes, "LockServer TRUE failed\n");

	    if (SUCCEEDED(hRes))
	    {
		// create instance
		hRes = pICF->CreateInstance(NULL, IID_IBalls, (void **)&pIBalls);
		TEST_FAILED2(hRes, "CreateInstance failed\n");

		// unlock server
		hRes = pICF->LockServer(FALSE);
		TEST_FAILED2(hRes, "LockServer FALSE failed\n");
	    }

	    // release class object
	    cRefs = pICF->Release();
	    TEST_FAILED3(cRefs, "Release pICF not 0\n");

	    if (pIBalls)
	    {
		// call instance
		hRes = pIBalls->MoveBall(10, 20);
		TEST_FAILED2(hRes, "pIBalls MoveBall failed\n");

		// release instance
		cRefs = pIBalls->Release();
		TEST_FAILED3(cRefs, "Release pIBalls not 0\n");
	    }
	}

	cLoops++;
	sprintf(szMsg, "    - Iterations:%x  Fails:%x\n", cLoops, gcFails);
	OUTPUT(szMsg);
	Sleep(gdwSleepValue);
    }

    return  RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\prxytest\prxytest.cxx ===
//+-------------------------------------------------------------------
//
//  File:	climain.cxx
//
//  Contents:	server test program to test OLE2 RPC
//
//  Classes:	None
//
//  Functions:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

#include    <windows.h>
#include    <ole2.h>
#include    <stdio.h>

#include    <rpctyp.h>		//  IRpcTypes interface



SCODE TestGuids(IRpcTypes *pRpc);
SCODE TestDwords(IRpcTypes *pRpc);

#define DebugOut(x) printf x



int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR lpCmdLine, int nCmdShow)
{
    DebugOut (("Test: Starting\n"));

    //	initialize with OLE2
    SCODE sc = OleInitialize(NULL);
    if (FAILED(sc))
    {
	DebugOut (("Test: OleInitialize = %x\n", sc));
	return sc;
    }

    //	create an instance
    sc = CoGetClassObject(CLSID_RpcTypes,
			  CLSCTX_LOCAL_SERVER,
			  NULL,
			  IID_IClassFactory,
			  (void **)&pCF);

    if (FAILED(sc))
    {
	DebugOut (("Test: CoGetClassObject=%x\n", sc));
	return sc;
    }

    sc = pCF->CreateInstance(NULL, IID_IRpcTypes, (void **)&pRpc);
    sc = pCF->Release();

    if (FAILED(sc))
    {
	DebugOut(("Test: CreateInstance=%x\n", sc));
	return sc;
    }


    sc = TestVoid(pRpc);

    sc = TestGuids(pRpc);

    sc = TestDwords(pRpc)

    sc = TestWindows(pRpc);

    sc = TestOleData(pRpc);


    //	finished with OLE2

    OleUninitialize();
    DebugOut (("Test: CoUninitialize called.\n"));

    return  sc;
}





SCODE TestGuids(IRpcTypes *pRpc)
{
    REFCLSID	     rclsid;
    CLSID	     clsid;
    REFIID	     riid;
    IID 	     iid;
    GUID	     guid;

    //	initialize the parameters

    SCODE sc = pRpc->GuidsIn(rclsid, clsid, riid, iid, guid);

    if (FAILED(sc))
    {
	DebugOut (("\n"));
    }


    sc = pRpc->GuidsOut(&clsid, &iid, &guid);

    if (FAILED(sc))
    {
	DebugOut (("\n"));
    }

    //	check the return values


    return S_OK;
}


SCODE TestDwords(IRpcTypes *pRpc)
{
    DWORD		dw = 1;
    ULONG		ul = 2;
    LONG		lg = 3;
    LARGE_INTEGER	li;
    ULARGE_INTEGER	uli;

    //	methods to test DWORD / LARGE_INTEGER parameter passing
    li.LowPart = 4;
    li.HighPart = 5;

    uli.LowPart = 6;
    uli.HighPart = 7;

    sc = pRpc->DwordIn(dw, ul, lg, li, uli);

    if (FAILED(sc))
    {
	DebugOut (("\n"));
    }

    sc = pRpc->DwordIn(&dw, &ul, &lg, &li, &uli);

    if (FAILED(sc))
    {
	DebugOut (("\n"));
    }

    //	check the return values

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\dllhost\tdllhost.cxx ===
//+------------------------------------------------------------------
//
// File:	tdllhost.cxx
//
// Contents:	test for dll hosting
//
//--------------------------------------------------------------------
#include <tstmain.hxx>
#include "tdllhost.h"


// BUGBUG: these should be in a public place somewhere.
DEFINE_OLEGUID(CLSID_Balls,	    0x0000013a, 1, 8);
DEFINE_OLEGUID(CLSID_Cubes,	    0x0000013b, 1, 8);
DEFINE_OLEGUID(CLSID_LoopSrv,	    0x0000013c, 1, 8);

DEFINE_OLEGUID(CLSID_QI,	    0x00000140, 0, 8);
const GUID CLSID_QI =
    {0x00000140,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_QIHANDLER1 =
    {0x00000141,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


const TCHAR *pszRegValThreadModel   = TEXT("ThreadingModel");
const TCHAR *pszSingleModel	    = TEXT("Single");
const TCHAR *pszApartmentModel	    = TEXT("Apartment");
const TCHAR *pszMultiThreadedModel  = TEXT("Free");
const TCHAR *pszBothModel	    = TEXT("Both");

BOOL  gfApt;

// ----------------------------------------------------------------------
//
//  Structures and Function Prototypes
//
// ----------------------------------------------------------------------
typedef struct tagLoadDLLParams
{
    DWORD	dwCallingTID; // tid of calling thread
    DWORD	dwCoInitFlag; // flag to initialize OLE with
    DWORD	dwItfFlag;    // flag if the resulting object should be a proxy
    BOOL	RetVal;       // return value
    HANDLE	hEvent;       // thread completion event
} SLoadDLLParam;

typedef enum tagITFFLAGS
{
    ITF_REAL	    = 1,      // expect ptr to real object
    ITF_PROXY	    = 2       // expect ptr to proxy object
} ITFFLAGS;


// worker subroutines
BOOL	       SpinThread(DWORD dwInitFlag, DWORD dwItfFlag);
DWORD _stdcall LoadDLLOnThread(void *param);
BOOL	       LoadClassObject(DWORD dwItfFlag);
BOOL	       SetRegForDll(REFCLSID rclsid, const TCHAR *pszThreadModel);


//  test routines  - return value of TRUE return means the test passed
BOOL TestLoadSingleThreaded(void);
BOOL TestLoadApartmentThreaded(void);
BOOL TestLoadMultiThreaded(void);
BOOL TestLoadBothThreaded(void);


// ----------------------------------------------------------------------
//
//	TestDllHost - main test driver. read the ini file to determine
//		      which tests to run.
//
// ----------------------------------------------------------------------
BOOL TestDllHost(void)
{
    BOOL RetVal = TRUE;

    gfApt = (gInitFlag == COINIT_APARTMENTTHREADED) ? TRUE : FALSE;

    // the driver did a CoInitialize, we dont want one so do CoUninit.
    CoUninitialize();

    if (GetProfileInt(TEXT("DllHost Test"),TEXT("LoadSingleThreaded"),1))
	RetVal &= TestLoadSingleThreaded();

    if (GetProfileInt(TEXT("DllHost Test"),TEXT("LoadApartmentThreaded"),1))
	RetVal &= TestLoadApartmentThreaded();

    if (GetProfileInt(TEXT("DllHost Test"),TEXT("LoadMultiThreaded"),1))
	RetVal &= TestLoadMultiThreaded();

    if (GetProfileInt(TEXT("DllHost Test"),TEXT("LoadBothThreaded"),1))
	RetVal &= TestLoadBothThreaded();

    // re-initialize so we dont get a complaint from OLE in debug builds
    // about an unbalanced call to Uninitialize.
    CoInitializeEx(NULL, gInitFlag);

    return  RetVal;
}



// ----------------------------------------------------------------------
//
//	TestLoadSingleThreaded
//
//	Tests loading a single-threaded DLL
//
// ----------------------------------------------------------------------
BOOL TestLoadSingleThreaded(void)
{
    BOOL	    RetVal = TRUE, RetVal2 = TRUE;
    HRESULT	    hRes = S_OK;

    OUTPUT ("\n\nStarting TestLoadSingleThreaded\n");

    // First, mark the DLL appropriately in the registry.
    RetVal2 = SetRegForDll(CLSID_QI, pszSingleModel);
    TEST_FAILED(!RetVal2, "SetRegForDLL Failed\n");


    hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "CoInitializeEx Failed\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Single-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_REAL : ITF_PROXY);
    TEST_FAILED(!RetVal2, "SingleThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Single-Threaded DLL on Main Thread\n");

    OUTPUT ("\n   Load Single-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_REAL : ITF_PROXY);
    TEST_FAILED(!RetVal2, "SingleThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Single-Threaded DLL on Main Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Single-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "SingleThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Done Load Single-Threaded DLL on Different Apartment Thread\n");

    OUTPUT ("\n   Second Load Single-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "Single-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Second Done Load Single-Threaded DLL on Different Apartment Thread\n");


// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Single-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "SingleThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Single-Thread DLL on Multi-Threaded Apartment Thread\n");

    OUTPUT ("\n   Load Single-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "SingleThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Single-Thread DLL on Multi-Threaded Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    CoUninitialize();

    BOOL fResult = TestResult(RetVal, "TestLoadSingleThreaded");
    Sleep(2000);
    return fResult;
}


// ----------------------------------------------------------------------
//
//	TestLoadApartmentThreaded
//
//	Tests loading an apartment-threaded DLL
//
// ----------------------------------------------------------------------
BOOL TestLoadApartmentThreaded(void)
{
    BOOL	    RetVal = TRUE, RetVal2 = FALSE;
    HRESULT	    hRes = S_OK;

    OUTPUT ("\n\nStarting TestLoadApartmentThreaded\n");

    // First, mark the DLL appropriately in the registry.
    RetVal2 = SetRegForDll(CLSID_QI, pszApartmentModel);
    TEST_FAILED(!RetVal2, "SetRegForDLL Failed\n");

    hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "CoInitializeEx Failed\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Apartment-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_REAL : ITF_PROXY);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Apartment-Threaded DLL on Main Thread\n");

    OUTPUT ("\n   Load Apartment-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_REAL : ITF_PROXY);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Apartment-Threaded DLL on Main Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Apartment-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Done Load Apartment-Threaded DLL on Different Apartment Thread\n");

    OUTPUT ("\n   Second Load Apartment-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Second Done Load Apartment-Threaded DLL on Different Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "Apartment-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    CoUninitialize();

    BOOL fResult = TestResult(RetVal, "TestLoadApartmentThreaded");
    Sleep(2000);
    return fResult;
}


// ----------------------------------------------------------------------
//
//	TestLoadMultiThreaded
//
//	Tests loading a multi-threaded DLL
//
// ----------------------------------------------------------------------
BOOL TestLoadMultiThreaded(void)
{
    BOOL	    RetVal = TRUE, RetVal2 = FALSE;;
    HRESULT	    hRes = S_OK;

    OUTPUT ("\n\nStarting TestLoadMultiThreaded\n");

    // First, mark the DLL appropriately in the registry.
    RetVal2 = SetRegForDll(CLSID_QI, pszMultiThreadedModel);
    TEST_FAILED(!RetVal2, "SetRegForDLL Failed\n");

    hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "CoInitializeEx Failed\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Free-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_PROXY : ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Free-Threaded DLL on Main Thread\n");

    OUTPUT ("\n   Load Free-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject((gfApt) ? ITF_PROXY : ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Free-Threaded DLL on Main Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Free-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Done Load Free-Threaded DLL on Different Apartment Thread\n");

    OUTPUT ("\n   Second Load Free-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_PROXY);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Second Done Load Apartment-Threaded DLL on Different Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Free-Thread DLL on Multi-Threaded Apartment Thread\n");

    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Free-Thread DLL on Multi-Threaded Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    CoUninitialize();

    BOOL fResult = TestResult(RetVal, "TestLoadMultiThreaded");
    Sleep(2000);
    return fResult;
}


// ----------------------------------------------------------------------
//
//	TestLoadBothThreaded
//
//	Tests loading a both-threaded DLL
//
// ----------------------------------------------------------------------
BOOL TestLoadBothThreaded(void)
{
    BOOL	    RetVal = TRUE, RetVal2 = FALSE;;
    HRESULT	    hRes = S_OK;

    OUTPUT ("\n\nStarting TestLoadBothThreaded\n");

    // First, mark the DLL appropriately in the registry.
    RetVal2 = SetRegForDll(CLSID_QI, pszBothModel);
    TEST_FAILED(!RetVal2, "SetRegForDLL Failed\n");

    hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "CoInitializeEx Failed\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Both-Threaded DLL on Main Thread\n");

    RetVal2 = LoadClassObject(ITF_REAL);
    TEST_FAILED(!RetVal2, "Both-ThreadedDLL on Main Thread Failed\n");

    OUTPUT ("   Done Load Both-Threaded DLL on Main Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Both-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Done Load Free-Threaded DLL on Different Apartment Thread\n");

    OUTPUT ("\n   Second Load Free-Threaded DLL on Different Apartment Thread\n");

    hRes = SpinThread(COINIT_APARTMENTTHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Apartment Thread Failed\n");

    OUTPUT ("   Second Done Load Free-Threaded DLL on Different Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Free-Thread DLL on Multi-Threaded Apartment Thread\n");

    OUTPUT ("\n   Load Apartment-Thread DLL on Multi-Threaded Apartment Thread\n");

    hRes = SpinThread(COINIT_MULTITHREADED, ITF_REAL);
    TEST_FAILED(!RetVal2, "Free-ThreadedDLL on Multi Thread Failed\n");

    OUTPUT ("   Done Load Free-Thread DLL on Multi-Threaded Apartment Thread\n");

// ----------------------------------------------------------------------
    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    CoUninitialize();

    BOOL fResult = TestResult(RetVal, "TestLoadBothThreaded");
    Sleep(2000);
    return fResult;
}


// ----------------------------------------------------------------------
//
//  Function:	SpinThread
//
//  Synopsis:	Creates a thread to do some work for us. Waits for it to
//		complete. Returns the results.
//
// ----------------------------------------------------------------------
BOOL SpinThread(DWORD dwInitFlag, DWORD dwItfFlag)
{
    BOOL RetVal = FALSE;

    // set up paramters to pass to the thread

    SLoadDLLParam   LoadParam;
    LoadParam.dwCallingTID = GetCurrentThreadId();
    LoadParam.dwCoInitFlag = dwInitFlag;
    LoadParam.dwItfFlag    = dwItfFlag;
    LoadParam.RetVal	   = FALSE;
    LoadParam.hEvent	   = CreateEvent(NULL, FALSE, FALSE, NULL);

    // create the thread

    DWORD  dwThrdId = 0;
    HANDLE hThrd = CreateThread(NULL, 0,
				LoadDLLOnThread,
				&LoadParam, 0, &dwThrdId);
    if (hThrd)
    {
	// enter a message loop and wait for the other thread to run
	// We stay here until the thread posts a QUIT message.

	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0))
	{
	    DispatchMessage(&msg);
	}

	// close the thread handle
	CloseHandle(hThrd);
    }
    else
    {
	HRESULT hRes = GetLastError();
	TEST_FAILED(hRes, "CreateThread failed\n")
	LoadParam.RetVal = RetVal;
    }

    // wait for the other thread to complete
    WaitForSingleObject(LoadParam.hEvent, 0xffffffff);
    CloseHandle(LoadParam.hEvent);

    return LoadParam.RetVal;
}

// ----------------------------------------------------------------------
//
//  Function:	LoadDLLOnThread
//
//  Synopsis:	Initializes COM, loads the class object and creates an
//		instance, releases them, Posts a message to wake up the
//		calling thread, Uninitializes COM, then exits.
//
// ----------------------------------------------------------------------
DWORD _stdcall LoadDLLOnThread(void *param)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    SLoadDLLParam   *pLoadParam = (SLoadDLLParam *)param;

    OUTPUT ("       - LoadDLLOnThread Entered\n");
    hRes = CoInitializeEx(NULL, pLoadParam->dwCoInitFlag);
    TEST_FAILED(FAILED(hRes), "CoInitialize failed\n")

    if (SUCCEEDED(hRes))
    {
	// attempt to load the class object on this thread.
	pLoadParam->RetVal = LoadClassObject(pLoadParam->dwItfFlag);
	CoUninitialize();
    }

    // post a message to the server thread to exit now that we are done.
    PostThreadMessage(pLoadParam->dwCallingTID, WM_QUIT, 0, 0);
    SetEvent(pLoadParam->hEvent);

    OUTPUT ("       - LoadDLLOnThread Exit\n");
    return RetVal;
}

// ----------------------------------------------------------------------
//
//  Function:	LoadClassObject
//
//  Synopsis:	Loads the class object, creates an instance, releases
//		them, returns the results.
//
// ----------------------------------------------------------------------
BOOL LoadClassObject(DWORD dwItfFlag)
{
    BOOL	    RetVal = TRUE;
    IClassFactory   *pICF  = NULL;
    IUnknown	    *pIPM  = NULL;

    //	try to load the dll class object
    HRESULT hRes = CoGetClassObject(CLSID_QI, CLSCTX_INPROC_SERVER, NULL,
				    IID_IClassFactory, (void **)&pICF);

    TEST_FAILED(FAILED(hRes), "CoGetClassObject failed\n");

    if (SUCCEEDED(hRes))
    {
	hRes = pICF->QueryInterface(IID_IProxyManager, (void **)&pIPM);

	if (SUCCEEDED(hRes))
	{
	    pIPM->Release();
	    TEST_FAILED(dwItfFlag != ITF_PROXY, "Got Proxy when expected Real\n");
	}
	else
	{
	    TEST_FAILED(dwItfFlag != ITF_REAL, "Got Real when expected Proxy\n");
	}

	// CODEWORK: create an instance, then release them

	// release the class object.
	OUTPUT ("       - CoGetClassObject succeeded\n");

	ULONG ulRefCnt = pICF->Release();
	TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
	pICF = NULL;
	OUTPUT ("       - Released ClassObject\n");
    }

    return RetVal;
}



//+-------------------------------------------------------------------
//
//  Function:   SetRegForDll, private
//
//  Synopsis:   Set registry entry for a DLL
//
//  Arguments:  [rclsid] - clsid for reg entry
//              [pszThreadModel] - threading model can be NULL.
//
//  Returns:    TRUE - Registry entry set successfully.
//              FALSE - Registry entry set successfully.
//
//  History:    01-Nov-94   Ricksa       Created
//
//--------------------------------------------------------------------
BOOL SetRegForDll(REFCLSID rclsid, const TCHAR *pszThreadModel)
{
    BOOL fResult   = FALSE;
    HKEY hKeyClass = NULL;
    HKEY hKeyDll   = NULL;
    TCHAR aszWkBuf[MAX_PATH]; // String buffer used for various purposes

    // Build clsid registry key
    wsprintf(aszWkBuf,
        TEXT("CLSID\\{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"),
        rclsid.Data1, rclsid.Data2, rclsid.Data3,
        rclsid.Data4[0], rclsid.Data4[1],
        rclsid.Data4[2], rclsid.Data4[3],
        rclsid.Data4[4], rclsid.Data4[5],
        rclsid.Data4[6], rclsid.Data4[7]);

    // Create the key for the class
    if (RegCreateKey(HKEY_CLASSES_ROOT, aszWkBuf, &hKeyClass) == ERROR_SUCCESS)
    {
	// Create the key for the DLL
	if (RegCreateKey(hKeyClass, TEXT("InprocServer32"), &hKeyDll) == ERROR_SUCCESS)
	{
	    // Set the value for the Threading Model
	    if (RegSetValueEx(hKeyDll, pszRegValThreadModel, 0,
				  REG_SZ,
				  (const unsigned char*) pszThreadModel,
				  (wcslen(pszThreadModel) + 1) * sizeof(WCHAR))
		== ERROR_SUCCESS)
	    {
		fResult = TRUE;
	    }

	    RegCloseKey(hKeyDll);
	}

        RegCloseKey(hKeyClass);
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\dllhost\tdllhost.h ===
#ifndef __TDLLHOST_H__
#define __TDLLHOST_H__

BOOL TestDllHost(void);

#endif // __TDLLHOST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\smarshal\smarshal.cxx ===
//+-------------------------------------------------------------------
//
//  File:	smarshal.cxx
//
//  Synopsis:	Source code for Interface Marshaling stress test main
//		driver functions. Source for individual tests is in
//		testvar.cxx
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
#include <smarshal.hxx>

//+-------------------------------------------------------------------
//
//  Globals:
//
//--------------------------------------------------------------------
BOOL  gfVerbose		= FALSE;    // print execution messages
BOOL  gfDebug		= FALSE;    // print debug messages

DWORD giThreadModel	= OPF_INITAPARTMENT; // threading model to use
int   giTestVar		= 0;	    // test variation to run
int   giHighestTestVar	= 2;	    // highest test var supported

int  gicReps		= 5;	    // number of repetitions of each test
int  gicThreads 	= 1;	    // number of threads to use on each test


//+-------------------------------------------------------------------
//
//  Private Function ProtoTypes:
//
//--------------------------------------------------------------------
HRESULT 	DoIfOperation(DWORD dwFlags, INTERFACEPARAMS *pIFD);
void		DisplayHelp(void);
BOOL		GetSwitch(CHAR *pCmdParam, CHAR *pszSwitch);
BOOL		GetSwitchInt(CHAR *pCmdParam, CHAR *pszSwitch, int *pInt);
BOOL		ParseCmdLine(int argc, char **argv);
int  _cdecl	main(int argc, char **argv);

BOOL		FreeWaitForEvent(HANDLE hEvent);
BOOL		AptWaitForEvent(HANDLE hEvent);

STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phdl);

//+-------------------------------------------------------------------
//
//  Misc:
//
//--------------------------------------------------------------------

#ifndef _CAIRO_
// COM initialization flags; passed to CoInitialize.
typedef enum tagCOINIT
{
    COINIT_MULTITHREADED      = 0,  // OLE calls objects on any thread.
    COINIT_SINGLETHREADED     = 1,  // OLE calls objects on single thread.
    COINIT_APARTMENTTHREADED  = 2   // Apartment model
} COINIT;

WINOLEAPI  CoInitializeEx(LPVOID pvReserved, DWORD);
#endif



//+-------------------------------------------------------------------
//
//  Function:	main
//
//  Synopsis:	Entry point to EXE. Parse the command line, then run
//		whatever test variations were selected.
//
//  Notes:	The test variation code is in testvars.cxx.
//		The rest of this file is helper routines.
//
//--------------------------------------------------------------------
int _cdecl main(int argc, char **argv)
{
    // parse the command line
    BOOL fRes = ParseCmdLine(argc, argv);

    if (fRes)
    {
	// run the selected test variations
	switch (giTestVar)
	{
	    case 1: fRes = TestVar1();
		    break;
	    case 2: fRes = TestVar2();
		    break;
	    default: break;
	}
    }

    // check the results
    CHKTESTRESULT(fRes, "Marshal Stress Tests");
    return 0;
}

//+-------------------------------------------------------------------
//
//  Function:	ParseCmdLine
//
//  Synopsis:	parses the execution parameters
//
//--------------------------------------------------------------------
BOOL ParseCmdLine(int argc, char **argv)
{
    BOOL fDontRun = (argc == 1) ? TRUE : FALSE;

    // the first parameter is the EXE name, skip it.
    argc--;
    argv++;

    for (int i=0; i<argc; i++, argv++)
    {
	if (GetSwitch(*argv, "v"))
	{
	    // run verbose
	    gfVerbose = TRUE;
	}
	else if (GetSwitch(*argv, "d"))
	{
	    // run debug mode
	    gfVerbose = TRUE;
	    gfDebug   = TRUE;
	}
	else if (GetSwitch(*argv, "h") || GetSwitch(*argv, "?"))
	{
	    // help wanted
	    fDontRun = TRUE;
	}
	else if (GetSwitchInt(*argv, "var:", &giTestVar))
	{
	    // selected test variation, ensure the variation is valid
	    if (giTestVar > giHighestTestVar)
	    {
		ERROUT("Unknown Test Variation:%x\n", giTestVar);
		fDontRun = TRUE;
	    }
	}
	else if (GetSwitchInt(*argv, "reps:", &gicReps))
	{
	    ; // selected repetition count
	}
	else if (GetSwitchInt(*argv, "threads:", &gicThreads))
	{
	    ; // selected thread count
	}
	else if (GetSwitch(*argv, "model:apt"))
	{
	    // run apartment model
	    giThreadModel = OPF_INITAPARTMENT;
	}
	else if (GetSwitch(*argv, "model:free"))
	{
	    // run freethreaded model
	    giThreadModel = OPF_INITFREE;
	}
	else
	{
	    // unknown switch, show help
	    ERROUT("Unknown command line switch:<%s>\n", *argv);
	    fDontRun = TRUE;
	}
    }

    if (fDontRun)
    {
	// help is wanted
	DisplayHelp();
	return FALSE;
    }

    // success, run the test
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:	DisplayHelp
//
//  Synopsis:	displays a command line help message
//
//--------------------------------------------------------------------
void DisplayHelp(void)
{
    printf("\nCommand Line Switches for Marshal Stress Test:\n\n");

    printf("-d         - debug mode\n");
    printf("-v         - verbose mode\n");
    printf("-h | -?    - display this help message\n\n");

    printf("-model:[apt|free] - threading model to use for test\n");
    printf("-var:#     - test variation to execute 1-%x\n", giHighestTestVar);
    printf("-threads:# - number of threads per variation\n");
    printf("-reps:#    - number of repetitions of the test\n");

    printf("\n");
}

//+-------------------------------------------------------------------
//
//  Function:	GetSwitch
//
//  Synopsis:	returns TRUE if the specified cmd line switch is set.
//
//--------------------------------------------------------------------
BOOL GetSwitch(CHAR *pCmdParam, CHAR *pszSwitch)
{
    if (*pCmdParam == '-' || *pCmdParam == '/')
    {
	pCmdParam++;
	return (!stricmp(pCmdParam, pszSwitch));
    }
    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Function:	GetSwitchInt
//
//  Synopsis:	returns TRUE if the specified cmd line switch is set,
//		and sets the value of that switch.
//
//--------------------------------------------------------------------
BOOL GetSwitchInt(CHAR *pCmdParam, CHAR *pszSwitch, int *pInt)
{
    if (*pCmdParam == '-' || *pCmdParam == '/')
    {
	pCmdParam++;
	int len = strlen(pszSwitch);
	if (!strnicmp(pCmdParam, pszSwitch, len))
	{
	    pCmdParam += len;
	    *pInt = atoi(pCmdParam);
	    return TRUE;
	}
    }

    return FALSE;
}

//+-------------------------------------------------------------------
//
//  Function:	CHKRESULT
//
//  Synopsis:	prints a failure message if the result code indicates
//		failure., and success message only in verbose mode.
//
//--------------------------------------------------------------------
void CHKRESULT(HRESULT hr, CHAR *pszOperation)
{
    if (FAILED(hr))
    {
	printf("FAILED hr:%x Op:%s\n", hr, pszOperation);
    }
    else if (gfVerbose)
    {
	printf("PASSED hr:%x Op:%s\n", hr, pszOperation);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	CHKOP
//
//  Synopsis:	prints a failure message if the result code indicates
//		failure, and success message only in debug mode.
//
//--------------------------------------------------------------------
void CHKOP(HRESULT hr, CHAR *pszOperation)
{
    if (FAILED(hr))
    {
	printf("FAILED hr:%x Op:%s\n", hr, pszOperation);
    }
    else if (gfDebug)
    {
	printf("PASSED hr:%x Op:%s\n", hr, pszOperation);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	CHKTESTRESULT
//
//  Synopsis:	prints a pass or fail message
//
//--------------------------------------------------------------------
void CHKTESTRESULT(BOOL fRes, CHAR *pszMsg)
{
    if (fRes)
	printf("%s PASSED\n", pszMsg);
    else
	printf("%s FAILED\n", pszMsg);
}

//+-------------------------------------------------------------------
//
//  Function:	GetEvent / ReleaseEvent
//
//  Synopsis:	allocates or releases an event
//
//  CODEWORK:	cache these for frequent use
//
//--------------------------------------------------------------------
HANDLE GetEvent()
{
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hEvent == NULL)
    {
	ERROUT("GetEvent FAILED\n");
    }
    DBGOUT("CreateEvent hEvent:%x\n", hEvent);
    return hEvent;
}

void ReleaseEvent(HANDLE hEvent)
{
    if (hEvent)
    {
	DBGOUT("ReleaseEvent hEvent:%x\n", hEvent);
	CloseHandle(hEvent);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	WaitForEvent
//
//  Synopsis:	waits on the given event (if there is one) for a
//		certain amount of time, returns FALSE if timedout.
//
//--------------------------------------------------------------------
BOOL WaitForEvent(HANDLE hEvent)
{
    if (hEvent)
    {
	// CODEWORK: base off the Threading Model

	return (TRUE) ? AptWaitForEvent(hEvent) :
			FreeWaitForEvent(hEvent);
    }
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:	FreeWaitForEvent
//
//  Synopsis:	FreeThreaded version of WaitForEvent. Waits on the
//		given event.
//
//--------------------------------------------------------------------
BOOL FreeWaitForEvent(HANDLE hEvent)
{
    DBGOUT("FreeWaitForEvent hEvent:%x\n", hEvent);
    if (WaitForSingleObject(hEvent, 30000) == WAIT_TIMEOUT)
    {
	ERROUT("WaitForSingleObject TimedOut");
	return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:	AptWaitForEvent
//
//  Synopsis:	Apartment model version of WaitForEvent. Waits on the
//		given event. Dispatches all incoming windows messages
//		while waiting.
//
//--------------------------------------------------------------------
BOOL AptWaitForEvent(HANDLE hEvent)
{
    DBGOUT("AptWaitForEvent hEvent:%x\n", hEvent);

    while (1)
    {
	HANDLE	arEvent[] = {hEvent};
	DWORD dwWakeReason = MsgWaitForMultipleObjects(1, arEvent, FALSE,
						       1000, QS_ALLINPUT);

	if (dwWakeReason == WAIT_OBJECT_0)
	{
	    // event was signalled. exit.
	    break;
	}
	else
	{
	    // check for and dispatch any messages that have arrived
	    MSG msg;
	    while (PeekMessage(&msg, 0, WM_NULL, WM_NULL, PM_REMOVE))
	    {
		DispatchMessage(&msg);
	    }
	}
    }
    return TRUE;
}

//+-------------------------------------------------------------------
//
//  Function:	SignalEvent
//
//  Synopsis:	signals an event (if there is one)
//
//--------------------------------------------------------------------
void SignalEvent(HANDLE hEvent)
{
    if (hEvent)
    {
	DBGOUT("SignalEvent hEvent:%x\n", hEvent);
	SetEvent(hEvent);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	GetStream / ReleaseStream
//
//  Synopsis:	allocates or releases a Stream
//
//  CODEWORK:	cache these for frequent use
//  CODEWORK:	use CStreamOnFile for cross process/machine marshaling.
//
//--------------------------------------------------------------------
IStream * GetStream(void)
{
    IStream *pStm = CreateMemStm(600, NULL);
    if (pStm == NULL)
    {
	ERROUT("ERROR: GetStream FAILED\n");
    }
    DBGOUT("GetStream pStm:%x\n", pStm);
    return pStm;
}

void ReleaseStream(IStream *pStm)
{
    if (pStm)
    {
	DBGOUT("ReleaseStream pStm:%x\n", pStm);
	pStm->Release();
    }
}

//+-------------------------------------------------------------------
//
//  Function:	ResetStream
//
//  Synopsis:	resets a steam back to the start
//
//--------------------------------------------------------------------
HRESULT ResetStream(IStream *pStm)
{
    DBGOUT("ResetStream pStm:%x\n", pStm);

    LARGE_INTEGER libMove;
    libMove.LowPart = 0;
    libMove.HighPart = 0;

    HRESULT hr = pStm->Seek(libMove, STREAM_SEEK_SET, 0);
    if (FAILED(hr))
    {
	ERROUT("ERROR: ResetStream FAILED hr:%x\n",hr);
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:	GetInterface / ReleaseInterface
//
//  Synopsis:	allocates or releases an object interface
//
//--------------------------------------------------------------------
IUnknown *GetInterface(void)
{
    IUnknown *punk = (IUnknown *) new CTestUnk();
    if (punk == NULL)
    {
	ERROUT("ERROR: GetInterface FAILED\n");
    }
    DBGOUT("GetInterface punk:%x\n", punk);
    return punk;
}

void ReleaseInterface(IUnknown *punk)
{
    if (punk)
    {
	DBGOUT("ReleaseInterface punk:%x\n", punk);
	punk->Release();
    }
}

//+-------------------------------------------------------------------
//
//  Function:	GenericExecute
//
//  Synopsis:	run all the parameter blocks on different threads
//		simultaneously.
//
//--------------------------------------------------------------------
BOOL GenericExecute(ULONG cEPs, EXECPARAMS *pEP[])
{
    BOOL fRes = TRUE;
    DBGOUT("Start GenericExecute cEPs:%x\n", cEPs);

    HANDLE hThread[50];

    // launch a thread to run each command block
    for (ULONG i=0; i<cEPs; i++)
    {
	// launch a thread to execute the parameter block
	DWORD  dwThreadId;
	hThread[i] = CreateThread(NULL, 0,
			    WorkerThread,
			    pEP[i],
			    0,
			    &dwThreadId);
    }

    // signal all the threads to start their work
    for (i=0; i<cEPs; i++)
    {
	SignalEvent(pEP[i]->hEventThreadStart);
    }

    // wait for all the threads to complete their work
    for (i=0; i<cEPs; i++)
    {
	if (pEP[i]->hEventThreadDone)
	{
	    WaitForSingleObject(pEP[i]->hEventThreadDone, 60000);
	}
    }

    // signal all the threads to exit
    for (i=0; i<cEPs; i++)
    {
	HANDLE hEventThreadExit = pEP[i]->hEventThreadExit;
	pEP[i]->hEventThreadExit = NULL;// set to NULL so only the thread will
					// release it, genericcleanup wont.
	SignalEvent(hEventThreadExit);
    }

    // wait for all the threads to exit
    for (i=0; i<cEPs; i++)
    {
	WaitForSingleObject(hThread[i], 5000);
	CloseHandle(hThread[i]);
    }

    DBGOUT("Done GenericExecute fRes:%x\n", fRes);
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Function:	GenericCleanup
//
//  Synopsis:	clean all the parameter blocks
//
//--------------------------------------------------------------------
void GenericCleanup(ULONG cEPs, EXECPARAMS *pEP[])
{
    DBGOUT("GenericCleanup\n");

    // delete the execution parameter blocks
    for (ULONG i=0; i<cEPs; i++)
    {
	ReleaseExecParam(pEP[i]);
	// CODEWORK: get results from the parameter block?
    }
}

//+-------------------------------------------------------------------
//
//  Function:	WorkerThread
//
//  Synopsis:	entry point for thread that executes a series of
//		interface commands
//
//--------------------------------------------------------------------
DWORD _stdcall WorkerThread(void *params)
{
    DBGOUT("StartWorkerThread TID:%x pEP:%x\n", GetCurrentThreadId(), params);

    EXECPARAMS	*pEP = (EXECPARAMS *)params;
    if (pEP == NULL)
    {
	return E_OUTOFMEMORY;
    }

    HRESULT	hr = S_OK;

    // Initialize OLE for this thread.
    if (pEP->dwFlags & OPF_INITAPARTMENT)
    {
	hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    }
    else
    {
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }

    if (FAILED(hr))
    {
	ERROUT("ERROR: CoInitializeEx FAILED\n");
	return hr;
    }

    // wait for signal to start the test
    if (!WaitForEvent(pEP->hEventThreadStart))
    {
	return E_OUTOFMEMORY;	// BUGBUG
    }

    // loop for the number of reps requested
    for (ULONG iRep = 0; iRep < pEP->cReps; iRep++)
    {
	// wait for the start signal
	if (!WaitForEvent(pEP->hEventRepStart))
	{
	    return E_OUTOFMEMORY;   // BUGBUG
	}

	MSGOUT("    TID:%x Rep:%x of %x\n",
		    GetCurrentThreadId(), iRep, pEP->cReps);

	// loop for the number of INTERFACEPARAMSs, performing
	// the requested operation(s) on each interface.

	for (ULONG iIP=0; iIP < pEP->cIPs; iIP++)
	{
	    hr = DoIfOperation(pEP->dwFlags, &(pEP->aIP[iIP]));
	}

	// signal the completion event
	SignalEvent(pEP->hEventRepDone);
    }

    // signal the thread completion event. Cant touch pEP after this
    // point in time since the main thread may delete it. We extract
    // the ThreadExit event and NULL it in the parameter block so that
    // the main thread wont release it. We release it after the event
    // has been signaled.

    HANDLE hEventThreadExit = pEP->hEventThreadExit;
    SignalEvent(pEP->hEventThreadDone);

    // wait on the thread exit event. This allows other threads to
    // complete their work (eg unmarshaling/Releasing interfaces on
    // object in this thread.

    WaitForEvent(hEventThreadExit);
    ReleaseEvent(hEventThreadExit);

    // uninitialize OLE for this thread
    CoUninitialize();

    DBGOUT("ExitWorkerThread TID:%x hr:%x\n", GetCurrentThreadId(), hr);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:	DoIfOperation
//
//  Synopsis:	executes one interface operation
//
//--------------------------------------------------------------------
HRESULT DoIfOperation(DWORD dwFlags, INTERFACEPARAMS *pIP)
{
    // find the interface pointers and IID in the params
    IUnknown *punk = pIP->punk;
    IStream  *pStm = pIP->pStm;
    REFIID    riid = pIP->iid;
    HRESULT   hr   = S_OK;

    DBGOUT("DoIfOperation Oper:%x pUnk:%x pStm:%x\n", dwFlags, punk, pStm);

    // wait for the start signal
    if (!WaitForEvent(pIP->hEventStart))
    {
	return -1;
    }

    // do the requested operation(s) on the interface
    if (dwFlags & OPF_MARSHAL)
    {
	// marshal the interface into the stream
	ResetStream(pStm);
	hr = CoMarshalInterface(pStm, riid, punk, 0, NULL, MSHLFLAGS_NORMAL);
	CHKOP(hr, "CoMarshalInterface");
    }

    if (dwFlags & OPF_DISCONNECT)
    {
	hr = CoDisconnectObject(punk, 0);
	CHKOP(hr, "CoDisconnectObject");
    }

    if (dwFlags & OPF_RELEASEMARSHALDATA)
    {
	// call RMD on the stream
	ResetStream(pStm);
	hr = CoReleaseMarshalData(pStm);
	CHKOP(hr, "CoReleaseMarshalData");
    }

    if (dwFlags & OPF_UNMARSHAL)
    {
	// unmarshal the interface from the stream
	ResetStream(pStm);
	hr = CoUnmarshalInterface(pStm, riid, (void **)&punk);
	CHKOP(hr, "CoUnmarshalInterface");
    }

    if (dwFlags & OPF_RELEASE)
    {
	// release the interface pointer (if there is one).
	if (punk != NULL)
	{
	    ULONG cRefs = punk->Release();
	}
    }

    SignalEvent(pIP->hEventDone);

    DBGOUT("DoIfOperation Oper:%x hr:%x\n", dwFlags, hr);
    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:	CreateExecParam
//
//  Synopsis:	allocates an exec parameter packet for the given # of
//		INTERFACEPARAMSs.
//
//--------------------------------------------------------------------
EXECPARAMS *CreateExecParam(ULONG cIP)
{
    // allocate memory
    ULONG ulSize = sizeof(EXECPARAMS) + (cIP * sizeof(INTERFACEPARAMS));

    EXECPARAMS *pEP = (EXECPARAMS *) new BYTE[ulSize];
    if (pEP == NULL)
    {
	DBGOUT("CreateExecParams OOM\n");
	return NULL;
    }

    // zero fill the packet
    memset((BYTE*)pEP, 0, ulSize);
    pEP->cIPs = cIP;

    DBGOUT("CreateExecParam pEP:%x\n", pEP);
    return pEP;
}

//+-------------------------------------------------------------------
//
//  Function:	FillExecParam
//
//  Synopsis:	fills an exec parameter packet
//
//--------------------------------------------------------------------
void FillExecParam(EXECPARAMS *pEP, DWORD dwFlags, ULONG cReps,
		   HANDLE hEventRepStart, HANDLE hEventRepDone,
		   HANDLE hEventThreadStart, HANDLE hEventThreadDone)
{
    DBGOUT("FillExecParam pEP:%x\n", pEP);

    pEP->dwFlags	   = dwFlags;
    pEP->hEventThreadStart = hEventThreadStart;
    pEP->hEventThreadDone  = hEventThreadDone;
    pEP->hEventThreadExit  = GetEvent();

    pEP->cReps		   = cReps;
    pEP->hEventRepStart    = hEventRepStart;
    pEP->hEventRepDone	   = hEventRepDone;
}

//+-------------------------------------------------------------------
//
//  Function:	ReleaseExecParam
//
//  Synopsis:	releases an exec parameter packet
//
//--------------------------------------------------------------------
void ReleaseExecParam(EXECPARAMS *pEP)
{
    DBGOUT("ReleaseExecParam pEP:%x\n", pEP);

    if (!pEP)
	return;

    // release the events.
    ReleaseEvent(pEP->hEventThreadStart);
    ReleaseEvent(pEP->hEventThreadDone);
    ReleaseEvent(pEP->hEventThreadExit);
    ReleaseEvent(pEP->hEventRepStart);
    ReleaseEvent(pEP->hEventRepDone);

    // release the interface parameter blocks
    for (ULONG i=0; i<pEP->cIPs; i++)
    {
	ReleaseInterfaceParam(&(pEP->aIP[i]));
    }

    // free the memory
    delete pEP;
}

//+-------------------------------------------------------------------
//
//  Function:	FillInterfaceParam
//
//  Synopsis:	fills default info into the interface parms
//
//--------------------------------------------------------------------
void FillInterfaceParam(INTERFACEPARAMS *pIP, REFIID riid, IUnknown *punk,
			IStream *pStm, HANDLE hEventStart, HANDLE hEventDone)
{
    DBGOUT("FillInterfaceParam pIP:%x\n", pIP);

    pIP->iid	      = riid;
    pIP->punk	      = punk;
    pIP->pStm	      = pStm;
    pIP->hEventStart  = hEventStart;
    pIP->hEventDone   = hEventDone;
}

//+-------------------------------------------------------------------
//
//  Function:	ReleaseInterfaceParam
//
//  Synopsis:	releases an interface parameter packet
//
//--------------------------------------------------------------------
void ReleaseInterfaceParam(INTERFACEPARAMS *pIP)
{
    DBGOUT("ReleaseInterfaceParam pIP:%x\n", pIP);

    if (!pIP)
	return;

    // release the interfaces
    ReleaseInterface(pIP->punk);
    ReleaseInterface(pIP->pStm);

    // release the events
    ReleaseEvent(pIP->hEventStart);
    ReleaseEvent(pIP->hEventDone);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\smarshal\tunk.cxx ===
// #include <oleport.h>
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <tunk.h>


CTestUnk::CTestUnk(void) : _cRefs(1)
{
}

CTestUnk::~CTestUnk(void)
{
}


STDMETHODIMP CTestUnk::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hRslt = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IParseDisplayName))
    {
	*ppvObj = (void *)(IParseDisplayName *)this;
	AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hRslt = E_NOINTERFACE;
    }

    return  hRslt;
}



STDMETHODIMP_(ULONG) CTestUnk::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}


STDMETHODIMP_(ULONG) CTestUnk::Release(void)
{
    _cRefs--;
    if (_cRefs == 0)
    {
	delete this;
	return 0;
    }
    else
    {
	return _cRefs;
    }
}


STDMETHODIMP CTestUnk::ParseDisplayName(LPBC pbc, LPOLESTR lpszDisplayName,
					ULONG *pchEaten, LPMONIKER *ppmkOut)
{
    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\smarshal\testvars.cxx ===
//+-------------------------------------------------------------------
//
//  File:	testvars.cxx
//
//  Synopsis:	source code for Interface Marshaling stress test
//		variations.
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
#include <smarshal.hxx>

//+-------------------------------------------------------------------
//
//  Private Function ProtoTypes:
//
//--------------------------------------------------------------------
BOOL SingleThreadOps(ULONG cThreads, ULONG cReps, DWORD dwFlags);

BOOL ThreadPairOps(ULONG cThreadPairs,	ULONG cReps,
		   DWORD dwServerFlags, DWORD dwClientFlags);


//+-------------------------------------------------------------------
//
//  Function:	TestVar1
//
//  Synopsis:	Multiple Operations on the Same Thread.
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL TestVar1(void)
{
    MSGOUT("TestStart: TestLevel1\n");

    ULONG cThreads = gicThreads;
    ULONG cReps    = gicReps;
    DWORD dwOps    = 0;
    BOOL  fRes;


    // VAR1: test Marshal + ReleaseMarshalData

    dwOps = giThreadModel | OPF_MARSHAL | OPF_RELEASEMARSHALDATA;
    fRes = SingleThreadOps(cThreads, cReps, dwOps);
    CHKTESTRESULT(fRes, "TestVar1");


    // VAR2: test Marshal + Unmarshal + Release

    dwOps = giThreadModel | OPF_MARSHAL | OPF_UNMARSHAL | OPF_RELEASE;
    fRes = SingleThreadOps(cThreads, cReps, dwOps);
    CHKTESTRESULT(fRes, "TestVar2");


    // VAR3: test Marshal + Disconnect

    dwOps = giThreadModel | OPF_MARSHAL | OPF_DISCONNECT;
    fRes = SingleThreadOps(cThreads, cReps, dwOps);
    CHKTESTRESULT(fRes, "TestVar3");



    CHKTESTRESULT(fRes, "TestLevel1");
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Function:	SingleThreadOps
//
//  Synopsis:	Perform Operations on the Same Thread.
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL SingleThreadOps(ULONG cThreads, ULONG cReps, DWORD dwFlags)
{
    BOOL fRes = TRUE;
    MSGOUT("SingleThreadOps Start\n");

    // CODEWORK: multiple interfaces
    ULONG cIPs = 1;

    EXECPARAMS *pEP[20];	// can launch up to 20 threads at once

    for (ULONG i=0; i<cThreads; i++)
    {
	// build an execution parameter block
	pEP[i] = CreateExecParam(cIPs);

	// fill in the execution parameter block. we dont need events
	// to synchronize the repetitions since all operations are done
	// on the same thread.

	FillExecParam(pEP[i],
		  dwFlags,	    // dwFlags (operations to perform)
		  cReps,	    // cReps
		  NULL,		    // hEventRepStart
		  NULL,		    // hEventRepDone
		  GetEvent(),	    // hEventThreadStart
		  GetEvent());	    // hEventThreadDone

	// fill in the INTERFACEPARAMSs
	for (ULONG j=0; j<cIPs; j++)
	{
	    INTERFACEPARAMS *pIP = &(pEP[i]->aIP[j]);

	    FillInterfaceParam(pIP,
		   IID_IUnknown,    // iid to operate on
		   GetInterface(),  // interface pointer to operate on
		   GetStream(),     // stream to use
		   NULL,	    // per interface start event
		   NULL);	    // per interface done  event
	}
    }

    // Execute all the command blocks simultaneously
    fRes = GenericExecute(cThreads, pEP);

    GenericCleanup(cThreads, pEP);

    CHKTESTRESULT(fRes, "SingleThreadOps");
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Function:	TestVar2
//
//  Synopsis:	Operations on Thread Pairs (1 server, 1 client)
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL TestVar2(void)
{
    MSGOUT("TestStart: TestLevel2\n");

    ULONG cThreads = gicThreads;
    ULONG cReps    = gicReps;
    DWORD dwOps    = 0;
    BOOL  fRes;


    // VAR1: test Marshal on Server, Unmarshal + Release on Client.

    DWORD dwSrvOps = giThreadModel | OPF_MARSHAL;
    DWORD dwCliOps = giThreadModel | OPF_UNMARSHAL | OPF_RELEASE;
    fRes = ThreadPairOps(cThreads, cReps, dwSrvOps, dwCliOps);
    CHKTESTRESULT(fRes, "TestVar1");


    // VAR2: test Marshal on Server, RMD on Client.

#if 0
    dwSrvOps = giThreadModel | OPF_MARSHAL;
    dwCliOps = giThreadModel | OPF_RELEASEMARSHALDATA;
    fRes = ThreadPairOps(cThreads, cReps, dwSrvOps, dwCliOps);
    CHKTESTRESULT(fRes, "TestVar1");
#endif


    CHKTESTRESULT(fRes, "TestLevel2");
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Function:	ThreadPairOps
//
//  Synopsis:	Perform Operations on two synchronized threads.
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL ThreadPairOps(ULONG cThreadPairs,	ULONG cReps,
		   DWORD dwServerFlags, DWORD dwClientFlags)
{
    BOOL fRes = TRUE;
    MSGOUT("ThreadPairOps Start\n");

    // CODEWORK: multiple interfaces
    ULONG cIPs = 1;

    EXECPARAMS *pEP[20];	// can launch up to 20 threads at once

    for (ULONG i=0; i<cThreadPairs * 2; i+=2)
    {
	// build execution parameter blocks for the server and client threads.
	EXECPARAMS *pEPSrv = CreateExecParam(cIPs);
	EXECPARAMS *pEPCli = CreateExecParam(cIPs);
	pEP[i]	 = pEPSrv;
	pEP[i+1] = pEPCli;


	// fill in the server execution parameter block.
	FillExecParam(pEPSrv,
		  dwServerFlags,    // dwFlags (operations to perform)
		  cReps,	    // cReps
		  GetEvent(),	    // hEventRepStart
		  GetEvent(),	    // hEventRepDone
		  GetEvent(),	    // hEventThreadStart
		  GetEvent());	    // hEventThreadDone

	// we need to kick the hEventRepStart in order to get the ball rolling,
	// since the server thread will be waiting on it.

	SignalEvent(pEPSrv->hEventRepStart);

	// client waits for the server to complete his first repetition
	// before starting. Server waits for the client to complete his
	// first repetition before starting the next iteration.

	FillExecParam(pEPCli,
		  dwClientFlags,	    // dwFlags (operations to perform)
		  cReps,		    // cReps
		  pEPSrv->hEventRepDone,    // hEventRepStart
		  pEPSrv->hEventRepStart,   // hEventRepDone
		  GetEvent(),		    // hEventThreadStart
		  GetEvent());		    // hEventThreadDone


	// fill in the INTERFACEPARAMSs
	// CODEWORK: when multiple interfaces, will need to use events.

	for (ULONG j=0; j<cIPs; j++)
	{
	    INTERFACEPARAMS *pIPSrv = &(pEPSrv->aIP[j]);
	    INTERFACEPARAMS *pIPCli = &(pEPCli->aIP[j]);

	    FillInterfaceParam(pIPSrv,
		   IID_IUnknown,    // iid to operate on
		   GetInterface(),  // interface pointer to operate on
		   GetStream(),	    // stream to use
		   NULL,	    // per interface start event
		   NULL);	    // per interface done  event

	    // AddRef the stream pointer since both the client and server
	    // will hold pointers to it.

	    pIPSrv->pStm->AddRef();

	    FillInterfaceParam(pIPCli,
		   IID_IUnknown,    // iid to operate on
		   NULL,	    // interface pointer to operate on
		   pIPSrv->pStm,    // use same stream as the server
		   NULL,	    // per interface start event
		   NULL);	    // per interface done  event
	}
    }

    // Execute all the command blocks simultaneously
    fRes = GenericExecute(cThreadPairs * 2, pEP);

    // cleanup all the command blocks. We need to NULL out one copy of
    // those events that are shared between two command blocks.
    for (i=0; i<cThreadPairs * 2; i+=2)
    {
	EXECPARAMS *pEPCli = pEP[i+1];
	pEPCli->hEventRepStart = NULL;
	pEPCli->hEventRepDone  = NULL;

	for (ULONG j=0; j<cIPs; j++)
	{
	    INTERFACEPARAMS *pIPCli = &(pEPCli->aIP[j]);
	    pIPCli->hEventStart = NULL;
	    pIPCli->hEventDone	= NULL;
	}
    }

    GenericCleanup(cThreadPairs * 2, pEP);


    CHKTESTRESULT(fRes, "ThreadPairOps");
    return fRes;
}

//+-------------------------------------------------------------------
//
//  Function:	TestLevel3
//
//  Synopsis:	Operations on Thread Pools (1 server, n clients)
//
//  History:	21-Aug-95  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL TestLevel3(void)
{
    BOOL fRes = TRUE;
    MSGOUT("TestStart: TestLevel3\n");

    // build a command block

    // launch a thread to run the command block


    CHKTESTRESULT(fRes, "TestLevel3");
    return fRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\smarshal\tunk.h ===
#ifndef _TUNK_
#define _TUNK_

class	CTestUnk : public IParseDisplayName
{
public:
    CTestUnk(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //	IParseDisplayName
    STDMETHODIMP ParseDisplayName(LPBC pbc, LPOLESTR lpszDisplayName,
				  ULONG *pchEaten, LPMONIKER *ppmkOut);

private:

    ~CTestUnk(void);

    ULONG   _cRefs;

};

#endif	//  _TUNK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\smarshal\stream.cxx ===
//+-------------------------------------------------------------------
//
//  File:	stream.cxx
//
//  Contents:	Stream interface on flat File.
//
//  Classes:	CStreamOnFile
//
//  Macros:     DEFINE_INTERFACE_XMIT_ROUTINES
//
//  History:	08-08-95    Rickhi  Created
//
//--------------------------------------------------------------------
#include    <ole2.h>
#include    <stream.hxx>


CStreamOnFile::CStreamOnFile(const WCHAR *pwszFileName, SCODE &sc, BOOL fRead) :
    _clRefs(1),
    _hFile(NULL),
    _lOffset(0),
    _cSize(0),
    _cbData(0),
    _fRead(fRead)
{
    _pbData = new BYTE[2048];		    // should be big enough
    if (!_pbData)
    {
	sc = E_OUTOFMEMORY;
	return;
    }

    _cbData = 2048;

    // open the file.
    DWORD fdwCreate = (_fRead) ? OPEN_EXISTING : CREATE_ALWAYS;


    _hFile = CreateFile(pwszFileName,
			GENERIC_READ | GENERIC_WRITE,	    // fdwAccess
			FILE_SHARE_READ | FILE_SHARE_WRITE, // fdwShareMode
			NULL,			// lpsaSecurity
			fdwCreate,		// creation options
			FILE_ATTRIBUTE_NORMAL,	// attributes & flags
			NULL			// hTemplateFile
			);

    if (_hFile == INVALID_HANDLE_VALUE)
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    // read the file into the memory block
    DWORD cbRead = 0;
    if (_fRead && ! ReadFile(_hFile,
			    _pbData,
			    _cbData,
			    &cbRead,
			    NULL))
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    if (_fRead)
    {
	_cSize = _cbData;
    }

    sc = S_OK;
}

CStreamOnFile::~CStreamOnFile(void)
{
    if (_hFile)
    {
	if (!_fRead)
	{
	    // write the data to the file
	    DWORD cbWritten = 0;
	    if (!WriteFile(_hFile,
			   _pbData,
			   _cbData,
			   &cbWritten,
			   NULL))
	    {
		SCODE sc = HRESULT_FROM_WIN32(GetLastError());
	    }
	}

	CloseHandle(_hFile);
    }
}



STDMETHODIMP CStreamOnFile::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
	IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CStreamOnFile::AddRef(void)
{
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) CStreamOnFile::Release(void)
{
    if (InterlockedDecrement(&_clRefs) == 0)
    {
	delete this;
	return 0;
    }

    return _clRefs;
}

STDMETHODIMP CStreamOnFile::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if ((LONG)cb + _lOffset > _cSize)
    {
	cb = _cSize - _lOffset;
        hresult = STG_E_READFAULT;
    }

    memcpy(pv, _pbData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite + _lOffset > _cbData)
    {
	return E_OUTOFMEMORY;
    }

    // copy in the new data
    memcpy(_pbData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
	*pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
	_cSize = _lOffset;
    }

    return hresult;
}



STDMETHODIMP CStreamOnFile::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

    LONG  dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && (-dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

	if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
	    _lOffset = _cbData + dlibMove;
        }
	else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    memset(pstatstg, 0, sizeof(STATSTG));
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Clone(IStream FAR * FAR *ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\tmarshal\main.cxx ===
//+------------------------------------------------------------------
//
// File:	main.cxx
//
// Contents:	common entry point for test drivers.
//
//--------------------------------------------------------------------
#include    <tstmain.hxx>
#include    <tmarshal.h>

//+-------------------------------------------------------------------
//
//  Function:	main
//
//  Synopsis:	Entry point to EXE
//
//  Returns:    TRUE
//
//  History:	21-Nov-92  Rickhi	Created
//
//  Just delegates to a <main> subroutine that is common for all test
//  drivers.
//
//
//--------------------------------------------------------------------
int _cdecl main(int argc, char **argv)
{
    return DriverMain(argc, argv, "InterfaceMarshal", &TestMarshal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\tmarshal\stream.cxx ===
//+-------------------------------------------------------------------
//
//  File:	stream.cxx
//
//  Contents:	Stream interface on flat File.
//
//  Classes:	CStreamOnFile
//
//  Macros:     DEFINE_INTERFACE_XMIT_ROUTINES
//
//  History:	08-08-95    Rickhi  Created
//
//--------------------------------------------------------------------
#include    <ole2.h>
#include    <stream.hxx>


CStreamOnFile::CStreamOnFile(const WCHAR *pwszFileName, SCODE &sc, BOOL fRead) :
    _clRefs(1),
    _hFile(NULL),
    _lOffset(0),
    _cSize(0),
    _cbData(0),
    _fRead(fRead)
{
    _pbData = new BYTE[2048];		    // should be big enough
    if (!_pbData)
    {
	sc = E_OUTOFMEMORY;
	return;
    }

    _cbData = 2048;

    // open the file.
    DWORD fdwCreate = (_fRead) ? OPEN_EXISTING : CREATE_ALWAYS;


    _hFile = CreateFileW(pwszFileName,
			GENERIC_READ | GENERIC_WRITE,	    // fdwAccess
			FILE_SHARE_READ | FILE_SHARE_WRITE, // fdwShareMode
			NULL,			// lpsaSecurity
			fdwCreate,		// creation options
			FILE_ATTRIBUTE_NORMAL,	// attributes & flags
			NULL			// hTemplateFile
			);

    if (_hFile == INVALID_HANDLE_VALUE)
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    // read the file into the memory block
    DWORD cbRead = 0;
    if (_fRead && ! ReadFile(_hFile,
			    _pbData,
			    _cbData,
			    &cbRead,
			    NULL))
    {
	sc = HRESULT_FROM_WIN32(GetLastError());
	return;
    }

    if (_fRead)
    {
	_cSize = _cbData;
    }

    sc = S_OK;
}

CStreamOnFile::~CStreamOnFile(void)
{
    if (_hFile)
    {
	if (!_fRead)
	{
	    // write the data to the file
	    DWORD cbWritten = 0;
	    if (!WriteFile(_hFile,
			   _pbData,
			   _cbData,
			   &cbWritten,
			   NULL))
	    {
		SCODE sc = HRESULT_FROM_WIN32(GetLastError());
	    }
	}

	CloseHandle(_hFile);
    }
}



STDMETHODIMP CStreamOnFile::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
	IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CStreamOnFile::AddRef(void)
{
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) CStreamOnFile::Release(void)
{
    if (InterlockedDecrement(&_clRefs) == 0)
    {
	delete this;
	return 0;
    }

    return _clRefs;
}

STDMETHODIMP CStreamOnFile::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if ((LONG)cb + _lOffset > _cSize)
    {
	cb = _cSize - _lOffset;
        hresult = STG_E_READFAULT;
    }

    memcpy(pv, _pbData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite + _lOffset > _cbData)
    {
	return E_OUTOFMEMORY;
    }

    // copy in the new data
    memcpy(_pbData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
	*pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
	_cSize = _lOffset;
    }

    return hresult;
}



STDMETHODIMP CStreamOnFile::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

    LONG  dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && (-dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

	if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
	    _lOffset = _cbData + dlibMove;
        }
	else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    memset(pstatstg, 0, sizeof(STATSTG));
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Clone(IStream FAR * FAR *ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\tmarshal\tmarshal.h ===
#ifndef __TMARSH_H__
#define __TMARSH_H__

BOOL TestMarshal(void);

#endif // __TMARSH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\tmarshal\tmarshal.cxx ===
// tmarsh.cxx : various tests related to marshalling...
//
#include <windows.h>
#include <ole2.h>
#include <stdio.h>

#include "tmarshal.h"
#include "tunk.h"
#include <iballs.h>
#include <icube.h>
#include <iloop.h>
#include <stream.hxx>	    // CStreamOnFile
#include <tstmain.hxx>	    // fQuiet

//  BUGBUG: these should be in a public place somewhere.
DEFINE_OLEGUID(CLSID_Balls,	    0x0000013a, 1, 8);
DEFINE_OLEGUID(CLSID_Cubes,	    0x0000013b, 1, 8);
DEFINE_OLEGUID(CLSID_LoopSrv,	    0x0000013c, 1, 8);
DEFINE_OLEGUID(CLSID_QI,	    0x00000140, 0, 8);
DEFINE_OLEGUID(CLSID_QIHANDLER1,    0x00000141, 0, 8);

DEFINE_OLEGUID(IID_IInternalUnknown,0x00000021, 0, 0);
DEFINE_OLEGUID(IID_IStdIdentity,    0x0000001b, 0, 0);
DEFINE_OLEGUID(CLSID_OLEPSFACTORY,  0x00000320, 0, 0);

const GUID CLSID_LoopSrv =
    {0x0000013c,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

// testsrv.exe
const GUID CLSID_TestEmbed =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x47}};

const GUID CLSID_Async =
    {0x00000401,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_QI =
    {0x00000140,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_QIHANDLER1 =
    {0x00000141,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

//const GUID IID_IMultiQI =
//    {0x00000020,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID IID_IInternalUnknown =
    {0x00000021,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID IID_IStdIdentity =
    {0x0000001b,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_OLEPSFACTORY =
    {0x00000320,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

extern "C" const GUID CLSID_TestEmbed;


// external functions
STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phdl);
HRESULT VerifyOBJREFFormat(IStream *pStm, DWORD mshlflags);
DWORD _stdcall RundownClient(void *param);

// APIs exported by OLE32 but not in the header files.
STDAPI CoGetIIDFromMarshaledInterface(IStream *pStm, IID *piid);


//  function prototypes - TRUE return means the test passed
BOOL TestMarshalFormat(void);
BOOL TestGetIIDFromMI(void);
BOOL TestLocalInterfaceNormal(void);
BOOL TestUnmarshalGUIDNULL(void);
BOOL TestUnmarshalDifferentIID(void);
BOOL TestUniqueQIPointer(void);
BOOL TestLocalInterfaceTableStrong(void);
BOOL TestLocalInterfaceTableWeak(void);
BOOL TestRemoteInterfaceNormal(void);
BOOL TestRemoteInterfaceTableStrong(void);
BOOL TestNoPing(void);
BOOL TestEcho(void);
BOOL TestMiddleMan(void);
BOOL TestLoop(void);
BOOL TestLockObjectExternal(void);
BOOL TestDisconnectObject(void);
BOOL TestHandler(void);
BOOL TestReleaseMarshalData(void);
BOOL TestCustomMarshalNormal(void);
BOOL TestCustomMarshalTable(void);
BOOL TestGetStandardMarshal(void);
BOOL TestLocalInterfaceDiffMachine(void);
BOOL TestRemoteInterfaceDiffMachine(void);
BOOL TestExpiredOXIDs(void);
BOOL TestNonNDRProxy(void);
BOOL TestTIDAndLID(void);
BOOL TestMarshalSizeMax(void);
BOOL TestMarshalStorage(void);
BOOL TestMultiQINormal(void);
BOOL TestMultiQIHandler(void);
BOOL TestCrossThread(void);
BOOL TestPSClsid(void);
BOOL TestPSClsid2(void);

BOOL TestAsync(void);
BOOL TestRundown(void);
BOOL TestAggregate(void);
BOOL TestCreateRemoteHandler(void);
BOOL TestStorageInterfaceDiffMachine(void);


WCHAR	  *pwszFileName[] = {L"c:\\mshlfile.1",
			     L"c:\\mshlfile.2",
			     L"c:\\mshlfile.3"};




//  internal subroutines
void VerifyRHRefCnt(IUnknown *punk, ULONG ulExpectedRefCnt);
void VerifyObjRefCnt(IUnknown *punk, ULONG ulExpectedRefCnt);

TCHAR g_szIniFile[MAX_PATH];


// ----------------------------------------------------------------------
//
//	TestMarshal - main test driver
//
// ----------------------------------------------------------------------
BOOL GetProfileValue(TCHAR *pszKeyName, int nDefault)
{
    return (GetPrivateProfileInt(TEXT("Marshal Test"),
				 pszKeyName,
				 nDefault,
				 g_szIniFile));
}

// ----------------------------------------------------------------------
//
//	TestMarshal - main test driver
//
// ----------------------------------------------------------------------
BOOL TestMarshal(void)
{
    BOOL	RetVal = TRUE;

    // Get file name of .ini file, TMARSHAL.INI in the current directory
    GetCurrentDirectory (MAX_PATH, g_szIniFile);
    lstrcat(g_szIniFile, TEXT("\\TMARSHAL.INI"));


    if (GetProfileValue(TEXT("Format"),1))
	RetVal &= TestMarshalFormat();

    if (GetProfileValue(TEXT("GetIIDFromMI"),1))
	RetVal &= TestGetIIDFromMI();

    if (GetProfileValue(TEXT("MarshalSizeMax"),1))
	RetVal &= TestMarshalSizeMax();

    if (GetProfileValue(TEXT("GetStandardMarshal"),1))
	RetVal &= TestGetStandardMarshal();

    if (GetProfileValue(TEXT("LocalInterfaceNormal"),1))
	RetVal &= TestLocalInterfaceNormal();

    if (GetProfileValue(TEXT("UniqueQIPointer"),1))
	RetVal &= TestUniqueQIPointer();

    if (GetProfileValue(TEXT("LocalInterfaceTableStrong"),1))
	RetVal &= TestLocalInterfaceTableStrong();

    if (GetProfileValue(TEXT("LocalInterfaceTableWeak"),1))
	RetVal &= TestLocalInterfaceTableWeak();

    if (GetProfileValue(TEXT("RemoteInterfaceNormal"),1))
	RetVal &= TestRemoteInterfaceNormal();

    if (GetProfileValue(TEXT("UnmarshalGUIDNULL"),1))
	RetVal &= TestUnmarshalGUIDNULL();

    if (GetProfileValue(TEXT("UnmarshalDifferentIID"),1))
	RetVal &= TestUnmarshalDifferentIID();

    if (GetProfileValue(TEXT("RemoteInterfaceTableStrong"),1))
	RetVal &= TestRemoteInterfaceTableStrong();

    if (GetProfileValue(TEXT("CrossThread"),1))
	RetVal &= TestCrossThread();

    if (GetProfileValue(TEXT("CustomMarshalNormal"),1))
	RetVal &= TestCustomMarshalNormal();

    if (GetProfileValue(TEXT("CustomMarshalTable"),1))
	RetVal &= TestCustomMarshalTable();

    if (GetProfileValue(TEXT("Echo"),1))
	RetVal &= TestEcho();

    if (GetProfileValue(TEXT("Loop"),1))
	RetVal &= TestLoop();

    if (GetProfileValue(TEXT("LockObjectExternal"),1))
	RetVal &= TestLockObjectExternal();

    if (GetProfileValue(TEXT("DisconnectObject"),1))
	RetVal &= TestDisconnectObject();

    if (GetProfileValue(TEXT("ReleaseMarshalData"),1))
	RetVal &= TestReleaseMarshalData();

    if (GetProfileValue(TEXT("MultiQINormal"),1))
	RetVal &= TestMultiQINormal();

    if (GetProfileValue(TEXT("MultiQIHandler"),1))
	RetVal &= TestMultiQIHandler();

    if (GetProfileValue(TEXT("Handler"),1))
	RetVal &= TestHandler();

    if (GetProfileValue(TEXT("MiddleMan"),1))
	RetVal &= TestMiddleMan();

    if (GetProfileValue(TEXT("MarshalStorage"),1))
	RetVal &= TestMarshalStorage();

    if (GetProfileValue(TEXT("LocalDiffMachine"),1))
	RetVal &= TestLocalInterfaceDiffMachine();

    if (GetProfileValue(TEXT("RemoteDiffMachine"),1))
	RetVal &= TestRemoteInterfaceDiffMachine();

    if (GetProfileValue(TEXT("ExpiredOXIDs"),1))
	RetVal &= TestExpiredOXIDs();

    if (GetProfileValue(TEXT("NonNDRProxy"),1))
	RetVal &= TestNonNDRProxy();

    if (GetProfileValue(TEXT("TIDAndLID"),1))
	RetVal &= TestTIDAndLID();

    if (GetProfileValue(TEXT("NoPing"),1))
	RetVal &= TestNoPing();

    if (GetProfileValue(TEXT("PSClsid"),1))
	RetVal &= TestPSClsid();

    if (GetProfileValue(TEXT("PSClsid2"),1))
	RetVal &= TestPSClsid2();

    // -------------------------------------------------------------------

    if (GetProfileValue(TEXT("Rundown"),0))
	RetVal &= TestRundown();

    if (GetProfileValue(TEXT("Async"),0))
	RetVal &= TestAsync();

    if (GetProfileValue(TEXT("StorageDiffMachine"),0))
	RetVal &= TestStorageInterfaceDiffMachine();

    if (GetProfileValue(TEXT("Aggregate"),0))
	RetVal &= TestAggregate();

    if (GetProfileValue(TEXT("CreateRemoteHandler"),0))
	RetVal &= TestCreateRemoteHandler();

    return  RetVal;
}

// ----------------------------------------------------------------------
//
//  subroutine to verify that the RH RefCnt is as expected.
//
// ----------------------------------------------------------------------

typedef IMarshal * (* PFNDBG_FINDRH)(IUnknown *punk);
PFNDBG_FINDRH gpfnFindRH = NULL;

HMODULE ghOle32Dll = NULL;
BOOL gfTriedToLoad = FALSE;


void LoadProc()
{
    if (!gfTriedToLoad)
    {
	gfTriedToLoad = TRUE;

	ghOle32Dll = LoadLibrary(TEXT("OLE32.DLL"));
	if (ghOle32Dll)
	{
	    gpfnFindRH = (PFNDBG_FINDRH) GetProcAddress(ghOle32Dll,
							"Dbg_FindRemoteHdlr");
	}
    }
}

void FreeProc()
{
    if (ghOle32Dll)
    {
	FreeLibrary(ghOle32Dll);
    }
}

// ----------------------------------------------------------------------
//
//  subroutine to verify that the RH RefCnt is as expected.
//
// ----------------------------------------------------------------------

void VerifyRHRefCnt(IUnknown *punk, ULONG ulExpectedRefCnt)
{
    if (gpfnFindRH == NULL)
    {
	LoadProc();
    }

    if (gpfnFindRH)
    {
	// this function is internal to COMPOBJ marshalling.
	IMarshal *pIM = (gpfnFindRH)(punk);
	if (pIM == NULL)
	{
	    if (ulExpectedRefCnt != 0)
		printf ("ERROR: RH RefCnt 0, expected=%x\n", ulExpectedRefCnt);
	    return;
	}

	ULONG ulRefCnt = pIM->Release();
	if (ulRefCnt != ulExpectedRefCnt)
	{
	    printf ("ERROR: RH RefCnt=%x, expected=%x\n", ulRefCnt, ulExpectedRefCnt);
	}
    }
}

// ----------------------------------------------------------------------
//
//  subroutine to verify that the Object RefCnt is as expected.
//
// ----------------------------------------------------------------------

void VerifyObjRefCnt(IUnknown *punk, ULONG ulExpectedRefCnt)
{
    if (ulExpectedRefCnt == 0)
	return; 		//  cant verify this

//#if DBG==1
    //	this function is internal to COMPOBJ marshalling.
    punk->AddRef();
    ULONG ulRefCnt = punk->Release();
    if (ulRefCnt != ulExpectedRefCnt)
    {
	printf ("ERROR: Object RefCnt=%x, expected=%x\n", ulRefCnt, ulExpectedRefCnt);
    }
//#endif
}


// ----------------------------------------------------------------------
//
//  MarshalAndRead
//
// ----------------------------------------------------------------------
HRESULT MarshalAndRead(IUnknown *punkIn, BYTE *pbuf, ULONG *pulSize)
{
    BOOL    RetVal = TRUE;
    HRESULT hres;

    ULARGE_INTEGER ulSeekEnd;
    LARGE_INTEGER lSeekStart;
    LISet32(lSeekStart, 0);

    IStream *pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK\n");

    // get current seek position
    hres = pStm->Seek(lSeekStart, STREAM_SEEK_CUR, &ulSeekEnd);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")
    OUTPUT ("   - Seek Current OK\n");

    // go back to begining
    hres = pStm->Seek(lSeekStart, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")
    OUTPUT ("   - Seek Start OK\n");

    // read in the data
    hres = pStm->Read(pbuf ,ulSeekEnd.LowPart, pulSize);
    TEST_FAILED_EXIT(FAILED(hres), "Read on stream failed\n")
    OUTPUT ("   - Read OK\n");

Cleanup:

    // release the stream
    pStm->Release();

    if (RetVal == TRUE)
	return S_OK;
    else
	return hres;
}

// ----------------------------------------------------------------------
//
//	GetTestUnk - return an inproc IUnknown ptr.
//
// ----------------------------------------------------------------------
IUnknown *GetTestUnk()
{
    IUnknown *punkIn = (IUnknown *)(IParseDisplayName *) new CTestUnk();
    return punkIn;
}


// ----------------------------------------------------------------------
//
//  RunThread - runs a thread and waits for it to complete
//
// ----------------------------------------------------------------------
void RunThread(void *param, HANDLE hEvent, LPTHREAD_START_ROUTINE pfn)
{
    DWORD dwThrdId;
    HANDLE hThrd = CreateThread(NULL, 0, pfn, param, 0, &dwThrdId);

    if (hThrd)
    {
	if (gInitFlag == COINIT_APARTMENTTHREADED)
	{
	    // enter a message pump to accept incoming calls from the
	    // other thread.

	    MSG msg;
	    while (GetMessage(&msg, NULL, 0, 0))
	    {
		DispatchMessage(&msg);
	    }
	}
	else
	{
	    // wait for the other thread to run to completion
	    WaitForSingleObject(hEvent, 0xffffffff);
	}

	// close the thread handle
	CloseHandle(hThrd);
    }
}


// ----------------------------------------------------------------------
//
//	TestAsync
//
// ----------------------------------------------------------------------
BOOL TestAsync(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    ULONG	    ulRefCnt = 0;
    IUnknown	    *pUnkSrv = NULL;
    IAdviseSink	    *pAdvSnk = NULL;

    OUTPUT ("Starting TestAsync\n");

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_Async, NULL, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnkSrv);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance First failed\n")

    OUTPUT ("   - QI for IAdviseSink\n");
    hRes = pUnkSrv->QueryInterface(IID_IAdviseSink, (void **)&pAdvSnk);
    TEST_FAILED_EXIT(FAILED(hRes), "QI for IAdviseSink failed\n")

    // now call on the IAdviseSink Interface
    pAdvSnk->OnSave();

    Sleep(30);

    // release the interface
    pAdvSnk->Release();
    pAdvSnk = NULL;

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pAdvSnk)
    {
	ulRefCnt = pAdvSnk->Release();
	TEST_FAILED(ulRefCnt != 1, "pAdvSnk RefCnt not zero\n");
    }

    if (pUnkSrv)
    {
	ulRefCnt = pUnkSrv->Release();
	TEST_FAILED(ulRefCnt != 0, "PunkSrv RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestAsync");
}


// ----------------------------------------------------------------------
//
//	test marshal format
//
// ----------------------------------------------------------------------
BOOL TestMarshalFormat(void)
{
    BOOL	  RetVal = TRUE;
    BOOL	  fSame  = TRUE;
    HRESULT	  hres;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    BYTE	  buf1[600];
    BYTE	  buf2[600];
    ULONG	  ulSize1 = sizeof(buf1);
    ULONG	  ulSize2 = sizeof(buf2);

    OUTPUT ("Starting TestMarshalFormat\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

// ----------------------------------------------------------------------

    hres = MarshalAndRead(punkIn, buf1, &ulSize1);
    TEST_FAILED_EXIT(FAILED(hres), "MarshalAndRead failed\n")
    OUTPUT ("   - First MarshalAndRead OK\n");

    hres = MarshalAndRead(punkIn, buf2, &ulSize2);
    TEST_FAILED_EXIT(FAILED(hres), "MarshalAndRead failed\n")
    OUTPUT ("   - Second MarshalAndRead OK\n");

    TEST_FAILED_EXIT((ulSize1 != ulSize2), "Buffer Sizes Differ\n")
    fSame = !memcmp(buf1, buf2, ulSize1);

    TEST_FAILED_EXIT(!fSame, "Buffer Contents Differ\n")
    OUTPUT ("   - Buffers Compare OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    CoDisconnectObject(punkIn,0);

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestMarshalFormat");
}


// ----------------------------------------------------------------------
//
//	test CoGetMarshalSizeMax
//
// ----------------------------------------------------------------------
BOOL TestMarshalSizeMax(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    ULONG	  ulSize = 0;

    OUTPUT ("Starting TestMarshalSizeMax\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

// ----------------------------------------------------------------------

    hres = CoGetMarshalSizeMax(&ulSize, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoGetMarshalSizeMax failed\n")
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - CoGetMarshalSizeMax OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");
    if (punkIn)
    {
	punkIn->Release();
	punkIn = NULL;
    }

    return TestResult(RetVal, "TestMarshalSizeMax");
}


// ----------------------------------------------------------------------
//
//	test LOCAL interface MSHLFLAGS_NORMAL
//
// ----------------------------------------------------------------------

BOOL TestLocalInterfaceNormal(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    LPSTREAM	  pStm = NULL;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    IUnknown	  *punkOut = NULL;
    IUnknown	  *punkOut2 = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestLocalInterfaceNormal\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

// ----------------------------------------------------------------------
    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	since we are unmarshalling in the same process, the RH should go away.
    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 2);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero");
    punkOut = NULL;
    OUTPUT ("   - Release OK\n");

    //	the RH should have gone away, and we should have only the original
    //	refcnt from creation left on the object.
    VerifyObjRefCnt(punkIn, 1);

// ----------------------------------------------------------------------
#if 0
    // this test disabled for DCOM since we no longer write into the stream
    // to mark the thing as having been unmarshaled. This lets unmarshals
    // work with read-only streams.


    //	test unmarshalling twice. this should fail since we did marshal
    //	flags normal and already unmarshalled it once.

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut2);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoUnmarshalInterface second time succeeded but should have failed\n")
    OUTPUT ("   - Second CoUnmarshalInterface OK\n");

// ----------------------------------------------------------------------

    //	CoReleaseMarshalData should fail because Unmarshall already called it.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoReleaseMarshalData succeeded but should have failed.\n")
    OUTPUT  ("	- CoReleaseMarshalData OK\n");

#endif
// ----------------------------------------------------------------------

    //	marshal again and try CoRelease without having first done an
    //	unmarshal. this should work.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK\n");
    VerifyRHRefCnt(punkIn, 1);

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT  ("   - CoReleaseMarshalData OK\n");

// ----------------------------------------------------------------------

    // release the object and try to unmarshal it again. Should fail
    // since the object has gone away.

    ulRefCnt = punkIn->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    punkIn = NULL;

    // go back to start of stream
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoUnmarshalInterface should have failed\n")

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkOut2)
    {
	ulRefCnt = punkOut2->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut2 RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestLocalInterfaceNormal");
}


// ----------------------------------------------------------------------
//
//	test LOCAL interface MSHLFLAGS_NORMAL when the object returns a
//	differnt interface pointer on each subsequent QI for the same
//	interface
//
// ----------------------------------------------------------------------
BOOL TestUniqueQIPointer(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    LPSTREAM	  pStm = NULL;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    IUnknown	  *punkOut = NULL;
    ICube	  *pCubeIn  = NULL;
    ICube	  *pCubeOut = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestUniqueQIPointer\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    hres = punkIn->QueryInterface(IID_ICube, (void **)&pCubeIn);
    TEST_FAILED_EXIT((pCubeIn == NULL), "QI for IID_ICube failed\n")
    VerifyObjRefCnt(punkIn, 2);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

// ----------------------------------------------------------------------
    hres = CoMarshalInterface(pStm, IID_ICube, pCubeIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(pCubeIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    // since we are unmarshalling in the same process, the RH should go away.
    hres = CoUnmarshalInterface(pStm, IID_ICube, (LPVOID FAR*)&pCubeOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(pCubeIn, 0);
    VerifyRHRefCnt(pCubeOut, 0);
    VerifyRHRefCnt(punkIn, 0);

    VerifyObjRefCnt(pCubeIn, 1);
    VerifyObjRefCnt(pCubeOut, 1);
    VerifyObjRefCnt(punkIn, 3);

    // make sure the Ctrl Unknown interface pointers are identical
    hres = pCubeOut->QueryInterface(IID_IUnknown, (void **)&punkOut);
    TEST_FAILED_EXIT((punkOut == NULL), "QI for IID_IUnknown failed\n")
    VerifyObjRefCnt(punkOut, 4);

    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK\n");

    // attempt a call on the in interface pointer.
    hres = pCubeIn->MoveCube(0,0);
    TEST_FAILED_EXIT(FAILED(hres), "pCubeIn->MoveCube failed\n")

    // release the in-pointer
    ulRefCnt = pCubeIn->Release();
    TEST_FAILED(ulRefCnt != 0, "pCubeIn RefCnt not zero\n");
    pCubeIn = NULL;

    // now call on the out interface pointer
    hres = pCubeOut->MoveCube(0,0);
    TEST_FAILED_EXIT(FAILED(hres), "pCubeOut->MoveCube failed\n")

    // release the out-pointer
    ulRefCnt = pCubeOut->Release();
    TEST_FAILED(ulRefCnt != 0, "pCubeOut RefCnt not zero\n");
    pCubeOut = NULL;


Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (pCubeIn)
    {
	ulRefCnt = pCubeIn->Release();
	TEST_FAILED(ulRefCnt != 0, "pCubeIn RefCnt not zero\n");
    }

    if (pCubeOut)
    {
	ulRefCnt = pCubeOut->Release();
	TEST_FAILED(ulRefCnt != 0, "pCubeOut RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt == 0, "punkOut RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestUniqueQIPointer");
}



// ----------------------------------------------------------------------
//
//  test LOCAL interface MSHLFLAGS_TABLESTRONG
//
// ----------------------------------------------------------------------

BOOL TestLocalInterfaceTableStrong(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    LPSTREAM	  pStm = NULL;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    IUnknown	  *punkOut = NULL;
    IUnknown	  *punkOut2 = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestLocalInterfaceTableStrong\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

// ----------------------------------------------------------------------

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_TABLESTRONG);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	unmarshalling should leave the RH intact, as it is marshalled for TABLE.
    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero");
    punkOut = NULL;
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	test unmarshalling twice - should work since we used flags table
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut2);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface second time succeeded but should have failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Second CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut2->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut2 RefCnt is zero");
    punkOut2 = NULL;
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	CoReleaseMarshalData should release the marshalled data TABLESTRONG
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT  ("   - CoReleaseMarshalData OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkOut2)
    {
	ulRefCnt = punkOut2->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut2 RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestLocalInterfaceTableStrong");
}


// ----------------------------------------------------------------------
//
//  test LOCAL interface MSHLFLAGS_TABLEWEAK
//
// ----------------------------------------------------------------------

BOOL TestLocalInterfaceTableWeak(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    LPSTREAM	  pStm = NULL;
    ULONG	  ulRefCnt = 0;
    IUnknown	  *punkIn = NULL;
    IUnknown	  *punkOut = NULL;
    IUnknown	  *punkOut2 = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestLocalInterfaceTableWeak\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

// ----------------------------------------------------------------------

    hres = CoMarshalInterface(pStm, IID_IParseDisplayName, punkIn, 0, NULL, MSHLFLAGS_TABLEWEAK);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	unmarshalling should leave the RH intact, as it is marshalled for TABLE.
    hres = CoUnmarshalInterface(pStm, IID_IParseDisplayName, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero");
    punkOut = NULL;
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	test unmarshalling twice - should work since we used flags table
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IParseDisplayName, (LPVOID FAR*)&punkOut2);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface second time succeeded but should have failed\n")
    VerifyRHRefCnt(punkIn, 1);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut2)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...2nd Local Unmarshal\n")
    OUTPUT ("   - Second CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut2->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut2 RefCnt is zero");
    punkOut2 = NULL;
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	CoReleaseMarshalData should release the marshalled data TABLEWEAK
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT  ("   - CoReleaseMarshalData OK\n");


    ulRefCnt = punkIn->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkIn RefCnt is not zero");
    punkIn = NULL;

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkOut2)
    {
	ulRefCnt = punkOut2->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut2 RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestLocalInterfaceTableWeak");
}

// ----------------------------------------------------------------------
//
//	test calling CoUmarshalInterface with GUID_NULL
//
// ----------------------------------------------------------------------

// ----------------------------------------------------------------------
//
//  Structure passed between apartments.
//
// ----------------------------------------------------------------------
typedef struct tagThreadUnmarshalInfo
{
    HANDLE   hEvent;
    IStream  *pStm;
    IUnknown *pUnk;
    IID      iid;
    DWORD    dwInitFlag;
    DWORD    dwThreadId;
    ULONG    RelRefCnt;
    HRESULT  hr;
} ThreadUnmarshalInfo;


DWORD _stdcall ThreadTestUnmarshal(void *params)
{
    ThreadUnmarshalInfo *pInfo = (ThreadUnmarshalInfo *)params;
    BOOL      RetVal  = TRUE;
    ULONG     ulRefCnt= 0;
    IUnknown *punkOut = NULL;
    HRESULT   hres;

    hres = CoInitializeEx(NULL, pInfo->dwInitFlag);

    hres = CoUnmarshalInterface(pInfo->pStm, pInfo->iid, (LPVOID FAR*)&punkOut);
    TEST_FAILED(FAILED(hres), "CoUnmarshalInterface failed\n")

    if (SUCCEEDED(hres))
    {
	// make sure the interface pointers are identical
	if (pInfo->pUnk != NULL && pInfo->pUnk != punkOut)
	{
	    TEST_FAILED(TRUE, "Interface ptrs are wrong\n")
	}
	else
	{
	    OUTPUT ("   - CoUnmarshalInterface OK.\n");
	}

	// release the interface
	ulRefCnt = punkOut->Release();
	punkOut  = NULL;
	TEST_FAILED(ulRefCnt != pInfo->RelRefCnt, "Released punkOut RefCnt is wrong\n");

	OUTPUT ("   - Release OK\n");
    }

    pInfo->hr = hres;

    CoUninitialize();

    // signal the other thread we are done.
	// but only if we were called from a different thread

	if (pInfo->dwThreadId != 0)
	{
		if (gInitFlag == COINIT_APARTMENTTHREADED)
		{
 			PostThreadMessage(pInfo->dwThreadId, WM_QUIT, 0, 0);
		}
		else
		{
			SetEvent(pInfo->hEvent);
		}
	}

    return 0;
}


BOOL TestUnmarshalGUIDNULL(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    IUnknown	    *punkIn  = NULL;
    ULONG	    ulRefCnt, i;
    HANDLE	    hEvent = NULL;
    ThreadUnmarshalInfo Info;


    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestUnmarshalGUIDNULL\n");

    //	Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

// ----------------------------------------------------------------------

    for (i=0; i<2; i++)
    {
	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	TEST_FAILED_EXIT(hEvent == NULL, "CreateEvent failed\n")

	punkIn = GetTestUnk();
	TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
	VerifyObjRefCnt(punkIn, 1);

	// reset the stream ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_IParseDisplayName, punkIn,
				  0, 0, MSHLFLAGS_NORMAL);
	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	VerifyRHRefCnt(punkIn, 1);
	OUTPUT ("   - CoMarshalInterface OK.\n");

	// reset the stream ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	Info.hEvent = hEvent;
	Info.pStm = pStm;
	Info.iid  = GUID_NULL;
	Info.dwInitFlag = gInitFlag;
	Info.dwThreadId = 0;

	if (i==0)
	{
	    // first time, call on same thread, expect original ptr and
	    // non-zero refcnt after release
	    Info.pUnk	   = punkIn;
	    Info.RelRefCnt = 1;

	    ThreadTestUnmarshal(&Info);
	}
	else
	{
	    // second time, call on different thread
	    if (gInitFlag == COINIT_APARTMENTTHREADED)
	    {
		// apartment thread, expect differnt ptr and
		// zero refcnt after release

		Info.dwThreadId = GetCurrentThreadId();
		Info.pUnk	= 0;
		Info.RelRefCnt	= 0;
	    }
	    else
	    {
		// multi-thread, expect same ptr and non-zero refcnt
		// after release

		Info.dwThreadId = GetCurrentThreadId();
		Info.pUnk	= punkIn;
		Info.RelRefCnt	= 1;
	    }

	    RunThread(&Info, hEvent, ThreadTestUnmarshal);
	    CloseHandle(hEvent);
	}

	// release the punkIn.
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
	punkIn = NULL;

	hres = Info.hr;
	OUTPUT ("    - Run Complete\n");
    }

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestUnmarshalGUIDNULL");
}

// ----------------------------------------------------------------------
//
//	test calling CoUmarshalInterface with an IID different from
//	the IID that was marshaled.
//
// ----------------------------------------------------------------------

BOOL TestUnmarshalDifferentIID(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    IUnknown	    *punkIn  = NULL;
    ULONG	    ulRefCnt, i;
    HANDLE	    hEvent = NULL;
    ThreadUnmarshalInfo Info;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestUnmarshalDifferentIID\n");

    //	Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

// ----------------------------------------------------------------------

    for (i=0; i<2; i++)
    {
	hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	TEST_FAILED_EXIT(hEvent == NULL, "CreateEvent failed\n")

	punkIn = GetTestUnk();
	TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
	VerifyObjRefCnt(punkIn, 1);

	// reset the stream ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_IParseDisplayName, punkIn,
				  0, 0, MSHLFLAGS_NORMAL);
	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	VerifyRHRefCnt(punkIn, 1);
	OUTPUT ("   - CoMarshalInterface OK.\n");

	// reset the stream ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	Info.hEvent = hEvent;
	Info.pStm   = pStm;
	Info.iid    = IID_IOleWindow;
	Info.pUnk   = punkIn;
	Info.dwInitFlag = gInitFlag;
	Info.dwThreadId = 0;

	if (i==0)
	{
	    // first time, call on same thread, expect different ptr and
	    // non-zero refcnt after release
	    Info.pUnk	   = 0;
	    Info.RelRefCnt = 1;

	    ThreadTestUnmarshal(&Info);
	}
	else
	{
	    if (gInitFlag == COINIT_APARTMENTTHREADED)
	    {
		// apartment thread, expect differnt ptr and
		// zero refcnt after release

		Info.dwThreadId = GetCurrentThreadId();
		Info.pUnk	= 0;
		Info.RelRefCnt	= 0;
	    }
	    else
	    {
		// multi-thread, expect same ptr and non-zero refcnt
		// after release

		Info.dwThreadId = GetCurrentThreadId();
		Info.pUnk	= 0;
		Info.RelRefCnt	= 1;
	    }

	    RunThread(&Info, hEvent, ThreadTestUnmarshal);
	    CloseHandle(hEvent);
	}

	// release the punkIn.
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
	punkIn = NULL;

	hres = Info.hr;
	OUTPUT ("    - Run Complete\n");
    }

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestUnmarshalDifferentIID");
}


// ----------------------------------------------------------------------
//
//	test REMOTE interface MSHLFLAGS_NORMAL
//
// ----------------------------------------------------------------------

BOOL TestRemoteInterfaceNormal(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    LPCLASSFACTORY  pICF = NULL;
    ULONG	    ulRefCnt;
    IUnknown	    *punkOut = NULL;
    IUnknown	    *punkIn  = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestRemoteInterfaceNormal\n");

    //	Create an IClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject failed\n")
    VerifyRHRefCnt((IUnknown *)pICF, 1);
    OUTPUT ("   - Aquired Remote Class Object.\n");

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_IUnknown, (void **)&punkIn);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((punkIn == NULL), "CreateInstance failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Created Instance.\n");

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
//    VerifyRHRefCnt((IUnknown *)pICF, 0);
    pICF = NULL;
    OUTPUT ("   - Released Class Object.\n");

// ----------------------------------------------------------------------

    //	Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

    //	Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punkIn, 1);

    //	unmarshal the interface. should get the same proxy back.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 2);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..1st Remote Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK.\n");


    //	release the interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

#if 0
    //	test unmarshalling twice. this should fail since we marshalled normal
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoUnmarshalInterface succeeded but should have failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Second CoUnmarshalInterface OK.\n");
    punkOut = NULL;

// ----------------------------------------------------------------------

    //	CoReleaseMarshalData should FAIL since we already unmarshalled it
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoReleaseMarshalData succeeded but should have failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT  ("   - CoReleaseMarshalData OK\n");

#endif
// ----------------------------------------------------------------------

    //	marshal again and try CoRelease without having first done an
    //	unmarshal. this should work.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT  ("   - CoReleaseMarshalData OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT  ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (pICF)
    {
	ulRefCnt = pICF->Release();
	TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestRemoteInterfaceNormal");
}


// ----------------------------------------------------------------------
//
//	test REMOTE interface MSHLFLAGS_TABLESTRONG
//
// ----------------------------------------------------------------------

BOOL TestRemoteInterfaceTableStrong(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    LPCLASSFACTORY  pICF = NULL;
    ULONG	    ulRefCnt;
    IUnknown	    *punkIn = NULL;
    IUnknown	    *punkOut = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestRemoteInterfaceTableStrong\n");

    //	Create an IClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject failed\n")
    OUTPUT ("   - Aquired Remote Class Object.\n");

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_IUnknown, (void **)&punkIn);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((punkIn == NULL), "CreateInstance failed\n")
    OUTPUT ("   - Created Instance.\n");

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    pICF = NULL;
    OUTPUT ("   - Released Class Object.\n");

// ----------------------------------------------------------------------

    // Create a shared memory stream for the marshaled moniker
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

    // Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_TABLESTRONG);
    TEST_FAILED_EXIT(SUCCEEDED(hres), "CoMarshalInterface succeeded but should have failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

#if 0
    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..1st Remote Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK.\n");

    //	release it
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    punkOut = NULL;
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	test unmarshalling twice.
    //	this should work since we did marshal flags TABLE_STRONG
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    OUTPUT ("   - Second CoUnmarshalInterface OK.\n");

// ----------------------------------------------------------------------

    //	CoReleaseMarshalData should WORK for TABLESTRONG interfaces
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    OUTPUT  ("	- CoReleaseMarshalData OK\n");

// ----------------------------------------------------------------------
#endif
Cleanup:

    OUTPUT  ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    }

    if (punkIn)
    {
	//  release instance
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0,"punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestRemoteInterfaceTableStrong");
}

// ----------------------------------------------------------------------
//
//	test CUSTOM interface MSHLFLAGS_NORMAL --- CODEWORK
//
// ----------------------------------------------------------------------

BOOL TestCustomMarshalNormal(void)
{
    BOOL	RetVal = TRUE;

    return TestResult(RetVal, "TestCustomMarshalNormal");
}


// ----------------------------------------------------------------------
//
//	test CUSTOM interface MSHLFLAGS_TABLESTRONG --- CODEWORK
//
// ----------------------------------------------------------------------

BOOL TestCustomMarshalTable(void)
{
    BOOL	RetVal = TRUE;

    return TestResult(RetVal, "TestCustomMarshalTableStrong");
}


// ----------------------------------------------------------------------
//
//	TestEcho
//
//	test sending an interface to a remote server and getting the same
//	interface back again. the test is done with once with a local
//	interface and once with a remote interface.
//
//		Local Interface 		Remote Interface
//
//	1.  marshal [in] local		    marshal [in] remote proxy
//	2.  unmarshal [in] remote	    unmarshal [in] local proxy
//	3.  marshal [out] remote proxy	    marshal [out] local
//	4.  unmarshal [in] local proxy	    unmarshal [out] remote
//
// ----------------------------------------------------------------------

BOOL TestEcho(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    LPCLASSFACTORY  pICF = NULL;
    IBalls	    *pIBalls = NULL;
    IUnknown	    *punkIn = NULL;
    IUnknown	    *punkIn2 = NULL;
    IUnknown	    *punkOut = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestEcho\n");

    //	Create an IBall ClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject failed\n")
    OUTPUT ("   - Aquired Remote Class Object.\n");

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_IBalls, (void **)&pIBalls);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((pIBalls == NULL), "CreateInstance failed\n")
    OUTPUT ("   - Created First Instance.\n");

    hres = pICF->CreateInstance(NULL, IID_IUnknown, (void **)&punkIn2);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((punkIn2 == NULL), "CreateInstance failed\n")
    OUTPUT ("   - Created Second Instance.\n");

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    pICF = NULL;
    OUTPUT ("   - Released Class Object.\n");

// ----------------------------------------------------------------------

    //	create a local interface
    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    //	call a method that echos the local interface right back to us.
    hres = pIBalls->Echo(punkIn, &punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "Echo on IBalls failed\n")
    TEST_FAILED_EXIT((punkOut == NULL), "Echo on IBalls failed\n")

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..Echo\n")

    VerifyObjRefCnt(punkIn, 2);
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - Echo OK.\n");

    //	release the out interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED_EXIT(ulRefCnt != 1, "punkOut RefCnt is not 1\n");
    OUTPUT ("   - Released punkOut OK\n");

    //	release the In interface
    ulRefCnt = punkIn->Release();
    punkIn = NULL;
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkIn RefCnt is not zero\n");
    OUTPUT ("   - Released punkIn OK\n");

    OUTPUT ("   - Echo Local Interface OK\n");

// ----------------------------------------------------------------------

    //	call a method that echos a remote interface right back to us.
    hres = pIBalls->Echo(punkIn2, &punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "Echo on IBalls failed\n")
    TEST_FAILED_EXIT((punkOut == NULL), "Echon on IBalls failed\n")

    //	make sure the interface pointers are identical
    if (punkIn2 != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..Echo\n")

    VerifyObjRefCnt(punkIn2, 2);
    VerifyRHRefCnt(punkIn2, 2);
    OUTPUT ("   - Echo OK.\n");

    //	release the out interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED_EXIT(ulRefCnt != 1, "punkOut RefCnt is not 1\n");
    OUTPUT ("   - Released punkOut OK\n");

    //	release the In interface
    ulRefCnt = punkIn2->Release();
    punkIn2 = NULL;
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkIn2 RefCnt is not zero\n");
    OUTPUT ("   - Released punkIn2 OK\n");

    OUTPUT ("   - Echo Remote Interface OK\n");

// ----------------------------------------------------------------------

    //	release the IBalls interface
    ulRefCnt = pIBalls->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "pIBalls RefCnt is not zero\n");
    pIBalls = NULL;
    OUTPUT  ("   - Released IBalls OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT  ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (pICF)
    {
	ulRefCnt = pICF->Release();
	TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    if (pIBalls)
    {
	ulRefCnt = pIBalls->Release();
	TEST_FAILED(ulRefCnt != 0, "pIBalls RefCnt not zero\n");
    }

    if (punkIn2)
    {
	ulRefCnt = punkIn2->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn2 RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestEcho");
}



// ----------------------------------------------------------------------
//
//	TestMiddleMan
//
//	test sending an remote interface to a second different process.
//
//	1.  marshal [in] remote proxy
//	2.  unmarshal [in] remote proxy
//	3.  marshal [out] remote proxy
//	4.  unmarshal [in] local proxy
//
// ----------------------------------------------------------------------

BOOL TestMiddleMan(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    LPCLASSFACTORY  pICF = NULL;
    IBalls	    *pIBalls = NULL;
    ICube	    *pICubes = NULL;
    IUnknown	    *punkIn = NULL;
    IUnknown	    *punkOut = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestMiddleMan\n");

    //	Create an IBall ClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject Balls failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject Balls failed\n")
    OUTPUT ("   - Aquired Remote Balls Class Object.\n");
    VerifyObjRefCnt(pICF, 1);
    VerifyRHRefCnt(pICF, 1);

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_IBalls, (void **)&pIBalls);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((pIBalls == NULL), "CreateInstance failed\n")
    OUTPUT ("   - Created Balls Instance.\n");

    VerifyObjRefCnt(pIBalls, 1);
    VerifyRHRefCnt(pIBalls, 1);

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    pICF = NULL;
    OUTPUT ("   - Released Balls Class Object.\n");

// ----------------------------------------------------------------------

    //	Create an ICube ClassFactory Interface.
    grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Cubes,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject Cubes failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject Cubes failed\n")
    OUTPUT ("   - Aquired Remote Cubes Class Object.\n");
    VerifyObjRefCnt(pICF, 1);
    VerifyRHRefCnt(pICF, 1);

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_ICube, (void **)&pICubes);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance Cubes failed\n")
    TEST_FAILED_EXIT((pICubes == NULL), "CreateInstance Cubes failed\n")
    OUTPUT ("   - Created Cubes Instance.\n");

    VerifyObjRefCnt(pICubes, 1);
    VerifyRHRefCnt(pICubes, 1);

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    pICF = NULL;
    OUTPUT ("   - Released Cubes Class Object.\n");

// ----------------------------------------------------------------------

    //	pass the remote cubes interface to the balls interface.
    hres = pIBalls->IsContainedIn(pICubes);
    TEST_FAILED_EXIT(FAILED(hres), "IsContainedIn failed\n")
    VerifyObjRefCnt(pIBalls, 1);
    VerifyRHRefCnt(pIBalls, 1);
    VerifyObjRefCnt(pICubes, 1);
    VerifyRHRefCnt(pICubes, 1);
    OUTPUT ("   - IsContainedIn OK.\n");

// ----------------------------------------------------------------------

    //	pass the remote balls interface to the cubes interface.
    hres = pICubes->Contains(pIBalls);
    TEST_FAILED_EXIT(FAILED(hres), "Contains failed\n")
    VerifyObjRefCnt(pIBalls, 1);
    VerifyRHRefCnt(pIBalls, 1);
    VerifyObjRefCnt(pICubes, 1);
    VerifyRHRefCnt(pICubes, 1);
    OUTPUT ("   - Contains OK.\n");

// ----------------------------------------------------------------------

    //	echo the remote ICubes interface to the remote IBalls interface
    hres = pICubes->QueryInterface(IID_IUnknown, (void **)&punkIn);
    TEST_FAILED_EXIT(FAILED(hres), "QueryInterface IUnknown failed\n")
    VerifyRHRefCnt(pICubes, 2);
    VerifyObjRefCnt(pICubes, 2);
    OUTPUT ("   - QueryInterface OK.\n");

    hres = pIBalls->Echo(punkIn, &punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "Echo on IBalls failed\n")
    TEST_FAILED_EXIT((punkOut == NULL), "Echo on IBalls failed\n")

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..Echo\n")

    VerifyObjRefCnt(punkIn, 3);
    VerifyRHRefCnt(punkIn, 3);
    OUTPUT ("   - Echo OK.\n");

    //	release the out interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED(ulRefCnt != 2, "punkOut RefCnt is not 2\n");
    OUTPUT ("   - Released punkOut OK\n");

    //	release the In interface
    ulRefCnt = punkIn->Release();
    punkIn = NULL;
    TEST_FAILED(ulRefCnt != 1, "punkIn RefCnt is not 1\n");
    OUTPUT ("   - Released punkIn OK\n");

// ----------------------------------------------------------------------

    //	release the ICubes interface
    ulRefCnt = pICubes->Release();
    TEST_FAILED(ulRefCnt != 0, "pICubes RefCnt is not zero\n");
    pICubes = NULL;
    OUTPUT  ("   - Released ICubes OK\n");

// ----------------------------------------------------------------------

    //	release the IBalls interface
    ulRefCnt = pIBalls->Release();
    TEST_FAILED(ulRefCnt != 0, "pIBalls RefCnt is not zero\n");
    pIBalls = NULL;
    OUTPUT  ("   - Released IBalls OK\n");

// ----------------------------------------------------------------------


Cleanup:

    OUTPUT  ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (pICF)
    {
	ulRefCnt = pICF->Release();
	TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    }

    if (pIBalls)
    {
	ulRefCnt = pIBalls->Release();
	TEST_FAILED(ulRefCnt != 0, "pIBalls RefCnt not zero\n");
    }

    if (pICubes)
    {
	ulRefCnt = pICubes->Release();
	TEST_FAILED(ulRefCnt != 0, "pICubes RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestMiddleMan");
}


// ----------------------------------------------------------------------
//
//	TestLoop
//
//	tests A calling B calling A calling B etc n times, to see if Rpc
//	can handle this.
//
// ----------------------------------------------------------------------

BOOL TestLoop(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    ILoop	    *pLocalLoop = NULL;
    ILoop	    *pRemoteLoop = NULL;

    OUTPUT ("Starting TestLoop\n");

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_LoopSrv, NULL, CLSCTX_LOCAL_SERVER,
			    IID_ILoop, (void **)&pLocalLoop);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance First failed\n")

    //	create the remote object
    hRes = CoCreateInstance(CLSID_LoopSrv, NULL, CLSCTX_LOCAL_SERVER,
			    IID_ILoop, (void **)&pRemoteLoop);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance Second failed\n")

    //	initialize the two instances
    OUTPUT ("   - Initializing Instances\n");
    hRes = pLocalLoop->Init(pRemoteLoop);
    TEST_FAILED_EXIT(FAILED(hRes), "Initialize First failed\n")
    hRes = pRemoteLoop->Init(pLocalLoop);
    TEST_FAILED_EXIT(FAILED(hRes), "Initialize Second failed\n")

    //	now start the test
    OUTPUT ("   - Running LoopTest\n");
    hRes = pLocalLoop->Loop(10);
    TEST_FAILED(FAILED(hRes), "Loop failed\n")

    //	uninitialize the two instances
    OUTPUT ("   - Uninitializing Instances\n");
    hRes = pLocalLoop->Uninit();
    TEST_FAILED_EXIT(FAILED(hRes), "Uninitialize First failed\n")
    hRes = pRemoteLoop->Uninit();
    TEST_FAILED_EXIT(FAILED(hRes), "Uninitialize Second failed\n")

Cleanup:

    //	release the two instances
    OUTPUT ("   - Releasing Instances\n");

    if (pRemoteLoop)
	pRemoteLoop->Release();

    if (pLocalLoop)
	pLocalLoop->Release();

    return TestResult(RetVal, "TestLoop");
}

// ----------------------------------------------------------------------
//
//	TestMultiQINormal
//
//	tests IMultiQI interface on Normal proxies
//
// ----------------------------------------------------------------------

ULONG cMisc = 4;
const IID *iidMisc[] = {
		 &IID_IParseDisplayName, &IID_IPersistStorage,
		 &IID_IPersistFile,	 &IID_IStorage,
		 &IID_IOleContainer,	 &IID_IOleItemContainer,
		 &IID_IOleInPlaceSite,	 &IID_IOleInPlaceActiveObject,
		 &IID_IOleInPlaceObject, &IID_IOleInPlaceUIWindow,
		 &IID_IOleInPlaceFrame,	 &IID_IOleWindow};

MULTI_QI    arMQI[20];
MULTI_QI    *pMQIResStart = arMQI;

BOOL TestMultiQINormal(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes   = S_OK;
    IUnknown	    *pUnk  = NULL;
    IUnknown	    *pUnk2 = NULL;
    IMultiQI	    *pMQI  = NULL;
    ULONG		 i = 0, j=0, cRefs = 0;
    MULTI_QI	    *pMQIRes = NULL;

// ----------------------------------------------------------------------
    ULONG cSupported = 4;
    const IID *iidSupported[] = {&IID_IUnknown,	       &IID_IMultiQI,
				 &IID_IClientSecurity, &IID_IMarshal,
				 &IID_IStdIdentity,    &IID_IProxyManager};

    ULONG cUnSupported = 2;
    const IID *iidUnSupported[] = {&IID_IInternalUnknown,
				   &IID_IServerSecurity};

// ----------------------------------------------------------------------

    OUTPUT ("Starting TestMultiQINormal\n");

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_QI, NULL, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnk);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance QISRV failed\n")

    VerifyObjRefCnt(pUnk, 1);
    VerifyRHRefCnt(pUnk, 1);

// ----------------------------------------------------------------------

    OUTPUT ("\n   - NormalQI for supported interfaces\n");

    // loop through all the supported interfaces doing a normal QI.

    for (i=0; i<cSupported; i++)
    {
	hRes = pUnk->QueryInterface(*iidSupported[i], (void **)&pUnk2);
	TEST_FAILED(FAILED(hRes), "QueryInterface on supported interfaces failed\n")
	if (SUCCEEDED(hRes))
	{
	    // release the interface
	    VerifyObjRefCnt(pUnk, 2);
	    VerifyRHRefCnt(pUnk, 2);

	    OUTPUT ("       - QI for supported interface OK\n");
	    pUnk2->Release();
	}
    }


    OUTPUT ("\n   - NormalQI for unsupported interfaces\n");

    // loop through all the unsupported interfaces doing a normal QI.

    for (i=0; i<cUnSupported; i++)
    {
	hRes = pUnk->QueryInterface(*iidUnSupported[i], (void **)&pUnk2);
	TEST_FAILED(SUCCEEDED(hRes), "QueryInterface on unsupported interface succeeded but should have failed\n")

	if (SUCCEEDED(hRes))
	{
	    // release the interface
	    pUnk2->Release();
	}
	else
	{
	    VerifyObjRefCnt(pUnk, 1);
	    VerifyRHRefCnt(pUnk, 1);

	    OUTPUT ("       - QI for unsupported interface OK.\n");
	}
    }

    // should be back to normal (IUnknown)
    VerifyObjRefCnt(pUnk, 1);
    VerifyRHRefCnt(pUnk, 1);

// ----------------------------------------------------------------------

    hRes = pUnk->QueryInterface(IID_IMultiQI, (void **)&pMQI);
    TEST_FAILED_EXIT(FAILED(hRes), "QI for IMultiQI failed\n")
    VerifyObjRefCnt(pUnk, 2);
    VerifyRHRefCnt(pUnk, 2);


    OUTPUT ("\n   - MultiQI for supported interfaces\n");

    // now issue a MultiQI for the supported interfaces
    pMQIRes = pMQIResStart;
    for (i=0; i<cSupported; i++, pMQIRes++)
    {
	pMQIRes->pIID = iidSupported[i];
	pMQIRes->pItf = NULL;
    }

    pMQIRes = pMQIResStart;
    hRes = pMQI->QueryMultipleInterfaces(cSupported, pMQIRes);
    TEST_FAILED(hRes != S_OK, "QueryMultipleInterfaces should have return S_OK\n")
    VerifyObjRefCnt(pUnk, 2 + cSupported);
    VerifyRHRefCnt(pUnk, 2 + cSupported);

    for (i=0; i<cSupported; i++, pMQIRes++)
    {
	TEST_FAILED(pMQIRes->pItf == NULL, "QueryMultipleInterfaces on supported interfaces returned NULL\n")
	TEST_FAILED(FAILED(pMQIRes->hr), "QueryMultipleInterfaces on supported interfaces failed\n")

	if (pMQIRes->pItf != NULL)
	{
	    OUTPUT ("       - MultiQI for supported interface OK\n");
	    pMQIRes->pItf->Release();

	    VerifyObjRefCnt(pUnk, 2 + cSupported - (i+1));
	    VerifyRHRefCnt(pUnk, 2 + cSupported - (i+1));
	}
    }

    // should be back to normal (IUnknown + IMultiQI)
    VerifyObjRefCnt(pUnk, 2);
    VerifyRHRefCnt(pUnk, 2);

// ----------------------------------------------------------------------

    OUTPUT ("\n   - MultiQI for unsupported interfaces\n");

    // now issue a MultiQI for the unsupported interfaces
    pMQIRes = pMQIResStart;
    for (i=0; i<cUnSupported; i++, pMQIRes++)
    {
	pMQIRes->pIID = iidUnSupported[i];
	pMQIRes->pItf = NULL;
    }

    pMQIRes = pMQIResStart;
    hRes = pMQI->QueryMultipleInterfaces(cUnSupported, pMQIRes);
    TEST_FAILED(hRes != E_NOINTERFACE, "QueryMultipleInterfaces should have return E_NOINTERFACES\n")
    VerifyObjRefCnt(pUnk, 2);
    VerifyRHRefCnt(pUnk, 2);

    for (i=0; i<cUnSupported; i++, pMQIRes++)
    {
	TEST_FAILED(pMQIRes->pItf != NULL, "QueryMultipleInterfaces on supported interfaces returned NULL\n")
	TEST_FAILED(SUCCEEDED(pMQIRes->hr), "QueryMultipleInterfaces on supported interfaces failed\n")

	if (pMQIRes->pItf != NULL)
	{
	    pMQIRes->pItf->Release();
	}
	else
	{
	    OUTPUT ("       - MultiQI for unsupported interface OK\n");
	}
    }

    // should back to normal refcnts (IUnknown + IMultiQI)
    VerifyObjRefCnt(pUnk, 2);
    VerifyRHRefCnt(pUnk, 2);

// ----------------------------------------------------------------------

    // repeat this test twice, first time goes remote for the misc interfaces,
    // second time finds them already instantiated.

  for (j=0; j<2; j++)
  {
    OUTPUT ("\n   - MultiQI for combination of interfaces\n");

    pMQIRes = pMQIResStart;
    for (i=0; i<cMisc; i++, pMQIRes++)
    {
	pMQIRes->pIID = iidMisc[i];
	pMQIRes->pItf = NULL;
    }

    for (i=0; i<cSupported; i++, pMQIRes++)
    {
	pMQIRes->pIID = iidSupported[i];
	pMQIRes->pItf = NULL;
    }

    for (i=0; i<cUnSupported; i++, pMQIRes++)
    {
	pMQIRes->pIID = iidUnSupported[i];
	pMQIRes->pItf = NULL;
    }

    pMQIRes = pMQIResStart;
    hRes = pMQI->QueryMultipleInterfaces(cSupported + cUnSupported + cMisc, pMQIRes);
    TEST_FAILED(hRes != S_FALSE, "QueryMultipleInterfaces should have return S_FALSE\n")
    VerifyObjRefCnt(pUnk, 2 + cSupported + cMisc);
    VerifyRHRefCnt(pUnk, 2 + cSupported + cMisc);

    for (i=0; i<cMisc; i++, pMQIRes++)
    {
	TEST_FAILED(pMQIRes->pItf == NULL, "QueryMultipleInterfaces on supported interfaces returned NULL\n")
	TEST_FAILED(FAILED(pMQIRes->hr), "QueryMultipleInterfaces on supported interfaces failed\n")

	if (pMQIRes->pItf != NULL)
	{
	    OUTPUT ("       - MultiQI for supported remote interface OK\n");
	    pMQIRes->pItf->Release();

	    VerifyObjRefCnt(pUnk, 2 + cSupported + cMisc - (i+1));
	    VerifyRHRefCnt(pUnk, 2 + cSupported + cMisc - (i+1));
	}
    }

    for (i=0; i<cSupported; i++, pMQIRes++)
    {
	TEST_FAILED(pMQIRes->pItf == NULL, "QueryMultipleInterfaces on supported interfaces returned NULL\n")
	TEST_FAILED(FAILED(pMQIRes->hr), "QueryMultipleInterfaces on supported interfaces failed\n")

	if (pMQIRes->pItf != NULL)
	{
	    OUTPUT ("       - MultiQI for supported local interface OK\n");
	    pMQIRes->pItf->Release();

	    VerifyObjRefCnt(pUnk, 2 + cSupported - (i+1));
	    VerifyRHRefCnt(pUnk, 2 + cSupported - (i+1));
	}
    }

    for (i=0; i<cUnSupported; i++, pMQIRes++)
    {
	TEST_FAILED(pMQIRes->pItf != NULL, "QueryMultipleInterfaces on supported interfaces returned NULL\n")
	TEST_FAILED(SUCCEEDED(pMQIRes->hr), "QueryMultipleInterfaces on supported interfaces failed\n")

	if (pMQIRes->pItf != NULL)
	{
	    pMQIRes->pItf->Release();
	}
	else
	{
	    OUTPUT ("       - MultiQI for unsupported local interface OK\n");
	}
    }

    // should back to normal refcnts (IUnknown + IMultiQI)
    VerifyObjRefCnt(pUnk, 2);
    VerifyRHRefCnt(pUnk, 2);

  } // for (j=...)

// ----------------------------------------------------------------------
Cleanup:

    //	release the two instances
    OUTPUT ("   - Releasing Instances\n");

    if (pMQI)
    {
	pMQI->Release();
    }

    if (pUnk)
    {
	cRefs = pUnk->Release();
	TEST_FAILED(cRefs != 0, "Last release not zero\n");
    }

    return TestResult(RetVal, "TestMultiQINormal");
}

// ----------------------------------------------------------------------
//
//	TestMultiQIHandler
//
//	tests IMultiQI interface on Handlers
//
// ----------------------------------------------------------------------
BOOL TestMultiQIHandler(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes   = S_OK;
    IUnknown	    *pUnk  = NULL;
    IUnknown	    *pUnk2 = NULL;
    ULONG		 i = 0;
    MULTI_QI	    *pMQIRes = NULL;

// ----------------------------------------------------------------------
    ULONG cSupported = 4;
    const IID *iidSupported[] = {&IID_IUnknown, &IID_IMarshal,
				 &IID_IStdIdentity, &IID_IProxyManager};

    ULONG cUnSupported = 4;
    const IID *iidUnSupported[] = {&IID_IInternalUnknown, &IID_IClientSecurity,
				   &IID_IServerSecurity, &IID_IMultiQI};


// ----------------------------------------------------------------------

    OUTPUT ("Starting TestMultiQIHandler\n");

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_QIHANDLER1, NULL, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnk);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance QIHANDLER1 failed\n")

// ----------------------------------------------------------------------

    OUTPUT ("\n   - NormalQI for supported interfaces\n");

    // loop through all the supported interfaces doing a normal QI.

    for (i=0; i<cSupported; i++)
    {
	hRes = pUnk->QueryInterface(*iidSupported[i], (void **)&pUnk2);
	TEST_FAILED(FAILED(hRes), "QueryInterface on supported interfaces failed\n")
	if (SUCCEEDED(hRes))
	{
	    // release the interface
	    OUTPUT ("   - QI for supported interface OK\n");
	    pUnk2->Release();
	}
    }

    OUTPUT ("\n   - NormalQI for unsupported interfaces\n");

    // loop through all the unsupported interfaces doing a normal QI.

    for (i=0; i<cUnSupported; i++)
    {
	hRes = pUnk->QueryInterface(*iidUnSupported[i], (void **)&pUnk2);
	TEST_FAILED(SUCCEEDED(hRes), "QueryInterface on unsupported interface succeeded but should have failed\n")

	if (SUCCEEDED(hRes))
	{
	    // release the interface
	    pUnk2->Release();
	}
	else
	{
	    OUTPUT ("   - QI for unsupported interface OK.\n");
	}
    }
// ----------------------------------------------------------------------
Cleanup:

    //	release the two instances
    OUTPUT ("   - Releasing Instances\n");

    if (pUnk)
	pUnk->Release();

    return TestResult(RetVal, "TestMultiQIHandler");
}


// ----------------------------------------------------------------------
//
//	TestHandler
//
//	tests activating a server that has a handler
//
// ----------------------------------------------------------------------

BOOL TestHandler(void)
{
    BOOL	    RetVal   = TRUE;
    ULONG	    cRefs    = 0;
    HRESULT	    hRes     = S_OK;
    IUnknown	    *pUnkSrv = NULL;
    IUnknown	    *pUnkHdl = NULL;
    IRunnableObject *pIRO    = NULL;
    IOleObject	    *pIOO    = NULL;
    IDropTarget     *pIDT    = NULL;


    OUTPUT ("Starting TestHandler\n");

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_TestEmbed, NULL, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnkSrv);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance LOCAL_SERVER failed\n")
    VerifyObjRefCnt(pUnkSrv, 1);
    OUTPUT ("   - CoCreateInstance LOCAL_SERVER succeeded\n");

    OUTPUT ("   - QI for IRunnableObject\n");
    hRes = pUnkSrv->QueryInterface(IID_IRunnableObject, (void **)&pIRO);
    TEST_FAILED(SUCCEEDED(hRes), "QI for IRO on LOCAL_SERVER succeeded\n")

    if (pIRO)
    {
	pIRO->Release();
	pIRO = NULL;
    }

    OUTPUT ("   - Releasing Instance\n");
    if (pUnkSrv)
    {
	cRefs = pUnkSrv->Release();
	TEST_FAILED(cRefs != 0, "REFCNT wrong on Release\n")
	pUnkSrv = NULL;
    }
    OUTPUT ("   - LOCAL_SERVER case complete\n");

// ----------------------------------------------------------------------
    //	create the remote object

    hRes = CoCreateInstance(CLSID_TestEmbed, NULL, CLSCTX_INPROC_HANDLER,
			    IID_IUnknown, (void **)&pUnkHdl);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance INPROC_HANDLER failed\n")
    VerifyObjRefCnt(pUnkHdl, 1);
    VerifyRHRefCnt(pUnkHdl, 1);
    OUTPUT ("   - CoCreateInstance INPROC_HANDLER succeeded\n");

// ----------------------------------------------------------------------
    // query for some unsupported interface to ensure OLE handles QI
    // when not yet connected to the server.

    OUTPUT ("   - QI for IDropTarget\n");
    hRes = pUnkHdl->QueryInterface(IID_IDropTarget, (void **)&pIDT);
    VerifyObjRefCnt(pUnkHdl, 1);
    VerifyRHRefCnt(pUnkHdl, 1);
    TEST_FAILED_EXIT(SUCCEEDED(hRes),
	"QI for IDropTarget on INPROC_HANDLER worked but should have failed!\n")

    // the return value from failed QI on a handler that was never connected
    // must be E_NOINTERFACE
    TEST_FAILED_EXIT(hRes != E_NOINTERFACE,
	"QI for IDropTarget on INPROC_HANDLER did not return E_NOINTERFACE!\n")

    OUTPUT ("   - Query for remote Interface before connected OK.\n");

// ----------------------------------------------------------------------
    //	run the remote server

    OUTPUT ("   - QI for IRunnableObject\n");
    hRes = pUnkHdl->QueryInterface(IID_IRunnableObject, (void **)&pIRO);
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);
    TEST_FAILED_EXIT(FAILED(hRes), "QI for IRO on INPROC_HANDLER failed\n")

    hRes = pIRO->Run(NULL);
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);
    TEST_FAILED(FAILED(hRes), "IRO->Run on INPROC_HANDLER failed\n")
    OUTPUT ("   - INPROC_HANDLER run OK\n");

// ----------------------------------------------------------------------
    // test stoping the server

    OUTPUT ("   - Stop the Server\n");
    hRes = pUnkHdl->QueryInterface(IID_IOleObject, (void **)&pIOO);
    VerifyObjRefCnt(pUnkHdl, 3);
    VerifyRHRefCnt(pUnkHdl, 3);

    TEST_FAILED_EXIT(FAILED(hRes), "QI for IOleObject on INPROC_HANDLER failed\n")

    hRes = pIOO->Close(OLECLOSE_NOSAVE);
    VerifyObjRefCnt(pUnkHdl, 3);
    VerifyRHRefCnt(pUnkHdl, 3);

    TEST_FAILED(FAILED(hRes), "IOO->Close on INPROC_HANDLER failed\n")
    pIOO->Release();
    pIOO = NULL;
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);
    OUTPUT ("   - INPROC_HANDLER Close OK\n");

// ----------------------------------------------------------------------
    // query again for some unsupported interface to ensure OLE handles QI
    // when disconnected from the server.

    OUTPUT ("   - QI for IDropTarget\n");
    hRes = pUnkHdl->QueryInterface(IID_IDropTarget, (void **)&pIDT);
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);
    TEST_FAILED_EXIT(SUCCEEDED(hRes),
	"QI for IDropTarget on disconnected INPROC_HANDLER worked but should have failed!\n")

    // the return value from failed QI on a handler that has been disconnected
    // must be CO_O_OBJNOTCONNECTED

    TEST_FAILED_EXIT(hRes != CO_E_OBJNOTCONNECTED,
	"QI for IDropTarget on INPROC_HANDLER did not return CO_E_OBJNOTCONNECTED!\n")

    OUTPUT ("   - Query for remote Interface after disconnected OK.\n");

// ----------------------------------------------------------------------
    // test restarting the server

    Sleep(500);
    OUTPUT ("   - Run the Server Again\n");
    hRes = pIRO->Run(NULL);
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);

    TEST_FAILED(FAILED(hRes), "Second IRO->Run on INPROC_HANDLER failed\n")
    OUTPUT ("   - Second INPROC_HANDLER Run OK\n");

// ----------------------------------------------------------------------
    // test stoping the server

    OUTPUT ("   - Stop the Server\n");
    hRes = pUnkHdl->QueryInterface(IID_IOleObject, (void **)&pIOO);
    VerifyObjRefCnt(pUnkHdl, 3);
    VerifyRHRefCnt(pUnkHdl, 3);

    TEST_FAILED_EXIT(FAILED(hRes), "QI for IOleObject on INPROC_HANDLER failed\n")

    hRes = pIOO->Close(OLECLOSE_NOSAVE);
    VerifyObjRefCnt(pUnkHdl, 3);
    VerifyRHRefCnt(pUnkHdl, 3);

    TEST_FAILED(FAILED(hRes), "IOO->Close on INPROC_HANDLER failed\n")
    pIOO->Release();
    pIOO = NULL;
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);
    OUTPUT ("   - INPROC_HANDLER Close OK\n");

// ----------------------------------------------------------------------
    // test using weak references

    OUTPUT ("   - Call OleSetContainedObject TRUE\n");
    hRes = OleSetContainedObject(pUnkHdl, 1);
    TEST_FAILED(FAILED(hRes), "1st OleSetContainedObject on pUnkHdl failed\n")
    OUTPUT ("   - OleSetContainedObject OK\n");

    Sleep(500);
    OUTPUT ("   - Run the Server Again\n");
    hRes = pIRO->Run(NULL);
    VerifyObjRefCnt(pUnkHdl, 2);
    VerifyRHRefCnt(pUnkHdl, 2);

    TEST_FAILED(FAILED(hRes), "Third IRO->Run on INPROC_HANDLER failed\n")
    OUTPUT ("   - Third INPROC_HANDLER Run OK\n");

    // try making the references strong again
    OUTPUT ("   - Call OleSetContainedObject FALSE\n");
    hRes = OleSetContainedObject(pUnkHdl, 0);
    TEST_FAILED(FAILED(hRes), "2nd OleSetContainedObject on pUnkHdl failed\n")
    OUTPUT ("   - OleSetContainedObject OK\n");

    // try making the references weak again
    OUTPUT ("   - Call OleSetContainedObject TRUE\n");
    hRes = OleSetContainedObject(pUnkHdl, 1);
    TEST_FAILED(FAILED(hRes), "3rd OleSetContainedObject on pUnkHdl failed\n")
    OUTPUT ("   - OleSetContainedObject OK\n");

// ----------------------------------------------------------------------
    // cleanup

    pIRO->Release();
    pIRO = NULL;
    VerifyObjRefCnt(pUnkHdl, 1);
    VerifyRHRefCnt(pUnkHdl, 1);

// ----------------------------------------------------------------------

    OUTPUT ("   - Releasing Instance\n");
    if (pUnkHdl)
    {
	cRefs = pUnkHdl->Release();
	TEST_FAILED(cRefs != 0, "REFCNT wrong on Release\n")
	pUnkHdl = NULL;
    }
    OUTPUT ("   - INPROC_HANDLER case complete\n");

// ----------------------------------------------------------------------

Cleanup:

    //	release the two instances
    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    if (pIDT)
    {
	pIDT->Release();
    }

    if (pIRO)
    {
	pIRO->Release();
    }

    if (pIOO)
    {
	pIOO->Release();
    }

    if (pUnkSrv)
    {
	pUnkSrv->Release();
    }

    if (pUnkHdl)
    {
	pUnkHdl->Release();
    }

    return TestResult(RetVal, "TestHandler");
}

// ----------------------------------------------------------------------
//
//	TestGetStandardMarshal
//
//	test CoGetStandardMarshal API
//
// ----------------------------------------------------------------------

BOOL TestGetStandardMarshal(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    IMarshal	    *pIM = NULL, *pIM2 = NULL;
    IStream	    *pStm;
    IUnknown	    *punkIn = NULL;
    IUnknown	    *punkOut = NULL;


    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestGetStandardMarshal\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

// ----------------------------------------------------------------------
    hres = CoGetStandardMarshal(IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL, &pIM);
    TEST_FAILED_EXIT(FAILED(hres), "CoGetStandardMarshal failed\n")
    VerifyRHRefCnt(punkIn, 1);

    hres = CoGetStandardMarshal(IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL, &pIM2);
    TEST_FAILED_EXIT(FAILED(hres), "second CoGetStandardMarshal failed\n")
    VerifyRHRefCnt(punkIn, 2);

    TEST_FAILED((pIM != pIM2), "CoGetStandardMarshal returned two different interfaces.\n")
    ulRefCnt = pIM2->Release();
    TEST_FAILED_EXIT(ulRefCnt != 1, "pIM2 RefCnt is wrong");
    pIM2 = NULL;

    hres = CoGetStandardMarshal(IID_IUnknown, NULL, 0, NULL, MSHLFLAGS_NORMAL, &pIM2);
    TEST_FAILED_EXIT(FAILED(hres), "third CoGetStandardMarshal failed\n")
    VerifyRHRefCnt(punkIn, 1);

    OUTPUT ("   - CoGetStandardMarshal OK\n");

// ----------------------------------------------------------------------
    hres = pIM->MarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "MarshalInterface failed\n")

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	since we are unmarshalling in the same process, the RH should go away.
    hres = pIM->UnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "UnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - UnmarshalInterface OK\n");

    //	release interface and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero");
    punkOut = NULL;
    OUTPUT ("   - Release OK\n");


// ----------------------------------------------------------------------
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = pIM->MarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "MarshalInterface failed\n")

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	since we are unmarshalling in the same process, the RH should go away.
    hres = pIM2->UnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "UnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match...1st Local Unmarshal\n")
    OUTPUT ("   - Second UnmarshalInterface OK\n");

    //	release interface and make sure it does not go away - refcnt > 0
    ulRefCnt = punkOut->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero");
    punkOut = NULL;
    OUTPUT ("   - Release OK\n");

    ulRefCnt = pIM2->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "pIM2 RefCnt is zero");
    pIM2 = NULL;
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

    //	release the marshalled data
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = pIM->MarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "MarshalInterface failed\n")

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = pIM->ReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "Release Marshal Data failed\n.");
    OUTPUT ("   - ReleaseMarshalData OK\n");


    //	the RH should go away, and we should have only the original
    //	refcnt from creation left on the object.
    ulRefCnt = pIM->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "pIM RefCnt not zero");
    pIM = NULL;

    //	release the original object
    ulRefCnt = punkIn->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkIn RefCnt not zero");
    punkIn = NULL;

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT  ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestGetStandardMarshal");
}



// ----------------------------------------------------------------------
//
//	TestLockObjectExternal
//
//	test CoLockObjectExternal API
//
// ----------------------------------------------------------------------

BOOL TestLockObjectExternal(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    IUnknown	    *punkIn = NULL;
    IStream	    *pStm = NULL;

    OUTPUT ("Starting TestLockObjectExternal\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);


// ----------------------------------------------------------------------
    //	test calling it once, then releasing it once

    hres = CoLockObjectExternal(punkIn, TRUE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - CoLockObjectExternal TRUE OK\n");

    hres = CoLockObjectExternal(punkIn, FALSE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "second CoLockObjectExternal failed\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT ("   - CoLockObjectExternal FALSE OK\n");

// ----------------------------------------------------------------------
    //	test calling it twice, then releasing it twice

    //	the first AddRef inc's the StrongCnt, the RH, and the real object.
    hres = CoLockObjectExternal(punkIn, TRUE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - CoLockObjectExternal TRUE OK\n");

    //	the second AddRef inc's the StrongCnt and the RH, but not the
    //	real object.
    hres = CoLockObjectExternal(punkIn, TRUE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal failed.\n")
    VerifyRHRefCnt(punkIn, 2);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - CoLockObjectExternal TRUE OK\n");

    //	the second release Dec's the StrongCnt and the RH, but not the
    //	real object.
    hres = CoLockObjectExternal(punkIn, FALSE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "second CoLockObjectExternal failed\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - CoLockObjectExternal FALSE OK\n");

    //	the last Release dec's the StrongCnt, the RH, and the real object.
    hres = CoLockObjectExternal(punkIn, FALSE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "second CoLockObjectExternal failed\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT ("   - CoLockObjectExternal FALSE OK\n");

// ----------------------------------------------------------------------
    //	test calling it once, then releasing the punkIn and ensuring
    //	the object is still alive.

    hres = CoLockObjectExternal(punkIn, TRUE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - CoLockObjectExternal TRUE OK\n");

    ulRefCnt = punkIn->Release();
    TEST_FAILED(ulRefCnt != 1, "Release returned incorrect value.\n");
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - punkIn->Release OK\n");

    hres = CoLockObjectExternal(punkIn, FALSE, FALSE);
    TEST_FAILED_EXIT(FAILED(hres), "second CoLockObjectExternal failed\n")
    punkIn = NULL;
    OUTPUT ("   - CoLockObjectExternal FALSE OK\n");

// ----------------------------------------------------------------------
    // test calling marshal interface, followed by CLOE(F,T). This
    // should disconnect the object. This is bizarre backward compatibility
    // semantics that some LOTUS apps do rely on.

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL,
			      MSHLFLAGS_TABLESTRONG);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface TABLE_STRONG OK\n");

    hres = CoLockObjectExternal(punkIn, FALSE, TRUE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal(F,T) failed\n")
    VerifyObjRefCnt(punkIn, 1);
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - CoLockObjectExternal FALSE TRUE OK\n");


    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL,
			      MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface NORMAL OK\n");

    hres = CoLockObjectExternal(punkIn, FALSE, TRUE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal(F,T) failed\n")
    VerifyObjRefCnt(punkIn, 1);
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - CoLockObjectExternal FALSE TRUE OK\n");


    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL,
			      MSHLFLAGS_TABLEWEAK);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - CoMarshalInterface TABLEWEAK OK\n");

    // BUGBUG: refcnts seem to be wrong on the following call:

    hres = CoLockObjectExternal(punkIn, FALSE, TRUE);
    TEST_FAILED_EXIT(FAILED(hres), "CoLockObjectExternal(F,T) failed\n")
    VerifyObjRefCnt(punkIn, 1);
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - CoLockObjectExternal FALSE TRUE OK\n");

    punkIn->Release();
    punkIn = NULL;

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    if (pStm)
    {
	pStm->Release();
    }

    return TestResult(RetVal, "TestLockObjectExternal");
}


// ----------------------------------------------------------------------
//
//	TestReleaseMarshalData
//
//	test CoReleaseMarshalData API
//
// ----------------------------------------------------------------------

BOOL TestReleaseMarshalData(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    cRefs;
    IUnknown	    *punkIn = NULL;
    IStream	    *pStm = NULL;
    LARGE_INTEGER   large_int;


    OUTPUT ("Starting TestReleaseMarshalData\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    // Create a shared memory stream for the marshaled object
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

// ----------------------------------------------------------------------

    // try RMD on NORMAL marshal

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - MarshalInterface NORMAL OK\n");

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT ("   - CoReleaseMarshalData NORMAL OK\n");


    // try RMD on TABLESTRONG marshal

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_TABLESTRONG);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - MarshalInterface TABLESTRONG OK\n");

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT ("   - CoReleaseMarshalData TABLESTRONG OK\n");

    // try RMD on TABLEWEAK marshal


    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_TABLEWEAK);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);
    OUTPUT ("   - MarshalInterface TABLEWEAK OK\n");

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);
    OUTPUT ("   - CoReleaseMarshalData TABLEWEAK OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (punkIn)
    {
	cRefs = punkIn->Release();
	TEST_FAILED(cRefs != 0, "punkIn RefCnt not zero\n");
    }

    if (pStm)
    {
	pStm->Release();
    }

    return TestResult(RetVal, "TestReleaseMarshalData");
}



// ----------------------------------------------------------------------
//
//	TestDisconnectObject
//
//	test CoDisconnectObject API
//
// ----------------------------------------------------------------------

BOOL TestDisconnectObject(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    IUnknown	    *punkIn = NULL;
    IStream	    *pStm = NULL;
    LARGE_INTEGER   large_int;


    OUTPUT ("Starting TestDisconnectObject\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

    // Create a shared memory stream for the marshaled object
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

// ----------------------------------------------------------------------
    //	test calling it without having ever marshalled it.

    hres = CoDisconnectObject(punkIn, 0);
    TEST_FAILED_EXIT(FAILED(hres), "CoDisconnectObject succeeded but should have failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);

    OUTPUT ("   - first CoDisconnectObject OK\n");


    //	test calling after having marshalled it.

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_TABLEWEAK);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed.\n")
    VerifyRHRefCnt(punkIn, 1);
    VerifyObjRefCnt(punkIn, 2);

    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = CoDisconnectObject(punkIn, 0);
    TEST_FAILED_EXIT(FAILED(hres), "second CoDisconnectObject failed\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);

    OUTPUT ("   - second CoDisconnectObject OK\n");

    //	now release the marshalled data

    LISet32(large_int, 0);
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED_EXIT(FAILED(hres), "CoReleaseMarshalData failed.\n")
    VerifyRHRefCnt(punkIn, 0);
    VerifyObjRefCnt(punkIn, 1);

    OUTPUT ("   - CoReleaseMarshalData OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    // Dump interfaces we are done with
    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    if (pStm)
    {
	pStm->Release();
    }

    return TestResult(RetVal, "TestDisconnectObject");
}

// ----------------------------------------------------------------------
//
//	TestOXIDs
//
//	tests A calling B calling A calling B etc n times, to see if Rpc
//	can handle this.
//
// ----------------------------------------------------------------------
BOOL TestExpiredOXIDs(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    ILoop	    *pLocalLoop = NULL;
    IClassFactory   *pUnk = NULL;

    OUTPUT ("Starting TestExpiredOXIDs\n");

    // start the local server process manually so it stays alive for the
    // duration of the test (even though we dont have an OXIDEntry for it.

    STARTUPINFO startupInfo;
    PROCESS_INFORMATION processInfo;
    memset(&processInfo, 0, sizeof(processInfo));
    memset(&startupInfo, 0, sizeof(startupInfo));

    RetVal = CreateProcess(TEXT("ballsrv.exe"),
			   NULL,    // command line
			   NULL,    // security for process
			   NULL,    // security for thread
			   FALSE,   // inherit handles
			   NORMAL_PRIORITY_CLASS,
			   NULL,    // environment block
			   NULL,    // current directory
			   &startupInfo,
			   &processInfo);

    if (RetVal == FALSE)
    {
        hRes = GetLastError();
        OUTPUT ("   - CreateProcess Failed\n");
    }
    else
    {
        // give the process time to register its class object
        Sleep(2000);
    }

    for (ULONG i=0; i<7; i++)
    {
        // create a new instance of a local server that is already running,
        // causing us to reuse the same OXID.

        hRes = CoGetClassObject(CLSID_Balls,
        			CLSCTX_LOCAL_SERVER,
        			NULL,		     // pvReserved
        			IID_IClassFactory,
        			(void **)&pUnk);

        TEST_FAILED_EXIT(FAILED(hRes), "CoGetClassObject ballsrv failed\n")

        // release interface (lets OXIDEntry be placed on the expired list)
        pUnk->Release();
        pUnk = NULL;

        for (ULONG j=0; j<i; j++)
        {
            // create (i) new instances of another class and release them
            // right away. This causes (i) new processes to start and (i)
            // entries of the OXID table expired list to get flushed.

            hRes = CoCreateInstance(CLSID_LoopSrv, NULL, CLSCTX_LOCAL_SERVER,
        		    IID_ILoop, (void **)&pLocalLoop);
            TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance First failed\n")
            pLocalLoop->Release();
            pLocalLoop = NULL;
        }
    }

Cleanup:

    //	release the two instances
    OUTPUT ("   - Releasing Instances\n");

    if (pUnk)
        pUnk->Release();

    if (pLocalLoop)
        pLocalLoop->Release();

    // kill the server process
    if (processInfo.hProcess != 0)
    {
        BOOL fKill = TerminateProcess(processInfo.hProcess, 0);
        if (!fKill)
        {
            hRes = GetLastError();
            OUTPUT ("   - TermintateProcess Failed\n");
        }

        CloseHandle(processInfo.hThread);
        CloseHandle(processInfo.hProcess);
    }

    return TestResult(RetVal, "TestExpiredOXIDs");
}




// ----------------------------------------------------------------------
//
//	TestAggregate
//
//	tests creating an RH that is aggregated.
//
// ----------------------------------------------------------------------

BOOL TestAggregate(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    IUnknown	    *punkOuter = NULL;
    IUnknown	    *pUnk = NULL;
    IBalls	    *pIBall = NULL;
    ULONG	    ulRefCnt = 0;

    OUTPUT ("Starting TestAggregate\n");

    punkOuter = GetTestUnk();
    TEST_FAILED_EXIT((punkOuter == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkOuter, 1);

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_Balls, punkOuter, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnk);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance First failed\n")

    //	now release the object
    ulRefCnt = pUnk->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "Release failed\n")

// ----------------------------------------------------------------------

    //	create our interface to pass to the remote object.
    hRes = CoCreateInstance(CLSID_Balls, punkOuter, CLSCTX_LOCAL_SERVER,
			    IID_IUnknown, (void **)&pUnk);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance First failed\n")

    hRes = pUnk->QueryInterface(IID_IBalls, (void **)&pIBall);
    TEST_FAILED_EXIT(FAILED(hRes), "QueryInterface failed\n")

    //	now release the interface
    ulRefCnt = pIBall->Release();
    TEST_FAILED_EXIT(ulRefCnt == 0, "Release failed\n")

    //	now release the object
    ulRefCnt = pUnk->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "Release failed\n")

    //	now release the punkOuter
    ulRefCnt = punkOuter->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "Release failed\n")

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    return TestResult(RetVal, "TestAggregate");
}



// ----------------------------------------------------------------------
//
//	TestCreateRemoteHandler
//
//	test CoCreateRemoteHandler API and unmarshalling data into it.
//
// ----------------------------------------------------------------------

BOOL TestCreateRemoteHandler(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    IUnknown	    *punkBall = NULL;
    IUnknown	    *punkOuter = NULL;
    IClassFactory   *pICF = NULL;


    OUTPUT ("Starting TestCreateRemoteHandler\n");


    //	create the controlling unknown for the remote object.
    punkOuter = GetTestUnk();

// ----------------------------------------------------------------------

    //	create a remote object that we will aggregate.

    //	Create an IBall ClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject Balls failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject Balls failed\n")
    OUTPUT ("   - Aquired Remote Balls Class Object.\n");
    VerifyObjRefCnt(pICF, 1);
    VerifyRHRefCnt(pICF, 1);

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(punkOuter, IID_IUnknown, (void **)&punkBall);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((punkBall == NULL), "CreateInstance failed\n")
    OUTPUT ("   - Created Balls Instance.\n");

    VerifyObjRefCnt(punkBall, 1);
    VerifyRHRefCnt(punkBall, 1);

// ----------------------------------------------------------------------

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    pICF = NULL;
    OUTPUT ("   - Released Balls Class Object.\n");

    //	release the remote object handler
    ulRefCnt = punkBall->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkBall RefCnt not zero");
    punkBall = NULL;

    //	release the outer
    ulRefCnt = punkOuter->Release();
    TEST_FAILED_EXIT(ulRefCnt != 0, "punkOuter RefCnt not zero");
    punkOuter = NULL;

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    if (punkBall)
    {
	ulRefCnt = punkBall->Release();
	TEST_FAILED(ulRefCnt != 0, "punkBall RefCnt not zero\n");
    }

    if (punkOuter)
    {
	ulRefCnt = punkOuter->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOuter RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestCreateRemoteHandler");
}


// ----------------------------------------------------------------------
//
//	TestTIDAndLID
//
//	test the values of TID and MID to ensure they are correct across
//	calls.
//
// ----------------------------------------------------------------------
HRESULT        TIDAndLIDSubroutine();
DWORD _stdcall TIDAndLIDServer(void *param);


BOOL TestTIDAndLID(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes;

    // First, try it across process boundaries.
    hRes = TIDAndLIDSubroutine();
    TEST_FAILED(FAILED(hRes), "TIDAndLID different process failed\n")


    // Next, try it across thread boundaries.
    // Spin a thread to be the server of the TIDAndLID

    HANDLE hEvent[2];
    hEvent[0]= CreateEvent(NULL, FALSE, FALSE, NULL);
    hEvent[1]= CreateEvent(NULL, FALSE, FALSE, NULL);

    DWORD dwThrdId = 0;
    HANDLE hThrd = CreateThread(NULL, 0,
			    TIDAndLIDServer,
			    &hEvent[0], 0, &dwThrdId);
    if (hThrd)
    {
	// wait for thread to register its class object
	WaitForSingleObject(hEvent[0], 0xffffffff);
	Sleep(0);

	// Now run the whole test again. This time CoGetClassObject should
	// find the server running in the other thread.

	hRes = TIDAndLIDSubroutine();
	TEST_FAILED(FAILED(hRes), "TIDAndLID different process failed\n")

	// signal the other thread to exit
	CloseHandle(hThrd);
	PostThreadMessage(dwThrdId, WM_QUIT, 0, 0);

	// wait for other thread to call CoUninitialize
	WaitForSingleObject(hEvent[1], 0xffffffff);
	CloseHandle(hEvent[0]);
	CloseHandle(hEvent[1]);
    }
    else
    {
	hRes = GetLastError();
	TEST_FAILED(hRes, "CreateThread failed\n")
    }

    return TestResult(RetVal, "TestTIDAndLID");
}

HRESULT TIDAndLIDSubroutine()
{
    BOOL	    RetVal = TRUE;
    ULONG	    ulRefCnt;
    ICube	    *pCube = NULL;
    IUnknown	    *pUnk  = NULL;
    HRESULT	    hRes;

    // create our interface to pass to the remote object.
    OUTPUT ("   - Create Instance of ICube\n");
    hRes = CoCreateInstance(CLSID_Cubes, NULL, CLSCTX_LOCAL_SERVER,
			    IID_ICube, (void **)&pCube);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance CLSID_Cubes failed\n")
    OUTPUT ("   - Instance of ICubes created OK\n");

    pUnk = GetTestUnk();

    hRes = pCube->PrepForInputSyncCall(pUnk);
    TEST_FAILED(FAILED(hRes), "pCube->PreForInputSyncCall failed\n")

    hRes = pCube->InputSyncCall();
    if (gInitFlag == COINIT_APARTMENTTHREADED)
    {
	TEST_FAILED(FAILED(hRes), "pCube->InputSyncCall failed\n")
    }
    else
    {
	TEST_FAILED(SUCCEEDED(hRes), "pCube->InputSyncCall should have failed\n")
    }
    OUTPUT ("   - Completed Release inside InputSync call\n");


    OUTPUT ("   - Get the current LID information\n");
    UUID  lidCaller;
    CoGetCurrentLogicalThreadId(&lidCaller);

    OUTPUT ("   - call on ICube interface\n");
    hRes = pCube->SimpleCall(GetCurrentProcessId(),
			     GetCurrentThreadId(),
			     lidCaller);

    TEST_FAILED(FAILED(hRes), "pCube->SimpleCall failed\n")

    // release the interface
    OUTPUT ("   - Release the ICube interface\n");
    ulRefCnt = pCube->Release();
    TEST_FAILED(ulRefCnt != 0, "pCube RefCnt not zero\n");
    pCube = NULL;

Cleanup:

    OUTPUT ("   - Subroutine Complete. Doing Cleanup\n");

    if (pCube != NULL)
    {
	pCube->Release();
	pCube = NULL;
    }

    return hRes;
}

// current COINIT flag used on main thread
extern DWORD gInitFlag;

DWORD _stdcall TIDAndLIDServer(void *param)
{
    BOOL    RetVal = TRUE;

    HANDLE *pHandle = (HANDLE *) param;

    HANDLE  hEvent[2];
    hEvent[0] = *pHandle;
    hEvent[1] = *(pHandle+1);

    OUTPUT ("   - TIDAndLIDServer Start\n");

    HRESULT hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "TIDAndLIDServer CoInitialize failed\n")

    if (SUCCEEDED(hRes))
    {
	DWORD dwReg;
	IClassFactory *pICF = new CTestUnkCF();

	if (pICF)
	{
	    hRes = CoRegisterClassObject(CLSID_Cubes, pICF,
					 CLSCTX_LOCAL_SERVER,
					 REGCLS_MULTIPLEUSE, &dwReg);

	    TEST_FAILED(FAILED(hRes), "TIDAndLID CoRegisterClassObject failed\n")
	    SetEvent(hEvent[0]);

	    if (SUCCEEDED(hRes))
	    {
		MSG msg;
		while (GetMessage(&msg, NULL, 0, 0))
		{
		    DispatchMessage(&msg);
		}

		hRes = CoRevokeClassObject(dwReg);
		TEST_FAILED(FAILED(hRes), "TIDAndLID CoRevokeClassObject failed\n")
	    }
	}
	else
	{
	    // set the event anyway
	    TEST_FAILED(TRUE, "TIDAndLID new CTestUnkCF failed\n")
	    SetEvent(hEvent[0]);
	}

	CoUninitialize();
    }
    else
    {
	// wake the other guy anyway
	SetEvent(hEvent[0]);
    }

    // signal we've called CoUninitialize
    SetEvent(hEvent[1]);

    OUTPUT ("   - TIDAndLIDServer done\n");
    return hRes;
}


// ----------------------------------------------------------------------
//
//	TestNonNDRProxy
//
//	test using a non-NDR proxy and stub for ICube interface.
//
// ----------------------------------------------------------------------
BOOL TestNonNDRProxy(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes;
    ULONG	    ulRefCnt;
    ICube	    *pCube = NULL;


    OUTPUT ("Starting TestNonNDR\n");

    // stomp on the registry to use our custom proxy dll for ICube interface
    BYTE  szValueSave[MAX_PATH];
    DWORD cbValue = sizeof(szValueSave);
    DWORD dwType;

    LONG lRes = RegQueryValueEx(HKEY_CLASSES_ROOT,
		    TEXT("Interface\\{00000139-0001-0008-C000-000000000046}\\ProxyStubClsid32"),
		    NULL,
		    &dwType,
		    szValueSave,
		    &cbValue);

    if (lRes == ERROR_SUCCESS)
    {
	BYTE szValueNew[40];
	strcpy((char *)&szValueNew[0], "{0000013e-0001-0008-C000-000000000046}");

	lRes = RegSetValueEx(HKEY_CLASSES_ROOT,
		    TEXT("Interface\\{00000139-0001-0008-C000-000000000046}\\ProxyStubClsid32"),
		    NULL,
		    dwType,
		    szValueNew,
		    sizeof(szValueNew));
    }

    // create our interface to pass to the remote object.
    OUTPUT ("   - Create Instance of ICube\n");
    hRes = CoCreateInstance(CLSID_Cubes, NULL, CLSCTX_LOCAL_SERVER,
			    IID_ICube, (void **)&pCube);
    TEST_FAILED_EXIT(FAILED(hRes), "CoCreateInstance failed\n")
    OUTPUT ("   - Instance of ICube created OK\n");


    OUTPUT ("   - Make first call on ICube interface\n");
    hRes = pCube->MoveCube(23, 34);
    TEST_FAILED(FAILED(hRes), "ICube->MoveCube failed\n")

    // release the interface
    OUTPUT ("   - Release the ICube interface\n");
    ulRefCnt = pCube->Release();
    TEST_FAILED(ulRefCnt != 0, "pCube RefCnt not zero\n");
    pCube = NULL;

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    // restore the registry to use real proxy dll for ICube interface
    if (lRes == ERROR_SUCCESS)
    {
	lRes = RegSetValueEx(HKEY_CLASSES_ROOT,
		    TEXT("Interface\\{00000139-0001-0008-C000-000000000046}\\ProxyStubClsid32"),
		    NULL,
		    dwType,
		    szValueSave,
		    cbValue);
    }

    return TestResult(RetVal, "TestNonNDR");
}


// ----------------------------------------------------------------------
//
//	test rundown
//
//  - build 9 objects
//  - marshal 3 NORMAL, 3 TABLE_STRONG, 3 TABLE_WEAK.
//  - start 3 clients that each do 3 things...
//	  Unmarshal Objects
//	  Call Method on each object
//	  Release Objects
//	  each client has a sleep before one of the operations to let rundown
//	  happen.
//  - CoDisconnectObject each of the 9 objects
//
// ----------------------------------------------------------------------
BOOL TestRundown(void)
{
    BOOL	  RetVal = TRUE;
    BOOL	  fSame  = TRUE;
    ULONG	  k = 0;
    HRESULT	  hres;
    IStream	  *pstm[3] = {NULL, NULL, NULL};
    IUnknown	  *punk[9] = {NULL, NULL, NULL,
			      NULL, NULL, NULL,
			      NULL, NULL, NULL};

    DWORD	   mshlflags[3] = {MSHLFLAGS_NORMAL,
				   MSHLFLAGS_TABLESTRONG,
				   MSHLFLAGS_TABLEWEAK};

    MSG msg;
    DWORD dwEndTime;


    OUTPUT ("Starting TestRundown\n");


    // create 9 objects to play with
    OUTPUT ("Creating Nine Objects\n");
    for (ULONG i=0; i<9; i++)
    {
	punk[i] = GetTestUnk();
	TEST_FAILED_EXIT((punk[i] == NULL), "new CTestUnk failed\n")
	VerifyObjRefCnt(punk[i], 1);
    }


    // create 3 streams on files
    OUTPUT ("Creating Three Streams\n");
    for (i=0; i<3; i++)
    {
	pstm[i] = (IStream *) new CStreamOnFile(pwszFileName[i] ,hres, FALSE);
	TEST_FAILED_EXIT((pstm[i] == NULL), "new CStreamOnFile failed\n")
	TEST_FAILED_EXIT(FAILED(hres),	 "CStreamOnFile failed\n")
	VerifyObjRefCnt(pstm[i], 1);
    }

// ----------------------------------------------------------------------

    // marshal the nine objects into 3 different streams on files.
    OUTPUT ("Marshal Nine Objects into Three Streams\n");


    // loop on stream
    for (i=0; i<3; i++)
    {
	// loop on marshal flags
	for (ULONG j=0; j<3; j++)
	{
	    hres = CoMarshalInterface(pstm[i], IID_IParseDisplayName, punk[k++],
				      0, NULL, mshlflags[j]);
	    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	}
    }


    // release the streams
    OUTPUT ("Releasing the streams\n");
    for (i=0; i<3; i++)
    {
	pstm[i]->Release();
	pstm[i] = NULL;
    }


    // start the 3 client processes
    OUTPUT ("Start Three Client Processes\n");

#if 0
    for (i=0; i<3; i++)
    {
	DWORD dwThrdId = 0;
	HANDLE hThrd = CreateThread(NULL, 0,
				    RundownClient,
				    (void *)i,
				    0, &dwThrdId);

	if (hThrd)
	{
	    CloseHandle(hThrd);
	}
	else
	{
	    hres = GetLastError();
	    TEST_FAILED_EXIT(hres, "CreateThread failed\n")
	}
    }
#endif

    // sleep for some time to let the clients run
    OUTPUT ("Waiting 12 minutes to let clients run\n");

    dwEndTime = GetTickCount() + 780000;

    while (GetTickCount() < dwEndTime)

    {
	if (PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE))
	{
	    if (GetMessage(&msg, NULL, 0, 0))
		DispatchMessage(&msg);
	}
	else
	{
	    Sleep(250);
	}
    }

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    // disconnect the nine objects
    OUTPUT ("Disconnecting Nine Objects\n");
    for (i=0; i<9; i++)
    {
	if (punk[i] != NULL)
	{
	    hres = CoDisconnectObject(punk[i], 0);
	    punk[i] = NULL;
	    TEST_FAILED(FAILED(hres), "CoDisconnectObject failed\n")
	}
    }

    // release the streams
    OUTPUT ("Releasing the streams\n");
    for (i=0; i<3; i++)
    {
	if (pstm[i] != NULL)
	{
	    pstm[i]->Release();
	    pstm[i] = NULL;
	}
    }

    return TestResult(RetVal, "TestRundown");
}

// ----------------------------------------------------------------------
//
//	test rundown worker thread
//
//	starts a thread that will do...
//	  Unmarshal Objects
//	  Call Method on each object
//	  Release Objects
//
//	perform a sleep before one of the operations to let rundown
//	happen.
//
// ----------------------------------------------------------------------
DWORD _stdcall RundownClient(void *param)
{
    BOOL    RetVal = TRUE;
    ULONG   i = 0;
    HRESULT hres;
    IStream *pstm = NULL;
    IBindCtx *pbctx = NULL;
    IParseDisplayName *punk[3] = {NULL, NULL, NULL};


    OUTPUT ("    Starting RundownClient\n");

    // get the filename from the passed in parameter
    DWORD dwThreadNum = (DWORD)param;

    hres = CoInitialize(NULL);
    TEST_FAILED_EXIT(FAILED(hres),   "CoInitialzie failed\n")


    // create a stream on the file
    OUTPUT ("   - CreateStreamOnFile\n");
    pstm = (IStream *) new CStreamOnFile(pwszFileName[dwThreadNum], hres, TRUE);
    TEST_FAILED_EXIT((pstm == NULL), "CStreamOnFile failed\n")
    TEST_FAILED_EXIT(FAILED(hres),   "CStreamOnFile failed\n")
    VerifyObjRefCnt(pstm, 1);

// ----------------------------------------------------------------------

    if (dwThreadNum == 2)
	Sleep(5000);

    // unmarshal the interfaces
    OUTPUT ("   - Unmarshal the interfaces\n");
    for (i=0; i<3; i++)
    {
	hres = CoUnmarshalInterface(pstm, IID_IParseDisplayName,
				    (void **)&punk[i]);
	TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    }
    OUTPUT ("   - Unmarshaled the interfaces OK.\n");

// ----------------------------------------------------------------------

    if (dwThreadNum == 1)
	Sleep(5000);

    hres = CreateBindCtx(0, &pbctx);
    TEST_FAILED_EXIT(FAILED(hres), "CreateBindCtx failed\n")

    // call the objects
    for (i=0; i<3; i++)
    {
	ULONG cbEaten = 0;
	IMoniker *pmnk = NULL;

	hres = punk[i]->ParseDisplayName(pbctx, pwszFileName[dwThreadNum],
					&cbEaten, &pmnk);
	TEST_FAILED(FAILED(hres), "call on object failed\n")

	if (pmnk)
	{
	    pmnk->Release();
	}
    }
    OUTPUT ("   - Called the interfaces OK.\n");

    pbctx->Release();

// ----------------------------------------------------------------------

    if (dwThreadNum == 0)
	Sleep(5000);

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Rundown Thread Complete. Doing Cleanup\n");

    // release the objects
    for (i=0; i<3; i++)
    {
	if (punk[i] != NULL)
	{
	    punk[i]->Release();
	    punk[i] = NULL;
	}
    }
    OUTPUT ("   - Released the interfaces OK.\n");

    // release the stream
    pstm->Release();

    CoUninitialize();

    return TestResult(RetVal, "TestRundown");
}



// ----------------------------------------------------------------------
//
//	TestMarshalStorage
//
//	test marshalling a docfile
//
// ----------------------------------------------------------------------

BOOL TestMarshalStorage(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    ULONG	    ulRefCnt;
    IStorage	    *pStgIn = NULL;
    IStorage	    *pStgOut = NULL;
    IStream	    *pStm = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestMarshalStorage\n");

    //	create a docfile
    hres = StgCreateDocfile(L"foo.bar",
			    STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
			    0, &pStgIn);

    TEST_FAILED_EXIT(FAILED(hres), "StgCreateDocFile failed\n")

    //	create a stream to marshal the storage into
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);


// ----------------------------------------------------------------------

    //	marshal the interface
    hres = CoMarshalInterface(pStm, IID_IStorage, pStgIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    //	since we are unmarshalling in the same process, the RH should go away.
    hres = CoUnmarshalInterface(pStm, IID_IStorage, (LPVOID FAR*)&pStgOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")

    //	make sure the interface pointers are identical
    if (pStgIn != pStgOut)
	OUTPUT("WARNING: CoUnmarshalInterface Local...ptrs dont match\n")
    else
	OUTPUT ("   - CoUnmarshalInterface OK\n");

    //	release it and make sure it does not go away - refcnt > 0
    ulRefCnt = pStgOut->Release();
    pStgOut  = NULL;
    TEST_FAILED(ulRefCnt == 0, "pStgOut RefCnt is not zero");
    OUTPUT ("   - Release OK\n");

    //	the RH should have gone away, and we should have only the original
    //	refcnt from creation left on the object.
    VerifyObjRefCnt(pStgIn, 1);


// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    if (pStgIn)
    {
	ulRefCnt = pStgIn->Release();
	TEST_FAILED(ulRefCnt != 0, "pStgIn RefCnt not zero\n");
    }

    if (pStgOut)
    {
	ulRefCnt = pStgOut->Release();
	TEST_FAILED(ulRefCnt != 0, "pStgOut RefCnt not zero\n");
    }

    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "pStm RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestMarshalStorage");
}



// ----------------------------------------------------------------------
//
//	test LOCAL interface MSHLFLAGS_NORMAL, MSHCTX_DIFFERENTMACHINE
//
// ----------------------------------------------------------------------

BOOL TestStorageInterfaceDiffMachine(void)
{
    BOOL	  RetVal = TRUE;
    HRESULT	  hres;
    LPSTREAM	  pStm = NULL;
    ULONG	  ulRefCnt = 0;
    IStorage	  *pStgIn = NULL;
    IStorage	  *pStgOut = NULL;

    LARGE_INTEGER large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestStorageInterfaceDiffMachine\n");

    //	create a docfile
    hres = StgCreateDocfile(L"foo.bar",
			    STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
			    0, &pStgIn);
    TEST_FAILED_EXIT(FAILED(hres), "CreateDocfile failed\n")

    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);


// ----------------------------------------------------------------------
    hres = CoMarshalInterface(pStm, IID_IStorage, pStgIn,
			      MSHCTX_DIFFERENTMACHINE, 0,
			      MSHLFLAGS_NORMAL);

    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    VerifyRHRefCnt(pStgIn, 1);
    OUTPUT ("   - CoMarshalInterface OK\n");

    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IStorage, (LPVOID FAR*)&pStgOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(pStgIn, 0);

    //	release them
    ulRefCnt = pStgOut->Release();
    pStgOut = NULL;
    OUTPUT ("   - Release OK\n");

    ulRefCnt = pStgIn->Release();
    pStgIn = NULL;
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    if (pStgIn)
    {
	ulRefCnt = pStgIn->Release();
	TEST_FAILED(ulRefCnt != 0, "pStgIn RefCnt not zero\n");
    }

    if (pStgOut)
    {
	ulRefCnt = pStgOut->Release();
	TEST_FAILED(ulRefCnt != 0, "pStgOut RefCnt not zero\n");
    }

    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "pStm RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestStorageInterfaceDiffMachine");
}



// ----------------------------------------------------------------------
//
//	test REMOTE interface MSHLFLAGS_NORMAL, MSHCTX_DIFFERENTMACHINE
//
// ----------------------------------------------------------------------

BOOL TestRemoteInterfaceDiffMachine(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    LPCLASSFACTORY  pICF = NULL;
    ULONG	    ulRefCnt;
    IUnknown	    *punkOut = NULL;
    IUnknown	    *punkIn  = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestRemoteInterfaceDifferentMachine\n");

    //	Create an IClassFactory Interface.
    DWORD grfContext=CLSCTX_LOCAL_SERVER; // handler/server/local server
    hres = CoGetClassObject(CLSID_Balls,
			    grfContext,
			    NULL,	  // pvReserved
			    IID_IClassFactory,
			    (void **)&pICF);

    TEST_FAILED_EXIT(FAILED(hres), "CoGetClassObject failed\n")
    TEST_FAILED_EXIT((pICF == NULL), "CoGetClassObject failed\n")
    VerifyRHRefCnt((IUnknown *)pICF, 1);
    OUTPUT ("   - Aquired Remote Class Object.\n");

// ----------------------------------------------------------------------

    //	note, since pICF is a class object, it has special super secret
    //	behaviour to make it go away.  create an instance, release the
    //	class object, then release the instance.

    hres = pICF->CreateInstance(NULL, IID_IUnknown, (void **)&punkIn);
    TEST_FAILED_EXIT(FAILED(hres), "CreateInstance failed\n")
    TEST_FAILED_EXIT((punkIn == NULL), "CreateInstance failed\n")
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Created Instance.\n");

    //	release class object
    ulRefCnt = pICF->Release();
    TEST_FAILED(ulRefCnt != 0, "pICF RefCnt not zero\n");
    // VerifyRHRefCnt((IUnknown *)pICF, 0);
    pICF = NULL;
    OUTPUT ("   - Released Class Object.\n");

// ----------------------------------------------------------------------

    //	Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

    //	Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn,
			      MSHCTX_DIFFERENTMACHINE, 0,
			      MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punkIn, 1);

    //	unmarshal the interface. should get the same proxy back.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 2);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..1st Remote Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK.\n");


    //	release the interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    VerifyRHRefCnt(punkIn, 1);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestRemoteInterfaceDiffMachine");
}

// ----------------------------------------------------------------------
//
//	test LOCAL interface MSHLFLAGS_NORMAL, MSHCTX_DIFFERENTMACHINE
//
// ----------------------------------------------------------------------

BOOL TestLocalInterfaceDiffMachine(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    LPCLASSFACTORY  pICF = NULL;
    ULONG	    ulRefCnt;
    IUnknown	    *punkOut = NULL;
    IUnknown	    *punkIn  = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestLocalInterfaceDifferentMachine\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

// ----------------------------------------------------------------------

    //	Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

    //	Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn,
			      MSHCTX_DIFFERENTMACHINE, 0,
			      MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punkIn, 1);

    //	unmarshal the interface. should get the same proxy back.
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
    TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")
    VerifyRHRefCnt(punkIn, 0);

    //	make sure the interface pointers are identical
    if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..1st Local Unmarshal\n")
    OUTPUT ("   - CoUnmarshalInterface OK.\n");


    //	release the interface
    ulRefCnt = punkOut->Release();
    punkOut = NULL;
    TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero\n");
    VerifyRHRefCnt(punkIn, 0);
    OUTPUT ("   - Release OK\n");

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    return TestResult(RetVal, "TestLocalInterfaceDiffMachine");
}

// ----------------------------------------------------------------------
//
//	test NOPING with MSHLFLAGS NORMAL, TABLEWEAK and TABLESTRONG
//
//  CodeWork: ensure SORF_FLAG set correctly.
//	      ensure precedence rules are followed.
//	      ensure protocol is followed.
//
// ----------------------------------------------------------------------
typedef struct tagNoPingThreadInfo
{
    HANDLE  hEvent;
    IStream *pStm;
    HRESULT hr;
} NoPingThreadInfo;

DWORD _stdcall NoPingThread(void *param);

BOOL TestNoPing(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    ULONG	    ulRefCnt, i;
    IUnknown	    *punkOut = NULL;
    IUnknown	    *punkIn  = NULL;
    IUnknown	    *punk[5] = {NULL, NULL, NULL, NULL, NULL};
    NoPingThreadInfo npInfo;
    DWORD	     dwThrdId = 0;
    HANDLE	    hThrd;
    IMarshal	    *pIM = NULL;

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestNoPing\n");

    punkIn = GetTestUnk();
    TEST_FAILED_EXIT((punkIn == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punkIn, 1);

// ----------------------------------------------------------------------

    // Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

    // marshal it NORMAL, TABLEWEAK and TABLESTRONG with the NOPING flag
    // set, and unmarshal each in the server apartment.

    for (i=0; i<3; i++)
    {
	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn,
			      0, 0, (i | MSHLFLAGS_NOPING));

	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	OUTPUT ("   - CoMarshalInterface OK.\n");
	VerifyRHRefCnt(punkIn, 1);


	// verify the marshal format
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = VerifyOBJREFFormat(pStm, (i | MSHLFLAGS_NOPING));
	TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	OUTPUT ("   - VerifyOBJREFFormat OK.\n");


	// unmarshal the interface. should get the same proxy back.
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = CoUnmarshalInterface(pStm, IID_IUnknown, (LPVOID FAR*)&punkOut);
	TEST_FAILED_EXIT(FAILED(hres), "CoUnmarshalInterface failed\n")


	// make sure the interface pointers are identical
	if (punkIn != punkOut)
	TEST_FAILED_EXIT(TRUE, "Interface ptrs dont match..1st Local Unmarshal\n")
	OUTPUT ("   - CoUnmarshalInterface OK.\n");

	// check the refcnt on the stdid
	if (i == 0)
	{
	    // normal case, stdid should have been cleaned up
	    VerifyRHRefCnt(punkIn, 0);
	}
	else
	{
	    // table case, stdid should still exist
	    VerifyRHRefCnt(punkIn, 1);
	}

	// release the interface
	ulRefCnt = punkOut->Release();
	punkOut  = NULL;

	TEST_FAILED_EXIT(ulRefCnt == 0, "punkOut RefCnt is zero\n");
	VerifyRHRefCnt(punkIn, (i == 0) ? 0 : 1);
	OUTPUT ("   - Release OK\n");

	if (i > 0)
	{
	    // need to release marshal data on table marshaled interfaces
	    // reset the stream
	    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	    hres = CoReleaseMarshalData(pStm);
	    TEST_FAILED_EXIT(FAILED(hres), "ReleaseMarshalData failed\n")
	}

	// reset the stream
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")
    }


    // check the precedence rules

    // Whatever an interface is first marshaled as is what sets the
    // PING / NOPING flags. Marshal first as normal then noping and
    // expect a normal 2nd marshal. Then marshal first as noping then
    // normal and expect a noping 2nd marshal.

    for (i=0; i<2; i++)
    {
	DWORD mshlflags1 =  (i==0) ? MSHLFLAGS_NORMAL : MSHLFLAGS_NOPING;
	DWORD mshlflags2 =  (i==0) ? MSHLFLAGS_NOPING : MSHLFLAGS_NORMAL;

	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn,
			      0, 0, mshlflags1);

	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	OUTPUT ("   - CoMarshalInterface OK.\n");
	VerifyRHRefCnt(punkIn, 1);

	// verify the marshal format
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = VerifyOBJREFFormat(pStm, mshlflags1);
	TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	OUTPUT ("   - VerifyOBJREFFormat OK.\n");


	// marshal it again, with the opposite flags then check the value
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn,
			      0, 0, mshlflags2);

	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	OUTPUT ("   - CoMarshalInterface OK.\n");
	VerifyRHRefCnt(punkIn, 1);

	// verify the marshal format
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = VerifyOBJREFFormat(pStm, mshlflags1);
	TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	OUTPUT ("   - VerifyOBJREFFormat OK.\n");

	// release the marshaled data
	hres = CoDisconnectObject(punkIn, 0);
	TEST_FAILED_EXIT(FAILED(hres), "CoDisconnectObject failed\n")
	OUTPUT ("   - CoDisconnectObject OK.\n");

	// reset the stream
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")



	// check CoGetStandardMarshal.
	hres = CoGetStandardMarshal(IID_IUnknown, punkIn, 0, 0,
				    mshlflags1, &pIM);
	TEST_FAILED_EXIT(FAILED(hres), "CoGetStandardMarshal failed\n")
	OUTPUT ("   - CoGetStandardMarshal OK.\n");

	// Marshal the interface into the stream
	hres = pIM->MarshalInterface(pStm, IID_IUnknown, punkIn,
				     0, 0, mshlflags2);
	TEST_FAILED_EXIT(FAILED(hres), "pIM->MarshalInterface failed\n")
	OUTPUT ("   - pIM->MarshalInterface OK.\n");

	// verify the marshal format
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	hres = VerifyOBJREFFormat(pStm, mshlflags1);
	TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	OUTPUT ("   - VerifyOBJREFFormat OK.\n");

	// release the IMarshal
	pIM->Release();

	// release the marshal data
	hres = CoDisconnectObject(punkIn, 0);
	TEST_FAILED_EXIT(FAILED(hres), "CoDisconnectObject failed\n")
	OUTPUT ("   - CoDisconnectObject OK.\n");

	// reset the stream
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")
    }



    // marshal 3 objects, NORMAL, TABLEWEAK, and TABLESTRONG, then
    // pass the stream to another apartment and unmarshal them.

    for (i=0; i<3; i++)
    {
	punk[i] = GetTestUnk();
	TEST_FAILED_EXIT((punk[i] == NULL), "new CTestUnk failed\n")
	VerifyObjRefCnt(punk[i], 1);

	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_IUnknown, punk[i],
			      0, 0, (i | MSHLFLAGS_NOPING));

	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	OUTPUT ("   - CoMarshalInterface OK.\n");
	VerifyRHRefCnt(punk[i], 1);
    }

    // marshal one more object, NOPING
    punk[i] = GetTestUnk();
    TEST_FAILED_EXIT((punk[i] == NULL), "new CTestUnk failed\n")
    VerifyObjRefCnt(punk[i], 1);

    // Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punk[i],
		      0, 0, (MSHLFLAGS_NORMAL | MSHLFLAGS_NOPING));

    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punk[i], 1);


    // marshal a second interface on the same object as PING
    hres = CoMarshalInterface(pStm, IID_IParseDisplayName, punk[i],
		      0, 0, MSHLFLAGS_NORMAL);

    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punk[i], 2);


    // pass one more interface that does custom marshaling delegating
    // to standard marshaling and replacing the PING option with NOPING.
    i++;
    punk[i] = (IUnknown *) new CTestUnkMarshal();
    TEST_FAILED_EXIT((punk[i] == NULL), "new CTestUnkMarshal failed\n")
    VerifyObjRefCnt(punk[i], 1);

    // Marshal the interface into the stream
    hres = CoMarshalInterface(pStm, IID_IUnknown, punk[i],
		      0, 0, MSHLFLAGS_NORMAL);

    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK.\n");
    VerifyRHRefCnt(punk[i], 2);


    // reset the stream seek ptr
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    for (i=0; i<6; i++)
    {
	// verify the marshal format
	hres = VerifyOBJREFFormat(pStm, (i | MSHLFLAGS_NOPING));
	TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	OUTPUT ("   - VerifyOBJREFFormat OK.\n");
    }

    // reset the stream seek ptr
    hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

    // create thread and wait for it to complete
    npInfo.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    npInfo.pStm   = pStm;
    npInfo.hr	  = S_OK;

    hThrd = CreateThread(NULL, 0, NoPingThread,
			&npInfo, 0, &dwThrdId);
    if (hThrd)
    {
	// wait for thread to register run to completetion. Note that
	// we dont have to provide a message pump because with the NOPING
	// flag set the other thread should never call back to get or release
	// any references.

	WaitForSingleObject(npInfo.hEvent, 0xffffffff);
	Sleep(0);
	CloseHandle(npInfo.hEvent);

	// close the thread handle
	CloseHandle(hThrd);
    }

    // cleanup the leftover objects.
    for (i=0; i<5; i++)
    {
	hres = CoDisconnectObject(punk[i], 0);
	TEST_FAILED_EXIT(FAILED(hres), "CoDisconnectObject failed\n")
	OUTPUT ("   - CoDisconnectObject OK.\n");
    }


// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    if (punkOut)
    {
	ulRefCnt = punkOut->Release();
	TEST_FAILED(ulRefCnt != 0, "punkOut RefCnt not zero\n");
    }

    if (punkIn)
    {
	ulRefCnt = punkIn->Release();
	TEST_FAILED(ulRefCnt != 0, "punkIn RefCnt not zero\n");
    }

    for (i=0; i<5; i++)
    {
	if (punk[i] != NULL)
	{
	    ulRefCnt = punk[i]->Release();
	    TEST_FAILED(ulRefCnt != 0, "punk[i] RefCnt not zero\n");
	}
    }

    return TestResult(RetVal, "TestNoPing");
}


// ----------------------------------------------------------------------
//
//  Thread SubRoutine for testing NOPING.
//
// ----------------------------------------------------------------------
DWORD _stdcall NoPingThread(void *param)
{
    BOOL    RetVal = TRUE;
    IUnknown *punk = NULL;
    ULONG	 i = 0;

    NoPingThreadInfo *npInfo = (NoPingThreadInfo *) param;
    OUTPUT ("   - NoPingThread Start\n");

    HRESULT hRes = CoInitializeEx(NULL, gInitFlag);
    TEST_FAILED(FAILED(hRes), "NoPingThread CoInitialize failed\n")

    // Create a shared memory stream for the marshaled interface
    IStream *pStm = CreateMemStm(600, NULL);
    if (pStm == NULL)
    {
	TEST_FAILED((pStm == NULL), "CreateMemStm failed\n")
	hRes = E_OUTOFMEMORY;
    }

    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    if (SUCCEEDED(hRes))
    {
	// unmarshal the interfaces
	for (i=0; i<6; i++)
	{

	    REFIID riid = (i==4) ? IID_IParseDisplayName : IID_IUnknown;

	    hRes = CoUnmarshalInterface(npInfo->pStm, riid, (void **)&punk);
	    TEST_FAILED(FAILED(hRes), "NoPingThread CoUnmarshalInterface failed\n")
	    OUTPUT("   - NoPingThread CoUnmarshalInterface done\n");

	    if (SUCCEEDED(hRes))
	    {
		if (i==3)
		{
		    // try remarshaling NOPING client as normal. Should end up
		    // as NOPING.

		    hRes = CoMarshalInterface(pStm, IID_IUnknown, punk,
					      0, 0, MSHLFLAGS_NORMAL);
		    TEST_FAILED(FAILED(hRes), "CoMarshalInterface failed\n")
		    OUTPUT ("   - CoMarshalInterface OK.\n");

		    // reset the stream seek ptr
		    hRes = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
		    TEST_FAILED(FAILED(hRes), "Seek on shared stream failed\n")

		    // verify the marshal format
		    hRes = VerifyOBJREFFormat(pStm, MSHLFLAGS_NOPING);
		    TEST_FAILED(FAILED(hRes), "VerifyOBJREFFormat failed\n")
		    OUTPUT ("   - VerifyOBJREFFormat OK.\n");
		}

		punk->Release();
		punk = NULL;
		OUTPUT("   - NoPingThread Release done\n");
	    }
	}

	// uninit OLE
	CoUninitialize();
    }

    if (pStm)
    {
	// release stream we created above
	pStm->Release();
    }

    OUTPUT ("   - NoPingThread Exit\n");
    npInfo->hr = hRes;
    SetEvent(npInfo->hEvent);
    return RetVal;
}


// ----------------------------------------------------------------------
//
//	test marshaling between apartments in the same process using
//	MSHLFLAGS_NORMAL, MSHLFLAGS_TABLEWEAK, and MSHLFLAGS_TABLESTRONG
//
// ----------------------------------------------------------------------
typedef struct tagCrossThreadCallInfo
{
    HANDLE  hEvent;
    IStream *pStm;
    DWORD   dwInitFlag;
    DWORD   dwThreadId;
    HRESULT hr;
} CrossThreadCallInfo;


DWORD _stdcall CrossThreadCalls(void *param);
DWORD _stdcall CrossThreadLoops(void *param);
DWORD _stdcall CrossThreadActivate(void *param);


BOOL TestCrossThread(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    LPSTREAM	    pStm = NULL;
    ULONG	    ulRefCnt, i, j;
    IUnknown	    *punk[3] = {NULL, NULL, NULL};
    IUnknown	    *pUnk;
    ILoop   *pLocalLoop = NULL;
    CrossThreadCallInfo ctInfo;
    DWORD	    dwThrdId = 0;
    HANDLE	    hThrd;
    DWORD	    mshlflags[3] = {MSHLFLAGS_NORMAL,
				    MSHLFLAGS_TABLEWEAK,
				    MSHLFLAGS_TABLESTRONG};

    DWORD	    dwInitFlags[4] = {COINIT_APARTMENTTHREADED,
				      COINIT_APARTMENTTHREADED,
				      COINIT_MULTITHREADED,
				      COINIT_MULTITHREADED};


    LARGE_INTEGER   large_int;
    LISet32(large_int, 0);

    OUTPUT ("Starting TestCrossThread\n");

    // Create a shared memory stream for the marshaled interface
    pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")

// ----------------------------------------------------------------------

    for (j=0; j<4; j++)
    {
	// reset the stream seek ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	// marshal an interface NORMAL, TABLEWEAK and TABLESTRONG
	// and unmarshal each in another apartment.

	for (i=0; i<3; i++)
	{
	    punk[i] = GetTestUnk();
	    TEST_FAILED_EXIT((punk[i] == NULL), "new CTestUnkCube failed\n")
	    VerifyObjRefCnt(punk[i], 1);

	    // Marshal the interface into the stream
	    hres = CoMarshalInterface(pStm, IID_ICube, punk[i],
				      0, 0, mshlflags[i]);

	    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	    OUTPUT ("   - CoMarshalInterface OK.\n");
	    VerifyRHRefCnt(punk[i], 1);
	}

	// reset the stream seek ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	for (i=0; i<3; i++)
	{
	    hres = VerifyOBJREFFormat(pStm, mshlflags[i]);
	    TEST_FAILED_EXIT(FAILED(hres), "VerifyOBJREFFormat failed\n")
	    OUTPUT ("   - VerifyOBJREFFormat OK.\n");
	}

	// reset the stream seek ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")


	// create thread and wait for it to complete
	ctInfo.hEvent	   = CreateEvent(NULL, FALSE, FALSE, NULL);
	ctInfo.pStm	   = pStm;
	ctInfo.dwInitFlag  = dwInitFlags[j];
	ctInfo.dwThreadId  = GetCurrentThreadId();
	ctInfo.hr	   = S_OK;

	RunThread(&ctInfo, ctInfo.hEvent, CrossThreadCalls);
	CloseHandle(ctInfo.hEvent);


	// cleanup the leftover objects.
	for (i=0; i<3; i++)
	{
	    hres = CoDisconnectObject(punk[i], 0);
	    punk[i] = NULL;
	    TEST_FAILED_EXIT(FAILED(hres), "CoDisconnectObject failed\n")
	    OUTPUT ("   - CoDisconnectObject OK.\n");
	}
    }

// ----------------------------------------------------------------------
    // Now test out doing activation from different apartments.
    // create thread and wait for it to complete

    for (j=0; j<2; j++)
    {
	ctInfo.hEvent	   = CreateEvent(NULL, FALSE, FALSE, NULL);
	ctInfo.pStm	   = NULL;
	ctInfo.dwInitFlag  = dwInitFlags[j];
	ctInfo.dwThreadId  = GetCurrentThreadId();
	ctInfo.hr	   = S_OK;

	RunThread(&ctInfo, ctInfo.hEvent, CrossThreadActivate);
	CloseHandle(ctInfo.hEvent);

	// create an interface
	hres = CoCreateInstance(CLSID_LoopSrv, NULL, CLSCTX_LOCAL_SERVER,
				IID_ILoop, (void **)&pLocalLoop);
	TEST_FAILED(FAILED(hres), "CoCreateInstance Second failed\n")

	if (SUCCEEDED(hres))
	{
	    pLocalLoop->Release();
	}
    }


// ----------------------------------------------------------------------

    // Now test doing nested calls between apartments.
#if 0
    for (j=0; j<2; j++)
    {
	// reset the stream seek ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")

	pUnk = GetTestUnk();
	TEST_FAILED_EXIT((pUnk == NULL), "new GetTestUnk failed\n")
	VerifyObjRefCnt(pUnk, 1);

	// Marshal the interface into the stream
	hres = CoMarshalInterface(pStm, IID_ILoop, pUnk,
				  0, 0, MSHLFLAGS_NORMAL);

	TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
	OUTPUT ("   - CoMarshalInterface OK.\n");
	VerifyRHRefCnt(pUnk, 1);

	// reset the stream seek ptr
	hres = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);
	TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")


	ctInfo.hEvent	   = CreateEvent(NULL, FALSE, FALSE, NULL);
	ctInfo.pStm	   = pStm;
	ctInfo.dwInitFlag  = dwInitFlags[j];
	ctInfo.dwThreadId  = GetCurrentThreadId();
	ctInfo.hr	   = S_OK;

	RunThread(&ctInfo, ctInfo.hEvent, CrossThreadLoops);
	CloseHandle(ctInfo.hEvent);

	pUnk->Release();
    }
#endif

// ----------------------------------------------------------------------

Cleanup:

    OUTPUT ("   - Test Complete. Doing Cleanup\n");

    //	Dump interfaces we are done with
    if (pStm)
    {
	ulRefCnt = pStm->Release();
	TEST_FAILED(ulRefCnt != 0, "Stream RefCnt not zero\n");
    }

    for (i=0; i<3; i++)
    {
	if (punk[i] != NULL)
	{
	    ulRefCnt = punk[i]->Release();
	    TEST_FAILED(ulRefCnt != 0, "punk[i] RefCnt not zero\n");
	}
    }

    return TestResult(RetVal, "TestCrossThread");
}


// ----------------------------------------------------------------------
//
//  Thread SubRoutine for testing CROSSTHREAD calls.
//
// ----------------------------------------------------------------------
DWORD _stdcall CrossThreadCalls(void *param)
{
    BOOL	 RetVal	= TRUE;
    ICube	*pCube	= NULL;
    IOleWindow	*pIOW	= NULL;
    IAdviseSink *pIAS	= NULL;
    ULONG	      i = 0;

    // get the execution parameters
    CrossThreadCallInfo *ctInfo = (CrossThreadCallInfo *) param;
    OUTPUT ("   - CrossThreadCalls Start\n");

    // initialize COM
    HRESULT hRes = CoInitializeEx(NULL, ctInfo->dwInitFlag);
    TEST_FAILED(FAILED(hRes), "CrossThreadCalls CoInitializeEx failed\n")

    if (SUCCEEDED(hRes))
    {
	// unmarshal the interfaces
	for (i=0; i<3; i++)
	{
	    hRes = CoUnmarshalInterface(ctInfo->pStm, IID_ICube, (void **)&pCube);
	    TEST_FAILED(FAILED(hRes), "CrossThread CoUnmarshalInterface failed\n")
	    OUTPUT("   - CrossThread CoUnmarshalInterface done\n");

	    if (SUCCEEDED(hRes))
	    {
		// test a synchronous method call between apartments
		// (also checks the lid & tid)

		UUID	lidCaller;
		CoGetCurrentLogicalThreadId(&lidCaller);
		hRes = pCube->SimpleCall(GetCurrentProcessId(),
					 GetCurrentThreadId(),
					 lidCaller);
		TEST_FAILED(FAILED(hRes), "pCube->SimpleCall failed\n")
		OUTPUT("   - Synchronous call done\n");

		// test an input-sync method call between apartments
		hRes = pCube->QueryInterface(IID_IOleWindow, (void **)&pIOW);

		if (SUCCEEDED(hRes))
		{
		    HWND hWnd;
		    hRes = pIOW->GetWindow(&hWnd);

		    // input sync is only allowed between two apartment
		    // threaded apartments.
		    if (ctInfo->dwInitFlag == gInitFlag)
		    {
			TEST_FAILED(FAILED(hRes), "pIOW->GetWindow failed\n");
		    }
		    else
		    {
			TEST_FAILED(SUCCEEDED(hRes), "pIOW->GetWindow should have failed\n");
		    }

		    pIOW->Release();
		    OUTPUT("   - Input-Synchronous call done\n");
		}


		// test an async method call between apartments
		hRes = pCube->QueryInterface(IID_IAdviseSink, (void **)&pIAS);

		if (SUCCEEDED(hRes))
		{
		    // no return code to check
		    pIAS->OnViewChange(1,2);
		    pIAS->Release();
		    OUTPUT("   - ASynchronous call done\n");
		}

		// release the object
		pCube->Release();
		pCube = NULL;
		OUTPUT("   - CrossThread Calls and Release done\n");
	    }
	}

	// uninit OLE
	CoUninitialize();
    }

    OUTPUT ("   - CrossThreadCalls Exit\n");
    ctInfo->hr = hRes;

    // signal the other thread we are done.
    if (gInitFlag == COINIT_APARTMENTTHREADED)
    {
	PostThreadMessage(ctInfo->dwThreadId, WM_QUIT, 0, 0);
    }
    else
    {
	SetEvent(ctInfo->hEvent);
    }

    return hRes;
}


// ----------------------------------------------------------------------
//
//  Thread SubRoutine for testing CROSSTHREAD activation
//
// ----------------------------------------------------------------------
DWORD _stdcall CrossThreadActivate(void *param)
{
    BOOL	 RetVal	= TRUE;
    ILoop   *pLocalLoop = NULL;

    // get the execution parameters
    CrossThreadCallInfo *ctInfo = (CrossThreadCallInfo *) param;
    OUTPUT ("   - CrossThreadActivate Start\n");

    // initialize COM
    HRESULT hRes = CoInitializeEx(NULL, ctInfo->dwInitFlag);
    TEST_FAILED(FAILED(hRes), "CrossThreadActivate CoInitializeEx failed\n")

    if (SUCCEEDED(hRes))
    {
	// create an interface
	hRes = CoCreateInstance(CLSID_LoopSrv, NULL, CLSCTX_LOCAL_SERVER,
				IID_ILoop, (void **)&pLocalLoop);
	TEST_FAILED(FAILED(hRes), "CoCreateInstance First failed\n")

	if (SUCCEEDED(hRes))
	{
	    pLocalLoop->Release();
	}

	// uninit OLE
	CoUninitialize();
    }

    OUTPUT ("   - CrossThreadActivate Exit\n");
    ctInfo->hr = hRes;

    // signal the other thread we are done.
    if (gInitFlag == COINIT_APARTMENTTHREADED)
    {
	PostThreadMessage(ctInfo->dwThreadId, WM_QUIT, 0, 0);
    }
    else
    {
	SetEvent(ctInfo->hEvent);
    }

    return hRes;
}








#if 0
// ----------------------------------------------------------------------
//
//  Thread SubRoutine for testing CROSSTHREAD calls.
//
// ----------------------------------------------------------------------
DWORD _stdcall CrossThreadLoops(void *param)
{
    BOOL	 RetVal	= TRUE;
    ILoop	*pLoop	= NULL;
    IUnknown	*punk	= NULL;
    ILoop	*pLoopLocal = NULL;

    // get the execution parameters
    CrossThreadCallInfo *ctInfo = (CrossThreadCallInfo *) param;
    OUTPUT ("   - CrossThreadLoops Start\n");

    // initialize COM
    HRESULT hRes = CoInitializeEx(NULL, ctInfo->dwInitFlag);
    TEST_FAILED(FAILED(hRes), "CrossThreadLoops CoInitializeEx failed\n")

    if (SUCCEEDED(hRes))
    {
	punk = GetTestUnk();
	punk->QueryInterface(IID_ILoop, (void **)&pLoopLocal);
	punk->Release();

	// unmarshal the interface
	hRes = CoUnmarshalInterface(ctInfo->pStm, IID_ILoop, (void **)&pLoop);
	TEST_FAILED(FAILED(hRes), "CrossThreadLoop CoUnmarshalInterface failed\n")
	OUTPUT("   - CrossThreadLoop CoUnmarshalInterface done\n");

	if (SUCCEEDED(hRes))
	{
	    // test nested synchronous method calls between apartments

	    hRes = pLoop->Init(pLoopLocal);
	    TEST_FAILED(FAILED(hRes), "pLoop->Init failed\n")

	    if (SUCCEEDED(hRes))
	    {
		hRes = pLoop->Loop(5);
		TEST_FAILED(FAILED(hRes), "pLoop->Loop failed\n")

		hRes = pLoop->Uninit();
		TEST_FAILED(FAILED(hRes), "pLoop->Uninit failed\n")
	    }

	    pLoop->Release();
	    pLoop = NULL;

	    OUTPUT("   - CrossThreadLoop Calls and Release done\n");
	}

	// uninit OLE
	CoUninitialize();
    }

    OUTPUT ("   - CrossThreadLoops Exit\n");
    ctInfo->hr = hRes;

    // signal the other thread we are done.
    if (gInitFlag == COINIT_APARTMENTTHREADED)
    {
	PostThreadMessage(ctInfo->dwThreadId, WM_QUIT, 0, 0);
    }
    else
    {
	SetEvent(ctInfo->hEvent);
    }

    return hRes;
}
#endif



// ----------------------------------------------------------------------
//
//  Test calling CoGetPSClsid and CoRegisterPSClsid
//
// ----------------------------------------------------------------------
BOOL TestPSClsid(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes;
    CLSID	    clsidOriginal, clsidNew;

    OUTPUT ("Starting TestPSClsid\n");

// ----------------------------------------------------------------------

    // get the PSClsid that is currently registered for this interface.

    hRes = CoGetPSClsid(IID_IViewObject, &clsidOriginal);
    TEST_FAILED(FAILED(hRes), "Failed 1st CoGetPSClsid\n");
    OUTPUT ("    - Done 1st CoGetPSClsid\n");

    // Set a new PSClsid for this interface for this process. Note that
    // if we have used the interface before, we will get an error back,
    // otherwise, this will succeed.

    hRes = CoRegisterPSClsid(IID_IViewObject, CLSID_Balls);
    TEST_FAILED(FAILED(hRes), "Failed 1st CoGRegisterPSClsid\n");
    OUTPUT ("    - Done 1st CoRegisterPSClsid\n");

    // now get the PSClsid that is registered for this interface. This
    // should match the value we just passed in.

    hRes = CoGetPSClsid(IID_IViewObject, &clsidNew);
    TEST_FAILED(FAILED(hRes), "Failed 2nd CoGetPSClsid\n");
    OUTPUT ("    - Done 2nd CoGetPSClsid\n");

    if (memcmp(&clsidNew, &CLSID_Balls, sizeof(CLSID)))
    {
	TEST_FAILED(TRUE, "Failed Compare of CLSIDs\n");
    }

    // now try to register it again. This should fail since it has
    // already been registered.

    hRes = CoRegisterPSClsid(IID_IViewObject, clsidOriginal);
    TEST_FAILED(FAILED(hRes), "Failed 2nd CoGRegisterPSClsid\n");
    OUTPUT ("    - Done 2nd CoRegisterPSClsid\n");

    // now get the PSClsid that is registered for this interface. This
    // should match the value we just passed in.

    hRes = CoGetPSClsid(IID_IViewObject, &clsidNew);
    TEST_FAILED(FAILED(hRes), "Failed 3rd CoGetPSClsid\n");
    OUTPUT ("    - Done 3rd CoGetPSClsid\n");

    if (memcmp(&clsidNew, &clsidOriginal, sizeof(CLSID)))
    {
	TEST_FAILED(TRUE, "Failed 2nd Compare of CLSIDs\n");
    }

// ----------------------------------------------------------------------

    OUTPUT ("   - Test Complete. Doing Cleanup\n");
    return TestResult(RetVal, "TestPSClsid");
}

// ----------------------------------------------------------------------
//
//  Test calling CoGetPSClsid for a LONG IID/PSCLSID pair.
//
// ----------------------------------------------------------------------
BOOL TestPSClsid2(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hRes = S_OK;
    CLSID	    clsidOriginal;

    OUTPUT ("Starting TestPSClsid2\n");

// ----------------------------------------------------------------------

    // get the PSClsid that is currently registered for this interface.
    hRes = CoGetPSClsid(IID_IViewObject, &clsidOriginal);
    TEST_FAILED(FAILED(hRes), "Failed 1st CoGetPSClsid\n");
    OUTPUT ("    - Done 1st CoGetPSClsid\n");

    if (!IsEqualGUID(clsidOriginal, CLSID_OLEPSFACTORY))
    {
	TEST_FAILED(FAILED(hRes), "CoGetPSClsid returned wrong value\n");
    }

// ----------------------------------------------------------------------

    OUTPUT ("   - Test Complete. Doing Cleanup\n");
    return TestResult(RetVal, "TestPSClsid2");
}



// ----------------------------------------------------------------------
//
//  TestGetIIDFromMI
//
// ----------------------------------------------------------------------
BOOL TestGetIIDFromMI(void)
{
    BOOL	    RetVal = TRUE;
    HRESULT	    hres;
    IUnknown	   *punkIn = NULL;
    IID 	    iid;

    OUTPUT ("Starting TestGetIIDFromMI\n");

// ----------------------------------------------------------------------

    ULARGE_INTEGER ulSeekEnd;
    LARGE_INTEGER lSeekStart;
    LISet32(lSeekStart, 0);

    IStream *pStm = CreateMemStm(600, NULL);
    TEST_FAILED_EXIT((pStm == NULL), "CreateMemStm failed\n")
    VerifyObjRefCnt((IUnknown *)pStm, 1);

    punkIn = GetTestUnk();

    hres = CoMarshalInterface(pStm, IID_IUnknown, punkIn, 0, NULL, MSHLFLAGS_NORMAL);
    TEST_FAILED_EXIT(FAILED(hres), "CoMarshalInterface failed\n")
    OUTPUT ("   - CoMarshalInterface OK\n");

    // go back to begining
    hres = pStm->Seek(lSeekStart, STREAM_SEEK_SET, NULL);
    TEST_FAILED_EXIT(FAILED(hres), "Seek on shared stream failed\n")
    OUTPUT ("   - Seek Start OK\n");

#if 0	// BUGBUG: RICKHI
    // get the IID from the stream, and ensure it matches the IID we
    // marshaled. Also, ensure the stream is left where it was. This
    // is accomplished by calling CRMD on the stream.

    hres = CoGetIIDFromMarshaledInterface(pStm, &iid);
    TEST_FAILED(FAILED(hres), "CoGetIIDFromMarshaledInterface failed\n")
    OUTPUT ("   - CoGetIIDFromMarshaledInterface Done\n");

    if (!IsEqualIID(IID_IUnknown, iid))
    {
	TEST_FAILED(TRUE, "IID read does not match IID marshaled\n")
    }
#endif
    // release the marshaled interface
    hres = CoReleaseMarshalData(pStm);
    TEST_FAILED(FAILED(hres), "CoReleaseMarshalData failed\n")
    OUTPUT ("   - CoReleaseMarshalData Done\n");

// ----------------------------------------------------------------------
Cleanup:

    if (punkIn)
    {
	punkIn->Release();
	punkIn = NULL;
    }

    OUTPUT ("   - Test Complete. Doing Cleanup\n");
    return TestResult(RetVal, "TestGetIIDFromMI");
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\tmarshal\tunk.cxx ===
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <tunk.h>


CTestUnk::CTestUnk(void) : _cRefs(1)
{
}

CTestUnk::~CTestUnk(void)
{
}


STDMETHODIMP CTestUnk::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hRslt = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IParseDisplayName))
    {
	*ppvObj = (void *)(IParseDisplayName *)this;
	AddRef();
    }
    else if (IsEqualIID(riid, IID_ICube))
    {
	*ppvObj = (void *) new CTestUnkCube((IUnknown *)(IParseDisplayName *)this);
	if (*ppvObj == NULL)
	{
	    hRslt = E_NOINTERFACE;
	}
    }
    else if (IsEqualIID(riid, IID_IOleWindow))
    {
	*ppvObj = (void *)(IOleWindow *)this;
	AddRef();
    }
    else if (IsEqualIID(riid, IID_IAdviseSink))
    {
	*ppvObj = (void *)(IAdviseSink *)this;
	AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hRslt = E_NOINTERFACE;
    }

    return  hRslt;
}



STDMETHODIMP_(ULONG) CTestUnk::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}


STDMETHODIMP_(ULONG) CTestUnk::Release(void)
{
    _cRefs--;
    if (_cRefs == 0)
    {
	delete this;
	return 0;
    }
    else
    {
	return _cRefs;
    }
}


STDMETHODIMP CTestUnk::ParseDisplayName(LPBC pbc, LPOLESTR lpszDisplayName,
					ULONG *pchEaten, LPMONIKER *ppmkOut)
{
    return  S_OK;
}

STDMETHODIMP CTestUnk::GetWindow(HWND *phwnd)
{
    *phwnd = NULL;
    return S_OK;
}

STDMETHODIMP CTestUnk::ContextSensitiveHelp(BOOL fEnterMode)
{
    return S_OK;
}

STDMETHODIMP_(void) CTestUnk::OnDataChange(FORMATETC *pFormatetc,
					   STGMEDIUM *pStgmed)
{
    return;
}

STDMETHODIMP_(void) CTestUnk::OnViewChange(DWORD dwAspect,
					   LONG lindex)
{
    return;
}

STDMETHODIMP_(void) CTestUnk::OnRename(IMoniker *pmk)
{
    return;
}

STDMETHODIMP_(void) CTestUnk::OnSave()
{
    return;
}

STDMETHODIMP_(void) CTestUnk::OnClose()
{
    return;
}



CTestUnkCube::CTestUnkCube(IUnknown *pUnkCtrl) :
    _cRefs(1),
    _pUnkCtrl(pUnkCtrl),
    _pUnkIn(NULL)
{
    _pUnkCtrl->AddRef();
}

CTestUnkCube::~CTestUnkCube(void)
{
    _pUnkCtrl->Release();
}


STDMETHODIMP CTestUnkCube::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    return  _pUnkCtrl->QueryInterface(riid, ppvObj);
}



STDMETHODIMP_(ULONG) CTestUnkCube::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}


STDMETHODIMP_(ULONG) CTestUnkCube::Release(void)
{
    _cRefs--;
    if (_cRefs == 0)
    {
	delete this;
	return 0;
    }
    else
    {
	return _cRefs;
    }
}


// these methods dont really have to do anything, we are just testing that
// they are callable.

STDMETHODIMP CTestUnkCube::MoveCube(ULONG xPos, ULONG yPos)
{
    if (_cRefs > 0)
	return S_OK;

    return E_UNEXPECTED;
}

STDMETHODIMP CTestUnkCube::GetCubePos(ULONG *xPos, ULONG *yPos)
{
    if (_cRefs > 0)
	return S_OK;

    return E_UNEXPECTED;
}

STDMETHODIMP CTestUnkCube::Contains(IBalls *pIFDb)
{
    if (_cRefs > 0)
	return S_OK;

    return E_UNEXPECTED;
}

STDMETHODIMP CTestUnkCube::SimpleCall(DWORD pidCaller, DWORD tidCaller, GUID lidCaller)
{
    HRESULT hr = S_OK;

    GUID lid;
    HRESULT hr2 = CoGetCurrentLogicalThreadId(&lid);

    if (SUCCEEDED(hr2))
    {
	if (!IsEqualGUID(lid, lidCaller))
	{
	    // LIDs dont match, error
	    hr |= 0x80000001;
	}
    }
    else
    {
	return hr2;
    }

    DWORD tid;
    hr2 = CoGetCallerTID(&tid);

    if (SUCCEEDED(hr2))
    {
	if (pidCaller == GetCurrentProcessId())
	{
	    // if in same process, CoGetCallerTID should return S_OK
	    if (hr2 != S_OK)
	    {
		hr |= 0x80000002;
	    }
	}
	else
	{
	    // if in different process, CoGetCallerTID should return S_FALSE
	    if (hr2 != S_FALSE)
	    {
		hr |= 0x80000004;
	    }
	}
    }
    else
    {
	return hr2;
    }

    return hr;
}

STDMETHODIMP CTestUnkCube::PrepForInputSyncCall(IUnknown *pUnkIn)
{
    // just remember the input ptr

    _pUnkIn = pUnkIn;
    _pUnkIn->AddRef();

    return S_OK;
}

STDMETHODIMP CTestUnkCube::InputSyncCall()
{
    // just attempt to release an Interface Pointer inside an InputSync
    // method.

    if (_pUnkIn)
    {
	if (_pUnkIn->Release() != 0)
	    return  RPC_E_CANTCALLOUT_ININPUTSYNCCALL;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:	CTestUnkCF::CTestUnkCF, public
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
CTestUnkCF::CTestUnkCF()
{
    _cRefs = 1;
}

//+-------------------------------------------------------------------
//
//  Member:	CTestUnkCF::QueryInterface, public
//
//  Algorithm:	if the interface is not one implemented by us,
//		pass the request to the proxy manager
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CTestUnkCF::QueryInterface(REFIID riid, void **ppUnk)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IClassFactory))
    {
	*ppUnk = (void *)(IClassFactory *) this;
	AddRef();
	return S_OK;
    }

    *ppUnk = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CTestUnkCF::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}


STDMETHODIMP_(ULONG) CTestUnkCF::Release(void)
{
    _cRefs--;
    if (_cRefs == 0)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:	CTestUnkCF::CreateInstance, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CTestUnkCF::CreateInstance(IUnknown *punkOuter,
					       REFIID	riid,
					       void	**ppunkObject)
{
    SCODE sc = E_OUTOFMEMORY;
    *ppunkObject = NULL;	//  in case of failure

    // create an instance object.
    IUnknown *punk = (IUnknown *)(IParseDisplayName *) new CTestUnk();

    if (punk)
    {
	// get the interface the caller wants to use
	sc = punk->QueryInterface(riid, ppunkObject);

	// release our hold, since the QI got a hold for the client.
	punk->Release();
    }

    return  sc;
}

//+-------------------------------------------------------------------
//
//  Member:	CTestUnkCF::LockServer, public
//
//  Synopsis:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CTestUnkCF::LockServer(BOOL fLock)
{
    return  S_OK;
}



CTestUnkMarshal::CTestUnkMarshal(void) : _cRefs(1), _pIM(NULL)
{
}

CTestUnkMarshal::~CTestUnkMarshal(void)
{
    if (_pIM)
    {
	_pIM->Release();
    }
}

STDMETHODIMP CTestUnkMarshal::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hRslt = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IMarshal))
    {
	*ppvObj = (void *)(IMarshal *)this;
	AddRef();
    }
    else
    {
	*ppvObj = NULL;
	hRslt = E_NOINTERFACE;
    }

    return  hRslt;
}

STDMETHODIMP_(ULONG) CTestUnkMarshal::AddRef(void)
{
    _cRefs++;
    return _cRefs;
}

STDMETHODIMP_(ULONG) CTestUnkMarshal::Release(void)
{
    _cRefs--;
    if (_cRefs == 0)
    {
	delete this;
	return 0;
    }
    else
    {
	return _cRefs;
    }
}

STDMETHODIMP CTestUnkMarshal::GetUnmarshalClass(REFIID riid, LPVOID pv,
	DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags, LPCLSID pClsid)
{
    if (GetStdMarshal() == NULL)
	return E_OUTOFMEMORY;

    return _pIM->GetUnmarshalClass(riid, pv, dwDestCtx, pvDestCtx,
				   (mshlflags | MSHLFLAGS_NOPING), pClsid);
}

STDMETHODIMP CTestUnkMarshal::GetMarshalSizeMax(REFIID riid, LPVOID pv,
	DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags, LPDWORD pSize)
{
    if (GetStdMarshal() == NULL)
	return E_OUTOFMEMORY;

    return _pIM->GetMarshalSizeMax(riid, pv, dwDestCtx, pvDestCtx,
		   (mshlflags | MSHLFLAGS_NOPING), pSize);
}

STDMETHODIMP CTestUnkMarshal::MarshalInterface(LPSTREAM pStm, REFIID riid,
	LPVOID pv,  DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags)
{
    if (GetStdMarshal() == NULL)
	return E_OUTOFMEMORY;

    return _pIM->MarshalInterface(pStm, riid, pv, dwDestCtx, pvDestCtx,
		   (mshlflags | MSHLFLAGS_NOPING));
}

STDMETHODIMP CTestUnkMarshal::UnmarshalInterface(LPSTREAM pStm, REFIID riid,
	LPVOID *ppv)
{
    return CoUnmarshalInterface(pStm, riid, ppv);
}

STDMETHODIMP CTestUnkMarshal::ReleaseMarshalData(LPSTREAM pStm)
{
    return CoReleaseMarshalData(pStm);
}

STDMETHODIMP CTestUnkMarshal::DisconnectObject(DWORD dwReserved)
{
    if (GetStdMarshal() == NULL)
	return E_OUTOFMEMORY;

    return _pIM->DisconnectObject(dwReserved);
}

IMarshal *CTestUnkMarshal::GetStdMarshal(void)
{
    if (_pIM == NULL)
    {
	HRESULT hr = CoGetStandardMarshal(IID_IUnknown, (IUnknown *)this, 0,
		    0, MSHLFLAGS_NOPING, &_pIM);
    }

    return _pIM;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\tmarshal\objref.cxx ===
#include <windows.h>
#include <ole2.h>
#include <stdio.h>
#include <malloc.h>	// _alloca
#include <obase.h>	// def'n of OBJREF

//-------------------------------------------------------------------------

// convenient mappings
#define ORCST(objref)	 objref.u_objref.u_custom
#define ORSTD(objref)	 objref.u_objref.u_standard
#define ORHDL(objref)	 objref.u_objref.u_handler


// bits that must be zero in the flags fields
#define OBJREF_RSRVD_MBZ ~(OBJREF_STANDARD | OBJREF_HANDLER | OBJREF_CUSTOM)

#define SORF_RSRVD_MBZ	 ~(SORF_NOPING | SORF_OXRES1 | SORF_OXRES2 |   \
			   SORF_OXRES3 | SORF_OXRES4 | SORF_OXRES5 |   \
			   SORF_OXRES6 | SORF_OXRES7 | SORF_OXRES8)


// Internal Uses of the reserved SORF_OXRES flags.

// SORF_TBLWEAK is needed so that RMD works correctly on TABLEWEAK
// marshaling, so it is ignored by unmarshalers. Therefore, we use one of
// the bits reserved for the object exporter that must be ignored by
// unmarshalers.
//
// SORF_WEAKREF is needed for container weak references, when handling
// an IRemUnknown::RemQueryInterface on a weak interface. This is a strictly
// local (windows) machine protocol, so we use a reserved bit.
//
// SORF_NONNDR is needed for interop of 16bit custom (non-NDR) marshalers
// with 32bit, since the 32bit guys want to use MIDL (NDR) to talk to other
// 32bit processes and remote processes, but the custom (non-NDR) format to
// talk to local 16bit guys. In particular, this is to support OLE Automation.
//
// SORF_FREETHREADED is needed when we create a proxy to the SCM interface
// in the apartment model. All apartments can use the same proxy so we avoid
// the test for calling on the correct thread.

#define SORF_TBLWEAK	  SORF_OXRES1 // (table) weak reference
#define SORF_WEAKREF	  SORF_OXRES2 // (normal) weak reference
#define SORF_NONNDR	  SORF_OXRES3 // stub does not use NDR marshaling
#define SORF_FREETHREADED SORF_OXRES4 // proxy may be used on any thread


// definition to simplify coding
const DWORD MSHLFLAGS_TABLE = MSHLFLAGS_TABLESTRONG | MSHLFLAGS_TABLEWEAK;

const DWORD MSHLFLAGS_USER_MASK = MSHLFLAGS_NORMAL | MSHLFLAGS_TABLE |
                                  MSHLFLAGS_NOPING;


// return codes
#define INVALID_SORFFLAG 90000001
#define INVALID_REFCNT	 90000002
#define INVALID_MSHLFLAG 90000003

//-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Function:   StRead
//
//  Synopsis:   Stream read that only succeeds if all requested bytes read
//
//  Arguments:  [pStm]     -- source stream
//              [pvBuffer] -- destination buffer
//              [ulcb]     -- bytes to read
//
//  Returns:    S_OK if successful, else error code
//
//--------------------------------------------------------------------------
HRESULT StRead(IStream *pStm, void *pvBuffer, ULONG ulcb)
{
    ULONG cbRead;
    HRESULT hr = pStm->Read(pvBuffer, ulcb, &cbRead);

    if (SUCCEEDED(hr))
    {
	if (ulcb != cbRead)
        {
	    hr = STG_E_READFAULT;
	}
    }

    return hr;
}

void DbgDumpSTD(STDOBJREF *pStd)
{

}

//+-------------------------------------------------------------------------
//
//  Function:	ReadObjRef
//
//  Synopsis:	Reads an OBJREF from the stream
//
//  Arguments:	[pStm]	 -- source stream
//		[objref] -- destination buffer
//
//  Returns:    S_OK if successful, else error code
//
//--------------------------------------------------------------------------
HRESULT ReadObjRef(IStream *pStm, OBJREF &objref, STDOBJREF **ppStd)
{
    HRESULT hr = StRead(pStm, &objref, 2*sizeof(ULONG)+sizeof(IID));

    if (SUCCEEDED(hr))
    {
	if ((objref.signature != OBJREF_SIGNATURE) ||
	    (objref.flags & OBJREF_RSRVD_MBZ)	   ||
	    (objref.flags == 0))
	{
	    // the objref signature is bad, or one of the reserved
	    // bits in the flags is set, or none of the required bits
	    // in the flags is set. the objref cant be interpreted so
	    // fail the call.

	    return E_UNEXPECTED;	// BUGBUG:
	}

	// compute the size of the remainder of the objref and
	// include the size fields for the resolver string array

	STDOBJREF	*pStd = &ORSTD(objref).std;
	DUALSTRINGARRAY *psa;
	ULONG		cbToRead;

	if (objref.flags & OBJREF_STANDARD)
	{
	    cbToRead = sizeof(STDOBJREF) + sizeof(ULONG);
	    psa = &ORSTD(objref).saResAddr;
	}
	else if (objref.flags & OBJREF_HANDLER)
	{
	    cbToRead = sizeof(STDOBJREF) + sizeof(CLSID) + sizeof(ULONG);
	    psa = &ORHDL(objref).saResAddr;
	}
	else if (objref.flags & OBJREF_CUSTOM)
	{
	    cbToRead = sizeof(CLSID) + sizeof(DWORD);	// clsid + data size
	    psa = NULL;
	}

	// return ptr to STDOBJREF
	*ppStd = pStd;

	// read the rest of the (fixed sized) objref from the stream
	hr = StRead(pStm, pStd, cbToRead);

	if (SUCCEEDED(hr) && psa)
	{
	    // Non custom interface. Make sure the resolver string array
	    // has some sensible values.

	    if (psa->wSecurityOffset >= psa->wNumEntries)
	    {
		hr = E_UNEXPECTED;  // BUGBUG: correct return code
	    }
	}

	if (SUCCEEDED(hr) && psa)
	{
	    // Non custom interface. The data that follows is a variable
	    // sized string array. Allocate memory for it and then read it.

	    DbgDumpSTD(pStd);

	    cbToRead = psa->wNumEntries * sizeof(WCHAR);

	    DUALSTRINGARRAY *psaNew = (DUALSTRINGARRAY *) _alloca(cbToRead +
							     sizeof(ULONG));
	    if (psaNew != NULL)
	    {
		// update the size fields and read in the rest of the data
		psaNew->wSecurityOffset = psa->wSecurityOffset;
		psaNew->wNumEntries = psa->wNumEntries;

		hr = StRead(pStm, psaNew->aStringArray, cbToRead);
	    }
	    else
	    {
		psa->wNumEntries     = 0;
		psa->wSecurityOffset = 0;
		hr = E_OUTOFMEMORY;

		// seek the stream past what we should have read, ignore
		// seek errors, since the OOM takes precedence.

		LARGE_INTEGER libMove;
		libMove.LowPart  = cbToRead;
		libMove.HighPart = 0;
		pStm->Seek(libMove, STREAM_SEEK_CUR, 0);
	    }
	}
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:	VerifyOBJREFFormat
//
//  Synopsis:	Checks the format of the marshal packet
//
//  Arguments:	[pStm]	    -- source stream
//		[mshlflags] -- destination buffer
//
//  Returns:    S_OK if successful, else error code
//
//--------------------------------------------------------------------------
HRESULT VerifyOBJREFFormat(IStream *pStm, DWORD mshlflags)
{
    OBJREF     objref;
    STDOBJREF *pStd;
    HRESULT hr = ReadObjRef(pStm, objref, &pStd);

    // now verify the format
    if (SUCCEEDED(hr))
    {
	if (mshlflags & MSHLFLAGS_NOPING)
	{
	    // SORF_NOPING should be set (unless previously marshaled PING)
	    if (!(pStd->flags & SORF_NOPING))
		return INVALID_SORFFLAG;
	}

	if ((mshlflags & MSHLFLAGS_TABLE) == MSHLFLAGS_NORMAL)
	{
	    // refcnt should be non-zero
	    if (pStd->cPublicRefs == 0)
		return INVALID_REFCNT;

	    // table flags should not be set
	    if (pStd->flags & (SORF_WEAKREF | SORF_TBLWEAK))
		return INVALID_SORFFLAG;
	}
	else if ((mshlflags & MSHLFLAGS_TABLE) == MSHLFLAGS_TABLESTRONG)
	{
	    // refcnt should be zero
	    if (pStd->cPublicRefs != 0)
		return INVALID_REFCNT;

	}
	else if ((mshlflags & MSHLFLAGS_TABLE) == MSHLFLAGS_TABLEWEAK)
	{
	    // refcnt should be zero
	    if (pStd->cPublicRefs != 0)
		return INVALID_REFCNT;

	    // SORF_TBLWEAK should be set
	    if (!(pStd->flags & SORF_TBLWEAK))
		return INVALID_SORFFLAG;
	}
	else
	{
	    // unknown flags
	    return INVALID_MSHLFLAG;
	}
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\client\tmarshal\tunk.h ===
#ifndef _TUNK_
#define _TUNK_

STDAPI CoGetCallerTID(DWORD *pTIDCaller);
STDAPI CoGetCurrentLogicalThreadId(GUID *pguid);

#include <icube.h>

class	CTestUnk : public IParseDisplayName, public IOleWindow,
		   public IAdviseSink
{
public:
    CTestUnk(void);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID iid, void FAR * FAR * ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //	IParseDisplayName
    STDMETHODIMP ParseDisplayName(LPBC pbc, LPOLESTR lpszDisplayName,
				  ULONG *pchEaten, LPMONIKER *ppmkOut);

    // IOleWinodw methods
    STDMETHODIMP GetWindow(HWND *phwnd);
    STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);


    // IAdviseSink
    STDMETHOD_(void, OnDataChange)(FORMATETC *pFormatetc,
				   STGMEDIUM *pStgmed);
    STDMETHOD_(void, OnViewChange)(DWORD dwAspect,
				   LONG lindex);
    STDMETHOD_(void, OnRename)(IMoniker *pmk);
    STDMETHOD_(void, OnSave)();
    STDMETHOD_(void, OnClose)();

private:

    ~CTestUnk(void);

    ULONG   _cRefs;
};


// A new instance of this object gets created each time the caller
// does a QI for ICube on the CTestUnk object above (or on the ICube
// interface iteself). The reason for this is to test that the remoting
// layer supports this capability correctly.

class	CTestUnkCube : public ICube
{
public:
    CTestUnkCube(IUnknown *pUnkCtrl);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // ICube implementation
    STDMETHODIMP MoveCube(ULONG xPos, ULONG yPos);
    STDMETHODIMP GetCubePos(ULONG *xPos, ULONG *yPos);
    STDMETHODIMP Contains(IBalls *pIFDb);
    STDMETHODIMP SimpleCall(DWORD pid, DWORD tid, GUID lidCaller);
    STDMETHODIMP PrepForInputSyncCall(IUnknown *pUnkIn);
    STDMETHODIMP InputSyncCall();

private:

    ~CTestUnkCube(void);

    ULONG     _cRefs;
    IUnknown *_pUnkCtrl;
    IUnknown *_pUnkIn;
};


class CTestUnkCF : public IClassFactory
{
public:
    CTestUnkCF(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHOD(CreateInstance)(IUnknown	*punkOuter,
			      REFIID	riid,
			      void	**ppunkObject);
    STDMETHOD(LockServer)(BOOL fLock);

private:
    ULONG    _cRefs;
};


class	CTestUnkMarshal : public IMarshal
{
public:
    CTestUnkMarshal(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID iid, void FAR * FAR * ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IMarshal - IUnknown taken from derived classes
    STDMETHOD(GetUnmarshalClass)(REFIID riid, LPVOID pv, DWORD dwDestCtx,
			LPVOID pvDestCtx, DWORD mshlflags, LPCLSID pClsid);
    STDMETHOD(GetMarshalSizeMax)(REFIID riid, LPVOID pv, DWORD dwDestCtx,
			LPVOID pvDestCtx, DWORD mshlflags, LPDWORD pSize);
    STDMETHOD(MarshalInterface)(LPSTREAM pStm, REFIID riid, LPVOID pv,
			DWORD dwDestCtx, LPVOID pvDestCtx, DWORD mshlflags);
    STDMETHOD(UnmarshalInterface)(LPSTREAM pStm, REFIID riid, LPVOID *ppv);
    STDMETHOD(ReleaseMarshalData)(LPSTREAM pStm);
    STDMETHOD(DisconnectObject)(DWORD dwReserved);

private:

    IMarshal *GetStdMarshal(void);
    ~CTestUnkMarshal(void);

    ULONG	_cRefs;
    IMarshal   *_pIM;
};

#endif	//  _TUNK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\advbnd.cxx ===
//+-------------------------------------------------------------------
//
//  Class:    CAdvBndCF
//
//  Synopsis: Class Factory for CAdvBnd
//
//  Interfaces:  IUnknown      - QueryInterface, AddRef, Release
//               IClassFactory - CreateInstance
//
//  History:  21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <advbnd.hxx>


const GUID CLSID_AdvBnd =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x48}};


//+-------------------------------------------------------------------
//
//  Member:	CAdvBndCF::CAdvBndCF()
//
//  Synopsis:	The constructor for CAdvBnd.
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBndCF::CAdvBndCF() : _cRefs(1), _pCF(NULL)
{
    return;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::~CAdvBndObj()
//
//  Synopsis:	The destructor for CAdvBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBndCF::~CAdvBndCF()
{
    if (_pCF)
    {
	_pCF->Release();
    }
    return;
}


//+-------------------------------------------------------------------
//
//  Method:	CAdvBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBndCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) ||
	IsEqualIID(iid, IID_IClassFactory))
    {
	*ppv = (IUnknown *) this;
	AddRef();
	return S_OK;
    }
    else
    {
        *ppv = NULL;
	return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CAdvBndCF::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CAdvBndCF::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
    }

    return _cRefs;
}



//+-------------------------------------------------------------------
//
//  Method:	CAdvBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object
//
//--------------------------------------------------------------------

STDMETHODIMP CAdvBndCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    Display(TEXT("CAdvBndCF::CreateInstance called\n"));

    HRESULT hresult;

    if (!_pCF)
    {
	// Load the class object for the class to aggregate.
	hresult = CoGetClassObject(CLSID_BasicBnd, CLSCTX_SERVER, NULL,
				   IID_IClassFactory, (void **) &_pCF);

	Win4Assert(SUCCEEDED(hresult)
	    && "CAdvBnd::CAdvBnd CoGetClassObject failed");

	if (FAILED(hresult))
	{
	    return hresult;
	}
    }

    if (pUnkOuter != NULL)
    {
	return E_FAIL;
    }

    CAdvBnd * lpcBB = new FAR CAdvBnd((IClassFactory *) _pCF);

    if (lpcBB == NULL)
    {
	return E_OUTOFMEMORY;
    }

    hresult = lpcBB->QueryInterface(iidInterface, ppv);

    lpcBB->Release();

    return hresult;
}

STDMETHODIMP CAdvBndCF::LockServer(BOOL fLock)
{
    if (fLock)
	GlobalRefs(TRUE);
    else
	GlobalRefs(FALSE);

    return  S_OK;
}





//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::CAdvBnd()
//
//  Synopsis:	The constructor for CAdvBnd. I
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBnd::CAdvBnd(IClassFactory *pcfBase) : _xiunk(), _dwRegister(0), _cRefs(1)
{
    HRESULT hresult = pcfBase->CreateInstance((IUnknown *) this, IID_IUnknown,
	(void **) &_xiunk);

    GlobalRefs(TRUE);
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::~CAdvBndObj()
//
//  Synopsis:	The destructor for CAdvBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CAdvBnd::~CAdvBnd()
{
    Display(TEXT("CAdvBndCF::~CAdvBnd called\n"));

    if (_dwRegister != 0)
    {
	// Get the running object table
	IRunningObjectTable *prot;

	HRESULT hresult = GetRunningObjectTable(0, &prot);

	Win4Assert(SUCCEEDED(hresult)
	    && "CAdvBnd::~CAdvBnd GetRunningObjectTable failed");

	hresult = prot->Revoke(_dwRegister);

	Win4Assert(SUCCEEDED(hresult)
	    && "CAdvBnd::~CAdvBnd Revoke failed");

	prot->Release();
    }

    GlobalRefs(FALSE);
}


//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::QueryInterface
//
//  Returns:    SUCCESS_SUCCCESS
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::QueryInterface(REFIID iid, void ** ppunk)
{
    Display(TEXT("CAdvBnd::QueryInterface called\n"));

    if (IsEqualIID(iid, IID_IUnknown))
    {
	*ppunk = (IUnknown *) this;
	AddRef();
	return S_OK;
    }
    else if ((IsEqualIID(iid, IID_IPersistFile)) ||
	     (IsEqualIID(iid, IID_IPersist)))
    {
	*ppunk = (IPersistFile *) this;
	AddRef();
	return S_OK;
    }

    return _xiunk->QueryInterface(iid, ppunk);
}

STDMETHODIMP_(ULONG) CAdvBnd::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CAdvBnd::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
    }

    return _cRefs;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::Load
//
//  Synopsis:   IPeristFile interface - needed 'cause we bind with
//              file moniker and BindToObject insists on calling this
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::Load(LPCOLESTR lpszFileName, DWORD grfMode)
{
    Display(TEXT("CAdvBndCF::Load called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->Load(lpszFileName, grfMode);

    pipfile->Release();

    if (FAILED(hresult))
    {
	// Make sure delegated too class liked what it got/
	// BUGBUG: Can't just forward hresults!
	return hresult;
    }

    // Create a file moniker. Cast to avoid const problem.
    IMoniker *pmk;
    hresult = CreateFileMoniker((LPOLESTR)lpszFileName, &pmk);

    Win4Assert(SUCCEEDED(hresult)
	&& "CAdvBnd::Load CreateFileMoniker failed");

    // Get the running object table
    IRunningObjectTable *prot;

    hresult = GetRunningObjectTable(0, &prot);

    Win4Assert(SUCCEEDED(hresult)
	&& "CAdvBnd::Load GetRunningObjectTable failed");

    // Register in the running object table
    IUnknown *punk;
    QueryInterface(IID_IUnknown, (void **) &punk);
    hresult = prot->Register(0, punk, pmk, &_dwRegister);

    Win4Assert(SUCCEEDED(hresult)
	&& "CAdvBnd::Load Register failed");

    // Set filetime to known value
    FILETIME filetime;
    memset(&filetime, 'B', sizeof(filetime));

    // Set time to some known value
    prot->NoteChangeTime(_dwRegister, &filetime);

    // Release uneeded objects
    pmk->Release();
    prot->Release();
    punk->Release();

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::Save
//
//  Synopsis:   IPeristFile interface - save
//              does little but here for commentry
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::Save(LPCOLESTR lpszFileName, BOOL fRemember)
{
    Display(TEXT("CAdvBndCF::Save called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->Save(lpszFileName, fRemember);

    pipfile->Release();

    return hresult;
}


//+-------------------------------------------------------------------
//
//  Member:	CAdvBnd::SaveCpmpleted
//		CAdvBnd::GetCurFile
//		CAdvBnd::IsDirty
//
//  Synopsis:   More IPeristFile interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CAdvBnd::SaveCompleted(LPCOLESTR lpszFileName)
{
    Display(TEXT("CAdvBndCF::SaveCompleted called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->SaveCompleted(lpszFileName);

    pipfile->Release();

    return hresult;
}

STDMETHODIMP CAdvBnd::GetCurFile(LPOLESTR FAR *lpszFileName)
{
    Display(TEXT("CAdvBndCF::GetCurFile called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->GetCurFile(lpszFileName);

    pipfile->Release();

    return hresult;
}

STDMETHODIMP CAdvBnd::IsDirty()
{
    Display(TEXT("CAdvBndCF::IsDirty called\n"));

    // Forward call to delegated class
    IPersistFile *pipfile;

    HRESULT hresult = _xiunk->QueryInterface(IID_IPersistFile,
	(void **) &pipfile);

    hresult = pipfile->IsDirty();

    pipfile->Release();

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Interface:  IPersist
//
//  Synopsis:   IPersist interface methods
//              Need to return a valid class id here
//
//  History:    21-Nov-92  SarahJ  Created
//

STDMETHODIMP CAdvBnd::GetClassID(LPCLSID classid)
{
    Display(TEXT("CAdvBndCF::GetClassID called\n"));

    *classid = CLSID_AdvBnd;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\actcf.cxx ===
//+-------------------------------------------------------------------
//
//  File:	actcf.cxx
//
//  Contents:	object activation test class factory
//
//  Classes:	CActClassFactory
//
//  Functions:
//
//  History:	23-Nov-92   Ricksa	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma hdrstop
#include    <actcf.hxx>     //	CActClassFactory
#include    <cact.hxx>	    //	CTestAct



const GUID CLSID_TestSingleUse =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x50}};

const GUID CLSID_TestMultipleUse =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x51}};

const GUID CLSID_DistBind =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x55}};





CActClassFactory::CActClassFactory(REFCLSID rclsid, BOOL fServer)
    : _fServer(fServer), _clsid(rclsid), _cRefs(1), _cLocks(0)
{
    // Header does all the work
}

CActClassFactory::~CActClassFactory()
{
    // Default actions are enough
}


STDMETHODIMP CActClassFactory::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) ||
	IsEqualIID(iid, IID_IClassFactory))
    {
	*ppv = (IUnknown *) this;
	AddRef();
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CActClassFactory::AddRef(void)
{
    InterlockedIncrement(&_cRefs);

    if (!_fServer)
    {
	// This is not being used in a server so we want to bump the
	// reference count. In a server we use the lock count rather
	// than the reference count to tell whether we should go away.
	GlobalRefs(TRUE);
    }

    return _cRefs;
}

STDMETHODIMP_(ULONG) CActClassFactory::Release(void)
{
    BOOL fKeepObject = InterlockedDecrement(&_cRefs);

    if (!_fServer)
    {
	// This is not being used in a server so we want to bump the
	// reference count. In a server we use the lock count rather
	// than the reference count to tell whether we should go away.
	GlobalRefs(FALSE);
    }

    if (!fKeepObject)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

STDMETHODIMP CActClassFactory::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    if (pUnkOuter != NULL)
    {
	// Object does not support aggregation
	return E_NOINTERFACE;
    }

    CTestAct *ptballs = new CTestAct(_clsid);

    HRESULT hr = ptballs->QueryInterface(iidInterface, ppv);

    ptballs->Release();

    return hr;
}

STDMETHODIMP CActClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
	InterlockedIncrement(&_cLocks);

	GlobalRefs(TRUE);
    }
    else
    {
	InterlockedDecrement(&_cLocks);

	GlobalRefs(FALSE);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\ballscf.cxx ===
//+-------------------------------------------------------------------
//
//  File:	ballscf.cxx
//
//  Contents:	test class factory object implementation
//
//  Classes:	CBallClassFactory
//
//  Functions:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <ballscf.hxx>	//  class definiton
#include    <cballs.hxx>	//  CBalls defines


const GUID CLSID_Balls =
    {0x0000013a,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};



//+-------------------------------------------------------------------
//
//  Member:	CBallClassFactory::CBallClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

CBallClassFactory::CBallClassFactory(IUnknown *punkOuter) :
    _punkOuter(punkOuter)
{
    ENLIST_TRACKING(CBallClassFactory);
}


//+-------------------------------------------------------------------
//
//  Member:	CBallClassFactory::~CBallClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

CBallClassFactory::~CBallClassFactory(void)
{
    //	automatic actions do the rest of the work
}


//+-------------------------------------------------------------------
//
//  Member:	CBallClassFactory::QueryInterface, public
//
//  Algorithm:	if the interface is not one implemented by us,
//		pass the request to the proxy manager
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBallClassFactory::QueryInterface(REFIID riid, void **ppUnk)
{
    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IClassFactory))
    {
	*ppUnk = (void *)(IClassFactory *) this;
	AddRef();
    }
    else
    {
	if (_punkOuter)
	{
	    sc = _punkOuter->QueryInterface(riid, ppUnk);
	}
	else
	{
	    *ppUnk = NULL;
	    sc = E_NOINTERFACE;
	}
    }
    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CBallClassFactory::CreateInstance, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBallClassFactory::CreateInstance(IUnknown *punkOuter,
					       REFIID	riid,
					       void	**ppunkObject)
{
    SCODE sc = E_OUTOFMEMORY;

    *ppunkObject = NULL;	//  in case of failure

    //	create a ball object.
    IUnknown *punk = (IUnknown *) new CBallCtrlUnk(punkOuter);

    if (punk)
    {
	//  get the interface the caller wants to use
	sc = punk->QueryInterface(riid, ppunkObject);

	//  release our hold on the ball, since the QI got a hold for
	//  the client.
	punk->Release();
    }

    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CBallClassFactory::LockServer, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBallClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
	GlobalRefs(TRUE);
    else
	GlobalRefs(FALSE);

    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\bscbnd.cxx ===
//+-------------------------------------------------------------------
//
//  Class:    CBasicBndCF
//
//  Synopsis: Class Factory for CBasicBnd
//
//  Interfaces:  IUnknown      - QueryInterface, AddRef, Release
//               IClassFactory - CreateInstance
//
//  History:  21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <bscbnd.hxx>


const GUID CLSID_BasicBnd =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x49}};

const GUID CLSID_TestEmbed =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x47}};

ULONG	g_UseCount = 0;



//+-------------------------------------------------------------------
//
//  Member:     CBasicBndCF::CBasicBndCF()
//
//  Synopsis:   The constructor for CBAsicBnd. 
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBndCF::CBasicBndCF() : _cRefs(1)
{
    g_UseCount++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndObj()
//
//  Synopsis:   The destructor for CBAsicBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBndCF::~CBasicBndCF()
{
    g_UseCount--;
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBndCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) ||
	IsEqualIID(iid, IID_IClassFactory))
    {
        *ppv = this;
	AddRef();
        return S_OK;
    } 
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBasicBndCF::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CBasicBndCF::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}



//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the 
//              actual class object
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::CreateInstance(IUnknown FAR* pUnkOuter,
	                                 REFIID iidInterface,
                                         void FAR* FAR* ppv)
{
    HRESULT hresult = S_OK;

    class CUnknownBasicBnd *pubb = new FAR CUnknownBasicBnd(pUnkOuter);

    if (pubb == NULL)
    {
	return E_OUTOFMEMORY;
    }

    //	Because when an aggregate is being requested, the controlling
    //	must be returned, no QI is necessary.
    if (pUnkOuter == NULL)
    {
	hresult = pubb->QueryInterface(iidInterface, ppv);

	pubb->Release();
    }
    else
    {
	*ppv = (void *) pubb;
    }

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Method:	CBasicBndCF::LockServer
//
//  Synopsis:	Who knows what this is for?
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBndCF::LockServer(BOOL fLock)
{
    return E_FAIL;
}





//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::CBasicBnd()
//
//  Synopsis:   The constructor for CBAsicBnd. I
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBnd::CBasicBnd(IUnknown *punk)
    : _punk(punk), _pmkContainer(NULL)
{
    // Create storage for "contained" objects
    SCODE sc = StgCreateDocfile(NULL,
	STGM_DELETEONRELEASE|STGM_DFRALL|STGM_CREATE, 0, &_psStg1);

    Win4Assert((sc == S_OK) && "Create of first storage failed");

    sc = StgCreateDocfile(NULL,
	STGM_DELETEONRELEASE|STGM_DFRALL|STGM_CREATE, 0, &_psStg2);

    Win4Assert((sc == S_OK) && "Create of second storage failed");
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndObj()
//
//  Synopsis:   The destructor for CBAsicBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBnd::~CBasicBnd()
{
    if (_pmkContainer)
    {
	_pmkContainer->Release();
    }

    if (_psStg1)
    {
	_psStg1->Release();
    }

    if (_psStg2)
    {
	_psStg2->Release();
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::QueryInterface
//
//  Returns:	S_OK
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::QueryInterface(REFIID iid, void **ppiuk)
{
    return _punk->QueryInterface(iid, ppiuk);
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::AddRef
//
//  Synopsis:   Standard stuff
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBasicBnd::AddRef(void)
{
    return _punk->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Release
//
//  Synopsis:   Standard stuff
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBasicBnd::Release(void)
{
    return _punk->Release();
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Load
//
//  Synopsis:   IPeristFile interface - needed 'cause we bind with
//              file moniker and BindToObject insists on calling this
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::Load(LPCOLESTR lpszFileName, DWORD grfMode)
{
    if (grfMode & ~(STGM_READWRITE | STGM_SHARE_EXCLUSIVE))
    {
	// Test requires default bind storage request and caller
	// has set some other bits so we fail.
	return STG_E_INVALIDPARAMETER;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Save
//
//  Synopsis:   IPeristFile interface - save
//              does little but here for commentry
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::Save(LPCOLESTR lpszFileName, BOOL fRemember)
{
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::SaveCpmpleted
//              CBasicBnd::GetCurFile
//              CBasicBnd::IsDirty
//
//  Synopsis:   More IPeristFile interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::SaveCompleted(LPCOLESTR lpszFileName)
{
    return S_OK;
}

STDMETHODIMP CBasicBnd::GetCurFile(LPOLESTR FAR *lpszFileName)
{
    return S_OK;
}

STDMETHODIMP CBasicBnd::IsDirty()
{
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Interface:  IPersist
//
//  Synopsis:   IPersist interface methods
//              Need to return a valid class id here
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::GetClassID(LPCLSID classid)
{
    *classid = CLSID_BasicBnd;
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Interface:	IOleObject
//
//  Synopsis:	IOleObject interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetClientSite(LPOLECLIENTSITE FAR* ppClientSite)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetHostNames(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObj)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::Close(DWORD dwSaveOption)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    if (_pmkContainer)
    {
	_pmkContainer->Release();

    }

    _pmkContainer = pmk;

    pmk->AddRef();

    return S_OK;
}

STDMETHODIMP CBasicBnd::GetMoniker(
    DWORD dwAssign,
    DWORD dwWhichMoniker,
    LPMONIKER FAR* ppmk)
{
    if (_pmkContainer != NULL)
    {
	*ppmk = _pmkContainer;
	_pmkContainer->AddRef();
	return S_OK;
    }

    return E_FAIL;
}

STDMETHODIMP CBasicBnd::InitFromData(
    LPDATAOBJECT pDataObject,
    BOOL fCreation,
    DWORD dwReserved)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetClipboardData(
    DWORD dwReserved,
    LPDATAOBJECT FAR* ppDataObject)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::DoVerb(
   LONG iVerb,
   LPMSG lpmsg,
   LPOLECLIENTSITE pActiveSite,
   LONG reserved,
   HWND hwndParent,
   LPCRECT lprcPosRect)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::EnumVerbs(IEnumOLEVERB FAR* FAR* ppenumOleVerb)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::Update(void)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::IsUpToDate(void)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetUserClassID(CLSID FAR* pClsid)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetUserType(DWORD dwFormOfType, LPOLESTR FAR* pszUserType)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::Advise(
    IAdviseSink FAR* pAdvSink,
    DWORD FAR* pdwConnection)
{
    *pdwConnection = 0;
    return S_OK;
}

STDMETHODIMP CBasicBnd::Unadvise(DWORD dwConnection)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetMiscStatus(DWORD dwAspect, DWORD FAR* pdwStatus)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    return E_FAIL;
}


//+-------------------------------------------------------------------
//
//  Interface:	IParseDisplayName
//
//  Synopsis:	IParseDisplayName interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::ParseDisplayName(
    LPBC pbc,
    LPOLESTR lpszDisplayName,
    ULONG FAR* pchEaten,
    LPMONIKER FAR* ppmkOut)
{
    *pchEaten = olestrlen(lpszDisplayName);
    return CreateItemMoniker(OLESTR("\\"), lpszDisplayName, ppmkOut);
}

//+-------------------------------------------------------------------
//
//  Interface:	IOleContainer
//
//  Synopsis:	IOleContainer interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::EnumObjects(
    DWORD grfFlags,
    LPENUMUNKNOWN FAR* ppenumUnknown)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::LockContainer(BOOL fLock)
{
    return E_FAIL;
}

//+-------------------------------------------------------------------
//
//  Interface:	IOleItemContainer
//
//  Synopsis:	IOleItemContainer interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBnd::GetObject(
    LPOLESTR lpszItem,
    DWORD dwSpeedNeeded,
    LPBINDCTX pbc,
    REFIID riid,
    LPVOID FAR* ppvObject)
{
    IStorage *psStorage;
    IOleObject *poo;
    IUnknown *punk;

    if (olestrcmp(lpszItem, OLESTR("1")) == 0)
    {
	psStorage = _psStg1;
    }
    else if (olestrcmp(lpszItem, OLESTR("2")) == 0)
    {
	psStorage = _psStg2;
    }
    else
    {
	return E_FAIL;
    }

    IOleClientSite * pocsObjCliSite;

    HRESULT hresult = QueryInterface(IID_IOleClientSite,
	(void **) &pocsObjCliSite);

    // Call OleCreate to create our embedded object
    hresult = OleCreate(
               CLSID_TestEmbed,         // Class ID of the object we are
                                        //   creating
               IID_IOleObject,          // Interface by which we want to talk
                                        //   to the object
               OLERENDER_NONE,          // We don't want to draw the object
                                        //   when it is not active
               NULL,                    // Used if we do draw the object when
                                        //   it is non-active
               pocsObjCliSite,          // IOleClientSite the server will use
               psStorage,               // IStorage the server will use
	       (void **) &poo);		// Pointer to the object

    Win4Assert(SUCCEEDED(hresult)
	&& "CBasicBnd::GetObject OlCreate Failed!\n");

    // Set the client site
    hresult = poo->SetClientSite(pocsObjCliSite);

    hresult = poo->QueryInterface(IID_IUnknown, (void **)&punk);

    Win4Assert(SUCCEEDED(hresult)
	&& "CBasicBnd::GetObject QI to IUnknown failed!\n");

    hresult = OleRun(punk);

    Win4Assert(SUCCEEDED(hresult)
	&& "CBasicBnd::GetObject OleRun!\n");

    punk->Release();

    LPRECT lprPosRect = (LPRECT) new RECT;

    hresult = poo->DoVerb(
		 OLEIVERB_SHOW,     // Verb we are invoking
		 NULL,		    // MSG that causes us to do this verb
		 pocsObjCliSite,    // Client site of this object
		 0,		    // Reserved - definitive value?
		 0,		    // hwndParent - ???
		 lprPosRect);	    // lprcPosRect - rectangle wrt hwndParent

    Win4Assert(SUCCEEDED(hresult)
	&& "CBasicBnd::GetObject DoVerb failed!\n");

    delete lprPosRect;

    pocsObjCliSite->Release();

    *ppvObject = (void *) poo;

    return hresult;
}

STDMETHODIMP CBasicBnd::GetObjectStorage(
    LPOLESTR lpszItem,
    LPBINDCTX pbc,
    REFIID riid,
    LPVOID FAR* ppvStorage)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::IsRunning(LPOLESTR lpszItem)
{
    return E_FAIL;
}

CUnknownBasicBnd::CUnknownBasicBnd(IUnknown *punk)
    : _pbasicbnd(NULL), _cRefs(1)
{
    if (punk == NULL)
    {
	punk = (IUnknown *) this;
    }

    // BUGBUG: No error checking!
    _pbasicbnd = new CBasicBnd(punk);
    g_UseCount++;
}

CUnknownBasicBnd::~CUnknownBasicBnd(void)
{
    g_UseCount--;
    delete _pbasicbnd;
}



//+-------------------------------------------------------------------
//
//  Member:	CUnknownBasicBnd::QueryInterface
//
//  Returns:	S_OK
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------


STDMETHODIMP CUnknownBasicBnd::QueryInterface(
    REFIID iid,
    void **ppiuk)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
	*ppiuk = (IUnknown *) this;
    }
    else if (IsEqualIID(iid, IID_IOleClientSite))
    {
	*ppiuk = (IOleClientSite *) _pbasicbnd;
    } 
    else if (IsEqualIID(iid, IID_IPersistFile)
	|| IsEqualIID(iid, IID_IPersist))
    {
	*ppiuk = (IPersistFile *) _pbasicbnd;
    } 
    else if (IsEqualIID(iid, IID_IOleObject))
    {
	*ppiuk = (IOleObject *) _pbasicbnd;
    } 
    else if (IsEqualIID(iid, IID_IOleItemContainer))
    {
	*ppiuk = (IOleItemContainer *)_pbasicbnd;
    } 
    else if (IsEqualIID(iid, IID_IOleContainer))
    {
	*ppiuk = (IOleContainer *)_pbasicbnd;
    } 
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
	*ppiuk = (IParseDisplayName *)_pbasicbnd;
    } 
    else
    {
        *ppiuk = NULL;
	return E_NOINTERFACE;
    }

    _pbasicbnd->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CUnknownBasicBnd::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CUnknownBasicBnd::Release(void)
{
    if (--_cRefs == 0)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}



//+-------------------------------------------------------------------
//  Method:	CBasicBnd::SaveObject
//
//  Synopsis:   See spec 2.00.09 p107.  This object should be saved.
//
//  Returns:    Should always return S_OK.
//
//  History:    04-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::SaveObject(void)
{
    // BUGBUG - NYI
    //   Returning S_OK tells OLE that we actually saved this object
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:	CBasicBnd::GetContainer
//
//  Synopsis:   See spec 2.00.09 p108.  Return the container in which
//              this object is found.
//
//  Returns:    Should return S_OK.
//
//  History:    04-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::GetContainer(LPOLECONTAINER FAR *ppContainer)
{
    return QueryInterface(IID_IOleContainer, (void **) ppContainer);
}


//+-------------------------------------------------------------------
//  Method:	CBasicBnd::ShowObject
//
//  Synopsis:   See spec 2.00.09 p109.  Server for this object is asking
//              us to display it.  Caller should not assume we have
//              actually worked, but we return S_OK either way.  Great!
//
//  Returns:    S_OK whether we work or not...
//
//  History:    04-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::ShowObject(void)
{
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:	CBasicBnd::OnShowWindow
//
//  Synopsis:   ???
//
//  Parameters: [fShow] -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::OnShowWindow(BOOL fShow)
{
    return(S_OK);
}



//+-------------------------------------------------------------------
//  Method:	CBasicBnd::RequestNewObjectLayout
//
//  Synopsis:   ???
//
//  Parameters: [fShow] -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::RequestNewObjectLayout(void)
{
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\cact.cxx ===
//+-------------------------------------------------------------------
//
//  File:	cact.cxx
//
//  Contents:	object activation test class
//
//  Classes:	CActTest
//
//  Functions:
//
//  History:	23-Nov-92   Ricksa	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma hdrstop
#include    <cact.hxx>	    //	CTestAct

// We need a semaphore to synchronize loads and releases.
CMutexSem mxsLoadRelease;

SAFE_INTERFACE_PTR(XIStream, IStream)

#define XPOS OLESTR("XPOS")
#define YPOS OLESTR("YPOS")


HRESULT ReadPos(IStorage *pstg, LPOLESTR pwszStream, ULONG *pulPos)
{
    HRESULT hr;

    BEGIN_BLOCK

	XIStream xstrm;

	// Read the streams for xpos and ypos
	hr = pstg->OpenStream(pwszStream, NULL,
	    STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, &xstrm);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	ULONG cb;

	hr = xstrm->Read(pulPos, sizeof(*pulPos), &cb);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	hr = ResultFromScode(S_OK);

    END_BLOCK

    return hr;
}

HRESULT WritePos(IStorage *pstg, LPOLESTR pwszStream, ULONG ulPos)
{
    HRESULT hr;

    BEGIN_BLOCK

	XIStream xstrm;

	// Read the streams for xpos and ypos
	hr = pstg->CreateStream(pwszStream,
	    STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE, NULL, NULL,
		&xstrm);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}


	ULONG cb;

	hr = xstrm->Write(&ulPos, sizeof(ulPos), &cb);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	hr = ResultFromScode(S_OK);

    END_BLOCK

    return hr;
}

CTestAct::CTestAct(REFCLSID rclsid)
    : _rclsid(rclsid), _fDirty(FALSE), _xPos(0), _yPos(0),
	_fSaveInprogress(FALSE), _pstg(NULL), _dwRegister(0), _cRefs(1)
{
    // Use as a flag for whether a file name has been assigned
    _awszCurFile[0] = 0;

    GlobalRefs(TRUE);
}

CTestAct::~CTestAct(void)
{
    if (_pstg != NULL)
    {
	// Release the storage because we are done with it
	ULONG ulCnt = _pstg->Release();

#if 0
	//  this test is not valid when running stress
	if (ulCnt != 0)
	{
	    DebugBreak();
	}
#endif

    }

    if (_dwRegister)
    {
	IRunningObjectTable *prot;
	GetRunningObjectTable(NULL, &prot);
	prot->Revoke(_dwRegister);
	prot->Release();
    }

    GlobalRefs(FALSE);
}

STDMETHODIMP CTestAct::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = ResultFromScode(S_OK);

    // We support IUnknown, IPersistFile and IBalls
    if (IsEqualIID(iid, IID_IUnknown))
    {
	*ppv = (IBalls *) this;
    }
    else if (IsEqualIID(iid, IID_IPersistFile))
    {
	*ppv = (IPersistFile *) this;
    }
    else if (IsEqualIID(iid, IID_IPersistStorage))
    {
	*ppv = (IPersistStorage *) this;
    }
    else if (IsEqualIID(iid, IID_IBalls))
    {
	*ppv = (IBalls *) this;
    }
    else
    {
	*ppv = NULL;
	hr = ResultFromScode(E_NOINTERFACE);
    }

    if (SUCCEEDED(hr))
    {
	AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CTestAct::AddRef(void)
{
    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) CTestAct::Release(void)
{
    CLock lck(mxsLoadRelease);

    if (InterlockedDecrement(&_cRefs) == 0)
    {
	delete this;
	return	0;
    }

    return _cRefs;
}

STDMETHODIMP CTestAct::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = _rclsid;
    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestAct::IsDirty()
{
    return (_fDirty) ? ResultFromScode(S_OK) : ResultFromScode(S_FALSE);
}

STDMETHODIMP CTestAct::Load(LPCOLESTR lpszFileName, DWORD grfMode)
{
    CLock lck(mxsLoadRelease);

    HRESULT hr;

    BEGIN_BLOCK

	hr = StgOpenStorage(lpszFileName, NULL,
	    STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, NULL, &_pstg);

	if (FAILED(hr))
	{
#if 0
	    //	this test is not valid when running stress
	    if (hr == STG_E_LOCKVIOLATION)
	    {
		DebugBreak();
	    }
#endif

	    EXIT_BLOCK;
	}

	// Get the saved xposition
	hr = GetData();

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	// Since everything went Ok save the file name
	olestrcpy(_awszCurFile, lpszFileName);

	// Create a file moniker for the object.
	// Cast to non-constant string.
	IMoniker *pmk;
	CreateFileMoniker((LPOLESTR)lpszFileName, &pmk);

	// Register it in the running object table.
	IRunningObjectTable *prot;
	GetRunningObjectTable(NULL, &prot);
	prot->Register(NULL, (IPersistFile *) this, pmk, &_dwRegister);

	// Release the temporary objects
	pmk->Release();
	prot->Release();

    END_BLOCK

    return hr;
}

STDMETHODIMP CTestAct::Save(LPCOLESTR lpszFileName, BOOL fRemember)
{
    HRESULT hr;

    BEGIN_BLOCK

	IStorage *pstgNew;

	// Save the data
	if (olestrcmp(lpszFileName, _awszCurFile) == 0)
	{
	    pstgNew = _pstg;
	    _fDirty = FALSE;
	}
	else
	{
	    hr = StgCreateDocfile(lpszFileName,
		STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
		    NULL, &pstgNew);
	}

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	WriteClassStg(pstgNew, _rclsid);

	hr = SaveData(pstgNew);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	if (fRemember)
	{
	    // Save the file name
	    olestrcpy(_awszCurFile, lpszFileName);


	    // Replace the storage
	    if (_pstg && pstgNew != _pstg)
	    {
		_pstg->Release();
	    }
	    _pstg = pstgNew;

	    _fDirty = FALSE;
	}
	else
	{
	    pstgNew->Release();
	}

	_fSaveInprogress = TRUE;

	hr = ResultFromScode(S_OK);

    END_BLOCK;

    return hr;
}

STDMETHODIMP CTestAct::SaveCompleted(LPCOLESTR lpszFileName)
{
    _fSaveInprogress = FALSE;
    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestAct::GetCurFile(LPOLESTR FAR *lpszFileName)
{
    // Allocate a buffer for the file and copy in the data
    if (_awszCurFile[0] == 0)
    {
	return ResultFromScode(S_FALSE);
    }


    IMalloc *pIMalloc;

    HRESULT hr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);

    if (SUCCEEDED(hr))
    {
	*lpszFileName = (OLECHAR *) pIMalloc->Alloc(
	    olestrlen((_awszCurFile) + 1) * sizeof(OLECHAR));

	olestrcpy(*lpszFileName, _awszCurFile);

	hr = ResultFromScode(S_OK);
    }

    return hr;
}

STDMETHODIMP CTestAct::MoveBall(ULONG xPos, ULONG yPos)
{
    if (!_fSaveInprogress)
    {
	_fDirty = TRUE;
	_xPos = xPos;
	_yPos = yPos;
	return S_OK;
    }

    // Can't change state because a save is still pending
    return ResultFromScode(E_UNEXPECTED);
}

STDMETHODIMP CTestAct::GetBallPos(ULONG *xPos, ULONG *yPos)
{
    *xPos = _xPos;
    *yPos = _yPos;
    return S_OK;
}

STDMETHODIMP CTestAct::IsOverLapped(IBalls *pIBall)
{
    ULONG xPos;
    ULONG yPos;

    HRESULT hr = pIBall->GetBallPos(&xPos, &yPos);

    if (SUCCEEDED(hr))
    {
	if ((xPos == _xPos) && (yPos == _yPos))
	{
	    hr = ResultFromScode(S_OK);
	}
	else
	{
	    hr = ResultFromScode(S_FALSE);
	}
    }

    return hr;
}

STDMETHODIMP CTestAct::IsContainedIn(ICube *pICube)
{
    ULONG xPos;
    ULONG yPos;

    HRESULT hr = pICube->GetCubePos(&xPos, &yPos);

    if (SUCCEEDED(hr))
    {
	if ((xPos == _xPos) && (yPos == _yPos))
	{
	    hr = ResultFromScode(S_OK);
	}
	else
	{
	    hr = ResultFromScode(S_FALSE);
	}
    }

    return hr;

}

STDMETHODIMP CTestAct::Clone(IBalls **ppIBall)
{
    CTestAct *ptballs = new CTestAct(_rclsid);

    ptballs->_xPos = _xPos;
    ptballs->_yPos = _yPos;
    ptballs->_fDirty = _fDirty;
    _pstg->AddRef();
    ptballs->_pstg = _pstg;
    olestrcpy(ptballs->_awszCurFile, _awszCurFile);
    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestAct::Echo(IUnknown *punkIn, IUnknown**ppunkOut)
{
    *ppunkOut = punkIn;
    return S_OK;
}

STDMETHODIMP CTestAct::InitNew(LPSTORAGE pStg)
{
    pStg->AddRef();
    _pstg = pStg;
    WriteClassStg(_pstg, _rclsid);

    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestAct::Load(LPSTORAGE pStg)
{
    HRESULT hr;

    _pstg = pStg;

    hr = GetData();

    if (SUCCEEDED(hr))
    {
	_pstg->AddRef();
    }
    else
    {
	_pstg = NULL;
    }

    return hr;
}

STDMETHODIMP CTestAct::Save(
    LPSTORAGE pStgSave,
    BOOL fSameAsLoad)
{
    HRESULT hr;

    if (!fSameAsLoad)
    {
	if (_pstg)
	    _pstg->Release();

	_pstg = pStgSave;

	pStgSave->AddRef();
    }
    else
    {
	pStgSave = _pstg;
    }

    WriteClassStg(pStgSave, _rclsid);

    hr = SaveData(pStgSave);

    _fSaveInprogress = TRUE;

    return hr;
}

STDMETHODIMP CTestAct::SaveCompleted(LPSTORAGE pStgSaved)
{
    _fSaveInprogress = FALSE;
    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestAct::HandsOffStorage(void)
{
    // Figure out what to do here!
    return ResultFromScode(E_UNEXPECTED);
}

HRESULT	CTestAct::GetData(void)
{
    HRESULT hr;

    BEGIN_BLOCK

	// Get the saved xposition
	hr = ReadPos(_pstg, XPOS, &_xPos);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	// Get the saved yposition
	hr = ReadPos(_pstg, YPOS, &_yPos);

    END_BLOCK

    return hr;
}

HRESULT	CTestAct::SaveData(IStorage *pstg)
{
    HRESULT hr;

    BEGIN_BLOCK

	// Get the saved xposition
	hr = WritePos(pstg, XPOS, _xPos);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	// Get the saved yposition
	hr = WritePos(pstg, YPOS, _yPos);


    END_BLOCK

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\cballs.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	cballs.cxx
//
//  Contents:	implementations for CBall
//
//  Functions:
//		CBall::CBall
//		CBall::~CBall
//		CBall::QueryInterface
//		CBall::CreateBall
//		CBall::MoveBall
//		CBall::GetBallPos
//		CBall::IsOverLapped
//		CBall::IsContainedIn
//		CBall::Clone
//		CBall::Echo
//
//		CBallCtrlUnk::CBallCtrlUnk
//		CBallCtrlUnk::~CBallCtrlUnk
//		CBallCtrlUnk::QueryInterface
//		CBallCtrlUnk::AddRef
//		CBallCtrlUnk::Release
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <cballs.hxx>    //	class definition
#include    <icube.h>	    //	ICube definition


#define CUBE_WIDTH  20


//+-------------------------------------------------------------------------
//
//  Method:	CBall::CBall
//
//  Synopsis:	Creates the application window
//
//  Arguments:	[pisb] - ISysBind instance
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CBall::CBall(IUnknown *punkOuter)
    : _xPos(BALL_UNDEF),
      _yPos(BALL_UNDEF),
      _punkOuter(punkOuter)
{
    CreateBall(0,0);

    GlobalRefs(TRUE);
}

//+-------------------------------------------------------------------------
//
//  Method:	CBall::~CBall
//
//  Synopsis:	Cleans up object
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CBall::~CBall(void)
{
    GlobalRefs(FALSE);

    //	automatic actions are enough
}


//+-------------------------------------------------------------------------
//
//  Method:	CBall::QueryInterface
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[ifid] - interface instance requested
//		[ppunk] - where to put pointer to interface instance
//
//  Returns:	S_OK or ERROR_BAD_COMMAND
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CBall::QueryInterface(REFIID riid, void **ppunk)
{
    return _punkOuter->QueryInterface(riid, ppunk);
}

//+-------------------------------------------------------------------------
//
//  Method:	CBall::AddRef
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBall::AddRef(void)
{
    return _punkOuter->AddRef();
}

//+-------------------------------------------------------------------------
//
//  Method:	CBall::Release
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBall::Release(void)
{
    return _punkOuter->Release();
}


//+-------------------------------------------------------------------------
//
//  Method:	CBall::QueryInternalIface
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[ifid] - interface instance requested
//		[ppunk] - where to put pointer to interface instance
//
//  Returns:	S_OK or ERROR_BAD_COMMAND
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CBall::QueryInternalIface(REFIID riid, void **ppunk)
{
    SCODE sc = E_FAIL;

    if (IsEqualIID(riid,IID_IUnknown) ||
	IsEqualIID(riid,IID_IBalls))
    {
	// Increase the reference count
	*ppunk = (void *)(IBalls *) this;
	AddRef();

	// Set to success
	sc = S_OK;
    }

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Method:	CBall::CreateBall
//
//  Synopsis:	Creates a ball on the screen
//
//  Arguments:	[xPos] - x position for new ball
//		[yPos] - y position for new ball
//
//  Returns:	S_OK or ERROR_BAD_COMMAND
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CBall::CreateBall(ULONG xPos, ULONG yPos)
{
    SCODE sc = E_FAIL;

    if (xPos != (ULONG) -1)
    {
	// Update data
	_xPos = xPos;
	_yPos = yPos;
	sc = S_OK;

	// Format message for the screen
	Display(TEXT("Create Ball xPos = %ld yPos = %ld\n"), xPos, yPos);
    }

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:	CBall::MoveBall
//
//  Synopsis:	Move the ball from one position to another
//
//  Arguments:	[xPos] - new x position for the ball
//		[yPos] - new y position for the ball
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CBall::MoveBall(ULONG xPos, ULONG yPos)
{
    // Set the position
    _xPos = xPos;
    _yPos = yPos;

    // Format message for the screen
    Display(TEXT("Move Ball xPos = %ld yPos = %ld\n"), xPos, yPos);
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:	CBall::GetBallPos
//
//  Synopsis:	Get the current position of the ball
//
//  Arguments:	[hWindow] - handle for the window
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CBall::GetBallPos(ULONG *pxPos, ULONG *pyPos)
{
    *pxPos = _xPos;
    *pyPos = _yPos;

    // Format message for the screen
    Display(TEXT("Get Ball Pos xPos = %ld yPos = %ld\n"), _xPos, _yPos);
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:	CBall::IsOverLapped
//
//  Synopsis:	Check if this ball overlaps the given ball.
//
//  Arguments:	[hWindow] - handle for the window
//		[pIBall]  - other ball to compare with
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CBall::IsOverLapped(IBalls *pIBall)
{
    ULONG   xPos, yPos;

    SCODE sc = pIBall->GetBallPos(&xPos, &yPos);

    if (SUCCEEDED(sc))
    {
	if ((abs(xPos - _xPos) < BALL_DIAMETER) &&
	    (abs(yPos - _yPos) < BALL_DIAMETER))
	{
	    // Format message for the screen
	    Display(TEXT("Balls OverLap. xpos = %ld yPos = %ld\n"), xPos, yPos);
	}
	else
	{
	    // Format message for the screen
	    Display(TEXT("Balls Dont OverlLap. xPos = %ld yPos = %ld\n"), xPos, yPos);
	}
    }

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Function:	CBall::IsContainedIn
//
//  Synopsis:	Check if this ball is contained in the given cube.
//
//  Arguments:	[hWindow] - handle for the window
//		[pICube]  - cube to compare with
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CBall::IsContainedIn(ICube *pICube)
{
    ULONG   xPos, yPos;

    SCODE sc = pICube->GetCubePos(&xPos, &yPos);

    if (SUCCEEDED(sc))
    {
	if ((abs(xPos - _xPos) < CUBE_WIDTH) &&
	    (abs(yPos - _yPos) < CUBE_WIDTH))
	{
	    // Format message for the screen
	    Display(TEXT("Ball Contained in Cube. xPos = %ld yPos = %ld\n"), xPos, yPos);
	}
	else
	{
	    // Format message for the screen
	    Display(TEXT("Ball Outside Cube. xPos = %ld yPos = %ld\n"), xPos, yPos);
	}
    }

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:	CBall::Clone
//
//  Synopsis:	make a copy of this ball
//
//  Arguments:	[hWindow] - handle for the window
//		[ppIBall] - new ball to return
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CBall::Clone(IBalls **ppIBall)
{
    Display(TEXT("Clone Ball\n"));

    CBallCtrlUnk *pNew = new CBallCtrlUnk(NULL);

    SCODE sc = pNew->QueryInterface(IID_IBalls, (void **)ppIBall);

    pNew->Release();

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:	CBall::Echo
//
//  Synopsis:	returns the same interface passed in. this is just to test
//		marshalling in and out interfaces.
//
//  Arguments:	[hWindow] - handle for the window
//		[punkIn] - IUnknown in
//		[ppunkOut] - IUnknown out
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CBall::Echo(IUnknown *punkIn, IUnknown **ppunkOut)
{
    Display(TEXT("Echo Interface\n"));

    punkIn->AddRef();		//  keep the in parameter...
    *ppunkOut = punkIn; 	//  cause we're gonna return it.

    return S_OK;
}


#pragma warning(disable:4355)	// 'this' used in base member init list
//+-------------------------------------------------------------------------
//
//  Method:	CBallCtrlUnk::CBallCtrlUnk
//
//  Synopsis:
//
//  Arguments:
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CBallCtrlUnk::CBallCtrlUnk(IUnknown *punkOuter)
    : _ball((punkOuter) ? punkOuter : this)
{
    ENLIST_TRACKING(CBallCtrlUnk);
}
#pragma warning(default:4355)  // 'this' used in base member init list


//+-------------------------------------------------------------------------
//
//  Method:	CBallCtrlUnk::~CBallCtrlUnk
//
//  Synopsis:	Cleans up object
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CBallCtrlUnk::~CBallCtrlUnk(void)
{
    //	automatic actions are enough
}


//+-------------------------------------------------------------------------
//
//  Method:	CBallCtrlUnk::QueryInterface
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[ifid] - interface instance requested
//		[ppunk] - where to put pointer to interface instance
//
//  Returns:	S_OK or ERROR_BAD_COMMAND
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CBallCtrlUnk::QueryInterface(REFIID riid, void **ppunk)
{
    SCODE sc = E_FAIL;

    if (IsEqualIID(riid,IID_IUnknown))
    {
	// Increase the reference count
	*ppunk = (void *)(IUnknown *) this;
	AddRef();

	// Set to success
	sc = S_OK;
    }
    else
    {
	sc = _ball.QueryInternalIface(riid, ppunk);
    }

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\ccubes.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	cubes.cxx
//
//  Contents:	implementations for CCube
//
//  Functions:
//		CCube::CCube
//		CCube::~CCube
//		CCube::QueryInterface
//		CCube::CreateCube
//		CCube::MoveCube
//		CCube::GetCubePos
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <ccubes.hxx>    //	class definition
#include    <iballs.h>	    //	IBalls interface definiton


#define CUBE_WIDTH  20


//+-------------------------------------------------------------------------
//
//  Method:	CCube::CCube
//
//  Synopsis:	Creates the application window
//
//  Arguments:	[pisb] - ISysBind instance
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CCube::CCube(void)
    : _xPos(CUBE_UNDEF),
      _yPos(CUBE_UNDEF)
{
    CreateCube(0,0);
    GlobalRefs(TRUE);

    ENLIST_TRACKING(CCube);
}


//+-------------------------------------------------------------------------
//
//  Method:	CCube::~CCube
//
//  Synopsis:	Cleans up object
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CCube::~CCube(void)
{
    GlobalRefs(FALSE);

    //	automatic actions are enough
}


//+-------------------------------------------------------------------------
//
//  Method:	CCube::QueryInterface
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[ifid] - interface instance requested
//		[ppunk] - where to put pointer to interface instance
//
//  Returns:	S_OK or ERROR_BAD_COMMAND
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CCube::QueryInterface(REFIID riid, void **ppunk)
{
    SCODE sc = E_NOINTERFACE;
    *ppunk = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_ICube))
    {
	// Increase the reference count
	*ppunk = (void *)(ICube *) this;
	AddRef();

	// Set to success
	sc = S_OK;
    }

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:	CCube::CreateCube
//
//  Synopsis:	Creates a Cube on the screen
//
//  Arguments:	[xPos] - x position for new Cube
//		[yPos] - y position for new Cube
//
//  Returns:	S_OK or ERROR_BAD_COMMAND
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CCube::CreateCube(ULONG xPos, ULONG yPos)
{
    SCODE sc = E_FAIL;

    if (xPos != (ULONG) -1)
    {
	// Update data
	_xPos = xPos;
	_yPos = yPos;
	sc = S_OK;

	// Format message for the screen
	Display(TEXT("Create Cube xPos = %ld yPos = %ld\n"), xPos, yPos);
    }

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:	CCube::MoveCube
//
//  Synopsis:	Move the Cube from one position to another
//
//  Arguments:	[xPos] - new x position for the Cube
//		[yPos] - new y position for the Cube
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CCube::MoveCube(ULONG xPos, ULONG yPos)
{
    // Set the position
    _xPos = xPos;
    _yPos = yPos;

    // Format message for the screen
    Display(TEXT("Move Cube xPos = %ld yPos = %ld\n"), xPos, yPos);
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	CCube::GetCubePos
//
//  Synopsis:	Get the current position of the Cube
//
//  Arguments:	[hWindow] - handle for the window
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CCube::GetCubePos(ULONG *pxPos, ULONG *pyPos)
{
    *pxPos = _xPos;
    *pyPos = _yPos;

    // Format message for the screen
    Display(TEXT("Get Cube Pos xPos = %ld yPos = %ld\n"), _xPos, _yPos);
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Function:	CCube::Contains
//
//  Synopsis:	Check if this Cube is contained in the given cube.
//
//  Arguments:	[hWindow] - handle for the window
//		[pICube]  - cube to compare with
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CCube::Contains(IBalls *pIBall)
{
    ULONG   xPos, yPos;

    SCODE sc = pIBall->GetBallPos(&xPos, &yPos);

    if (SUCCEEDED(sc))
    {
	if ((abs(xPos - _xPos) < CUBE_WIDTH) &&
	    (abs(yPos - _yPos) < CUBE_WIDTH))
	{
	    // Format message for the screen
	    Display(TEXT("Cube contains in Ball. xPos = %ld yPos = %ld\n"), xPos, yPos);
	}
	else
	{
	    // Format message for the screen
	    Display(TEXT("Ball Outside Cube. xPos = %ld yPos = %ld\n"), xPos, yPos);
	}
    }

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Function:	CCube::SimpleCall
//
//  Synopsis:	checks the TID and LID to make sure they match the callers.
//
//  Arguments:
//
//  Returns:	S_OK
//
//  History:	16-Jan-96 RickHi    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CCube::SimpleCall(DWORD pidCaller, DWORD tidCaller, GUID lidCaller)
{
    HRESULT hr = S_OK;

    GUID lid;
    HRESULT hr2 = CoGetCurrentLogicalThreadId(&lid);

    if (SUCCEEDED(hr2))
    {
	if (!IsEqualGUID(lid, lidCaller))
	{
	    // LIDs dont match, error
	    hr |= 0x80000001;
	}
    }
    else
    {
	return hr2;
    }

    DWORD tid;
    hr2 = CoGetCallerTID(&tid);

    if (SUCCEEDED(hr2))
    {
	if (pidCaller == GetCurrentProcessId())
	{
	    // if in same process, CoGetCallerTID should return S_OK
	    if (hr2 != S_OK)
	    {
		hr |= 0x80000002;
	    }
	}
	else
	{
	    // if in different process, CoGetCallerTID should return S_FALSE
	    if (hr2 != S_FALSE)
	    {
		hr |= 0x80000004;
	    }
	}
    }
    else
    {
	return hr2;
    }

    return hr;
}



STDMETHODIMP CCube::PrepForInputSyncCall(IUnknown *pUnkIn)
{
    // just remember the input ptr

    _pUnkIn = pUnkIn;
    _pUnkIn->AddRef();

    return S_OK;
}

STDMETHODIMP CCube::InputSyncCall()
{
    // just attempt to release an Interface Pointer inside an InputSync
    // method.

    if (_pUnkIn)
    {
	if (_pUnkIn->Release() != 0)
	    return  RPC_E_CANTCALLOUT_ININPUTSYNCCALL;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\cfballs.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	cfballs.cxx
//
//  Contents:	implementations for CFactory
//
//  Functions:
//		CCube::CCube
//		CCube::~CCube
//		CCube::QueryInterface
//		CCube::CreateCube
//		CCube::MoveCube
//		CCube::GetCubePos
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

#include    <pch.cxx>
#pragma hdrstop

#include    <ctballs.hxx>
#include    <cfballs.hxx>


CFactory::CFactory(REFCLSID rclsid, BOOL fServer)
    : _fServer(fServer), _clsid(rclsid), _cRefs(1), _cLocks(0)
{
    // Header does all the work
}

CFactory::~CFactory()
{
    // Default actions are enough
}


STDMETHODIMP CFactory::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (IsEqualIID(iid, IID_IUnknown)
	|| IsEqualIID(iid, IID_IClassFactory))
    {
	*ppv = (IUnknown *) this;
	AddRef();
	return ResultFromSCode(S_OK);
    }

    *ppv = NULL;
    return ResultFromSCode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CFactory::AddRef(void)
{
    InterlockedIncrement(&_cRefs);

    if (!_fServer)
    {
	// This is not being used in a server so we want to bump the
	// reference count. In a server we use the lock count rather
	// than the reference count to tell whether we should go away.
	GlobalRefs(TRUE);
    }

    return _cRefs;
}

STDMETHODIMP_(ULONG) CFactory::Release(void)
{
    BOOL fKeepObject = InterlockedDecrement(&_cRefs);

    if (!_fServer)
    {
	// This is not being used in a server so we want to bump the
	// reference count. In a server we use the lock count rather
	// than the reference count to tell whether we should go away.
	GlobalRefs(FALSE);
    }

    if (!fKeepObject)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

STDMETHODIMP CFactory::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    if (pUnkOuter != NULL)
    {
	// Object does not support aggregation
	return ResultFromSCode(E_NOINTERFACE);
    }

    CTestBalls *ptballs = new CTestBalls(_clsid);

    HRESULT hr = ptballs->QueryInterface(iidInterface, ppv);

    ptballs->Release();

    return hr;
}

STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
	InterlockedIncrement(&_cLocks);

	GlobalRefs(TRUE);
    }
    else
    {
	InterlockedDecrement(&_cLocks);

	GlobalRefs(FALSE);
    }

    return ResultFromSCode(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\cloop.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	cloop.cxx
//
//  Contents:	implementations for CBall
//
//  Functions:
//		CLoop::CLoop
//		CLoop::~CLoop
//		CLoop::QueryInterface
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <cloop.hxx>    //	class definition


//+-------------------------------------------------------------------------
//
//  Method:	CLoop::CLoop
//
//  Synopsis:	Creates the application window
//
//  Arguments:	[pisb] - ISysBind instance
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CLoop::CLoop(void)
    : _pRemoteLoop(NULL)
{
    GlobalRefs(TRUE);

    ENLIST_TRACKING(CLoop);
}

//+-------------------------------------------------------------------------
//
//  Method:	CLoop::~CLoop
//
//  Synopsis:	Cleans up object
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CLoop::~CLoop(void)
{
    if (_pRemoteLoop)
    {
	_pRemoteLoop->Release();
    }

    GlobalRefs(FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:	CLoop::QueryInterface
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[ifid] - interface instance requested
//		[ppunk] - where to put pointer to interface instance
//
//  Returns:	S_OK or ERROR_BAD_COMMAND
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CLoop::QueryInterface(REFIID riid, void **ppunk)
{
    SCODE sc = E_NOINTERFACE;
    *ppunk = NULL;

    if (IsEqualIID(riid,IID_IUnknown) ||
	IsEqualIID(riid,IID_ILoop))
    {
	// Increase the reference count
	*ppunk = (void *)(ILoop *) this;
	AddRef();

	// Set to success
	sc = S_OK;
    }

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:	CLoop::Init
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:	S_OK or ERROR_BAD_COMMAND
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CLoop::Init(ILoop *pRemoteLoop)
{
    _pRemoteLoop = pRemoteLoop;
    _pRemoteLoop->AddRef();

    // Format message for the screen
    Display(TEXT("Loop Init %ld\n"), pRemoteLoop);

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:	CLoop::Uninit
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CLoop::Uninit(void)
{
    // Format message for the screen
    Display(TEXT("Uninit %ld\n"), _pRemoteLoop);

    if (_pRemoteLoop)
    {
	_pRemoteLoop->Release();
	_pRemoteLoop = NULL;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	CLoop::Loop
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CLoop::Loop(ULONG ulLoopCount)
{
    // Format message for the screen
    Display(TEXT("Loop Count = %ld\n"), ulLoopCount);

    if (--ulLoopCount == 0)
	return S_OK;
    else
	return _pRemoteLoop->Loop(ulLoopCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\cqisrv.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	cqi.cxx
//
//  Contents:	implementations for QueryInterface test
//
//  Functions:
//		CQI::CQI
//		CQI::~CQI
//		CQI::QueryInterface
//		CQI::GetClassForHandler
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
#include    <pch.cxx>
#pragma     hdrstop
#include    <cqi.hxx>	 //	class definition

//+-------------------------------------------------------------------------
//
//  Method:	CQI::CQI
//
//  Synopsis:	Creates an instance of CQI
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
CQI::CQI(REFCLSID rclsid) : _clsid(rclsid)
{
    Display(TEXT("CQI created.\n"));
    GlobalRefs(TRUE);

    ENLIST_TRACKING(CQI);
}

//+-------------------------------------------------------------------------
//
//  Method:	CQI::~CQI
//
//  Synopsis:	Cleans up object
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
CQI::~CQI(void)
{
    Display(TEXT("CQI deleted.\n"));
    GlobalRefs(FALSE);

    //	automatic actions are enough
}

//+-------------------------------------------------------------------------
//
//  Method:	CQI::QueryInterface
//
//  Synopsis:	returns ptr to requested interface.
//
//		DANGER: this returns SUCCESS on almost every interface,
//		though the only valid methods on any interface are IUnknown
//		and IStdMarshalInfo.
//
//  Arguments:	[riid] - interface instance requested
//		[ppv]  - where to put pointer to interface instance
//
//  Returns:	S_OK or E_NOINTERFACE
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CQI::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IStdMarshalInfo))
    {
	if (IsEqualCLSID(_clsid, CLSID_QIHANDLER))
	{
	    *ppv = (IStdMarshalInfo *)this;
	    AddRef();
	    return S_OK;
	}
    }

    if (IsEqualIID(riid,IID_IUnknown) ||
	IsEqualIID(riid,IID_IAdviseSink) ||
	IsEqualIID(riid,IID_IDataObject) ||
	IsEqualIID(riid,IID_IOleObject) ||
	IsEqualIID(riid,IID_IOleClientSite) ||
	IsEqualIID(riid,IID_IParseDisplayName) ||
	IsEqualIID(riid,IID_IPersistStorage) ||
	IsEqualIID(riid,IID_IPersistFile) ||
	IsEqualIID(riid,IID_IStorage) ||
	IsEqualIID(riid,IID_IOleContainer) ||
	IsEqualIID(riid,IID_IOleItemContainer) ||
	IsEqualIID(riid,IID_IOleInPlaceSite) ||
	IsEqualIID(riid,IID_IOleInPlaceActiveObject) ||
	IsEqualIID(riid,IID_IOleInPlaceObject) ||
	IsEqualIID(riid,IID_IOleInPlaceUIWindow) ||
	IsEqualIID(riid,IID_IOleInPlaceFrame) ||
	IsEqualIID(riid,IID_IOleWindow))
    {
	*ppv = (void *)(IUnknown *) this;
	AddRef();
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Method:	CQI::GetClassForHandler
//
//  Synopsis:	returns the classid for the inproc handler of this object.
//		Used to test handler marshaling.
//
//  History:	06-Aug-92 Rickhi    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CQI::GetClassForHandler(DWORD dwDestContext,
				     void *pvDestContext,
				     CLSID *pClsid)
{
    *pClsid = CLSID_QIHANDLER;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\crpctyp.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	crpctyp.cxx
//
//  Contents:	implementations for rpc test
//
//  Functions:
//		CRpcTypes::CRpcTypes
//		CRpcTypes::~CRpcTypes
//		CRpcTypes::QueryInterface
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <crpctyp.hxx>	  //	class definition


const GUID CLSID_RpcTypes =
    {0x00000132,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTypes::CRpcTypes
//
//  Synopsis:	Creates the application window
//
//  Arguments:	[pisb] - ISysBind instance
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CRpcTypes::CRpcTypes(void)
{
    GlobalRefs(TRUE);

    ENLIST_TRACKING(CRpcTypes);
}


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTypes::~CRpcTypes
//
//  Synopsis:	Cleans up object
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CRpcTypes::~CRpcTypes(void)
{
    GlobalRefs(FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTypes::QueryInterface
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[ifid] - interface instance requested
//		[ppunk] - where to put pointer to interface instance
//
//  Returns:	S_OK or E_NOINTERFACE
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRpcTypes::QueryInterface(REFIID riid, void **ppunk)
{
    SCODE sc = S_OK;

    if (IsEqualIID(riid,IID_IUnknown) ||
	IsEqualIID(riid,IID_IRpcTypes))
    {
	// Increase the reference count
	*ppunk = (void *)(IRpcTypes *) this;
	AddRef();
    }
    else
    {
	*ppunk = NULL;
	sc = E_NOINTERFACE;
    }

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTypes::GuidsIn
//
//  Synopsis:	tests passing GUID parameters
//
//  Arguments:
//
//  Returns:	S_OK or error code with parm #s or'd in
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CRpcTypes::GuidsIn(
	REFCLSID rclsid,
	CLSID clsid,
	REFIID riid,
	IID iid,
	GUID guid)
{
    SCODE sc = S_OK;

    //	compare each parameter with the expected value
    if (!IsEqualCLSID(rclsid, CLSID_RpcTypes))
	sc |= 1;

    if (!IsEqualCLSID(clsid, CLSID_RpcTypes))
	sc |= 2;

    if (!IsEqualIID(riid, IID_IRpcTypes))
	sc |= 4;

    if (!IsEqualIID(iid, IID_IRpcTypes))
	sc |= 8;

    if (!IsEqualIID(guid, IID_IRpcTypes))
	sc |= 8;

    return sc;
}


STDMETHODIMP CRpcTypes::GuidsOut(
	CLSID *pclsid,
	IID *piid,
	GUID *pguid)
{
    //	copy in the expected return values
    memcpy(pclsid, &CLSID_RpcTypes, sizeof(CLSID));

    memcpy(piid, &IID_IRpcTypes, sizeof(IID));

    memcpy(pguid, &CLSID_RpcTypes, sizeof(GUID));

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTypes::DwordIn
//
//  Synopsis:	tests passing dword and large integer parameters
//
//  Arguments:
//
//  Returns:	S_OK or error code with parm #s or'd in
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CRpcTypes::DwordIn(
	DWORD dw,
	ULONG ul,
	LONG lg,
	LARGE_INTEGER li,
	ULARGE_INTEGER uli)
{
    SCODE sc = S_OK;

    //	compare each parameter with the expected value
    if (dw != 1)
	sc |= 1;

    if (ul != 2)
	sc |= 2;

    if (lg != 3)
	sc |= 4;

    if (li.LowPart != 4 ||
	li.HighPart != 5)
	sc |= 8;

    if (uli.LowPart != 6 ||
	uli.HighPart != 7)
	sc |= 16;

    return sc;
}


STDMETHODIMP CRpcTypes::DwordOut(
	DWORD *pdw,
	ULONG *pul,
	LONG *plg,
	LARGE_INTEGER *pli,
	ULARGE_INTEGER *puli)
{
    //	copy in the expected return values
    *pdw = 1;
    *pul = 2;
    *plg = 3;

    pli->LowPart = 4;
    pli->HighPart = 5;

    puli->LowPart = 6;
    puli->HighPart = 7;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTypes::WindowsIn
//
//  Synopsis:	tests passing windows structure parameters
//
//  Arguments:
//
//  Returns:	S_OK or error code with parm #s or'd in
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CRpcTypes::WindowsIn(
	POINTL pointl,
	SIZEL sizel,
	RECTL rectl,
	FILETIME filetime,
	PALETTEENTRY paletteentry,
	LOGPALETTE *plogpalette)
{
    SCODE sc = S_OK;

    // check the pointl structure
    if (pointl.x != 1 || pointl.y != 2)
	sc |= 1;

    if (sizel.cx != 3 || sizel.cy != 4)
	sc |= 2;

    if (filetime.dwLowDateTime != 5 || filetime.dwHighDateTime != 6)
	sc |= 4;

    if (paletteentry.peRed   != 7 ||
	paletteentry.peGreen != 8 ||
	paletteentry.peBlue  != 9 ||
	paletteentry.peFlags != 10)
	sc |= 8;

    if (plogpalette->palVersion != 11 ||
	plogpalette->palNumEntries != 1)
	sc |= 16;

    if (plogpalette->palPalEntry[0].peRed != 12)
	sc |= 32;

    return sc;
}


STDMETHODIMP CRpcTypes::WindowsOut(
	POINTL *ppointl,
	SIZEL *psizel,
	RECTL *prectl,
	FILETIME *pfiletime,
	PALETTEENTRY *ppaletteentry,
	LOGPALETTE **pplogpalette)
{
    ppointl->x = 1;
    ppointl->y = 2;

    psizel->cx = 3;
    psizel->cy = 4;

    pfiletime->dwLowDateTime = 5;
    pfiletime->dwHighDateTime = 6;

    ppaletteentry->peRed   = 7;
    ppaletteentry->peGreen = 8;
    ppaletteentry->peBlue  = 9;
    ppaletteentry->peFlags = 10;

    *pplogpalette = new LOGPALETTE;
    (*pplogpalette)->palVersion = 11;
    (*pplogpalette)->palNumEntries = 1;
    (*pplogpalette)->palPalEntry[0].peRed = 12;

    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTypes::OleData
//
//  Synopsis:	tests passing OLE2 structure parameters
//
//  Arguments:
//
//  Returns:	S_OK or error code with parm #s or'd in
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CRpcTypes::OleDataIn(
	STATDATA statdata,
	STATSTG statstg,
	STGMEDIUM stgmedium,
	FORMATETC formatetc,
	DVTARGETDEVICE *pdvtargetdevice)
{
    SCODE sc = S_OK;

    return sc;
}


STDMETHODIMP CRpcTypes::OleDataOut(
	STATDATA *pstatdata,
	STATSTG *pstatstg,
	STGMEDIUM *pstgmedium,
	FORMATETC *pformatetc,
	DVTARGETDEVICE **ppdvtargetdevice)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTypes::VoidPtr
//
//  Synopsis:	tests passing arrays of byte parameters
//
//  Arguments:
//
//  Returns:	S_OK or error code with parm #s or'd in
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CRpcTypes::VoidPtrIn(
	ULONG cb,
	void *pv)
{
    SCODE sc = S_OK;
    BYTE *pb = (BYTE *)pv;

    //	check the contents of the buffer
    for (ULONG i=0; i<cb, i++; pb++)
    {
	if (*pb != (BYTE)i)
	    sc = E_FAIL;
    }

    return sc;
}


STDMETHODIMP CRpcTypes::VoidPtrOut(
	void *pv,
	ULONG cb,
	ULONG *pcb)
{
    BYTE *pb = (BYTE *)pv;

    *pcb = 0;

    //	fill the buffer
    for (ULONG i=0; i<cb; i++, pb++)
    {
	*pb = (BYTE)i;
    }

    *pcb = cb;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\crpc.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:	crpc.cxx
//
//  Contents:	implementations for rpc test
//
//  Functions:
//		CRpcTest::CRpcTest
//		CRpcTest::~CRpcTest
//		CRpcTest::QueryInterface
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <crpc.hxx>	  //	class definition

IUnknown *gpPunk = NULL;

//+-------------------------------------------------------------------------
//
//  Method:	CRpcTest::CRpcTest
//
//  Synopsis:	Creates the application window
//
//  Arguments:	[pisb] - ISysBind instance
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CRpcTest::CRpcTest(void) : _punkIn(NULL)
{
    GlobalRefs(TRUE);

    ENLIST_TRACKING(CRpcTest);
}


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTest::~CRpcTest
//
//  Synopsis:	Cleans up object
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
CRpcTest::~CRpcTest(void)
{
    GlobalRefs(FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTest::QueryInterface
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[ifid] - interface instance requested
//		[ppunk] - where to put pointer to interface instance
//
//  Returns:	S_OK or ERROR_BAD_COMMAND
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRpcTest::QueryInterface(REFIID riid, void **ppunk)
{
    SCODE sc = S_OK;

    if (IsEqualIID(riid,IID_IUnknown) ||
	IsEqualIID(riid,IID_IRpcTest))
    {
	// Increase the reference count
	*ppunk = (void *)(IRpcTest *) this;
	AddRef();
    }
    else
    {
	*ppunk = NULL;
	sc = E_NOINTERFACE;
    }

    return sc;
}


//+-------------------------------------------------------------------------
//
//  Method:	CRpcTest::Void
//
//  Synopsis:	tests passing no parameters
//
//  Arguments:
//
//  Returns:	S_OK or ERROR_BAD_COMMAND
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRpcTest::Void(void)
{
    return S_OK;
}

STDMETHODIMP CRpcTest::VoidRC(void)
{
    return S_OK;
}

STDMETHODIMP CRpcTest::VoidPtrIn(ULONG cb, BYTE *pv)
{
    return S_OK;
}
    
STDMETHODIMP CRpcTest::VoidPtrOut(ULONG cb, ULONG *pcb, BYTE *pv)
{
    memset(pv, 1, cb);
    *pcb = cb;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	CRpcTest::Dword
//
//  Synopsis:	tests passing dwords in and out
//
//  Arguments:
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRpcTest::DwordIn(DWORD dw)
{
    return S_OK;
}


STDMETHODIMP CRpcTest::DwordOut(DWORD *pdw)
{
    *pdw = 1;
    return S_OK;
}


STDMETHODIMP CRpcTest::DwordInOut(DWORD *pdw)
{
    *pdw = 1;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	CRpcTest::Li
//
//  Synopsis:	tests passing LARGE INTEGERS in and out
//
//  Arguments:
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CRpcTest::LiIn(LARGE_INTEGER li)
{
    return S_OK;
}


STDMETHODIMP CRpcTest::LiOut(LARGE_INTEGER *pli)
{
    pli->LowPart = 0;
    pli->HighPart = 1;
    return S_OK;
}


STDMETHODIMP CRpcTest::ULiIn(ULARGE_INTEGER uli)
{
    return S_OK;
}


STDMETHODIMP CRpcTest::ULiOut(ULARGE_INTEGER *puli)
{
    puli->LowPart = 0;
    puli->HighPart = 1;
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	CRpcTest::String
//
//  Synopsis:	tests passing strings in and out
//
//  Arguments:
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRpcTest::StringIn(LPOLESTR pwsz)
{
    return S_OK;
}


STDMETHODIMP CRpcTest::StringOut(LPOLESTR *ppwsz)
{
    // LPOLESTR pwsz = new OLECHAR[80];
    // *ppwsz = pwsz;
    olestrcpy(*ppwsz, OLESTR("Hello World This is a Message"));
    return S_OK;
}


STDMETHODIMP CRpcTest::StringInOut(LPOLESTR pwsz)
{
    olestrcpy(pwsz, OLESTR("Hello World This is a Message"));
    return S_OK;
}



//+-------------------------------------------------------------------------
//
//  Function:	CRpcTest::Guid
//
//  Synopsis:	tests passing GUIDs in and out
//
//  Arguments:
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRpcTest::GuidIn(GUID guid)
{
    return S_OK;
}

STDMETHODIMP CRpcTest::GuidOut(GUID *piid)
{
    memcpy(piid, &IID_IRpcTest, sizeof(GUID));
    return  S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	CRpcTest::IUnknown
//
//  Synopsis:	tests passing IUnknown interfaces in and out
//
//  Arguments:
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRpcTest::IUnknownIn(IUnknown *punkIn)
{
    return S_OK;
}

STDMETHODIMP CRpcTest::IUnknownOut(IUnknown **ppunk)
{
    gpPunk->AddRef();
    *ppunk = gpPunk;
    return S_OK;
}

STDMETHODIMP CRpcTest::IUnknownInKeep(IUnknown *punkIn)
{
    if (punkIn)
    {
	punkIn->AddRef();

	if (punkIn != _punkIn)
	{
	    _punkIn->Release();
	    _punkIn = punkIn;
	}
    }

    return S_OK;
}

STDMETHODIMP CRpcTest::IUnknownInRelease()
{
    if (_punkIn)
    {
	_punkIn->Release();
    }

    return S_OK;
}

STDMETHODIMP CRpcTest::IUnknownOutKeep(IUnknown **ppunk)
{
    *ppunk = (IUnknown *)this;
    AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:	CRpcTest::Interface
//
//  Synopsis:	tests passing whose iid is specified by riid in and out
//
//  Arguments:
//
//  Returns:	S_OK
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
STDMETHODIMP CRpcTest::InterfaceIn(REFIID riid, IUnknown *punk)
{
    return S_OK;
}

STDMETHODIMP CRpcTest::InterfaceOut(REFIID riid, IUnknown **ppunk)
{
    this->QueryInterface(riid, (void **)ppunk);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\ctballs.cxx ===
#pragma hdrstop

#include    <ctballs.hxx>
#include    <sem32.hxx>


// We need a semaphore to synchronize loads and releases.
CMutexSem mxsLoadRelease;

SAFE_INTERFACE_PTR(XIStream, IStream)

#define XPOS L"XPOS"
#define YPOS L"YPOS"


HRESULT ReadPos(IStorage *pstg, LPOLESTR pwszStream, ULONG *pulPos)
{
    HRESULT hr;

    BEGIN_BLOCK

	XIStream xstrm;

	// Read the streams for xpos and ypos
	hr = pstg->OpenStream(pwszStream, NULL,
	    STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, &xstrm);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	ULONG cb;

	hr = xstrm->Read(pulPos, sizeof(*pulPos), &cb);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	hr = ResultFromScode(S_OK);

    END_BLOCK

    return hr;
}

HRESULT WritePos(IStorage *pstg, LPOLESTR pwszStream, ULONG ulPos)
{
    HRESULT hr;

    BEGIN_BLOCK

	XIStream xstrm;

	// Read the streams for xpos and ypos
	hr = pstg->CreateStream(pwszStream,
	    STGM_CREATE | STGM_WRITE | STGM_SHARE_EXCLUSIVE, NULL, NULL,
		&xstrm);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}


	ULONG cb;

	hr = xstrm->Write(&ulPos, sizeof(ulPos), &cb);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	hr = ResultFromScode(S_OK);

    END_BLOCK

    return hr;
}

CTestBalls::CTestBalls(REFCLSID rclsid)
    : _rclsid(rclsid), _fDirty(FALSE), _xPos(0), _yPos(0),
	_fSaveInprogress(FALSE), _pstg(NULL), _dwRegister(0), _cRefs(1)
{
    // Use as a flag for whether a file name has been assigned
    _awszCurFile[0] = 0;

    GlobalRefs(TRUE);
}

CTestBalls::~CTestBalls(void)
{
    if (_pstg != NULL)
    {
	// Release the storage because we are done with it
	ULONG ulCnt = _pstg->Release();

#if 0
	// this test is not valud when running stress
	if (ulCnt != 0)
	{
	    DebugBreak();
	}
#endif
    }

    if (_dwRegister)
    {
	IRunningObjectTable *prot;
	GetRunningObjectTable(NULL, &prot);
	prot->Revoke(_dwRegister);
	prot->Release();
    }

    GlobalRefs(FALSE);
}

STDMETHODIMP CTestBalls::QueryInterface(REFIID iid, void **ppv)
{
    HRESULT hr = ResultFromScode(S_OK);

    // We support IUnknown, IPersistFile and IBalls
    if (IsEqualIID(iid, IID_IUnknown))
    {
	*ppv = (IBalls *) this;
    }
    else if (IsEqualIID(iid, IID_IPersistFile))
    {
	*ppv = (IPersistFile *) this;
    }
    else if (IsEqualIID(iid, IID_IPersistStorage))
    {
	*ppv = (IPersistStorage *) this;
    }
    else if (IsEqualIID(iid, IID_IBalls))
    {
	*ppv = (IBalls *) this;
    }
    else
    {
	*ppv = NULL;
	hr = ResultFromScode(E_NOINTERFACE);
    }

    if (SUCCEEDED(hr))
    {
	AddRef();
    }

    return hr;
}

STDMETHODIMP_(ULONG) CTestBalls::AddRef(void)
{
    InterlockedIncrement(&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) CTestBalls::Release(void)
{
    CLock lck(mxsLoadRelease);

    if (InterlockedDecrement(&_cRefs) == 0)
    {
	delete this;
	return 0;
    }

    return _cRefs;
}

STDMETHODIMP CTestBalls::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = _rclsid;
    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestBalls::IsDirty()
{
    return (_fDirty) ? ResultFromScode(S_OK) : ResultFromScode(S_FALSE);
}

STDMETHODIMP CTestBalls::Load(LPCOLESTR lpszFileName, DWORD grfMode)
{
    CLock lck(mxsLoadRelease);

    HRESULT hr;

    BEGIN_BLOCK

	hr = StgOpenStorage(lpszFileName, NULL,
	    STGM_READWRITE | STGM_SHARE_EXCLUSIVE, NULL, NULL, &_pstg);

	if (FAILED(hr))
	{
#if 0
	    //	this test is not valid when running stress
	    if (hr == STG_E_LOCKVIOLATION)
	    {
		DebugBreak();
	    }
#endif
	    EXIT_BLOCK;
	}

	// Get the saved xposition
	hr = GetData();

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	// Since everything went Ok save the file name
	olestrcpy(_awszCurFile, lpszFileName);

	// Create a file moniker for the object
	IMoniker *pmk;
	CreateFileMoniker(lpszFileName, &pmk);

	// Register it in the running object table.
	IRunningObjectTable *prot;
	GetRunningObjectTable(NULL, &prot);
	prot->Register(NULL, (IPersistFile *) this, pmk, &_dwRegister);

	// Release the temporary objects
	pmk->Release();
	prot->Release();

    END_BLOCK

    return hr;
}

STDMETHODIMP CTestBalls::Save(LPCOLESTR lpszFileName, BOOL fRemember)
{
    HRESULT hr;

    BEGIN_BLOCK

	IStorage *pstgNew;

	// Save the data
	if (olestrcmp(lpszFileName, _awszCurFile) == 0)
	{
	    pstgNew = _pstg;
	    _fDirty = FALSE;
	}
	else
	{
	    hr = StgCreateDocfile(lpszFileName,
		STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
		    NULL, &pstgNew);
	}

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	WriteClassStg(pstgNew, _rclsid);

	hr = SaveData(pstgNew);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	if (fRemember)
	{
	    // Save the file name
	    olestrcpy(_awszCurFile, lpszFileName);


	    // Replace the storage
	    if (_pstg && pstgNew != _pstg)
	    {
		_pstg->Release();
	    }
	    _pstg = pstgNew;

	    _fDirty = FALSE;
	}
	else
	{
	    pstgNew->Release();
	}

	_fSaveInprogress = TRUE;

	hr = ResultFromScode(S_OK);

    END_BLOCK;

    return hr;
}

STDMETHODIMP CTestBalls::SaveCompleted(LPCOLESTR lpszFileName)
{
    _fSaveInprogress = FALSE;
    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestBalls::GetCurFile(LPOLESTR FAR * lpszFileName)
{
    // Allocate a buffer for the file and copy in the data
    if (_awszCurFile[0] == 0)
    {
	return ResultFromScode(S_FALSE);
    }


    IMalloc *pIMalloc;

    HRESULT hr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);

    if (SUCCEEDED(hr))
    {
	*lpszFileName = (WCHAR *) pIMalloc->Alloc(
	    olestrlen((_awszCurFile) + 1) * sizeof(WCHAR));

	olestrcpy(*lpszFileName, _awszCurFile);

	hr = ResultFromScode(S_OK);
    }

    return hr;
}

STDMETHODIMP CTestBalls::MoveBall(ULONG xPos, ULONG yPos)
{
    if (!_fSaveInprogress)
    {
	_fDirty = TRUE;
	_xPos = xPos;
	_yPos = yPos;
	return S_OK;
    }

    // Can't change state because a save is still pending
    return ResultFromScode(E_UNEXPECTED);
}

STDMETHODIMP CTestBalls::GetBallPos(ULONG *xPos, ULONG *yPos)
{
    *xPos = _xPos;
    *yPos = _yPos;
    return S_OK;
}

STDMETHODIMP CTestBalls::IsOverLapped(IBalls *pIBall)
{
    ULONG xPos;
    ULONG yPos;

    HRESULT hr = pIBall->GetBallPos(&xPos, &yPos);

    if (SUCCEEDED(hr))
    {
	if ((xPos == _xPos) && (yPos == _yPos))
	{
	    hr = ResultFromScode(S_OK);
	}
	else
	{
	    hr = ResultFromScode(S_FALSE);
	}
    }

    return hr;
}

STDMETHODIMP CTestBalls::IsContainedIn(ICube *pICube)
{
    ULONG xPos;
    ULONG yPos;

    HRESULT hr = pICube->GetCubePos(&xPos, &yPos);

    if (SUCCEEDED(hr))
    {
	if ((xPos == _xPos) && (yPos == _yPos))
	{
	    hr = ResultFromScode(S_OK);
	}
	else
	{
	    hr = ResultFromScode(S_FALSE);
	}
    }

    return hr;

}

STDMETHODIMP CTestBalls::Clone(IBalls **ppIBall)
{
    CTestBalls *ptballs = new CTestBalls(_rclsid);

    ptballs->_xPos = _xPos;
    ptballs->_yPos = _yPos;
    ptballs->_fDirty = _fDirty;
    _pstg->AddRef();
    ptballs->_pstg = _pstg;
    lstrcpy(ptballs->_awszCurFile, _awszCurFile);
    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestBalls::Echo(IUnknown *punkIn, IUnknown**ppunkOut)
{
    *ppunkOut = punkIn;
    return S_OK;
}

STDMETHODIMP CTestBalls::InitNew(LPSTORAGE pStg)
{
    pStg->AddRef();
    _pstg = pStg;
    WriteClassStg(_pstg, _rclsid);

    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestBalls::Load(LPSTORAGE pStg)
{
    HRESULT hr;

    _pstg = pStg;

    hr = GetData();

    if (SUCCEEDED(hr))
    {
	_pstg->AddRef();
    }
    else
    {
	_pstg = NULL;
    }

    return hr;
}

STDMETHODIMP CTestBalls::Save(
    LPSTORAGE pStgSave,
    BOOL fSameAsLoad)
{
    HRESULT hr;

    if (!fSameAsLoad)
    {
	if (_pstg)
	    _pstg->Release();

	_pstg = pStgSave;

	pStgSave->AddRef();
    }
    else
    {
	pStgSave = _pstg;
    }

    WriteClassStg(pStgSave, _rclsid);

    hr = SaveData(pStgSave);

    _fSaveInprogress = TRUE;

    return hr;
}

STDMETHODIMP CTestBalls::SaveCompleted(LPSTORAGE pStgSaved)
{
    _fSaveInprogress = FALSE;
    return ResultFromScode(S_OK);
}

STDMETHODIMP CTestBalls::HandsOffStorage(void)
{
    // Figure out what to do here!
    return ResultFromScode(E_UNEXPECTED);
}

HRESULT	CTestBalls::GetData(void)
{
    HRESULT hr;

    BEGIN_BLOCK

	// Get the saved xposition
	hr = ReadPos(_pstg, XPOS, &_xPos);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	// Get the saved yposition
	hr = ReadPos(_pstg, YPOS, &_yPos);

    END_BLOCK

    return hr;
}

HRESULT	CTestBalls::SaveData(IStorage *pstg)
{
    HRESULT hr;

    BEGIN_BLOCK

	// Get the saved xposition
	hr = WritePos(pstg, XPOS, _xPos);

	if (FAILED(hr))
	{
	    EXIT_BLOCK;
	}

	// Get the saved yposition
	hr = WritePos(pstg, YPOS, _yPos);


    END_BLOCK

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\common.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:	common.h
//
//  Contents:	headers shared by sources in common and in the servers and
//		clients.
//
//  History:	04-Feb-94 Rickhi	Created
//
//--------------------------------------------------------------------------
#include    <windows.h>
#include    <ole2.h>

#ifdef THREADING_SUPPORT
#include    <olecairo.h>    //
#include    <oleext.h>	    // OleInitializeEx, etc.
#endif

#include    <srvmain.hxx>   // COM Server entry points


#ifdef WIN32
#define olestrlen(x)	wcslen(x)
#define olestrcmp(x,y)	wcscmp(x,y)
#define olestrcpy(x,y)	wcscpy(x,y)
#define olestrcat(x,y)	wcscat(x,y)
#define olestrchr(x,y)	wcsrchr(x,y)
#else
#define olestrlen(x)	strlen(x)
#define olestrcmp(x,y)	strcmp(x,y)
#define olestrcpy(x,y)	strcpy(x,y)
#define olestrcat(x,y)	strcat(x,y)
#define olestrchr(x,y)	strchr(x,y)
#endif


#ifdef	WIN32
#ifdef	UNICODE
#define TEXT_TO_OLESTR(ole,wsz) wcscpy(ole,wsz)
#define OLESTR_TO_TEXT(wsz,ole) wcscpy(wsz,ole)
#else
#define TEXT_TO_OLESTR(ole,str) mbstowcs(ole,str,strlen(str)+1)
#define OLESTR_TO_TEXT(str,ole) wcstombs(str,ole,wcslen(ole)+1)
#endif	// UNICODE
#else
#ifdef	UNICODE
#define TEXT_TO_OLESTR(ole,wsz) wcstombs(ole,wsz,wcslen(wsz)+1)
#define OLESTR_TO_TEXT(wsz,ole) mbstowcs(wsz,ole,strlen(ole)+1)
#else
#define TEXT_TO_OLESTR(ole,str) strcpy(ole,str)
#define OLESTR_TO_TEXT(str,ole) strcpy(str,ole)
#endif	// UNICODE
#endif	// WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\cubescf.cxx ===
//+-------------------------------------------------------------------
//
//  File:	cubescf.cxx
//
//  Contents:	test class factory object implementation
//
//  Classes:	CCubesClassFactory
//
//  Functions:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <cubescf.hxx>	//  class definiton
#include    <ccubes.hxx>	//  CCubes defines


const GUID CLSID_Cubes =
    {0x0000013b,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


//+-------------------------------------------------------------------
//
//  Member:	CCubesClassFactory::CCubesClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

CCubesClassFactory::CCubesClassFactory(void)
{
    ENLIST_TRACKING(CCubesClassFactory);
}


//+-------------------------------------------------------------------
//
//  Member:	CCubesClassFactory::~CCubesClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

CCubesClassFactory::~CCubesClassFactory(void)
{
    //	automatic actions do the rest of the work
}


//+-------------------------------------------------------------------
//
//  Member:	CCubesClassFactory::QueryInterface, public
//
//  Algorithm:	if the interface is not one implemented by us,
//		pass the request to the proxy manager
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CCubesClassFactory::QueryInterface(REFIID riid, void **ppUnk)
{
    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IClassFactory))
    {
	*ppUnk = (void *)(IClassFactory *) this;
	AddRef();
    }
    else
    {
	*ppUnk = NULL;
	sc = E_NOINTERFACE;
    }
    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CCubesClassFactory::CreateInstance, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CCubesClassFactory::CreateInstance(IUnknown *punkOuter,
						REFIID	 riid,
						void	 **ppunkObject)
{
    SCODE sc = E_OUTOFMEMORY;

    *ppunkObject = NULL;	//  in case of failure

    //	create a Cube object.
    ICube *pCubes = (ICube *) new CCube();

    if (pCubes)
    {
	//  get the interface the caller wants to use
	sc = pCubes->QueryInterface(riid, ppunkObject);

	//  release our hold on the Cube, since the QI got a hold for
	//  the client.
	pCubes->Release();
    }

    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CCubesClassFactory::LockServer, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CCubesClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
	GlobalRefs(TRUE);
    else
	GlobalRefs(FALSE);

    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\dataobj.cxx ===
//+-------------------------------------------------------------------
//
//  File:	dataobj.cxx
//
//  Contents:   IDataObject methods of CTestEmbed class.
//
//  Classes:    CTestEmbed - IDataObject implementation
//
//  History:	7-Dec-92   DeanE   Created
//
//---------------------------------------------------------------------
#pragma optimize("",off)

#include    <pch.cxx>
#pragma     hdrstop
#include    <embed.hxx>
#include    <dataobj.hxx>


//+-------------------------------------------------------------------
//  Member:     CDataObject::CDataObject()
//
//  Synopsis:   The constructor for CDataObject.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CDataObject::CDataObject(CTestEmbed *pteObject)
{
    _cRef      = 1;
    _pDAHolder = NULL;
    _pteObject = pteObject;
}


//+-------------------------------------------------------------------
//  Member:     CDataObject::~CDataObject()
//
//  Synopsis:   The destructor for CDataObject.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CDataObject::~CDataObject()
{
    // _cRef count should be 1
    if (1 != _cRef)
    {
        // BUGBUG - Log error
        // Someone hasn't released one of these - Log error
    }
    return;
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::QueryInterface
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::QueryInterface(REFIID iid, void FAR * FAR *ppv)
{
    return(_pteObject->QueryInterface(iid, ppv));
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::AddRef
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDataObject::AddRef(void)
{
    ++_cRef;
    return(_pteObject->AddRef());
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::Release
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDataObject::Release(void)
{
    --_cRef;
    return(_pteObject->Release());
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::GetData
//
//  Synopsis:   See spec 2.00.09 p129.  Retrieve data for this object
//              using the FORMATETC passed.
//
//  Parameters: [pformatetcIn] - The format caller wants returned data
//              [pmedium]      - Returned data
//
//  Returns:    S_OK, or E_FORMAT if we don't support the format requested
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::GetData(
        LPFORMATETC pformatetcIn,
        LPSTGMEDIUM pmedium)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::GetDataHere
//
//  Synopsis:   See spec 2.00.09 p130.  Like GetData, but the pmedium is
//              allocated and ready for us to use.
//
//  Parameters: [pformatetc] - The format caller wants returned data
//              [pmedium]    - STGMEDIUM object ready for our use
//
//  Returns:    S_OK, E_FORMAT
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::GetDataHere(
        LPFORMATETC pformatetc,
        LPSTGMEDIUM pmedium)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::QueryGetData
//
//  Synopsis:   See spec 2.00.09 p130.  Answer if the format requested
//              would be honored by GetData.
//
//  Parameters: [pformatetc] - The format being queried about
//
//  Returns:    S_OK or S_FALSE
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::QueryGetData(LPFORMATETC pformatetc)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::GetCanonicalFormatEtc
//
//  Synopsis:   See spec 2.00.09 p131
//
//  Parameters: [pformatetc]    -
//              [pformatetcOut] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::GetCanonicalFormatEtc(
        LPFORMATETC pformatetc,
        LPFORMATETC pformatetcOut)

{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::SetData
//
//  Synopsis:   See spec 2.00.09 p131.
//
//  Parameters: [pformatetc] -
//              [pmedium]    -
//              [fRelease]   -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::SetData(
        LPFORMATETC    pformatetc,
        STGMEDIUM FAR *pmedium,
        BOOL           fRelease)
{
    // BUGBUG - NYI
    return(DV_E_CLIPFORMAT);
}


//+-------------------------------------------------------------------
//  Method:     CDataObject::EnumFormatEtc
//
//  Synopsis:   See spec 2.00.09 p131.
//
//  Parameters: [dwDirection]    -
//              [ppenmFormatEtc] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::EnumFormatEtc(
        DWORD                dwDirection,
        LPENUMFORMATETC FAR *ppenmFormatEtc)
{
    // BUGBUG - NYI
    *ppenmFormatEtc = NULL;
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:	CDataObject::DAdvise
//
//  Synopsis:   See spec 2.00.09 p132
//
//  Parameters: [pFormatetc]    -
//              [advf]          -
//              [pAdvSink]      -
//              [pdwConnection] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::DAdvise(
        FORMATETC FAR *pFormatetc,
        DWORD          advf,
        LPADVISESINK   pAdvSink,
        DWORD     FAR *pdwConnection)
{
    if (NULL == _pDAHolder)
    {
        if (S_OK != CreateDataAdviseHolder(&_pDAHolder))
        {
            return(E_OUTOFMEMORY);
        }
    }

    return(_pDAHolder->Advise(this, pFormatetc, advf, pAdvSink, pdwConnection));
}


//+-------------------------------------------------------------------
//  Method:	CDataObject::DUnadvise
//
//  Synopsis:   See spec 2.00.09 p133
//
//  Parameters: [dwConnection] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::DUnadvise(DWORD dwConnection)
{
    if (NULL == _pDAHolder)
    {
        // Nobody is registered
        return(E_INVALIDARG);
    }

    return(_pDAHolder->Unadvise(dwConnection));
}


//+-------------------------------------------------------------------
//  Method:	CDataObject::EnumDAdvise
//
//  Synopsis:   See spec 2.00.09 p133
//
//  Parameters: [ppenmAdvise] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CDataObject::EnumDAdvise(LPENUMSTATDATA FAR *ppenmAdvise)
{
    if (NULL == _pDAHolder)
    {
	return(E_FAIL);
    }

    return(_pDAHolder->EnumAdvise(ppenmAdvise));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\ctext.cxx ===
//+-------------------------------------------------------------------
//
//  File:	ctext.cxx
//
//  Contents:	Implementation for CRegTextFile class
//
//  Classes:	None.
//
//  Functions:	CRegTextFile::GetString -- get a string & convert to unicode
//		CRegTextFile::GetLong -- get a long from the file
//
//  History:	18-Dec-91   Ricksa	Created
//		19-Mar-92   Rickhi	Skip over comment lines in file
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma hdrstop
#include    <ctext.hxx>


TCHAR CRegTextFile::s_awcSysDir[MAX_PATH];

int CRegTextFile::s_cSysDir = 0;

//+-------------------------------------------------------------------
//
//  Member:	CRegTextFile::CRegTextFile, public
//
//  Synopsis:	Open a file
//
//  Effects:	File is open
//
//  Arguments:	[pszFile] -- name of file to open
//
//  Requires:	Nothing.
//
//  Returns:	Returns pointer to the file opened.
//
//  Signals:	CException.
//
//  Modifies:	None.
//
//  Derivation: None.
//
//  Algorithm:	Attempt to open the file & throw an exception if
//		the open request fails.
//
//  History:	19-Dec-91   Ricksa	Created
//
//  Notes:
//
//--------------------------------------------------------------------
CRegTextFile::CRegTextFile(LPSTR pszFile)
{
    if (lstrcmpA(pszFile, "") == 0)
    {
	_fp = stdin;
    }
    else if ((_fp = fopen(pszFile, "r")) == NULL)
    {
	printf("Open of file failed %s", pszFile);
    }

    if (s_cSysDir == 0)
    {
	// Get the system directory -- we divide by 2 because we want
	// cSysDir to be the number of characters *not* the number of
	// bytes.
	s_cSysDir = GetSystemDirectory(s_awcSysDir, sizeof(s_awcSysDir))
	    / sizeof(TCHAR);
    }
}




//+-------------------------------------------------------------------
//
//  Member:	CRegTextFile::~CRegTextFile, public
//
//  Synopsis:	Destroy object and close the file.
//
//  Effects:	Object is destroyed.
//
//  Arguments:	None.
//
//  Requires:	Valid pointer to CRegTextFile.
//
//  Returns:	Nothing.
//
//  Signals:	None.
//
//  Modifies:	Nothing global.
//
//  Derivation: None.
//
//  Algorithm:	Simply closes the file.
//
//  History:	19-Dec-91   Ricksa	Created
//
//  Notes:
//
//--------------------------------------------------------------------
CRegTextFile::~CRegTextFile(void)
{
    if (_fp != stdin)
    {
	fclose(_fp);
    }
}




//+-------------------------------------------------------------------
//
//  Member:	CRegTextFile::GetString, public
//
//  Synopsis:	Reads an ASCII string from the
//
//  Effects:	Outputs a buffer filled with UNICODE text.
//
//  Arguments:	None.
//
//  Requires:	Pointer to CRegTextFile object.
//
//  Returns:	Pointer to a buffer filled with Unicode text.
//
//  Signals:	CException
//
//  Algorithm:	Read a line of ASCII text and convert it into
//		Unicode and return a pointer to the data.
//
//  History:	19-Dec-91   Ricksa	Created
//
//  Notes:	This method is not multithreaded and the output
//		buffer will be reset on the next call to GetString.
//
//--------------------------------------------------------------------
LPTSTR
CRegTextFile::GetString(void)
{
    do
    {
	if (fgets(_abuf, sizeof(_abuf), _fp) == NULL)
	{
	    printf("Read of file failed");
	}

    } while (_abuf[0] == COMMENT_MARK);


    int len = lstrlenA(_abuf);
    int last = len - 1;

    // Hack needed because standard libraries think '\r' is part
    // of a string.
    if (_abuf[last] == 0x0a)
    {
	_abuf[last] = '\0';
	len = last;
    }

#ifdef UNICODE
    // Convert to wide characters including trailing null
    mbstowcs(_awcbuf, _abuf, len + 1);
#else
    memcpy(_awcbuf, _abuf, len+1);
#endif

    // return new string
    return _awcbuf;
}




//+-------------------------------------------------------------------
//
//  Member:	CRegTextFile::GetLong
//
//  Synopsis:	Get a string from a file and convert it to an unsigned long.
//
//  Arguments:	None.
//
//  Requires:	Pointer to valid CRegTextFile object.
//
//  Returns:	ULONG read from file.
//
//  Signals:	CException.
//
//  Algorithm:	Read string and covert data to a long.
//
//  History:	19-Dec-91   Ricksa	Created
//
//  Notes:	This method does no error checking.
//
//--------------------------------------------------------------------
ULONG
CRegTextFile::GetLong(void)
{
    do
    {
	if (fgets(_abuf, sizeof(_abuf), _fp) == NULL)
	{
	    printf("Read of long failed");
	}
    } while (_abuf[0] == COMMENT_MARK);

    return atol(_abuf);
}



//+-------------------------------------------------------------------
//
//  Member:	CRegTextFile::GetGUID
//
//  Synopsis:	Get a string from a file and convert it to a GUID.
//
//  Arguments:	None.
//
//  Returns:	a pointer to the GUID in the string buffer.
//
//  Signals:	CException.
//
//  Algorithm:	Read string and covert data to a GUID.
//
//  History:	19-Dec-91   Ricksa	Created
//
//  Notes:	This is not guaranteed to work in a multithreaded
//		environment.
//
//--------------------------------------------------------------------
GUID *
CRegTextFile::GetGUID(void)
{
    GUID *pguid = (GUID *) _awcbuf;

    do
    {
	if (fgets(_abuf, sizeof(_abuf), _fp) == NULL)
	{
	    printf("Read of GUID failed");
	}
    } while (_abuf[0] == COMMENT_MARK);


    // Convert the string to a GUID
    sscanf(_abuf, "%08lX%04X%04X",
	&pguid->Data1, &pguid->Data2, &pguid->Data3);

    for (int i = 0; i < 8; i++)
    {
	int tmp;
	sscanf(_abuf + 16 + (i * 2), "%02X", &tmp);
	pguid->Data4[i] = (char) tmp;
    }

    return pguid;
}






//+-------------------------------------------------------------------
//
//  Member:	CRegTextFile::GetPath
//
//  Synopsis:	Get a path to a file system object
//
//  Returns:	a pointer to the path in the string buffer.
//
//  Algorithm:	Read string and add the system directory
//
//  History:	26-Mar-92   Ricksa	Created
//
//  Notes:	This is not guaranteed to work in a multithreaded
//		environment.
//
//--------------------------------------------------------------------
LPTSTR
CRegTextFile::GetPath(void)
{
    GetString();

    if (lstrcmpi(_awcbuf, TEXT("END_OF_FILE")) == 0)
    {
	return _awcbuf;
    }

    // Temporary buffer to store result
    TCHAR awcTmp[MAX_PATH];

    // If the first characters in the string are "@:" we
    // want to prepend the string with the system directory.
#ifdef UNICODE
    if (wcsnicmp(SYS_DIR_STR, _awcbuf, SYS_DIR_STR_LEN) == 0)
#else
    if (strnicmp(SYS_DIR_STR, _awcbuf, SYS_DIR_STR_LEN) == 0)
#endif
    {
	// Copy in the system directory
	lstrcpy(awcTmp, s_awcSysDir);

	// Copy in the relative path
	lstrcat(awcTmp, _awcbuf + SYS_DIR_STR_LEN);

	// Copy whole string to output buffer
	lstrcpy(_awcbuf, awcTmp);
    }
    else if ((_awcbuf[1] != ':') && (_awcbuf[3] != ':') && (_awcbuf[1] != '\\'))
    {
	// Convert relative path to absolute path based in the current
	// directory.
	GetCurrentDirectory(sizeof(awcTmp), awcTmp);

	// Add a slash to end of the current directory
	lstrcat(awcTmp, TEXT("\\"));

	// Copy in the relative path
	lstrcat(awcTmp, _awcbuf);

	// Copy whole string to output buffer
	lstrcpy(_awcbuf, awcTmp);
    }

    return _awcbuf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\loopscf.cxx ===
//+-------------------------------------------------------------------
//
//  File:	loopscf.cxx
//
//  Contents:	test class factory object implementation
//
//  Classes:	CLoopClassFactory
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <loopscf.hxx>   //	class definiton
#include    <cloop.hxx>	    //	CLoop defines


const GUID CLSID_Loop =
    {0x0000013c,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};



//+-------------------------------------------------------------------
//
//  Member:	CLoopClassFactory::CLoopClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

CLoopClassFactory::CLoopClassFactory(void)
{
    ENLIST_TRACKING(CLoopClassFactory);
}


//+-------------------------------------------------------------------
//
//  Member:	CLoopClassFactory::~CLoopClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

CLoopClassFactory::~CLoopClassFactory(void)
{
    //	automatic actions do the rest of the work
}


//+-------------------------------------------------------------------
//
//  Member:	CLoopClassFactory::QueryInterface, public
//
//  Algorithm:	if the interface is not one implemented by us,
//		pass the request to the proxy manager
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CLoopClassFactory::QueryInterface(REFIID riid, void **ppUnk)
{
    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IClassFactory))
    {
	*ppUnk = (void *)(IClassFactory *) this;
	AddRef();
    }
    else
    {
	*ppUnk = NULL;
	sc = E_NOINTERFACE;
    }
    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CLoopClassFactory::CreateInstance, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CLoopClassFactory::CreateInstance(IUnknown *punkOuter,
					       REFIID	riid,
					       void	**ppunkObject)
{
    SCODE sc = E_OUTOFMEMORY;

    *ppunkObject = NULL;	//  in case of failure

    //	create a ball object.
    IUnknown *punk = (IUnknown *) new CLoop();

    if (punk)
    {
	//  get the interface the caller wants to use
	sc = punk->QueryInterface(riid, ppunkObject);

	//  release our hold on the ball, since the QI got a hold for
	//  the client.
	punk->Release();
    }

    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CLoopClassFactory::LockServer, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CLoopClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
	GlobalRefs(TRUE);
    else
	GlobalRefs(FALSE);

    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\memstm.h ===
#if !defined( _MEMSTM_H_ )
#define _MEMSTM_H_

class	CMarshalMemStm;
class	CMarshalMemBytes;

//  function prototypes
STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phMem);
STDAPI_(LPLOCKBYTES) CreateMemLockBytes(DWORD cb, LPHANDLE phMem);


// CMemStm is a stream implementation on top of global shared memory MEMSTM
//
// CMemStm
// +---------+
// + pvtf    +    Shared  memory
// +---------+	 +--------------+
// + m_pMem  +-->|cb            |
// +---------+   |cRef          |
//               |hGlobal       |--->+--------------+
//               +--------------+	 | Actual Data	|
// CMemStm	       MEMSTM		 +--------------+
//
struct MEMSTM
{
    DWORD cb;               // Size of buf[]
    DWORD cRef;             // See below
    BYTE buf[4];            // The data
};

// cRef counts all CMemStm pointers to this MEMSTM plus the number of times
// a hMem handle to MEMSTM had been returned



class	CMemStm : public IStream
{
public:
    CMemStm() { m_hMem = NULL; m_pData = NULL; m_pos = 0; m_refs = 0; }
    ~CMemStm() {}

    STDMETHOD(QueryInterface) (REFIID iidInterface, void  *  * ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);


    STDMETHOD(Read) (VOID HUGEP* pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write) (VOID const HUGEP* pv, ULONG cb, ULONG *pcbWritten);
    STDMETHOD(Seek) (LARGE_INTEGER dlibMove,
		     DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize) (ULARGE_INTEGER cb);
    STDMETHOD(CopyTo) (IStream *pstm, ULARGE_INTEGER cb,
		       ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit) (DWORD grfCommitFlags);
    STDMETHOD(Revert) (void);
    STDMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
			   DWORD dwLockType);
    STDMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
			     DWORD dwLockType);
    STDMETHOD(Stat) (STATSTG *pstatstg, DWORD statflag);
    STDMETHOD(Clone)(IStream **ppstm);

    static CMemStm *Create(HANDLE hMem);

private:
    ULONG	m_refs;	     // Number of references to this CmemStm
    ULONG	m_pos;	     // Seek pointer for Read/Write
    HANDLE	m_hMem;	     // Memory Handle passed on creation
    MEMSTM  *	m_pData;     // Pointer to that memroy

    friend class CMarshalMemStm;
};




// CMemBytes is an ILockBytes implementation on top of global shared
// memory MEMBYTES
//
// CMemBytes
// +---------+
// + pvtf    +    Shared  memory
// +---------+   +--------------+
// + m_pData +-->| cb           |	 
// +---------+   | cRef         |	 
//               | hGlobal      |--->+-------------+
//               +--------------+	 | Actual data |
// CMemBytes         MEMBYTES			 +-------------+
//
struct MEMBYTES     // Bookeeping info in shared memory
{
    DWORD	cRef;		    // See below
    DWORD	cb;		    // Size of hGlobal
    HANDLE	hGlobal;	    // The data
    BOOL	fDeleteOnRelease;
};

#define LOCKBYTE_SIG (0x0046574A)

// cRef counts all CMemBytes pointers to this MEMBYTES. 
// It and fDeleteOnRelease control the GlobalFreeing of the hGlobal.



class	CMemBytes : public ILockBytes
{
public:
    CMemBytes() {m_hMem = NULL; m_pData = NULL; m_refs = 0;}
    ~CMemBytes() {}

    STDMETHOD(QueryInterface) (REFIID iidInterface, void **ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);


    STDMETHOD(ReadAt) (ULARGE_INTEGER ulOffset, VOID HUGEP *pv, ULONG cb,
		       ULONG *pcbRead);
    STDMETHOD(WriteAt) (ULARGE_INTEGER ulOffset, VOID const HUGEP *pv,
			ULONG cb, ULONG *pcbWritten);
    STDMETHOD(Flush) (void);
    STDMETHOD(SetSize) (ULARGE_INTEGER cb);
    STDMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
			   DWORD dwLockType);
    STDMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
			     DWORD dwLockType);
    STDMETHOD(Stat) (STATSTG *pstatstg, DWORD statflag);

    static CMemBytes *Create(HANDLE hMem);

private:
    DWORD	m_dwSig;	// Signature indicating this is our
				// implementation of ILockBytes: LOCKBYTE_SIG
    ULONG	m_refs;		// Normal reference count
    HANDLE	m_hMem;		// Handle for bookeeping info (MEMBYTES)
    MEMBYTES  * m_pData;	// Pointer to that memroy

//    friend GetHGlobalFromILockBytes(LPLOCKBYTES, HGLOBAL *);
    friend class CMarshalMemBytes;
};


// CMarshalMemStm can Marshal, Unmarshal CMemStm.  It is impletented as
// a seperate object accessible from CMemStm, CMemBytes: QueryIntreface of
// IMarshal on CMemStm's IStream will return an IMarshal pointer to
// CMarshalMemStm, but QueryInterface of IStream on that IMarshal will
// fail.
//
// Also QueryInterface of IUnknown on IMarshal will not return the same value
// As QueryInterface of IUnkown on the original IStream.
//
class	CMarshalMemStm : public IMarshal
{
public:
    CMarshalMemStm() {m_pMemStm = NULL; m_refs = 0; }
    ~CMarshalMemStm() {}

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID  * ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv,
				DWORD dwDestContext, LPVOID pvDestContext,
				DWORD mshlflags, LPCLSID pCid);
    STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv,
				DWORD dwDestContext, LPVOID pvDestContext,
				DWORD mshlflags, LPDWORD pSize);
    STDMETHOD(MarshalInterface)(THIS_ IStream  * pStm, REFIID riid,
				LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
				DWORD mshlflags);
    STDMETHOD(UnmarshalInterface)(THIS_ IStream  * pStm, REFIID riid,
			LPVOID	* ppv);
    STDMETHOD(ReleaseMarshalData)(THIS_ IStream  * pStm);
    STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved);

    static CMarshalMemStm * Create(CMemStm *pMemStm);

private:
    ULONG	m_refs;		// Number of references to this CmemStm
    CMemStm  *	m_pMemStm;	// Pointer to object [Un]Marshalled
    CLSID	m_clsid;	// Class of object pointed by pUnk
};


// CMarshalMemBytes can Marshal, Unmarshal CMemBytes.  It is impletented as
// a seperate object accessible from CMemBytes, CMemBytes: QueryIntreface of
// IMarshal on CMemBytes's ILocBytes will return an IMarshal pointer to
// CMarshalMemBytes, but QueryInterface of ILockBytes on that IMarshal will
// fail.
//
// Also QueryInterface of IUnknown on IMarshal will not return the same value
// as QueryInterface of IUnknown on the original ILockBytes.
//
class	CMarshalMemBytes : public IMarshal
{
public:
    CMarshalMemBytes() {m_pMemBytes = NULL; m_refs = 0;}
    ~CMarshalMemBytes() {}

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID  * ppvObj);
    STDMETHOD_(ULONG,AddRef) (void);
    STDMETHOD_(ULONG,Release) (void);

    STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv,
				DWORD dwDestContext, LPVOID pvDestContext,
				DWORD mshlflags, LPCLSID pCid);
    STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv,
				DWORD dwDestContext, LPVOID pvDestContext,
				DWORD mshlflags, LPDWORD pSize);
    STDMETHOD(MarshalInterface)(THIS_ IStream  * pStm, REFIID riid,
				LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
				DWORD mshlflags);
    STDMETHOD(UnmarshalInterface)(THIS_ IStream  * pStm, REFIID riid,
			LPVOID	* ppv);
    STDMETHOD(ReleaseMarshalData)(THIS_ IStream  * pStm);
    STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved);

    static CMarshalMemBytes* Create(CMemBytes *pMemBytes);

private:
    ULONG	m_refs;		// Number of references to this CMemBytes
    CMemBytes  *m_pMemBytes;	// Pointer to object [Un]Marshalled
    CLSID	m_clsid;	// Class of object pointed by pUnk
};


#endif // _MEMSTM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\mixedcf.cxx ===
//+-------------------------------------------------------------------
//
//  File:	mixedcf.cxx
//
//  Contents:	class factory object implementation for implementing
//		multiple classes in the same factory code.
//
//  Classes:	CMixedClassFactory
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
#include    <pch.cxx>
#pragma     hdrstop
#include    <mixedcf.hxx>    // class definiton
#include    <cqi.hxx>	     // CQI
#include    <cballs.hxx>     // CBallCtrlUnk
#include    <ccubes.hxx>     // CCubes
#include    <cloop.hxx>      // CLoop

#if 0	// These are defined in the header files, but left here for reference.
const GUID CLSID_QI =
    {0x00000140,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_QIHANDLER =
    {0x00000141,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_Balls =
    {0x0000013a,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_Loop =
    {0x0000013c,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
#endif

const GUID CLSID_Cubes =
    {0x0000013b,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


//+-------------------------------------------------------------------
//
//  Member:	CMixedClassFactory::CMixedClassFactory, public
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
CMixedClassFactory::CMixedClassFactory(REFCLSID rclsid) : _clsid(rclsid)
{
    ENLIST_TRACKING(CMixedClassFactory);
}

//+-------------------------------------------------------------------
//
//  Member:	CMixedClassFactory::~CMixedClassFactory, public
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------
CMixedClassFactory::~CMixedClassFactory(void)
{
    //	automatic actions do the rest of the work
}

//+-------------------------------------------------------------------
//
//  Member:	CMixedClassFactory::QueryInterface, public
//
//  Algorithm:	if the interface is not one implemented by us,
//		pass the request to the proxy manager
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CMixedClassFactory::QueryInterface(REFIID riid, void **ppUnk)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IClassFactory))
    {
	*ppUnk = (void *)(IClassFactory *) this;
	AddRef();
	return S_OK;
    }

    *ppUnk = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:	CMixedClassFactory::CreateInstance, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CMixedClassFactory::CreateInstance(IUnknown *punkOuter,
					     REFIID    riid,
					     void     **ppunkObject)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppunkObject = NULL;	//  in case of failure

    // create a new object.
    IUnknown *pUnk = NULL;

    if (IsEqualCLSID(_clsid, CLSID_QI) ||
	IsEqualCLSID(_clsid, CLSID_QIHANDLER))
    {
	pUnk = (IUnknown *) new CQI(_clsid);
    }
    else if (IsEqualCLSID(_clsid, CLSID_Balls))
    {
	pUnk = (IUnknown *) new CBallCtrlUnk(NULL);
    }
    else if (IsEqualCLSID(_clsid, CLSID_Cubes))
    {
	pUnk = (IUnknown *) new CCube();
    }
    else if (IsEqualCLSID(_clsid, CLSID_Loop))
    {
	pUnk = (IUnknown *) new CLoop();
    }

    if (pUnk)
    {
	//  get the interface the caller wants to use
	hr = pUnk->QueryInterface(riid, ppunkObject);
	pUnk->Release();
    }

    return  hr;
}

//+-------------------------------------------------------------------
//
//  Member:	CMixedClassFactory::LockServer, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CMixedClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
	GlobalRefs(TRUE);
    else
	GlobalRefs(FALSE);

    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\embed.cxx ===
//+-------------------------------------------------------------------
//
//  File:	embed.cxx
//
//  Contents:
//
//  Classes:    CTestEmbedCF - IClassFactory
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------

#include    <pch.cxx>
#pragma  hdrstop
#pragma optimize("",off)

class	CTestServerApp;
class	CDataObject;
class	COleObject;
class	CPersistStorage;


#include <embed.hxx>
#include <dataobj.hxx>
#include <oleobj.hxx>
#include <persist.hxx>
#include <csrvapp.hxx>


extern	HWND	g_hwndMain;


//+-------------------------------------------------------------------
//  Member:     CTestEmbedCF::CTestEmbedCF()
//
//  Synopsis:   The constructor for CTestEmbedCF.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbedCF::CTestEmbedCF(CTestServerApp *ptsaServer) : _cRef(1)
{
    _ptsaServer = ptsaServer;

    return;
}


//+-------------------------------------------------------------------
//  Member:     CTestEmbedCF::~CTestEmbedCF()
//
//  Synopsis:   The destructor for CTestEmbedCF.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbedCF::~CTestEmbedCF()
{
    _ptsaServer = NULL;
}


//+-------------------------------------------------------------------
//  Member:     CTestEmbedCF::Create()
//
//  Synopsis:   Creates a new CTestEmbedCF object.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
IClassFactory FAR* CTestEmbedCF::Create(CTestServerApp *ptsaServer)
{
    CTestEmbedCF FAR* pteCF = new FAR CTestEmbedCF(ptsaServer);
    return(pteCF);
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbedCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//              return pointer to the actual object
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbedCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, IID_IClassFactory))
    {
        *ppv = this;
	AddRef();
        return(S_OK);
    }
    else
    {
        *ppv = NULL;
        return(E_NOINTERFACE);
    }
}

STDMETHODIMP_(ULONG) CTestEmbedCF::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CTestEmbedCF::Release(void)
{
    if (--_cRef == 0)
    {
	delete this;
	return 0;
    }

    return _cRef;
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbedCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object.
//
//  Parameters: [pUnkOuter]    - Ignored.  Affects aggregation.
//              [iidInterface] - Interface ID object should support.
//              [ppv]          - Pointer to the object.
//
//  Returns:    S_OOM if object couldn't be created, or SCODE from
//              QueryInterface call.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbedCF::CreateInstance(
        IUnknown FAR  *pUnkOuter,
        REFIID         iidInterface,
        void FAR* FAR *ppv)
{
    CTestEmbed FAR *pteObj;
    SCODE           sc;

    pteObj = new FAR CTestEmbed();
    if (pteObj == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    sc = pteObj->InitObject(_ptsaServer, g_hwndMain);
    if (S_OK != sc)
    {
        delete pteObj;
        return(E_OUTOFMEMORY);
    }

    // Having created the actual object, ensure desired
    // interfaces are available.
    //
    sc = pteObj->QueryInterface(iidInterface, ppv);


    // We are done with the CTestEmbed instance - it's now referenced by ppv
    pteObj->Release();

    return(sc);
}

//+-------------------------------------------------------------------
//  Method:     CTestEmbedCF::LockServer
//
//  Synopsis:   What does this do?
//
//  Parameters: [fLock] - ???
//
//  Returns:    ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbedCF::LockServer(BOOL fLock)
{
    // BUGBUG - What does this do?
    return(E_FAIL);
}





//+-------------------------------------------------------------------
//  Method:     CTestEmbed::CTestEmbed
//
//  Synopsis:   Constructor for CTestEmbed objects
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbed::CTestEmbed() : _cRef(1)
{
    _ptsaServer  = NULL;
    _pDataObject = NULL;
    _pOleObject  = NULL;
    _pPersStg    = NULL;
    _hwnd	 = NULL;
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbed::~CTestEmbed
//
//  Synopsis:   Performs cleanup for CTestEmbed objects by releasing
//              internal pointers.
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CTestEmbed::~CTestEmbed()
{
    // Inform controlling server app this object is gone
    _ptsaServer->DecEmbeddedCount();

    // Delete all of this objects interface classes
    delete _pDataObject;
    delete _pOleObject;
    delete _pPersStg;
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbed::InitObject
//
//  Synopsis:   Initialize this CTestEmbed object - ie, set everything
//              up for actual use.
//
//  Parameters: None
//
//  Returns:    S_OK if everything is okay to use, or an error code
//
//  History:    7-Dec-92   DeanE   Created
//
//  Notes:      The state of the object must be cleaned up in case of
//              failure - so the destructor will not blow up.
//--------------------------------------------------------------------
SCODE CTestEmbed::InitObject(CTestServerApp *ptsaServer, HWND hwnd)
{
    SCODE sc = S_OK;

    // Initialize controlling server app
    if (NULL != ptsaServer)
    {
        _ptsaServer = ptsaServer;
    }
    else
    {
        sc = E_ABORT;
    }

    // Initilize this objects window handle
    _hwnd = hwnd;

    // Create a CDataObject
    if (SUCCEEDED(sc))
    {
        _pDataObject = new CDataObject(this);
        if (NULL == _pDataObject)
        {
            sc = E_ABORT;
        }
    }

    // Create a COleObject
    if (SUCCEEDED(sc))
    {
        _pOleObject = new COleObject(this);
        if (NULL == _pOleObject)
        {
            sc = E_ABORT;
        }
    }

    // Create a CPersistStorage
    if (SUCCEEDED(sc))
    {
        _pPersStg = new CPersistStorage(this);
        if (NULL == _pPersStg)
        {
            sc = E_ABORT;
        }
    }

    if (FAILED(sc))
    {
        delete _pDataObject;
        delete _pOleObject;
        delete _pPersStg;
        _pDataObject = NULL;
        _pOleObject  = NULL;
        _pPersStg    = NULL;
        _ptsaServer  = NULL;
        _hwnd        = NULL;
    }

    // Inform controlling server we are a new embedded object
    if (SUCCEEDED(sc))
    {
        _ptsaServer->IncEmbeddedCount();
    }

    return(sc);
}


//+-------------------------------------------------------------------
//  Method:     CTestEmbed::QueryInterface
//
//  Synopsis:   IUnknown, IOleObject, IPersist, IPersistStorage supported
//              return pointer to the actual object
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CTestEmbed::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    SCODE scRet;

    if (IsEqualIID(IID_IUnknown, iid))
    {
        *ppv = (IUnknown *)this;
	AddRef();
        scRet = S_OK;
    }
    else
    if (IsEqualIID(IID_IOleObject, iid))
    {
        *ppv = _pOleObject;
	AddRef();
        scRet = S_OK;
    }
    else
    if (IsEqualIID(IID_IPersist, iid) || IsEqualIID(IID_IPersistStorage, iid))
    {
        *ppv = _pPersStg;
	AddRef();
        scRet = S_OK;
    }
    else
    if (IsEqualIID(IID_IDataObject, iid))
    {
        *ppv = _pDataObject;
	AddRef();
        scRet = S_OK;
    }
    else
    {
        *ppv  = NULL;
        scRet = E_NOINTERFACE;
    }

    return(scRet);
}


STDMETHODIMP_(ULONG) CTestEmbed::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CTestEmbed::Release(void)
{
    if (--_cRef == 0)
    {
	delete this;
	return 0;
    }

    return _cRef;
}
SCODE CTestEmbed::GetWindow(HWND *phwnd)
{
    if (NULL != phwnd)
    {
        *phwnd = _hwnd;
        return(S_OK);
    }
    else
    {
        return(E_ABORT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       PCH.CXX
//
//  Contents:   Precompiled header
//
//  History:	04-Feb-94 Rickhi	Created
//
//--------------------------------------------------------------------------
#pragma warning(disable:4101)  // Local variable not used

#include    <common.h>
#include    <debnot.h>
#include    <math.h>
#include    <smartp.hxx>
#include    <safepnt.hxx>
#include    <sem.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\memstm.cxx ===
//+-------------------------------------------------------------------
//
//  File:	memstm.cxx
//
//  Contents:	test class for IStream
//
//  Classes:	CMemStm
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    "memstm.h"


extern "C" {
const GUID CLSID_StdMemStm =
    {0x00000301,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_StdMemBytes =
    {0x00000302,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};
}




// Shared memory IStream implementation
//

STDMETHODIMP CMemStm::QueryInterface(REFIID iidInterface, void **ppvObj)
{
    SCODE error;
    *ppvObj = NULL;

    // Two interfaces supported: IUnknown, IStream

    if (m_pData != NULL &&
       (IsEqualIID(iidInterface,IID_IStream) ||
	IsEqualIID(iidInterface,IID_IUnknown)))

    {
        m_refs++;   // A pointer to this object is returned
        *ppvObj = this;
	error = S_OK;
    }
    else
    {		    // Not accessible or unsupported interface
        *ppvObj = NULL;
	error = E_NOINTERFACE;
    }

    return error;
}


STDMETHODIMP_(ULONG) CMemStm::AddRef(void)
{
    ++ m_refs;
    return m_refs;
}


STDMETHODIMP_(ULONG) CMemStm::Release(void)
{
    --m_refs;

    if (m_refs != 0) // Still used by others
        return m_refs;

    // Matches the allocation in CMemStm::Create().
    //
    if (--m_pData->cRef == 0)
    {
        GlobalUnlock(m_hMem);
        GlobalFree(m_hMem);
    }
    else
        GlobalUnlock(m_hMem);

    delete this; // Free storage
    return 0;
}


STDMETHODIMP CMemStm::Read(void HUGEP* pb, ULONG cb, ULONG * pcbRead)
{
    SCODE error = S_OK;
    ULONG cbRead = cb;
	
    if (pcbRead)
        *pcbRead = 0L;
	
    if (cbRead + m_pos > m_pData->cb)
    {
        cbRead = m_pData->cb - m_pos;
	error = E_FAIL;
    }

    // BUGBUG - size_t limit
    memcpy(pb,m_pData->buf + m_pos,(size_t) cbRead);
    m_pos += cbRead;

    if (pcbRead != NULL)
        *pcbRead = cbRead;

    return error;
}


STDMETHODIMP CMemStm::Write(void const HUGEP* pb, ULONG cb, ULONG * pcbWritten)
{
    SCODE error = S_OK;
    ULONG cbWritten = cb;
    ULARGE_INTEGER ularge_integer;

    if (pcbWritten)
        *pcbWritten = 0L;

    if (cbWritten + m_pos > m_pData->cb)
    {
	ULISet32( ularge_integer, m_pos+cbWritten );
        error = SetSize(ularge_integer);
	if (error != S_OK)
	    return error;
    }

    // BUGBUG - size_t limit
    memcpy(m_pData->buf + m_pos,pb,(size_t) cbWritten);
    m_pos += cbWritten;

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

    return error;
}

STDMETHODIMP CMemStm::Seek(LARGE_INTEGER dlibMoveIN, DWORD dwOrigin, ULARGE_INTEGER * plibNewPosition)
{
    SCODE error  = S_OK;
    LONG   dlibMove = dlibMoveIN.LowPart ;
    ULONG cbNewPos = dlibMove;

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, m_pos);
    }

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:
            if (dlibMove >= 0)
                m_pos = dlibMove;
            else
		error = E_FAIL;
	    break;

    case STREAM_SEEK_CUR:
            if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pos))
                m_pos += dlibMove;
            else
		error = E_FAIL;
	    break;

    case STREAM_SEEK_END:
            if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pData->cb))
                m_pos = m_pData->cb + dlibMove;
            else
		error = E_FAIL;
	    break;

    default:
	    error = E_FAIL;
    }

    if (plibNewPosition != NULL)
        ULISet32(*plibNewPosition, m_pos);

    return error;
}


STDMETHODIMP CMemStm::SetSize(ULARGE_INTEGER cb)
{
    HANDLE hMemNew;
    struct MEMSTM * pDataNew;

    if (m_pData->cb == cb.LowPart)
	return S_OK;

    if (GlobalUnlock(m_hMem) != 0)
	return E_FAIL;

    hMemNew = GlobalReAlloc(m_hMem,sizeof(MEMSTM) -
	     sizeof(m_pData->buf) + cb.LowPart,GMEM_DDESHARE | GMEM_MOVEABLE);

    if (hMemNew == NULL)
    {
        GlobalLock(m_hMem);
	return E_OUTOFMEMORY;
    }

    pDataNew = (MEMSTM *) GlobalLock(hMemNew);

    if (pDataNew == NULL) // Completely hosed
	return E_FAIL;

    m_hMem = hMemNew;
    pDataNew->cb = cb.LowPart;
    m_pData = pDataNew;

    return S_OK;
}

STDMETHODIMP CMemStm::CopyTo(IStream *pstm, ULARGE_INTEGER cb,
		   ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    SCODE hRslt;
    ULONG   cbWritten = 0;

    if (!pstm)
	return E_FAIL;

    //	write our data into the stream.
    hRslt = pstm->Write(m_pData->buf, cb.LowPart, &cbWritten);

    pcbRead->LowPart = cb.LowPart;
    pcbRead->HighPart = 0;
    pcbWritten->LowPart = cbWritten;
    pcbWritten->HighPart = 0;

    return hRslt;
}

STDMETHODIMP CMemStm::Commit(DWORD grfCommitFlags)
{
    return E_FAIL;
}
STDMETHODIMP CMemStm::Revert(void)
{
    return E_FAIL;
}
STDMETHODIMP CMemStm::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_FAIL;
}
STDMETHODIMP CMemStm::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return E_FAIL;
}

STDMETHODIMP CMemStm::Stat(STATSTG  *pstatstg, DWORD statflag)
{
    pstatstg->pwcsName = NULL;
    pstatstg->type = 0;
    pstatstg->cbSize.HighPart = 0;
    pstatstg->cbSize.LowPart = m_pData->cb;
    pstatstg->mtime.dwLowDateTime = 0;
    pstatstg->mtime.dwHighDateTime = 0;
    pstatstg->ctime.dwLowDateTime = 0;
    pstatstg->ctime.dwHighDateTime = 0;
    pstatstg->atime.dwLowDateTime = 0;
    pstatstg->atime.dwHighDateTime = 0;
    pstatstg->grfMode = 0;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid = CLSID_NULL;
    pstatstg->grfStateBits = 0;

#ifdef CAIROLE_DOWNLEVEL
    pstatstg->reserved = 0;
#else
    pstatstg->dwStgFmt = 0;
#endif

    return S_OK;
}

STDMETHODIMP CMemStm::Clone(IStream  *	*ppstm)
{
    SCODE hRslt = E_FAIL;

    //	create a new stream
    IStream *pIStm = CreateMemStm(m_pData->cb, NULL);

    if (pIStm)
    {
	//  copy data to it
	ULARGE_INTEGER	cbRead, cbWritten;
	ULARGE_INTEGER	cb;
	cb.LowPart = m_pData->cb;
	cb.HighPart = 0;

	hRslt = CopyTo(pIStm, cb, &cbRead, &cbWritten);
	if (hRslt == S_OK)
	{
	    *ppstm = pIStm;
	}
    }

    return hRslt;
}


// Create CMemStm.
//
CMemStm * CMemStm::Create(HANDLE hMem)
{
    CMemStm * pCMemStm;
    struct MEMSTM * pData;

    pData = (MEMSTM *) GlobalLock(hMem);
    if (pData == NULL)
        return NULL;

    pCMemStm = new CMemStm;

    if (pCMemStm == NULL)
    {
	GlobalUnlock(hMem);
        return NULL;
    }

    // Initialize CMemStm
    //
    pCMemStm->m_hMem = hMem;
    (pCMemStm->m_pData = pData)->cRef++;
    pCMemStm->m_refs = 1;

    return pCMemStm;
}




// Allocate shared memory and create CMemStm on top of it.
// Return pointer to the stream if done, NULL if error.
//
STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phMem)
{
    HANDLE hMem;
    struct MEMSTM * pData;
    IStream * pStm;

    if ( phMem )
        *phMem = NULL;

    // Get shared memory
    hMem = GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE,
                       sizeof(MEMSTM) - sizeof(pData->buf) + cb);
    if (hMem == NULL)
	return NULL;

    pData = (MEMSTM *) GlobalLock(hMem);
    if (pData == NULL)
        goto FreeMem;

    pData->cb = cb;
    // If caller doesn't ask for the memory handle
    // Release() should free the memory.
    //
    pData->cRef = (phMem == NULL) ? 0 : 1;
    GlobalUnlock(hMem);

    pStm = CMemStm::Create(hMem); // Create the stream
    if (pStm == NULL)
        goto FreeMem;

    if (phMem)
        *phMem = hMem;

    return pStm;

FreeMem:
    GlobalFree(hMem);
    return NULL;
}



// Create CMemStm on top of the specified hMem.
// Return pointer to the stream if done, NULL if error.
//
STDAPI_(LPSTREAM) CloneMemStm(HANDLE hMem)
{
    return CMemStm::Create(hMem); // Create the stream
}


//////////////////////////////////////////////////////////////////////////
// Shared memory ILockBytes implementation
//

STDMETHODIMP CMemBytes::QueryInterface(REFIID iidInterface,
				       void   **ppvObj)
{
    SCODE error = S_OK;
    *ppvObj = NULL;

    // Two interfaces supported: IUnknown, ILockBytes

    if (m_pData != NULL &&
	(IsEqualIID(iidInterface,IID_ILockBytes) ||
	 IsEqualIID(iidInterface,IID_IUnknown)))
    {

        m_refs++;   // A pointer to this object is returned
        *ppvObj = this;
    }
    else if (IsEqualIID(iidInterface,IID_IMarshal))
    {
        *ppvObj = (LPVOID) CMarshalMemBytes::Create(this);
	if (*ppvObj == NULL)
	    error = E_OUTOFMEMORY;
    }
    else
    {	 // Not accessible or unsupported interface
        *ppvObj = NULL;
	error = E_NOINTERFACE;
    }

    return error;
}


STDMETHODIMP_(ULONG) CMemBytes::AddRef(void)
{
    return ++m_refs;
}

STDMETHODIMP_(ULONG) CMemBytes::Release(void)
{
    if (--m_refs != 0) // Still used by others
        return m_refs;

    // Matches the allocation in CMemBytes::Create().
    //
    if (--m_pData->cRef == 0) 
    {
	if (m_pData->fDeleteOnRelease)
	{
	    GlobalFree(m_pData->hGlobal);
	}
        GlobalUnlock(m_hMem);
	GlobalFree(m_hMem);
    }
    else
        GlobalUnlock(m_hMem);

    delete this; // Free storage
    return 0;
}


STDMETHODIMP CMemBytes::ReadAt(ULARGE_INTEGER ulOffset, void HUGEP* pb,
			      ULONG cb, ULONG * pcbRead)
{
    SCODE error = S_OK;
    ULONG cbRead = cb;

    if (pcbRead)
        *pcbRead = 0L;

    if (cbRead + ulOffset.LowPart > m_pData->cb)
    {
        if (ulOffset.LowPart > m_pData->cb)
            cbRead = 0;
        else
            cbRead = m_pData->cb - ulOffset.LowPart;

	error = E_FAIL;
    }

    char HUGEP* pGlobal = (char HUGEP*) GlobalLock (m_pData->hGlobal);
    if (NULL==pGlobal)
    {
	return STG_E_READFAULT;
    }

    memcpy(pb, pGlobal + ulOffset.LowPart, cbRead);
    GlobalUnlock (m_pData->hGlobal);

    if (pcbRead != NULL)
        *pcbRead = cbRead;

    return error;
}


STDMETHODIMP CMemBytes::WriteAt(ULARGE_INTEGER ulOffset, void const HUGEP* pb,
			      ULONG cb, ULONG * pcbWritten)
{
    SCODE error = S_OK;
    ULONG cbWritten = cb;
    char HUGEP* pGlobal;

    if (pcbWritten)
        *pcbWritten = 0;

    if (cbWritten + ulOffset.LowPart > m_pData->cb)
    {
	ULARGE_INTEGER ularge_integer;
	ULISet32( ularge_integer, ulOffset.LowPart + cbWritten);
        error = SetSize( ularge_integer );
	if (error != S_OK)
	    return error;
    }

    pGlobal = (char HUGEP*) GlobalLock (m_pData->hGlobal);
    if (NULL==pGlobal)
    {
	return STG_E_WRITEFAULT;
    }

    memcpy(pGlobal + ulOffset.LowPart, pb, cbWritten);
    GlobalUnlock (m_pData->hGlobal);

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

    return error;
}

STDMETHODIMP CMemBytes::Flush(void)
{
    return S_OK;
}


STDMETHODIMP CMemBytes::SetSize(ULARGE_INTEGER cb)
{
    HANDLE hMemNew;

    if (m_pData->cb == cb.LowPart)
	return S_OK;

    hMemNew = GlobalReAlloc(m_pData->hGlobal,
			cb.LowPart,
			GMEM_DDESHARE | GMEM_MOVEABLE);

    if (hMemNew == NULL) 
	return E_OUTOFMEMORY;

    m_pData->hGlobal = hMemNew;
    m_pData->cb = cb.LowPart;

    return S_OK;
}


STDMETHODIMP CMemBytes::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    return S_OK;
}

STDMETHODIMP CMemBytes::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                                                      DWORD dwLockType)
{
    return S_OK;
}


STDMETHODIMP CMemBytes::Stat(STATSTG  *pstatstg, DWORD statflag)
{
    pstatstg->pwcsName = NULL;
    pstatstg->type = 0;
    pstatstg->cbSize.HighPart = 0;
    pstatstg->cbSize.LowPart = m_pData->cb;
    pstatstg->mtime.dwLowDateTime = 0;
    pstatstg->mtime.dwHighDateTime = 0;
    pstatstg->ctime.dwLowDateTime = 0;
    pstatstg->ctime.dwHighDateTime = 0;
    pstatstg->atime.dwLowDateTime = 0;
    pstatstg->atime.dwHighDateTime = 0;
    pstatstg->grfMode = 0;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid = CLSID_NULL;
    pstatstg->grfStateBits = 0;
#ifdef CAIROLE_DOWNLEVEL
    pstatstg->reserved = 0;
#else
    pstatstg->dwStgFmt = 0;
#endif

    return S_OK;
}


// Create CMemBytes.
//
CMemBytes * CMemBytes::Create(HANDLE hMem)
{
    CMemBytes * pCMemBytes;
    struct MEMBYTES * pData;

    pData = (MEMBYTES *) GlobalLock(hMem);
    if (pData == NULL)
	return NULL;

    pCMemBytes = new CMemBytes;

    if (pCMemBytes == NULL)
    {
	GlobalUnlock(hMem);
	return NULL;
    }

    // Initialize CMemBytes
    //
    pCMemBytes->m_dwSig = LOCKBYTE_SIG;
    pCMemBytes->m_hMem = hMem;
    (pCMemBytes->m_pData = pData)->cRef++;
    pCMemBytes->m_refs = 1;

    return pCMemBytes;
}



STDAPI_(LPLOCKBYTES) CreateMemLockBytes(DWORD cb, LPHANDLE phMem)
{
    HANDLE h;
    LPLOCKBYTES plb = NULL;

    if (phMem)
	*phMem = NULL;

    h = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, cb);
    if (NULL==h)
	return NULL;

    if (CreateILockBytesOnHGlobal (h, phMem==NULL, &plb) != S_OK)
	return NULL;

    if (phMem)
	GetHGlobalFromILockBytes (plb, phMem);

    return plb;
}




// Create CMemBytes on top of the specified hMem.
// Return pointer to the stream if done, NULL if error.
//
STDAPI_(LPLOCKBYTES) CloneMemLockbytes(HANDLE hMem)
{
    return CMemBytes::Create(hMem); // Create the lockbytes
}


// CMemStm object's IMarshal implementation
//

STDMETHODIMP CMarshalMemStm::QueryInterface(REFIID iidInterface,
					    void * * ppvObj)
{
    SCODE error = S_OK;
    *ppvObj = NULL;

    // Two interfaces supported: IUnknown, IMarshal

    if (IsEqualIID(iidInterface,IID_IMarshal)  ||
	IsEqualIID(iidInterface,IID_IUnknown))
    {
        m_refs++;           // A pointer to this object is returned
        *ppvObj = this;
    }
    else
    {		   // Not accessible or unsupported interface
        *ppvObj = NULL;
	 error = E_NOINTERFACE;
    }

    return error;
}


STDMETHODIMP_(ULONG) CMarshalMemStm::AddRef(void)
{
   return ++m_refs;
}

STDMETHODIMP_(ULONG) CMarshalMemStm::Release(void)
{
    if (--m_refs != 0) // Still used by others
        return m_refs;

    if (m_pMemStm)
        m_pMemStm->Release();

    delete this; // Free storage
    return 0;
}


// Returns the clsid of the object that created this CMarshalMemStm.
//
STDMETHODIMP CMarshalMemStm::GetUnmarshalClass(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, CLSID * pCid)
{
    *pCid = m_clsid;
    return S_OK;
}


STDMETHODIMP CMarshalMemStm::GetMarshalSizeMax(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, DWORD * pSize)
{
    *pSize = sizeof(m_pMemStm->m_hMem);
    return S_OK;
}


STDMETHODIMP CMarshalMemStm::MarshalInterface(IStream * pStm,
     REFIID riid, void * pv,
     DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags)
{
    if (m_pMemStm == NULL)
	return E_FAIL;

    if ((!IsEqualIID(riid,IID_IStream) &&
	 !IsEqualIID(riid,IID_IUnknown)) || pv != m_pMemStm)
	return E_INVALIDARG;

    // increase ref count on hglobal (ReleaseMarshalData has -- to match)
    SCODE error;
    error = pStm->Write(&m_pMemStm->m_hMem,sizeof(m_pMemStm->m_hMem), NULL);
    if (error == S_OK)
	m_pMemStm->m_pData->cRef++;

    return error;
}


STDMETHODIMP CMarshalMemStm::UnmarshalInterface(IStream * pStm,
					REFIID riid, void * * ppv)
{
    SCODE error;
    HANDLE hMem;

    *ppv = NULL;    
     
    if (!IsEqualIID(riid,IID_IStream) && !IsEqualIID(riid,IID_IUnknown))
	return E_INVALIDARG;

    error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error != S_OK)
        return error;

    if (m_pMemStm != NULL)
    {
        if (hMem != m_pMemStm->m_hMem)
	    return E_FAIL;
    }
    else
    {
	m_pMemStm = (CMemStm *) CloneMemStm(hMem);
        if (m_pMemStm == NULL)
	    return E_OUTOFMEMORY;
    }

    m_pMemStm->AddRef();
    *ppv = (LPVOID) m_pMemStm;
    return S_OK;
}


STDMETHODIMP CMarshalMemStm::ReleaseMarshalData(IStream * pStm)
{
    // reduce ref count on hglobal (matches that done in MarshalInterface)
    SCODE error;
    MEMSTM * pData;
    HANDLE hMem;

    error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error != S_OK)
        return error;

    pData = (MEMSTM *) GlobalLock(hMem);
    if (pData == NULL)
	return E_FAIL;

    if (--pData->cRef == 0)
    {
	GlobalUnlock(hMem);
        GlobalFree(hMem);
    } else
	// still used by one or more CMemStm in one or more processes
	GlobalUnlock(hMem);

    return S_OK;
}


STDMETHODIMP CMarshalMemStm::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}


CMarshalMemStm * CMarshalMemStm::Create(CMemStm * pMemStm)
{
    CMarshalMemStm * pMMS = new CMarshalMemStm;

    if (pMMS == NULL)
        return NULL;

    if (pMemStm != NULL)
    {
        pMMS->m_pMemStm = pMemStm;
        pMMS->m_pMemStm->AddRef();
    }

    pMMS->m_clsid = CLSID_StdMemStm;
    pMMS->m_refs = 1;

    return pMMS;
}


STDAPI_(IUnknown *) CMemStmUnMarshal(void)
{
    return CMarshalMemStm::Create(NULL);
}



// CMemBytes object's IMarshal implementation
//

STDMETHODIMP CMarshalMemBytes::QueryInterface(REFIID iidInterface,
						    void * * ppvObj)
{
    SCODE error = S_OK;
    *ppvObj = NULL;

    // Two interfaces supported: IUnknown, IMarshal

    if (IsEqualIID(iidInterface,IID_IMarshal) ||
	IsEqualIID(iidInterface,IID_IUnknown))
    {
        m_refs++;           // A pointer to this object is returned
        *ppvObj = this;
    }
    else
    {		   // Not accessible or unsupported interface
        *ppvObj = NULL;
	error = E_NOINTERFACE;
    }

    return error;
}


STDMETHODIMP_(ULONG) CMarshalMemBytes::AddRef(void)
{
    return ++m_refs;
}

STDMETHODIMP_(ULONG) CMarshalMemBytes::Release(void)
{
    if (--m_refs != 0) // Still used by others
        return m_refs;

    if (m_pMemBytes != NULL)
        m_pMemBytes->Release();

    delete this; // Free storage
    return 0;
}


// Returns the clsid of the object that created this CMarshalMemBytes.
//
STDMETHODIMP CMarshalMemBytes::GetUnmarshalClass(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, CLSID * pCid)
{
    *pCid = m_clsid;
    return S_OK;
}


STDMETHODIMP CMarshalMemBytes::GetMarshalSizeMax(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,	DWORD * pSize)
{
   *pSize = sizeof(m_pMemBytes->m_hMem);
    return S_OK;
}


STDMETHODIMP CMarshalMemBytes::MarshalInterface(IStream * pStm,
    REFIID riid, void * pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags)
{
    if (m_pMemBytes == NULL)
	return E_FAIL;

    if ((!IsEqualIID(riid,IID_ILockBytes) &&
	 !IsEqualIID(riid,IID_IUnknown)) || pv != m_pMemBytes)
	return E_INVALIDARG;

    // increase ref count on hglobal (ReleaseMarshalData has -- to match)
    SCODE error;
    error = pStm->Write(&m_pMemBytes->m_hMem,sizeof(m_pMemBytes->m_hMem),NULL);
    if (error == S_OK)
	m_pMemBytes->m_pData->cRef++;

    return error;
}


STDMETHODIMP CMarshalMemBytes::UnmarshalInterface(IStream * pStm,
				 REFIID riid, void * * ppv)
{
    HANDLE hMem;

    *ppv = NULL;

    if (!IsEqualIID(riid,IID_ILockBytes) && !IsEqualIID(riid,IID_IUnknown))
	return E_INVALIDARG;

    SCODE error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error != S_OK)
        return error;

    if (m_pMemBytes != NULL)
    {
        if (hMem != m_pMemBytes->m_hMem)
	    return E_FAIL;
    }
    else
    {
	m_pMemBytes = (CMemBytes *) CloneMemLockbytes(hMem);
        if (m_pMemBytes == NULL)
	    return E_OUTOFMEMORY;
    }

    m_pMemBytes->AddRef();
    *ppv = (LPVOID) m_pMemBytes;
    return S_OK;
}


STDMETHODIMP CMarshalMemBytes::ReleaseMarshalData(IStream * pStm)
{
    // reduce ref count on hglobal (matches that done in MarshalInterface)
    MEMBYTES  *pData;
    HANDLE     hMem;

    SCODE error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error != S_OK)
        return error;

    pData = (MEMBYTES *) GlobalLock(hMem);
    if (pData == NULL)
	return E_FAIL;

    if (--pData->cRef == 0)
    {
	GlobalUnlock(hMem);
        GlobalFree(hMem);
    }
    else
    {
	// still used by one or more CMemStm in one or more processes
	GlobalUnlock(hMem);
    }

    return S_OK;
}


STDMETHODIMP CMarshalMemBytes::DisconnectObject(DWORD dwReserved)
{
    return S_OK;
}


CMarshalMemBytes *CMarshalMemBytes::Create(CMemBytes *pMemBytes)
{
    CMarshalMemBytes *pMMB = new CMarshalMemBytes;

    if (pMMB == NULL)
        return NULL;

    if (pMemBytes != NULL)
    {
        pMMB->m_pMemBytes = pMemBytes;
        pMMB->m_pMemBytes->AddRef();
    }

    pMMB->m_clsid = CLSID_StdMemBytes;
    pMMB->m_refs = 1;

    return pMMB;
}


STDAPI_(IUnknown *) CMemBytesUnMarshal(void)
{
    return CMarshalMemBytes::Create(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\oleobj.cxx ===
//+-------------------------------------------------------------------
//  File:       ioleobj.cxx
//
//  Contents:   IOleObject methods of COleObject class.
//
//  Classes:    COleObject - IOleObject implementation
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)

#include    <pch.cxx>
#pragma     hdrstop
#include    <embed.hxx>
#include    <oleobj.hxx>


//+-------------------------------------------------------------------
//  Member:     COleObject::COleObject()
//
//  Synopsis:   The constructor for COleObject.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
COleObject::COleObject(CTestEmbed *pteObject)
{
    _cRef      = 1;
    _pOAHolder = NULL;
    _pocs      = NULL;
    _pteObject = pteObject;
    _pmkContainer = NULL;
}


//+-------------------------------------------------------------------
//  Member:     COleObject::~COleObject()
//
//  Synopsis:   The destructor for COleObject.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
COleObject::~COleObject()
{
    // _cRef should be 1
    if (1 != _cRef)
    {
        // BUGBUG - Log error - someone hasn't released
    }

    if (_pocs != NULL)
    {
	_pocs->Release();
    }

    if (_pmkContainer != NULL)
    {
	_pmkContainer->Release();
    }

}


//+-------------------------------------------------------------------
//  Method:     COleObject::QueryInterface
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::QueryInterface(REFIID iid, void FAR * FAR *ppv)
{
    return(_pteObject->QueryInterface(iid, ppv));
}


//+-------------------------------------------------------------------
//  Method:     COleObject::AddRef
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) COleObject::AddRef(void)
{
    ++_cRef;
    return(_pteObject->AddRef());
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Release
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) COleObject::Release(void)
{
    --_cRef;
    return(_pteObject->Release());
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetClientSite
//
//  Synopsis:   Save the IOleClientSite pointer passed - it's this
//              object's client site object.
//
//  Parameters: [pClientSite] - Pointer to the new client site object.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    if (_pocs != NULL)
    {
	_pocs->Release();
    }

    _pocs = pClientSite;

    if (pClientSite)
    {
	_pocs->AddRef();
    }

    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetClientSite
//
//  Synopsis:   Return this objects current client site - NULL indicates
//              it hasn't been set yet.
//
//  Parameters: [ppClientSite] - Save current client site pointer here.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetClientSite(LPOLECLIENTSITE FAR *ppClientSite)
{
    *ppClientSite = _pocs;
    _pocs->AddRef();
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetHostNames
//
//  Synopsis:   See spec 2.00.09 p99.  Returns names the caller can use
//              to display our object name (in window titles and such).
//
//  Parameters: [szContainerApp] - Name of container application.
//              [szContainerObj] - Name of this object.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetHostNames(
	LPCOLESTR szContainerApp,
	LPCOLESTR szContainerObj)
{
    szContainerApp = OLESTR("Test Server");
    szContainerObj = OLESTR("Test Server:Test Object");
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Close
//
//  Synopsis:   See spec 2.00.09 p104.  Short story is:  if fMerelyHide,
//              turn off the UI of this object, else return to the
//              "loaded" state, which for us means to shut down (since we
//              don't do any caching).
//
//  Parameters: [dwSaveOption] - ???
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - what if we have multiple instances?  Do we
//                return the server app to the loaded state or do we
//                return this object to the loaded state?
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Close(DWORD dwSaveOption)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetMoniker
//
//  Synopsis:   See spec 2.00.09 p99.  The moniker for this object
//              (or it's container) has been changed to that passed
//              in.  Take appropriate actions (de-register old object
//              and register new, inform contained objects, etc).
//
//  Parameters: [dwWhichMoniker] - Moniker type being sent.
//              [pmk]            - The new moniker.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    if (_pmkContainer)
    {
	_pmkContainer->Release();

    }

    _pmkContainer = pmk;

    pmk->AddRef();

    // Set moniker in container
    IOleObject *pobj;

    HRESULT hresult = _pocs->QueryInterface(IID_IOleObject, (void **) &pobj);

    pobj->SetMoniker(dwWhichMoniker, pmk);

    pobj->Release();

    return S_OK;
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetMoniker
//
//  Synopsis:   See spec 2.00.09 p100.  Return either this objects
//              container moniker, this objects relative moniker, or
//              this objects full moniker.
//
//  Parameters: [dwAssign]       - Condition to get moniker.
//              [dwWhichMoniker] - Kind of moniker being requested.
//              [ppmk]           - Return moniker here.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetMoniker(
        DWORD          dwAssign,
        DWORD          dwWhichMoniker,
        LPMONIKER FAR *ppmk)
{
    *ppmk = _pmkContainer;
    _pmkContainer->AddRef();
    return S_OK;
}


//+-------------------------------------------------------------------
//  Method:     COleObject::InitFromData
//
//  Synopsis:   See spec 2.00.09 p100.  Initialize this object from
//              the format passed in.
//
//  Parameters: [pDataObject] - IDataObject providing data.
//              [fCreation]   - TRUE if this is the initial creation.
//              [dwReserved]  - Ignored.
//
//  Returns:    S_OK if we attempt to initialize, S_FALSE if we don't
//              want to.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::InitFromData(
        LPDATAOBJECT pDataObject,
        BOOL         fCreation,
        DWORD        dwReserved)
{
    // BUGBUG - NYI
    return(S_FALSE);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetClipboardData
//
//  Synopsis:   See spec 2.00.09 p101.  Return clipboard object that would
//              be created if Edit/Copy were done to this item.
//
//  Parameters: [dwReserved]   - Ignored.
//              [ppDataObject] - IDataObject return locale.
//
//  Returns:    S_OK or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetClipboardData(
        DWORD             dwReserved,
        LPDATAOBJECT FAR *ppDataObject)
{
    // BUGBUG - NYI
    *ppDataObject = NULL;
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::DoVerb
//
//  Synopsis:   See spec 2.00.09 p101.  Execute the verb passed in.
//
//  Parameters: [iVerb]       - Verb being requested.
//              [pMsg]        - Message that triggered the request.
//              [pActiveSite] - IOleClientSite for this object.
//              [lReserved]   - Ignored.
//
//  Returns:    S_OK, or other ones specified but not defined yet...
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::DoVerb(
        LONG            iVerb,
        LPMSG           pMsg,
        LPOLECLIENTSITE pActiveSite,
	LONG		lReserved,
	HWND		hwndParent,
	LPCRECT 	lprcPosRect)
{
    // HWND hwndObj;

    if (OLEIVERB_SHOW == iVerb)
    {
        // BUGBUG - NYI
        // Display the object (we're not in-place yet)
	// PostMessage(g_hwndMain, WM_REPORT, MB_SHOWVERB, 0);
        // PostMessage(0xFFFF, WM_REPORT, MB_SHOWVERB, 0);
	// MessageBox(g_hwndMain, L"Received OLEIVERB_SHOW", L"OLE Server", MB_ICONINFORMATION | MB_OK);

        // Get hwndObj
        //_pteObject->GetWindow(&hwndObj);
	//MessageBox(hwndObj, L"Received OLEIVERB_SHOW", L"OLE Server", MB_ICONINFORMATION | MB_OK);
    }
    else
    {
        // Return alternate error code?
    }

    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::EnumVerbs
//
//  Synopsis:   See spec 2.00.09 p103.  Enumerate all the verbs available
//              on this object in increasing numerical order.
//
//  Parameters: [ppenmOleVerb] - Enumeration object return locale.
//
//  Returns:    S_OK or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::EnumVerbs(IEnumOLEVERB FAR* FAR *ppenmOleVerb)
{
    // BUGBUG - NYI
    *ppenmOleVerb = NULL;
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Update
//
//  Synopsis:   See spec 2.00.09 p105.  Ensure any data or view caches
//              maintained inside the object are up to date.
//
//  Parameters: None
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Update()
{
    // We don't use any caches, so we don't have to do anything
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::IsUpToDate
//
//  Synopsis:   See spec 2.00.09 p105. Check to see if this object is
//              up to date - including embedded children, etc.
//
//  Parameters: None
//
//  Returns:    S_OK, S_FALSE, or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::IsUpToDate()
{
    // We should always be up to date as we don't have any caches
    // or children or links
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:	COleObject::GetUserClassID
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Parameters: [dwFormOfType] -
//              [pszUserType]  -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetUserClassID(
	CLSID FAR *pClsid)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetUserType
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Parameters: [dwFormOfType] -
//              [pszUserType]  -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetUserType(
        DWORD      dwFormOfType,
	LPOLESTR FAR *pszUserType)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetExtent
//
//  Synopsis:   See spec 2.00.09 p106.  Set the rectangular extent of
//              this object.  Container will call us with the size
//              it will give us; we must fit accordingly.
//
//  Parameters: [dwDrawAspect] - DVASPECT specified for this object.
//              [lpsizel]      - Extent structure.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetExtent
//
//  Synopsis:   See spec 2.00.09 p106.  Size of the object given in the
//              the last SetExtent call is returned.  If SetExtent has
//              not been called, the natural size of the object is
//              returned.
//
//  Parameters: [dwDrawAspect] - DVASPECT specified for this object.
//              [lpsizel]      - Extent structure to set.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Advise
//
//  Synopsis:   See spec 2.00.09 p121.  Set up an advisory connection
//              between this object and an advisory sink; when certain
//              events happen (birthdays?) this sink should be informed
//              by this object.  Use the OleAdviseHolder object as a
//              helper (see p122).
//
//  Parameters: [pAdvSink]      - Sink that should be informed of changes.
//              [pdwConnection] - Pass advisory token returned so our
//                                caller can shut down the link.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Advise(
        IAdviseSink FAR *pAdvSink,
        DWORD       FAR *pdwConnection)
{
//    if (NULL == _pOAHolder)
//    {
//	 if (S_OK != CreateOleAdviseHolder(&_pOAHolder))
//	 {
//	     return(E_OUTOFMEMORY);
//	 }
//    }
//
//    return(_pOAHolder->Advise(pAdvSink, pdwConnection));
    *pdwConnection = 0;
    return S_OK;
}


//+-------------------------------------------------------------------
//  Method:     COleObject::Unadvise
//
//  Synopsis:   See spec 2.00.09 p121.  Tear down an advisory connection
//              set up previously.
//
//  Parameters: [dwConnection] - Connection established earlier.
//
//  Returns:    S_OK or ???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::Unadvise(DWORD dwConnection)
{
    if (NULL == _pOAHolder)
    {
        // No one is registered - see ellipswt.cpp for this
        return(E_INVALIDARG);
    }

    return(_pOAHolder->Unadvise(dwConnection));
}


//+-------------------------------------------------------------------
//  Method:     COleObject::EnumAdvise
//
//  Synopsis:   See spec 2.00.09 p122.  Enumerate the advisory connections
//              currently attached to this object.
//
//  Parameters: [ppenmAdvise] - Enumeration object to return.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::EnumAdvise(LPENUMSTATDATA FAR *ppenmAdvise)
{
    if (NULL == _pOAHolder)
    {
	return(E_FAIL);
    }
    return(_pOAHolder->EnumAdvise(ppenmAdvise));
}


//+-------------------------------------------------------------------
//  Method:     COleObject::GetMiscStatus
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Returns:    S_OK?
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::GetMiscStatus(
        DWORD dwAspect,
        DWORD FAR *pdwStatus)
{
    // BUGBUG - NYI
    return(E_FAIL);
}


//+-------------------------------------------------------------------
//  Method:     COleObject::SetColorScheme
//
//  Synopsis:   I have little idea what this does.  It's not in the
//              spec 2.00.09.
//
//  Returns:    S_OK?
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP COleObject::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    // BUGBUG - NYI
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\qicf.cxx ===
//+-------------------------------------------------------------------
//
//  File:	qicf.cxx
//
//  Contents:	test class factory object implementation
//
//  Classes:	CQIClassFactory
//
//  Functions:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <qicf.hxx>	//  class definiton
#include    <cqi.hxx>	//  CQI defines


const GUID CLSID_QI =
    {0x00000140,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

const GUID CLSID_QIHANDLER =
    {0x00000141,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


//+-------------------------------------------------------------------
//
//  Member:	CQIClassFactory::CQIClassFactory, public
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
CQIClassFactory::CQIClassFactory(REFCLSID rclsid) : _clsid(rclsid)
{
    ENLIST_TRACKING(CQIClassFactory);
}

//+-------------------------------------------------------------------
//
//  Member:	CQIClassFactory::~CQIClassFactory, public
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------
CQIClassFactory::~CQIClassFactory(void)
{
    //	automatic actions do the rest of the work
}

//+-------------------------------------------------------------------
//
//  Member:	CQIClassFactory::QueryInterface, public
//
//  Algorithm:	if the interface is not one implemented by us,
//		pass the request to the proxy manager
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CQIClassFactory::QueryInterface(REFIID riid, void **ppUnk)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IClassFactory))
    {
	*ppUnk = (void *)(IClassFactory *) this;
	AddRef();
	return S_OK;
    }

    *ppUnk = NULL;
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------
//
//  Member:	CQIClassFactory::CreateInstance, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CQIClassFactory::CreateInstance(IUnknown *punkOuter,
					     REFIID    riid,
					     void     **ppunkObject)
{
    SCODE sc = E_OUTOFMEMORY;

    *ppunkObject = NULL;	//  in case of failure

    // create a new object.
    IUnknown *pQI = new CQI(_clsid);

    if (pQI)
    {
	//  get the interface the caller wants to use
	sc = pQI->QueryInterface(riid, ppunkObject);
	pQI->Release();
    }

    return  sc;
}

//+-------------------------------------------------------------------
//
//  Member:	CQIClassFactory::LockServer, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
STDMETHODIMP CQIClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
	GlobalRefs(TRUE);
    else
	GlobalRefs(FALSE);

    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\persist.cxx ===
//+-------------------------------------------------------------------
//  File:       ipersist.cxx
//
//  Contents:   IPersist and IPersistStorage methods of CPersistStorage class.
//
//  Classes:    CPersistStorage - IPersist, IPersistStorage implementations
//
//  History:    7-Dec-92   DeanE   Created
//---------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#pragma optimize("",off)
#include    <persist.hxx>


//+-------------------------------------------------------------------
//  Member:     CPersistStorage::CPersistStorage()
//
//  Synopsis:   The constructor for CPersistStorage.
//
//  Arguments:  None
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CPersistStorage::CPersistStorage(CTestEmbed *pteObject)
{
    _cRef      = 1;
    _pteObject = pteObject;
    _fDirty    = FALSE;
}


//+-------------------------------------------------------------------
//  Member:     CPersistStorage::~CPersistStorage()
//
//  Synopsis:   The destructor for CPersistStorage.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
CPersistStorage::~CPersistStorage()
{
    // _cRef should be 1
    if (1 != _cRef)
    {
        // BUGBUG - Log error, someone hasn't released
    }
    return;
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::QueryInterface
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Parameters: [iid] - Interface ID to return.
//              [ppv] - Pointer to pointer to object.
//
//  Returns:    S_OK if iid is supported, or E_NOINTERFACE if not.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::QueryInterface(REFIID iid, void FAR * FAR *ppv)
{
    return(_pteObject->QueryInterface(iid, ppv));
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::AddRef
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPersistStorage::AddRef(void)
{
    ++_cRef;
    return(_pteObject->AddRef());
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::Release
//
//  Synopsis:   Forward this to the object we're associated with
//
//  Returns:    New reference count.
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPersistStorage::Release(void)
{
    --_cRef;
    return(_pteObject->Release());
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::GetClassId
//
//  Synopsis:   See spec 2.00.09 p197.  Answer the Class ID of this
//              object.
//
//  Parameters: [pClassId] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::GetClassID(LPCLSID pClassId)
{
    if (NULL != pClassId)
    {
        *pClassId = CLSID_TestEmbed;
    }
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::IsDirty
//
//  Synopsis:   See spec 2.00.09 p200.  Return S_OK if the object needs
//              to be saved in order to avoid data loss, or S_FALSE
//              if not.
//
//  Parameters: None
//
//  Returns:    S_OK or S_FALSE
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::IsDirty()
{
    // BUGBUG - NYI
    //   Because we are NYI, just return S_FALSE
    return(S_FALSE);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::InitNew
//
//  Synopsis:   See spec 2.00.09 p197.  This method provides a way
//              for a container to provide persistent storage to this
//              object.  Call AddRef on the pStg passed if we do save
//              it.
//
//  Parameters: [pStg] - IStorage instance this object can use.
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::InitNew(LPSTORAGE pStg)
{
    // BUGBUG - NYI
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::Load
//
//  Synopsis:   See spec 2.00.09 p200.  Called by handler to put this
//              object into the running state.  Object should use the
//              pStg passed to "initialize" itself.  We can hold onto
//              this pStg, but when ::Save is called, this can be
//              a different IStorage.
//
//  Parameters: [pStg] - IStorage to initialize object from.
//
//  Returns:    S_OK?
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::Load(LPSTORAGE pStg)
{
    // BUGBUG - NYI
    //   Initialize the object here, though, just as if we had obtained
    //   data from an IStorage
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::Save
//
//  Synopsis:   See spec 2.00.09 p197.  Save the data in the IStorage
//              passed.  Ignore flags for now.
//
//  Parameters: [pStgSave]    - Save data in here.
//              [fSameAsLoad] - Indicates this object is the same one
//                              that was initially started.
//              [fRemember]   - Only matters if fSameAsLoad is FALSE.
//
//  Returns:    STG_E_MEDIUMFULL - why???
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::Save(
        LPSTORAGE pStgSave,
	BOOL	  fSameAsLoad)
{
    // BUGBUG - NYI
    return(STG_E_MEDIUMFULL);
}


//+-------------------------------------------------------------------
//  Method:     CPersistStorage::SaveCompleted
//
//  Synopsis:   See spec 2.00.09 p198.  Used only in certain circumstances.
//
//  Parameters: [pStgSaved] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::SaveCompleted(LPSTORAGE pStgSaved)
{
    // BUGBUG - NYI
    //   We don't have to worry about this unless we allow a "Save As"
    //   operation
    return(S_OK);
}



//+-------------------------------------------------------------------
//  Method:	CPersistStorage::HandsOffStorage
//
//  Synopsis:   See spec 2.00.09 p198.  Used only in certain circumstances.
//
//  Parameters: [pStgSaved] -
//
//  Returns:    S_OK
//
//  History:    7-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CPersistStorage::HandsOffStorage(void)
{
    // BUGBUG - NYI
    //   We don't have to worry about this unless we allow a "Save As"
    //   operation
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\rpccf.cxx ===
//+-------------------------------------------------------------------
//
//  File:	rpccf.cxx
//
//  Contents:	rpc test class factory object implementation
//
//  Classes:	CRpcTestClassFactory
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <rpccf.hxx>	//  class definiton
#include    <crpc.hxx>	//  CRpcTests defines


const GUID CLSID_RpcTest =
    {0x0000013d,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


//+-------------------------------------------------------------------
//
//  Member:	CRpcTestClassFactory::CRpcTestClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

CRpcTestClassFactory::CRpcTestClassFactory(void)
{
    ENLIST_TRACKING(CRpcTestClassFactory);
}


//+-------------------------------------------------------------------
//
//  Member:	CRpcTestClassFactory::~CRpcTestClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

CRpcTestClassFactory::~CRpcTestClassFactory(void)
{
    //	automatic actions do the rest of the work
}


//+-------------------------------------------------------------------
//
//  Member:	CRpcTestClassFactory::QueryInterface, public
//
//  Algorithm:	if the interface is not one implemented by us,
//		pass the request to the proxy manager
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CRpcTestClassFactory::QueryInterface(REFIID riid, void **ppUnk)
{
    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IClassFactory))
    {
	*ppUnk = (void *)(IClassFactory *) this;
	AddRef();
    }
    else
    {
	*ppUnk = NULL;
	sc = E_NOINTERFACE;
    }
    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CRpcTestClassFactory::CreateInstance, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CRpcTestClassFactory::CreateInstance(IUnknown *punkOuter,
						  REFIID   riid,
						  void	   **ppunkObject)
{
    SCODE sc = E_OUTOFMEMORY;

    *ppunkObject = NULL;	//  in case of failure

    //	create a ball object.
    IUnknown *punk = (IUnknown *) new CRpcTest();

    if (punk)
    {
	//  get the interface the caller wants to use
	sc = punk->QueryInterface(riid, ppunkObject);

	//  release our hold on the ball, since the QI got a hold for
	//  the client.
	punk->Release();
    }

    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CRpcTestClassFactory::LockServer, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CRpcTestClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
	GlobalRefs(TRUE);
    else
	GlobalRefs(FALSE);

    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\regmain.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993.
//
//  File:       regmain.cxx
//
//  Contents:	registration of developer regression tests and benchmrk
//              tests.
//
//  Functions:	RegistrySetup
//
//  History:    23-May-96 Rickhi    Created
//
//--------------------------------------------------------------------------
#include <pch.cxx>
#include <regmain.hxx>

#define REGISTRY_ENTRY_LEN 256

typedef struct
{
  const char *key;
  const char *value;
} RegistryKeyValue;

const RegistryKeyValue REG_CONST_KEY[] =
{
  ".bm1", "CLSID\\{99999999-0000-0008-C000-000000000052}",
  ".bm2", "CLSID\\{99999999-0000-0008-C000-000000000051}",

  "CLSID\\{20730701-0001-0008-C000-000000000046}", "OleTestClass",
  "CLSID\\{20730711-0001-0008-C000-000000000046}", "OleTestClass1",
  "CLSID\\{20730712-0001-0008-C000-000000000046}", "OleTestClass2",
  "CLSID\\{20730713-0001-0008-C000-000000000046}", "OleTestClass3",
  "CLSID\\{20730714-0001-0008-C000-000000000046}", "OleTestClass4",
  "CLSID\\{20730715-0001-0008-C000-000000000046}", "OleTestClass5",
  "CLSID\\{20730716-0001-0008-C000-000000000046}", "OleTestClass6",
  "CLSID\\{20730717-0001-0008-C000-000000000046}", "OleTestClass7",
  "CLSID\\{20730718-0001-0008-C000-000000000046}", "OleTestClass8",

  "CLSID\\{00000138-0001-0008-C000-000000000046}", "CPrxyBalls",
  "Interface\\{00000138-0001-0008-C000-000000000046}", "IBalls",
  "Interface\\{00000139-0001-0008-C000-000000000046}", "ICube",
  "Interface\\{00000136-0001-0008-C000-000000000046}", "ILoops",
  "Interface\\{00000137-0001-0008-C000-000000000046}", "IRpcTest",

  "Interface\\{00000138-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "Interface\\{00000139-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "Interface\\{00000136-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "Interface\\{00000137-0001-0008-C000-000000000046}\\ProxyStubClsid32", "{00000138-0001-0008-C000-000000000046}",
  "CLSID\\{0000013a-0001-0008-C000-000000000046}\\ProgID", "ProgID60",
  "CLSID\\{0000013a-0001-0008-C000-000000000046}", "CBallsClassFactory",
  "CLSID\\{0000013b-0001-0008-C000-000000000046}", "CCubesClassFactory",
  "CLSID\\{0000013c-0001-0008-C000-000000000046}", "CLoopClassFactory",
  "CLSID\\{0000013d-0001-0008-C000-000000000046}", "CRpcTestClassFactory",
  "CLSID\\{0000013e-0001-0008-C000-000000000046}", "CHandCraftedProxy",
  "CLSID\\{00000140-0000-0008-C000-000000000046}", "CQueryInterface",
  "CLSID\\{00000141-0000-0008-C000-000000000046}", "CQueryInterfaceHandler",

  ".ut4", "ProgID50",
  ".ut5", "ProgID51",
  ".ut6", "ProgID52",
  ".ut7", "ProgID53",
  ".ut8", "ProgID54",
  ".ut9", "ProgID55",
  ".bls", "ProgID60",

  "CLSID\\{99999999-0000-0008-C000-000000000050}", "SDI",
  "CLSID\\{99999999-0000-0008-C000-000000000051}", "MDI",
  "CLSID\\{99999999-0000-0008-C000-000000000052}", "InprocNoRegister",
  "CLSID\\{99999999-0000-0008-C000-000000000053}", "InprocRegister",
  "CLSID\\{99999999-0000-0008-C000-000000000054}", "InprocRegister",
  "CLSID\\{99999999-0000-0008-C000-000000000054}\\TreatAs", "{99999999-0000-0008-C000-000000000050}",
  "CLSID\\{99999999-0000-0008-C000-000000000055}", "MDI",
  "CLSID\\{99999999-0000-0008-C000-000000000055}\\ActivateAtBits", "Y",

  "ProgID50", "objact sdi",
  "ProgID50\\CLSID", "{99999999-0000-0008-C000-000000000050}",
  "ProgID51", "objact mdi",
  "ProgID51\\CLSID", "{99999999-0000-0008-C000-000000000051}",
  "ProgID52", "objact dll",
  "ProgID52\\CLSID", "{99999999-0000-0008-C000-000000000052}",
  "ProgID53", "objact dll reg",
  "ProgID53\\CLSID", "{99999999-0000-0008-C000-000000000053}",
  "ProgID54", "objact dll reg",
  "ProgID54\\CLSID", "{99999999-0000-0008-C000-000000000054}",
  "ProgID55", "remote activation",
  "ProgID55\\CLSID", "{99999999-0000-0008-C000-000000000055}",
  "ProgID60", "CLSIDFromProgID test",
  "ProgID60\\CLSID", "{0000013a-0001-0008-C000-000000000046}",

  // Indicates end of list.
  "", ""
};

const RegistryKeyValue REG_EXE_KEY[] =
{
  "CLSID\\{20730701-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730711-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730712-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730713-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730714-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730715-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730716-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730717-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",
  "CLSID\\{20730718-0001-0008-C000-000000000046}\\InprocServer32", "oletest.dll",

  "CLSID\\{20730712-0001-0008-C000-000000000046}\\LocalServer32", "bmtstsvr.exe",
  "CLSID\\{20730701-0001-0008-C000-000000000046}\\LocalServer32", "bmtstsvr.exe",

  "CLSID\\{0000013a-0001-0008-C000-000000000046}\\LocalServer32", "ballsrv.exe",
  "CLSID\\{00000138-0001-0008-C000-000000000046}\\InprocServer32", "iballs.dll",
  "CLSID\\{0000013b-0001-0008-C000-000000000046}\\LocalServer32", "cubesrv.exe",
  "CLSID\\{0000013c-0001-0008-C000-000000000046}\\LocalServer32", "loopsrv.exe",
  "CLSID\\{0000013d-0001-0008-C000-000000000046}\\LocalServer32", "rpctst.exe",
  "CLSID\\{0000013e-0001-0008-C000-000000000046}\\InprocServer32", "myproxy.dll",
  "CLSID\\{00000140-0000-0008-C000-000000000046}\\LocalServer32",  "qisrv.exe",
  "CLSID\\{00000140-0000-0008-C000-000000000046}\\InprocServer32", "qisrv.dll",
  "CLSID\\{00000141-0000-0008-C000-000000000046}\\LocalServer32",  "qisrv.exe",
  "CLSID\\{00000141-0000-0008-C000-000000000046}\\InprocHandler32", "ole32.dll",


  "CLSID\\{99999999-0000-0008-C000-000000000050}\\LocalServer32", "sdi.exe",
  "CLSID\\{99999999-0000-0008-C000-000000000051}\\LocalServer32", "mdi.exe",
  "CLSID\\{99999999-0000-0008-C000-000000000052}\\InprocServer32", "dlltest.dll",
  "CLSID\\{99999999-0000-0008-C000-000000000053}\\InprocServer32", "dlltest.dll",
  "CLSID\\{99999999-0000-0008-C000-000000000055}\\LocalServer32", "db.exe",

  // Indicates end of list.
  "", ""
};


//+-------------------------------------------------------------------
//
//  Function: 	RegistrySetup
//
//  Synopsis:	write the registry entries for this program
//
//  Note:       This function uses all Ascii characters and character
//              arithmatic because it has to run on NT and Chicago.
//
//  History:   	16 Dec 94	AlexMit		Created
//
//--------------------------------------------------------------------
BOOL RegistrySetup(char *pszAppName)
{
    char value[REGISTRY_ENTRY_LEN];
    LONG  value_size;
    LONG  result;
    char  directory[MAX_PATH];
    char *appname;
    BOOL  success = FALSE;

    // Write constant entries.
    for (int i = 0; REG_CONST_KEY[i].key[0] != '\0'; i++)
    {
        result = RegSetValueA(
                 HKEY_CLASSES_ROOT,
                 REG_CONST_KEY[i].key,
                 REG_SZ,
                 REG_CONST_KEY[i].value,
                 strlen(REG_CONST_KEY[i].value) );

        if (result != ERROR_SUCCESS)
	        goto cleanup;
    }

    // Compute the path to the application.
    result = GetFullPathNameA(pszAppName, sizeof(directory), directory, &appname);
    if (result == 0)
        goto cleanup;

    // Add the path to all the dll and exe entries.
    for (i = 0; REG_EXE_KEY[i].key[0] != '\0'; i++)
    {
        // Verify that the path will fit in the buffer and compute the path
        // to the next executable.
        if (strlen(REG_EXE_KEY[i].value) >=
            (ULONG)(MAX_PATH - (appname - directory)))
	        goto cleanup;

        strcpy(appname, REG_EXE_KEY[i].value);

        // Write the next entry.
        result = RegSetValueA(
                 HKEY_CLASSES_ROOT,
                 REG_EXE_KEY[i].key,
                 REG_SZ,
                 directory,
                 strlen(directory));

        if (result != ERROR_SUCCESS)
	        goto cleanup;
    }

    success = TRUE;

cleanup:
    return success;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\rpctcf.cxx ===
//+-------------------------------------------------------------------
//
//  File:	rpccf.cxx
//
//  Contents:	rpc test class factory object implementation
//
//  Classes:	CRpcTestClassFactory
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

#include    <pch.cxx>
#pragma     hdrstop
#include    <rpctcf.hxx>	//  class definiton
#include    <crpctyp.hxx>	//  CRpcTests defines


//+-------------------------------------------------------------------
//
//  Member:	CRpcTypesClassFactory::CRpcTypesClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

CRpcTypesClassFactory::CRpcTypesClassFactory(void)
{
    ENLIST_TRACKING(CRpcTypesClassFactory);
}


//+-------------------------------------------------------------------
//
//  Member:	CRpcTypesClassFactory::~CRpcTypesClassFactory, public
//
//  Algorithm:
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

CRpcTypesClassFactory::~CRpcTypesClassFactory(void)
{
    //	automatic actions do the rest of the work
}


//+-------------------------------------------------------------------
//
//  Member:	CRpcTypesClassFactory::QueryInterface, public
//
//  Algorithm:	if the interface is not one implemented by us,
//		pass the request to the proxy manager
//
//  History:	23-Nov-92	Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CRpcTypesClassFactory::QueryInterface(REFIID riid, void **ppUnk)
{
    SCODE sc = S_OK;

    if (IsEqualIID(riid, IID_IUnknown) ||
	IsEqualIID(riid, IID_IClassFactory))
    {
	*ppUnk = (void *)(IClassFactory *) this;
	AddRef();
    }
    else
    {
	*ppUnk = NULL;
	sc = E_NOINTERFACE;
    }
    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CRpcTypesClassFactory::CreateInstance, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CRpcTypesClassFactory::CreateInstance(IUnknown *punkOuter,
						  REFIID   riid,
						  void	   **ppunkObject)
{
    SCODE sc = E_OUTOFMEMORY;

    *ppunkObject = NULL;	//  in case of failure

    //	create a ball object.
    IUnknown *punk = (IUnknown *) new CRpcTypes();

    if (punk)
    {
	//  get the interface the caller wants to use
	sc = punk->QueryInterface(riid, ppunkObject);

	//  release our hold on the ball, since the QI got a hold for
	//  the client.
	punk->Release();
    }

    return  sc;
}



//+-------------------------------------------------------------------
//
//  Member:	CRpcTypesClassFactory::LockServer, public
//
//  Synopsis:	create a new object with the same class
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------

STDMETHODIMP CRpcTypesClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
	GlobalRefs(TRUE);
    else
	GlobalRefs(FALSE);

    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\stream.cxx ===
//+-------------------------------------------------------------------
//
//  File:	stream.cxx
//
//  Contents:	Stream interface on flat File.
//
//  Classes:	CStreamOnFile
//
//  Macros:     DEFINE_INTERFACE_XMIT_ROUTINES
//
//  History:	08-08-95    Rickhi  Created
//
//--------------------------------------------------------------------
#include    <pch.cxx>
#pragma     hdrstop
#include    <stream.hxx>


CStreamOnFile::CStreamOnFile(const TCHAR *pwszFileName, SCODE &sc, BOOL fRead) :
    _clRefs(1),
    _hFile(NULL),
    _lOffset(0),
    _cSize(0),
    _cbData(0),
    _fRead(fRead)
{
    _pbData = new BYTE[2048];		    // should be big enough
    if (!_pbData)
    {
	    sc = E_OUTOFMEMORY;
	    return;
    }

    _cbData = 2048;

    // open the file.
    DWORD fdwCreate;
    if (_fRead)
	    fdwCreate = OPEN_EXISTING;  // open existing, fail if not found.
    else
	    fdwCreate = CREATE_ALWAYS;  // overwrite existing if present


    _hFile = CreateFile(pwszFileName,
			GENERIC_READ | GENERIC_WRITE,	    // fdwAccess
			FILE_SHARE_READ | FILE_SHARE_WRITE, // fdwShareMode
			NULL,			// lpsaSecurity
			fdwCreate,		// creation options
			FILE_ATTRIBUTE_NORMAL,	// attributes & flags
			NULL			// hTemplateFile
			);

    if (_hFile == INVALID_HANDLE_VALUE)
    {
	    sc = HRESULT_FROM_WIN32(GetLastError());
	    return;
    }

    // read the file into the memory block
    DWORD cbRead = 0;
    if (_fRead && ! ReadFile(_hFile,
			    _pbData,
			    _cbData,
			    &cbRead,
			    NULL))
    {
	    sc = HRESULT_FROM_WIN32(GetLastError());
	    return;
    }

    if (_fRead)
    {
	    _cSize = _cbData;
    }

    sc = S_OK;
}

CStreamOnFile::~CStreamOnFile(void)
{
    if (_hFile)
    {
    	if (!_fRead)
    	{
    	    // write the data to the file
    	    DWORD cbWritten = 0;
    	    if (!WriteFile(_hFile,
    			   _pbData,
    			   _cbData,
    			   &cbWritten,
    			   NULL))
    	    {
    		    SCODE sc = HRESULT_FROM_WIN32(GetLastError());
    	    }
    	}

	CloseHandle(_hFile);
    }
}



STDMETHODIMP CStreamOnFile::QueryInterface(
    REFIID iidInterface,
    void FAR* FAR* ppvObj)
{
    HRESULT hresult = S_OK;

    // We only support IUnknown and IStream
    if (IsEqualIID(iidInterface, IID_IUnknown) ||
	IsEqualIID(iidInterface, IID_IStream))
    {
        *ppvObj = this;
        AddRef();
    }
    else
    {
	    *ppvObj = NULL;
	    hresult = E_NOINTERFACE;
    }

    return hresult;
}

STDMETHODIMP_(ULONG) CStreamOnFile::AddRef(void)
{
    InterlockedIncrement(&_clRefs);
    return _clRefs;
}

STDMETHODIMP_(ULONG) CStreamOnFile::Release(void)
{
    if (InterlockedDecrement(&_clRefs) == 0)
    {
	    delete this;
	    return 0;
    }

    return _clRefs;
}

STDMETHODIMP CStreamOnFile::Read(
    VOID HUGEP* pv,
    ULONG cb,
    ULONG FAR* pcbRead)
{
    HRESULT hresult = S_OK;

    if (pcbRead)
    {
        *pcbRead = 0L;
    }

    if (cb + _lOffset > _cSize)
    {
	    cb = _cSize - _lOffset;
        hresult = STG_E_READFAULT;
    }

    memcpy(pv, _pbData + _lOffset, (size_t) cb);
    _lOffset += cb;

    if (pcbRead != NULL)
    {
        *pcbRead = cb;
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::Write(
    VOID  const HUGEP* pv,
    ULONG cbToWrite,
    ULONG FAR* pcbWritten)
{
    HRESULT hresult = S_OK;

    if (pcbWritten)
    {
        *pcbWritten = 0L;
    }

    if (cbToWrite + _lOffset > _cbData)
    {
	    return E_OUTOFMEMORY;
    }

    // copy in the new data
    memcpy(_pbData + _lOffset, pv, (size_t) cbToWrite);
    _lOffset += cbToWrite;

    if (pcbWritten != NULL)
    {
	    *pcbWritten = cbToWrite;
    }

    // We assume maxium size of buffer is the size to send on the network.
    if (_cSize < _lOffset)
    {
	    _cSize = _lOffset;
    }

    return hresult;
}



STDMETHODIMP CStreamOnFile::Seek(
    LARGE_INTEGER dlibMoveIN,
    DWORD dwOrigin,
    ULARGE_INTEGER FAR* plibNewPosition)
{
    HRESULT hresult = S_OK;

    LONG dlibMove = dlibMoveIN.LowPart;
    ULONG cbNewPos = dlibMove;

    switch(dwOrigin)
    {
    case STREAM_SEEK_SET:

        if (dlibMove >= 0)
        {
            _lOffset = dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_CUR:

        if (!(dlibMove < 0 && ((ULONG) -dlibMove > _lOffset)))
        {
            _lOffset += (ULONG) dlibMove;
        }
        else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    case STREAM_SEEK_END:

	    if (!(dlibMove < 0 && ((ULONG) -dlibMove) > _cbData))
        {
	        _lOffset = _cbData + dlibMove;
        }
	    else
        {
            hresult = STG_E_SEEKERROR;
        }
        break;

    default:

        hresult = STG_E_SEEKERROR;
    }

    if (plibNewPosition != NULL)
    {
        ULISet32(*plibNewPosition, _lOffset);
    }

    return hresult;
}

STDMETHODIMP CStreamOnFile::SetSize(ULARGE_INTEGER cb)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::CopyTo(
    IStream FAR* pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER FAR* pcbRead,
    ULARGE_INTEGER FAR* pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Commit(DWORD grfCommitFlags)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::Revert(void)
{
    return NOERROR;
}

STDMETHODIMP CStreamOnFile::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return STG_E_INVALIDFUNCTION;
}

STDMETHODIMP CStreamOnFile::Stat(
    STATSTG FAR* pstatstg,
    DWORD statflag)
{
    memset(pstatstg, 0, sizeof(STATSTG));
    return E_NOTIMPL;
}

STDMETHODIMP CStreamOnFile::Clone(IStream FAR * FAR *ppstm)
{
    return E_NOTIMPL;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\tstmain.cxx ===
//+------------------------------------------------------------------
//
// File:	tmain.cxx
//
// Contents:	entry point common for all test drivers.
//
//--------------------------------------------------------------------
#include <pch.cxx>
#include <tstmain.hxx>
#include <regmain.hxx>

BOOL   fQuiet = 0;   // turn tracing on/off
DWORD  gInitFlag;    // current COINT flag used on main thread.

DWORD dwInitFlag[2] = {COINIT_APARTMENTTHREADED,
			   COINIT_MULTITHREADED};

LPSTR pszInitFlag[2] = {"ApartmentThreaded",
			"MultiThreaded"};


// global statistics counters
LONG	gCountAttempts = 0;	// # of tests attempted
LONG	gCountPassed   = 0;	// # of tests passed
LONG	gCountFailed   = 0;	// # of tests failed

void InitStatistics();
void PrintStatistics();

//+-------------------------------------------------------------------
//
//  Function:	DriverMain
//
//  Synopsis:	Entry point to EXE
//
//  Returns:    TRUE
//
//  History:	21-Nov-92  Rickhi	Created
//
//  Parses parameters, sets the threading model, initializes OLE,
//  runs the test, Uninitializes OLE, reports PASSED/FAILED.
//
//--------------------------------------------------------------------
int _cdecl DriverMain(int argc, char **argv, char *pszTestName, LPFNTEST pfnTest)
{
    char *pszAppName = *argv;

    // default to running both single-thread and multi-thread
    int iStart = 0;
    int iEnd = 2;


    // process the command line args
    if (argc > 1)
    {
        for (int i=argc; i>0; i--, argv++)
        {
            if (!_strnicmp(*argv, "-r", 2))
            {
                // register class information
                RegistrySetup(pszAppName);
                return 0;
            }
            else if (!_strnicmp(*argv, "-q", 2))
            {
                // quiet output
                fQuiet = TRUE;
            }
            else if (!_strnicmp(*argv, "-s", 2))
            {
                // just run single-threaded
                iStart = 0;
                iEnd = 1;
            }
            else if (!_strnicmp(*argv, "-m", 2))
            {
                // just run multi-threaded
                iStart = 1;
                iEnd = 2;
            }
        }
    }


    // run the tests.
    for (int i=iStart; i<iEnd; i++)
    {
        InitStatistics();

        WriteProfileStringA("OleSrv",
        		    "ThreadMode",
        		    pszInitFlag[i]);

        printf ("Starting %s Test with %s threading model\n",
        	 pszTestName, pszInitFlag[i]);

        gInitFlag = dwInitFlag[i];
        SCODE sc = CoInitializeEx(NULL, gInitFlag);

        if (sc != S_OK)
        {
            printf("CoInitializeEx Failed with %lx\n", sc);
            DebugBreak();
            return 1;
        }

        BOOL fRslt = (pfnTest)();

        PrintStatistics();

        if (fRslt)
            printf("%s Tests PASSED\n", pszTestName);
        else
            printf("%s Tests FAILED\n", pszTestName);

        CoUninitialize();
    }

    return 0;
}

//+-------------------------------------------------------------------
//
//  Function:	TestResult
//
//  Synopsis:	prints test results
//
//  History:	21-Nov-92  Rickhi	Created
//
//--------------------------------------------------------------------
BOOL TestResult(BOOL RetVal, LPSTR pszTestName)
{
    gCountAttempts++;

    if (RetVal == TRUE)
    {
        printf ("PASSED: %s\n", pszTestName);
        gCountPassed++;
    }
    else
    {
        printf ("FAILED: %s\n", pszTestName);
        gCountFailed++;
    }

    return  RetVal;
}

//+-------------------------------------------------------------------
//
//  Function:	InitStatistics
//
//  Synopsis:	Initializes run statistics
//
//  History:	21-Nov-92  Rickhi	Created
//
//--------------------------------------------------------------------
void InitStatistics()
{
    gCountAttempts = 0;
    gCountPassed   = 0;
    gCountFailed   = 0;
}

//+-------------------------------------------------------------------
//
//  Function:	PrintStatistics
//
//  Synopsis:	Prints run statistics
//
//  History:	21-Nov-92  Rickhi	Created
//
//--------------------------------------------------------------------
void PrintStatistics()
{
    printf("\nTEST STATISTICS -- Attempted:%d   Passed:%d   Failed:%d\n\n",
	       gCountAttempts, gCountPassed, gCountFailed);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\srvmain.cxx ===
//+-------------------------------------------------------------------
//
//  File:	srvmain.cxx
//
//  Contents:	Server entry points.
//
//  Classes:	none
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
#include    <pch.cxx>
#pragma     hdrstop

extern "C"
{
#include    "wterm.h"
#include    <memory.h>
#include    <stdio.h>
}

// globals
LONG	    g_Usage = 0;
DWORD	    gTlsIndex = TlsAlloc();


//+-------------------------------------------------------------------
//
//  typedef:	SCLASSDATA - class data stored in TLS.
//
//+-------------------------------------------------------------------
typedef struct tagSCLASSDATA
{
    ULONG	cClasses;
    SCLASSINFO *pClsInfo;
} SCLASSDATA;

//+-------------------------------------------------------------------
//
//  Function:	RememberClasses
//
//  Synopsis:	Stores the class info for this thread in TLS.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
HRESULT RememberClasses(SCLASSINFO *pClsInfo, ULONG cClasses)
{
    SCLASSDATA *pClsData = (SCLASSDATA *) new BYTE[sizeof(SCLASSDATA)];

    if (pClsData)
    {
	pClsData->cClasses = cClasses;
	pClsData->pClsInfo = pClsInfo;
	TlsSetValue(gTlsIndex, pClsData);
	return S_OK;
    }

    return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------
//
//  Function:	RecallClasses
//
//  Synopsis:	retrieves the class info for this thread from TLS.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
void RecallClasses(SCLASSINFO **ppClsInfo, ULONG *pcClasses)
{
    SCLASSDATA *pClsData = (SCLASSDATA *) TlsGetValue(gTlsIndex);

    if (pClsData)
    {
	*pcClasses = pClsData->cClasses;
	*ppClsInfo = pClsData->pClsInfo;
    }
    else
    {
	*pcClasses = 0;
	*ppClsInfo = NULL;
    }
}

//+-------------------------------------------------------------------
//
//  Function:	ForgetClasses
//
//  Synopsis:	removes the class info for this thread from TLS.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
void ForgetClasses()
{
    SCLASSDATA *pClsData = (SCLASSDATA *) TlsGetValue(gTlsIndex);

    if (pClsData)
    {
	delete pClsData;
	TlsSetValue(gTlsIndex, NULL);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	RegisterAllClasses
//
//  Synopsis:	loops, registering each class specified by the server.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
void RegisterAllClasses(SCLASSINFO *pClsInfo, ULONG cClasses)
{
    // store the class info in TLS so we can get it back later
    // in GlobalRefs.

    if (FAILED(RememberClasses(pClsInfo, cClasses)))
	return;

    HRESULT hr;

    for (ULONG i=0; i<cClasses; i++, pClsInfo++)
    {
	// register the CF. Note that we do this AFTER creating the
	// window, so that if we get a Release very quickly we have
	// a valid window handle to send a message to.
	hr = CoRegisterClassObject(pClsInfo->clsid,
				   pClsInfo->pCF,
				   pClsInfo->dwCtx,
				   pClsInfo->dwClsReg,
				   &pClsInfo->dwReg);

	if (FAILED(hr))
	{
	    Display(TEXT("ERROR: failed CoRegisterClassObject %x\n"), hr);
	}
    }

    if (FAILED(hr))
    {
	Display(TEXT("ERROR: failed CoResumeClassObjects %x\n"), hr);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	RevokeAllClasses
//
//  Synopsis:	loops, revoking each class specified by the server.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
void RevokeAllClasses()
{
    // first, get the class information from TLS
    SCLASSINFO *pClsInfo;
    ULONG	cClasses;

    RecallClasses(&pClsInfo, &cClasses);

    // now revoke each of the registered classes
    for (ULONG i=0; i<cClasses; i++, pClsInfo++)
    {
	if (pClsInfo->dwReg != 0)
	{
	    ULONG ulRef = CoRevokeClassObject(pClsInfo->dwReg);
	    Display(TEXT("Revoked ClassObject\n"));
	    pClsInfo->dwReg = 0;
	}
    }
}

//+-------------------------------------------------------------------
//
//  Function:	ReleaseAllClasses
//
//  Synopsis:	loops, releasing each class factory object.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
void ReleaseAllClasses()
{
    // first, get the class information from TLS
    SCLASSINFO *pClsInfo;
    ULONG	cClasses;

    RecallClasses(&pClsInfo, &cClasses);

    // now release each of the class factories
    for (ULONG i=0; i<cClasses; i++, pClsInfo++)
    {
	ULONG ulRef = pClsInfo->pCF->Release();
	Display(TEXT("CF RefCnt = %x\n"), ulRef);
    }

    // now remove the class information from TLS
    ForgetClasses();
}

//+-------------------------------------------------------------------------
//
//  Function:	GlobalRefs
//
//  Synopsis:	keeps track of global reference couting. Revokes all the
//		classes when the global count reaches 0.
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
void GlobalRefs(BOOL fAddRef)
{
    if (fAddRef)
    {
	g_Usage = CoAddRefServerProcess();
	Display(TEXT("Object Count: %ld\n"), g_Usage);
    }
    else
    {
	if (0 == (g_Usage = CoReleaseServerProcess()))
	{
	    // No more objects so we can quit
	    Display(TEXT("Object Server Exiting\n"));
	    PostMessage((HWND)g_hMain, WM_TERM_WND, 0, 0);
	}
    }
}

//+-------------------------------------------------------------------
//
//  Function:	SrvMain
//
//  Synopsis:	Special entry point for registing just 1 class.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int SrvMain(
    HANDLE hInstance,
    REFCLSID rclsid,
    DWORD dwClsReg,
    TCHAR *pszAppName,
    IClassFactory *pCF)
{
    SCLASSINFO clsinfo;
    clsinfo.clsid    = rclsid;
    clsinfo.dwCtx    = CLSCTX_LOCAL_SERVER,
    clsinfo.dwClsReg = dwClsReg;
    clsinfo.pCF      = pCF;
    clsinfo.dwReg    = 0;

    STHREADINFO ThrdInfo;
    ThrdInfo.hEventRun	= CreateEvent(NULL, FALSE, FALSE, NULL);
    ThrdInfo.hEventDone = CreateEvent(NULL, FALSE, FALSE, NULL);
    ThrdInfo.hInstance	= (HINSTANCE)hInstance;
    ThrdInfo.dwTid	= GetCurrentThreadId();
    ThrdInfo.pszWindow	= pszAppName;
    ThrdInfo.dwFlags	= SRVF_THREADMODEL_UNKNOWN;
    ThrdInfo.cClasses	= 1;
    ThrdInfo.pClsInfo	= &clsinfo;

    return SrvMain2(&ThrdInfo);
}

//+-------------------------------------------------------------------
//
//  Function:	SrvMain2
//
//  Synopsis:	Main entry point for registering classes, entering modal
//		loop, and cleaning up on exit.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int SrvMain2(STHREADINFO *pThrdInfo)
{
    MakeTheWindow(pThrdInfo->hInstance, pThrdInfo->pszWindow);

    // Initialize the OLE libraries
    DWORD dwThreadMode = COINIT_APARTMENTTHREADED;

    if (pThrdInfo->dwFlags & SRVF_THREADMODEL_UNKNOWN)
    {
	// Look up the thread mode from the win.ini file.
	TCHAR buffer[80];
	int len;

	len = GetProfileString( TEXT("OleSrv"),
			    TEXT("ThreadMode"),
			    TEXT("MultiThreaded"),
			    buffer,
			    sizeof(buffer) );

	if (lstrcmp(buffer, TEXT("ApartmentThreaded")) != 0)
	    dwThreadMode = COINIT_MULTITHREADED;
    }
    else if (pThrdInfo->dwFlags & SRVF_THREADMODEL_MULTI)
    {
	dwThreadMode = COINIT_MULTITHREADED;
    }


    HRESULT hr = CoInitializeEx(NULL, dwThreadMode);

    if (SUCCEEDED(hr))
    {
	// registe all the classes
	RegisterAllClasses(pThrdInfo->pClsInfo, pThrdInfo->cClasses);
    }
    else
    {
	Display(TEXT("ERROR: failed OleInitialize %x\n"), hr);
    }

    if (pThrdInfo->dwFlags & SRVF_REGISTER_RESUME)
    {
	hr = CoResumeClassObjects();
    }

    // notify the main thread we are running now
    SetEvent(pThrdInfo->hEventRun);


    // Message processing loop
    MSG msg;
    while (GetMessage (&msg, NULL, 0, 0))
    {
	TranslateMessage (&msg);
	DispatchMessage (&msg);
    }


    // revoke the classes again incase we missed any (eg. no instances
    // were created, the user just closed the app).
    RevokeAllClasses();

    // release the classes
    ReleaseAllClasses();

    // Tell OLE we are going away.
    CoUninitialize();

    // notify the main thread that we are done
    SetEvent(pThrdInfo->hEventDone);

    return (msg.wParam);   /* Returns the value from PostQuitMessage */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\wterm.h ===
#ifndef __WTERM__
#define __WTERM__

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// Message to print a line on the window
#define WM_PRINT_LINE (WM_USER + 1)

// Message to print a character on the window
#define WM_PUTC (WM_USER + 2)

// Message used to terminate this window
#define WM_TERM_WND (WM_USER + 3)

//
//  Typedefs for call back functions for the window
//
typedef long (*MFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);
typedef long (*CFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);
typedef long (*TFUNCP)(HWND, UINT, WPARAM, LPARAM, void *);

// Register the terminal window class
BOOL TermRegisterClass(
    HANDLE hInstance,
    LPTSTR MenuName,
    LPTSTR ClassName,
    LPTSTR ICON);

// Create a window for the terminal
BOOL
TermCreateWindow(
    LPTSTR lpClassName,
    LPTSTR lpWindowName,
    HMENU hMenu,
    MFUNCP MenuProc,
    CFUNCP CharProc,
    TFUNCP CloseProc,
    int nCmdShow,
    HWND *phNewWindow,
    void *pvCallBackData);

// make the window for the server
void
MakeTheWindow(
    HANDLE hInstance,
    TCHAR *pwszAppName);

extern HWND g_hMain;

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // __WTERM__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\wterm.c ===
/****************************************************************************

    PROGRAM: wterm.c

    PURPOSE: Implementation of TermWClass Windows

    FUNCTIONS:


    COMMENTS:


****************************************************************************/

#include "windows.h"
#include "stdlib.h"
#include "memory.h"
#include "wterm.h"

#define MAX_ROWS 24
#define MAX_COLS 80

typedef struct WData
{
    // Function to execute for processing a menu
    MFUNCP pMenuProc;

    // Function to execute for processing a single character
    CFUNCP pCharProc;

    // Function to execute when window is closed (terminated)
    TFUNCP pCloseProc;

    // Pass on callback
    void *pvCallBackData;

    BOOL fGotFocus;

    BOOL fCaretHidden;

    // Rows on the screen
    int cRows;

    // Columns on the screen
    int cCols;

    // Row at top of screen
    int iTopRow;

    // Row at bottom of the screen
    int iBottomRow;

    // First Column on screen
    int iFirstCol;

    // Column at bottom of the screen
    int iBottomCol;

    // Row for next character
    int iNextRow;

    // Row for next column
    int iNextCol;

    // Width of character
    int cxChar;

    // Height of character
    int cyChar;

    // Memory image of screen this is treated as a circular buffer
    TCHAR aImage[MAX_ROWS] [MAX_COLS];

    // First row in circular screen buffer
    int iBufferTop;
} WData;

static HANDLE hInst = 0;
TCHAR BlankLine[80];

static int
row_diff(
    int row1,
    int row2)
{
    return (row2 > row1)
        ? MAX_ROWS - (row2 - row1)
        : row1 - row2;
}

static void
set_vscroll_pos(
    HWND hwnd,
    WData *pwdata)
{
    if (pwdata->cRows != 0)
    {
        // Save a few indirections by caching cRows
        register int cRows = pwdata->cRows;

        // calculate distance bottom of screen from top of data buffer
        register int top_from_row = row_diff(pwdata->iBottomRow,
            pwdata->iBufferTop);

        // Output position of scroll bar
        int new_pos = 0;

        if (top_from_row >= cRows)
        {
            // Calculate number of screens to display entire buffer
            int screens_for_data = MAX_ROWS / cRows
               + ((MAX_ROWS % cRows != 0) ? 1 : 0);

            // Figure out which screen the row falls in
            int screen_loc = top_from_row / cRows
                + ((top_from_row % cRows != 0) ? 1 : 0);

            // If the screen is in the last one set box to max
            new_pos = (screen_loc == screens_for_data)
                ? MAX_ROWS : screen_loc * cRows;
        }

        SetScrollPos(hwnd, SB_VERT, new_pos, TRUE);
    }
}

static int
calc_row(
    register int row,
    WData *pwdata)
{
    register int top = pwdata->iTopRow;
    static int boopa = 0;

    if (top > row)
        boopa++;

    return (row >= top) ? row - top : (MAX_ROWS - (top - row));
}

static void
display_text(
    HWND hwnd,
    int row,
    int col,
    LPTSTR text,
    int text_len,
    WData *pWData)
{
    // Get the DC to display the text
    HDC hdc = GetDC(hwnd);

    // Select Font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    // Hide caret while we are printing
    HideCaret(hwnd);

    // Update the screen
    TextOut(hdc, (col - pWData->iFirstCol) * pWData->cxChar,
        calc_row(row, pWData) * pWData->cyChar, text, text_len);

    // Done with DC
    ReleaseDC(hwnd, hdc);

    // Put the caret back now that we are done
    ShowCaret(hwnd);
}

static void
display_char(
    HWND hwnd,
    TCHAR char_to_display,
    WData *pWData)
{
    // Update image buffer
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = char_to_display;

    display_text(hwnd, pWData->iNextRow, pWData->iNextCol,
      &char_to_display, 1, pWData);
}

static void
do_backspace(
    HWND hwnd,
    WData *pWData)
{
    // Point to the previous character in the line
    if (--pWData->iNextCol < 0)
    {
        // Can't backspace beyond the current line
        pWData->iNextCol = 0;
        return;
    }

    display_char(hwnd, ' ', pWData);

    // Null character for repaint
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = '\0';
}

static int
inc_row(
    int row,
    int increment)
{
    row += increment;

    if (row >= MAX_ROWS)
    {
        row -= MAX_ROWS;
    }
    else if (row < 0)
    {
        row += MAX_ROWS;
    }

    return row;
}

void
inc_next_row(
    HWND hwnd,
    WData *pWData)
{
    if (pWData->iNextRow == pWData->iBottomRow)
    {
        // Line is at bottom -- scroll the client area one row
        ScrollWindow(hwnd, 0, -pWData->cyChar, NULL, NULL);

        // Increment the top & bottom of the screen
        pWData->iTopRow = inc_row(pWData->iTopRow, 1);
        pWData->iBottomRow = inc_row(pWData->iBottomRow, 1);
    }

    // Increment the row
    pWData->iNextRow = inc_row(pWData->iNextRow, 1);

    if (pWData->iNextRow == pWData->iBufferTop)
    {
        // Have to reset circular buffer to next
        pWData->iBufferTop = inc_row(pWData->iBufferTop, 1);

        // Reset line to nulls for repaint
        memset(&pWData->aImage[pWData->iNextRow][0], '\0', MAX_COLS);
    }

    pWData->iNextCol = 0;
}

static void
do_cr(
    HWND hwnd,
    WData *pWData)
{
    // Set position to next row
    inc_next_row(hwnd, pWData);
    pWData->iNextCol = 0;

    // Make sure next character is null for repaint of line
    pWData->aImage[pWData->iNextRow][pWData->iNextCol] = '\0';

    // Update the vertical scroll bar's position
    set_vscroll_pos(hwnd, pWData);
}

static void
do_char(
    HWND hwnd,
    WPARAM wParam,
    WData *pWData)
{
    display_char(hwnd, (TCHAR) wParam, pWData);

    // Point to the next character in the line
    if (++pWData->iNextCol > MAX_COLS)
    {
        // Handle switch to next line
        inc_next_row(hwnd, pWData);
    }
}

static void
do_tab(
    HWND hwnd,
    WData *pWData)
{
    int c = pWData->iNextCol % 8;

    if ((pWData->iNextCol + c) <= MAX_COLS)
    {
        for ( ; c; c--)
        {
            do_char(hwnd, ' ', pWData);
        }
    }
    else
    {
        do_cr(hwnd, pWData);
    }
}

static void
EchoChar(
    HWND hwnd,
    WORD cRepeats,
    WPARAM wParam,
    WData *pWData)
{
    for ( ; cRepeats; cRepeats--)
    {
        switch (wParam)
        {
        // Backspace
        case '\b':
            do_backspace(hwnd, pWData);
            break;

        // Carriage return
        case '\n':
        case '\r':
            do_cr(hwnd, pWData);
            break;

        // Tab
        case '\t':
            do_tab(hwnd, pWData);
            break;

        // Regular characters
        default:
            do_char(hwnd, wParam, pWData);
        }
    }

    // The row is guaranteed to be on the screen because we will
    // scroll on a CR. However, the next column for input may be
    // beyond the window we are working in.
    if (pWData->iNextCol > pWData->iBottomCol)
    {
        // We are out of the window so scroll the window one
        // column to the right.
        SendMessage(hwnd, WM_HSCROLL, SB_LINEDOWN, 0L);
    }
    else if (pWData->iNextCol < pWData->iFirstCol)
    {
        // We are out of the window so repaint the window using
        // iNextCol as the first column for the screen.
        pWData->iFirstCol = pWData->iNextCol;
        pWData->iBottomCol = pWData->iFirstCol + pWData->cCols - 1;

        // Reset scroll bar
        SetScrollPos(hwnd, SB_HORZ, pWData->iFirstCol, TRUE);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
    else
    {
        // Reset Caret's position
        SetCaretPos((pWData->iNextCol - pWData->iFirstCol) * pWData->cxChar,
            calc_row(pWData->iNextRow, pWData) * pWData->cyChar);
    }
}

/****************************************************************************

    FUNCTION: WmCreate(HWND)

    PURPOSE:  Initializes control structures for a TermWClass Window

    MESSAGES:
              WM_CREATE

    COMMENTS:

            This prepares a window for processing character based
            I/O. In particular it does stuff like calculate the
            size of the window needed.

****************************************************************************/
static void
WmCreate(
    HWND hwnd,
    CREATESTRUCT *pInit)
{
    WData *pData = (WData *) (pInit->lpCreateParams);
    HDC hdc = GetDC(hwnd);
    TEXTMETRIC tm;

    // Store pointer to window data
    SetWindowLong(hwnd, 0, (LONG) pData);

    // Set font to system fixed font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    // Calculate size of a character
    GetTextMetrics(hdc, &tm);
    pData->cxChar = tm.tmAveCharWidth;
    pData->cyChar = tm.tmHeight;
    ReleaseDC(hwnd, hdc);

    // Set up vertical scroll bars
    SetScrollRange(hwnd, SB_VERT, 0, MAX_ROWS, TRUE);
    SetScrollPos(hwnd, SB_VERT, 0, TRUE);

    // Set up horizontal scroll bars
    SetScrollRange(hwnd, SB_HORZ, 0, MAX_COLS, TRUE);
    SetScrollPos(hwnd, SB_HORZ, 0, TRUE);
}

/****************************************************************************

    FUNCTION: WmSize(HWND, WORD, LONG)

    PURPOSE:  Processes a size message

    MESSAGES:

    COMMENTS:

****************************************************************************/
static void
WmSize(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    // Get the new size of the window
    int cxClient;
    int cyClient;
    int cRowChange = pwdata->cRows;
    RECT rect;

    // Get size of client area
    GetClientRect(hwnd, &rect);

    // Calculate size of client area
    cxClient = rect.right - rect.left;
    cyClient = rect.bottom - rect.top;

    // Calculate size of area in rows
    pwdata->cCols = cxClient / pwdata->cxChar;
    pwdata->cRows = min(MAX_ROWS, cyClient / pwdata->cyChar);
    pwdata->iBottomCol = min(pwdata->iFirstCol + pwdata->cCols, MAX_COLS);
    cRowChange = pwdata->cRows - cRowChange;

    // Keep input line toward bottom of screen
    if (cRowChange < 0)
    {
        // Screen has shrunk in size.
        if (pwdata->iNextRow != pwdata->iTopRow)
        {
            // Has input row moved out of screen?
            if (row_diff(pwdata->iNextRow, pwdata->iTopRow) >= pwdata->cRows)
            {
                // Yes -- Calculate top new top that puts input line on
                // the bottom.
                pwdata->iTopRow =
                    inc_row(pwdata->iNextRow, 1 - pwdata->cRows);
            }
        }
    }
    else
    {
        // Screen has gotten bigger -- Display more text if possible
        if (pwdata->iTopRow != pwdata->iBufferTop)
        {
            pwdata->iTopRow = inc_row(pwdata->iTopRow,
                -(min(row_diff(pwdata->iTopRow, pwdata->iBufferTop),
                    cRowChange)));
        }
    }

    // Calculate new bottom
    pwdata->iBottomRow = inc_row(pwdata->iTopRow, pwdata->cRows - 1);

    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);
}

static void
WmSetFocus(
    HWND hwnd,
    WData *pwdata)
{
    // save indirections
    register int cxchar = pwdata->cxChar;
    register int cychar = pwdata->cyChar;
    pwdata->fGotFocus = TRUE;
    CreateCaret(hwnd, NULL, cxchar, cychar);

    if (!pwdata->fCaretHidden)
    {
        SetCaretPos(pwdata->iNextCol * cxchar,
            calc_row(pwdata->iNextRow, pwdata) * cychar);
    }

    ShowCaret(hwnd);
}

static void
WmKillFocus(
    HWND hwnd,
    WData *pwdata)
{
    pwdata->fGotFocus = FALSE;

    if (!pwdata->fCaretHidden)
    {
        HideCaret(hwnd);
    }

    DestroyCaret();
}

static void
WmVscroll(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    int cVscrollInc = 0;
    register int top_diff = row_diff(pwdata->iTopRow, pwdata->iBufferTop);
    register int bottom_diff = MAX_ROWS - (top_diff + pwdata->cRows);

    switch(wParam)
    {
    case SB_TOP:

        if (top_diff != 0)
        {
            cVscrollInc = -top_diff;
        }

        break;

    case SB_BOTTOM:

        if (bottom_diff != 0)
        {
            cVscrollInc = bottom_diff;
        }

        break;

    case SB_LINEUP:

        if (top_diff != 0)
        {
            cVscrollInc = -1;
        }

        break;

    case SB_LINEDOWN:

        if (bottom_diff != 0)
        {
            cVscrollInc = 1;
        }

        break;

    case SB_PAGEUP:

        if (top_diff != 0)
        {
            cVscrollInc = - ((top_diff > pwdata->cRows)
                ? pwdata->cRows : top_diff);
        }

        break;

    case SB_PAGEDOWN:

        if (bottom_diff != 0)
        {
            cVscrollInc = (bottom_diff > pwdata->cRows)
                ? pwdata->cRows : bottom_diff;
        }

        break;

    case SB_THUMBTRACK:

        if (LOWORD(lParam) != 0)
        {
            cVscrollInc = LOWORD(lParam)
                - row_diff(pwdata->iTopRow, pwdata->iBufferTop);
        }
    }

    // Cacluate new top row
    if (cVscrollInc != 0)
    {
        // Calculate new top and bottom
        pwdata->iTopRow = inc_row(pwdata->iTopRow, cVscrollInc);
        pwdata->iBottomRow = inc_row(pwdata->iTopRow, pwdata->cRows);

        // Scroll window
        ScrollWindow(hwnd, 0, pwdata->cyChar * cVscrollInc, NULL, NULL);

        // Reset scroll bar
        set_vscroll_pos(hwnd, pwdata);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
}

static void
WmHscroll(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pwdata)
{
    register int cHscrollInc = 0;

    switch(wParam)
    {
    case SB_LINEUP:

        cHscrollInc = -1;
        break;

    case SB_LINEDOWN:

        cHscrollInc = 1;
        break;

    case SB_PAGEUP:

        cHscrollInc = -8;
        break;

    case SB_PAGEDOWN:

        cHscrollInc = 8;
        break;

    case SB_THUMBTRACK:

        if (LOWORD(lParam) != 0)
        {
            cHscrollInc = LOWORD(lParam) - pwdata->iFirstCol;
        }
    }

    if (cHscrollInc != 0)
    {
        // Cacluate new first column
        register int NormalizedScrollInc = cHscrollInc + pwdata->iFirstCol;

        if (NormalizedScrollInc < 0)
        {
            cHscrollInc = -pwdata->iFirstCol;
        }
        else if (NormalizedScrollInc > MAX_COLS - pwdata->cCols)
        {
            cHscrollInc = (MAX_COLS - pwdata->cCols) - pwdata->iFirstCol;
        }

        pwdata->iFirstCol += cHscrollInc;
        pwdata->iBottomCol = pwdata->iFirstCol + pwdata->cCols - 1;

        // Scroll window
        ScrollWindow(hwnd, -(pwdata->cxChar * cHscrollInc), 0, NULL, NULL);

        // Reset scroll bar
        SetScrollPos(hwnd, SB_HORZ, pwdata->iFirstCol, TRUE);

        // Tell window to update itself.
        InvalidateRect(hwnd, NULL, TRUE);
        UpdateWindow(hwnd);
    }
}

static void
WmPaint(
    HWND hwnd,
    WData *pwdata)
{
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(hwnd, &ps);
    register int row = pwdata->iTopRow;
    register int col = pwdata->iFirstCol;
    int bottom_row = pwdata->iBottomRow;
    int cxChar = pwdata->cxChar;
    int cyChar = pwdata->cyChar;
    int y;

    // Select System Font
    SelectObject(hdc, GetStockObject(SYSTEM_FIXED_FONT));

    while (TRUE)
    {
	int len = lstrlen(&pwdata->aImage[row][col]);

        if (len != 0)
        {
            y = calc_row(row, pwdata) * cyChar;
	    TextOut(hdc, 0, y, &pwdata->aImage[row][col], len);
        }

        if (row == bottom_row)
        {
            break;
        }

        row = inc_row(row, 1);
    }

    if (pwdata->fGotFocus)
    {
        if ((pwdata->iNextCol >= pwdata->iFirstCol)
            && (row_diff(pwdata->iNextRow, pwdata->iTopRow) < pwdata->cRows))
        {
            if (pwdata->fCaretHidden)
            {
                pwdata->fCaretHidden = FALSE;
                ShowCaret(hwnd);
            }

            SetCaretPos(
                (pwdata->iNextCol - pwdata->iFirstCol) * pwdata->cxChar,
                calc_row(pwdata->iNextRow, pwdata) * pwdata->cyChar);
        }
        else
        {
            if (!pwdata->fCaretHidden)
            {
                pwdata->fCaretHidden = TRUE;
                HideCaret(hwnd);
            }
        }
    }

    EndPaint(hwnd, &ps);
}





//
//  FUNCTION:   WmPrintLine
//
//  PURPOSE:    Print a line on the screen.
//
//  Note: this is a user message not an intrinsic Window's message.
//
void
WmPrintLine(
    HWND hwnd,
    WPARAM wParam,
    LONG lParam,
    WData *pTermData)
{
    TCHAR *pBuf = (TCHAR *) lParam;

    // MessageBox(hwnd, L"WmPrintLine", L"Debug", MB_OK);

    // DebugBreak();

    while (wParam--)
    {
        // Is character a lf?
        if (*pBuf == '\n')
        {
            // Convert to cr since that is what this window uses
            *pBuf = '\r';
        }

        // Write the character to the window
        EchoChar(hwnd, 1, *pBuf++, pTermData);
    }

}

//
//  FUNCTION:   WmPutc
//
//  PURPOSE:    Print a single character on the screen
//
//  Note: this is a user message not an intrinsic Window's message.
//
void
WmPutc(
    HWND hwnd,
    WPARAM wParam,
    WData *pTermData)
{
    // Is character a lf?
    if (wParam == '\n')
    {
        // Convert to cr since that is what this window uses
        wParam = '\r';
    }

    // Write the character to the window
    EchoChar(hwnd, 1, wParam, pTermData);
}


/****************************************************************************

    FUNCTION: TermWndProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

    MESSAGES:

    COMMENTS:

****************************************************************************/

long TermWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    WData *pTerm = (WData *) GetWindowLong(hWnd, 0);

    switch (message)
    {
        case WM_CREATE:
            WmCreate(hWnd, (CREATESTRUCT *) lParam);
            break;

        case WM_COMMAND:
        case WM_SYSCOMMAND:
            // Call procedure that processes the menus
            return (*(pTerm->pMenuProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_SIZE:
            WmSize(hWnd, wParam, lParam, pTerm);
            break;

        case WM_SETFOCUS:
            WmSetFocus(hWnd, pTerm);
            break;

        case WM_KILLFOCUS:
            WmKillFocus(hWnd, pTerm);
            break;

        case WM_VSCROLL:
            WmVscroll(hWnd, wParam, lParam, pTerm);
            break;

        case WM_HSCROLL:
            WmHscroll(hWnd, wParam, lParam, pTerm);
            break;

        case WM_CHAR:
            // Character message echo and put in buffer
            return (*(pTerm->pCharProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_PAINT:
            WmPaint(hWnd, pTerm);
            break;

        case WM_CLOSE:
            DestroyWindow(hWnd);
            break;

        case WM_NCDESTROY:
            // Call close notification procedure
            return (*(pTerm->pCloseProc))(hWnd, message, wParam, lParam,
                pTerm->pvCallBackData);

        case WM_PRINT_LINE:
            WmPrintLine(hWnd, wParam, lParam, pTerm);
            break;

        case WM_PUTC:
            WmPutc(hWnd, wParam, pTerm);
            break;

	case WM_DESTROY:
	    PostQuitMessage(0);
	    break;

	case WM_TERM_WND:
	    DestroyWindow(hWnd);
	    break;

	default:			  /* Passes it on if unproccessed    */
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }

    return 0;
}


/****************************************************************************

    FUNCTION: TermRegisterClass(HANDLE)

    PURPOSE:  Register a class for a terminal window

    COMMENTS:


****************************************************************************/

BOOL TermRegisterClass(
    HANDLE hInstance,
    LPTSTR MenuName,
    LPTSTR ClassName,
    LPTSTR Icon)
{
    WNDCLASS  wc;
    BOOL retVal;

    // Make sure blank line is blank
    memset(BlankLine, ' ', 80);

    /* Fill in window class structure with parameters that describe the       */
    /* main window.                                                           */

    wc.style = 0;
    wc.lpfnWndProc = TermWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(WData *);
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(NULL, Icon);
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  MenuName;
    wc.lpszClassName = ClassName;

    /* Register the window class and return success/failure code. */
    if (retVal = RegisterClass(&wc))
    {
        // Class got registered -- so finish set up
        hInst = hInstance;
    }

    return retVal;
}


/****************************************************************************

    FUNCTION:  TermCreateWindow(LPTSTR, LPTSTR, HMENU, void *, void *, int)

    PURPOSE:   Create a window of a previously registered window class

    COMMENTS:


****************************************************************************/

BOOL
TermCreateWindow(
    LPTSTR lpClassName,
    LPTSTR lpWindowName,
    HMENU hMenu,
    MFUNCP MenuProc,
    CFUNCP CharProc,
    TFUNCP CloseProc,
    int nCmdShow,
    HWND *phNewWindow,
    void *pvCallBackData)
{
    HWND            hWnd;               // Main window handle.
    WData           *pTermData;

    // Allocate control structure for the window
    if ((pTermData = malloc(sizeof(WData))) == NULL)
    {
        return FALSE;
    }

    // Set entire structure to nulls
    memset((TCHAR *) pTermData, '\0', sizeof(WData));

    // Initialize function pointers
    pTermData->pMenuProc = MenuProc;
    pTermData->pCharProc = CharProc;
    pTermData->pCloseProc = CloseProc;

    // Initialize callback data
    pTermData->pvCallBackData = pvCallBackData;

    // Create a main window for this application instance.
    hWnd = CreateWindow(
        lpClassName,
        lpWindowName,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        CW_USEDEFAULT,
        NULL,
        hMenu,
        hInst,
	(LPTSTR) pTermData
    );

    // If window could not be created, return "failure"

    if (!hWnd)
    {
        free(pTermData);
        return FALSE;
    }

    SetFocus(hWnd);

    // Make the window visible; update its client area; and return "success"

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);
    *phNewWindow = hWnd;
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\common\wterm2.cxx ===
//+-------------------------------------------------------------------
//
//  File:	wterm2.cxx
//
//  Contents:	Shared Windows Procedures
//
//  Classes:	none
//
//  History:	23-Nov-92   Rickhi	Created
//
//--------------------------------------------------------------------
#include    <pch.cxx>
#pragma     hdrstop

extern "C"
{
#include    "wterm.h"
#include    <memory.h>
#include    <stdio.h>
}

//  function prototypes
long ProcessMenu(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
		 void *);
long ProcessChar(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
		 void *);
long ProcessClose(
    HWND hWindow,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam,
    void *pvCallBackData);

#define IDM_DEBUG 0x100

// global variables.

HWND	    g_hMain;
#if DBG==1
BOOL  g_fDisplay = 1;
#else
BOOL  g_fDisplay = 0;
#endif


//+-------------------------------------------------------------------------
//
//  Function:	Display
//
//  Synopsis:	prints a message on the window
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
void Display(TCHAR *pszFmt, ...)
{
    //	since it takes a long time to display these messages and we dont
    //	want to skew benchmarks, displaying the messages is optional.
    //	the messages are usefull for debugging.

    if (!g_fDisplay)
	return;

    va_list marker;
    TCHAR szBuffer[256];

    va_start(marker, pszFmt);

#ifdef UNICODE
    int iLen = vswprintf(szBuffer, pszFmt, marker);
#else
    int iLen = vsprintf(szBuffer, pszFmt, marker);
#endif

    va_end(marker);

    // Display the message on terminal window
    SendMessage(g_hMain, WM_PRINT_LINE, iLen, (LONG) szBuffer);
}

//+-------------------------------------------------------------------------
//
//  Function:	ProcessMenu
//
//  Synopsis:	Gets called when a WM_COMMAND message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessMenu(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
    void *)
{
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}

//+-------------------------------------------------------------------------
//
//  Function:	ProcessChar
//
//  Synopsis:	Gets called when a WM_CHAR message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessChar(HWND hWindow, UINT uiMessage, WPARAM wParam, LPARAM lParam,
    void *)
{
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}

//+-------------------------------------------------------------------------
//
//  Function:	ProcessClose
//
//  Synopsis:	Gets called when a NC_DESTROY message received.
//
//  Arguments:	[hWindow] - handle for the window
//		[uiMessage] - message id
//		[wParam] - word parameter
//		[lParam] - long parameter
//
//  Returns:	DefWindowProc result
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
long ProcessClose(
    HWND hWindow,
    UINT uiMessage,
    WPARAM wParam,
    LPARAM lParam,
    void *pvCallBackData)
{
    // Take default action with message
    return (DefWindowProc(hWindow, uiMessage, wParam, lParam));
}

//+-------------------------------------------------------------------------
//
//  Function:	MakeTheWindow
//
//  Synopsis:	Creates the terminal window.
//
//  Arguments:	[hInstance] -
//		[pwszAppName] - app name to display
//
//  History:	06-Aug-92 Ricksa    Created
//
//--------------------------------------------------------------------------
void MakeTheWindow(HANDLE hInstance, TCHAR *pwszAppName)
{
    // Register the window class
    TermRegisterClass(hInstance, (LPTSTR) pwszAppName,
	 (LPTSTR) pwszAppName, (LPTSTR) (1));

    // Create the server window
    TermCreateWindow(
	(LPTSTR) pwszAppName,
	(LPTSTR) pwszAppName,
	NULL,
	ProcessMenu,
	ProcessChar,
	ProcessClose,
	SW_SHOWMINIMIZED,
	(HWND *)&g_hMain,
	NULL);

    // Add debug option to system menu
    HMENU hmenu = GetSystemMenu(g_hMain, FALSE);
    AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hmenu, MF_STRING | MF_ENABLED, IDM_DEBUG, TEXT("Debug"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\chicago.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF

DLLENTRY=     _DllMainCRTStartup

DLLBASE=@$(COFFBASE_TXT_FILE),usermode


!include      ..\..\..\chicago.inc

INCLUDES=     ;..;$(OLEBALLSDIR)\common;
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\chicago

UMTYPE=       windows
UMAPPL=
UMTEST=

LINKLIBS=     \
	      ..\..\..\oleprx32\uuid\chicago\$(O)\uuid.lib	      \
	      ..\..\..\common\chicago\$(O)\servers.lib       \
	      $(BASEDIR)\private\ole32\common\chicago\$(O)\common.lib	\
	      $(SDK_LIB_PATH)\uuid.lib	      \
	      $(SDK_LIB_PATH)\ole32.lib	      \
              $(SDK_LIB_PATH)\gdi32.lib           \
              $(SDK_LIB_PATH)\kernel32.lib        \
              $(SDK_LIB_PATH)\user32.lib          \
              $(SDK_LIB_PATH)\advapi32.lib

!IF $(386)
NTTARGETFILE0=$(DLLDEF:*=i386)
!ENDIF

!IF $(MIPS)
NTTARGETFILE0=$(DLLDEF:*=mips)
!ENDIF

!IF $(ALPHA)
NTTARGETFILE0=$(DLLDEF:*=alpha)
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF

DLLENTRY=     _DllMainCRTStartup

DLLBASE=@$(COFFBASE_TXT_FILE),usermode


!include      ..\..\..\daytona.inc

INCLUDES=     ;..;$(OLEBALLSDIR)\common;
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\daytona

UMTYPE=       windows
UMAPPL=
UMTEST=

LINKLIBS=     \
	      ..\..\..\oleprx32\uuid\daytona\$(O)\uuid.lib	      \
	      ..\..\..\common\daytona\$(O)\servers.lib       \
	      $(BASEDIR)\private\ole32\common\daytona\$(O)\common.lib	\
	      $(SDK_LIB_PATH)\uuid.lib	      \
	      $(SDK_LIB_PATH)\ole32.lib	      \
              $(SDK_LIB_PATH)\gdi32.lib           \
              $(SDK_LIB_PATH)\kernel32.lib        \
              $(SDK_LIB_PATH)\user32.lib          \
              $(SDK_LIB_PATH)\advapi32.lib

!IF $(386)
NTTARGETFILE0=$(DLLDEF:*=i386)
!ENDIF

!IF $(MIPS)
NTTARGETFILE0=$(DLLDEF:*=mips)
!ENDIF

!IF $(ALPHA)
NTTARGETFILE0=$(DLLDEF:*=alpha)
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\dlltest\dlltest.cxx ===
//+-------------------------------------------------------------------
//
//  File:	dlltest.cxx
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      DllGetClassObject (Bindings key func)
//			CAdvBndCF (class factory)
//			CAdvBnd   (actual class implementation)
//
//  Classes:	CAdvBndCF, CAdvBnd
//
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------

#include    <windows.h>
#include    <ole2.h>
// #include    <debnot.h>
#include    <sem.hxx>
#include    <actcf.hxx>


static GUID CLSID_TestNoRegister =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x52}};

static GUID CLSID_TestRegister =
    {0x99999999,0x0000,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x53}};

// The class objects can be totally static in a DLL
CActClassFactory clsfactNoRegister(CLSID_TestNoRegister, FALSE);
CActClassFactory clsfactRegister(CLSID_TestRegister, FALSE);

CMutexSem mxsUnloadTest;

BOOL fUnload = FALSE;

DWORD dwRegistration;

ULONG gUsage = 0;


extern "C" BOOL WINAPI DllMain (HANDLE  hDll,
				  DWORD   dwReason,
				  LPVOID  pvReserved)
{
    return TRUE;
}



void GlobalRefs(BOOL fAddRef)
{
    if (fAddRef)
    {
	gUsage++;
    }
    else
    {
	gUsage--;
    }
}


STDAPI DllCanUnloadNow(void)
{
    CLock clk(mxsUnloadTest);

    if (gUsage == 0)
    {
	fUnload = TRUE;

	if (dwRegistration != 0)
	{
	    HRESULT hr = CoRevokeClassObject(dwRegistration);

	    Win4Assert(SUCCEEDED(hr) && "CoRevokeClassObject failed!!");
	}
    }

    return (gUsage == 0);
}

STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    CLock clk(mxsUnloadTest);

    if (fUnload)
    {
	return E_UNEXPECTED;
    }

    if (IsEqualCLSID(clsid, CLSID_TestNoRegister))
    {
	clsfactNoRegister.AddRef();
	*ppv = &clsfactNoRegister;
    }
    else if (IsEqualCLSID(clsid, CLSID_TestRegister))
    {
	clsfactNoRegister.AddRef();
	*ppv = &clsfactNoRegister;

	if (dwRegistration == 0)
	{
	    // Register the class
	    HRESULT hr = CoRegisterClassObject(CLSID_TestRegister,
		&clsfactRegister, CLSCTX_INPROC_SERVER, REGCLS_MULTIPLEUSE,
		    &dwRegistration);

	    Win4Assert(SUCCEEDED(hr) && "CoRegisterClassObject failed!!");

	    // Decrement the global reference count since the registration
	    // bumped the reference count because it does an addref
	    gUsage--;
	}
    }
    else
    {
	return E_UNEXPECTED;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\cairo.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

DLLENTRY=     _DllMainCRTStartup

DLLBASE=@$(COFFBASE_TXT_FILE),usermode


!include      ..\..\..\daytona.inc

INCLUDES=     ..\;..\..\..\..\..\cinc;..\..\..\oleprx32\proxy;..\..\..\common

UMTYPE=       windows
UMAPPL=
UMTEST=

LINKLIBS=     \
	      ..\..\..\oleprx32\uuid\daytona\$(O)\uuid.lib	      \
	      ..\..\..\common\daytona\$(O)\servers.lib       \
	      $(BASEDIR)\private\ole32\com\port\daytona\$(O)\port.lib	\
	      $(BASEDIR)\private\ole32\common\daytona\$(O)\common.lib	\
	      $(SDK_LIB_PATH)\uuid.lib	      \
	      $(SDK_LIB_PATH)\ole32.lib	      \
              $(SDK_LIB_PATH)\gdi32.lib           \
              $(SDK_LIB_PATH)\kernel32.lib        \
              $(SDK_LIB_PATH)\user32.lib          \
              $(SDK_LIB_PATH)\advapi32.lib

!IF $(386)
NTTARGETFILE0=$(DLLDEF:*=i386)
!ENDIF

!IF $(MIPS)
NTTARGETFILE0=$(DLLDEF:*=mips)
!ENDIF

!IF $(ALPHA)
NTTARGETFILE0=$(DLLDEF:*=alpha)
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\dlltest\cairo\makefile.inc ===
obj\i386\dlltest.def: dlltest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\dlltest\chicago\makefile.inc ===
obj\i386\dlltest.def: dlltest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\dlltest\daytona\makefile.inc ===
obj\i386\dlltest.def: dlltest.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\oleimpl\chicago\makefile.inc ===
obj\i386\oleimpl.def: oleimpl.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\oleimpl\cairo\makefile.inc ===
obj\i386\oleimpl.def: oleimpl.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\oleimpl\oleimpl.cxx ===
//+-------------------------------------------------------------------
//
//  File:       oleimpl.cxx
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      DllGetClassObject (Bindings key func)
//                      CBasicBndCF (class factory)
//                      CBasicBnd   (actual class implementation)
//
//  Classes:    CBasicBndCF, CBasicBnd
//
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------

#include    <windows.h>
#include    <ole2.h>
#include    <bscbnd.hxx>


extern ULONG g_UseCount;

CBasicBndCF *g_pcf = NULL;


//+-------------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:  
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

extern "C" BOOL WINAPI DLLMain (HANDLE  hDll,
				  DWORD   dwReason,
				  LPVOID  pvReserved)
{
    return TRUE;
}


//+-------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Called by client (from within BindToObject et al)
//              interface requested  should be IUnknown or IClassFactory - 
//              Creates ClassFactory object and returns pointer to it
//
//  Arguments:  REFCLSID clsid    - class id
//              REFIID iid        - interface id
//              void FAR* FAR* ppv- pointer to class factory interface
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------


STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    if (!IsEqualIID(iid, IID_IUnknown) && !IsEqualIID(iid, IID_IClassFactory))
    {
	return E_NOINTERFACE;
    }

    if (IsEqualCLSID(clsid, CLSID_BasicBnd))
    {
	if (g_pcf)
	{
	    *ppv = g_pcf;
	    g_pcf->AddRef();
	}
	else
	{
	    *ppv = new CBasicBndCF();
	}

	return (*ppv != NULL) ? S_OK : E_FAIL;
    }

    return E_FAIL;
}


STDAPI DllCanUnloadNow(void)
{
    return (g_UseCount == 0) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\oleimpl\daytona\makefile.inc ===
obj\i386\oleimpl.def: oleimpl.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\qi\cairo\makefile.inc ===
obj\i386\qisrv.def: qisrv.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\qi\qisrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:	qisrv.cxx
//
//  Contents:   This file contins the DLL entry points
//			DllGetClassObject
//			DllCanUnloadNow
//
//  History:	30-Nov-92      Rickhi	    Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <qicf.hxx>

ULONG gUsage = 0;


extern "C" BOOL WINAPI DllMain (HANDLE  hDll,
				DWORD	dwReason,
				LPVOID	pvReserved)
{
    return TRUE;
}

void GlobalRefs(BOOL fAddRef)
{
    if (fAddRef)
    {
	gUsage++;
    }
    else
    {
	gUsage--;
    }
}

STDAPI DllCanUnloadNow(void)
{
    return (gUsage == 0);
}

STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    if (IsEqualCLSID(clsid, CLSID_QI) ||
	IsEqualCLSID(clsid, CLSID_QIHANDLER))
    {
	*ppv = (void *)(IClassFactory *) new CQIClassFactory(clsid);
    }
    else
    {
	return E_UNEXPECTED;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\qi\daytona\makefile.inc ===
obj\i386\qisrv.def: qisrv.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\rpctst\chicago\makefile.inc ===
obj\i386\rpcsrv.def: rpcsrv.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\rpctst\cairo\makefile.inc ===
obj\i386\rpcsrv.def: rpcsrv.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\qi\chicago\makefile.inc ===
obj\i386\qisrv.def: qisrv.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\rpctst\rpcsrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:	rpcsrv.cxx
//
//  Contents:   This file contins the DLL entry points
//			DllGetClassObject
//			DllCanUnloadNow
//
//  Classes:
//
//  History:	30-Nov-92      Rickhi	    Created
//
//---------------------------------------------------------------------

#include    <windows.h>
#include    <ole2.h>
#include    <rpccf.hxx>


ULONG gUsage = 0;


extern "C" BOOL WINAPI DllMain(HANDLE  hDll,
				  DWORD   dwReason,
				  LPVOID  pvReserved)
{
    return TRUE;
}


void GlobalRefs(BOOL fAddRef)
{
    if (fAddRef)
    {
	gUsage++;
    }
    else
    {
	gUsage--;
    }
}


STDAPI DllCanUnloadNow(void)
{
    return (gUsage == 0);
}



STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    if (IsEqualCLSID(clsid, CLSID_RpcTest))
    {
	*ppv = (void *)(IClassFactory *) new CRpcTestClassFactory();
    }
    else
    {
	return E_UNEXPECTED;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\myproxy\daytona\makefile.inc ===
obj\i386\qisrv.def: qisrv.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\dll\rpctst\daytona\makefile.inc ===
obj\i386\rpcsrv.def: rpcsrv.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\myproxy\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF

DLLENTRY=     _DllMainCRTStartup

DLLBASE=@$(COFFBASE_TXT_FILE),usermode


!include      ..\..\daytona.inc

INCLUDES=     ;..;$(OLEBALLSDIR)\common;
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\daytona

UMTYPE=       windows
UMAPPL=
UMTEST=

LINKLIBS=     \
	      ..\..\oleprx32\uuid\daytona\$(O)\uuid.lib	      \
	      ..\..\common\daytona\$(O)\servers.lib	     \
	      $(OLEDIR)\common\daytona\$(O)\common.lib    \
	      $(SDK_LIB_PATH)\uuid.lib	      \
	      $(SDK_LIB_PATH)\ole32.lib	      \
              $(SDK_LIB_PATH)\gdi32.lib           \
              $(SDK_LIB_PATH)\kernel32.lib        \
              $(SDK_LIB_PATH)\user32.lib          \
              $(SDK_LIB_PATH)\advapi32.lib

!IF $(386)
NTTARGETFILE0=$(DLLDEF:*=i386)
!ENDIF

!IF $(MIPS)
NTTARGETFILE0=$(DLLDEF:*=mips)
!ENDIF

!IF $(ALPHA)
NTTARGETFILE0=$(DLLDEF:*=alpha)
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\idl\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       PCH.CXX
//
//  Contents:   Precompiled header
//
//  History:    12-Jul-93 ShannonC  Created
//
//--------------------------------------------------------------------------
#pragma warning(disable:4101)  // Local variable not used

#include <windows.h>
#include <basetyps.h>
#include <varnt.h>
#include <wtypes.h>
#include <shtyps.h>
#include <oletyp.h>
#include <stdrpc.hxx>
#include <idltyps.h>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\oleprx32\proxy\chicago\makefile.inc ===
oleprx32.sym: $(TARGET)
!IF $(386)
        mapsym $(TARGETPATH)\i386\$(TARGETNAME).map  $(TARGETPATH)\i386\$(TARGETNAME).sym
!ELSEIF $(MIPS)
        mapsym $(TARGETPATH)\mips\$(TARGETNAME).map  $(TARGETPATH)\mips\$(TARGETNAME).sym
!ELSEIF $(ALPHA)
        mapsym $(TARGETPATH)\alpha\$(TARGETNAME).map $(TARGETPATH)\alpha\$(TARGETNAME).sym
!ELSEIF $(PPC)
        mapsym $(TARGETPATH)\ppc\$(TARGETNAME).map $(TARGETPATH)\ppc\$(TARGETNAME).sym
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\cairo.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

!ENDIF

!include      ..\..\..\cairo.inc

UMTYPE=       windows
UMENTRY=      winmain

UMLIBS=	      ..\..\..\oleprx32\uuid\cairo\$(O)\uuid.lib  \
	      ..\..\..\common\cairo\$(O)\servers.lib	   \
	      $(OLEDIR)\com\port\cairo\$(O)\port.lib	   \
	      $(SDK_LIB_PATH)\uuid.lib	   \
	      $(SDK_LIB_PATH)\ole32.lib  \
              $(SDK_LIB_PATH)\rpcrt4.lib       \
              $(SDK_LIB_PATH)\rpcns4.lib       \
              $(SDK_LIB_PATH)\mpr.lib          \
              $(SDK_LIB_PATH)\netapi32.lib     \
              $(SDK_LIB_PATH)\kernel32.lib     \
              $(SDK_LIB_PATH)\user32.lib       \
	      $(SDK_LIB_PATH)\advapi32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\myproxy\myproxy.cxx ===
//---------------------------------------------------------------------------
//
//  File:	myproxy.cxx
//
//  Purpose:	Sample implementation of wrappers to allow simultaneous
//		hand-crafted and MILD-generated stubs.
//
//  History:	12-11-95    Rickhi	Created
//
//---------------------------------------------------------------------------
#include <ole2.h>
#include <stddef.h>		// offsetof
#include <icube.h>		// custom interface ICube, IID_ICube


// flag set in rpcFlags field of RPCOLEMESSAGE if the call is from a
// non-NDR client.
#define RPCFLG_NON_NDR	0x80000000UL


DEFINE_OLEGUID(IID_INonNDRStub, 0x0000013DL, 0, 0);
DEFINE_OLEGUID(CLSID_MyProxy,	0x0000013EL, 0, 0);

// IID that the proxy querys the channel for to see if the server
// has an NDR or NON NDR stub.
const GUID IID_INonNDRStub =
    {0x0000013d,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

// class id of my custom proxy dll
const GUID CLSID_MyProxy =
    {0x0000013e,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};

// class id of the MIDL generated proxy dll
const GUID CLSID_CubeProxy =
    {0x00000138,0x0001,0x0008,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};



#define GETPPARENT(pmemb, struc, membname) (\
		(struc FAR *)(((char FAR *)(pmemb))-offsetof(struc, membname)))


//---------------------------------------------------------------------------
//
//  Class:	CPSFactory
//
//  Purpose:	ProxyStub Class Factory
//
//  Notes:	fill in the CreateProxy and CreateStub methods for
//		other custom interfaces supported by this DLL.
//
//---------------------------------------------------------------------------
class CPSFactory : public IPSFactoryBuffer
{
public:
    // no ctor or dtor needed. DllGetClassObject returns a static
    // instance of this class.

    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    STDMETHOD(CreateProxy)(IUnknown *pUnkOuter, REFIID riid,
			   IRpcProxyBuffer **ppProxy, void **ppv);

    STDMETHOD(CreateStub)(REFIID riid, IUnknown *pUnkObj,
			  IRpcStubBuffer **ppStub);
};

//---------------------------------------------------------------------------
//
//  Class:	CStubWrapper
//
//  Purpose:	Wrapper object for stubs.
//
//  Notes:	This class can wrap any stub object regardless of
//		the interface the stub is for.
//
//---------------------------------------------------------------------------
class CStubWrapper : public IRpcStubBuffer
{
public:
    CStubWrapper(IUnknown *pUnkObj, REFIID riid);

    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    STDMETHOD(Connect)(IUnknown *pUnkObj);
    STDMETHOD_(void, Disconnect)(void);
    STDMETHOD(Invoke)(RPCOLEMESSAGE *pMsg, IRpcChannelBuffer *pChnl);
    STDMETHOD_(IRpcStubBuffer *, IsIIDSupported)(REFIID riid);
    STDMETHOD_(ULONG, CountRefs)(void);
    STDMETHOD(DebugServerQueryInterface)(void **ppv);
    STDMETHOD_(void, DebugServerRelease)(void *pv);

private:
    ~CStubWrapper(void);

    ULONG	    _cRefs;
    IUnknown *	    _pUnkObj;
    IRpcStubBuffer *_pHCStub;
    IRpcStubBuffer *_pMIDLStub;
    IID 	    _iid;
};

//---------------------------------------------------------------------------
//
//  Class:	CCubesStub
//
//  Purpose:	Hand-Crafted stub object for interface ICube.
//
//  Notes:	Replace this with your exisitng 32bit hand-crafted stubs.
//
//---------------------------------------------------------------------------
class CCubesStub : public IRpcStubBuffer
{
public:
    CCubesStub(IUnknown *pUnkObj);

    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    STDMETHOD(Connect)(IUnknown *pUnkObj);
    STDMETHOD_(void, Disconnect)(void);
    STDMETHOD(Invoke)(RPCOLEMESSAGE *pMsg, IRpcChannelBuffer *pChnl);
    STDMETHOD_(IRpcStubBuffer *, IsIIDSupported)(REFIID riid);
    STDMETHOD_(ULONG, CountRefs)(void);
    STDMETHOD(DebugServerQueryInterface)(void **ppv);
    STDMETHOD_(void, DebugServerRelease)(void *pv);

private:
    ~CCubesStub(void);

    ULONG	    _cRefs;
    IUnknown *	    _pUnkObj;
};

//---------------------------------------------------------------------------
//
//  Class:	CInternalUnk
//
//  Purpose:	Internal proxy class that implements IRpcProxyBuffer
//
//  Notes:	This could use some work. Perhaps dont make it an internal
//		class, but derive the other proxy classes from it, allowing
//		common code.
//
//---------------------------------------------------------------------------
#define DECLARE_INTERNAL_PROXY()			       \
    class CInternalUnk : public IRpcProxyBuffer		       \
    {							       \
    public:						       \
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj); \
	STDMETHOD_(ULONG,AddRef)(void) ;		       \
	STDMETHOD_(ULONG,Release)(void);		       \
	STDMETHOD(Connect)(IRpcChannelBuffer *pChnl);	       \
	STDMETHOD_(void, Disconnect)(void);		       \
    };							       \
    friend CInternalUnk;				       \
    CInternalUnk _InternalUnk;


//---------------------------------------------------------------------------
//
//  Class:	CProxyWrapper
//
//  Purpose:	Wrapper object for itnerface proxies.
//
//  Notes:	the routines in this class simply delegate to the
//		real proxy or the internal proxy unknown, or to the
//		controlling unknown.
//
//---------------------------------------------------------------------------
class CProxyWrapper : public ICube
{
public:
    CProxyWrapper(IUnknown *pUnkOuter, IRpcProxyBuffer **ppProxy);

    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // interface specific routines below here
    STDMETHOD(MoveCube)(ULONG xPos, ULONG yPos);
    STDMETHOD(GetCubePos)(ULONG *pxPos, ULONG *pyPos);
    STDMETHOD(Contains)(IBalls *pIFDb);
    STDMETHOD(SimpleCall)(DWORD pidCaller,
			  DWORD tidCaller,
			  GUID	lidCaller);

    DECLARE_INTERNAL_PROXY()

private:
    ~CProxyWrapper(void);

    ULONG	       _cRefs;
    IUnknown	      *_pUnkOuter;
    IRpcProxyBuffer   *_pRealProxy;
    ICube	      *_pRealIf;
};

//---------------------------------------------------------------------------
//
//  Class:	CCubesProxy
//
//  Purpose:	Hand-Crafted proxy object for ICube interface.
//
//---------------------------------------------------------------------------
class CCubesProxy : public ICube
{
public:
    CCubesProxy(IUnknown *pUnkOuter, IRpcProxyBuffer **ppProxy);

    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // interface specific routines below here
    STDMETHOD(MoveCube)(ULONG xPos, ULONG yPos);
    STDMETHOD(GetCubePos)(ULONG *pxPos, ULONG *pyPos);
    STDMETHOD(Contains)(IBalls *pIFDb);
    STDMETHOD(SimpleCall)(DWORD pidCaller,
			  DWORD tidCaller,
			  GUID	lidCaller);


    DECLARE_INTERNAL_PROXY()

private:
    ~CCubesProxy(void);

    ULONG	       _cRefs;
    IUnknown	      *_pUnkOuter;
    IRpcChannelBuffer *_pChnl;
};


//---------------------------------------------------------------------------
//
//  Function:	DllMain
//
//  Purpose:	Entry point for the Proxy/Stub Dll
//
//---------------------------------------------------------------------------
extern "C" BOOL WINAPI DllMain(HANDLE hDll, DWORD dwReason, void *pvReserved)
{
    return TRUE;
}

//---------------------------------------------------------------------------
//
//  Function:	DllGetClassObject
//
//  Purpose:	Entry point to return proxy/stub class factory
//
//---------------------------------------------------------------------------

// static instance of the class factory
CPSFactory gPSFactory;

STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    if (IsEqualCLSID(clsid, CLSID_MyProxy))
    {
	*ppv = (void *)(IClassFactory *)&gPSFactory;
	return S_OK;
    }

    return E_UNEXPECTED;
}

//---------------------------------------------------------------------------
//
//  Function:	DllCanUnloadNow
//
//  Purpose:	Entry point to determine if DLL is unloadable.
//
//---------------------------------------------------------------------------
STDAPI DllCanUnloadNow(void)
{
    return FALSE;
}

//---------------------------------------------------------------------------
//
//  Function:	GetMIDLPSFactory
//
//  Purpose:	Function for getting the MIDL generated PSFactoryBuffer
//		for the test interface.
//
//---------------------------------------------------------------------------
HRESULT GetMIDLPSFactory(REFIID riid, IPSFactoryBuffer **ppIPSF)
{
    *ppIPSF = NULL;

    // load the dll and get the PS class object

    return CoGetClassObject(CLSID_CubeProxy,
			      CLSCTX_INPROC_SERVER, // | CLSCTX_PS_DLL,
			      NULL,
			      IID_IPSFactoryBuffer,
			      (void **)ppIPSF);
}

//---------------------------------------------------------------------------
//
//  Function:	CreateMIDLProxy
//
//  Purpose:	Function for creating the MIDL generated proxy
//		for the test interface.
//
//---------------------------------------------------------------------------
IUnknown *CreateMIDLProxy(REFIID riid,
			  IUnknown *pUnkOuter,
			  IRpcProxyBuffer **ppProxy)
{
    IUnknown	     *pRealIf = NULL;
    IPSFactoryBuffer *pPSFactory = NULL;

    HRESULT hr = GetMIDLPSFactory(riid, &pPSFactory);
    if (SUCCEEDED(hr))
    {
	hr = pPSFactory->CreateProxy(pUnkOuter,riid,ppProxy,(void **)&pRealIf);
	pPSFactory->Release();
    }

    return pRealIf;
}

//---------------------------------------------------------------------------
//
//  Function:	CreateMIDLStub
//
//  Purpose:	Function for creating the MIDL generated stub
//		for the test interface.
//
//---------------------------------------------------------------------------
IRpcStubBuffer *CreateMIDLStub(REFIID  riid,
			       IUnknown *pUnkOuter)
{
    IRpcStubBuffer   *pStub = NULL;
    IPSFactoryBuffer *pPSFactory = NULL;

    HRESULT hr = GetMIDLPSFactory(riid, &pPSFactory);
    if (SUCCEEDED(hr))
    {
	hr = pPSFactory->CreateStub(riid, pUnkOuter, &pStub);
	pPSFactory->Release();
    }

    return pStub;
}


//---------------------------------------------------------------------------
//
//  Implement:	CPSFactory
//
//  Purpose:	ProxyStub Class Factory
//
//  Notes:	just fill in the CreateProxy and CreateStub methods for
//		your other custom interfaces.
//
//---------------------------------------------------------------------------
HRESULT CPSFactory::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IPSFactoryBuffer) ||
	IsEqualIID(riid, IID_IUnknown))
    {
	*ppv = (IPSFactoryBuffer *)this;
	// static object, dont need refcnt
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG CPSFactory::AddRef(void)
{
    // static object, dont need refcnt
    return 1;
}

ULONG CPSFactory::Release(void)
{
    // static object, dont need refcnt
    return 1;
}

HRESULT CPSFactory::CreateProxy(IUnknown *pUnkOuter, REFIID riid,
				IRpcProxyBuffer **ppProxy, void **ppv)
{
    // check for supported interfaces
    if (IsEqualIID(riid, IID_ICube))
    {
	CProxyWrapper *pProxy = new CProxyWrapper(pUnkOuter, ppProxy);

	if (pProxy)
	{
	    *ppv = (void *)(ICube *) pProxy;
	    ((IUnknown *)(*ppv))->AddRef(); // AddRef the returned interface
	    return S_OK;
	}
    }

    *ppProxy = NULL;
    *ppv = NULL;
    return E_NOINTERFACE;
}

HRESULT CPSFactory::CreateStub(REFIID riid, IUnknown *pUnkObj, IRpcStubBuffer **ppStub)
{
    // check for supported interfaces
    if (IsEqualIID(riid, IID_ICube))
    {
	CStubWrapper *pStub = new CStubWrapper(pUnkObj, riid);

	if (pStub)
	{
	    *ppStub = (IRpcStubBuffer *) pStub;
	    return S_OK;
	}
    }

    *ppStub = NULL;
    return E_NOINTERFACE;
}


//---------------------------------------------------------------------------
//
//  Implement:	CStubWrapper
//
//  Purpose:	Wrapper object for stubs.
//
//  Notes:	This same class can wrap any stub object regardless of
//		the interface the stub is for.
//
//---------------------------------------------------------------------------
CStubWrapper::CStubWrapper(IUnknown *pUnkObj, REFIID riid) :
    _cRefs(1),
    _pUnkObj(pUnkObj),
    _pHCStub(NULL),
    _pMIDLStub(NULL),
    _iid(riid)
{
    _pUnkObj->AddRef();
}

CStubWrapper::~CStubWrapper(void)
{
    Disconnect();
}

HRESULT CStubWrapper::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IRpcStubBuffer) ||
	IsEqualIID(riid, IID_IUnknown))
    {
	*ppv = (IRpcStubBuffer *)this;
	AddRef();
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG CStubWrapper::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

ULONG CStubWrapper::Release(void)
{
    ULONG cRefs = _cRefs-1;
    if (InterlockedDecrement((LONG *)&_cRefs) == 0)
    {
	delete this;
	return 0;
    }

    return cRefs;
}

HRESULT CStubWrapper::Connect(IUnknown *pUnkObj)
{
    if (_pUnkObj)
    {
	// already connected, disconnect
	Disconnect();
    }

    // get the requested interface and hold it.
    HRESULT hr = pUnkObj->QueryInterface(_iid, (void **)&_pUnkObj);
    if (FAILED(hr))
    {
	// make sure our ptr is NULL else we might think we're connected
	_pUnkObj = NULL;
    }

    return hr;
}

void CStubWrapper::Disconnect()
{
    if (_pHCStub)
    {
	_pHCStub->Disconnect();
	_pHCStub->Release();
	_pHCStub = NULL;
    }

    if (_pMIDLStub)
    {
	_pMIDLStub->Disconnect();
	_pMIDLStub->Release();
	_pMIDLStub = NULL;
    }

    if (_pUnkObj)
    {
	_pUnkObj->Release();
	_pUnkObj = NULL;
    }
}

HRESULT CStubWrapper::Invoke(RPCOLEMESSAGE *pMsg, IRpcChannelBuffer *pChnl)
{
    if (pMsg->rpcFlags & RPCFLG_NON_NDR)
    {
	// call is not NDR format, so use the hand-crafted stub.
	// create the stub if it does not exist yet.

	if (_pHCStub == NULL)
	{
	    if ((_pHCStub = new CCubesStub(_pUnkObj)) == NULL)
		return E_OUTOFMEMORY;
	}

	return _pHCStub->Invoke(pMsg, pChnl);
    }

    // call is	NDR format, so use the MIDL generated stub.
    // create the stub if it does not exist yet.

    if (_pMIDLStub == NULL)
    {
	_pMIDLStub = CreateMIDLStub(IID_ICube, _pUnkObj);
	if (_pMIDLStub == NULL)
	    return E_OUTOFMEMORY;
    }

    return _pMIDLStub->Invoke(pMsg, pChnl);
}

IRpcStubBuffer *CStubWrapper::IsIIDSupported(REFIID riid)
{
    if (IsEqualIID(riid, _iid))
    {
	AddRef();
	return (IRpcStubBuffer *)this;
    }

    return NULL;
}

ULONG CStubWrapper::CountRefs()
{
    ULONG cRefs = (_pUnkObj) ? 1 : 0;

    if (_pHCStub)
	cRefs += _pHCStub->CountRefs();

    if (_pMIDLStub)
	cRefs += _pMIDLStub->CountRefs();

    return cRefs;
}

HRESULT CStubWrapper::DebugServerQueryInterface(void **ppv)
{
    *ppv = (void *)_pUnkObj;
    return S_OK;
}

void CStubWrapper::DebugServerRelease(void *pv)
{
    return;
}


//---------------------------------------------------------------------------
//
//  Implement:	CProxyWrapper
//
//  Purpose:	Wrapper object for itnerface proxies.
//
//  Notes:	the top several routines are the same for all proxies
//		but you must change the interface specific routines for
//		each new interface.
//
//---------------------------------------------------------------------------
CProxyWrapper::CProxyWrapper(IUnknown *pUnkOuter, IRpcProxyBuffer **ppProxy) :
    _cRefs(1),
    _pUnkOuter(pUnkOuter),	// don't AddRef
    _pRealProxy(NULL)
{
    *ppProxy = (IRpcProxyBuffer *)&_InternalUnk;
}

CProxyWrapper::~CProxyWrapper(void)
{
    if (_pRealProxy)
    {
	_InternalUnk.Disconnect();
    }
}

HRESULT CProxyWrapper::CInternalUnk::QueryInterface(REFIID riid, void **ppv)
{
    CProxyWrapper *pProxy = GETPPARENT(this, CProxyWrapper, _InternalUnk);

    if (IsEqualIID(riid, IID_IRpcProxyBuffer) ||
	IsEqualIID(riid, IID_IUnknown))
    {
	pProxy->AddRef();
	*ppv = (IRpcProxyBuffer *)this;
	return S_OK;
    }
    else if (IsEqualIID(riid, IID_ICube))
    {
	*ppv = (ICube *)pProxy;
	AddRef();
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG CProxyWrapper::CInternalUnk::AddRef(void)
{
    CProxyWrapper *pProxy = GETPPARENT(this, CProxyWrapper, _InternalUnk);

    InterlockedIncrement((LONG *)&pProxy->_cRefs);
    return pProxy->_cRefs;
}

ULONG CProxyWrapper::CInternalUnk::Release(void)
{
    CProxyWrapper *pProxy = GETPPARENT(this, CProxyWrapper, _InternalUnk);

    ULONG cRefs = pProxy->_cRefs-1;
    if (InterlockedDecrement((LONG *)&pProxy->_cRefs) == 0)
    {
	delete this;
	return 0;
    }

    return cRefs;
}

HRESULT CProxyWrapper::CInternalUnk::Connect(IRpcChannelBuffer *pChnl)
{
    CProxyWrapper *pProxy = GETPPARENT(this, CProxyWrapper, _InternalUnk);

    void *pv;
    HRESULT hr = pChnl->QueryInterface(IID_INonNDRStub, &pv);
    if (SUCCEEDED(hr))
    {
	((IUnknown *)pv)->Release();

	// create the hand-crafted proxy
	pProxy->_pRealIf = new CCubesProxy(pProxy->_pUnkOuter,
					   &pProxy->_pRealProxy);
    }
    else
    {
	// create the MIDL generated proxy
	pProxy->_pRealIf = (ICube *) CreateMIDLProxy(IID_ICube,
					    pProxy->_pUnkOuter,
					    &pProxy->_pRealProxy);

    }

    if (pProxy->_pRealIf == NULL)
	return E_OUTOFMEMORY;

    // since the proxy AddRef'd the punkOuter, we need to release it.
    pProxy->_pUnkOuter->Release();

    // connect the proxy
    hr = pProxy->_pRealProxy->Connect(pChnl);
    if (FAILED(hr))
    {
	pProxy->_pRealProxy->Release();
	pProxy->_pRealProxy = NULL;
    }

    return hr;
}

void CProxyWrapper::CInternalUnk::Disconnect(void)
{
    CProxyWrapper *pProxy = GETPPARENT(this, CProxyWrapper, _InternalUnk);

    if (pProxy->_pRealProxy)
    {
	pProxy->_pRealProxy->Disconnect();
	pProxy->_pRealProxy->Release();
	pProxy->_pRealProxy = NULL;
    }
}

//---------------------------------------------------------------------------
//
//  ICube specific proxy wrapper code below here.
//
//---------------------------------------------------------------------------
HRESULT CProxyWrapper::QueryInterface(REFIID riid, void **ppv)
{
    return _pUnkOuter->QueryInterface(riid, ppv);
}

ULONG CProxyWrapper::AddRef(void)
{
    return _pUnkOuter->AddRef();
}

ULONG CProxyWrapper::Release(void)
{
    return _pUnkOuter->Release();
}

HRESULT CProxyWrapper::MoveCube(ULONG xPos, ULONG yPos)
{
    if (_pRealProxy)
    {
	return _pRealIf->MoveCube(xPos, yPos);
    }

    return CO_E_OBJNOTCONNECTED;
}

HRESULT CProxyWrapper::GetCubePos(ULONG *pxPos, ULONG *pyPos)
{
    if (_pRealProxy)
    {
	return _pRealIf->GetCubePos(pxPos, pyPos);
    }

    *pxPos = 0;
    *pyPos = 0;
    return CO_E_OBJNOTCONNECTED;
}

HRESULT CProxyWrapper::Contains(IBalls *pIFDb)
{
    if (_pRealProxy)
    {
	return _pRealIf->Contains(pIFDb);
    }

    return CO_E_OBJNOTCONNECTED;
}


HRESULT CProxyWrapper::SimpleCall(
		DWORD pidCaller,
		DWORD tidCaller,
		GUID  lidCaller)
{
    return CO_E_OBJNOTCONNECTED;
}

//---------------------------------------------------------------------------
//
//  Implement:	CCubesProxy
//
//  Purpose:	Hand-Crafted proxy object for interface ICube.
//
//  Notes:	Replace this with your exisitng 32bit hand-crafted proxies.
//
//---------------------------------------------------------------------------
CCubesProxy::CCubesProxy(IUnknown *pUnkOuter, IRpcProxyBuffer **ppProxy) :
    _pUnkOuter(pUnkOuter),
    _pChnl(NULL)
{
    _pUnkOuter->AddRef();
    *ppProxy = (IRpcProxyBuffer *)&_InternalUnk;
}

CCubesProxy::~CCubesProxy(void)
{
    _InternalUnk.Disconnect();
}

HRESULT CCubesProxy::CInternalUnk::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IRpcProxyBuffer) ||
	IsEqualIID(riid, IID_IUnknown))
    {
	CCubesProxy *pProxy = GETPPARENT(this, CCubesProxy, _InternalUnk);
	pProxy->AddRef();

	*ppv = (IRpcProxyBuffer *)this;
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}

ULONG CCubesProxy::CInternalUnk::AddRef(void)
{
    CCubesProxy *pProxy = GETPPARENT(this, CCubesProxy, _InternalUnk);

    InterlockedIncrement((LONG *)&pProxy->_cRefs);
    return pProxy->_cRefs;
}

ULONG CCubesProxy::CInternalUnk::Release(void)
{
    CCubesProxy *pProxy = GETPPARENT(this, CCubesProxy, _InternalUnk);

    ULONG cRefs = pProxy->_cRefs-1;
    if (InterlockedDecrement((LONG *)&pProxy->_cRefs) == 0)
    {
	delete this;
	return 0;
    }

    return cRefs;
}

HRESULT CCubesProxy::CInternalUnk::Connect(IRpcChannelBuffer *pChnl)
{
    Disconnect();	// make sure we are disconnected

    CCubesProxy *pProxy = GETPPARENT(this, CCubesProxy, _InternalUnk);

    pProxy->_pChnl = pChnl;	// keep the channel ptr
    pChnl->AddRef();
    return S_OK;
}

void CCubesProxy::CInternalUnk::Disconnect(void)
{
    CCubesProxy *pProxy = GETPPARENT(this, CCubesProxy, _InternalUnk);

    if (pProxy->_pChnl)
    {
	pProxy->_pChnl->Release();
	pProxy->_pChnl = NULL;
    }
}

//---------------------------------------------------------------------------
//
//  ICubes Proxy Implementation
//
//---------------------------------------------------------------------------
HRESULT CCubesProxy::QueryInterface(REFIID riid, void **ppv)
{
    return _pUnkOuter->QueryInterface(riid, ppv);
}

ULONG CCubesProxy::AddRef(void)
{
    return _pUnkOuter->AddRef();
}

ULONG CCubesProxy::Release(void)
{
    return _pUnkOuter->Release();
}

HRESULT CCubesProxy::MoveCube(ULONG xPos, ULONG yPos)
{
    // set up the message and get the buffer
    RPCOLEMESSAGE msg;
    memset(&msg, 0, sizeof(msg));
    msg.iMethod  = 3;
    msg.dataRepresentation = NDR_LOCAL_DATA_REPRESENTATION;
    msg.cbBuffer = 16;

    HRESULT hrFromServer;
    HRESULT hr = _pChnl->GetBuffer(&msg, IID_ICube);

    if (SUCCEEDED(hr))
    {
	// Marshal the parameters. The string "myproxy" followed by
	// xPos and yPos values.

	char *pBuf = (char *)msg.Buffer;
	strcpy((char *)pBuf, "myproxy");

	pBuf += 8;
	DWORD *dwp = (DWORD *)pBuf;
	*dwp  = xPos;
	pBuf += 4;
	dwp = (DWORD *)pBuf;
	*dwp  = yPos;

	// Send the message and get the reply
	ULONG ulStatus = 0;
	hr = _pChnl->SendReceive(&msg, &ulStatus);

	if (SUCCEEDED(hr))
	{
	    // unmarshal the results
	    hrFromServer = (DWORD)(msg.Buffer);
	}

	// FreeBuffer
	hr = _pChnl->FreeBuffer(&msg);
    }

    return hr;
}

HRESULT CCubesProxy::GetCubePos(ULONG *pxPos, ULONG *pyPos)
{
    *pxPos = 0;
    *pyPos = 0;
    return E_NOTIMPL;
}

HRESULT CCubesProxy::Contains(IBalls *pIFDb)
{
    return E_NOTIMPL;
}

HRESULT CCubesProxy::SimpleCall(
		DWORD pidCaller,
		DWORD tidCaller,
		GUID  lidCaller)
{
    return E_NOTIMPL;
}


//---------------------------------------------------------------------------
//
//  Implement:	CCubesStub
//
//  Purpose:	Hand-Crafted stub object for interface ICube.
//
//  Notes:	Replace this with your exisitng 32bit hand-crafted stubs.
//
//---------------------------------------------------------------------------

CCubesStub::CCubesStub(IUnknown *pUnkObj) :
    _cRefs(1),
    _pUnkObj(pUnkObj)
{
    _pUnkObj->AddRef();
}

CCubesStub::~CCubesStub(void)
{
    Disconnect();
}

HRESULT CCubesStub::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IRpcStubBuffer) ||
	IsEqualIID(riid, IID_IUnknown))
    {
	*ppv = (IRpcStubBuffer *)this;
    }
    else
    {
	*ppv = NULL;
	return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG CCubesStub::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

ULONG CCubesStub::Release(void)
{
    ULONG cRefs = _cRefs-1;
    if (InterlockedDecrement((LONG *)&_cRefs) == 0)
    {
	delete this;
	return 0;
    }

    return cRefs;
}

HRESULT CCubesStub::Connect(IUnknown *pUnkObj)
{
    if (_pUnkObj)
    {
	// already connected, disconnect
	Disconnect();
    }

    // get the requested interface and hold it.
    HRESULT hr = pUnkObj->QueryInterface(IID_ICube, (void **)&_pUnkObj);
    if (FAILED(hr))
    {
	_pUnkObj = NULL;
    }

    return hr;
}

void CCubesStub::Disconnect()
{
    if (_pUnkObj)
    {
	_pUnkObj->Release();
	_pUnkObj = NULL;
    }
}

HRESULT CCubesStub::Invoke(RPCOLEMESSAGE *pMsg, IRpcChannelBuffer *pChnl)
{
    // Check the method number.
    if (pMsg->iMethod !=3 || pMsg->cbBuffer != 16)
	return E_INVALIDARG;

    // unmarshal the parameters
    char *pBuf = (char *)pMsg->Buffer;
    pBuf += 8;
    DWORD *dwp = (DWORD *)pBuf;
    ULONG xPos = *dwp;

    pBuf += 4;
    dwp = (DWORD *)pBuf;
    ULONG yPos = *dwp;

    // call the real object
    HRESULT hrFromServer = ((ICube *)_pUnkObj)->MoveCube(xPos, yPos);

    // get a new buffer
    pMsg->cbBuffer = 4;
    HRESULT hr = pChnl->GetBuffer(pMsg, IID_ICube);

    if (SUCCEEDED(hr))
    {
	// marshal the return values
	pBuf = (char *)pMsg->Buffer;
	dwp = (DWORD *)pBuf;
	*dwp = hrFromServer;
    }

    return hr;
}

IRpcStubBuffer *CCubesStub::IsIIDSupported(REFIID riid)
{
    if (IsEqualIID(riid, IID_ICube))
    {
	AddRef();
	return (IRpcStubBuffer *)this;
    }

    return NULL;
}

ULONG CCubesStub::CountRefs()
{
    // only keep one reference
    return 1;
}

HRESULT CCubesStub::DebugServerQueryInterface(void **ppv)
{
    *ppv = (void *)_pUnkObj;
    return S_OK;
}

void CCubesStub::DebugServerRelease(void *pv)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\oleprx32\proxy\transmit.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       transmit.cxx
//
//  Contents:   Support for Windows/OLE data types for oleprx32.dll.
//              Used to be transmit_as routines, now user_marshal routines.
//
//  Functions:  HGLOBAL_UserSize
//              HGLOBAL_UserMarshal
//              HGLOBAL_UserUnmarshal
//              HGLOBAL_UserFree
//              HMETAFILEPICT_UserSize
//              HMETAFILEPICT_UserMarshal
//              HMETAFILEPICT_UserUnmarshal
//              HMETAFILEPICT_UserFree
//              HENHMETAFILE_UserSize
//              HENHMETAFILE_UserMarshal
//              HENHMETAFILE_UserUnmarshal
//              HENHMETAFILE_UserFree
//              HBITMAP_UserSize
//              HBITMAP_UserMarshal
//              HBITMAP_UserUnmarshal
//              HBITMAP_UserFree
//              HBRUSH_UserSize
//              HBRUSH_UserMarshal
//              HBRUSH_UserUnmarshal
//              HBRUSH_UserFree
//              STGMEDIUM_UserSize
//              STGMEDIUM_UserMarshal
//              STGMEDIUM_UserUnmarshal
//              STGMEDIUM_UserFree
//              HACCEL_UserSize
//              HACCEL_UserMarshal
//              HACCEL_UserUnmarshal
//              HACCEL_UserFree
//              HWND_UserSize
//              HWND_UserMarshal
//              HWND_UserUnmarshal
//              HWND_UserFree
//              HMENU_UserSize
//              HMENU_UserMarshal
//              HMENU_UserUnmarshal
//              HMENU_UserFree
//
//  History:    24-Aug-93   ShannonC    Created
//              24-Nov-93   ShannonC    Added HGLOBAL
//              14-May-94   DavePl      Added HENHMETAFILE
//              18-May-94   ShannonC    Added HACCEL, UINT, WPARAM
//              19-May-94   DavePl      Added HENHMETAFILE to STGMEDIUM code
//                 May-95   Ryszardk    Wrote all the _User* routines
//
//--------------------------------------------------------------------------
#include "stdrpc.hxx"
#pragma hdrstop

#include <oleauto.h>
#include <objbase.h>
#include "transmit.h"
#include <rpcwdt.h>


WINOLEAPI_(void) ReleaseStgMedium(LPSTGMEDIUM pStgMed);

#pragma code_seg(".orpc")

EXTERN_C const CLSID CLSID_MyPSFactoryBuffer = {0x6f11fe5c,0x2fc5,0x101b,{0x9e,0x45,0x00,0x00,0x0b,0x65,0xc7,0xef}};



//+-------------------------------------------------------------------------
//
//  class:  CPunkForRelease
//
//  purpose:    special IUnknown for remoted STGMEDIUMs
//
//  history:    02-Mar-94   Rickhi      Created
//
//  notes:  This class is used to do the cleanup correctly when certain
//      types of storages are passed between processes or machines
//      in Nt and Chicago.
//
//      On NT, GLOBAL, GDI, and BITMAP handles cannot be passed between
//      processes, so we actually copy the whole data and create a
//      new handle in the receiving process. However, STGMEDIUMs have
//      this weird behaviour where if PunkForRelease is non-NULL then
//      the sender is responsible for cleanup, not the receiver. Since
//      we create a new handle in the receiver, we would leak handles
//      if we didnt do some special processing.  So, we do the
//      following...
//
//          During STGMEDIUM_UserUnmarshal, if there is a pUnkForRelease
//          replace it with a CPunkForRelease.  When Release is called
//          on the CPunkForRelease, do the necessary cleanup work,
//          then call the real PunkForRelease.
//
//+-------------------------------------------------------------------------

class   CPunkForRelease : public IUnknown
{
public:
    CPunkForRelease( STGMEDIUM *pStgMed, ulong fTopLayerOnly);

    //  IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppunk);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

private:
    ~CPunkForRelease(void);

    ULONG       _cRefs;                 //  reference count
    ULONG       _fTopLayerMFP:1;        //  optimisation flag for Chicago
    STGMEDIUM   _stgmed;                //  storage medium
    IUnknown  * _pUnkForRelease;        //  real pUnkForRelease
};


inline CPunkForRelease::CPunkForRelease(
    STGMEDIUM * pStgMed,
    ulong       fTopLayerMFPict
    ) :
    _cRefs(1),
    _fTopLayerMFP( fTopLayerMFPict),
    _stgmed(*pStgMed)
{
    //  NOTE: we assume the caller has verified pStgMed is not NULL,
    //  and the pUnkForRelease is non-null, otherwise there is no
    //  point in constructing this object.  The tymed must also be
    //  one of the special ones.

    UserNdrAssert(pStgMed);
    UserNdrAssert(pStgMed->tymed == TYMED_HGLOBAL ||
       pStgMed->tymed == TYMED_GDI  ||
       pStgMed->tymed == TYMED_MFPICT  ||
       pStgMed->tymed == TYMED_ENHMF);

    _pUnkForRelease = pStgMed->pUnkForRelease;
}


inline CPunkForRelease::~CPunkForRelease()
{
    //  since we really have our own copies of these handles' data, just
    //  pretend like the callee is responsible for the release, and
    //  recurse into ReleaseStgMedium to do the cleanup.

    _stgmed.pUnkForRelease = NULL;

    // There is this weird optimized case of Chicago MFPICT when we have two
    // layers with a HENHMETAFILE handle inside. Top layer is an HGLOBAL.

    if ( _fTopLayerMFP )
        GlobalFree( _stgmed.hGlobal );
    else
        ReleaseStgMedium( &_stgmed );

    //  release the callers punk
    _pUnkForRelease->Release();
}

STDMETHODIMP_(ULONG) CPunkForRelease::AddRef(void)
{
    InterlockedIncrement((LONG *)&_cRefs);
    return _cRefs;
}

STDMETHODIMP_(ULONG) CPunkForRelease::Release(void)
{
    long Ref = _cRefs - 1;

    UserNdrAssert( _cRefs );

    if (InterlockedDecrement((LONG *)&_cRefs) == 0)
        {
        // null out the vtable.
        long * p = (long *)this;
        *p = 0;

        delete this;
        return 0;
        }
    else
        return Ref;
}

STDMETHODIMP CPunkForRelease::QueryInterface(REFIID riid, void **ppv)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
    *ppv = (void *)(IUnknown *) this;
    AddRef();
    return S_OK;
    }
    else
    {
    *ppv = NULL;
    return E_NOINTERFACE;
    }
}


// These methods are needed as the object is used for interface marshaling.

/***************************************************************************/
STDMETHODIMP_(ULONG) CStreamOnMessage::AddRef( THIS )
{
  return ref_count += 1;
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Clone(THIS_ IStream * *ppstm)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Commit(THIS_ DWORD grfCommitFlags)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::CopyTo(THIS_ IStream *pstm,
                  ULARGE_INTEGER cb,
                  ULARGE_INTEGER *pcbRead,
                  ULARGE_INTEGER *pcbWritten)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
CStreamOnMessage::CStreamOnMessage(unsigned char **ppMessageBuffer)
    : ref_count(1), ppBuffer(ppMessageBuffer), cbMaxStreamLength(0xFFFFFFFF)
{
    pStartOfStream = *ppMessageBuffer;
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::LockRegion(THIS_ ULARGE_INTEGER libOffset,
                  ULARGE_INTEGER cb,
                  DWORD dwLockType)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown))
  {
    *ppvObj = (IUnknown *) this;
    ref_count += 1;
    return ResultFromScode(S_OK);
  }
  else if (IsEqualIID(riid, IID_IStream))
  {
    *ppvObj = (IStream *) this;
    ref_count += 1;
    return ResultFromScode(S_OK);
  }
  else
    return ResultFromScode(E_NOINTERFACE);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Read(THIS_ VOID HUGEP *pv,
                  ULONG cb, ULONG *pcbRead)
{
  memcpy( pv, *ppBuffer, cb );
  *ppBuffer += cb;
  if (pcbRead != NULL)
    *pcbRead = cb;
  return ResultFromScode(S_OK);
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CStreamOnMessage::Release( THIS )
{
  ref_count -= 1;
  if (ref_count == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;

}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Revert(THIS)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Seek(THIS_ LARGE_INTEGER dlibMove,
                  DWORD dwOrigin,
                  ULARGE_INTEGER *plibNewPosition)
{
  ULONG   pos;

  // Verify that the offset isn't out of range.
  if (dlibMove.HighPart != 0)
    return ResultFromScode( E_FAIL );

  // Determine the new seek pointer.
  switch (dwOrigin)
  {
    case STREAM_SEEK_SET:
      pos = dlibMove.LowPart;
      break;

    case STREAM_SEEK_CUR:
      /* Must use signed math here. */
      pos = *ppBuffer - pStartOfStream;
      if ((long) dlibMove.LowPart < 0 &&
      pos < (unsigned long) - (long) dlibMove.LowPart)
    return ResultFromScode( E_FAIL );
      pos += (long) dlibMove.LowPart;
      break;

    case STREAM_SEEK_END:
        return ResultFromScode(E_NOTIMPL);
    break;

    default:
      return ResultFromScode( E_FAIL );
  }

  // Set the seek pointer.
  *ppBuffer = pStartOfStream + pos;
  if (plibNewPosition != NULL)
  {
    plibNewPosition->LowPart = pos;
    plibNewPosition->HighPart = 0;
  }
  return ResultFromScode(S_OK);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::SetSize(THIS_ ULARGE_INTEGER libNewSize)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Stat(THIS_ STATSTG *pstatstg, DWORD grfStatFlag)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::UnlockRegion(THIS_ ULARGE_INTEGER libOffset,
                  ULARGE_INTEGER cb,
                  DWORD dwLockType)
{
  return ResultFromScode(E_NOTIMPL);
}

/***************************************************************************/
STDMETHODIMP CStreamOnMessage::Write(THIS_ VOID const HUGEP *pv,
                  ULONG cb,
                  ULONG *pcbWritten)
{
  // Write the data.
  memcpy( *ppBuffer, pv, cb );
  if (pcbWritten != NULL)
    *pcbWritten = cb;
  *ppBuffer += cb;
  return ResultFromScode(S_OK);
}


//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserSize
//
//  Synopsis:   Sizes an SNB.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
SNB_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    SNB           * pSnb )
{
    if ( ! pSnb )
        return Offset;

    // calculate the number of strings and characters (with their terminators)

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSnb && *pSnb)
        {
        SNB snb = *pSnb;
    
        WCHAR *psz = *snb;
        while (psz)
            {
            ulCntChar += wcslen(psz) + 1;
            ulCntStr++;
            snb++;
            psz = *snb;
            }
        }

    // The wire size is: conf size, 2 fields and the wchars.

    LENGTH_ALIGN( Offset, 3 );

    return ( Offset + 3 * sizeof(long) + ulCntChar * sizeof( WCHAR ) );
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserMarshall
//
//  Synopsis:   Marshalls an SNB into the RPC buffer.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
SNB_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    SNB           * pSnb )
{
    UserNdrDebugOut((UNDR_FORCE, "SNB_UserMarshal\n"));

    if ( ! pSnb )
        return pBuffer;

    // calculate the number of strings and characters (with their terminators)

    ULONG ulCntStr = 0;
    ULONG ulCntChar = 0;

    if (pSnb && *pSnb)
        {
        SNB snb = *pSnb;
    
        WCHAR *psz = *snb;
        while (psz)
            {
            ulCntChar += wcslen(psz) + 1;
            ulCntStr++;
            snb++;
            psz = *snb;
            }
        }

    // conformant size

    ALIGN( pBuffer, 3 );
    *( PULONG_LV_CAST pBuffer)++ = ulCntChar;

    // fields

    *( PULONG_LV_CAST pBuffer)++ = ulCntStr;
    *( PULONG_LV_CAST pBuffer)++ = ulCntChar;

    // actual strings only

    if ( pSnb  &&  *pSnb )
        {
        // There is a NULL string pointer to mark the end of the pointer array.
        // However, the strings don't have to follow tightly.
        // Hence, we have to copy one string at a time.

        SNB   snb = *pSnb;
        WCHAR *pszSrc;

        while (pszSrc = *snb++)
            {
            ULONG ulCopyLen = (wcslen(pszSrc) + 1) * sizeof(WCHAR);

            WdtpMemoryCopy( pBuffer, pszSrc, ulCopyLen );
            pBuffer += ulCopyLen;
            }
        }

    return pBuffer;
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserUnmarshall
//
//  Synopsis:   Unmarshalls an SNB from the RPC buffer.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
SNB_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    SNB           * pSnb )
{
    UserNdrDebugOut((UNDR_FORCE, "SNB_UserUnmarshal\n"));

    ALIGN( pBuffer, 3 );

    // conf size

    unsigned long ulCntChar = *( PULONG_LV_CAST pBuffer)++;

    // fields

    unsigned long ulCntStr = *( PULONG_LV_CAST pBuffer)++;
    pBuffer += sizeof(long);

    // no reusage of pSNB.

    if ( *pSnb )
        WdtpFree( pFlags, *pSnb );

    if ( ulCntStr == 0 )
        {
        *pSnb = NULL;
        return pBuffer;
        }

    // construct the SNB.

    SNB Snb = (SNB) WdtpAllocate( pFlags,
                                  ( (ulCntStr + 1) * sizeof(WCHAR *) +
                                     ulCntChar * sizeof(WCHAR)) );

    *pSnb = Snb;

    if (Snb)
        {
        // create the pointer array within the SNB.

        WCHAR *pszSrc = (WCHAR *) pBuffer;
        WCHAR *pszTgt = (WCHAR *) (Snb + ulCntStr + 1); // right behind array

        for (ULONG i = ulCntStr; i > 0; i--)
            {
            *Snb++ = pszTgt;
        
            ULONG ulLen = wcslen(pszSrc) + 1;
            pszSrc += ulLen;
            pszTgt += ulLen;
            }

        *Snb++ = NULL;

        // Copy the actual strings.
        // We can do a block copy here as we packed them tight in the buffer.
        // Snb points right behind the lastarray of pointers within the SNB.

        WdtpMemoryCopy( Snb, pBuffer, ulCntChar * sizeof(WCHAR) );
        pBuffer += ulCntChar * sizeof(WCHAR);
        }

    return pBuffer;
}

//+-------------------------------------------------------------------------
//
//  Function:   SNB_UserFree
//
//  Synopsis:   Frees an SNB.
//
//  Derivation: An array of strings in one block of memory.
//
//  history:    June-95   Ryszardk      Created, based on SNB_*_xmit.
//
//--------------------------------------------------------------------------

void __RPC_USER
SNB_UserFree(
    unsigned long * pFlags,
    SNB           * pSnb )
{
    if ( pSnb && *pSnb )
        WdtpFree( pFlags, *pSnb );
}


//+-------------------------------------------------------------------------
//
//  Function:   WdtpVoidStar_UserSize
//
//  Synopsis:   Sizes a remotable void star as ulong.
//
//  history:    June-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
WdtpVoidStar_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    unsigned long * pVoid )
{
    if ( !pVoid )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    return( Offset + 4 ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpVoidStar_UserMarshall
//
//  Synopsis:   Marshalls a remotable void star as ulong.
//
//  history:    June-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpVoidStar_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    unsigned long * pVoid )
{
    if ( !pVoid )
        return pBuffer;

    ALIGN( pBuffer, 3 );

    *( PULONG_LV_CAST pBuffer)++ = *pVoid;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpVoidStaer_UserUnmarshall
//
//  Synopsis:   Unmarshalls a remotable void star as ulong.
//
//  history:    June-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpVoidStar_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    unsigned long *           pVoid )
{
    ALIGN( pBuffer, 3 );

    *pVoid= *( PULONG_LV_CAST pBuffer)++;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpVoidStar_UserFree
//
//--------------------------------------------------------------------------

void __RPC_USER
WdtpVoidStar_UserFree(
    unsigned long * pFlags,
    unsigned long * pVoid )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserSize
//
//  Synopsis:   Sizes an HWND handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HWND_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HWND          * pH )
{
    return WdtpVoidStar_UserSize( pFlags, Offset, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserMarshall
//
//  Synopsis:   Marshalls an HWND handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HWND_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HWND          * pH )
{
    return WdtpVoidStar_UserMarshal( pFlags, pBuffer, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HWND handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HWND_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HWND          * pH )
{
    return WdtpVoidStar_UserUnmarshal( pFlags, pBuffer, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HWND_UserFree
//
//  Synopsis:   Shouldn't be called.
//
//--------------------------------------------------------------------------

void __RPC_USER
HWND_UserFree(
    unsigned long * pFlags,
    HWND          * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserSize
//
//  Synopsis:   Sizes an HMENU handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMENU_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMENU         * pH )
{
    return WdtpVoidStar_UserSize( pFlags, Offset, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserMarshall
//
//  Synopsis:   Marshalls an HMENU handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMENU_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMENU         * pH )
{
    return WdtpVoidStar_UserMarshal( pFlags, pBuffer, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HMENU handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMENU_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMENU         * pH )
{
    return WdtpVoidStar_UserUnmarshal( pFlags, pBuffer, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMENU_UserFree
//
//  Synopsis:   Free an HMENU.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMENU_UserFree(
    unsigned long * pFlags,
    HMENU         * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserSize
//
//  Synopsis:   Sizes an HACCEL handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HACCEL_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HACCEL        * pH )
{
    return WdtpVoidStar_UserSize( pFlags, Offset, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserMarshall
//
//  Synopsis:   Marshalls an HACCEL handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HACCEL_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HACCEL        * pH )
{
    return WdtpVoidStar_UserMarshal( pFlags, pBuffer, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HACCEL handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HACCEL_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HACCEL        * pH )
{
    return WdtpVoidStar_UserUnmarshal( pFlags, pBuffer, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HACCEL_UserFree
//
//  Synopsis:   Free an HACCEL.
//
//--------------------------------------------------------------------------

void __RPC_USER
HACCEL_UserFree(
    unsigned long * pFlags,
    HACCEL        * pH )
{
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserSize
//
//  Synopsis:   Sizes an HBRUSH handle.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HBRUSH_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HBRUSH        * pH )
{
    return WdtpVoidStar_UserSize( pFlags, Offset, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserMarshall
//
//  Synopsis:   Marshalls an HBRUSH handle into the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBRUSH_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBRUSH        * pH )
{
    return WdtpVoidStar_UserMarshal( pFlags, pBuffer, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HBRUSH handle from the RPC buffer.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBRUSH_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBRUSH        * pH )
{
    return WdtpVoidStar_UserUnmarshal( pFlags, pBuffer, (ulong*)pH );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBRUSH_UserFree
//
//  Synopsis:   Free an HBRUSH.
//
//--------------------------------------------------------------------------

void __RPC_USER
HBRUSH_UserFree(
    unsigned long * pFlags,
    HBRUSH        * pH )
{
}


// #########################################################################
//
//  HGLOBAL.
//  See transmit.h for explanation of strict data/handle passing.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserSize
//
//  Synopsis:   Get the wire size the HGLOBAL handle and data.
//
//  Derivation: Conformant struct with a flag field:
//                  align + 12 + data size.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HGLOBAL_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HGLOBAL       * pGlobal)
{
    if ( !pGlobal )
        return Offset;

    // userHGLOBAL: the encapsulated union.
    // Discriminant and then handle or pointer from the union arm.

    LENGTH_ALIGN( Offset, 3 );

    Offset += sizeof(long) + sizeof(void*);

    if ( ! *pGlobal )
        return Offset;

    if ( HGLOBAL_DATA_PASSING(*pFlags) )
        {
        unsigned long   ulDataSize = GlobalSize( *pGlobal );
                            
        Offset += 3 * sizeof(long) + ulDataSize;
        }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserMarshall
//
//  Synopsis:   Marshalls an HGLOBAL object into the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HGLOBAL_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal)
{
    if ( !pGlobal )
        return pBuffer;

    // We marshal a null handle, too.

    UserNdrDebugOut((UNDR_OUT4, "HGLOBAL_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( HGLOBAL_DATA_PASSING(*pFlags) )
        {
        unsigned long   ulDataSize;
    
        // userHGLOBAL

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = (ulong) *pGlobal;

        if ( ! *pGlobal )
            return pBuffer;
    
        // FLAGGED_BYTE_BLOB
    
        ulDataSize = GlobalSize( *pGlobal );
    
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
    
        // Handle is the non-null flag
    
        *( PULONG_LV_CAST pBuffer)++ = (ulong)*pGlobal;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
    
        if( ulDataSize )
            {
            void * pData = GlobalLock( *pGlobal);
            memcpy( pBuffer, pData, ulDataSize );
            GlobalUnlock( *pGlobal);
            }
    
        pBuffer += ulDataSize;
        }
    else
        {
        // Sending a handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = (ulong) *pGlobal;
        }

    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   WdtpGlobalUnmarshal
//
//  Synopsis:   Unmarshalls an HGLOBAL object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  Note:       Reallocation is forbidden when the hglobal is part of
//              an [in,out] STGMEDIUM in IDataObject::GetDataHere.
//              This affects only data passing with old handles being
//              non null.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpGlobalUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal,
    BOOL            fCanReallocate )
{
    unsigned long   ulDataSize, fHandle, UnionDisc;
    HGLOBAL         hGlobal;

    ALIGN( pBuffer, 3 );

    UnionDisc =           *( PULONG_LV_CAST pBuffer)++;
    hGlobal   = (HGLOBAL) *( PULONG_LV_CAST pBuffer)++;

    if ( IS_DATA_MARKER( UnionDisc) )
        {
        if ( ! hGlobal )
            {
            if ( *pGlobal )
                GlobalFree( *pGlobal );
            *pGlobal = NULL;
            return pBuffer;
            }

        // There is a handle data on wire.
    
        ulDataSize = *( PULONG_LV_CAST pBuffer)++;
        // fhandle and data size again.
        pBuffer += 8;

        if ( *pGlobal )
            {
            // Check for reallocation

            if ( GlobalSize( *pGlobal ) == ulDataSize )
                hGlobal = *pGlobal;
            else
                {
                if ( fCanReallocate )
                    {
                    //  hGlobal = GlobalReAlloc( *pGlobal, ulDataSize, GMEM_MOVEABLE );

                    GlobalFree( *pGlobal );
                    hGlobal = GlobalAlloc( GMEM_MOVEABLE, ulDataSize );
                    }
                else
                    {
                    if ( GlobalSize(*pGlobal) < ulDataSize )
                        RpcRaiseException( STG_E_MEDIUMFULL );
                    else
                        hGlobal = *pGlobal;
                    }
                }
            }
        else
            {
            // allocate a new block

            hGlobal = GlobalAlloc( GMEM_MOVEABLE, ulDataSize );
            }

        if ( hGlobal == NULL )
            RpcRaiseException(E_OUTOFMEMORY);
        else
            {
            void * pData = GlobalLock( hGlobal);
            memcpy( pData, pBuffer, ulDataSize );
            pBuffer += ulDataSize;
            GlobalUnlock( hGlobal);
            }
        }
    else
        {
        // Sending a handle only.
        // Reallocation problem doesn't apply to handle passing.

        if ( *pGlobal != hGlobal  && *pGlobal )
            GlobalFree( *pGlobal );
        }

    *pGlobal = hGlobal;
    
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HGLOBAL object from the RPC buffer.
//
//  Derivation: Conformant struct with a flag field:
//                  align, size, null flag, size, data (bytes, if any)
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HGLOBAL_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HGLOBAL       * pGlobal)
{
    return( WdtpGlobalUnmarshal( pFlags,
                                 pBuffer,
                                 pGlobal,
                                 TRUE ) );     // reallocation possible
}

//+-------------------------------------------------------------------------
//
//  Function:   HGLOBAL_UserFree
//
//  Synopsis:   Free an HGLOBAL.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HGLOBAL_UserFree(
    unsigned long * pFlags,
    HGLOBAL *       pGlobal)
{
    if( pGlobal  &&  *pGlobal )
        {
        if ( HGLOBAL_DATA_PASSING(*pFlags) )
            GlobalFree( *pGlobal);
        }
}


// #########################################################################
//
//  HMETAFILEPICT
//  See transmit.h for explanation of strict vs. lax data/handle passing.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserSize
//
//  Synopsis:   Get the wire size the HMETAFILEPICT handle and data.
//
//  Derivation: Union of a long and the meta file pict handle.
//              Then struct with top layer (and a hmetafile handle).
//              The the representation of the metafile.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HMETAFILEPICT_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HMETAFILEPICT * pHMetaFilePict )
{
    if ( !pHMetaFilePict )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    // Discriminant of the encapsulated union and the union arm.

    Offset += 8;

    if ( ! *pHMetaFilePict )
        return Offset;

    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
        return Offset;

    // Now, this is a two layer object with HGLOBAL on top.
    // Upper layer - hglobal part - needs to be sent as data.

    METAFILEPICT *
    pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

    if ( pMFP == NULL )
        RpcRaiseException( E_OUTOFMEMORY );

    // Upper layer: 3 long fields + handle

    Offset += 3 * sizeof(long) + sizeof(void*);

    // The lower part is a metafile handle.

    if ( HGLOBAL_DATA_PASSING( *pFlags) )
        {
        ulong  ulDataSize = GetMetaFileBitsEx( pMFP->hMF, 0 , NULL );
    
        Offset += 12 + ulDataSize;
        }

    GlobalUnlock( *(HANDLE *)pHMetaFilePict );

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserMarshal
//
//  Synopsis:   Marshalls an HMETAFILEPICT object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HMETAFILEPICT * pHMetaFilePict )
{
    if ( !pHMetaFilePict )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILEPICT_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
        {
        // Sending only the top level global handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = (ulong)*(HANDLE*)pHMetaFilePict;

        return pBuffer;
        }

    // userHMETAFILEPICT
    // We need to send the data from the top (hglobal) layer.

    *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
    *( PULONG_LV_CAST pBuffer)++ = (ulong)*pHMetaFilePict;

    if ( ! *pHMetaFilePict )
        return pBuffer;

    // remoteHMETAFILEPICT

    METAFILEPICT * pMFP = (METAFILEPICT*) GlobalLock(
                                             *(HANDLE *)pHMetaFilePict );
    if ( pMFP == NULL )
        RpcRaiseException( E_OUTOFMEMORY );

    *( PULONG_LV_CAST pBuffer)++ = pMFP->mm;
    *( PULONG_LV_CAST pBuffer)++ = pMFP->xExt;
    *( PULONG_LV_CAST pBuffer)++ = pMFP->yExt;
    *( PULONG_LV_CAST pBuffer)++ = (ulong) pMFP->hMF;

    // See if the HMETAFILE needs to be sent as data, too.

    if ( pMFP->hMF  &&  HGLOBAL_DATA_PASSING(*pFlags) )
        {
        ulong  ulDataSize = GetMetaFileBitsEx( pMFP->hMF, 0 , NULL );

        // conformant size then the size field

        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        GetMetaFileBitsEx( pMFP->hMF, ulDataSize , pBuffer );

        pBuffer += ulDataSize;
        }

    GlobalUnlock( *(HANDLE *)pHMetaFilePict );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserUnmarshal
//
//  Synopsis:   Unmarshalls an HMETAFILEPICT object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HMETAFILEPICT_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBufferStart,
    HMETAFILEPICT * pHMetaFilePict )
{
    unsigned long   ulDataSize, fHandle;
    unsigned char * pBuffer;
    HMETAFILEPICT   hMetaFilePict;

    UserNdrDebugOut((UNDR_OUT4, "HMETAFILEPICT_UserUnmarshal\n"));

    pBuffer = pBufferStart;
    ALIGN( pBuffer, 3 );

    unsigned long UnionDisc =       *( PULONG_LV_CAST pBuffer)++;
    hMetaFilePict = (HMETAFILEPICT) *( PULONG_LV_CAST pBuffer)++;

    if ( IS_DATA_MARKER( UnionDisc)  &&  hMetaFilePict )
        {
        HGLOBAL hGlobal = GlobalAlloc( GMEM_MOVEABLE, sizeof(METAFILEPICT) );
        hMetaFilePict = (HMETAFILEPICT) hGlobal;

        if ( hMetaFilePict == NULL )
            RpcRaiseException( E_OUTOFMEMORY );

        METAFILEPICT * pMFP = (METAFILEPICT*) GlobalLock(
                                                    (HANDLE) hMetaFilePict );
        if ( pMFP == NULL )
            RpcRaiseException( E_OUTOFMEMORY );

        pMFP->mm   = *( PULONG_LV_CAST pBuffer)++;
        pMFP->xExt = *( PULONG_LV_CAST pBuffer)++;
        pMFP->yExt = *( PULONG_LV_CAST pBuffer)++;
        pMFP->hMF  = (HMETAFILE) *( PULONG_LV_CAST pBuffer)++;

        if ( pMFP->hMF  &&  HGLOBAL_DATA_PASSING(*pFlags) )
            {
            // conformant size then the size field

            ulong ulDataSize = *( PULONG_LV_CAST pBuffer)++;
            pBuffer += 4;
    
            pMFP->hMF = SetMetaFileBitsEx( ulDataSize, (uchar*)pBuffer );
    
            pBuffer += ulDataSize;
            }

        GlobalUnlock( (HANDLE) hMetaFilePict );
        }

    // no reusage, just release the previous one.

    if ( *pHMetaFilePict )
        {
        // This may happen on the client only and doesn't depend on
        // how the other one was passed.

        METAFILEPICT *
        pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

        if ( pMFP == NULL )
            RpcRaiseException( E_OUTOFMEMORY );

        if ( pMFP->hMF )
            DeleteMetaFile( pMFP->hMF );

        GlobalUnlock( *pHMetaFilePict );
        GlobalFree( *pHMetaFilePict );
        }

    *pHMetaFilePict = hMetaFilePict;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HMETAFILEPICT_UserFree
//
//  Synopsis:   Free an HMETAFILEPICT.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HMETAFILEPICT_UserFree(
    unsigned long * pFlags,
    HMETAFILEPICT * pHMetaFilePict )
{
    UserNdrDebugOut((UNDR_FORCE, "HMETAFILEPICT_UserFree\n"));

    if( pHMetaFilePict  &&  *pHMetaFilePict )
        {
        if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
            return;

        // Need to free the upper hglobal part.

        METAFILEPICT *
        pMFP = (METAFILEPICT*) GlobalLock( *(HANDLE *)pHMetaFilePict );

        if ( pMFP == NULL )
            RpcRaiseException( E_OUTOFMEMORY );

        // See if we need to free the hglobal, too.

        if ( pMFP->hMF  &&  HGLOBAL_DATA_PASSING(*pFlags) )
            DeleteMetaFile( pMFP->hMF );

        GlobalUnlock( *pHMetaFilePict );
        GlobalFree( *pHMetaFilePict );
        }
}



// #########################################################################
//
//  HENHMETAFILE
//  See transmit.h for explanation of lax data/handle passing.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserSize
//
//  Synopsis:   Get the wire size the HENHMETAFILE handle and data.
//
//  Derivation: Union of a long and the meta file handle and then struct.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HENHMETAFILE_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HENHMETAFILE  * pHEnhMetafile )
{
    if ( !pHEnhMetafile )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.

    Offset += sizeof(long) + sizeof(void*);

    if ( ! *pHEnhMetafile )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // Pointee of the union arm for the remote case.
        // Byte blob : conformant size, size field, data

        Offset += 2 * sizeof(long);

        ulong ulDataSize = GetEnhMetaFileBits( *pHEnhMetafile, 0, NULL );
        Offset += ulDataSize;
        }

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserMarshall
//
//  Synopsis:   Marshalls an HENHMETAFILE object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile )
{
    if ( !pHEnhMetafile )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HENHMETAFILE_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // userHENHMETAFILE

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = (ulong) *pHEnhMetafile;

        if ( !*pHEnhMetafile )
            return pBuffer;

        // BYTE_BLOB: conformant size, size field, data

        ulong ulDataSize = GetEnhMetaFileBits( *pHEnhMetafile, 0, NULL );

        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;
        *( PULONG_LV_CAST pBuffer)++ = ulDataSize;

        if ( 0 == GetEnhMetaFileBits( *pHEnhMetafile,
                                      ulDataSize,
                                      (uchar*)pBuffer ) )
           RpcRaiseException( HRESULT_FROM_WIN32(GetLastError()));

        pBuffer += ulDataSize;
        }
    else
        {
        // Sending a handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = (ulong) *(HANDLE *)pHEnhMetafile;
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HENHMETAFILE object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HENHMETAFILE_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HENHMETAFILE  * pHEnhMetafile )
{
    HENHMETAFILE    hEnhMetafile;

    UserNdrDebugOut((UNDR_OUT4, "HENHMETAFILE_UserUnmarshal\n"));

    ALIGN( pBuffer, 3 );

    unsigned long UnionDisc =     *( PULONG_LV_CAST pBuffer)++;
    hEnhMetafile = (HENHMETAFILE) *( PULONG_LV_CAST pBuffer)++;

    if ( IS_DATA_MARKER( UnionDisc) )
        {
        if ( hEnhMetafile )
            {
            // Byte blob : conformant size, size field, data

            ulong ulDataSize = *(ulong*)pBuffer;
            pBuffer += 8;
            hEnhMetafile = SetEnhMetaFileBits( ulDataSize, (uchar*) pBuffer );
            pBuffer += ulDataSize;
            }
        }

    // No reusage of the old object.

    if (*pHEnhMetafile)
        DeleteEnhMetaFile( *pHEnhMetafile );

    *pHEnhMetafile = hEnhMetafile;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HENHMETAFILE_UserFree
//
//  Synopsis:   Free an HENHMETAFILE.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HENHMETAFILE_UserFree(
    unsigned long * pFlags,
    HENHMETAFILE  * pHEnhMetafile )
{
    UserNdrDebugOut((UNDR_FORCE, "HENHMETAFILE_UserFree\n"));

    if( pHEnhMetafile  &&  *pHEnhMetafile )
        {
        if ( GDI_DATA_PASSING(*pFlags) )
            {
            DeleteEnhMetaFile( *pHEnhMetafile );
            }
        }
}


// #########################################################################
//
//  HBITMAP
//  See transmit.h for explanation of lax data/handle passing.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserSize
//
//  Synopsis:   Get the wire size the HBITMAP handle and data.
//
//  Derivation: Union of a long and the bitmap handle and then struct.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HBITMAP_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HBITMAP       * pHBitmap )
{
    if ( !pHBitmap )
        return Offset;

    BITMAP      bm;
    HBITMAP     hBitmap = *pHBitmap;

    LENGTH_ALIGN( Offset, 3 );

    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.

    Offset += sizeof(long) + sizeof(void*);

    if ( ! *pHBitmap )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // Pointee of the union arm for the remote case.
        // Conformat size, 6 fields, size, conf array.

        Offset += 4 + 4 * sizeof(LONG) + 2 * sizeof(WORD) + 4;

        // Get information about the bitmap

        #if defined(_CHICAGO_)
            if (FALSE == GetObjectA(hBitmap, sizeof(BITMAP), &bm))
        #else
            if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
        #endif
                {
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
                }

        ULONG ulDataSize = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;

        Offset += ulDataSize;
        }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserMarshall
//
//  Synopsis:   Marshalls an HBITMAP object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap )
{
    if ( !pHBitmap )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // userHBITMAP

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = (ulong) *pHBitmap;

        if ( ! *pHBitmap )
            return pBuffer;

        // Get information about the bitmap

        BITMAP bm;
        HBITMAP hBitmap = *pHBitmap;

        #if defined(_CHICAGO_)
            if (FALSE == GetObjectA(hBitmap, sizeof(BITMAP), &bm))
        #else
            if (FALSE == GetObject(hBitmap, sizeof(BITMAP), &bm))
        #endif
                {
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
                }

        DWORD dwCount = bm.bmPlanes * bm.bmHeight * bm.bmWidthBytes;

        *( PULONG_LV_CAST pBuffer)++ = dwCount;

        // Get the bm structure fields.

        ulong ulBmSize = 4 * sizeof(LONG) + 2 * sizeof( WORD );

        memcpy( pBuffer, (void *) &bm, ulBmSize );
        pBuffer += ulBmSize;

        // Get the raw bits.

        if (0 == GetBitmapBits( hBitmap, dwCount, pBuffer ) )
            {
            RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
            }
        pBuffer += dwCount;
        }
    else
        {
        // Sending a handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = (ulong) *(HANDLE *)pHBitmap;
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HBITMAP object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HBITMAP_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HBITMAP       * pHBitmap )
{
    HBITMAP         hBitmap;

    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserUnmarshal\n"));

    ALIGN( pBuffer, 3 );

    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;
    hBitmap =       (HBITMAP) *( PULONG_LV_CAST pBuffer)++;

    if ( IS_DATA_MARKER( UnionDisc) )
        {
        if ( hBitmap )
            {
            DWORD    dwCount = *( PULONG_LV_CAST  pBuffer)++;
            BITMAP * pBm     = (BITMAP *) pBuffer;

            ulong ulBmSize = 4 * sizeof(LONG) + 2 * sizeof( WORD );

            pBuffer += ulBmSize;

            // Create a bitmap based on the BITMAP structure and the raw bits in
            // the transmission buffer

            hBitmap = CreateBitmap( pBm->bmWidth,
                                    pBm->bmHeight,
                                    pBm->bmPlanes,
                                    pBm->bmBitsPixel,
                                    pBuffer );

            pBuffer += dwCount;
            }
        }

    // A new bitmap handle is ready, destroy the old one, if needed.

    if ( *pHBitmap )
        DeleteObject( *pHBitmap );

    *pHBitmap = hBitmap;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HBITMAP_UserFree
//
//  Synopsis:   Free an HBITMAP.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HBITMAP_UserFree(
    unsigned long * pFlags,
    HBITMAP       * pHBitmap )
{
    UserNdrDebugOut((UNDR_OUT4, "HBITMAP_UserFree\n"));

    if( pHBitmap  &&  *pHBitmap )
        {
        if ( GDI_DATA_PASSING(*pFlags) )
            {
            DeleteObject( *pHBitmap );
            }
        }
}


// #########################################################################
//
//  HPALETTE
//  See transmit.h for explanation of lax data/handle passing.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserSize
//
//  Synopsis:   Get the wire size the HPALETTE handle and data.
//
//  Derivation: Union of a long and the hpalette handle.
//              Then the struct represents hpalette.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
HPALETTE_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HPALETTE      * pHPalette )
{
    if ( !pHPalette )
        return Offset;

    BITMAP      bm;

    LENGTH_ALIGN( Offset, 3 );

    // The encapsulated union.
    // Discriminant and then handle or pointer from the union arm.

    Offset += sizeof(long) + sizeof(void*);

    if ( ! *pHPalette )
        return Offset;

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // Conformat struct with version and size and conf array of entries.

        Offset += sizeof(long) + 2 * sizeof(short);

        // Determine the number of color entries in the palette

        DWORD cEntries = GetPaletteEntries(*pHPalette, 0, 0, NULL);

        Offset += cEntries * sizeof(PALETTEENTRY);
        }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserMarshall
//
//  Synopsis:   Marshalls an HPALETTE object into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette )
{
    if ( !pHPalette )
        return pBuffer;

    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserMarshal\n"));

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( GDI_DATA_PASSING(*pFlags) )
        {
        // userHPALETTE

        *( PULONG_LV_CAST pBuffer)++ = WDT_DATA_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = (ulong) *pHPalette;

        if ( ! *pHPalette )
            return pBuffer;
    
        // rpcLOGPALETTE
        // Logpalette is a conformant struct with a version field,
        // size filed and conformant array of palentries.

        // Determine the number of color entries in the palette

        DWORD cEntries = GetPaletteEntries(*pHPalette, 0, 0, NULL);

        // Conformant size

        *( PULONG_LV_CAST pBuffer)++ = cEntries;

        // Fields: both are short!
        // The old code was just setting the version number.
        // They say it has to be that way.

        *( PUSHORT_LV_CAST pBuffer)++ = (ushort) 0x300;
        *( PUSHORT_LV_CAST pBuffer)++ = (ushort) cEntries;

        // Entries: each entry is a struct with 4 bytes.
        // Calculate the resultant data size

        DWORD cbData = cEntries * sizeof(PALETTEENTRY);

        if (cbData)
            {
            if (0 == GetPaletteEntries( *pHPalette,
                                        0,
                                        cEntries,
                                        (PALETTEENTRY *)pBuffer ) )
                {
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
                }
            pBuffer += cbData;
            }
        }
    else
        {
        // Sending a handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = (ulong) *(HANDLE *)pHPalette;
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserUnmarshall
//
//  Synopsis:   Unmarshalls an HPALETTE object from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
HPALETTE_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HPALETTE      * pHPalette )
{
    HPALETTE        hPalette;

    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserUnmarshal\n"));

    ALIGN( pBuffer, 3 );

    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;
    hPalette =     (HPALETTE) *( PULONG_LV_CAST pBuffer)++;

    if ( IS_DATA_MARKER( UnionDisc) )
        {
        if ( hPalette )
            {
            // Get the conformant size.
    
            DWORD           cEntries = *( PULONG_LV_CAST pBuffer)++;
            LOGPALETTE *    pLogPal;
    
            // If there are 0 color entries, we need to allocate the LOGPALETTE
            // structure with the one dummy entry (it's a variably sized struct).
            // Otherwise, we need to allocate enough space for the extra n-1
            // entries at the tail of the structure
    
            if (0 == cEntries)
                {
                pLogPal = (LOGPALETTE *) WdtpAllocate( pFlags,
                                                       sizeof(LOGPALETTE));
                }
            else
                {
                pLogPal = (LOGPALETTE *)
                          WdtpAllocate( pFlags,
                                        sizeof(LOGPALETTE) +
                                        (cEntries - 1) * sizeof(PALETTEENTRY));
                }
    
            pLogPal->palVersion    = *( PUSHORT_LV_CAST pBuffer)++;
            pLogPal->palNumEntries = *( PUSHORT_LV_CAST pBuffer)++;
    
            // If there are entries, move them into out LOGPALETTE structure
    
            if (cEntries)
                {
                memcpy( &(pLogPal->palPalEntry[0]),
                        pBuffer,
                        cEntries * sizeof(PALETTEENTRY) );
                pBuffer += cEntries * sizeof(PALETTEENTRY);
                }
    
            // Attempt to create the palette
    
            hPalette = CreatePalette(pLogPal);
    
            // Success or failure, we're done with the LOGPALETTE structure
    
            WdtpFree( pFlags, pLogPal );
    
            // If the creation failed, raise an exception
    
            if (NULL == hPalette)
                {
                RpcRaiseException(HRESULT_FROM_WIN32(GetLastError()));
                }
            }
        }

    // A new palette is ready, destroy the old one, if needed.

    if ( *pHPalette )
        DeleteObject( *pHPalette );

    *pHPalette = hPalette;

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   HPALETTE_UserFree
//
//  Synopsis:   Free an HPALETTE.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
HPALETTE_UserFree(
    unsigned long * pFlags,
    HPALETTE      * pHPalette )
{
    UserNdrDebugOut((UNDR_OUT4, "HPALETTE_UserFree\n"));

    if( pHPalette  &&  *pHPalette )
        {
        if ( GDI_DATA_PASSING(*pFlags) )
            {
            DeleteObject( *pHPalette );
            }
        }
}


// #########################################################################
//
//  NON REMOTABLE GDI and other HANDLES
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   WdtpNonRemotableHandle_UserSize
//
//  Synopsis:   Get the wire size for a non remotable GDI handle.
//
//  Derivation: Union of a long and nothing.
//              It is union just in case some remoting is needed.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
WdtpNonRemotableHandle_UserSize (
    unsigned long * pFlags,
    unsigned long   Offset,
    HANDLE        * pHandle )
{
    if ( !pHandle  ||  *pHandle == NULL )
        return Offset;

    if ( HGLOBAL_DATA_PASSING(*pFlags) )
        RpcRaiseException(E_INVALIDARG );

    LENGTH_ALIGN( Offset, 3 );

    // The encapsulated union.
    // No remote case on any platform.

    return( Offset + 8 ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpNonRemotableHandle_UserMarshal
//
//  Synopsis:   Marshalls a non-remotable handle into the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpNonRemotableHandle_UserMarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HANDLE        * pHandle )
{
    if ( !pHandle  ||  *pHandle == NULL )
        return pBuffer;

    ALIGN( pBuffer, 3 );

    // Discriminant of the encapsulated union and union arm.

    if ( HGLOBAL_DATA_PASSING(*pFlags) )
        {
        RpcRaiseException(E_INVALIDARG );
        }
    else
        {
        // Sending a handle.

        *( PULONG_LV_CAST pBuffer)++ = WDT_HANDLE_MARKER;
        *( PULONG_LV_CAST pBuffer)++ = (ulong) *(HANDLE *)pHandle;
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpNonRemotableHandle_UserUnmarshal
//
//  Synopsis:   Unmarshalls a non-remotable handle from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpNonRemotableHandle_UserUnmarshal (
    unsigned long * pFlags,
    unsigned char * pBuffer,
    HANDLE        * pHandle )
{
    ALIGN( pBuffer, 3 );

    unsigned long UnionDisc = *( PULONG_LV_CAST pBuffer)++;

    if ( IS_DATA_MARKER( UnionDisc) )
        {
        RpcRaiseException(E_INVALIDARG );
        }
    else
        {
        // Sending a handle.

        *pHandle = (HANDLE) *( PULONG_LV_CAST pBuffer)++;
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpNonRemotableHandle_UserFree
//
//  Synopsis:   Nothing to free.
//
//--------------------------------------------------------------------------

void __RPC_USER
WdtpNonRemotableGdiHandle_UserFree(
    unsigned long * pFlags,
    HANDLE        * pHandle )
{
}



// #########################################################################
//
//  Interface pointers.
//
// #########################################################################

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserSize
//
//  Synopsis:   Get the wire size for an interface pointer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
WdtpInterfacePointer_UserSize (
    USER_MARSHAL_CB   * pContext,
    unsigned long       Flags,
    unsigned long       Offset,
    IUnknown          * pIf,
    const IID &         IId )
{
    if ( pIf )
        {
        LENGTH_ALIGN( Offset, 3 );

        //Leave space for array bounds and length

        Offset += 2 * sizeof(long);

        HRESULT         hr;
        unsigned long   cbSize = 0;

        hr = CoGetMarshalSizeMax( &cbSize,
                                  IId,
                                  pIf,
                                  USER_CALL_CTXT_MASK( Flags ),
                                  pContext->pStubMsg->pvDestContext,
                                  MSHLFLAGS_NORMAL );
        if ( FAILED(hr) )
            RpcRaiseException( hr );

        Offset += cbSize;
        }

    return( Offset ) ;
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserMarshal
//
//  Synopsis:   Marshalls an interface pointer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpInterfacePointer_UserMarshal (
    USER_MARSHAL_CB   * pContext,
    unsigned long       Flags,
    unsigned char     * pBuffer,
    IUnknown          * pIf,
    const IID &         IId )
{
    unsigned long * pMaxCount, *pSize;
    unsigned long   cbData = 0;

    UserNdrDebugOut((UNDR_OUT1, "WdtpInterface_PointerMarshal\n"));

    if ( pIf )
        {
        // Always marshaled because of the apartment model.

        CStreamOnMessage MemStream( (unsigned char **) &pBuffer );

        ALIGN( pBuffer, 3 );

        pMaxCount = (unsigned long *) pBuffer;
        pBuffer += 4;

        // Leave space for length

        pSize = (unsigned long *) pBuffer;
        pBuffer += 4;

        HRESULT  hr;
        unsigned char * pBufferMark = pBuffer;

        hr = CoMarshalInterface( &MemStream,
                                 IId,
                                 pIf,
                                 USER_CALL_CTXT_MASK( Flags ),
                                 pContext->pStubMsg->pvDestContext,
                                 MSHLFLAGS_NORMAL );
        if( FAILED(hr) )
            {
            RpcRaiseException(hr);
            }

        // Calculate the size of the data written

        DWORD cbData = pBuffer - pBufferMark;

        // Update the array bounds.

        *pMaxCount = cbData;
        *pSize = cbData;
        }

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserUnmarshal
//
//  Synopsis:   Unmarshalls an interface pointer from the RPC buffer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
WdtpInterfacePointer_UserUnmarshal (
    USER_MARSHAL_CB   * pContext,
    unsigned char     * pBuffer,
    IUnknown         ** ppIf,
    const IID &         IId )
{
    unsigned long      *pMaxCount, *pSize;
    unsigned long       cbData = 0;

    UserNdrDebugOut((UNDR_OUT1, "WdtpInterfacePointerUnmarshal\n"));

    // Always unmarshaled because of the apartment model.

    CStreamOnMessage  MemStream((unsigned char **) &pBuffer);

    ALIGN( pBuffer, 3 );

    pMaxCount = (unsigned long *) pBuffer;
    pBuffer += sizeof(long);

    //Unmarshal count
    pSize = (unsigned long *) pBuffer;
    pBuffer += sizeof(long);

    // Release the old pointer after unmarshalling the new one
    // to prevent object from getting released too early.
    // Then release the old one only when successful.

    IUnknown * punkTemp = 0;

    HRESULT hr = CoUnmarshalInterface( &MemStream,
                                       IId,
                                       (void **) &punkTemp );
    if(FAILED(hr))
        RpcRaiseException(hr);
    else
        {
        // On the client side, release the [in,out] interface pointer.
        // The pointer may be different from NULL only on the client side.

        if ( (IId == IID_IStorage  ||  IId == IID_IStream ) &&  *ppIf )
            {
            // This may happen only on the client side.

            // Throw away a new one when coming back to the client !!
            // This is a  pecularity of DocFile custom marshalling:
            // pointer identity is broken.

            if ( punkTemp )
                punkTemp->Release();

            // keep the old one
            }
        else
            {
            // release the old one, keep the new one.

            if ( *ppIf )
                (*ppIf)->Release();
            *ppIf = punkTemp;
            }
        }


    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   WdtpInterfacePointer_UserFree
//
//  Synopsis:   Releases an interface pointer.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
WdtpInterfacePointer_UserFree(
    IUnknown      * pIf )
{
    UserNdrDebugOut((UNDR_OUT1, "WdtpInterfacePointer_UserFree\n"));

    if( pIf )
        {
        pIf->Release();
        }
}



//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserSize
//
//  Synopsis:   Sizes a stgmedium pbject for RPC marshalling.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
STGMEDIUM_UserSize(
    unsigned long * pFlags,
    unsigned long   Offset,
    STGMEDIUM     * pStgmed )
{
    if ( ! pStgmed )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    if ( pStgmed->tymed == TYMED_NULL )
        Offset += sizeof(void*) + sizeof(long);   // pointer, switch only
    else
        Offset += sizeof(void*) + sizeof(long) + sizeof(void*); // same + handle

    // Pointee of the union arm.
    // Only if the handle/pointer field is non-null.

    if ( pStgmed->hGlobal )
        {
        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:
                Offset = HMETAFILEPICT_UserSize( pFlags,
                                                  Offset,
                                                  &pStgmed->hMetaFilePict );
                break;
            case TYMED_ENHMF:
                Offset = HENHMETAFILE_UserSize( pFlags,
                                                  Offset,
                                                  &pStgmed->hEnhMetaFile );
                break;
            case TYMED_GDI:
    
                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.
    
                // switch for object type.
    
                Offset += sizeof(long);
    
                switch( GetObjectType( (HGDIOBJ)pStgmed->hBitmap ) )
                    {
                    case OBJ_BITMAP:
                        Offset = HBITMAP_UserSize( pFlags,
                                                   Offset,
                                                   &pStgmed->hBitmap );
                        break;
    
                    case OBJ_PAL:
                        Offset = HPALETTE_UserSize( pFlags,
                                                    Offset,
                                       (HPALETTE *) & pStgmed->hBitmap );
                        break;
    
                    default:
                        RpcRaiseException(DV_E_TYMED);
                        break;
                    }
                break;
    
            case TYMED_HGLOBAL:
                Offset = HGLOBAL_UserSize( pFlags,
                                            Offset,
                                            &pStgmed->hGlobal );
                break;
            case TYMED_FILE:
                {
                ulong ulDataSize = wcslen(pStgmed->lpszFileName) + 1;
                Offset += 3 * sizeof(long); // [string]
                Offset += ulDataSize * sizeof(wchar_t);
                }
                break;
    
            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                // Note, that we have to set the local flag for backward
                // compatibility.
    
                Offset = WdtpInterfacePointer_UserSize(
                            (USER_MARSHAL_CB *)pFlags,
                            MSHCTX_LOCAL,
                            Offset,
                            pStgmed->pstg,
                            ((pStgmed->tymed == TYMED_ISTREAM)  ? IID_IStream
                                                                : IID_IStorage));
                break;
    
            default:
                break;
    
            }
        }

    // pUnkForRelease, if not null.

    if ( pStgmed->pUnkForRelease )
        Offset = WdtpInterfacePointer_UserSize( (USER_MARSHAL_CB *)pFlags,
                                                 *pFlags,
                                                 Offset,
                                                 pStgmed->pUnkForRelease,
                                                 IID_IUnknown );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserMarshal
//
//  Synopsis:   Marshals a stgmedium pbject for RPC.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserMarshal(
    unsigned long * pFlags,
    unsigned char * pBufferStart,
    STGMEDIUM     * pStgmed )
{
    unsigned char * pBuffer;
    unsigned char * pUnionArmMark;

    if ( ! pStgmed )
        return pBufferStart;

    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserMarshal: %s\n", WdtpGetStgmedName(pStgmed)));

    pBuffer = pBufferStart;
    ALIGN( pBuffer, 3 );

    // userSTGMEDIUM: if pointer, switch, union arm, .

    *( PULONG_LV_CAST pBuffer)++ = (ulong)pStgmed->pUnkForRelease;
    *( PULONG_LV_CAST pBuffer)++ = pStgmed->tymed;
    pUnionArmMark = pBuffer;
    if ( pStgmed->tymed != TYMED_NULL )
        {
        // hGlobal stands for any of these handles.

        *( PULONG_LV_CAST pBuffer)++ = (ulong)pStgmed->hGlobal;
        }

    // Now the pointee of the union arm.
    // We need to marshal only if the handle/pointer field is non null.
    // Otherwise it is already in the buffer. 

    if ( pStgmed->hGlobal )
        {
        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:
                pBuffer = HMETAFILEPICT_UserMarshal( pFlags,
                                                     pBuffer,
                                                     &pStgmed->hMetaFilePict );
                break;
            case TYMED_ENHMF:
                pBuffer = HENHMETAFILE_UserMarshal( pFlags,
                                                    pBuffer,
                                                    &pStgmed->hEnhMetaFile );
                break;
            case TYMED_GDI:
    
                {
                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.
    
                ulong GdiObjectType = GetObjectType( (HGDIOBJ)pStgmed->hBitmap );
    
                // GDI_OBJECT
    
                *( PULONG_LV_CAST pBuffer)++ = GdiObjectType;
    
    
    
                switch( GdiObjectType )
                    {
                    case OBJ_BITMAP:
                        pBuffer = HBITMAP_UserMarshal( pFlags,
                                                       pBuffer,
                                                       &pStgmed->hBitmap );
                        break;
    
                    case OBJ_PAL:
                        pBuffer = HPALETTE_UserMarshal( pFlags,
                                                        pBuffer,
                                           (HPALETTE *) & pStgmed->hBitmap );
                        break;
    
                    default:
                        RpcRaiseException(DV_E_TYMED);
                    }
                }
                break;
    
            case TYMED_HGLOBAL:
                pBuffer = HGLOBAL_UserMarshal( pFlags,
                                               pBuffer,
                                               & pStgmed->hGlobal );
                break;
            case TYMED_FILE:
                {
                // We marshal it as a [string].
    
                ulong Count = (pStgmed->lpszFileName)
                                    ?  wcslen(pStgmed->lpszFileName) + 1
                                    :  0;
    
                *( PULONG_LV_CAST pBuffer)++ = Count;
                *( PULONG_LV_CAST pBuffer)++ = 0;
                *( PULONG_LV_CAST pBuffer)++ = Count;
                memcpy( pBuffer, pStgmed->lpszFileName, Count * sizeof(wchar_t) );
                pBuffer += Count * sizeof(wchar_t);
                }
                break;
    
            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                // Note, that we have to set the local flag for backward compatibility.
    
                pBuffer = WdtpInterfacePointer_UserMarshal(
                               ((USER_MARSHAL_CB *)pFlags),
                               MSHCTX_LOCAL,
                               pBuffer,
                               pStgmed->pstg,
                               ((pStgmed->tymed == TYMED_ISTREAM)  ? IID_IStream
                                                                   : IID_IStorage));
                break;
    
            default:
                break;
            }
        }

    // Marker for this pointer is already in the buffer.

    if ( pStgmed->pUnkForRelease )
        pBuffer = WdtpInterfacePointer_UserMarshal( ((USER_MARSHAL_CB *)pFlags),
                                                    *pFlags,
                                                    pBuffer,
                                                    pStgmed->pUnkForRelease,
                                                    IID_IUnknown );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserUnmarshal
//
//  Synopsis:   Unmarshals a stgmedium object for RPC.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
STGMEDIUM_UserUnmarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    STGMEDIUM     * pStgmed )
{
    unsigned long   fUnkForRelease;
    unsigned long   Handle = 0;

    // if pointer, switch, union arm.

    ALIGN( pBuffer, 3 );

    // pUnkForRelease pointer marker.

    fUnkForRelease = *( PULONG_LV_CAST pBuffer)++;
    pStgmed->tymed = *( PULONG_LV_CAST pBuffer)++;

    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserUnmarshal: %s\n", WdtpGetStgmedName(pStgmed) ));

    if ( pStgmed->tymed != TYMED_NULL )
        {
        // handle or interface pointer (marker) from the buffer
        Handle =  *( PULONG_LV_CAST pBuffer)++;
        }

    // First pointee

    // Union arm pointee.
    // We need to unmarshal only if the handle/pointer field was not NULL.

    if ( Handle )
        {
        switch( pStgmed->tymed )
            {
            case TYMED_NULL:
                break;
            case TYMED_MFPICT:
                pBuffer = HMETAFILEPICT_UserUnmarshal( pFlags,
                                                       pBuffer,
                                                       &pStgmed->hMetaFilePict );
                break;
            case TYMED_ENHMF:
                pBuffer = HENHMETAFILE_UserUnmarshal( pFlags,
                                                      pBuffer,
                                                      &pStgmed->hEnhMetaFile );
                break;
            case TYMED_GDI:
                {
                // A GDI object is not necesarrily a BITMAP.  Therefore, we handle
                // those types we know about based on the object type, and reject
                // those which we do not support.
    
                DWORD GdiObjectType = *( PULONG_LV_CAST pBuffer)++;
    
                switch( GdiObjectType )
                    {
                    case OBJ_BITMAP:
                        pBuffer = HBITMAP_UserUnmarshal( pFlags,
                                                         pBuffer,
                                                         &pStgmed->hBitmap );
                        break;
    
                    case OBJ_PAL:
                        pBuffer = HPALETTE_UserUnmarshal( pFlags,
                                                          pBuffer,
                                             (HPALETTE *) & pStgmed->hBitmap );
                        break;
    
                    default:
                        RpcRaiseException(DV_E_TYMED);
                    }
                }
                break;
    
            case TYMED_HGLOBAL:
                // reallocation is forbidden for [in-out] hglobal in STGMEDIUM.
    
                pBuffer = WdtpGlobalUnmarshal( pFlags,
                                               pBuffer,
                                               & pStgmed->hGlobal,
                                               FALSE );     // realloc flag
                break;
    
            case TYMED_FILE:
                {
                // We marshal it as a [string].
    
                ulong Count = *( PULONG_LV_CAST pBuffer)++;
                pBuffer += 8;
    
                if ( ! pStgmed->lpszFileName )
                    pStgmed->lpszFileName = (LPOLESTR)
                                        WdtpAllocate( pFlags,
                                                      Count * sizeof(wchar_t) );
                memcpy( pStgmed->lpszFileName, pBuffer, Count * sizeof(wchar_t) );
                pBuffer += Count * sizeof(wchar_t);
                }
                break;
    
            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                // Non null pointer, retrieve the interface pointer
    
                pBuffer = WdtpInterfacePointer_UserUnmarshal(
                              (USER_MARSHAL_CB *)pFlags,
                              pBuffer,
                              (IUnknown **) &pStgmed->pstm,
                              ((pStgmed->tymed == TYMED_ISTREAM)
                                    ? IID_IStream
                                    : IID_IStorage));
                break;
    
            default:
                break;
            }
        }
    else
        {
        // New handle/pointer field is null, so release the previous one
        // if it wasn't null.

        if ( pStgmed->hGlobal )
            {
            // This should never happen for GetDataHere.

            // Note, that we release the handle field, not the stgmedium itself.
            // Accordingly, we don't follow punkForRelease.

            UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserUnmarshal: %s: NULL in, freeing old one\n", WdtpGetStgmedName(pStgmed)));

            STGMEDIUM  TmpStg = *pStgmed;
            TmpStg.pUnkForRelease = NULL;

            if ( pStgmed->tymed == TYMED_HGLOBAL )
                {
                // Cannot reallocate.
                RpcRaiseException(DV_E_TYMED);
                }
            else
                {
                ReleaseStgMedium( &TmpStg );
                }
            }

        pStgmed->hGlobal = 0;
        }

    if ( fUnkForRelease )
        {
        // There is an interface pointer on the wire.

        pBuffer = WdtpInterfacePointer_UserUnmarshal( (USER_MARSHAL_CB *)pFlags,
                                                      pBuffer,
                                                      &pStgmed->pUnkForRelease,
                                                      IID_IUnknown );
        }

    if ( pStgmed->pUnkForRelease )
        {
        // Replace the app's punkForRelease with our custom release
        // handler for special situations.

        // The special situation is when a handle is remoted with data
        // and so we have to clean up a side effect of having a data copy
        // around. UserFree does it properly but we need that for the callee.
        // When the callee releases a stgmed, it would invoke
        // ReleaseStgMedium and this API doesn't do anything for handles
        // when the punkForRelease is not NULL.

        ULONG fHandleWithData = 0;
        ULONG fTopLevelOnly = 0;

        switch ( pStgmed->tymed )
            {
            case TYMED_HGLOBAL:
                fHandleWithData = HGLOBAL_DATA_PASSING( *pFlags );
                break;

            case TYMED_ENHMF:
            case TYMED_GDI:
                fHandleWithData = GDI_DATA_PASSING( *pFlags );
                break;

            case TYMED_MFPICT:
                fHandleWithData = HGLOBAL_DATA_PASSING( *pFlags );
                fTopLevelOnly   = fHandleWithData  &&
                                        ! GDI_DATA_PASSING( *pFlags );
                break;

            default:
                break;
            }

        if ( fHandleWithData )
            {
            IUnknown *
            punkTmp = (IUnknown *) new CPunkForRelease( pStgmed,
                                                        fTopLevelOnly );
            if (!punkTmp)
                {
                RpcRaiseException(E_OUTOFMEMORY);
                }

            pStgmed->pUnkForRelease = punkTmp;
            }
        }

    return( pBuffer );
}


//+-------------------------------------------------------------------------
//
//  Function:   STGMEDIUM_UserFree
//
//  Synopsis:   Frees a stgmedium object for RPC.
//
//  history:    May-95   Ryszardk      Created.
//
//  Note:       This routine is called from the freeing walk at server
//              or from the SetData *proxy*, when ownership has been passed.
//
//--------------------------------------------------------------------------

EXTERN_C
void NukeHandleAndReleasePunk(
    STGMEDIUM * pStgmed )
{
    pStgmed->hGlobal = NULL;
    pStgmed->tymed = TYMED_NULL;

    if (pStgmed->pUnkForRelease)
        {
        pStgmed->pUnkForRelease->Release();
        pStgmed->pUnkForRelease = 0;
        }
}

void __RPC_USER
STGMEDIUM_UserFree(
    unsigned long * pFlags,
    STGMEDIUM * pStgmed )
{
    UserNdrDebugOut((UNDR_FORCE, "--STGMEDIUM_UserFree: %s\n", WdtpGetStgmedName(pStgmed)));

    if( pStgmed )
        {
        switch ( pStgmed->tymed )
            {
            case TYMED_FILE:
                WdtpFree( pFlags, pStgmed->lpszFileName);
                NukeHandleAndReleasePunk( pStgmed );
                break;

            case TYMED_NULL:
            case TYMED_ISTREAM:
            case TYMED_ISTORAGE:
                ReleaseStgMedium( pStgmed );
                break;

            case TYMED_GDI:
            case TYMED_ENHMF:

                if ( GDI_HANDLE_PASSING(*pFlags) )
                    {
                    NukeHandleAndReleasePunk( pStgmed );
                    }
                else
                    {
                    // Handle w/data: there is a side effect to clean up.
                    // For punk !=0, this will go to our CPunk object.

                    ReleaseStgMedium( pStgmed );
                    }
                break;

            case TYMED_HGLOBAL:

                if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
                    {
                    NukeHandleAndReleasePunk( pStgmed );
                    }
                else
                    {
                    // Handle w/data: there is a side effect to clean up.
                    // For punk ==0, this will just release the data.
                    // For punk !=0, this will go to our CPunk object,
                    // release the data, and then call the original punk.

                    ReleaseStgMedium( pStgmed );
                    }
                break;

            case TYMED_MFPICT:

                if ( HGLOBAL_HANDLE_PASSING(*pFlags) )
                    {
                    NukeHandleAndReleasePunk( pStgmed );
                    }
                else if ( GDI_HANDLE_PASSING(*pFlags) )
                    {
                    if ( pStgmed->hGlobal )
                        GlobalFree( pStgmed->hGlobal );
                    NukeHandleAndReleasePunk( pStgmed );
                    }
                else
                    {
                    // Handle w/data: there is a side effect to clean up.
                    // For punk !=0, this will go to our CPunk object.

                    ReleaseStgMedium( pStgmed );
                    }
                break;

            default:
                RpcRaiseException( E_INVALIDARG );
                break;
            }
        }
}


//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserSize
//
//  Synopsis:   Sizes a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned long  __RPC_USER
FLAG_STGMEDIUM_UserSize(
    unsigned long * pFlags,
    unsigned long   Offset,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    if ( ! pFlagStgmed )
        return Offset;

    LENGTH_ALIGN( Offset, 3 );

    Offset += sizeof(long);
    Offset  = STGMEDIUM_UserSize( pFlags, Offset, & pFlagStgmed->Stgmed );

    return( Offset );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserMarshal
//
//  Synopsis:   Marshals a wrapper for stgmedium. Used in SetData.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
FLAG_STGMEDIUM_UserMarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    if ( ! pFlagStgmed )
        return pBuffer;

    ALIGN( pBuffer, 3 );

    // Flags: we need them when freeing in the client call_as routine

    pFlagStgmed->ContextFlags = *pFlags;

    *( PULONG_LV_CAST pBuffer)++ = *pFlags;
    *( PULONG_LV_CAST pBuffer)++ = pFlagStgmed->fPassOwnership;

    pBuffer = STGMEDIUM_UserMarshal( pFlags,
                                     pBuffer,
                                     & pFlagStgmed->Stgmed );

    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserUnmarshal
//
//  Synopsis:   Unmarshals a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

unsigned char __RPC_FAR * __RPC_USER
FLAG_STGMEDIUM_UserUnmarshal(
    unsigned long * pFlags,
    unsigned char * pBuffer,
    FLAG_STGMEDIUM* pFlagStgmed )
{
    ALIGN( pBuffer, 3 );

    // Flags and buffer marker

    pFlagStgmed->ContextFlags   = *( PULONG_LV_CAST pBuffer)++;

    // We need that in the Proxy, when we call the user free routine.

    pFlagStgmed->fPassOwnership = *( PULONG_LV_CAST pBuffer)++;
    pFlagStgmed->ContextFlags   = *pFlags;

    // We always unmarshal a FLAG_STGMEDIUM object.
    // The engine will always free the FLAG_STGMEDIUM object later.
    // Adjustments for passing the ownership are done within SetData_Stub.

    pBuffer = STGMEDIUM_UserUnmarshal( pFlags,
                                       pBuffer,
                                       & pFlagStgmed->Stgmed );
    return( pBuffer );
}

//+-------------------------------------------------------------------------
//
//  Function:   FLAG_STGMEDIUM_UserFree
//
//  Synopsis:   Freess a wrapper for stgmedium.
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

void __RPC_USER
FLAG_STGMEDIUM_UserFree(
    unsigned long * pFlags,
    FLAG_STGMEDIUM* pFlagsStgmed )
{
    if ( ! pFlagsStgmed->fPassOwnership )
        STGMEDIUM_UserFree( pFlags, & pFlagsStgmed->Stgmed );

    // else the callee is supposed to release the stg medium.
}


#if (DBG==1)
//+-------------------------------------------------------------------------
//
//  Function:   WdtpGetStgmedName
//
//  Synopsis:   Debug support
//
//  history:    May-95   Ryszardk      Created.
//
//--------------------------------------------------------------------------

char *
WdtpGetStgmedName( STGMEDIUM * pStgmed)

{
    char * Name;
    if ( pStgmed )
        {
        switch (pStgmed->tymed)
            {
            case TYMED_NULL:
                Name = "TYMED_NULL";
                break;
            case TYMED_MFPICT:
                Name = "TYMED_MFPICT";
                break;
            case TYMED_ENHMF:
                Name = "TYMED_ENHMF";
                break;
            case TYMED_GDI:
                Name = "TYMED_GDI";
                break;
            case TYMED_HGLOBAL:
                Name = "TYMED_HGLOBAL";
                break;
            case TYMED_FILE:
                Name = "TYMED_FILE";
                break;
            case TYMED_ISTREAM:
                Name = "TYMED_ISTREAM";
                break;
            case TYMED_ISTORAGE:
                Name = "TYMED_ISTORAGE";
                break;
            default:
                Name = "TYMED invalid";
                break;
            }
        return Name;
        }
    else
        return "STGMED * is null";
}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\oleprx32\proxy\transmit.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994.
//
//  File:       transmit.h
//
//  Contents:   Function prototypes for STGMEDIUM marshalling.
//
//  Functions:  STGMEDIUM_to_xmit
//              STGMEDIUM_from_xmit
//              STGMEDIUM_free_inst
//
//  History:    May-10-94   ShannonC    Created
//  History:    May-10-95   Ryszardk    wire_marshal changes
//
//--------------------------------------------------------------------------

#ifndef __TRANSMIT_H__
#define __TRANSMIT_H__

#if (DBG==1)

#include <debnot.h>

DECLARE_DEBUG(UserNdr)
//
#define UserNdrDebugOut(x)
#define UserNdrAssert(x)
#define UserNdrVerify(x)

//#define UNDR_FORCE   DEB_FORCE
#define UNDR_FORCE   0
#define UNDR_OUT1    0
#define UNDR_OUT4    0

EXTERN_C char *
WdtpGetStgmedName( STGMEDIUM * );

#else

#define UserNdrDebugOut(x) 
#define UserNdrAssert(x)  
#define UserNdrVerify(x)   

#define UNDR_FORCE   0
#define UNDR_OUT1    0
#define UNDR_OUT4    0

#endif

// Shortcut typedefs.

typedef unsigned char   uchar;
typedef unsigned short  ushort;
typedef unsigned long   ulong;
typedef unsigned int    uint;

#ifndef TRUE
#define TRUE    (1)
#define FALSE   (0)

typedef unsigned short BOOL;
#endif

#define ALIGN( pStuff, cAlign ) \
        pStuff = (unsigned char *)((ulong)((pStuff) + (cAlign)) & ~ (cAlign))

#define LENGTH_ALIGN( Length, cAlign ) \
            Length = (((Length) + (cAlign)) & ~ (cAlign))

#define PCHAR_LV_CAST   *(char __RPC_FAR * __RPC_FAR *)&
#define PSHORT_LV_CAST  *(short __RPC_FAR * __RPC_FAR *)&
#define PLONG_LV_CAST   *(long __RPC_FAR * __RPC_FAR *)&
#define PHYPER_LV_CAST  *(hyper __RPC_FAR * __RPC_FAR *)&

#define PUSHORT_LV_CAST  *(unsigned short __RPC_FAR * __RPC_FAR *)&
#define PULONG_LV_CAST   *(unsigned long __RPC_FAR * __RPC_FAR *)&

#define USER_MARSHAL_MARKER     0x72657355

// These are based on flags defined in wtypes.idl comming from the channel

#define INPROC_CALL( Flags) (USER_CALL_CTXT_MASK(Flags) == MSHCTX_INPROC)
#define REMOTE_CALL( Flags) ((USER_CALL_CTXT_MASK(Flags) == MSHCTX_DIFFERENTMACHINE) \
                          || (USER_CALL_CTXT_MASK(Flags) == MSHCTX_NOSHAREDMEM))

// There is a difference in the scope of handles, Daytona vs. Chicago.
// The following is an illustration of the notions of strict and lax passing.

// rpc call as defined by the flags above

// Daytona rules
//I------------I----------------I-----------------------------------I
//I   inproc   I  same machine  I  diff. machine (a.k.a "remote" )  I
//I------------I----------------------------------------------------I
//| HGLOBL h.p.|           HGLOBAL data passing                     |
//|------------|----------------------------------------------------|
//|  GDI h.p.  |             GDI data passing                       |
//|------------|----------------------------------------------------|

// Chicago rules
//I------------I----------------I-----------------------------------I
//I   inproc   I  same machine  I  diff. machine (a.k.a "remote" )  I
//I------------I----------------------------------------------------I
//| HGLOBL h.p.|           HGLOBAL data passing                     |
//|-----------------------------------------------------------------|
//|  GDI handle passing         |          GDI data passing         |
//|-----------------------------|-----------------------------------|

#define HGLOBAL_HANDLE_PASSING( Flags )      INPROC_CALL( Flags)
#define HGLOBAL_DATA_PASSING( Flags )     (! INPROC_CALL( Flags))

// On Chicago, some handles are valid between processes.

#if defined(_CHICAGO_)
#define GDI_HANDLE_PASSING( Flags )      (! REMOTE_CALL( Flags ))
#define GDI_DATA_PASSING( Flags )           REMOTE_CALL( Flags )
#else  
#define GDI_HANDLE_PASSING( Flags )         HGLOBAL_HANDLE_PASSING( Flags )
#define GDI_DATA_PASSING( Flags )           HGLOBAL_DATA_PASSING( Flags )
#endif

#define WDT_DATA_MARKER        WDT_REMOTE_CALL
#define WDT_HANDLE_MARKER      WDT_INPROC_CALL
#define IS_DATA_MARKER( dw )   (WDT_REMOTE_CALL == dw)

#define WdtpMemoryCopy(Destination, Source, Length) \
    RtlCopyMemory(Destination, Source, Length)
#define WdtpZeroMemory(Destination, Length) \
    RtlZeroMemory(Destination, Length)

#define WdtpAllocate(p,size)    \
    ((USER_MARSHAL_CB *)p)->pStubMsg->pfnAllocate( size )
#define WdtpFree(pf,ptr)    \
    ((USER_MARSHAL_CB *)pf)->pStubMsg->pfnFree( ptr )

EXTERN_C
void NukeHandleAndReleasePunk(
    STGMEDIUM * pStgmed );

#endif  // __TRANSMIT_H__



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF


!include      ..\..\..\daytona.inc

INCLUDES=     ;..;$(OLEBALLSDIR)\common;
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\daytona

UMTYPE=       windows
UMENTRY=      winmain
UMAPPL=
UMTEST=
UMLIBS=	      ..\..\..\oleprx32\uuid\daytona\$(O)\uuid.lib	   \
	      ..\..\..\common\daytona\$(O)\servers.lib	   \
	      $(OLEDIR)\common\daytona\$(O)\common.lib	   \
	      $(SDK_LIB_PATH)\uuid.lib	   \
	      $(SDK_LIB_PATH)\ole32.lib	   \
              $(SDK_LIB_PATH)\rpcrt4.lib       \
              $(SDK_LIB_PATH)\rpcns4.lib       \
              $(SDK_LIB_PATH)\mpr.lib          \
              $(SDK_LIB_PATH)\netapi32.lib     \
              $(SDK_LIB_PATH)\kernel32.lib     \
              $(SDK_LIB_PATH)\user32.lib       \
	      $(SDK_LIB_PATH)\advapi32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\balls\ballsrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:	srvmain.cxx
//
//  Contents:	This file contins the EXE entry points
//			WinMain
//
//  Classes:
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <ballscf.hxx>


//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:  
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    CBallClassFactory *pCF = new CBallClassFactory(NULL);

    int sc = SrvMain(hInstance, CLSID_Balls, REGCLS_MULTIPLEUSE,
		     TEXT("Balls Server"), pCF);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\chicago.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    David Plummer (davepl)   19-Mar-94

        Modifed by via awk to include global project include file
        and to wrap precompiled header line within a conditional
        that can be set in this include file.

    Donna Liu (DonnaLi) 19-Dec-1993

!ENDIF


!include      ..\..\..\chicago.inc

INCLUDES=     ;..;$(OLEBALLSDIR)\common;
INCLUDES=     $(INCLUDES);$(OLEUTESTDIR)\balls\oleprx32\chicago

UMTYPE=       windows
UMENTRY=      winmain
UMAPPL=
UMTEST=
UMLIBS=	      ..\..\..\oleprx32\uuid\chicago\$(O)\uuid.lib	   \
	      ..\..\..\common\chicago\$(O)\servers.lib	   \
	      $(OLEDIR)\common\chicago\$(O)\common.lib	   \
	      $(SDK_LIB_PATH)\uuid.lib	   \
	      $(SDK_LIB_PATH)\ole32.lib	   \
              $(SDK_LIB_PATH)\rpcrt4.lib       \
              $(SDK_LIB_PATH)\rpcns4.lib       \
              $(SDK_LIB_PATH)\mpr.lib          \
              $(SDK_LIB_PATH)\netapi32.lib     \
              $(SDK_LIB_PATH)\kernel32.lib     \
              $(SDK_LIB_PATH)\user32.lib       \
	      $(SDK_LIB_PATH)\advapi32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\distbind\db.cxx ===
//+-------------------------------------------------------------------
//
//  File:	mdi.cxx
//
//  Contents:	This file contins the DLL entry points
//			WinMain
//
//  Classes:
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <actcf.hxx>


//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:  
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    CActClassFactory *pCF = new CActClassFactory(CLSID_DistBind ,TRUE);

    int sc = SrvMain(hInstance, CLSID_DistBind, REGCLS_MULTIPLEUSE,
		     TEXT("DistBind Server"), pCF);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\olesrv\olesrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:	srvmain.cxx
//
//  Contents:	This file contins the EXE entry points
//			WinMain
//
//  Classes:
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <advbnd.hxx>

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:  
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    CAdvBndCF *pCF = new CAdvBndCF();

    int sc = SrvMain(hInstance, CLSID_AdvBnd, REGCLS_MULTIPLEUSE,
		     TEXT("Ole Server"), pCF);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\loops\loopsrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:	srvmain.cxx
//
//  Contents:	This file contins the EXE entry points
//			WinMain
//
//  Classes:
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <loopscf.hxx>

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:  
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    CLoopClassFactory *pCF = new CLoopClassFactory();

    int sc = SrvMain(hInstance, CLSID_Loop, REGCLS_SINGLEUSE,
		     TEXT("Loops Server"), pCF);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\cubes\cubesrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:	srvmain.cxx
//
//  Contents:	This file contins the EXE entry points
//			WinMain
//
//  Classes:
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <cubescf.hxx>

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:  
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    CCubesClassFactory *pCF = new CCubesClassFactory();

    int sc = SrvMain(hInstance, CLSID_Cubes, REGCLS_MULTIPLEUSE,
		     TEXT("Cubes Server"), pCF);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\mdi\mdi.cxx ===
//+-------------------------------------------------------------------
//
//  File:	mdi.cxx
//
//  Contents:	This file contins the DLL entry points
//			WinMain
//
//  Classes:
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <actcf.hxx>

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:  
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    CActClassFactory *pCF = new CActClassFactory(CLSID_TestMultipleUse ,TRUE);

    int sc = SrvMain(hInstance, CLSID_TestMultipleUse, REGCLS_MULTIPLEUSE,
		     TEXT("MDI Server"), pCF);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\qi\qisrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:	srvmain.cxx
//
//  Contents:	This file contins the EXE entry points
//
//  History:	28-Feb-96   Rickhi  Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <mixedcf.hxx>


extern "C" const GUID CLSID_QI;
extern "C" const GUID CLSID_QIHANDLER;

TCHAR *pszWindow[] = { TEXT("QI Server") };

STHREADINFO *gpThrdInfo = NULL;
ULONG	     gcThrds	= 0;

//+-------------------------------------------------------------------
//
//  Function:	MakeClassInfo
//
//  Synopsis:	fills in a SCLASSINFO structure
//
//  History:	28-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
HRESULT MakeClassInfo(REFCLSID rclsid, SCLASSINFO *pClsInfo)
{
    pClsInfo->clsid	= rclsid;
    pClsInfo->pCF	= (IClassFactory *) new CMixedClassFactory(rclsid);
    pClsInfo->dwCtx	= CLSCTX_LOCAL_SERVER;
    pClsInfo->dwClsReg	= REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED;
    pClsInfo->dwReg	= 0;

    return (pClsInfo->pCF != NULL) ? S_OK : E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------
//
//  Function:	RegisterSameThread
//
//  Synopsis:	Entry point. Creates the classinfo and enters the main
//		server loop.
//
//  History:	28-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
int WINAPI RegisterSameThread(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow,
    DWORD dwThreadModel)
{
    SCLASSINFO	ClsInfo[2];
    STHREADINFO	ThrdInfo;
    HRESULT	hr[2];

    hr[0] = MakeClassInfo(CLSID_QI,    &ClsInfo[0]);
    hr[1] = MakeClassInfo(CLSID_QIHANDLER, &ClsInfo[1]);

    ThrdInfo.hEventRun	= CreateEvent(NULL, FALSE, FALSE, NULL);
    ThrdInfo.hEventDone = CreateEvent(NULL, FALSE, FALSE, NULL);
    ThrdInfo.hInstance	= hInstance;
    ThrdInfo.pszWindow	= pszWindow[0];
    ThrdInfo.dwFlags	= dwThreadModel;
    ThrdInfo.cClasses	= 2;
    ThrdInfo.pClsInfo	= &ClsInfo[0];

    // this thread is the one that should call resume.
    ThrdInfo.dwFlags   |= SRVF_REGISTER_RESUME;
    ThrdInfo.dwTid	= GetCurrentThreadId();

    // stuff the thrd pointers and count into globals so we can
    // wake the threads up whenever 1 single thread exits.
    gpThrdInfo = &ThrdInfo;
    gcThrds    = 1;

    hr[0] = SrvMain2(&ThrdInfo);

    return hr[0];
}

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:	Entry point. Creates the classinfo and enters the main
//		server loop.
//
//  History:	28-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{

    return RegisterSameThread(hInstance, hPrevInstance, lpCmdLine, nCmdShow,
				  SRVF_THREADMODEL_APARTMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\mixed\mixedsrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:	srvmain.cxx
//
//  Contents:	This file contins the EXE entry points
//
//  History:	28-Feb-96   Rickhi  Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <mixedcf.hxx>


extern "C" const GUID CLSID_QI;
extern "C" const GUID CLSID_Balls;
extern "C" const GUID CLSID_Loop;
extern "C" const GUID CLSID_Cubes;

int WINAPI RegisterSameThread(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow,
    DWORD dwThreadModel);

int WINAPI RegisterDifferentThreads(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow,
    DWORD dwThreadModel);


void RunServerThread(STHREADINFO *pThrdInfo);
DWORD _stdcall ServerThread(void *param);
void WakeupAllThreads();


TCHAR *pszWindow[] = { TEXT("QI Server"),
		       TEXT("Balls Server"),
		       TEXT("Cubes Server"),
		       TEXT("Loops Server")};


STHREADINFO *gpThrdInfo = NULL;
ULONG	     gcThrds	= 0;
BOOL	     gfWokenUpAllThreads = FALSE;


//+-------------------------------------------------------------------
//
//  Function:	MakeClassInfo
//
//  Synopsis:	fills in a SCLASSINFO structure
//
//  History:	28-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
HRESULT MakeClassInfo(REFCLSID rclsid, SCLASSINFO *pClsInfo)
{
    pClsInfo->clsid	= rclsid;
    pClsInfo->pCF	= (IClassFactory *) new CMixedClassFactory(rclsid);
    pClsInfo->dwCtx	= CLSCTX_LOCAL_SERVER;
    pClsInfo->dwClsReg	= REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED;
    pClsInfo->dwReg	= 0;

    return (pClsInfo->pCF != NULL) ? S_OK : E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:	Entry point. Creates the classinfo and enters the main
//		server loop.
//
//  History:	28-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    if (lpCmdLine == NULL)
    {
	// ShowHelp();
	return -1;
    }

    if (!(strncmp(lpCmdLine, "ApartmentSameThread", 19)))
    {
	return RegisterSameThread(hInstance, hPrevInstance, lpCmdLine, nCmdShow,
				  SRVF_THREADMODEL_APARTMENT);
    }
    else if (!(strncmp(lpCmdLine, "FreeSameThread", 14)))
    {
	return RegisterSameThread(hInstance, hPrevInstance, lpCmdLine, nCmdShow,
				  SRVF_THREADMODEL_MULTI);
    }
    else if (!(strncmp(lpCmdLine, "ApartmentDifferentThread", 24)))
    {
	return RegisterDifferentThreads(hInstance, hPrevInstance, lpCmdLine, nCmdShow,
				  SRVF_THREADMODEL_APARTMENT);
    }
    else if (!(strncmp(lpCmdLine, "FreeDifferentThread", 24)))
    {
	return RegisterDifferentThreads(hInstance, hPrevInstance, lpCmdLine, nCmdShow,
				  SRVF_THREADMODEL_MULTI);

    }

    return -1;
}

//+-------------------------------------------------------------------
//
//  Function:	RegisterSameThread
//
//  Synopsis:	Entry point. Creates the classinfo and enters the main
//		server loop.
//
//  History:	28-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
int WINAPI RegisterSameThread(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow,
    DWORD dwThreadModel)
{
    SCLASSINFO	ClsInfo[4];
    STHREADINFO	ThrdInfo;
    HRESULT	hr[4];

    hr[0] = MakeClassInfo(CLSID_QI,    &ClsInfo[0]);
    hr[1] = MakeClassInfo(CLSID_Balls, &ClsInfo[1]);
    hr[2] = MakeClassInfo(CLSID_Cubes, &ClsInfo[2]);
    hr[3] = MakeClassInfo(CLSID_Loop,  &ClsInfo[3]);

    ThrdInfo.hEventRun	= CreateEvent(NULL, FALSE, FALSE, NULL);
    ThrdInfo.hEventDone = CreateEvent(NULL, FALSE, FALSE, NULL);
    ThrdInfo.hInstance	= hInstance;
    ThrdInfo.pszWindow	= pszWindow[0];
    ThrdInfo.dwFlags	= dwThreadModel;
    ThrdInfo.cClasses	= 4;
    ThrdInfo.pClsInfo	= &ClsInfo[0];

    // this thread is the one that should call resume.
    ThrdInfo.dwFlags   |= SRVF_REGISTER_RESUME;
    ThrdInfo.dwTid	= GetCurrentThreadId();

    // stuff the thrd pointers and count into globals so we can
    // wake the threads up whenever 1 single thread exits.
    gpThrdInfo = &ThrdInfo;
    gcThrds    = 1;

    hr[0] = SrvMain2(&ThrdInfo);

    return hr[0];
}


//+-------------------------------------------------------------------
//
//  Function:	RegisterDifferentThreads
//
//  Synopsis:	Entry point. Creates the classinfo and enters the main
//		server loop.
//
//  History:	28-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
int WINAPI RegisterDifferentThreads(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow,
    DWORD dwThreadModel)
{
    SCLASSINFO	ClsInfo[4];
    STHREADINFO	ThrdInfo[4];
    HRESULT	hr[4];

    hr[0] = MakeClassInfo(CLSID_QI,    &ClsInfo[0]);
    hr[1] = MakeClassInfo(CLSID_Balls, &ClsInfo[1]);
    hr[2] = MakeClassInfo(CLSID_Cubes, &ClsInfo[2]);
    hr[3] = MakeClassInfo(CLSID_Loop,  &ClsInfo[3]);

    for (int i=0; i<4; i++)
    {
	if (SUCCEEDED(hr[i]))
	{
	    ThrdInfo[i].hEventRun  = CreateEvent(NULL, FALSE, FALSE, NULL);
	    ThrdInfo[i].hEventDone = CreateEvent(NULL, FALSE, FALSE, NULL);
	    ThrdInfo[i].hInstance  = hInstance;
	    ThrdInfo[i].pszWindow  = pszWindow[i];
	    ThrdInfo[i].dwFlags	   = dwThreadModel;
	    ThrdInfo[i].cClasses   = 1;
	    ThrdInfo[i].pClsInfo   = &ClsInfo[i];

	    if (i > 0)
	    {
		// run the thread and wait for it signal it's ready
		RunServerThread(&ThrdInfo[i]);
		WaitForSingleObject(ThrdInfo[i].hEventRun, 0xffffffff);
		CloseHandle(ThrdInfo[i].hEventRun);
	    }
	}
    }

    // this thread is the one that should call resume.
    ThrdInfo[0].dwFlags |= SRVF_REGISTER_RESUME;
    ThrdInfo[0].dwTid	 = GetCurrentThreadId();

    // stuff the thrd pointers and count into globals so we can
    // wake the threads up whenever 1 single thread exits.
    gpThrdInfo = &ThrdInfo[0];
    gcThrds = 4;


    hr[0] = SrvMain2(&ThrdInfo[0]);
    WakeupAllThreads();

    for (i=0; i<4; i++)
    {
	if (SUCCEEDED(hr[i]))
	{
	    // wait for other thread to complete before exiting.
	    WaitForSingleObject(ThrdInfo[i].hEventDone, 0xffffffff);
	    CloseHandle(ThrdInfo[i].hEventDone);
	}
    }

    return hr[0];
}

//+-------------------------------------------------------------------
//
//  Function:	WakeupAllThreads
//
//  Synopsis:	Wakes up all the other threads in the process when
//		one thread decides to exit.
//
//  History:	28-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
void WakeupAllThreads()
{
    if (gfWokenUpAllThreads)
	return;

    gfWokenUpAllThreads = TRUE;
    STHREADINFO *pThrdInfo = gpThrdInfo;

    for (ULONG i=0; i<gcThrds; i++, pThrdInfo++)
    {
	PostThreadMessage(pThrdInfo->dwTid, WM_QUIT, 0, 0);
    }
}

//+-------------------------------------------------------------------
//
//  Function:	ServerThread
//
//  Synopsis:	Thread Entry point. Registers a class and waits for calls
//		on it.
//
//  History:	28-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
DWORD _stdcall ServerThread(void *param)
{
    STHREADINFO *pThrdInfo = (STHREADINFO *)param;

    HRESULT hr = SrvMain2(pThrdInfo);

    // wake up the other threads.
    WakeupAllThreads();

    return hr;
}

//+-------------------------------------------------------------------
//
//  Function:	RunServerThread
//
//  Synopsis:	Spins up a thread to act as a class server.
//
//  History:	28-Feb-96   Rickhi  Created
//
//--------------------------------------------------------------------
void RunServerThread(STHREADINFO *pThrdInfo)
{
    HANDLE hThrd = CreateThread(NULL, 0, ServerThread, pThrdInfo,
				0, &(pThrdInfo->dwTid));
    if (hThrd)
    {
	CloseHandle(hThrd);
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\rpctst\rpcsrv.cxx ===
//+-------------------------------------------------------------------
//
//  File:	srvmain.cxx
//
//  Contents:	This file contins the EXE entry points
//			WinMain
//
//  Classes:
//
//  History:	30-Nov-92      Rickhi	     Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <rpccf.hxx>
#include    <stream.hxx>
#include    <rpctst.h>	    // IID_IRpcTest

extern IUnknown *gpPunk;

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:	Entry point to EXE
//
//  Arguments:  
//
//  Returns:    TRUE
//
//  History:	21-Nov-92  Rickhi	Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    CRpcTestClassFactory *pCF = new CRpcTestClassFactory();

    // create an instance, then marshal that instance TABLE_STRONG
    // and LONG_FORM into a stream.

    IRpcTest *pUnk = NULL;
    HRESULT hr = pCF->CreateInstance(NULL, IID_IRpcTest, (void **)&pUnk);
    if (FAILED(hr))
    {
	return hr;
    }

    hr = E_OUTOFMEMORY;
    IStream *pStm = (IStream *) new CStreamOnFile(TEXT("c:\\rickrpc.stm"),
						  hr, FALSE);

    if (FAILED(hr))
    {
	return hr;
    }

    DWORD dwThreadMode;
    TCHAR buffer[80];
    int len;

    len = GetProfileString( TEXT("OleSrv"),
			    TEXT("ThreadMode"),
			    TEXT("MultiThreaded"),
			    buffer,
			    sizeof(buffer) );

#ifdef THREADING_SUPPORT
    if (lstrcmp(buffer, TEXT("ApartmentThreaded")) == 0)
	dwThreadMode = COINIT_APARTMENTTHREADED;
    else
	dwThreadMode = COINIT_MULTITHREADED;

    hr = OleInitializeEx(NULL, dwThreadMode);
#else
    hr = OleInitialize(NULL);
#endif

    hr = CoMarshalInterface(pStm, IID_IRpcTest, pUnk, 0, NULL,
			    MSHLFLAGS_TABLESTRONG);

    if (FAILED(hr))
    {
	return hr;
    }

    // close the stream
    pStm->Release();

    hr = pCF->CreateInstance(NULL, IID_IUnknown, (void **)&gpPunk);
    if (FAILED(hr))
    {
	return hr;
    }

    int sc = SrvMain(hInstance, CLSID_RpcTest, REGCLS_SINGLEUSE,
		      TEXT("IRpcTest Server"), pCF);

    OleUninitialize();
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\sdi\sdi.cxx ===
//+-------------------------------------------------------------------
//
//  File:	sdi.cxx
//
//  Contents:	This file contins the DLL entry points
//			WinMain
//
//  Classes:
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------
#include    <common.h>
#include    <actcf.hxx>

//+-------------------------------------------------------------------
//
//  Function:	WinMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:  
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
int WINAPI WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow)
{
    CActClassFactory *pCF = new CActClassFactory(CLSID_TestSingleUse ,TRUE);

    int sc = SrvMain(hInstance, CLSID_TestSingleUse, REGCLS_SINGLEUSE,
		      TEXT("SDI Server"), pCF);

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\testsrv\testsrv.cxx ===
//+-------------------------------------------------------------------
//  File:       testsrv.cxx
//
//  Contents:
//
//  Classes:    CBasicSrvCF - IUnknown IClassFactory
//              CBasicSrv   - IUnknown IPersist IPersistFile IParseDisplayName
//
//  Notes:      This code is written based on OLE2.0 code. Therefore
//              all error codes, defines etc are OLE style rather than Cairo
//
//  History:    24-Nov-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include <csrvapp.hxx>
#include <embed.hxx>
#include <stdio.h>

// BUGBUG - memory allocation hacks need these so new and delete don't
//   break us
//
#include <malloc.h>
#include <dos.h>

#define IDM_DEBUG 0x100

extern "C" LRESULT FAR PASCAL MainWndProc(HWND, UINT, WPARAM, LPARAM);
void ReportMessage(HWND, WORD);

// This is global because we're still in $%E#$#K 16-bit world
HWND g_hwndMain = NULL;

// Note constructor cannot fail
CTestServerApp tsaMain;


//+--------------------------------------------------------------
//  Function:   WinMain
//
//  Synopsis:   Initializes application and controls message pump.
//
//  Returns:    Exits with exit code 0 if success, non-zero otherwise
//
//  History:    25-Nov-92   DeanE   Created
//---------------------------------------------------------------
int PASCAL WinMain(
	HINSTANCE hInstance,
	HINSTANCE hPrevInstance,
        LPSTR  lpszCmdline,
        int    nCmdShow)
{
    static TCHAR szAppName[] = TEXT("OleServer");
    MSG         msg;
    WNDCLASS    wndclass;

    if (!hPrevInstance)
    {
        wndclass.style         = CS_HREDRAW | CS_VREDRAW;
        wndclass.lpfnWndProc   = MainWndProc;
        wndclass.cbClsExtra    = 0;
        wndclass.cbWndExtra    = 0;
        wndclass.hInstance     = hInstance;
        wndclass.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(125));
        wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wndclass.hbrBackground = (HBRUSH) GetStockObject(BLACK_BRUSH);
        wndclass.lpszMenuName  = NULL;
        wndclass.lpszClassName = szAppName;

        if (0==RegisterClass(&wndclass))
        {
            // Error! Clean up and exit
            return(LOG_ABORT);
        }
    }

    g_hwndMain	 = CreateWindow(
                       szAppName,
		       TEXT("OLE Server"),
                       WS_OVERLAPPEDWINDOW | WS_VSCROLL,
                       GetSystemMetrics(SM_CXSCREEN)/12,      // Init X pos
                       GetSystemMetrics(SM_CYSCREEN)/12,      // Init Y pos
                       GetSystemMetrics(SM_CXSCREEN)*2/3,     // width
                       GetSystemMetrics(SM_CYSCREEN)*2/3,     // height
                       NULL,
                       NULL,
                       hInstance,
		       NULL);

    if (NULL==g_hwndMain)
    {
        // Error! Clean up and exit
        return(LOG_ABORT);
    }

    // Add debug option to system menu
    HMENU hmenu = GetSystemMenu(g_hwndMain, FALSE);

    AppendMenu(hmenu, MF_SEPARATOR, 0, NULL);
    AppendMenu(hmenu, MF_STRING | MF_ENABLED, IDM_DEBUG, TEXT("Debug"));


    // Initialize Application
    if (S_OK != tsaMain.InitApp(lpszCmdline))
    {
        tsaMain.CloseApp();
        return(LOG_ABORT);
    }

    if (tsaMain.GetEmbeddedFlag())
    {
        // We're running as an embedded app
        // Don't show the main window unless we're instructed to do so
        // BUGBUG - In-place editing is NYI
	ShowWindow(g_hwndMain, SW_SHOWMINIMIZED);
    }
    else
    {
        // We are not running as an embedded app - show the main window
        ShowWindow(g_hwndMain, nCmdShow);
    }

    UpdateWindow(g_hwndMain);


    // message loop
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    // Clean up and exit
    // BUGBUG - check return code?
    tsaMain.CloseApp();

    return(0);
}


//+--------------------------------------------------------------
// Function:    MainWndProc
//
// Synopsis:    Callback for the server window
//
// Returns:     Varies dependent on message received.
//
// History:     25-Nov-92   DeanE   Created
//---------------------------------------------------------------
extern "C" LRESULT FAR PASCAL MainWndProc(
        HWND   hwnd,
        UINT   wMsg,
        WPARAM wParam,
        LPARAM lParam)
{
    switch(wMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
	return(0);

    case WM_USER:
	DestroyWindow(hwnd);
	return 0;

    case WM_SYSCOMMAND:

	if (wParam == IDM_DEBUG)
	{
	    // Request for a debug breakpoint!
	    DebugBreak();
	}

    default:
	break;
    }

    return(DefWindowProc(hwnd, wMsg, wParam, lParam));
}


void ReportMessage(HWND hwnd, WORD wParam)
{
    TCHAR szBuffer[MAX_PATH];
    szBuffer[0] = '\0';

    switch (wParam)
    {
    case MB_SHOWVERB:
	lstrcpy(szBuffer, TEXT("OLEIVERB_SHOW Received"));
        break;

    case MB_PRIMVERB:
	lstrcpy(szBuffer, TEXT("OLEIVERB_PRIMARY Received"));
        break;

    default:
	lstrcpy(szBuffer, TEXT("Unrecognized ReportMessage code"));
        break;
    }

    MessageBox(hwnd, szBuffer, TEXT("OLE Server"), MB_ICONINFORMATION | MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cachetst\davedbg.h ===
//+----------------------------------------------------------------------------
//
//      File:
//              davedbg.h
//
//      Contents:
//              A debug trace class
//
//      Classes:
//              TraceLog
//
//      History:
//              04-Sep-94    davepl    Created
//
//-----------------------------------------------------------------------------

const ULONG MAX_ARGS = 20;
const ULONG MAX_BUF  = 255;

typedef enum tagGROUPSET
{
    GS_CACHE    = 0x000000001
} GROUPSET;
    
typedef enum tagDVARTYPE
{
    NO_TYPE     = 0x0000,
    LONG_TYPE   = 0x0001,
    SHORT_TYPE  = 0x0002,
    INT_TYPE    = 0x0004,
    CHAR_TYPE   = 0x0008,
    STRING_TYPE = 0x0010,
    FLOAT_TYPE  = 0x0020,
    COMMA_TYPE  = 0x0040,
    MSG_TYPE    = 0x0080,
    PTR_TYPE    = 0x0100,
    HEXINT_TYPE = 0x0200
} DVARTYPE;

inline DVARTYPE operator |= (DVARTYPE & vtORON, const DVARTYPE vtORBY)
{
    return (vtORON = (DVARTYPE)((int) vtORON | (int) vtORBY));
}

typedef enum tagVERBOSITY
{
    VB_SILENT   = 0x0000,
    VB_MINIMAL  = 0x0001,
    VB_MODERATE = 0x0002,
    VB_MAXIMUM  = 0x0004
} VERBOSITY;

class TraceLog
{
public:

    TraceLog (void *, char *, GROUPSET, VERBOSITY);
    ~TraceLog();                                  

    void OnEntry();    
    void OnEntry(char * pszFormat, ...);    
    void OnExit (const char * pszFormat, ...);
    

private:

    char m_pszFormat[ MAX_BUF ];
    void *m_aPtr[ MAX_ARGS ];
    BYTE m_cArgs;
    BOOL m_fShouldDisplay;
    void *m_pvThat;
    char m_pszFunction[MAX_BUF];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cachetst\enum.cpp ===
//+----------------------------------------------------------------------------
//
//      File:
//              enum.cpp
//
//      Contents:
//              Enumerator test methods for the cache unit test
//
//      History:
//
//              04-Sep-94       davepl  Created
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+----------------------------------------------------------------------------
//
//      Member:		TestInstance::EnumeratorTest
//
//      Synopsis:	Performs various tests on the cache enumerator
//
//      Arguments:	(void)
//
//      Returns:	HRESULT
//
//      Notes:  General sequence of events is as follows:
//
//	- Add cache nodes for EMF, DIB (and BMP) and MF
//	- Try to add BMP node (expecting failure)
//	- Create a cache enumerator
//	- Run generic enumerator tests on that cache enumerator
//	- Reset the enumerator
//	- Grab the 4 nodes added above in a single Next()
//	- Verify that the correct 4 nodes were returned
//	- Reset the enumerator
//	- Uncache the MF node
//	- Grab the 3 remaining nodes
//	- Verify that the correct 3 nodes were returned
//	- Reset the enumerator
//	- Skip 1 node
//	- Uncache the DIB (and BMP) node
//	- Try to uncache the BMP node (expecting failure)
//	- Try to skip (expecting failure, as BMP node has disappeared midflight)
//	- Uncache the EMF node (cache should now be empty)
//	- Reset and Skip (expecting failure to verify the cache is empty)
//	- Release the enumerator
//
//      History:	23-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------

HRESULT TestInstance::EnumeratorTest()
{
    HRESULT hr;
    DWORD dwEMFCon, dwBMPCon, dwDIBCon, dwMFCon;

    TraceLog Log(this, "TestInstance::EnumeratorTest", GS_CACHE, VB_MINIMAL);
    Log.OnEntry ();
    Log.OnExit  (" ( %X )\n", &hr);

    SetCurrentState(TESTING_ENUMERATOR);
    //
    // Cache  DIB, MF, EMF, and BITMAP nodes
    //

    hr = AddEMFCacheNode(&dwEMFCon);

    if (S_OK == hr)
    {
    	hr = AddDIBCacheNode(&dwDIBCon);
    }

    if (S_OK == hr)
    {
        hr = AddMFCacheNode(&dwMFCon);
    }

    if (S_OK == hr)
    {
        hr = AddBITMAPCacheNode(&dwBMPCon);

    	//
    	// We expect that caching a Bitmap node when a DIB node has
    	// already been cached should return CACHE_S_SAMECACHE, so
    	// we transform that into S_OK
    	//

    	if (CACHE_S_SAMECACHE == hr)
    	{
    	    hr = S_OK;
    	}
    }

    //
    // Get an enumerator on the cache
    //

    LPENUMSTATDATA pEsd;	
    if (S_OK == hr)
    {
    	hr = m_pOleCache->EnumCache(&pEsd);
    }

    //
    // Perform generic emnumerator testing
    //

    if (S_OK == hr)
    {
	hr = TestEnumerator((void *) pEsd, sizeof(STATDATA), 4, NULL, NULL,NULL);
    }

    //
    // Reset the enumerator before our specific tests
    //

    if (S_OK == hr)
    {
    	hr = pEsd->Reset();
    }


    ULONG cFetched;		// Count of elements enumd
    STATDATA rgStat[4];		// Array of STATDATA to enum into

    //
    // Get an enumeration of the expected 4 nodes, then check to
    // ensure that all four match (at a basic level) the four
    // we expect to find
    //

    if (S_OK == hr)
    {
    	hr = pEsd->Next(4, rgStat, &cFetched);
    }

    STATDATA sdEMF, sdMF, sdBMP, sdDIB;

    // These are the STATDATAs we expect to find

    sdEMF.formatetc.cfFormat = CF_ENHMETAFILE;
    sdEMF.dwConnection       = dwEMFCon;
    sdMF.formatetc.cfFormat  = CF_METAFILEPICT;
    sdMF.dwConnection	     = dwMFCon;
    sdDIB.formatetc.cfFormat = CF_BITMAP;
    sdDIB.dwConnection       = dwBMPCon;
    sdBMP.formatetc.cfFormat = CF_DIB;
    sdBMP.dwConnection       = dwBMPCon;

    //
    // Verify that each of our STATDATAs came back
    // from the enumeration
    //

    if (S_OK == hr)
    {
	if (S_FALSE == EltIsInArray(sdDIB, rgStat, 4))
	{
	    hr = E_FAIL;
	}
	else if (S_FALSE == EltIsInArray(sdBMP, rgStat, 4))
	{
	    hr = E_FAIL;
	}
	else if (S_FALSE == EltIsInArray(sdEMF, rgStat, 4))
	{
	    hr = E_FAIL;
	}
	else if (S_FALSE == EltIsInArray(sdMF, rgStat, 4))
	{
	    hr = E_FAIL;
	}
    }

    //
    // Reset the enumerator
    //

    if (S_OK == hr)
    {
    	hr = pEsd->Reset();
    }

    //
    // Remove the EMF node, leaving only MF, DIB and Bitmap
    //

    if (S_OK == hr)
    {
    	hr = m_pOleCache->Uncache(dwMFCon);
    }

    //
    // Get an enumeration of the expected 3 nodes, then check to
    // ensure that the DIB and Bitmap nodes are there
    //

    if (S_OK == hr)
    {
    	hr = pEsd->Next(3, rgStat, &cFetched);
    }

    //
    // Verify that each of our STATDATAs came back
    // from the enumeration.
    //

    if (S_OK == hr)
    {
	if (S_FALSE == EltIsInArray(sdDIB, rgStat, 3))
	{
	    hr = E_FAIL;
	}
	else if (S_FALSE == EltIsInArray(sdBMP, rgStat, 3))
	{
	    hr = E_FAIL;
	}
	else if (S_FALSE == EltIsInArray(sdEMF, rgStat, 3))
	{
	    hr = E_FAIL;
	}
    }

    //
    // Reset and Skip one node.  WARNING: We assume that the EMF
    // node is the first on to be enum'd.  This is NOT valid, but
    // is based on knowledge of how the cache is implemented, and
    // is our only way of testing this...
    //

    if (S_OK == hr)
    {
    	hr = pEsd->Reset();
    }

    if (S_OK == hr)
    {
    	hr = pEsd->Skip(1);
    }
	
    //
    // What we expect at this point:	EMF
    //					DIB  <---
    //					BMP
    //
    //
    // If we kill the DIB or BMP node, both should disappear, and Next()
    // must fail (even though we can't assume order, we know that DIB
    // and BMP are never enum'd out of order, such as DIB-EMF-DIB
    //

    if (S_OK == hr)
    {
    	hr = m_pOleCache->Uncache(dwDIBCon);
    }

    // Since we have uncached the DIB node, the BITMAP node should have
    // been automatically uncached as well.  First we ensure that we are
    // unable to uncache the BITMAP node...

    if (S_OK == hr)
    {
    	hr = m_pOleCache->Uncache(dwBMPCon);

	// This _should_ have failed, so adjust the error code
		
	hr = MassageErrorCode(OLE_E_NOCONNECTION, hr);
    }

    //
    // Now try to skip; the next node automatically disappeared,
    // so it should fail
    //

    if (S_OK == hr)
    {
    	hr = pEsd->Skip(1);

	// The above _should_ fail
		
	hr = MassageErrorCode(S_FALSE, hr);
    }

    //
    // The EMF node should be the only one remaining, so uncache it
    // to ensure that we leave the cache as empty as we found it.
    //


    if (S_OK == hr)
    {
    	hr = m_pOleCache->Uncache(dwEMFCon);
    }

    //
    // Verify that the cache is empty
    //

    if (S_OK == hr)
    {
    	hr = pEsd->Reset();
	if (hr == S_OK)
	{
	    hr = pEsd->Skip(1);
	    hr = MassageErrorCode(S_FALSE, hr);
	}
    }

    //
    // Release the enumerator
    //

    pEsd->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\balls\srv\testsrv\csrvapp.cxx ===
//+-------------------------------------------------------------------
//  File:       csrvapp.cxx
//
//  Contents:   Implementation of CTestServerApp
//
//  Classes:    CTestServerApp
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------------
#pragma optimize("",off)
#include <common.h>
#include <csrvapp.hxx>
#include <except.hxx>
#include <embed.hxx>

void ProcessCmdLine(LPSTR, BOOL *);

// Used to send a quit message
extern HWND g_hwndMain;

extern "C" const GUID CLSID_TestEmbed;


//+--------------------------------------------------------------
//  Function:   CTestServerApp::CTestServerApp
//
//  Synopsis:   Constructor - initialize members
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
CTestServerApp::CTestServerApp()
{
    _pteClassFactory = NULL;
    _dwRegId         = 0;
    _fRegistered     = FALSE;
    _fInitialized    = FALSE;
    _fEmbedded	     = TRUE;
    _cEmbeddedObjs   = 0;
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::~CTestServerApp
//
//  Synopsis:   Insure pointers are free - note this is mainly for
//              error-checking.
//
//  Parameters: None
//
//  Returns:    None
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
CTestServerApp::~CTestServerApp()
{
    delete _pteClassFactory;
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::InitApp
//
//  Synopsis:   Initialize this instance of the app.
//
//  Parameters: [lpszCmdline] - Command line of the application.
//
//  Returns:    S_OK if everything was initialized, or an error if not.
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      If this does not return, the CloseApp method should
//              still be called for proper cleanup.
//---------------------------------------------------------------
SCODE CTestServerApp::InitApp(LPSTR lpszCmdline)
{
    SCODE sc;

    // Check OLE version running
    // BUGBUG - NYI by OLE
    //   Bail out if we are not running with an acceptable version of OLE

    // Process Command Line arguments
    ProcessCmdLine(lpszCmdline, &_fEmbedded);

    // Initialize OLE
    // Look up the thread mode from the win.ini file.
    DWORD thread_mode;
    TCHAR buffer[80];
    int len;

    len = GetProfileString( TEXT("TestSrv"),
                            TEXT("ThreadMode"),
                            TEXT("MultiThreaded"),
                            buffer,
			    sizeof(buffer) / sizeof(TCHAR));

    if (lstrcmp(buffer, TEXT("ApartmentThreaded")) == 0)
    {
	thread_mode = COINIT_APARTMENTTHREADED;
	sc = CoInitialize(NULL);
    }
    else
    {
#ifdef THREADING_SUPPORT
	thread_mode = COINIT_MULTITHREADED;
	sc = CoInitializeEx(NULL, thread_mode);
#else
	// multi-threading not supported
	sc = E_INVALIDARG;
#endif
    }

    if (S_OK == sc)
    {
        _fInitialized = TRUE;
    }
    else
    {
        return(sc);
    }

    // Create the applications class factory - note that we have to free
    //   at a later time
    _pteClassFactory = CTestEmbedCF::Create(this);
    if (NULL == _pteClassFactory)
    {
        return(E_ABORT);
    }

    // Register the class with OLE
    sc = CoRegisterClassObject(
           CLSID_TestEmbed,
           _pteClassFactory,
           CLSCTX_LOCAL_SERVER,
	   REGCLS_MULTIPLEUSE,
           &_dwRegId);
    if (S_OK == sc)
    {
        _fRegistered = TRUE;
    }

    return(sc);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::CloseApp
//
//  Synopsis:   Clean up resources this instance of the app is using.
//
//  Parameters: None
//
//  Returns:    S_OK if everything was cleaned up, or an error if not.
//
//  History:    17-Dec-92   DeanE   Created
//---------------------------------------------------------------
SCODE CTestServerApp::CloseApp()
{
    // Revoke the class object, if registered
    if (TRUE == _fRegistered)
    {
        CoRevokeClassObject(_dwRegId);
    }

    // Release this apps class factory, and insure the returned count is 0
    if (0 == _pteClassFactory->Release())
    {
        _pteClassFactory = NULL;
    }
    else
    {
        // BUGBUG - Log error
    }

    // Uninitialize OLE only if OleInitialize succeeded
    if (TRUE == _fInitialized)
    {
	CoUninitialize();
    }
    return(S_OK);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::GetEmbeddedFlag
//
//  Synopsis:   Returns TRUE if app was started for an embedded object,
//              FALSE if standalone.
//
//  Parameters: None
//
//  Returns:    BOOL (_fEmbedded)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
CTestServerApp::GetEmbeddedFlag()
{
    return(_fEmbedded);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::IncEmbeddedCount
//
//  Synopsis:   Increments the count of embedded objects the server
//              has open.
//
//  Parameters: None
//
//  Returns:    ULONG (_cEmbeddedObjs)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
ULONG CTestServerApp::IncEmbeddedCount()
{
    return(++_cEmbeddedObjs);
}


//+--------------------------------------------------------------
//  Function:   CTestServerApp::DecEmbeddedCount
//
//  Synopsis:   Decrements the count of embedded objects the server
//              has open.  If 0 are left and we were running for an
//              embedded object(s), shut down.
//
//  Parameters: None
//
//  Returns:    ULONG (_cEmbeddedObjs)
//
//  History:    17-Dec-92   DeanE   Created
//
//  Notes:      BUGBUG - This should be an inline method
//---------------------------------------------------------------
ULONG CTestServerApp::DecEmbeddedCount()
{
    if ((0 == --_cEmbeddedObjs) && _fEmbedded)
    {
	SendMessage(g_hwndMain, WM_USER, 0xFFFFFFFF, 0xFFFFFFFF);
    }

    return(_cEmbeddedObjs);
}


//+--------------------------------------------------------------
// Function:    ProcessCmdline
//
// Synopsis:    Checks the cmd line parameters, in particular for
//              '/Embedding' or '-Embedding'.
//
// Parameters:  [lpszCmdLine] - Command line buffer.
//              [pfEmbedded]  - Flag should be set to true if we get
//                              the '/Embedding' switch.
//
// Returns:     void
//
// History:	25-Nov-92   DeanE   Created
//
// Notes:	Only two valid commandlines for this program:
//		(1) -Embedding when started by OLE or (2) Null
//		string if started from the command line.
//---------------------------------------------------------------
void ProcessCmdLine(LPSTR lpszCmdline, BOOL *pfEmbedded)
{
    if (lpszCmdline[0] == 0)
    {
	*pfEmbedded = FALSE;
	return;
    }

    if (strcmp(lpszCmdline, "-Embedding") == 0)
    {
	*pfEmbedded = TRUE;
	return;
    }

    *pfEmbedded = FALSE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cachetst\bmpfile.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       bmpfile.cxx
//
//  Contents:   CBitmapFile implementation
//
//  Classes:
//
//  Functions:
//
//  History:    4-23-94   KirtD   Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::CBitmapFile
//
//  Synopsis:   Constructor
//
//  Arguments:  (none)
//
//  Returns:    nothing
//
//  History:    4-23-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBitmapFile::CBitmapFile ()
{
     //
     // Initialize private members
     //

     //
     // The name
     //

     _pszBitmapFile[0] = '\0';
     _cBitmapFile = 0;

     //
     // The bitmap information
     //

     _cbi = 0;
     _pbi = NULL;

     //
     // The bits
     //

     _cbData = 0;
     _pbData = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::~CBitmapFile
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    nothing
//
//  History:    4-23-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
CBitmapFile::~CBitmapFile ()
{
     //
     // Delete any possibly allocated things
     //

     delete _pbi;
     delete _pbData;
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::LoadBitmapFile
//
//  Synopsis:   loads a bitmap file
//
//  Arguments:  [pszFile] -- the file
//
//  Returns:    HRESULT
//
//  History:    4-23-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CBitmapFile::LoadBitmapFile (LPSTR pszFile)
{
     HRESULT hr = ResultFromScode(S_OK);
     HANDLE  hFile = INVALID_HANDLE_VALUE;
     HANDLE  hMap = INVALID_HANDLE_VALUE;
     DWORD   dwFileSizeLow = 0;
     DWORD   dwFileSizeHigh = 0;
     LPBYTE  pbuffer = NULL;

     //
     // First open the file
     //

     hFile = CreateFileA(pszFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

     if (hFile == INVALID_HANDLE_VALUE)
     {
          hr = HRESULT_FROM_WIN32(GetLastError());
     }

     //
     // Get the size of the file
     //

     if (SUCCEEDED(hr))
     {
          dwFileSizeLow = GetFileSize(hFile, &dwFileSizeHigh);
          if ((dwFileSizeLow == 0xFFFFFFFF) && (GetLastError() != NO_ERROR))
          {
               hr = HRESULT_FROM_WIN32(GetLastError());
          }
          else if (dwFileSizeHigh != 0)
          {
               //
               // Bitmap files can't be greater than 4G
               //

               hr = ResultFromScode(E_FAIL);
          }
     }

     //
     // Create a file mapping object on the file
     //

     if (SUCCEEDED(hr))
     {
          hMap = CreateFileMapping(hFile,
                                   NULL,
                                   PAGE_READONLY,
                                   0,
                                   dwFileSizeLow,
                                   NULL);

          if (hMap == INVALID_HANDLE_VALUE)
          {
               hr = HRESULT_FROM_WIN32(GetLastError());
          }
     }

     //
     // Now map a view of the file into our address space
     //

     if (SUCCEEDED(hr))
     {
          pbuffer = (LPBYTE)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
          if (pbuffer == NULL)
          {
               hr = HRESULT_FROM_WIN32(GetLastError());
          }
     }

     //
     // Get the bitmap data from the buffer
     //

     if (SUCCEEDED(hr))
     {
          hr = _GetBitmapDataFromBuffer(pbuffer, (ULONG)dwFileSizeLow);
     }

     //
     // Record the file name
     //

     if (SUCCEEDED(hr))
     {
          ULONG cFile;

          //
          // Get the length of the file name
          //

          cFile = strlen(pszFile);

          //
          // Check to see that our buffer is big enough and then copy
          // it.  NOTE that I can use sizeof here since the buffer is
          // in characters which are 1 byte.
          //

          if (cFile < sizeof(_pszBitmapFile))
          {
               strcpy(_pszBitmapFile, pszFile);
               _cBitmapFile = cFile;
          }
          else
          {
               hr = ResultFromScode(E_FAIL);
          }
     }

     //
     // Cleanup
     //

     if (hMap != INVALID_HANDLE_VALUE)
     {
          CloseHandle(hMap);
     }

     if (hFile != INVALID_HANDLE_VALUE)
     {
          CloseHandle(hFile);
     }

     return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::GetBitmapFileName
//
//  Synopsis:   gets the file name used to set the bitmap
//
//  Arguments:  [pszFile] -- the file
//              [cChar]   -- the length of the buffer in characters
//
//  Returns:    HRESULT
//
//  History:    4-23-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CBitmapFile::GetBitmapFileName (LPSTR pszFile, ULONG cChar) const
{
     //
     // Check the length of the receiving buffer, making sure the buffer size
     // includes the null terminator
     //

     if (cChar <= _cBitmapFile)
     {
          return(ResultFromScode(E_INVALIDARG));
     }

     //
     // Copy the string
     //

     strcpy(pszFile, _pszBitmapFile);

     return(ResultFromScode(S_OK));
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::GetBitmapFileNameLength
//
//  Synopsis:   returns _cBitmapFile
//
//  Arguments:  (none)
//
//  Returns:    ULONG
//
//  History:    4-23-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
ULONG
CBitmapFile::GetBitmapFileNameLength () const
{
     return(_cBitmapFile);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::GetDIBHeight
//
//  Synopsis:   gets the height in pixels of the DIB
//
//  Arguments:  (none)
//
//  Returns:    LONG
//
//  History:    4-23-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG
CBitmapFile::GetDIBHeight () const
{
     if (_pbi)
     {
          return(_pbi->bmiHeader.biHeight);
     }
     else
     {
          return(0);
     }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::GetDIBWidth
//
//  Synopsis:   gets the width in pixels of the DIB
//
//  Arguments:  (none)
//
//  Returns:    LONG
//
//  History:    4-23-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LONG
CBitmapFile::GetDIBWidth () const
{
     if (_pbi)
     {
          return(_pbi->bmiHeader.biWidth);
     }
     else
     {
          return(0);
     }
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::GetLogicalPalette
//
//  Synopsis:   gets the logical palette from the DIB
//
//  Arguments:  [pplogpal] -- logical palette goes here
//
//  Returns:    HRESULT
//
//  History:    4-23-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CBitmapFile::GetLogicalPalette (LPLOGPALETTE *pplogpal) const
{
     HRESULT    hr = ResultFromScode(S_OK);
     LOGPALETTE *plogpal = NULL;
     WORD       cPalEntry;
     LPMALLOC   pMalloc = NULL;

     //
     // First check to see if we have been initialized with a bitmap
     //

     if (_pbi == NULL)
     {
          return(ResultFromScode(E_FAIL));
     }

     //
     // Check to see if this bit count allows a palette
     //

     if (HasPaletteData() == FALSE)
     {
          return(ResultFromScode(E_FAIL));
     }

     //
     // NOTE: We are about to get the number of palette entries we
     //       need to allocate, we do NOT use biClrUsed since we
     //       know that if this field was set the bitmap would
     //       not have been loaded, see BUGBUG in
     //       _GetBitmapDataFromBuffer notes section.  This is
     //       probably a good candidate for an assert.
     //

     //
     // Get the palette entries
     //

     cPalEntry = (WORD) (1 << _pbi->bmiHeader.biBitCount);

     //
     // Allocate a LOGPALETTE
     //

     hr = CoGetMalloc(MEMCTX_TASK, &pMalloc);
     if (SUCCEEDED(hr))
     {
          plogpal = (LOGPALETTE *)pMalloc->Alloc(sizeof(LOGPALETTE)+
                                                 ((cPalEntry-1)*
                                                 sizeof(PALETTEENTRY)));

          if (plogpal == NULL)
          {
               hr = ResultFromScode(E_OUTOFMEMORY);
          }
     }

     //
     // Copy the palette information
     //

     if (SUCCEEDED(hr))
     {
          ULONG cCount;

          plogpal->palVersion = 0x300;
          plogpal->palNumEntries = cPalEntry;

          for (cCount = 0; cCount < cPalEntry; cCount++)
          {
               plogpal->palPalEntry[cCount].peRed = _pbi->bmiColors[cCount].rgbRed;
               plogpal->palPalEntry[cCount].peGreen = _pbi->bmiColors[cCount].rgbGreen;
               plogpal->palPalEntry[cCount].peBlue = _pbi->bmiColors[cCount].rgbBlue;
               plogpal->palPalEntry[cCount].peFlags = PC_NOCOLLAPSE;
          }

          *pplogpal = plogpal;
     }

     //
     // Cleanup
     //

     if (pMalloc)
     {
          pMalloc->Release();
     }

     return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::CreateDIBInHGlobal
//
//  Synopsis:   creates a DIB i.e. info and data in a GlobalAlloc'd buffer
//
//  Arguments:  [phGlobal] -- handle goes here
//
//  Returns:    HRESULT
//
//  History:    5-06-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CBitmapFile::CreateDIBInHGlobal (HGLOBAL *phGlobal) const
{
     HRESULT hr = ResultFromScode(S_OK);
     ULONG   cb = 0;
     LPBYTE  pb = NULL;
     HGLOBAL hGlobal = NULL;
     ULONG   cbPalEntry = 0;

     //
     // Check to see if we are initialized
     //

     if (_pbi == NULL)
     {
          return(ResultFromScode(E_FAIL));
     }

     //
     // The size to allocate for the data must be calculated
     // from the following ...
     //

     //
     // The size of the bitmap info plus the size of the data
     //

     cb = _cbi + _cbData;

     //
     // Allocate
     //

     hGlobal = GlobalAlloc(GHND, cb);
     if (hGlobal == NULL)
     {
          hr = HRESULT_FROM_WIN32(GetLastError());
     }

     //
     // Lock the handle
     //

     if (SUCCEEDED(hr))
     {
          pb = (LPBYTE)GlobalLock(hGlobal);
          if (pb == NULL)
          {
               hr = HRESULT_FROM_WIN32(GetLastError());
          }
     }

     //
     // Copy the information
     //

     if (SUCCEEDED(hr))
     {
          //
          // First the bitmap info
          //

          memcpy(pb, _pbi, _cbi);

          //
          // Move pointer but if there is no palette compensate
          // for the extra RGBQUAD
          //

          if (_pbi->bmiHeader.biBitCount == BMP_24_BITSPERPIXEL)
          {
               pb += (_cbi - sizeof(RGBQUAD));
          }
          else
          {
               pb += _cbi;
          }

          //
          // Now the bits
          //

          memcpy(pb, _pbData, _cbData);
     }

     //
     // Cleanup
     //

     //
     // If we locked the handle, unlock it
     //

     if (pb)
     {
          GlobalUnlock(hGlobal);
     }

     //
     // If we succeeded, set the out parameter, if we failed and
     // we had allocated the hGlobal, free it
     //

     if (SUCCEEDED(hr))
     {
          *phGlobal = hGlobal;
     }
     else if (hGlobal)
     {
          GlobalFree(hGlobal);
     }

     return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::HasPaletteData
//
//  Synopsis:   returns whether or not the dib has palette data
//
//  Arguments:  (none)
//
//  Returns:    BOOL
//
//  History:    5-16-94   kirtd   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL
CBitmapFile::HasPaletteData () const
{
     //
     // If we are not initialized return FALSE
     //

     if (_pbi == NULL)
     {
          return(FALSE);
     }

     //
     // If we are a 24, 16 or 32 bpp DIB then we do not have
     // palette data
     //
     // BUGBUG: The case where biClrUsed is set is not dealt
     //         with
     //

     if ((_pbi->bmiHeader.biBitCount == BMP_24_BITSPERPIXEL) ||
         (_pbi->bmiHeader.biBitCount == BMP_16_BITSPERPIXEL) ||
         (_pbi->bmiHeader.biBitCount == BMP_32_BITSPERPIXEL))
     {
          return(FALSE);
     }

     //
     // Otherwise we do have palette data
     //

     return(TRUE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::GetDIBBits
//
//  Synopsis:   gets the bits
//
//  Arguments:  (none)
//
//  Returns:    LPBYTE
//
//  History:    5-02-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPBYTE
CBitmapFile::GetDIBBits ()
{
     return(_pbData);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::GetBitmapInfo
//
//  Synopsis:   gets the bitmap info pointer
//
//  Arguments:  (none)
//
//  Returns:    LPBITMAPINFO
//
//  History:    5-14-94   kirtd   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LPBITMAPINFO
CBitmapFile::GetBitmapInfo ()
{
     return(_pbi);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::_GetBitmapDataFromBuffer
//
//  Synopsis:   gets the bitmap data from the given buffer
//
//  Arguments:  [pbuffer] -- the buffer
//              [cb]      -- the buffer size
//
//  Returns:    HRESULT
//
//  History:    4-23-94   KirtD   Created
//
//  Notes:      BUGBUG: If biClrUsed is set the bitmap is not loaded
//
//----------------------------------------------------------------------------
HRESULT
CBitmapFile::_GetBitmapDataFromBuffer (LPBYTE pbuffer, ULONG cb)
{
     HRESULT          hr = ResultFromScode(S_OK);
     BITMAPFILEHEADER bmfh;
     BITMAPCOREHEADER *pbch;
     BITMAPINFOHEADER bih;
     LPBYTE           pbStart;
     ULONG            cbi = 0;
     ULONG            cbData;
     LPBITMAPINFO     pbi = NULL;
     LPBYTE           pbData = NULL;
     DWORD            dwSizeOfHeader;

     //
     // Record the starting position
     //

     pbStart = pbuffer;

     //
     // First validate the buffer for size
     //

     if (cb < sizeof(BITMAPFILEHEADER))
     {
          return(ResultFromScode(E_FAIL));
     }

     //
     // Now get the bitmap file header
     //

     memcpy(&bmfh, pbuffer, sizeof(BITMAPFILEHEADER));

     //
     // Validate the information
     //

     hr = _ValidateBitmapFileHeader (&bmfh, cb);

     //
     // Get the next 4 bytes which will represent the size of the
     // next structure and allow us to determine the type
     //

     if (SUCCEEDED(hr))
     {
          pbuffer += sizeof(BITMAPFILEHEADER);
          memcpy(&dwSizeOfHeader, pbuffer, sizeof(DWORD));

          if (dwSizeOfHeader == sizeof(BITMAPCOREHEADER))
          {
               pbch = (BITMAPCOREHEADER *)pbuffer;
               memset(&bih, 0, sizeof(BITMAPINFOHEADER));

               bih.biSize = sizeof(BITMAPINFOHEADER);
               bih.biWidth = pbch->bcWidth;
               bih.biHeight = pbch->bcHeight;
               bih.biPlanes = pbch->bcPlanes;
               bih.biBitCount = pbch->bcBitCount;

               pbuffer += sizeof(BITMAPCOREHEADER);
          }
          else if (dwSizeOfHeader == sizeof(BITMAPINFOHEADER))
          {
               memcpy(&bih, pbuffer, sizeof(BITMAPINFOHEADER));

               pbuffer += sizeof(BITMAPINFOHEADER);
          }
          else
          {
               hr = ResultFromScode(E_FAIL);
          }
     }

     //
     // Check if biClrUsed is set since we do not handle that
     // case at this time
     //

     if (SUCCEEDED(hr))
     {
          if (bih.biClrUsed != 0)
          {
               hr = ResultFromScode(E_FAIL);
          }
     }

     //
     // Now we need to calculate the size of the BITMAPINFO we need
     // to allocate including any palette information
     //

     if (SUCCEEDED(hr))
     {
          //
          // First the size of the header
          //

          cbi = sizeof(BITMAPINFOHEADER);

          //
          // Now the palette
          //

          if (bih.biBitCount == BMP_24_BITSPERPIXEL)
          {
               //
               // Just add on the 1 RGBQUAD for the structure but
               // there is no palette
               //

               cbi += sizeof(RGBQUAD);
          }
          else if ((bih.biBitCount == BMP_16_BITSPERPIXEL) ||
                   (bih.biBitCount == BMP_32_BITSPERPIXEL))
          {
               //
               // Add on the 3 DWORD masks which are used to
               // get the colors out of the data
               //

               cbi += (3 * sizeof(DWORD));
          }
          else
          {
               //
               // Anything else we just use the bit count to calculate
               // the number of entries
               //

               cbi += ((1 << bih.biBitCount) * sizeof(RGBQUAD));
          }

          //
          // Now allocate the BITMAPINFO
          //

          pbi = (LPBITMAPINFO) new BYTE [cbi];
          if (pbi == NULL)
          {
               hr = ResultFromScode(E_OUTOFMEMORY);
          }
     }

     //
     // Fill in the BITMAPINFO data structure and get the bits
     //

     if (SUCCEEDED(hr))
     {
          //
          // First copy the header data
          //

          memcpy(&(pbi->bmiHeader), &bih, sizeof(BITMAPINFOHEADER));

          //
          // Now the palette data
          //

          if (bih.biBitCount == BMP_24_BITSPERPIXEL)
          {
               //
               // No palette data to copy
               //
          }
          else if ((bih.biBitCount == BMP_16_BITSPERPIXEL) ||
                   (bih.biBitCount == BMP_32_BITSPERPIXEL))
          {
               //
               // Copy the 3 DWORD masks
               //

               memcpy(&(pbi->bmiColors), pbuffer, 3*sizeof(DWORD));
          }
          else
          {
               //
               // If we were a BITMAPCOREHEADER type then we have our
               // palette data in the form of RGBTRIPLEs so we must
               // explicitly copy each.  Otherwise we can just memcpy
               // the RGBQUADs
               //

               if (dwSizeOfHeader == sizeof(BITMAPCOREHEADER))
               {
                    ULONG     cPalEntry = (1 << bih.biBitCount);
                    ULONG     cCount;
                    RGBTRIPLE *argbt = (RGBTRIPLE *)pbuffer;

                    for (cCount = 0; cCount < cPalEntry; cCount++)
                    {
                         pbi->bmiColors[cCount].rgbRed =
                                            argbt[cCount].rgbtRed;
                         pbi->bmiColors[cCount].rgbGreen =
                                            argbt[cCount].rgbtGreen;
                         pbi->bmiColors[cCount].rgbBlue =
                                            argbt[cCount].rgbtBlue;

                         pbi->bmiColors[cCount].rgbReserved = 0;
                    }
               }
               else
               {
                    ULONG cbPalette = (1 << bih.biBitCount) * sizeof(RGBQUAD);

                    memcpy(&(pbi->bmiColors), pbuffer, cbPalette);
               }
          }

          //
          // Now find out where the bits are
          //

          pbuffer = pbStart + bmfh.bfOffBits;

          //
          // Get the size to copy
          //

          cbData = cb - bmfh.bfOffBits;

          //
          // Allocate the buffer to hold the bits
          //

          pbData = new BYTE [cbData];
          if (pbData == NULL)
          {
               hr = ResultFromScode(E_OUTOFMEMORY);
          }

          if (SUCCEEDED(hr))
          {
               memcpy(pbData, pbuffer, cbData);
          }
     }

     //
     // If everything succeeded record the data
     //

     if (SUCCEEDED(hr))
     {
          //
          // Record the info
          //

          delete _pbi;
          _cbi = cbi;
          _pbi = pbi;

          //
          // Record the data
          //

          delete _pbData;
          _cbData = cbData;
          _pbData = pbData;
     }
     else
     {
          //
          // Cleanup
          //

          delete pbi;
          delete pbData;
     }

     return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CBitmapFile::_ValidateBitmapFileHeader
//
//  Synopsis:   validates a bitmap file header
//
//  Arguments:  [pbmfh]  -- bitmap file header
//              [cbFile] -- bitmap file size
//
//  Returns:    HRESULT
//
//  History:    4-23-94   KirtD   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT
CBitmapFile::_ValidateBitmapFileHeader (BITMAPFILEHEADER *pbmfh, ULONG cbFile)
{
     //
     // Check for the following,
     //
     // 1. The bfType member contains 'BM'
     // 2. The bfOffset member is NOT greater than the size of the file
     //

     if ((pbmfh->bfType == 0x4d42) && (pbmfh->bfOffBits <= cbFile))
     {
          return(ResultFromScode(S_OK));
     }

     return(ResultFromScode(E_FAIL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cachetst\davedbg.cpp ===
//+----------------------------------------------------------------------------
//
//      File:		DAVEDBG.CPP
//
//      Synopsis:	TraceLog class for debugging
//
//      Arguments:	
// 
//      History:	23-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

GROUPSET  LEGroups    = GS_CACHE;               // Groups to display
VERBOSITY LEVerbosity = VB_MAXIMUM;             // Verbosity level to display at


//+----------------------------------------------------------------------------
//
//      Member:		dprintf
//
//      Synopsis:	Dumps a printf style string to the debugger.
//
//      Arguments:	[szFormat]        THIS pointer of caller
//                      [...]             Arguments
//
//      Notes:
//
//      History:	05-Sep-94  Davepl	Created
//
//-----------------------------------------------------------------------------

int dprintf(LPCSTR szFormat, ...)
{
    char szBuffer[MAX_BUF];

    va_list  vaList;
    va_start(vaList, szFormat);
    
    int retval = vsprintf(szBuffer, szFormat, vaList);

    OutputDebugStringA(szBuffer);
    
    va_end  (vaList);
    return retval;
}
        
//+----------------------------------------------------------------------------
//
//      Member:		mprintf
//
//      Synopsis:	Dumps a printf style string to a message box.
//
//      Arguments:	[szFormat]        THIS pointer of caller
//                      [...]             Arguments
//
//      Notes:
//
//      History:	05-Sep-94  Davepl	Created
//
//-----------------------------------------------------------------------------

int mprintf(LPCSTR szFormat, ...)
{
    char szBuffer[MAX_BUF];

    va_list  vaList;
    va_start(vaList, szFormat);
    
    int retval = vsprintf(szBuffer, szFormat, vaList);

    extern CCacheTestApp ctest;
        
    MessageBox(ctest.Window(), 
               szBuffer, 
               "CACHE UNIT TEST INFO", 
               MB_ICONINFORMATION | MB_APPLMODAL | MB_OK);

    va_end  (vaList);
    return retval;
}

//+----------------------------------------------------------------------------
//
//      Member:		TraceLog::TraceLog
//
//      Synopsis:	Records the THIS ptr and function name of the caller,
//                      and determines whether or not the caller meets the
//                      group and verbosity criteria for debug output
//
//      Arguments:	[pvThat]        THIS pointer of caller
//                      [pszFuntion]    name of caller
//                      [gsGroups]      groups to which caller belongs
//                      [vbVerbosity]   verbosity level need to display debug
//                                       info for this function
//
//      Notes:
//
//      History:	23-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------

TraceLog::TraceLog (void     * pvThat, 
                    char     * pszFunction, 
                    GROUPSET   gsGroups, 
                    VERBOSITY  vbVerbosity)
{       
    //
    // Determine whether or not the trace logging should be displayed
    // for this function. Iff it is, we need to track some information
    // about the function (ie: this ptr, func name)
    //
    // In order to be displayed, the function must belong to a group
    // which has been set in the group display mask, and the function
    // must be in an equal or lesser verbosity class.
    //
    
    if ( (gsGroups & LEGroups) && (LEVerbosity >= vbVerbosity) )
    {
        m_fShouldDisplay = TRUE;
        m_pvThat         = pvThat;
        strncpy(m_pszFunction, pszFunction, MAX_BUF - 1);
    }
    else
    {
        m_fShouldDisplay = FALSE;
    }
}

//+----------------------------------------------------------------------------
//
//      Member:		TraceLog::OnEntry()
//
//      Synopsis:	Default entry output, which simply displays the _IN
//                      trace with the function name and THIS pointer
//
//      Returns:	HRESULT
//
//      Notes:
//
//      History:	23-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------

void TraceLog::OnEntry()
{
    if (m_fShouldDisplay)
    {
        dprintf("[%p] _IN %s\n", m_pvThat, m_pszFunction);
    }
}

//+----------------------------------------------------------------------------
//
//      Member:		TraceLog::OnEntry
//
//      Synopsis:	Displays standard entry debug info, plus a printf
//                      style trailer string as supplied by the caller
//
//      Arguments:	[pszFormat ...]         printf style output string
//
//      Returns:	void
//
//      Notes:
//
//      History:	23-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------

void TraceLog::OnEntry(char * pszFormat, ...)
{
    //
    // Only display if we have already matched the correct criteria
    //

    if (m_fShouldDisplay)
    {
        char szBuffer[MAX_BUF];

        // 
        // print the standard trace output, then the custom information as
        // received from the caller
        //
    
        dprintf("[%p] _IN %s ", m_pvThat, m_pszFunction);
        
        va_list vaList;
        va_start(vaList, pszFormat);
        vsprintf(szBuffer, pszFormat, vaList);
        dprintf(szBuffer);
        va_end(vaList);
    }
}

//+----------------------------------------------------------------------------
//
//      Member:		TraceLog::OnExit
//
//      Synopsis:	Sets the debug info that should be displayed when
//                      the TraceLog object is destroyed
//
//      Arguments:	[pszFormat ...]         printf style custom info
//
//      Returns:	void
//
//      Notes:          Since it would make no sense to pass variables by
//                      value into this function (which would snapshot them
//                      at the time this was called), variables in the arg
//                      list must be passed by REFERENCE
//              
//      History:	23-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------

void TraceLog::OnExit(const char * pszFormat, ...)
{
    if (m_fShouldDisplay)
    {
        const char * pch;                       // ptr to walk format string
        BOOL     fBreak;                        // set when past fmt specifier

        // 
        // Start processing the argument list
        //

        va_list   arg;                          
        va_start (arg, pszFormat);

        //
        // Save the format string for use in the destructor
        //

        strcpy (m_pszFormat, pszFormat);
        m_cArgs = 0;

        //
        // Walk the format string looking for % modifiers
        //

        for (pch = pszFormat; *pch; pch++)
        {
            if (*pch != '%')
            {
                continue;
            }
        
            // We can stop looking until EOL or end of specifier

            fBreak = FALSE;

            while (!fBreak)
            {
                if (!* (++pch))         // Hit EOL
                {
                    break;
                }
                                
                switch (*pch)
                {
                    //
                    // These are all valid format specifiers and
                    // modifers which may be combined to reference
                    // a single argument in the argument list
                    //

                    case 'F':           
                    case 'l': 
                    case 'h': 
                    case 'X': 
                    case 'x': 
                    case 'O': 
                    case 'o': 
                    case 'd': 
                    case 'u': 
                    case 'c': 
                    case 's': 
                    
                        break;
                    
                    default:     
                    
                    // 
                    // We have hit a character which is not a valid specifier,
                    // so we stop searching in order to pull the argument
                    // which corresponds with it from the arg list
                    //    
                        fBreak = TRUE;     
                        break;
                }
            }

            //
            // If we have already hit the maximum number of args, we can't do 
            // any more
            //
                
            if (m_cArgs == MAX_ARGS)
            {
                break;
            }

            // 
            // Grab the argument as a NULL ptr.  We will save it away and figure
            // out what kind of argument it was when it comes time to display it,
            // based on the format string
            //

            m_aPtr[m_cArgs] = va_arg (arg, void *);
            m_cArgs++;

            if (! *pch)
            {
                break;
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//      Member:		TraceLog::~TraceLog
//
//      Synopsis:	On destruction, the TraceLog class displays its debug
//                      output as set by the OnExit() method.
//
//      Returns:	void
//
//      Notes:
//                     
//      History:	23-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------

TraceLog::~TraceLog()
{
    char      szTmpFmt[ MAX_BUF ];
    char      szOutStr[ MAX_BUF ];
    char     *pszOut;
    char     *pszszTmpFmt;
    const char * pszFmt;
    void     *pv;
    BYTE     i = 0;
    VARTYPE  vtVarType;
    BOOL     fBreak;

    pszOut = szOutStr;

    // 
    // Walk the format string looking for format specifiers
    //

    for (pszFmt = m_pszFormat; *pszFmt; pszFmt++)
    {
        if (*pszFmt != '%')
        {
            *pszOut++ = *pszFmt;
            continue;
        }

        // 
        // Found the start of a specifier.  Reset the expected argument type,
        // then walk to the end of the specifier
        //

        vtVarType = NO_TYPE;
        fBreak = FALSE;

        //
        // Start recording the specifier for a single call to sprintf later
        //

        for (pszszTmpFmt = szTmpFmt; !fBreak; )
        {
            *pszszTmpFmt++ = *pszFmt;

            //
            // Guard against a terminator that doesn't comlete before EOL
            //

            if (!* (++pszFmt))
            {
                break;
            }
            
            // 
            // These are all valid format specifiers.  Skip over them and
            // update the vtVarType.  It's end value will be our heuristic
            // which indicates what type of variable was really intended
            //

            switch (*pszFmt)
            {
                case 'l':    vtVarType |= LONG_TYPE;    break;
                case 'h':    vtVarType |= SHORT_TYPE;   break;
                case 'X':    vtVarType |= INT_TYPE;     break;
                case 'x':    vtVarType |= INT_TYPE;     break;
                case 'O':    vtVarType |= INT_TYPE;     break;
                case 'o':    vtVarType |= INT_TYPE;     break;
                case 'd':    vtVarType |= INT_TYPE;     break;
                case 'u':    vtVarType |= INT_TYPE;     break;
                case 'c':    vtVarType |= CHAR_TYPE;    break;
                case 's':    vtVarType |= STRING_TYPE;  break;
                case 'p':    vtVarType |= PTR_TYPE;     break;
                default:     fBreak = TRUE;     break;
            }
        }

        // NUL-terminate the end of the temporary format string

        *pszszTmpFmt = 0;

        // Grab the argument pointer which corresponds to this argument

        pv = m_aPtr[ i ];
        i++;

        //
        // Using the appropriate cast, spew the argument into our
        // local output buffer using the original format specifier.
        //

        if (vtVarType & STRING_TYPE)
        {
            sprintf (pszOut, szTmpFmt, (char *)pv);
        }
        else if (vtVarType & LONG_TYPE)
        {
            sprintf (pszOut, szTmpFmt, *(long *)pv);
        }
        else if (vtVarType & SHORT_TYPE)
        {
            sprintf (pszOut, szTmpFmt, *(short *)pv);
        }
        else if (vtVarType & INT_TYPE)
        {
            sprintf (pszOut, szTmpFmt, *(int *)pv);
        }
        else if (vtVarType & CHAR_TYPE)
        {
            sprintf (pszOut, szTmpFmt, (char)*(char *)pv);
        }
        else if (vtVarType & PTR_TYPE)
        {
            sprintf (pszOut, szTmpFmt, (void *)pv);
        }
        else
        {
            *pszOut = 0;
        }

        // Advance the output buffer pointer to the end of the
        // current buffer

        pszOut = &pszOut[ strlen(pszOut) ];

        if (! *pszFmt)
        {
            break;
        }
    }

    // NUL-terminate the buffer

    *pszOut = 0;

    //
    // Dump the resultant buffer to the output
    //

    dprintf("[%p] OUT %s %s", m_pvThat, m_pszFunction, szOutStr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cachetst\genenum.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:     genenum.cpp
//
//  Contents:     implementation of CEnumeratorTest object
//                This is the object that does all of the testing.
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Member:      CEnumeratorTest::CEnumeratorTest
//
//  Synopsis:    constructor
//
//  Arguments:   none
//
//  Returns:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

CEnumeratorTest::CEnumeratorTest()
{
    m_pEnumTest      = NULL;
    m_ElementSize    = 0;
    m_ElementCount   = -1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEnumeratorTest::CEnumeratorTest
//
//  Synopsis:   constructor
//
//  Arguments:  [enumtest] --      The enumerator object to be tested
//              [elementsize] --   The size of one element from next
//              [elementcount] --  The number of elements expected to in
//                                 the enumerator. 0 if unknown.
//
//  Returns:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

CEnumeratorTest::CEnumeratorTest(IGenEnum * enumtest, size_t elementsize, LONG elementcount)
{
    m_pEnumTest    = enumtest;
    m_ElementSize    = elementsize;
    m_ElementCount    = elementcount;
}


//+-------------------------------------------------------------------------
//
//  Function:   CEnumeratorTest::GetNext
//
//  Synopsis:   Internal Next Implementation. Does some basic checks on the
//              return values.
//
//  Effects:
//
//  Arguments:  [celt] --         the number of items to fetch
//              [pceltFetched] -- the number of items fetched
//              [phresult] --     the return from next
//
//  Requires:
//
//  Returns:    True if the basic tests passed, false if they didn't
//              The result of the next call itself is passed in param 3.
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  Checks:
//                  That if s_ok is returned celt and pceltFetched are ==
//                  If a verify is provided it is called
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CEnumeratorTest::GetNext(    ULONG   celt,
        ULONG*  pceltFetched,
        HRESULT* phresult
        )
{
    void*    prgelt;
    ULONG    ul;
    BOOL     fRet = TRUE;

    //
    // Allocate memory for the return elements
    //

    prgelt = new char[m_ElementSize * celt];

    if (prgelt == NULL)
    {
        printf("IEnumX::GetNext out of memory.\r\n");

        return(FALSE);
    }

    //
    // Call next
    //

    *phresult = m_pEnumTest->Next(celt, prgelt, pceltFetched);

    //
    // If the return result is S_OK make sure the numbers match
    //

    if (*phresult == S_OK)
    {
        if ((pceltFetched) && (celt != *pceltFetched))
        {
            printf("IEnumX::Next returned S_OK but celt"
                    " and pceltFetch mismatch.\r\n");

            fRet = FALSE;
        }
    }

    //
    // If false is returned then make sure celt is less than
    // the number actually fetched
    //

    if (*phresult == S_FALSE)
    {
        if ((pceltFetched) && (celt < *pceltFetched))
        {
            printf("IEnumX::Next return S_FALSE but celt is"
                   " less than pceltFetch.\r\n");

            fRet = FALSE;
        }
    }

    //
    // Call verify to make sure the elements are ok.
    //

    if ((*phresult == S_OK) || (*phresult == S_FALSE))
    {
        //
        // If we got S_FALSE back set celt to the number of elements
        // returned in pceltFetched.  If the user gave NULL for
        // pceltFetched and we got S_FALSE back then celt can only be
        // zero.
        //

        if (*phresult == S_FALSE)
        {
            if (pceltFetched)
            {
                celt = *pceltFetched;
            }
            else
            {
                celt = 0;
            }
        }

        //
        // loop through every returned element
        //

        for (ul=0; ul <= celt ; ul++)
        {
            if ((fRet == TRUE) &&
                (Verify(((char *)prgelt) + (ul * m_ElementSize)) == FALSE))
            {
                printf("Data element %d returned by IEnumX::Next is bad.\r\n", ul);

                fRet = FALSE;

                //
                // we keep looping anyway just to
                // free up resources.
                //
            }

            //
            // If the user supplied a cleanup function there is additional
            // memory that needs to be freed
            //
            // Math: cast prgelt to char* to it a one byte size and then scale
            // it by the index * the element size
            //

            Cleanup(((char *)prgelt) + (ul * m_ElementSize));

        }
    }

    delete prgelt;

    return fRet;
}

//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTest::TestNext
//
//  Synopsis:   Test the next enumerator methods
//
//  Effects:
//
//  Arguments:    None.
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:      BUGBUG: This function should really be broken down into
//              smaller function.
//              Also, the return mechanism is unwieldy.
//
//--------------------------------------------------------------------------

HRESULT CEnumeratorTest::TestNext(void)
{
    ULONG    celtFetched;
    LONG     lInternalCount = 0;
    HRESULT  hresult;
    ULONG    i;
    void*    prgelt;

    //
    // First we want to count the element by doing a next on each one.
    //

    do {
        if (!GetNext(1, &celtFetched, &hresult))
        {
            return(E_FAIL);
        }
        if (hresult == S_OK)
        {
            lInternalCount++;
        }

    } while ( hresult == S_OK );

    //
    // If the user passed in an amount make sure it matches what we got
    //

    if ((m_ElementCount != -1) && (lInternalCount != m_ElementCount))
    {
        printf("IEnumX: enumerated count and passed count do not match!\r\n");

        return(E_FAIL);
    }
    else if (m_ElementCount == -1)
    {
        //
        //  If the user didn't pass in the element count let's set it here.
        //

        m_ElementCount = lInternalCount;
    }

    hresult = m_pEnumTest->Reset();

    if (hresult != S_OK)
    {
        printf("IEnumnX: Reset failed (%lx)\r\n", hresult );

        return(E_FAIL);
    }


    //
    // Make sure we fail on ...Next(celt>1, ...,NULL)
    //

    if (GetNext(2, NULL, &hresult))
    {
        if (SUCCEEDED(hresult))
        {
            printf("IEnumX: celt>1 pceltFetched==NULL returned success\r\n");

            return(E_FAIL);
        }
    }
    else
    {
        return(E_FAIL);
    }


    //
    // This next test will call next getting more each time
    //

    for (i = 1; i < (ULONG)m_ElementCount; i++)
    {
        hresult = m_pEnumTest->Reset();

        if (hresult != S_OK)
        {
            printf("IEnumnX: Reset failed (%lx)\r\n", hresult );

            return(E_FAIL);
        }

        if (!GetNext(i, &celtFetched, &hresult))
        {
            return(E_FAIL);
        }

        if ((hresult != S_OK) || (celtFetched != i))
        {
            printf("IEnumX: next/reset test failed!\r\n");

            return(E_FAIL);
        }
    }


    //
    // Now get more elements than we were supposed to
    // This should return S_FALSE with the max number in the number fetched
    //

    hresult = m_pEnumTest->Reset();

    if (hresult != S_OK)
    {
        printf("IEnumX: Reset failed (%lx)\r\n", hresult );

        return(E_FAIL);
    }

    if (!GetNext(m_ElementCount + 1, &celtFetched, &hresult))
    {
        return(E_FAIL);
    }

    if ((hresult != S_FALSE) || (lInternalCount != m_ElementCount))
    {
        printf("IEnumX: next/reset test failed!\r\n");

        return(E_FAIL);
    }

    //
    // Now verifyall.  We do it here after the object has been worked on a bit
    // since it is more likely to fail at this point
    //

    hresult = m_pEnumTest->Reset();

    if (hresult != S_OK)
    {
        printf("IEnumX: Reset failed (%lx)\r\n", hresult );

        return(E_FAIL);
    }

    //
    // Allocate memory for the return elements
    //

    prgelt = new char[m_ElementSize * m_ElementCount];

    if (prgelt == NULL)
    {
        printf("IEnumX: verifyall new failed\r\n");

        return(E_OUTOFMEMORY);
    }

    hresult = m_pEnumTest->Next(m_ElementCount, prgelt, &celtFetched);

    if ((hresult != S_OK) || (celtFetched != (ULONG)m_ElementCount))
    {
        printf("IEnumX: verifyall test: next failed (%lx)\r\n", hresult );
        delete prgelt;

        return(E_FAIL);
    }

    if (VerifyAll(prgelt, m_ElementCount) == FALSE)
    {
        printf("IEnumX: verifyall failed (%lx)\r\n", hresult );

        delete prgelt;

        return(E_FAIL);
    }

    delete prgelt;

    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTest::TestSkip
//
//  Synopsis:    This function calls all the tests
//
//  Effects:
//
//  Arguments:    None
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CEnumeratorTest::TestSkip(void)
{
    LONG        i;
    HRESULT        hresult;
    ULONG        celtFetched;

    //
    // Make sure we call TestNext to set the element count
    //

    if (m_ElementCount == -1)
    {
        TestNext();
    }

    //
    // Call Skip, reset and try to get one element
    //

    for (i = 0; i < (LONG)m_ElementCount; i++)
    {
        hresult = m_pEnumTest->Reset();

        if (hresult != S_OK)
        {
            printf("IEnumnX: Reset failed (%lx)\r\n", hresult );

            return(E_FAIL);
        }

        hresult = m_pEnumTest->Skip(i);

        if (hresult != S_OK)
        {
            printf("IEnumnX: Skip failed (%lx)\r\n", hresult );

            return(E_FAIL);
        }

        //
        //  Now one element to provide some check that the skip worked
        //

        if (!GetNext(1, &celtFetched, &hresult))
        {
            return(E_FAIL);
        }

        if (hresult != S_OK)
        {
            return(E_FAIL);
        }
    }

    //
    //  Reset the enumerator before we leave
    //

    hresult = m_pEnumTest->Reset();

    if (hresult != S_OK)
    {
        printf("IEnumnX: Reset failed (%lx)\r\n", hresult );
        return(E_FAIL);
    }

    return(S_OK);

}

//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTest::TestRelease
//
//  Synopsis:    This function calls all the tests
//
//  Effects:
//
//  Arguments:    None
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CEnumeratorTest::TestRelease(void)
{
    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTest::TestClone
//
//  Synopsis:    This function calls all the tests
//
//  Effects:
//
//  Arguments:    None
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CEnumeratorTest::TestClone(void)
{
    return(S_OK);
}

//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTest::TestAll
//
//  Synopsis:    This function calls all the tests
//
//  Effects:
//
//  Arguments:    None
//
//  Requires:
//
//  Returns:    HRESULT
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

HRESULT CEnumeratorTest::TestAll(void)
{
    HRESULT    hresult;

    hresult = TestNext();

    if (hresult == S_OK)
    {
        hresult = TestSkip();
    }

    if (hresult == S_OK)
    {
        hresult = TestClone();
    }

    if (hresult == S_OK)
    {
        hresult = TestRelease();
    }

    return(hresult);
}



//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTest::VerifyAll
//
//  Synopsis:   Verify entire array of returned results.
//
//  Arguments:  None
//
//  Returns:    BOOL
//
//  Algorithm:  Just default to saying everything is ok
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CEnumeratorTest::VerifyAll(void *pv, LONG cl)
{
        return TRUE;
}


//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTest::Verify
//
//  Synopsis:   Verify one element
//
//  Arguments:  None
//
//  Returns:    BOOL
//
//  Algorithm:  Just default to saying everything is ok
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CEnumeratorTest::Verify(void *pv)
{
        return TRUE;
}




//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTest::Cleanup
//
//  Synopsis:   Default implementation of cleanup
//
//  Arguments:  [pv] - pointer to entry enumerated
//
//  Algorithm:  If there is nothing special to free this implementation
//              can be used.
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//--------------------------------------------------------------------------

void  CEnumeratorTest::Cleanup(void *pv)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cachetst\utils.cpp ===
#include "headers.hxx"
#pragma hdrstop

//+----------------------------------------------------------------------------
//
//      File:
//              utils.cpp
//
//      Contents:
//              Utility functions for the cache unit test
//
//      History:
//              
//              04-Sep-94       davepl  Created
//
//-----------------------------------------------------------------------------


//+----------------------------------------------------------------------------
//
//      Member:		TestInstance::AddXXXCacheNode
//
//      Synopsis:	Adds an empty cache node for various formats
//
//      Arguments:	[inst]		-- ptr to test instance
//			[pdwCon]	-- ptr to connection ID (out)
//
//      Returns:	HRESULT
//
//      Notes:
//
//      History:	23-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------

HRESULT	TestInstance::AddMFCacheNode(DWORD *pdwCon)
{			  
    HRESULT hr;
  
    TraceLog Log(this, "TestInstance::AddMFCacheNode", GS_CACHE, VB_MAXIMUM);
    Log.OnEntry (" ( %p ) \n", pdwCon);
    Log.OnExit  (" ( %X ) [ %p ]\n", &hr, pdwCon);
    					 
    FORMATETC fetcMF = 
     		 {
  		     CF_METAFILEPICT,   // Clipformat
		     NULL,		// DVTargetDevice
		     DVASPECT_CONTENT,	// Aspect
		     -1,		// Index
		     TYMED_MFPICT	// TYMED
		 };

    // 
    // Cache a METAFILE node
    //

    hr = m_pOleCache->Cache(&fetcMF, ADVF_PRIMEFIRST, pdwCon);
    return hr;
}

HRESULT	TestInstance::AddEMFCacheNode(DWORD *pdwCon)
{			  
    HRESULT hr;
    					 
    TraceLog Log(this, "TestInstance::AddEMFCacheNode", GS_CACHE, VB_MAXIMUM);
    Log.OnEntry (" ( %p ) \n", pdwCon);
    Log.OnExit  (" ( %X ) [ %p ]\n", &hr, pdwCon);
    
    FORMATETC fetcEMF = {
			     CF_ENHMETAFILE,    // Clipformat
			     NULL,		// DVTargetDevice
			     DVASPECT_CONTENT,	// Aspect
			     -1,		// Index
			     TYMED_ENHMF	// TYMED
  		        };

    // 
    // Cache an ENH METAFILE node
    //

    hr = m_pOleCache->Cache(&fetcEMF, ADVF_PRIMEFIRST, pdwCon);
    return hr;
}

HRESULT	TestInstance::AddDIBCacheNode(DWORD *pdwCon)
{			  
    HRESULT hr;

    TraceLog Log(this, "TestInstance::AddDIBCacheNode", GS_CACHE, VB_MAXIMUM);
    Log.OnEntry (" ( %p ) \n", pdwCon);
    Log.OnExit  (" ( %X ) [ %p ]\n", &hr, pdwCon);
    
					 
    FORMATETC fetcDIB = {
        		     CF_DIB,            // Clipformat
			     NULL,		// DVTargetDevice
			     DVASPECT_CONTENT,	// Aspect
			     -1,		// Index
			     TYMED_HGLOBAL	// TYMED
	 	        };

    // 
    // Cache a DIB node
    //

    hr = m_pOleCache->Cache(&fetcDIB, ADVF_PRIMEFIRST, pdwCon);
    return hr;

}

HRESULT	TestInstance::AddBITMAPCacheNode(DWORD *pdwCon)
{			  
    HRESULT hr;

    TraceLog Log(this, "TestInstance::AddMFCacheNode", GS_CACHE, VB_MAXIMUM);
    Log.OnEntry (" ( %p ) \n", pdwCon);
    Log.OnExit  (" ( %X ) [ %p ]\n", &hr, pdwCon);
    					 
    FORMATETC fetcBITMAP = {
			     CF_BITMAP,         // Clipformat
			     NULL,		// DVTargetDevice
			     DVASPECT_CONTENT,	// Aspect
			     -1,		// Index
			     TYMED_GDI  	// TYMED
			   };

    // 
    // Cache a BITMAP node
    //

    hr = m_pOleCache->Cache(&fetcBITMAP, ADVF_PRIMEFIRST, pdwCon);
    return hr;
}						 

//+----------------------------------------------------------------------------
//
//      Function:	EltIsInArray
//
//      Synopsis:	Checks to see if a STATDATA search item is in 
//			a STATDATA array.  Checks clipformat and connection
//			ID only.
//
//      Arguments:	[sdToFind]	STATDATA we are looking for
//			[rgStat]	Array of STATDATAs to look in
//			[cCount]	Count of STATDATAs in rgStat
//
//      Returns:	S_OK if found, S_FALSE if not
//
//      Notes:
//
//      History:	23-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------


HRESULT EltIsInArray(STATDATA sdToFind, STATDATA rgStat[], DWORD cCount)
{
    HRESULT hr = S_FALSE;

    TraceLog Log(NULL, "EltIsInArray", GS_CACHE, VB_MAXIMUM);
    Log.OnEntry (" ( %p, %p, %d )\n", &sdToFind, rgStat, cCount);
    Log.OnExit  (" ( %X )\n", &hr);
    
    for (DWORD a=0; a<cCount; a++)
    {
    	if (rgStat[a].formatetc.cfFormat == sdToFind.formatetc.cfFormat   &&
	    rgStat[a].dwConnection       == sdToFind.dwConnection)
	{
	    hr = S_OK;
            break;
	}
    }

    return hr;
    
}

//+----------------------------------------------------------------------------
//
//      Function:	ConvWidthInPelsToLHM
//                      ConvHeightInPelsToLHM
//
//      Synopsis:	Converts a measurement in pixels to LOGICAL HIMETRICS.
//                      If a reference DC is given, it is used, otherwise
//                      the screen DC is used as a default.
//
//      Arguments:	[hDC]           The reference DC
//			[int]           The width or height to convert
//
//      Returns:	S_OK if found, S_FALSE if not
//
//      History:	06-Aug-94  Davepl  Copy/Paste/Cleanup
//
//-----------------------------------------------------------------------------

const LONG HIMETRIC_PER_INCH = 2540;

int ConvWidthInPelsToLHM(HDC hDC, int iWidthInPix)
{
    int             iXppli;             // Pixels per logical inch along width
    int             iWidthInHiMetric;
    BOOL            fSystemDC = FALSE;

    if (NULL == hDC)
    {
        hDC = GetDC(NULL);
        fSystemDC = TRUE;
    }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

    // We got pixel units, convert them to logical HIMETRIC along
    // the display

    iWidthInHiMetric = MulDiv(HIMETRIC_PER_INCH, iWidthInPix, iXppli);

    if (fSystemDC)
    {
        ReleaseDC(NULL, hDC);
    }

    return iWidthInHiMetric;
}

int ConvHeightInPelsToLHM(HDC hDC, int iHeightInPix)
{
    int             iYppli;             //Pixels per logical inch along height
    int             iHeightInHiMetric;
    BOOL            fSystemDC = FALSE;

    if (NULL == hDC)
    {
        hDC = GetDC(NULL);
        fSystemDC = TRUE;
    }

    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    // We got pixel units, convert them to logical HIMETRIC along the
    // display

    iHeightInHiMetric = MulDiv(HIMETRIC_PER_INCH, iHeightInPix, iYppli);

    if (fSystemDC)
    {
        ReleaseDC(NULL, hDC);
    }
   
    return iHeightInHiMetric;
}

//+----------------------------------------------------------------------------
//
//      Function:	TestInstance::UncacheFormat
//
//      Synopsis:	Uncaches the first node found in the cache that
//                      matches the format specified.
//
//      Arguments:	[cf]            Format to look for
//
//      Returns:	HRESULT
//
//      Notes:          If there are multiple nodes (ie: various apsects) of
//                      the same clipformat, only the first one found is
//                      removed.
//
//      History:	23-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------

HRESULT TestInstance::UncacheFormat(CLIPFORMAT cf)
{
    HRESULT hr;

    TraceLog Log(NULL, "TestInstance::UncacheFormat", GS_CACHE, VB_MAXIMUM);
    Log.OnEntry (" ( %d )\n", cf);
    Log.OnExit  (" ( %X )\n", &hr);

    BOOL fFound = FALSE;

    // 
    // Get an enumerator on the cache
    //

    LPENUMSTATDATA pEsd;	
    
    hr = m_pOleCache->EnumCache(&pEsd);
    
    
    if (S_OK == hr)
    {
        //
        // Loop until a failure or until we have removed all of
        // the nodes that we thought should exist
        //
        
        STATDATA stat;

        while (S_OK == hr && FALSE == fFound)
        {
            hr = pEsd->Next(1, &stat, NULL);
            
            if (S_OK == hr && stat.formatetc.cfFormat == cf)
            {
                hr = m_pOleCache->Uncache(stat.dwConnection);
                if (S_OK == hr)
                {
                     fFound = TRUE;
                }
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cachetst\genenum.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:    genenum.hxx
//
//  Contents:     Declaration of a generic enum object and test object.
//
//  Classes:    CGenEnumObject
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              23-May-94 kennethm  author! author!
//
//--------------------------------------------------------------------------

#ifndef _GENENUM_H
#define _GENENUM_H

#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <ole2.h>

//
// This macro allows the code to use a different outputstring function.
//

EXTERN_C HRESULT TestEnumerator(
            void *penum,
            size_t ElementSize,
            LONG ElementCount,
            BOOL (*verify)(void*),
            BOOL (*verifyall)(void*,LONG),
            void (*cleanup)(void*));

//
// Classes are exposed for C++ clients only
//

#ifdef __cplusplus

//+-------------------------------------------------------------------------
//
//  Class:      IGenEnum
//
//  Purpose:    generic enumerator
//
//  Interface:  Abstract class
//
//  History:    dd-mmm-yy Author    Comment
//              23-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

class IGenEnum
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
    STDMETHOD_(ULONG,AddRef)(void) = 0;
    STDMETHOD_(ULONG,Release)(void) = 0;

    STDMETHOD(Next) (ULONG celt, void *rgelt,
            ULONG *pceltFetched) = 0;
    STDMETHOD(Skip) (ULONG celt) = 0;
    STDMETHOD(Reset) (void) = 0;
    STDMETHOD(Clone) (void **ppenum) = 0;
};

//+-------------------------------------------------------------------------
//
//  Class:      CEnumeratorTest
//
//  Purpose:    enumerator test class
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
//              23-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

class CEnumeratorTest
{
public:

    //
    // Constructor
    //

    CEnumeratorTest(IGenEnum * enumtest, size_t elementsize, LONG elementcount);

    //
    // Test for each enumerator object
    //

    HRESULT TestAll(void);
    HRESULT TestNext(void);
    HRESULT TestSkip(void);
    HRESULT TestClone(void);
    HRESULT TestRelease(void);

    //
    // Verification functions
    //

    virtual BOOL Verify(void *);
    virtual BOOL VerifyAll(void*, LONG);
    virtual void Cleanup(void *);

protected:
    CEnumeratorTest();

    BOOL GetNext(ULONG celt, ULONG* pceltFetched, HRESULT* phresult);

    IGenEnum *        m_pEnumTest;
    size_t            m_ElementSize;
    LONG              m_ElementCount;
};

#endif

#endif // !_GENENUM_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cachetst\multi.cpp ===
//+----------------------------------------------------------------------------
//
//      File:
//              multi.cpp
//
//      Contents:
//              Cache node test which creates multiple nodes, then performs
//              various data tests on them.
//
//      History:
//
//              04-Sep-94       davepl  Created
//
//-----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+----------------------------------------------------------------------------
//
//      Member:         TestInstance::MultiCache
//
//      Synopsis:	Caches N unique nodes, where N is large (>100).  Saves
//                      the cache, then reloads it to compare.
//
//      Arguments:	[dwCount]       Number of new nodes to cache
//
//      Returns:	HRESULT
//
//      Notes:
//
//      History:	24-Aug-94  Davepl	Created
//
//-----------------------------------------------------------------------------

HRESULT TestInstance::MultiCache(DWORD dwCount)
{
    HRESULT hr;

    DWORD iCFGEN = 0,
          iNODES = 0,
          iSDATA = 0;

    TraceLog Log(NULL, "TestInstance::MultiCache", GS_CACHE, VB_MINIMAL);
    Log.OnEntry (" ( %d )\n", dwCount);
    Log.OnExit  (" ( %X )\n", &hr);

    //
    // A temporary buffer for creating text clipformat names
    //

    char szFormatName[ MAX_BUF ];

    //
    // An array of UINTs to hold our private clipformats, and an
    // array of DWORDS to hold the connection IDs
    //

    CLIPFORMAT *acfArray = (CLIPFORMAT *) malloc(dwCount * sizeof(CLIPFORMAT));
    if (NULL == acfArray)
    {
        return E_OUTOFMEMORY;
    }

    DWORD *adwConnections = (DWORD *) malloc(dwCount * sizeof(DWORD));
    if (NULL == adwConnections)
    {
        free(acfArray);
        return E_OUTOFMEMORY;
    }

    //
    // Generate N private clipformats
    //

    for (iCFGEN=0; iCFGEN < dwCount; iCFGEN++)
    {
        sprintf(szFormatName, "LocalFormat%d", iCFGEN);

        acfArray[iCFGEN] = (WORD) RegisterClipboardFormat(szFormatName);
        if (0 == acfArray[iCFGEN])
        {
            free(acfArray);
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }

    //
    // Cache N nodes based on those formats
    //

    FORMATETC fetc =
     		 {
  		     0,                 // Clipformat
		     NULL,		// DVTargetDevice
		     DVASPECT_CONTENT,	// Aspect
		     -1,		// Index
		     TYMED_HGLOBAL	// TYMED
		 };

    STGMEDIUM stgm;

    for (iNODES = 0; iNODES < dwCount; iNODES++)
    {
        fetc.cfFormat = acfArray[iNODES];
        hr = m_pOleCache->Cache(&fetc, ADVF_PRIMEFIRST, &adwConnections[iNODES]);

        // We are expecting the cache to return CACHE_S_FORMATETC_NOTSUPPORTED
        // for this data, since it cannot draw it.

        hr = MassageErrorCode(CACHE_S_FORMATETC_NOTSUPPORTED, hr);

        if (S_OK != hr)
        {
            break;
        }
    }

    //
    // If all went well adding the nodes, proceed to SetData into
    // each of the nodes with some unique data
    //

    if (S_OK == hr)
    {
        for (iSDATA = 0; iSDATA < dwCount; iSDATA++)
        {
            HGLOBAL hTmp = GlobalAlloc(GMEM_MOVEABLE, sizeof(DWORD));
            if (NULL == hTmp)
            {
                break;
            }
            DWORD * pdw = (DWORD *) GlobalLock(hTmp);
            if (NULL == pdw)
            {
                GlobalFree(hTmp);
                break;
            }

            //
            // Set the data in the HGLOBAL equal to the clipformat
            // for this node
            //

            *pdw = iSDATA;

            GlobalUnlock(hTmp);

            stgm.tymed = TYMED_HGLOBAL;
            stgm.hGlobal = hTmp;
            fetc.cfFormat = acfArray[iSDATA];

            hr = m_pOleCache->SetData(&fetc, &stgm, TRUE /* fRelease */);

            if (S_OK != hr)
            {
                break;
            }
        }
    }

    //
    // Save the cache and reload it
    //

    if (S_OK == hr)
    {
        hr = SaveAndReload();
    }

    //
    // Just to make things interesting, let's DiscardCache before we
    // start looking for data.  This will force the cache to demand-load
    // the data as we ask for it. Since we know the cache is not dirty,
    // there's no value (practical or from a test perspective) in asking
    // the DiscardCache to save along the way.
    //

    if (S_OK == hr)
    {
        hr = m_pOleCache2->DiscardCache(DISCARDCACHE_NOSAVE);
    }

    if (S_OK == hr)
    {
        for (iSDATA = 0; iSDATA < dwCount; iSDATA++)
        {
            //
            // For each of the cache nodes we added, try to
            // get the data that was saved in the cache under
            // that clipformat
            //

            fetc.cfFormat = acfArray[iSDATA];
            hr = m_pDataObject->GetData(&fetc, &stgm);
            if (S_OK != hr)
            {
                ReleaseStgMedium(&stgm);
                break;
            }

            //
            // Lock the HGLOBAL and compare what is in the cache
            // node to what we expect should be there (the index
            // into our clipboard format table
            //

            DWORD * pdw = (DWORD *) GlobalLock(stgm.hGlobal);
            if (NULL == pdw)
            {
                hr = E_OUTOFMEMORY;
                break;
            }

            if (*pdw != iSDATA)
            {
                hr = E_FAIL;
                GlobalUnlock(stgm.hGlobal);
                ReleaseStgMedium(&stgm);
                break;
            }

            GlobalUnlock(stgm.hGlobal);
            ReleaseStgMedium(&stgm);
        }
    }

    //
    // We want to remove all of the cache nodes we have added.
    // Unforunately, there is no easy way to do this; we have to
    // enumerate over the cache and toss nodes as we find them, even
    // though we _know_ everything about the nodes.  Sigh...
    //

    //
    // Get an enumerator on the cache
    //

    LPENUMSTATDATA pEsd;	
    if (S_OK == hr)
    {
    	hr = m_pOleCache->EnumCache(&pEsd);
    }

    //
    // Since we've got a large number of cache nodes in the cache,
    // now is a perfect time to run the generic enumerator tests on
    // the cache.
    //

    if (S_OK == hr)
    {
	hr = TestEnumerator((void *) pEsd, sizeof(STATDATA), iSDATA, NULL, NULL,NULL);
    }

    //
    // Reset the enumerator before beginning our UnCache loop.
    //

    if (S_OK == hr)
    {
    	hr = pEsd->Reset();
    }

    if (S_OK == hr)
    {
        //
        // Loop until a failure or until we have removed all of
        // the nodes that we thought should exist
        //

        STATDATA stat;

        while (S_OK == hr && iSDATA > 0)
        {
            hr = pEsd->Next(1, &stat, NULL);

            if (S_OK == hr)
            {
                hr = m_pOleCache->Uncache(stat.dwConnection);
                iSDATA--;
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cachetst\main.cpp ===
//              This is a multi-threaded app with two primary threads.  One
//              sits in the message loop, waiting specifically for WM_PAINT
//              messages which are generated by the other thread, on which
//              the actual unit test runs.
//
//              When the window thread receives an update message, it takes
//              a snapshot of the unit test state (protected by a mutex),
//              and redraws the screen accordingly.
//
//              When the unit test thread wants a resource to be drawn in
//              the main window, it places the handle to that resource (for
//              example, an HMETAFILEPICT) in the ctest object associated
//              with the window thread, then fires a screen update.  In
//              doing so, ownership of the resource is transfered from the
//              unit test thread to the window thread.  By using this
//              mechanism, the window thread can draw the resource at its
//              leisure, while the unit test proceeds.  The onus is on
//              the window thread to clean up any resources which have
//              been deposited in its care when it exists.
//
//              If the window thread receives a WM_CLOSE message, it must
//              first check to see that the unit test thread has completed.
//              If not, it spins in a RETRY/CANCEL loop until the unit test
//              thread has completed, or until the user selects CANCEL, at
//              which point execution proceeds, ignoring the WM_CLOSE.
//
//                  "OVER-ENGINEERED, AND BUILT TO STAY THAT WAY" (tm)
//


#include "headers.hxx"
#pragma hdrstop

CCacheTestApp ctest;    // Application instance
TestInstance  inst;     // Test instance

//
// Prototype for the entry-point of the unit test thread
//

unsigned long __stdcall testmain(void *);

//+---------------------------------------------------------------------------
//
//  Function:   WinMain
//
//  Synopsis:   windows entry point
//
//  Arguments:  [hInst]       --
//              [hPrevInst]   --
//              [lpszCmdLine] --
//              [nCmdShow]    --
//
//  Returns:    int
//
//  History:    05-Sep-94  davepl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

int WINAPI WinMain (HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpszCmdLine, int nCmdShow)
{
     MSG message;

     //
     // Initialize the application
     //

     if (SUCCEEDED(ctest.Initialize(hInst, hPrevInst, lpszCmdLine)))
     {
	  //
	  // Show and update the window
	  //

	  ShowWindow(ctest.Window(), nCmdShow);
	  UpdateWindow(ctest.Window());

	  //
	  // The main message loop
	  //

	  while (GetMessage(&message, NULL, NULL, NULL))
	  {
	       TranslateMessage(&message);
	       DispatchMessage(&message);
	  }
     }
     else
     {
	  return(0);
     }

     return(message.wParam);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCacheTestApp::CCacheTestApp
//
//  Synopsis:   Constructor
//
//  Arguments:  (none)
//
//  Returns:    nothing
//
//  History:    05-Sep-94   Davepl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CCacheTestApp::CCacheTestApp ()
{

}

//+---------------------------------------------------------------------------
//
//  Member:     CCacheTestApp::Initialize
//
//  Synopsis:   initializes the application
//
//  Arguments:  [hInst]       -- current instance
//              [hPrevInst]   -- previous instance
//              [lpszCmdLine] -- command line parameters
//
//  Returns:    HRESULT
//
//  History:    05-Sep-94   Davepl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

HRESULT CCacheTestApp::Initialize (HINSTANCE hInst, HINSTANCE hPrevInst, LPSTR lpszCmdLine)
{
     HRESULT      hr = S_OK;

     //
     // Register the window class
     //

     if (hPrevInst == NULL)
     {
	  WNDCLASS wndclass;

	  wndclass.style         = 0;
	  wndclass.lpfnWndProc   = CacheTestAppWndProc;

	  wndclass.cbClsExtra    = 0;
	  wndclass.cbWndExtra    = 0;

	  wndclass.hInstance     = hInst;
	  wndclass.hIcon         = LoadIcon(hInst, IDI_EXCLAMATION);
	  wndclass.hCursor       = LoadCursor(NULL, IDC_ARROW);
	  wndclass.hbrBackground = (HBRUSH)(COLOR_APPWORKSPACE + 1);
	  wndclass.lpszMenuName  = NULL;
	  wndclass.lpszClassName = CTESTAPPCLASS;

	  if (RegisterClass(&wndclass) == 0)
	  {
	       hr = HRESULT_FROM_WIN32(GetLastError());
	  }
     }

     //
     // Create the mutex
     //

     m_hMutex = CreateMutex(NULL, FALSE, NULL);
     if (NULL == m_hMutex)
     {
	hr = HRESULT_FROM_WIN32(GetLastError());
     }

     //
     // Create the window
     //

     if (SUCCEEDED(hr))
     {
	  if ((m_hWnd = CreateWindowEx(0L,
				       CTESTAPPCLASS,
				       CTESTAPPTITLE,
				       WS_OVERLAPPEDWINDOW,
				       CW_USEDEFAULT,
				       0,
				       CW_USEDEFAULT,
				       0,
				       NULL,
				       NULL,
				       hInst,
				       NULL)) == NULL)
	  {
	       hr = HRESULT_FROM_WIN32(GetLastError());
	  }
     }

     return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCacheTestApp::~CCacheTestApp
//
//  Synopsis:   Destructor
//
//  Arguments:  (none)
//
//  Returns:    nothing
//
//  History:    05-Sep-94   Davepl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CCacheTestApp::~CCacheTestApp ()
{

}

//+---------------------------------------------------------------------------
//
//  Function:   CacheTestAppWndProc
//
//  Synopsis:   window procedure
//
//  Arguments:  [hWnd]    -- window
//              [message] -- message id
//              [wParam]  -- parameter
//              [lParam]  -- parameter
//
//  Returns:    LRESULT
//
//  History:    05-Sep-94   Davepl   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
LRESULT FAR PASCAL CacheTestAppWndProc (HWND hWnd,
					UINT message,
					WPARAM wParam,
					LPARAM lParam)
{
     //
     // Process the messages
     //

     switch (message)
     {
     case WM_CREATE:

	//
	// The unit test window is opening.  Create another thread
	// on which the unit test itself runs, while this thread
	// continues to spin, waiting for redraws, close, and so
	// on...
	//

	ctest.m_hTest = CreateThread(NULL,
				     0,
				     testmain,
				     NULL,
				     0,
				     &ctest.m_dwThreadID);

	if (NULL == ctest.m_hTest)
	{
	    mprintf("Unable to begin unit test\n");
	    PostQuitMessage(0);
	}

	break;


     case WM_PAINT:
	  {
	       PAINTSTRUCT ps;
	       HDC         hDC;

	       //
	       // Get the DC for painting
	       //

	       hDC = BeginPaint(hWnd, &ps);
	       if (hDC)
	       {
		    //
		    // Draw the metafile
		    //

		    inst.Draw(hDC);

		    EndPaint(hWnd, &ps);
	       }
	  }
	  break;

     case WM_SIZE:

	  //
	  // Invalidate the rectangle
	  //

	  InvalidateRect(hWnd, NULL, TRUE);
	  return DefWindowProc(hWnd, message, wParam, lParam);
	  break;

     case WM_CLOSE:

	{
	    //
	    // The user has tried to exit the main program.  Before we
	    // can shut down, we must wait until the child thread has
	    // completed.  We allow the user to keep retrying on the
	    // thread, or to "cancel" and wait until later.  We do not
	    // provide the option of terminating the child thread while
	    // it is still busy.
	    //

	    DWORD dwStatus = 0;

	    if (FALSE == GetExitCodeThread(ctest.m_hTest, &dwStatus))
	    {
		mprintf("Could not get thread information!");
		break;
	    }
	    else
	    {
		INT response = IDRETRY;

		while (STILL_ACTIVE == dwStatus)
		{
		    response = MessageBox(ctest.Window(),
			       "The child thread has not yet completed.",
			       "Cannot Shutdown",
			       MB_RETRYCANCEL);

		    if (IDCANCEL == response)
		    {
			break;
		    }
		
		}
	    }
	
	    //
	    // Destroy the window if the child has gone away
	    //

	    if (STILL_ACTIVE != dwStatus)
	    {
		DestroyWindow(hWnd);
	    }

	    break;
	}

     case WM_DESTROY:
	
	  PostQuitMessage(0);
	  break;


     default:
	  return DefWindowProc(hWnd, message, wParam, lParam);
     }

     return NULL;
}

//+----------------------------------------------------------------------------
//
//      Member:
//
//      Synopsis:
//
//      Arguments:
//
//      Returns:        HRESULT
//
//      Notes:
//
//      History:        23-Aug-94  Davepl       Created
//
//-----------------------------------------------------------------------------

unsigned long __stdcall testmain(void *)
{
    HRESULT hr;

    hr = inst.CreateAndInit( OLESTR("mystg") );

    if (S_OK != hr)
    {
	mprintf("Cache Unit Test Failed [CreateAndInit] hr = %x\n", hr);
	goto exit;
    }

    hr = inst.EnumeratorTest();
    if (S_OK != hr)
    {
	mprintf("Cache Unit Test Failed [EnumeratorTest] hr = %x\n", hr);
	goto exit;
    }

    hr = inst.MultiCache(50);
    if (S_OK != hr)
    {
	mprintf("Cache Unit Test Failed [MultiCache] hr = %x\n", hr);
	goto exit;
    }

    hr = inst.CacheDataTest("TIGER.BMP", "TIGERNPH.WMF");
    if (S_OK != hr)
    {
	mprintf("Cache Unit Test Failed [CacheDataTest] hr = %x\n", hr);
	goto exit;
    }

exit:

    PostMessage(ctest.Window(), WM_CLOSE, (WPARAM) hr, 0);
    return (ULONG) hr;

}


//+----------------------------------------------------------------------------
//
//      Member:         TestInstance::TestInstance
//
//      Synopsis:       Constructor
//
//      Arguments:
//
//      Returns:
//
//      Notes:
//
//      History:        23-Aug-94  Davepl       Created
//
//-----------------------------------------------------------------------------

TestInstance::TestInstance()
{

    m_pStorage        = NULL;
    m_pPersistStorage = NULL;
    m_pOleCache       = NULL;
    m_pOleCache2      = NULL;
    m_pDataObject     = NULL;
    m_pViewObject     = NULL;
    m_State           = TEST_STARTING;
}

TestInstance::~TestInstance()
{
    //
    // Release our interface pointers
    //

    if (m_pDataObject)
    {
	m_pDataObject->Release();
    }

    if (m_pViewObject)
    {
	m_pViewObject->Release();
    }

    if (m_pPersistStorage)
    {
	m_pPersistStorage->Release();
    }

    if (m_pOleCache2)
    {
	m_pOleCache2->Release();
    }

    if (m_pOleCache)
    {
	m_pOleCache->Release();
    }

    if (m_pStorage)
    {
	m_pStorage->Release();
    }
}

//+----------------------------------------------------------------------------
//
//      Member:         TestInstance::CreateAndInit
//
//      Synopsis:       Creates a cache and sets up internal interface ptrs
//
//      Arguments:      (none)
//
//      Returns:        HRESULT
//
//      Notes:
//
//      History:        23-Aug-94  Davepl       Created
//
//-----------------------------------------------------------------------------

HRESULT TestInstance::CreateAndInit(LPOLESTR lpwszStgName)
{
    HRESULT hr;

    TraceLog Log(this, "TestInstance::CreateAndInit", GS_CACHE, VB_MINIMAL);
    Log.OnEntry (" ( %p ) \n", lpwszStgName);
    Log.OnExit  (" ( %X ) \n", &hr);
	
    //
    // Create the storage on which we will instantiate our cache
    //

    // BUGBUG use correct strcpy fn

    wcscpy(m_wszStorage, lpwszStgName);

    hr = StgCreateDocfile(lpwszStgName,
			  STGM_DIRECT |
			  STGM_READWRITE |
			  STGM_SHARE_EXCLUSIVE |
			  STGM_CREATE,
			  0,
			  &m_pStorage);

    //
    // Create a Data Cache on our IStorage
    //

    if (S_OK == hr)
    {
	hr = CreateDataCache(NULL,
			 CLSID_NULL,
			 IID_IPersistStorage,
			 (void **)&m_pPersistStorage);
    }

    if (S_OK == hr)
    {
	hr = m_pPersistStorage->InitNew(m_pStorage);
    }

    //
    // Get an IOleCache interface pointer to the cache
    //

    if (S_OK == hr)
    {
	hr = m_pPersistStorage->QueryInterface(IID_IOleCache,
					       (void **) &m_pOleCache);
    }

    //
    // Get an IOleCache2 interface pointer to the cache
    //

    if (S_OK == hr)
    {
	hr = m_pPersistStorage->QueryInterface(IID_IOleCache2,
					       (void **) &m_pOleCache2);
    }

    //
    // Get an IViewObject interface pointer to the cache
    //

    if (S_OK == hr)
    {
	hr = m_pPersistStorage->QueryInterface(IID_IViewObject,
					       (void **) &m_pViewObject);
    }

    //
    // Get an IDataObject interface pointer to the cache
    //

    if (S_OK == hr)
    {
	hr = m_pPersistStorage->QueryInterface(IID_IDataObject,
					       (void **) &m_pDataObject);
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//      Member:         TestInstance::SaveAndReload
//
//      Synopsis:       Saves the cache to its storage and reloads it
//                      right back.
//
//      Arguments:      (none)
//
//      Returns:        HRESULT
//
//      Notes:          Once saved, the behavior of DiscardCache will
//                      change, since each node present at the time of
//                      save will have a stream from which it can demand
//                      load its data.
//
//                      Since each interface pointer is released and
//                      reaquired, the pointer values will (likely) change
//                      during this call; hence, so _not_ cache the pointers
//                      locally around this call.
//
//      History:        23-Aug-94  Davepl       Created
//
//-----------------------------------------------------------------------------

HRESULT TestInstance::SaveAndReload()
{
    HRESULT hr;

    TraceLog Log(NULL, "TestInstance::SaveAndReload", GS_CACHE, VB_MINIMAL);
    Log.OnEntry ();
    Log.OnExit  (" ( %X )\n", &hr);

    SetCurrentState(SAVE_AND_RELOAD);

    hr = m_pPersistStorage->Save(m_pStorage, TRUE);

    if (S_OK == hr)
    {
       hr = m_pPersistStorage->SaveCompleted(NULL);
    }

    // Release our hold on the storage and the cache

    if (S_OK == hr)
    {
	m_pViewObject->Release();
	m_pViewObject = NULL;
	m_pDataObject->Release();
	m_pDataObject = NULL;

	m_pStorage->Release();
	m_pStorage = NULL;

	m_pPersistStorage->Release();
	m_pPersistStorage = NULL;

	m_pOleCache2->Release();
	m_pOleCache2 = NULL;

	m_pOleCache->Release();
	m_pOleCache = NULL;


	//
	// Reload the cache and QI to get our interfaces back
	//

	hr = StgOpenStorage(m_wszStorage,
			NULL,
			STGM_DIRECT |
			STGM_READWRITE |
			STGM_SHARE_EXCLUSIVE,
			NULL,
			0,
			&m_pStorage);

	//
	// Create a Data Cache on our IStorage
	//

	if (S_OK == hr)
	{
	    hr = CreateDataCache(NULL,
				 CLSID_NULL,
				 IID_IPersistStorage,
				(void **)&m_pPersistStorage);
	}
	
	if (S_OK == hr)
	{
	     hr = m_pPersistStorage->Load(m_pStorage);
	}

	//
	// Get an IOleCache interface pointer to the cache
	//

	if (S_OK == hr)
	{
	    hr = m_pPersistStorage->QueryInterface(IID_IOleCache,
					       (void **) &m_pOleCache);
	}
	
	//
	// Get an IOleCache2 interface pointer to the cache
	//

	if (S_OK == hr)
	{
	    hr = m_pPersistStorage->QueryInterface(IID_IOleCache2,
					       (void **) &m_pOleCache2);
	}

	//
	// Get an IViewObject interface pointer to the cache
	//

	if (S_OK == hr)
	{
	    hr = m_pPersistStorage->QueryInterface(IID_IViewObject,
					       (void **) &m_pViewObject);
	}

	//
	// Get an IDataObject interface pointer to the cache
	//

	if (S_OK == hr)
	{
	    hr = m_pPersistStorage->QueryInterface(IID_IDataObject,
					       (void **) &m_pDataObject);
	}
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//      Member:         TestInstance::CacheDataTest
//
//      Synopsis:       Checks the cache for data integrity
//
//      Arguments:      lpszBMPFileName - Name of .BMP file to use for test
//                      lpszWMFFileName - Name of .WMF file to use for test
//
//      Returns:        HRESULT
//
//      Notes:
//
//      History:        04-Sep-94  Davepl       Created
//
//-----------------------------------------------------------------------------

HRESULT TestInstance::CacheDataTest(char * lpszBMPFileName, char * lpszWMFFileName)
{
    HRESULT hr = S_OK;

    TraceLog Log(NULL, "TestInstance::CacheDataTest", GS_CACHE, VB_MINIMAL);
    Log.OnEntry (" ( BMP=%s, WMF=%s  )\n", lpszBMPFileName, lpszWMFFileName);
    Log.OnExit  (" ( %X )\n", &hr);

    SetCurrentState(DATA_TEST);

    CBitmapFile bmpFile;
    HGLOBAL     hDIB = NULL;
	
    //
    // Allocate an hglobal to hold our metafilepict structure
    //

    HGLOBAL hMFPICT = GlobalAlloc(GMEM_FIXED, sizeof(METAFILEPICT));
    if (NULL == hMFPICT)
    {
	hr = HRESULT_FROM_WIN32(GetLastError());
    }
    METAFILEPICT * pMFPICT = (METAFILEPICT *) hMFPICT;

    //
    // Load the bitmap from disk
    //

    if (S_OK == hr)
    {
	hr = bmpFile.LoadBitmapFile(lpszBMPFileName);
    }

    //
    // Create a DIB on an HGLOBAL from the bitmap
    //

    if (S_OK == hr)
    {
	hr = bmpFile.CreateDIBInHGlobal(&hDIB);
    }

    //
    // Add DIB and MF nodes to the cache
    //

    DWORD dwDIBCon;
    DWORD dwMFCon;

    if (S_OK == hr)
    {
	hr = AddDIBCacheNode(&dwDIBCon);
    }

    if (S_OK == hr)
    {
	hr = AddMFCacheNode(&dwMFCon);
    }

    //
    // Load the metafile from disk, then set up the
    // METAFILEPICT structure
    //

    if (S_OK == hr)
    {
	pMFPICT->hMF = GetMetaFileA(lpszWMFFileName);
	if (NULL == pMFPICT->hMF)
	{
	    hr = HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
	    //
	    // We deem the metafile to have the same extents
	    // as the the DIB.  This is completely arbitrary,
	    // but might aid in tracking down extents problems.
	    // After all, we have to pick _some_ value, so it
	    // might as well be a useful one...
	    //

	    pMFPICT->xExt = ConvWidthInPelsToLHM(NULL, bmpFile.GetDIBHeight());
	    pMFPICT->yExt = ConvHeightInPelsToLHM(NULL, bmpFile.GetDIBWidth());
	    pMFPICT->mm   = MM_ANISOTROPIC;
	}
    }

    //
    // Place the nodes in the cache.  We keep ownership of the handles,
    // which will force the cache to duplicate it.  We can then compare
    // our original with whatever we later get back from the cache.
    //

    FORMATETC fetcDIB =
		     {
			CF_DIB,
			NULL,
			DVASPECT_CONTENT,
			DEF_LINDEX,
			TYMED_HGLOBAL
		     };

    STGMEDIUM stgmDIB;

    FORMATETC fetcMF =
		     {
			CF_METAFILEPICT,
			NULL,
			DVASPECT_CONTENT,
			DEF_LINDEX,
			TYMED_MFPICT
		     };

    STGMEDIUM stgmMF;



    if (S_OK == hr)
    {
	stgmDIB.tymed   = TYMED_HGLOBAL;
	stgmDIB.hGlobal = hDIB;

	hr = m_pOleCache->SetData(&fetcDIB, &stgmDIB, FALSE);
    }

    if (S_OK == hr)
    {
	stgmMF.tymed = TYMED_MFPICT,
	stgmMF.hMetaFilePict = hMFPICT;

	hr = m_pOleCache->SetData(&fetcMF, &stgmMF, FALSE);
    }

    //
    // If we were able to place the data in the cache, check
    // to make sure whatever is in the cache matches our
    // original.
    //

    if (S_OK == hr)
    {
	hr = CompareDIB(hDIB);
	
	if (S_OK == hr)
	{
	   hr = CompareMF(hMFPICT);
	}
    }

    //
    // Save and Reload the cache to test persistance
    //

    if (S_OK == hr)
    {
	hr = SaveAndReload();
    }

    if (S_OK == hr)
    {
	SetCurrentState(DATA_TEST);
    }

    //
    // Compare the data again
    //

    if (S_OK == hr)
    {
	hr = CompareDIB(hDIB);
	
	if (S_OK == hr)
	{
	   hr = CompareMF(hMFPICT);
	}
    }

    //
    // Discard the cache.
    //

    if (S_OK == hr)
    {
	hr = m_pOleCache2->DiscardCache(DISCARDCACHE_NOSAVE);
    }

    //
    // Now compare again against the current presentations,
    // which would have to be demand-loaded after the discard.
    //
	
    if (S_OK == hr)
    {
	hr = CompareDIB(hDIB);
	
	if (S_OK == hr)
	{
	   hr = CompareMF(hMFPICT);
	}
    }


    //
    // Try to draw the cache's best presentation (which should
    // be metafile at this point) into a metafile DC which we
    // will then hand off to the window thread for drawing.
    //

    if (S_OK == hr)
    {
	hr = DrawCacheToMetaFilePict(&ctest.m_hMFP, FALSE);
	
	if (S_OK == hr)
	{
	    SetCurrentState(DRAW_METAFILE_NOW);
	}
    }

    //
    // Now draw the metafile tiled 4 times into the display
    // metafile, and hand it off...
    //

    if (S_OK == hr)
    {
	hr = DrawCacheToMetaFilePict(&ctest.m_hMFPTILED, TRUE);
	
	if (S_OK == hr)
	{
	    SetCurrentState(DRAW_METAFILETILED_NOW);
	}
    }

    //
    // Uncache the metafile node, which will leave the DIB node
    // as the best (and only) node left for drawing
    //

    if (S_OK == hr)
    {
	hr = UncacheFormat(CF_METAFILEPICT);
    }

    //
    // Now draw the DIB into a metafile and hand that off
    // to the window thread for drawing
    //

    if (S_OK == hr)
    {
	hr = DrawCacheToMetaFilePict(&ctest.m_hMFPDIB, FALSE);
	
	if (S_OK == hr)
	{
	    SetCurrentState(DRAW_DIB_NOW);
	}
    }

    //
    // Now draw the DIB again, this time tiled into the mf
    //
																	
    if (S_OK == hr)
    {
	hr = DrawCacheToMetaFilePict(&ctest.m_hMFPDIBTILED, TRUE);
	
	if (S_OK == hr)
	{
	    SetCurrentState(DRAW_DIBTILED_NOW);
	}
    }

    //
    // Cleanup our local DIB
    //

    if (hDIB)
    {
	GlobalFree(hDIB);
    }

    //
    // Cleaup our local metafile
    //

    if (pMFPICT)
    {
	if (pMFPICT->hMF)
	{
	    if (FALSE == DeleteMetaFile(pMFPICT->hMF))
	    {
		hr = HRESULT_FROM_WIN32(GetLastError());
	    }
	}

	GlobalFree(hMFPICT);
    }

    return hr;
}

HRESULT TestInstance::CompareDIB(HGLOBAL hDIB)
{
    return S_OK;
}

HRESULT TestInstance::CompareMF(HMETAFILEPICT hMFPICT)
{
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//      Member:         TestInstance::DrawCacheToMetaFilePict
//
//      Synopsis:       Draws the cache's current best presentation to
//                      a metafile, contained in a metafilepict structure,
//                      which is allocated off of the hGlobal pointer passed
//                      in by the caller
//
//      Arguments:      [phGlobal] - The ptr to the hglobal to allocate on
//                      [fTile]    - If true, the pres is tiled into the mf
//
//      Returns:        HRESULT
//
//      Notes:
//
//      History:        06-Sep-94  Davepl       Created
//
//-----------------------------------------------------------------------------

HRESULT TestInstance::DrawCacheToMetaFilePict(HGLOBAL *phGlobal, BOOL fTile)
{
    HRESULT hr = S_OK;

    TraceLog Log(NULL, "TestInstance::DrawCacheToMetaFilePict", GS_CACHE, VB_MINIMAL);
    Log.OnEntry (" ( %p, %d  )\n", phGlobal, fTile);
    Log.OnExit  (" ( %X )\n", &hr);

    //
    // Create a metafile, and have the cache draw its metafile
    // into _our_ metafile.
    //

    //
    // First, set up the METAFILEPICT structure.
    // Since ANISOTROPIC mode allows arbitrary scaling extents, we
    // pick 1000 as a nice arbitrary size.
    //
    //
	
    METAFILEPICT *pmfp = NULL;
    if (S_OK == hr)
    {
	*phGlobal = GlobalAlloc(GMEM_FIXED, sizeof(METAFILEPICT));
	if (NULL == *phGlobal)
	{
	    hr = HRESULT_FROM_WIN32(GetLastError());
	}
	else
	{
	    pmfp = (METAFILEPICT *) GlobalLock(*phGlobal);
	    if (NULL == pmfp)
	    {
		GlobalFree(*phGlobal);
		*phGlobal = NULL;
		hr = HRESULT_FROM_WIN32(GetLastError());
	    }
	    else
	    {
		pmfp->xExt = 1000;
		pmfp->yExt = 1000;
		pmfp->mm   = MM_ANISOTROPIC;
	    }
	}
    }

    //
    // Now create the metafile within the METAFILEPICT structure,
    // and ask the cache to draw to it.
    //

    HDC mfdc;
    if (S_OK == hr)
    {
	mfdc = CreateMetaFile(NULL);
	if (NULL == mfdc)
	{
	    hr = HRESULT_FROM_WIN32(GetLastError());
	    GlobalUnlock(*phGlobal);
	    GlobalFree(*phGlobal);
	    *phGlobal = NULL;
	}
    }

    //
    // If we are not tiling the metafile, we draw it exactly once,
    // scaled to fit the entire output metafile
    //

    if (S_OK == hr  && FALSE == fTile)
    {
	RECTL rcBounds  = {0, 0, 1000, 1000};
	RECTL rcWBounds = {0, 0, 1000, 1000};

	SetMapMode(mfdc, MM_ANISOTROPIC);
	SetWindowExtEx(mfdc, 1000, 1000, NULL);
	SetWindowOrgEx(mfdc, 0, 0, NULL);

	hr = m_pViewObject->Draw(DVASPECT_CONTENT, // Aspect
				 DEF_LINDEX,       // LIndex
				 NULL,             // pvAspect
				 NULL,             // ptd
				 NULL,             // hicTargetDev
				 mfdc,             // hdc to draw to
				 &rcBounds,        // rectange to draw to
				 &rcWBounds,       // bounds of our mfdc
				 NULL,             // callback fn
				 0);               // continue param
	
    }

    //
    // If we are tiling the metafile (which tests the ability of
    // the cache to offset and scale the presentation to a rect within
    // a larger metafile rect), we draw it once in each of the four
    // corners
    //

    if (S_OK == hr && TRUE == fTile)
    {
	RECTL rcBounds;
	RECTL rcWBounds = {0, 0, 1000, 1000};

	SetMapMode(mfdc, MM_ANISOTROPIC);
	SetWindowExtEx(mfdc, 1000, 1000, NULL);
	SetWindowOrgEx(mfdc, 0, 0, NULL);

	for (int a=0; a < 4 && S_OK == hr; a++)
	{
	    switch(a)
	    {
		case 0:         // Upper left hand tile

		    rcBounds.left   = 0;
		    rcBounds.top    = 0;
		    rcBounds.right  = 500;
		    rcBounds.bottom = 500;
		    break;

		case 1:         // Upper right hand tile

		    rcBounds.left   = 500;
		    rcBounds.top    = 0;
		    rcBounds.right  = 1000;
		    rcBounds.bottom = 500;
		    break;

		case 2:         // Lower left hand tile

		    rcBounds.left   = 0;
		    rcBounds.top    = 500;
		    rcBounds.right  = 500;
		    rcBounds.bottom = 1000;
		    break;

		case 3:         // Lower right hand tile

		    rcBounds.left   = 500;
		    rcBounds.top    = 500;
		    rcBounds.right  = 1000;
		    rcBounds.bottom = 1000;
		    break;
	    }
	
	    hr = m_pViewObject->Draw(DVASPECT_CONTENT, // Aspect
				     DEF_LINDEX,       // LIndex
				     NULL,             // pvAspect
				     NULL,             // ptd
				     NULL,             // hicTargetDev
				     mfdc,             // hdc to draw to
				     &rcBounds,        // rectange to draw to
				     &rcWBounds,       // bounds of our mfdc
				     NULL,             // callback fn
				     0);               // continue param
	}
    }
			
    //
    // If the draw failed, clean up the metafile DC now
    //
			
    if (S_OK != hr)
    {
	GlobalUnlock(*phGlobal);
	GlobalFree(*phGlobal);

	HMETAFILE temp = CloseMetaFile(mfdc);
	if (temp)
	{
	    DeleteMetaFile(temp);
	}
    }

    //
    // Finish up the metafile and prepare to return it to the caller
    //

    if (S_OK == hr)
    {
	pmfp->hMF = CloseMetaFile(mfdc);

	if (pmfp->hMF)
	{
	    GlobalUnlock(*phGlobal);
	}
	else
	{
	    hr = HRESULT_FROM_WIN32(GetLastError());
	    GlobalUnlock(*phGlobal);
	    GlobalFree(*phGlobal);
	    *phGlobal = NULL;
	}
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//      Member:         TestInstance::GetCurrentState
//
//      Synopsis:       Returns the state of the unit test (for drawing)
//
//      Arguments:      (none)
//
//      Returns:        HRESULT
//
//      Notes:
//
//      History:        04-Sep-94  Davepl       Created
//
//-----------------------------------------------------------------------------

TEST_STATE TestInstance::GetCurrentState()
{
    //
    // In order to avoid race conditions, we have a mutex around the
    // current state of the unit test (required because this member
    // function will be running on the window's thread, not the current
    // test instance thread.)
    //

    DWORD dwResult = WaitForSingleObject(ctest.Mutex(), INFINITE);
    if (WAIT_FAILED == dwResult)
    {
	return INVALID_STATE;
    }

    TEST_STATE tsSnapshot = m_State;

    ReleaseMutex(ctest.Mutex());

    return tsSnapshot;
}

//+----------------------------------------------------------------------------
//
//      Member:         TestInstance::SetCurrentState
//
//      Synopsis:       Sets the current (drawing) state of the unit test
//
//      Arguments:      [state] - the state to set
//
//      Returns:        HRESULT
//
//      Notes:
//
//      History:        04-Sep-94  Davepl       Created
//
//-----------------------------------------------------------------------------

void TestInstance::SetCurrentState(TEST_STATE state)
{
    //
    // In order to avoid race conditions, we have a mutex around the
    // current state of the unit test (required because this member
    // function will be running on the window's thread, not the current
    // test instance thread.)
    //

    DWORD dwResult = WaitForSingleObject(ctest.Mutex(), INFINITE);
    if (WAIT_FAILED == dwResult)
    {
	return;
    }

    m_State = state;

    ReleaseMutex(ctest.Mutex());

    //
    // Invalid the main window so it will redraw itself with the new
    // state of the test.
    //

    InvalidateRgn(ctest.Window(), NULL, FALSE);
    UpdateWindow(ctest.Window());
	
}

//+----------------------------------------------------------------------------
//
//      Member:         TestInstance::Draw
//
//      Synopsis:       Draws the current state of the unit test
//
//      Arguments:      [hdc]   - The DC to draw to
//
//      Returns:        HRESULT
//
//      Notes:          The DC is supplied, but the main window is assumed
//
//      History:        04-Sep-94  Davepl       Created
//
//-----------------------------------------------------------------------------

static char szStarting[]      = "Test is starting...";
static char szInvalid[]       = "The state of the test has become invalid...";
static char szEnumerator[]    = "Testing the cache enumerator...";
static char szSaveReload[]    = "Saving and reloading the cache and its data...";
static char szDataTest[]      = "Testing data integrity within the cache...";
static char szMulti[]         = "Testing a large number of simultaneous cache nodes...";
static char szMetafile[]      = "MF -> MF";
static char szMetafileTiled[] = "MF -> MF (Tiled)";
static char szDib[]           = "";     // Dib contains its own title

void TestInstance::Draw(HDC hdc)
{
    //
    // Retrieve the current state of the unit test
    //

    TEST_STATE tsState = GetCurrentState();

    //
    // Clear the window
    //

    RECT rect;
    if (TRUE == GetClientRect(ctest.Window(), &rect))
    {
	FillRect(hdc, &rect, (HBRUSH) GetStockObject(LTGRAY_BRUSH));
    }

    //
    // Draw the current state
    //

    int iBackMode = SetBkMode(hdc, TRANSPARENT);

    switch(tsState)
    {
	case TEST_STARTING:

	    TextOut(hdc, 10, 10, szStarting, strlen(szStarting));
	    break;

	case TESTING_ENUMERATOR:
	
	    TextOut(hdc, 10, 10, szEnumerator, strlen(szEnumerator));
	    break;

	case SAVE_AND_RELOAD:

	    TextOut(hdc, 10, 10, szSaveReload, strlen(szSaveReload));
	    break;

	case DATA_TEST:

	    TextOut(hdc, 10, 10, szDataTest, strlen(szDataTest));
	    break;

	case MULTI_CACHE:

	    TextOut(hdc, 10, 10, szMulti, strlen(szMulti));
	    break;

	case DRAW_METAFILE_NOW:
	case DRAW_METAFILETILED_NOW:
	case DRAW_DIB_NOW:
	case DRAW_DIBTILED_NOW:
	{
	    // We know now that we have to draw a metafile, so
	    // determine which of the metafiles we should be drawing,
	    // and set a handle (so we can reuse the draw code) and
	    // the description text appropriately.

	    HGLOBAL hMFP;
	    char * szDesc;
	
	    if (DRAW_METAFILE_NOW == tsState)
	    {
		hMFP = ctest.m_hMFP;
		szDesc = szMetafile;
	    }
	    else if (DRAW_METAFILETILED_NOW == tsState)
	    {
		hMFP = ctest.m_hMFPTILED;
		szDesc = szMetafileTiled;
	    }
	    else if (DRAW_DIB_NOW == tsState)
	    {
		hMFP = ctest.m_hMFPDIB;
		szDesc = szDib;
	    }
	    else if (DRAW_DIBTILED_NOW == tsState)
	    {
		hMFP = ctest.m_hMFPDIBTILED;
		szDesc = szDib;
	    }

	    TextOut(hdc, 10, 10, szDesc, strlen(szDesc));
			
	    //
	    // Now actually draw the metafile to our main window
	    //
		
	    if (hMFP)
	    {
		METAFILEPICT *pMFP = (METAFILEPICT *) GlobalLock(hMFP);
		if (NULL == pMFP)
		{
		    mprintf("Unable to lock metafile handle");
		    break;
		}

		int save = SaveDC(hdc);

		SetMapMode(hdc, pMFP->mm);
		SetWindowExtEx(hdc, pMFP->xExt, pMFP->yExt, NULL);
		
		RECT client;
		GetClientRect(ctest.Window(), &client);

		SetViewportExtEx(hdc, client.right, client.bottom, NULL);
		SetWindowOrgEx(hdc, 0, 0, NULL);
		SetViewportOrgEx(hdc, client.left, client.top, NULL);
		
		PlayMetaFile(hdc, pMFP->hMF);
		
		RestoreDC(hdc, save);

	    }
	    break;
	}

	case INVALID_STATE:
	default:

	    TextOut(hdc, 10, 10, szInvalid, strlen(szInvalid));
	    break;

    }

    SetBkMode(hdc, iBackMode);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cachetst\genforc.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:     genforc.cpp
//
//  Contents:     implementation of CEnumeratorTestForC.
//        This class is a subclass of CEnumeratorTest that calls for less
//        Implementation work than CEnumeratorTest but is less flexible.
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//--------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Member:      CEnumeratorTestForC::CEnumeratorTestForC
//
//  Synopsis:    default constructor
//
//  Arguments:
//
//  Returns:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

CEnumeratorTestForC::CEnumeratorTestForC()
{
    m_fnVerify     = NULL;
    m_fnVerifyAll  = NULL;
    m_fnCleanup    = NULL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTestForC::Verify
//
//  Synopsis:   Verify one element.
//
//  Arguments:  None
//
//  Returns:    BOOL
//
//  Algorithm:  call the user provided function or defer to the super-class
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CEnumeratorTestForC::Verify(void *pv)
{
    if (m_fnVerify)
    {
        return(m_fnVerify(pv ));
    }
    else
    {
        return(CEnumeratorTest::Verify(pv));
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTestForC::VerifyAll
//
//  Synopsis:   Verify entire array of returned results.
//
//  Arguments:  None
//
//  Returns:    BOOL
//
//  Algorithm:  call the user provided function or defer to the super-class
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CEnumeratorTestForC::VerifyAll(void *pv, LONG cl)
{
    if (m_fnVerifyAll)
    {
        return(m_fnVerifyAll(pv, cl ));
    }
    else
    {
        return(CEnumeratorTest::VerifyAll(pv, cl));
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     CEnumeratorTestForC::CleanUp
//
//  Synopsis:   Default implementation of cleanup
//
//  Arguments:  [pv] - pointer to entry enumerated
//
//  Algorithm:  call the user provided function or do nothing.
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//--------------------------------------------------------------------------

void  CEnumeratorTestForC::Cleanup(void *pv)
{
    if (m_fnCleanup)
    {
        m_fnCleanup(pv);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:      CEnumeratorTestForC::Create
//
//  Synopsis:    Static create function.
//
//  Effects:
//
//  Arguments:  [ppEnumtest]   -- TestEnumerator object pointer
//              [penum]        -- Enumerator Interface cast to void*
//              [ElementSize]  -- Size of elements return from next
//              [ElementCount] -- Numer of elements that should be in the enumeration,
//                                   -1 if unknown.
//              [verify]       -- verifies one element.
//              [verifyall]    -- verifies an array correctly contains all elements
//              [cleanup]      -- Frees any additional memory from next call.
//              [pPassedDebugLog] -- The debug log object, NULL if none.
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//  Notes:      all of the functions passed in are optional and may be NULL.
//
//--------------------------------------------------------------------------

HRESULT CEnumeratorTestForC::Create(
            CEnumeratorTestForC **ppEnumTest,
            void *penum,
            size_t ElementSize,
            LONG ElementCount,
            BOOL (*verify)(void*),
            BOOL (*verifyall)(void*,LONG),
            void (*cleanup)(void*))
{
    HRESULT               hresult = S_OK;
    CEnumeratorTestForC   *pEnumTest;

    if ((penum == NULL) || (ppEnumTest == NULL))
    {
        return(E_INVALIDARG);
    }

    *ppEnumTest = NULL;

    //
    // Create the new enumerator object
    //

    pEnumTest = new CEnumeratorTestForC();

    if (pEnumTest == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    //
    // Initialize the enumerator and reset it.
    //

    pEnumTest->m_pEnumTest      = (IGenEnum*)penum;

    pEnumTest->m_ElementSize    = ElementSize;
    pEnumTest->m_ElementCount   = ElementCount;
    pEnumTest->m_fnVerify       = verify;
    pEnumTest->m_fnVerifyAll    = verifyall;
    pEnumTest->m_fnCleanup      = cleanup;

    hresult = pEnumTest->m_pEnumTest->Reset();

    if (hresult != S_OK)
    {
        printf("IEnumnX: Reset failed (%lx)\r\n", hresult );

        delete pEnumTest;

        return(E_FAIL);
    }

    *ppEnumTest = pEnumTest;

    return(hresult);

}

//+-------------------------------------------------------------------------
//
//  Function:    TestEnumerator
//
//  Synopsis:   This is the one stop testing for C programs.
//
//  Arguments:  [pv] - pointer to entry enumerated
//
//  Algorithm:  If there is nothing special to free this implementation
//              can be used.
//
//  History:    dd-mmm-yy Author    Comment
//              24-May-94 kennethm  author
//
//--------------------------------------------------------------------------


HRESULT TestEnumerator(
            void *penum,
            size_t ElementSize,
            LONG ElementCount,
            BOOL (*verify)(void*),
            BOOL (*verifyall)(void*,LONG),
            void (*cleanup)(void*))
{
    CEnumeratorTestForC    *pEnumTest;
    HRESULT                hresult;

    hresult = CEnumeratorTestForC::Create(
                &pEnumTest,
                penum,
                ElementSize,
                ElementCount,
                verify,
                verifyall,
                cleanup);

    if (SUCCEEDED(hresult))
    {
        hresult = pEnumTest->TestAll();
        delete pEnumTest;
    }

    return(hresult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cfmex\cdir.cxx ===
//+==========================================================================
//
//  File:       CDir.cxx
//
//  Purpose:    Define the CDirectory class.
//
//              This class is used to represent a directory name.
//              Along with maintaining the name, it can determine
//              the type of FileSystem.
//
//+==========================================================================


//  --------
//  Includes
//  --------

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <wtypes.h>

#include "CFMEx.hxx"
#include "CDir.hxx"


//+------------------------------------------------------------------------------
//
//  Function:   CDirectory::Initialize (no arguments)
//
//  Synopsis:   Generate a directory name, using the TEMP environment
//              variable, and use it to initialize this object.
//
//  Inputs:     None.
//
//  Outputs:    TRUE if the function succeeds, FALSE otherwise.
//
//+------------------------------------------------------------------------------

BOOL CDirectory::Initialize()
{
    //  ---------------
    //  Local Variables
    //  ---------------

    // Assume failure for now.
    BOOL bSuccess = FALSE;

    // The TEMP environment variable.
    WCHAR wszSystemTempPath[ MAX_PATH + sizeof( L'\0' )];

    // Reset the error code.
    m_lError = 0L;

    //  ----------
    //  Get %TEMP% 
    //  ----------

    if( !GetTempPath( MAX_PATH,
                      wszSystemTempPath )
      )
    {
        m_lError = GetLastError();
        EXIT( L"GetTempPath() failed (%d)" );
    }

    //  ----------------------
    //  Initialize this object
    //  ----------------------

    // Initialize using the temporary path.  We must never pass a NULL here,
    // or we'll cause an infinite recursion.

    if( wszSystemTempPath == NULL )
        EXIT( L"Invalid temporary path" );
    bSuccess = Initialize( wszSystemTempPath );

    //  ----
    //  Exit
    //  ----

Exit:

    return( bSuccess );

}

//+-----------------------------------------------------------------------
//
//  Function:   CDirectory::Initialize (with an ANSI string)
//
//  Synopsis:   This function converts the ANSI string to a Unicode
//              string, then initializes the object with it.
//
//  Inputs:     A Unicode string.
//
//  Outputs:    TRUE if the function succeeds, FALSE otherwise.
//
//+-----------------------------------------------------------------------

BOOL CDirectory::Initialize( LPCSTR szDirectory )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    // Assume failure.
    BOOL bSuccess = FALSE;

    // A buffer for the Unicode path
    WCHAR wszDirectory[ MAX_UNICODE_PATH + sizeof( L'\0' )];

    //  -----
    //  Begin
    //  -----

    // Initialize the error code.
    m_lError = 0L;


    // If we were givin a NULL path, use the version of Initialize
    // that requires no path.

    if( szDirectory == NULL )
    {
        bSuccess = Initialize();
        goto Exit;
    }

    // Convert the Ansi name to Unicode.

    if( m_lError = (long) AnsiToUnicode( szDirectory,
                                         wszDirectory,
                                         strlen( szDirectory )
                                       )
      )
    {
        EXIT( L"Unable to convert directory to Unicode" );
    }

    // Initialize using the temporary path.  We must never pass a NULL here,
    // or we'll cause an infinite recursion.

    if( wszDirectory == NULL )
        EXIT( L"Invalid Directory (internal error)" );
    bSuccess = Initialize( wszDirectory );

    //  ----
    //  Exit
    //  ----

Exit:

    return( bSuccess );

}


//+-----------------------------------------------------------------------
//
//  Function:   CDirectory::Initialize (with a Unicode string)
//
//  Synopsis:   This function is the only form of Initialize
//              (there are several variations of the Initialize member)
//              which really initializes the object.  It stores the
//              directory name, and determines the type of filesystem
//              on which it resides.
//
//  Inputs:     A Unicode string.
//
//  Outputs:    TRUE if the function succeeds, FALSE otherwise.
//
//+-----------------------------------------------------------------------

BOOL CDirectory::Initialize( LPCWSTR wszDirectory )
{

    //  ---------------
    //  Local Variables
    //  ---------------

    // Assume failure.
    BOOL bSuccess = FALSE;

    // Buffers for the root of the path and for the volume name.
    WCHAR wszDirectoryRoot[ MAX_PATH + sizeof( L'\0' )];
    WCHAR wszVolumeName[ MAX_PATH + sizeof( L'\0' )];

    // Parameters to GetVolumeInformation which we won't use.
    DWORD   dwMaxComponentLength = 0L;
    DWORD   dwFileSystemFlags = 0L;

    //  -----
    //  Begin
    //  -----

    // Initialize the error code.
    m_lError = 0L;

    // If we were given a NULL path, use the variation of Initialization()
    // which does not require one.  Note that we will then be called again,
    // but this time with a path.

    if( wszDirectory == NULL )
    {
        bSuccess = Initialize();
        goto Exit;
    }

    // Validate the path.

    if( wcslen( wszDirectory ) > MAX_PATH )
    {
        m_lError = wcslen( wszDirectory );
        EXIT( L"Input path is too long (%d)\n" );
    }

    // Save the path to our member buffer

    wcscpy( m_wszDirectory, wszDirectory );


    //  ------------------------
    //  Get the file system name
    //  ------------------------

    // Get the root path to the directory.

    wcscpy( wszDirectoryRoot, wszDirectory );
    MakeRoot( wszDirectoryRoot );

    // Get the volume information, which will include the filesystem name.

    if( !GetVolumeInformation(  wszDirectoryRoot,   // Root path name.
                                wszVolumeName,      // Buffer for volume name
                                MAX_PATH,           // Length of the above buffer
                                NULL,               // Buffer for serial number
                                                    // Longest filename length.
                                &dwMaxComponentLength,
                                &dwFileSystemFlags, // Compression, etc.
                                m_wszFileSystemName,// Buffer for the FS name.
                                MAX_PATH )          // Length of above buffer
      )
    {
        m_lError = GetLastError();
        EXIT( L"GetVolumeInformation() failed" );
    }


    // Determine the file system type from the name.

    if( !wcscmp( m_wszFileSystemName, L"FAT" ))
        m_FileSystemType = fstFAT;

    else if( !wcscmp( m_wszFileSystemName, L"NTFS" ))
        m_FileSystemType = fstNTFS;

    else if( !wcscmp( m_wszFileSystemName, L"OFS" ))
        m_FileSystemType = fstOFS;

    else
        m_FileSystemType = fstUnknown;

    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CDirectory::Initialize( wszDirectory )" );
    return( bSuccess );

}



//
//  GetRootLength
//
//  This routine was simply copied from private\windows\shell\shelldll\tracker.cxx,
//  and should not be modified here.
//

unsigned
CDirectory::GetRootLength(const WCHAR *pwszPath)
{
    ULONG   cwcRoot = 0;
    m_lError = 0L;

    if (pwszPath == 0)
        pwszPath = L"";

    if (*pwszPath == L'\\')
    {
        //  If the first character is a path separator (backslash), this
        //  must be a UNC drive designator which must be of the form:
        //      <path-separator><path-separator>(<alnum>+)
        //          <path-separator>(<alnum>+)<path-separator>
        //
        //  This covers drives like these: \\worf\scratch\ and
        //  \\savik\win4dev\.
        //
        pwszPath++;
        cwcRoot++;

        BOOL    fMachine = FALSE;
        BOOL    fShare   = FALSE;

        if (*pwszPath == L'\\')
        {
            cwcRoot++;
            pwszPath++;

            while (*pwszPath != '\0' && *pwszPath != L'\\')
            {
                cwcRoot++;
                pwszPath++;

                fMachine = TRUE;
            }

            if (*pwszPath == L'\\')
            {
                cwcRoot++;
                pwszPath++;

                while (*pwszPath != '\0' && *pwszPath != L'\\')
                {
                    cwcRoot++;
                    pwszPath++;

                    fShare = TRUE;
                }

                //  If there weren't any characters in the machine or
                //  share portions of the UNC name, then the drive
                //  designator is bogus.
                //
                if (!fMachine || !fShare)
                {
                    cwcRoot = 0;
                }
            }
            else
            {
                cwcRoot = 0;
            }
        }
        else
        {
            cwcRoot = 0;
        }
    }
    else
    if (iswalpha(*pwszPath))
    {
        //  If the first character is an alphanumeric, we must have
        //  a drive designator of this form:
        //      (<alnum>)+<drive-separator><path-separator>
        //
        //  This covers drives like these: a:\, c:\, etc
        //

        pwszPath++;
        cwcRoot++;

        if (*pwszPath == L':')
        {
            cwcRoot++;
            pwszPath++;
        }
        else
        {
            cwcRoot = 0;
        }
    }

    //  If we have counted one or more characters in the root and these
    //  are followed by a component separator, we need to add the separator
    //  to the root length.  Otherwise this is not a valid root and we need
    //  to return a length of zero.
    //
    if ((cwcRoot > 0) && (*pwszPath == L'\\'))
    {
        cwcRoot++;
    }
    else
    {
        cwcRoot = 0;
    }

    return (cwcRoot);
}

//
//  MakeRoot
//
//  This routine was simply copied from private\windows\shell\shelldll\tracker.cxx,
//  and should not be modified here.
//


VOID
CDirectory::MakeRoot(WCHAR *pwszPath)
{
    unsigned rootlength = GetRootLength(pwszPath);
    m_lError = 0L;

    if (rootlength)
    {
        pwszPath[rootlength] = L'\0';
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cfmex\cfmex.cxx ===
//+===============================================================
//
//  File:       CFMEx.cxx
//
//  Purpose:    This file provides the main() and global functions
//              for the CreateFileMonikerEx (CFMEx) DRT.
//              This DRT tests the CreateFileMonikerEx API (new to
//              Cairo), as well as related changes to BIND_OPTS
//              (use of the BIND_OPTS2 structure).
//
//              All moniker activity is performed in the CMoniker
//              object (such as creating a bind context, creating
//              a link source file, moving it, binding it, etc.).
//
//              The test engine is in the CTest object.  When a link
//              source file is moved to test link-tracking, the
//              original and final location of the file may be
//              specified by the user (on the command-line).  CTest
//              is aware of the filesystem type (FAT, NTFS, OFS)
//              of these locations, and is aware of how that will
//              effect the results.
//
//              This file also provides global functions (not associated
//              with an object).
//
//  Usage:      cfmex [-o<Directory>] [-f<Directory>]
//
//              -o<Directory> specifies the original directory for link sources
//              -f<Directory> specifies the final directory for link sources
//
//  Examples:   cfmex
//              cfmex -oC:\ -fC:\
//
//+===============================================================


//  ----
//  TODO:
//  ----
//
// - Replace CRT calls with Win32 calls.
// - Validate the directory in CDirectory.
// - Add a flag to CDirectory to indicate "indexed".
// - Add a flag to CDirectory to indicate local vs remote.
// - Add a test to verify that the moniker returned from Reduce is
//   not a tracking moniker.
//


//  -------------
//  Include Files
//  -------------


#define _DCOM_			// Allow DCOM extensions (e.g., CoInitializeEx).

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <wtypes.h>
#include <oaidl.h>
#include <dsys.h>
#include <olecairo.h>
#include "CFMEx.hxx"
#include "CMoniker.hxx"
#include "CTest.hxx"
#include "CDir.hxx"


//  ------
//  Macros
//  ------

// Early-exit macro:  put the error message in a global array,
// and jump to Exit

WCHAR wszErrorMessage[ 512 ];

#undef EXIT
#define EXIT( error )    \
                         {\
                            wcscpy( wszErrorMessage, ##error );\
                            goto Exit;\
                         }



// Run a Test:  Display a new paragraph on the screen, run a test,
// and update stats.

#define RUN_TEST( testID )    \
                        {\
			    nTotalTests++;  \
                            wprintf( L"----------------------------------------------\n" ); \
                            wprintf( L"Test %d:  ", nTotalTests );  \
                            if( cTest.##testID ) \
                               wprintf( L"Passed\n" ); \
                            else \
                                nTestsFailed++; \
                        }


//+---------------------------------------------------------------------------------------
//
//  Function:   DisplayHelp
//
//  Synopsis:   Display a help screen with usage information.
//
//  Inputs:     None.
//
//  Outputs:    None.
//
//  Effects:    None
//
//+---------------------------------------------------------------------------------------


void DisplayHelp( void )
{

    wprintf( L"This DRT tests the CreateFileMonikerEx API, and related changes.\n"
             L"Most of these tests create a link source file, create a moniker\n"
             L"representing that file, then move the file.  You can specify the\n"
             L"original and/or final locations of the link source, or let those\n"
             L"locations default to the \%TEMP\% directory\n"
             L"\n"
             L"Usage:  cfmex [-o<Directory>] [-f<Directory>]\n"
             L"\n"
             L"Where:  -o<Directory> specifies the original directory for link sources\n"
             L"        -f<Directory> specifies the final directory for link sources\n"
             L"\n"
             L"Note:   If an original or final directory is specified on the command-\n"
             L"        line, that directory must already exist.  If one of these locations\n"
             L"        is not specified, the TEMP environment variable must be defined\n"
             L"        and it must specify an extant directory.\n"
             L"\n"
             L"E.g.:   cfmex\n"
             L"        cfmex -oC:\\\n"
             L"        cfmex -oE:\\ -fF:\\temp\n"
             L"\n" );
    return;
}



//+---------------------------------------------------------------------------------------
//
//  Function:   UnicodeToAnsi
//
//  Synopsis:   Convert a Unicode (wide) string to ANSI
//
//  Inputs:     The Unicode String
//              The buffer for the ANSI string
//              The size of the above buffer
//
//  Outputs:    0 if successful
//              GetLastError() otherwise
//
//  Effects:    None
//
//+---------------------------------------------------------------------------------------

DWORD UnicodeToAnsi( const WCHAR * wszUnicode,
                     CHAR * szAnsi,
                     int cbAnsiMax )
{
    int cbAnsi = 0;

    // Convert WCS to the MBCS, using the ANSI code page.

    cbAnsi = WideCharToMultiByte( CP_ACP,
                                  WC_COMPOSITECHECK | WC_DEFAULTCHAR,
                                  wszUnicode,
                                  wcslen( wszUnicode ),
                                  szAnsi,
                                  cbAnsiMax,
                                  NULL,
                                  NULL );
    if( !cbAnsi )
    {
        // No characters were converted - there was an error.
        // Note that this will be returned if a null Unicode string is
        // passed in.

        return( GetLastError() );
    }
    else
    {
        // Terminate the Ansi string and return.

        szAnsi[ cbAnsi ] = '\0';
        return( 0L );
    }

}   // UnicodeToAnsi()



//+---------------------------------------------------------------------------------------
//
//  Function:   AnsiToUnicode
//
//  Synopsis:   Convert an ANSI string to Unicode (i.e. Wide)
//
//  Inputs:     The ANSI String
//              The buffer for the Unicode string
//              The size of the above buffer.
//
//  Outputs:    0 if successful
//              GetLastError() otherwise
//
//  Effects:    None
//
//+---------------------------------------------------------------------------------------

DWORD AnsiToUnicode( const CHAR * szAnsi,
                     WCHAR * wszUnicode,
                     int cbUnicodeMax )
{
    int cbUnicode = 0;

    cbUnicode = MultiByteToWideChar( CP_ACP,
                                     MB_PRECOMPOSED,
                                     szAnsi,
                                     strlen( szAnsi ),
                                     wszUnicode,
                                     cbUnicodeMax );

    if( !cbUnicode )
    {
        // If no characters were converted, then there was an error.
        
        return( GetLastError() );
    }
    else
    {
        // Terminate the Unicode string and return.

        wszUnicode[ cbUnicode ] = L'\0';
        return( 0L );
    }

}   // AnsiToUnicode()



//+---------------------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Run the CFMEx DRT.  All tests are in the CTest object.  These
//              tests are simply called sequentially.
//
//  Inputs:     (argc) the count of arguments
//              (argv) the arguments.  See DisplayHelp() for a description.
//
//  Outputs:    0 if completely successful
//              1 if help was displayed
//              2 if a test failed
//
//  Effects:    None
//
//+---------------------------------------------------------------------------------------


int main( int argc, char** argv )
{

    //  ---------------
    //  Local Variables
    //  ---------------

    // Test statistics.

    int nTotalTests = 0;
    int nTestsFailed = 0;

    // The original and final directories (in ANSI) of the link source file.

    CHAR* szOriginalDirectory = NULL;
    CHAR* szFinalDirectory = NULL;

    // Objects representing the original and final directories.

    CDirectory cDirectoryOriginal;
    CDirectory cDirectoryFinal;

    // The test engine.

    CTest cTest;

    int index = 0;


    //  --------------
    //  Opening Banner
    //  --------------

    printf( "\n"
            "*** CreateFileMonikerEx DRT ***\n"
            "(use \"cfmex -?\" for help)\n"
            "\n" );


    //  ------------------------------
    //  Handle command-line parameters
    //  ------------------------------


    for( index = 1; index < argc; index++ )
    {
        // The first character of an argument should be an "-" or "/"
        // (they are interchangable).

        if( ( ( argv[index][0] != '-' )
              &&
              ( argv[index][0] != '/' )
            )
            ||
            ( strlen( &argv[index][0] ) < 2 )  // Must have more than '-' & an option.
          )
        {
            printf( "Invalid argument ignored:  %s\n", argv[ index ] );
            continue;
        }


        // Switch based on the first character (which defines the option).

        switch( argv[index][1] )
        {
            // Help requested

            case '?':
                DisplayHelp();
                exit( 1 );

            // An original directory is specified.

            case 'o':
            case 'O':

                // Verify the specified path length.

                if( strlen( &argv[index][2] ) > MAX_PATH )
                {
                    printf( "Path is too long, ignored:  %s\n", &argv[index][2] );
                    break; // From the switch
                }

                szOriginalDirectory = &argv[index][2];
                break;  // From the switch

            // A final directory is specified

            case 'f':
            case 'F':

                if( strlen( &argv[index][2] ) > MAX_PATH )
                {
                    printf( "Path is too long, ignored:  %s\n", &argv[index][2] );
                    break; // From the switch
                }

                szFinalDirectory = &argv[index][2];
                break;  // From the switch

            // Invalid argument.

            default:

                printf( "Invalid option ignored:  \"-%c\"\n", argv[index][1] );
                break;
        }
    }

    //  --------------
    //  Initialization
    //  --------------

    // Initialize COM

    CoInitialize( NULL );


    // Initialize the CDirectory and CTest objects.  If no original/final
    // directory was specified above, CDirectory will create a default
    // (based on %TEMP%).

    if( !cDirectoryOriginal.Initialize( szOriginalDirectory ) )
        EXIT( L"Could not initialize cDirectoryOriginal" );

    if( !cDirectoryFinal.Initialize( szFinalDirectory ) )
        EXIT( L"Could not initialize cDirectoryFinal" );

    if( !cTest.Initialize( cDirectoryOriginal, cDirectoryFinal ) )
        EXIT( L"Could not initialize CTest" );


    //  Show the end result.

    wprintf( L"Link sources will be created in \"%s\" (%s)\n",
             cDirectoryOriginal.GetDirectoryName(),
             cDirectoryOriginal.GetFileSystemName() );
    wprintf( L"and will be moved to \"%s\" (%s)\n",
             cDirectoryFinal.GetDirectoryName(),
             cDirectoryFinal.GetFileSystemName() );


    //  ---------
    //  Run Tests
    //  ---------

    RUN_TEST( GetOversizedBindOpts() );
    RUN_TEST( GetUndersizedBindOpts() );
    RUN_TEST( SetOversizedBindOpts() );
    RUN_TEST( SetUndersizedBindOpts() );
    RUN_TEST( CreateFileMonikerEx() );
    RUN_TEST( GetDisplayName() );
    RUN_TEST( GetTimeOfLastChange() );
    RUN_TEST( ComposeWith() );
    RUN_TEST( IPersist() );
    RUN_TEST( BindToStorage() );
    RUN_TEST( BindToObject() );
    RUN_TEST( DeleteLinkSource( 0 ));           // Timeout immediately.
    RUN_TEST( DeleteLinkSource( 200 ));         // Timeout in multi-threaded search
    RUN_TEST( DeleteLinkSource( INFINITE ));    // Don't timeout

    //  ----
    //  Exit
    //  ----

Exit:

    // Show test results.

    wprintf( L"\n\nTesting complete:\n"
                 L"   Total Tests = %d\n"
                 L"   Failed =      %d\n",
             nTotalTests, nTestsFailed );

    // Free COM

    CoUninitialize();

    return( nTestsFailed ? 2 : 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cfmex\cmoniker.cxx ===
//+=======================================================================
//
//  File:       CMoniker.cxx
//
//  Purpose:    Define the CMoniker class.
//
//              This class provides for all handling of monikers in
//              the CreateFileMonikerEx DRT.  Not only does it maintain
//              a file moniker, it also maintains the represented link
//              source file, and a bind context.
//
//+=======================================================================

//  --------
//  Includes
//  --------

#define _DCOM_			// Allow DCOM extensions (e.g., CoInitializeEx).

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <wtypes.h>
#include <oaidl.h>
#include <dsys.h>
#include <olecairo.h>
#include "CFMEx.hxx"
#include "CMoniker.hxx"


//+-------------------------------------------------------------------------
//  
//  Function:   CMoniker::CMoniker
//
//  Synopsis:   Simply initialize all member variables.
//
//  Inputs:     None.
//
//  Outputs:    N/A
//
//  Effects:    Members are defaulted/initialized.
//
//+-------------------------------------------------------------------------


CMoniker::CMoniker()
{
    *m_wszSystemTempPath = L'\0';
    *m_wszTemporaryStorage = L'\0';
    m_pIMoniker = NULL;
    m_pIBindCtx = NULL;
    m_pIStorage = NULL;
    *m_wszErrorMessage = L'\0';
    m_dwTrackFlags = 0L;
    m_hkeyLinkTracking = NULL;
    m_hr = 0L;
    m_bSuppressErrorMessages = FALSE;
    m_pcDirectoryOriginal = NULL;
    m_pcDirectoryFinal = NULL;

    return;

}   // CMoniker::CMoniker()


//+--------------------------------------------------------------------------
//
//  Function:   CMoniker::~CMoniker
//
//  Synopsis:   Release any COM objects.
//
//  Inputs:     N/A
//
//  Outputs:    N/A
//
//  Effects:    All COM objects are released.
//
//+--------------------------------------------------------------------------


CMoniker::~CMoniker()
{
    if( m_pIMoniker )
    {
        m_pIMoniker->Release();
        m_pIMoniker = NULL;
    }

    if( m_pIBindCtx )
    {
        m_pIBindCtx->Release();
        m_pIBindCtx = NULL;
    }

    if( m_pIStorage )
    {
        m_pIStorage->Release();
        m_pIStorage = NULL;
    }

    return;

}   // CMoniker::~CMoniker()


//+-----------------------------------------------------------------------
//
//  Function:   CMoniker::Initialize
//
//  Synopsis:   Keep pointers to the CDirectory objects passed in.
//
//  Inputs:     A CDirectory object for the original link source file location
//              A CDirectory object for the final location
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    The member CDirectory objects are set.
//
//+-----------------------------------------------------------------------


BOOL CMoniker::Initialize( const CDirectory& cDirectoryOriginal,
                           const CDirectory& cDirectoryFinal )
{
    m_hr = S_OK;

    m_pcDirectoryOriginal = &cDirectoryOriginal;
    m_pcDirectoryFinal = &cDirectoryFinal;

    return( TRUE ); // Success

}   // CMoniker::Initialize()


//+-----------------------------------------------------------------------------
//
//  Function:   CMoniker::CreateFileMonikerEx
//
//  Synopsis:   Create a tracking file moniker.  But before doing so, initialize
//              the Bind Context, and create a link source file.
//
//  Inputs:     Track Flags (from the TRACK_FLAGS defines)
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    The member bind context is initialized, and a link
//              source file is created.
//
//+-----------------------------------------------------------------------------


BOOL CMoniker::CreateFileMonikerEx( DWORD dwTrackFlags )
{

    //  ---------------
    //  Local Variables
    //  ---------------

    // Assume failure
    BOOL bSuccess = FALSE;

    //  -----
    //  Begin
    //  -----

    // Initialize the error code.

    m_hr = S_OK;

    // Free any existing IMoniker.

    if( m_pIMoniker )
    {
        m_pIMoniker->Release();
        m_pIMoniker = NULL;
    }

    // Initialize the bind context.

    if( !InitializeBindContext() )
        EXIT( L"Could not initialize the bind context" );

    // Create a root storage for use as a link source.

    if( !CreateTemporaryStorage() )
        EXIT( L"Could not create temporary Storage" );

    // Create a tracking File Moniker on that root storage.

    m_hr = ::CreateFileMonikerEx( dwTrackFlags, m_wszTemporaryStorage, &m_pIMoniker );
    EXIT_ON_FAILED( L"Failed CreateFileMonikerEx" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CMoniker::CreateFileMonikerEx" );
    return( bSuccess );

}   // CMoniker::CreateFileMonikerEx()


//+---------------------------------------------------------------------
//
//  Function:   CMoniker::SaveDeleteLoad
//
//  Synopsis:   This function exercises a moniker's IPersistStream interface.
//              It creates saves the member moniker's persistent state to
//              a stream, deletes the moniker, and then re-creates it
//              using CreateFileMoniker (no Ex, so it's not a tracking
//              file moniker).  It then re-loads the original moniker's
//              persistent state.
//
//  Inputs:     None.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    The member moniker is deleted, re-created, and re-loaded.
//
//+---------------------------------------------------------------------


BOOL CMoniker::SaveDeleteLoad()
{
    //  ---------------
    //  Local Variables
    //  ---------------

    // Assume failure
    BOOL bSuccess = FALSE;
    HRESULT hr = E_FAIL;

    IStream*        pStream = NULL;
    IPersistStream* pIPersistStream = NULL;
    LARGE_INTEGER   li;
    ULARGE_INTEGER  uli;

    //  -----
    //  Begin
    //  -----

    // Initialize the error code.

    m_hr = S_OK;

    // Verify that we have a member moniker.

    if( !m_pIMoniker )
        EXIT( L"Attempt to run SaveDeleteLoad test without an existing file moniker" );


    //  ------------------------
    //  Save the moniker's state
    //  ------------------------

    // Get the moniker's IPersistStream interface

    m_hr = m_pIMoniker->QueryInterface( IID_IPersistStream, (void **) &pIPersistStream );
    EXIT_ON_FAILED( L"Failed 1st IMoniker::QueryInterface(IPersistStream)" );

    // Create a stream

    hr = CreateStreamOnHGlobal( NULL,   // Auto alloc
                                TRUE,   // Delete on release
                                &pStream );
    EXIT_ON_FAILED( L"Failed CreateStreamOnHGlobal()" );

    // Save the moniker's state to this stream.

    hr = pIPersistStream->Save( pStream, TRUE /* Clear dirty*/ );
    EXIT_ON_FAILED( L"Failed IPersistStream::Save()" );

    //  ------------------
    //  Delete the moniker
    //  ------------------

    // Release all interfaces for the moniker.

    m_pIMoniker->Release();
    pIPersistStream->Release();

    m_pIMoniker = NULL;
    pIPersistStream = NULL;

    //  --------------------
    //  Create a new moniker
    //  --------------------
    
    // Create a new moniker, using the non-Ex version of the function.

    m_hr = ::CreateFileMoniker( m_wszTemporaryStorage, &m_pIMoniker );
    EXIT_ON_FAILED( L"Failed CreateFileMoniker()" );

    //  --------------------
    //  Load the new moniker
    //  --------------------

    // Get the IPersisStream interface

    m_hr = m_pIMoniker->QueryInterface( IID_IPersistStream, (void **) &pIPersistStream );
    EXIT_ON_FAILED( L"Failed 2nd IMoniker::QueryInterface(IPersistStream)" );

    // Re-seek the stream to the beginning.

    li.LowPart = li.HighPart = 0L;
    hr = pStream->Seek( li, STREAM_SEEK_SET, &uli );
    EXIT_ON_FAILED( L"Failed IStream::Seek()" );
    if( uli.LowPart || uli.HighPart ) EXIT( L"Incorrect IStream::Seek()" );

    // Re-load the moniker from the stream.

    m_hr = pIPersistStream->Load( pStream );
    EXIT_ON_FAILED( L"Failed IPersistStream::Load()" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    // Clean up the stream and the IPersistStream interface.

    if( pStream )
       pStream->Release;

    if( pIPersistStream )
       pIPersistStream->Release();


    DisplayErrors( bSuccess, L"CMoniker::SaveDeleteLoad()" );
    return( bSuccess );

}   // CMoniker::SaveDeleteLoad()


//+------------------------------------------------------------------
//
//  Function:   CMoniker::ComposeWith
//
//  Synopsis:   Compose a tracking moniker with a non-tracking moniker
//              on the right.  (The resulting moniker should be tracking,
//              but this is not relevant to this function; that is, whether
//              or not the composed moniker is tracking, this function will
//              succeed.)
//
//  Inputs:     None.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    The member moniker is deleted, then recreated.
//
//+------------------------------------------------------------------

BOOL CMoniker::ComposeWith()
{

    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    IMoniker* pmkrFirst = NULL;
    IMoniker* pmkrSecond = NULL;
    HRESULT hr = E_FAIL;

    WCHAR  wszDirectoryName[ MAX_PATH + sizeof( L'\0' ) ];
    WCHAR* wszFileName = NULL;

    //  -----
    //  Begin
    //  -----

    // Initiailize the error code.

    m_hr = S_OK;

    // If we have a moniker already, delete it.

    if( m_pIMoniker )
    {
        m_pIMoniker->Release();
        m_pIMoniker = NULL;
    }

    // Verify we already have a link source file created.

    if( !wcslen( m_wszTemporaryStorage ) )
        EXIT( L"Attempt to use ComposeWith without first creating a link source.\n" );

    //  -----------------------------------------------
    //  Create a tracking and non-tracking file moniker
    //  -----------------------------------------------

    // Parse the storage's filename into a path and a file ...
    // for example, "C:\Temp\file.tmp" would become
    // "C:\Temp" and "file.tmp".
    //
    // First, make a copy of the storage's complete path name,
    // then replace the last '\\' with a '\0', thus creating two
    // strings.

    wcscpy( wszDirectoryName, m_wszTemporaryStorage );
    wszFileName = wcsrchr( wszDirectoryName, L'\\' );
    *wszFileName = L'\0';
    wszFileName++;

    // Create a tracking file moniker using the directory name.

    m_hr = ::CreateFileMonikerEx( 0L, wszDirectoryName, &pmkrFirst );
    EXIT_ON_FAILED( L"Failed 1st CreateFileMoniker()" );

    // Create a non-tracking file moniker using the file name.

    m_hr = ::CreateFileMoniker( wszFileName, &pmkrSecond );
    EXIT_ON_FAILED( L"Failed 2nd CreateFileMoniker()" );

    //  -------
    //  Compose
    //  -------

    // Compose the directory name moniker (on the left) with the file name moniker
    // (on the right).  Put the result in the member moniker.

    m_hr = pmkrFirst->ComposeWith( pmkrSecond, TRUE, &m_pIMoniker );
    EXIT_ON_FAILED( L"Failed IMoniker::ComposeWith" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    // Clean up the intermediary monikers.

    if( pmkrFirst )
        pmkrFirst->Release();

    if( pmkrSecond )
        pmkrSecond->Release();

    DisplayErrors( bSuccess, L"CMoniker::ComposeWith()" );
    return( bSuccess );

}   // CMoniker::ComposeWith()


//+--------------------------------------------------------------------
//
//  Function:   CMoniker::CreateTemporaryStorage
//
//  Synopsis:   This function creates a Structured Storage
//              in the directory identified by m_cDirectoryOriginal.
//              The name of the file is randomly generated by the system,
//              but begins with "MKR" and has the extension ".tmp".
//
//  Inputs:     None.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    Stores the Structure Storage's name in
//              m_wszTemporaryStorageName, and releases m_pIStorage if
//              it is currently set.
//
//+--------------------------------------------------------------------


BOOL CMoniker::CreateTemporaryStorage()
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL    bSuccess = FALSE;

    DWORD   dwError = 0L;
    UINT    nError = 0;


    //  -----
    //  Begin
    //  -----

    m_hr = S_OK;

    // Delete any existing storage.

    if( wcslen( m_wszTemporaryStorage ))
    {
        if( !DeleteTemporaryStorage() )
            EXIT( L"Could not delete the existing temporary storage" );
    }

    // Generate a temporary filename.

    nError = GetTempFileName(  m_pcDirectoryOriginal->GetDirectoryName(),
                               L"MKR",  // Prefix string.
                               0,       // Generate random number,
                               m_wszTemporaryStorage );
    if( nError == 0 )
    {
        m_hr = (HRESULT) GetLastError();
        EXIT( L"Failed GetTempFileName()" );
    }

    // Create a root Storage.

    m_hr = StgCreateDocfile( m_wszTemporaryStorage,
                             STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT,
                             0L,    // Reserved
                             &m_pIStorage );
    EXIT_ON_FAILED( L"Failed StgCreateDocfile()" );


    //  Release the storage.

    m_pIStorage->Release();
    m_pIStorage = NULL;

    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:


    DisplayErrors( bSuccess, L"CMoniker::CreateTemporaryStorage()" );
    return( bSuccess );

}   // CMoniker::CreateTemporaryStorage()


//+-------------------------------------------------------------------------
//
//  Function:   CMoniker::RenameTemporaryStorage
//
//  Synopsis:   Rename the link source file (who's name is in m_wszTemporaryStorage)
//              to the m_cDirectoryFinal directory, with a new name.
//              The current name is "MKR#.tmp" (where "#" is a random number
//              generated by the system), and the new name is "RKM#.tmp" (where
//              "#" is the same random number).  (We must rename the base file
//              name, rather than its extension, because otherwise the default
//              link-tracking would fail (it would only score the renamed file
//              a 32 - by matching the file extension the score is 40.)
//
//  Inputs:     None.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    The link source file is renamed, and it's new name is
//              put into m_wszTemporaryStorage.
//
//+-------------------------------------------------------------------------


BOOL CMoniker::RenameTemporaryStorage()
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;
    int  nError = 0;

    WCHAR  wszNewName[ MAX_PATH + sizeof( L'\0' ) ];
    WCHAR* wszOldFileName;
    WCHAR  wszNewFileName[ MAX_PATH + sizeof( L'\0' ) ];

    char   szOldName[ MAX_PATH + sizeof( L'\0' ) ];
    char   szNewName[ MAX_PATH + sizeof( L'\0' ) ];


    //  -----
    //  Begin
    //  -----

    m_hr = S_OK;

    // Verify that we already have a link source created.

    if( !wcslen( m_wszTemporaryStorage ))
        EXIT( L"No temporary storage to rename." );

    // Locate the file name within the complete path.
    // (E.g., find the "foo.txt" in "C:\TEMP\foot.txt".)

    wszOldFileName = wcsrchr( m_wszTemporaryStorage, L'\\' );
    if( !wszOldFileName )
        EXIT( L"Could not extract old file name from temporary storage name\n" );
    wszOldFileName++; // Get past the '\\'

    // Generate the new file name (change "MKR" to "RKM").
    
    wcscpy( wszNewFileName, wszOldFileName );

    wszNewFileName[0] = L'R';
    wszNewFileName[1] = L'K';
    wszNewFileName[2] = L'M';

    // Generate the complete path spec of the new file.

    wcscpy( wszNewName, m_pcDirectoryFinal->GetDirectoryName() );
    wcscat( wszNewName, wszNewFileName );


    // Convert the new and old file names to ANSI.

    if( m_hr = UnicodeToAnsi( m_wszTemporaryStorage, szOldName, sizeof( szOldName )) )
    {
        EXIT( L"Could not convert convert Unicode to Ansi for old name" );
    }

    if( m_hr = UnicodeToAnsi( wszNewName, szNewName, sizeof( szNewName )) )
    {
        EXIT( L"Could not convert convert Unicode to Ansi for new name" );
    }


    // Rename the file.

    nError = rename( szOldName, szNewName );
    if( nError )
    {
        m_hr = (HRESULT) errno;
        EXIT( L"Failed rename()" );
    }

    // Record the new name.

    wcscpy( m_wszTemporaryStorage, wszNewName );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CMoniker::RenameTemporaryStorage()" );
    return( bSuccess );

}   // CMoniker::RenameTemporaryStorage()


//+--------------------------------------------------------------------
//
//  Function:   CMoniker::DeleteTemporaryStorage
//
//  Synopsis:   Delete the temporary storage that this object uses
//              as a link source for the moniker.  The name of the
//              storage is in m_wszTemporaryStorage.
//
//  Inputs:     None.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    The link source file is deleted, and m_wszTemporaryStorage
//              is set to a NULL string.
//
//+--------------------------------------------------------------------


BOOL CMoniker::DeleteTemporaryStorage()
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    int  nError = 0;
    CHAR szTemporaryStorage[ MAX_PATH + sizeof( '\0' ) ];

    //  -----
    //  Begin
    //  -----

    m_hr = S_OK;

    // Don't do anything if we have no file (don't report an
    // error either; the caller wants the file deleted, and it's
    // already not there).

    if( wcslen( m_wszTemporaryStorage ))
    {

        // Get the file name in ANSI.

        if( m_hr = UnicodeToAnsi( m_wszTemporaryStorage, szTemporaryStorage, sizeof( szTemporaryStorage )))
            EXIT( L"Could not convert unicode path to ANSI path" );

        // Delete the file.

        nError = unlink( szTemporaryStorage );
        if( nError )
        {
            m_hr = (HRESULT) errno;
            EXIT( L"Failed unlink()" );
        }

        // Clear the file name.

        wcscpy( m_wszTemporaryStorage, L"" );
    }

    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CMoniker::DeleteTemporaryStorage()" );
    return( bSuccess );

}   // CMoniker::DeleteTemporaryStorage()




//+-----------------------------------------------------------------
//
//  Function:   CMoniker::Reduce
//
//  Synopsis:   Perform a IMoniker::Reduce on the member moniker.
//              
//  Inputs:     -   Number of ticks until the deadline for completion of
//                  the operation.
//              -   A buffer into which to put the reduced IMoniker*
//                  (may be NULL).
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+-----------------------------------------------------------------


BOOL CMoniker::Reduce( DWORD dwDelay, IMoniker** ppmkReturn )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;
    IMoniker* pmkReduced = NULL;
    BIND_OPTS2 bind_opts;
    bind_opts.cbStruct = sizeof( BIND_OPTS2 );

    //  -----
    //  Begin
    //  -----

    m_hr = S_OK;

    //  ----------
    //  Initialize
    //  ----------

    // Initialize the return buffer, if extant.

    if( ppmkReturn )
        *ppmkReturn = NULL;

    // Validate our state.

    if( !m_pIMoniker )
        EXIT( L"No moniker exists to be reduced" );

    //  ----------------
    //  Set the deadline
    //  ----------------

    // Get the BIND_OPTS from the bind context.

    m_hr = m_pIBindCtx->GetBindOptions( (LPBIND_OPTS) &bind_opts );
    EXIT_ON_FAILED( L"Failed IBindCtx::GetBindOptions" );

    // Determine what the tick count of the deadline is.

    if( dwDelay == INFINITE )
    {
        bind_opts.dwTickCountDeadline = 0;
    }
    else
    {
        bind_opts.dwTickCountDeadline = GetTickCount() + dwDelay;

        // Make sure the resulting tick count is not 0 (indicating no
        // deadline).

        if( bind_opts.dwTickCountDeadline == 0 )
            bind_opts.dwTickCountDeadline++;
    }

    // Put the resulting BIND_OPTS back into the bind context.

    m_hr = m_pIBindCtx->SetBindOptions( (LPBIND_OPTS) &bind_opts );
    EXIT_ON_FAILED( L"Failed IBindCtx::SetBindOptions" );

    
    //  ------------------
    //  Reduce the Moniker
    //  ------------------

    m_hr = m_pIMoniker->Reduce( m_pIBindCtx,
                                MKRREDUCE_ALL,
                                NULL,
                                &pmkReduced );
    EXIT_ON_FAILED( L"Failed IMoniker::Reduce" );

    // Return the reduced moniker to the caller (if so requested).

    if( ppmkReturn )
    {
        // Transfer responsibility for the release to the caller.
        *ppmkReturn = pmkReduced;
        pmkReduced = NULL;
    }

    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CMoniker::Reduce()" );

    if( pmkReduced )
	    pmkReduced->Release();

    return( bSuccess );

}   // CMoniker::Reduce()



//+----------------------------------------------------------------------
//
//  Function:   CMoniker::GetDisplayName
//
//  Synopsis:   Get the moniker's display name.
//
//  Inputs:     A Unicode buffer for the display name, and (optionally)
//              a moniker from which to get the display name.  If such
//              a moniker is not provided by the caller, then the member
//              moniker is used.
//
//              The unicode buffer must be long enough for MAX_PATH characters
//              and a terminating NULL.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+----------------------------------------------------------------------


BOOL CMoniker::GetDisplayName( WCHAR * wszDisplayName, IMoniker* pmnkCaller )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    WCHAR* wszReturnedDisplayName = NULL;
    IMoniker* pmnk = NULL;

    //  -----
    //  Begin
    //  -----

    m_hr = NOERROR;

    // Determine which moniker to use, the caller-specified one or
    // the member one.

    if( pmnkCaller != NULL )
        pmnk = pmnkCaller;
    else
        pmnk = m_pIMoniker;

    if( !pmnk )
        EXIT( L"Attempt to GetDisplayName on NULL moniker" );

    // Get the display name from the moniker.

    m_hr = pmnk->GetDisplayName( m_pIBindCtx,
                                 NULL,
                                 &wszReturnedDisplayName );
    EXIT_ON_FAILED( L"Failed IMoniker::GetDisplayName()" );

    if( wcslen( wszReturnedDisplayName ) > MAX_UNICODE_PATH )
        EXIT( L"IMoniker::GetDisplayName() returned a path which was too long" );

    // Copy the display name into the caller's buffer, and free it.

    wcscpy( wszDisplayName, wszReturnedDisplayName );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    if( wszReturnedDisplayName )
    {
        CoTaskMemFree( wszReturnedDisplayName );
        wszReturnedDisplayName = NULL;
    }

    DisplayErrors( bSuccess, L"CMoniker::GetDisplayName()" );
    return( bSuccess );

}   // CMoniker::GetDisplayName()


//+-------------------------------------------------------------
//
//  Function:   CMoniker::InitializeBindContext
//
//  Synopsis:   Create a new bind context, and store it
//              in a member pointer.
//
//  Inputs:     None.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    Updates m_pIBindCtx.
//
//+-------------------------------------------------------------



BOOL CMoniker::InitializeBindContext( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    //  -----
    //  Begin
    //  -----

    m_hr = S_OK;

    // Release the old bind context if we have one.

    if( m_pIBindCtx )
        m_pIBindCtx->Release();

    // Create the new bind context.

    m_hr = CreateBindCtx( 0L, &m_pIBindCtx );
    EXIT_ON_FAILED( L"Failed CreateBindCtx()" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CMoniker::InitializeBindContext()" );
    return( bSuccess );

}   // CMoniker::InitializeBindContext()


//+----------------------------------------------------------------
//
//  Function:   CMoniker::GetTimeOfLastChange
//
//  Synopsis:   Request the time-of-last-change from our member
//              moniker.
//
//  Inputs:     A buffer into which to put the FILETIME.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+----------------------------------------------------------------


BOOL CMoniker::GetTimeOfLastChange( FILETIME* pft )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    //  -----
    //  Begin
    //  -----

    m_hr = S_OK;

    // Validate our state.

    if( !m_pIMoniker )
        EXIT( L"Cannot GetTimeOfLastChange on a NULL moniker" );

    // Get the time from the moniker.

    m_hr = m_pIMoniker->GetTimeOfLastChange( m_pIBindCtx,
                                             NULL,
                                             pft );
    EXIT_ON_FAILED( L"Failed IMoniker::GetTimeOfLastChange()" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CMoniker::GetTimeOfLastChange()" );
    return( bSuccess );

}   // CMoniker::GetTimeOfLastChange()



//+------------------------------------------------------------------------
//
//  Function:   CMoniker::BindToStorage
//
//  Synopsis:   Bind our member moniker to its Structured Storage object.
//
//  Inputs:     None.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+------------------------------------------------------------------------


BOOL CMoniker::BindToStorage()
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;
    BIND_OPTS2 bind_opts;
    bind_opts.cbStruct = sizeof( BIND_OPTS2 );

    //  -----
    //  Begin
    //  -----

    m_hr = S_OK;

    // Validate our state.

    if( !m_pIMoniker )
        EXIT( L"Cannot GetTimeOfLastChange on a NULL moniker" );

    // Release the IStorage interface if we have one.

    if( m_pIStorage )
    {
        m_pIStorage->Release();
        m_pIStorage = NULL;
    }

    // Get the bind_opts and set the flags for StgOpenStorage.

    m_hr = m_pIBindCtx->GetBindOptions( (LPBIND_OPTS) &bind_opts );
    EXIT_ON_FAILED( L"Failed IBindCtx::GetBindOptions" );

    bind_opts.grfMode = STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT;

    m_hr = m_pIBindCtx->SetBindOptions( (LPBIND_OPTS) &bind_opts );
    EXIT_ON_FAILED( L"Failed IBindCtx::SetBindOptions" );


    // Bind to the storage.

    m_hr = m_pIMoniker->BindToStorage( m_pIBindCtx,
                                       NULL,
                                       IID_IStorage,
                                       (void **) &m_pIStorage );
    EXIT_ON_FAILED( L"Failed IMoniker::BindToStorage()" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    // Release the Storage if we got it.

    if( m_pIStorage )
    {
        m_pIStorage->Release();
        m_pIStorage = NULL;
    }

    DisplayErrors( bSuccess, L"CMoniker::BindToStorage()" );
    return( bSuccess );

}   // CMoniker::BindToStorage()


//+-------------------------------------------------------------------
//
//  Function:   CMoniker::BindToObject
//
//  Synopsis:   Bind to our member moniker's object.
//
//  Inputs:     None.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//  Notes:      Since the member moniker represents a storage with no
//              associated server, BindToObject will fail.  We will
//              consider it a success if the failure is do to an
//              object-related problem, rather than a Storage-related
//              problem.
//
//+-------------------------------------------------------------------

BOOL CMoniker::BindToObject()
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;
    IUnknown* pUnk = NULL;

    //  -----
    //  Begin
    //  -----

    m_hr = S_OK;

    // Validate our state.

    if( !m_pIMoniker )
        EXIT( L"Cannot bind to an object with a NULL moniker" );

    // Bind to the object.

    m_hr = m_pIMoniker->BindToObject( m_pIBindCtx,
                                      NULL,
                                      IID_IUnknown,
                                      (void **) &pUnk );

    // If the bind succeeded, or failed for a valid reason,
    // then return Success to the caller.

    if( SUCCEEDED( m_hr )
        ||
        ( m_hr = MK_E_INVALIDEXTENSION ) // No handler for ".tmp" files.
      )
    {
        bSuccess = TRUE;
    }
    else
    {
        EXIT( L"Failed BindToObject" );
    }

    //  ----
    //  Exit
    //  ----

Exit:

    //  If we got an IUnknown interface on the Bind, release it.

    if( pUnk )
    {
        pUnk->Release();
        pUnk = NULL;
    }

    DisplayErrors( bSuccess, L"CMoniker::BindToObject()" );
    return( bSuccess );

}   // CMoniker::BindToObject()


//+-------------------------------------------------------------------
//
//  Function:   CMoniker::GetTemporaryStorageTime
//
//  Synopsis:   Get the time from the link source file
//              (identified by m_wszTemporaryStorage).
//
//  Inputs:     A buffer in which to put the FILETIME structure.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+-------------------------------------------------------------------


BOOL CMoniker::GetTemporaryStorageTime( FILETIME * pft)
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;
    HANDLE hFile = NULL;

    //  -----
    //  Begin
    //  -----

    m_hr = NOERROR;

    //  Get a handle to the file.

    hFile = CreateFile( m_wszTemporaryStorage,  // File name
                        GENERIC_READ,           // Desired access
                        FILE_SHARE_READ,        // Share mode
                        NULL,                   // Security attributes
                        OPEN_EXISTING,          // Creation distribution
                        0L,                     // Flags & Attributes
                        NULL );                 // hTemplateFile
    if( hFile == NULL )
    {
        m_hr = (HRESULT) GetLastError();
        EXIT( L"Failed call to CreateFile()" );
    }

    // Get the time on the file.

    if( !GetFileTime(   hFile,  // File to check
                        NULL,   // Create Time
                        NULL,   // Access Time
                        pft )   // Write Time
      )
    {
        m_hr = (HRESULT) GetLastError();
        EXIT( L"Failed call to GetFileTime()" );
    }

    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    // Close the file if we opened it.

    if( hFile )
    {
        CloseHandle( hFile );
        hFile = NULL;
    }


    DisplayErrors( bSuccess, L"CMoniker::GetTemporaryStorageTime()" );
    return( bSuccess );

}   // CMoniker::GetTemporaryStorageTime()


//+------------------------------------------------------------------------
//
//  Function:   CMoniker::TouchTemporaryStorage
//
//  Synopsis:   Set the Access time on the link source file.
//
//  Inputs:     None.
//  
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    The link source file (identified by m_wszTemporaryStorage)
//              has its Access time set to the current time.
//
//+------------------------------------------------------------------------


BOOL CMoniker::TouchTemporaryStorage( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;
    HANDLE hFile = NULL;
    STATSTG statStorage;
    FILETIME ftNow;

    //  -----
    //  Begin
    //  -----

    m_hr = NOERROR;

    // Open the root Storage.

    m_hr = StgOpenStorage(  m_wszTemporaryStorage,
                            NULL,
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_DIRECT,
                            NULL,
                            0L,
                            &m_pIStorage );
    EXIT_ON_FAILED( L"Failed StgOpenStorage()" );

    // Get the current time.

    m_hr = CoFileTimeNow( &ftNow );
    EXIT_ON_FAILED( L"Failed CoFileTimeNow()" );

    // Set the access time

    m_pIStorage->SetElementTimes(   NULL,   // Set the storage itself
                                    NULL,   // Create time
                                    NULL,   // Access time
                                    &ftNow );
    EXIT_ON_FAILED( L"Failed IStorage::SetTimes()" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    // If we got the storage, release it.

    if( m_pIStorage )
    {
        m_pIStorage->Release();
        m_pIStorage = NULL;
    }

    DisplayErrors( bSuccess, L"CMoniker::TouchTemporaryStorage()" );
    return( bSuccess );

}   // CMoniker::TouchTemporaryStorage()



#ifdef _FUTURE_

/*
BOOL CMoniker::OpenLinkTrackingRegistryKey()
{

    BOOL bSuccess = FALSE;
    DWORD dwDisposition = 0L;
    long lResult = 0L;

    m_hr = S_OK;

    lResult = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            OLETRACKING_KEY,
                            0L,
                            KEY_ALL_ACCESS,
                            &m_hkeyLinkTracking
                         );

    if( lResult != ERROR_SUCCESS
        &&
        lResult != ERROR_FILE_NOT_FOUND
      )
    {
        m_hr = (HRESULT) lResult;
        EXIT( L"Failed RegOpenKeyEx()" );
    }


    bSuccess = TRUE;

Exit:

    DisplayErrors( bSuccess, L"CMoniker::OpenLinkTrackingRegistryKey()" );
    return( bSuccess );


}   // CMoniker::OpenLinkTrackingRegistryKey()


BOOL CMoniker::CreateLinkTrackingRegistryKey()
{

    BOOL bSuccess = FALSE;
    HKEY hkey = NULL;
    DWORD dwDisposition = 0L;
    long lResult = 0L;

    m_hr = S_OK;

    if( m_hkeyLinkTracking )
        CloseLinkTrackingRegistryKey();

    lResult = RegCreateKeyEx(  HKEY_LOCAL_MACHINE,
                               OLETRACKING_KEY,
                               0L,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &m_hkeyLinkTracking,
                               &dwDisposition
                            );

    if( lResult != ERROR_SUCCESS )
    {
        m_hr = (HRESULT) lResult;
        EXIT( L"Failed RegCreateKeyEx()" );
    }

    bSuccess = TRUE;

Exit:

    DisplayErrors( bSuccess, L"CMoniker::CreateLinkTrackingRegistryKey()" );
    return( bSuccess );

}   // CMoniker::CreateLinkTrackingRegistryKey()



BOOL CMoniker::CloseLinkTrackingRegistryKey()
{
    m_hr = S_OK;

    if( m_hkeyLinkTracking )
        RegCloseKey( m_hkeyLinkTracking );

    m_hkeyLinkTracking = NULL;

    return TRUE;

}   // CMoniker::CloseLinkTrackingRegistryKey()



BOOL CMoniker::SaveRegistryTrackFlags()
{
    BOOL bSuccess = FALSE;

    long lResult = 0L;
    DWORD dwType = 0L;
    DWORD dwcbData = sizeof( m_dwTrackFlags );
    

    m_hr = S_OK;

    if( !OpenLinkTrackingRegistryKey() )
        EXIT( L"Could not open the registry" );

    lResult = RegQueryValueEx( m_hkeyLinkTracking,
                               OLETRACKING_FILEMONIKER_VALUE,
                               NULL,
                               &dwType,
                               (LPBYTE) &m_dwTrackFlags,
                               &dwcbData );

    if( lResult != ERROR_SUCCESS )
    {
        CloseLinkTrackingRegistryKey();
        
        if( lResult != ERROR_FILE_NOT_FOUND )
        {
            m_hr = (HRESULT) lResult;
            EXIT( L"Failed RegQueryValueEx()" );
        }
    }


    bSuccess = TRUE;

Exit:

    DisplayErrors( bSuccess, L"CMoniker::SaveRegistryTrackFlags()" );
    return( bSuccess );

}   // CMoniker::SaveRegistryTrackFlags()



BOOL CMoniker::DeleteRegistryTrackFlags()
{
    BOOL bSuccess = FALSE;

    long lResult = 0L;
    DWORD dwType = 0L;
    DWORD dwcbData = sizeof( m_dwTrackFlags );
    

    m_hr = S_OK;

    if( !CreateLinkTrackingRegistryKey() )
        EXIT( L"Could not open the registry" );


    lResult = RegDeleteValue(   m_hkeyLinkTracking,
                                OLETRACKING_FILEMONIKER_VALUE );


    if( lResult != ERROR_SUCCESS
        &&
        lResult != ERROR_FILE_NOT_FOUND
      )
    {
        if( lResult != ERROR_FILE_NOT_FOUND )
        {
            m_hr = (HRESULT) lResult;
            EXIT( L"Failed RegDeleteValue()" );
        }
    }

    bSuccess = TRUE;

Exit:

    CloseLinkTrackingRegistryKey();

    DisplayErrors( bSuccess, L"CMoniker::DeleteRegistryTrackFlags()" );
    return( bSuccess );

}   // CMoniker::DeleteRegistryTrackFlags()



BOOL CMoniker::RestoreRegistryTrackFlags()
{
    BOOL bSuccess = FALSE;
    long lResult = 0L;


    m_hr = S_OK;

    // If the registry key doesn't exist, then there's no flags
    // to restore.

    if( m_hkeyLinkTracking )
    {

        lResult = RegSetValueEx( m_hkeyLinkTracking,
                                 OLETRACKING_FILEMONIKER_VALUE,
                                 0L,
                                 REG_DWORD,
                                 (LPBYTE) &m_dwTrackFlags,
                                 sizeof( m_dwTrackFlags )
                               );

        if( lResult != ERROR_SUCCESS )
        {
            m_hr = (HRESULT) lResult;
            EXIT( L"Failed RegSetValueEx()" );
        }

        CloseLinkTrackingRegistryKey();
        
    }
    

    bSuccess = TRUE;

Exit:

    DisplayErrors( bSuccess, L"CMoniker::RestoreRegistryTrackFlags()" );
    return( bSuccess );

}   // CMoniker::RestoreRegistryTrackFlags()

CMoniker::SetTrackFlagsInRegistry( DWORD dwTrackFlags )
{
    BOOL bSuccess = FALSE;
    long lResult = 0L;
    HKEY hkey = NULL;


    m_hr = S_OK;

    if( !CreateLinkTrackingRegistryKey() )
        EXIT( L"Could not create registry key" );

    lResult = RegSetValueEx( m_hkeyLinkTracking,
                             OLETRACKING_FILEMONIKER_VALUE,
                             0L,
                             REG_DWORD,
                             (LPBYTE) &dwTrackFlags,
                             sizeof( dwTrackFlags )
                           );

    if( lResult != ERROR_SUCCESS )
    {
        m_hr = (HRESULT) lResult;
        EXIT( L"Failed RegSetValueEx()" );
    }
    

    bSuccess = TRUE;

Exit:

    DisplayErrors( bSuccess, L"CMoniker::SetTrackFlagsInRegistry()" );
    return( bSuccess );

}   // CMoniker::SetTrackFlagsInRegistry()


BOOL CMoniker::CreateFileMoniker()
{

    BOOL bSuccess = FALSE;

    m_hr = S_OK;

    // Free any existing IMoniker.

    if( m_pIMoniker )
    {
        m_pIMoniker->Release();
        m_pIMoniker = NULL;
    }

    // Create a root storage.

    if( !CreateTemporaryStorage() )
        EXIT( L"Could not create a temporary storage" );

    // Create a default File Moniker on that root storage.

    m_hr = ::CreateFileMoniker( m_wszTemporaryStorage, &m_pIMoniker );
    EXIT_ON_FAILED( L"Failed CreateFileMoniker" );


    bSuccess = TRUE;


Exit:

    DisplayErrors( bSuccess, L"CMoniker::CreateFileMoniker" );
    return( bSuccess );

}   // CMoniker::CreateFileMoniker()
*/
#endif // _FUTURE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cfmex\ctest.cxx ===
//+=======================================================================
//
//  File:       CTest.cxx
//
//  Purpose:    Define the CTest class.
//
//              This class is the test engine for the CreateFileMonikerEx
//              (CFMEx) DRTs.  All interactions with monikers are handled
//              through the CMoniker class.
//
//+=======================================================================


//  -------------
//  Include Files
//  -------------

#define _DCOM_			// Allow DCOM extensions (e.g., CoInitializeEx).

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <wchar.h>
#include <wtypes.h>
#include <oaidl.h>
#include <dsys.h>
#include <olecairo.h>
#include "CDir.hxx"
#include "CMoniker.hxx"
#include "CTest.hxx"


//+------------------------------------------------------------------------
//
//  Function:   CTest::CTest
//
//  Synopsis:   Inititialize member variables.
//
//  Inputs:     None.
//
//  Outputs:    N/A
//
//  Effects:    All members are initialized/defaulted.
//
//+------------------------------------------------------------------------


CTest::CTest( )
{

    m_lError = 0L;
    *m_wszErrorMessage = L'\0';

    m_pcDirectoryOriginal = NULL;
    m_pcDirectoryFinal = NULL;

}   // CTest::CTest

//+------------------------------------------------------------------------------
//
//  Function:   CTest::~CTest
//
//  Synopsis:   No action.
//
//  Inputs:     N/A
//
//  Outputs:    N/A
//
//  Effects:    None.
//
//+------------------------------------------------------------------------------


CTest::~CTest()
{
}   // CTest::~CTest


//+-------------------------------------------------------------------------------
//
//  Function:   CTest::Initialize
//
//  Synopsis:   Inititialize a CTest object.
//
//  Inputs:     CDirectory objects representing the original and final
//              locations of a link source file.  The original location
//              is used in CreateTemporaryStorage(), and the final location
//              is used in RenameTemporaryStorage().
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    m_cDirectoryOriginal and m_cDirectoryFinal are set.
//
//+-------------------------------------------------------------------------------


BOOL CTest::Initialize( const CDirectory& cDirectoryOriginal,
                        const CDirectory& cDirectoryFinal
                      )
{
    //  -----
    //  Begin
    //  -----

    m_pcDirectoryOriginal = &cDirectoryOriginal;
    m_pcDirectoryFinal    = &cDirectoryFinal;

    m_cMoniker.Initialize( cDirectoryOriginal, cDirectoryFinal );

    //  ----
    //  Exit
    //  ----

    return TRUE;

}   // CTest::Initialize

//+-------------------------------------------------------------------------
//
//  Function:   CTest::CreateFileMonikerEx
//
//  Synopsis:   Verify that CreateFileMonikerEx actually creates a
//              *tracking* file moniker.  This is done by creating
//              the file moniker, renaming the link source,
//              Reducing the moniker, and getting the display name
//              of the reduced moniker.  Note that this tests
//              both CreateFileMonikerEx and Reduce.
//
//  Inputs:     None.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+-------------------------------------------------------------------------


BOOL CTest::CreateFileMonikerEx( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    WCHAR wszDisplayName[ MAX_PATH + sizeof( L'\0' ) ];
    IMoniker* pmnkReduced = NULL;

    //  -----
    //  Begin
    //  -----

    wprintf( L"CreateFileMonikerEx()\n" );
    wprintf( L"   Create a tracking file moniker (using CreateFileMonikerEx),\n"
             L"   move the represented file, Reduce the moniker, and get\n"
	     L"   the display name from the reduced moniker.  It should be the\n"
	     L"   new file name.  This test covers both CreateFileMonikerEx and\n"
             L"   Reduce.\n" );


    // Create the tracking file moniker.

    if( !m_cMoniker.CreateFileMonikerEx( ) )
        EXIT( L"Could not CreateFileMonikerEx" );

    // Rename the link source file.

    if( !m_cMoniker.RenameTemporaryStorage() )
        EXIT( L"Could not rename the temporary storage file" );

    // Reduce the tracking file moniker

    if( !m_cMoniker.Reduce( INFINITE, &pmnkReduced ))
	EXIT( L"Could not reduce the moniker" );

    // Use the reduced (non-tracking) file moniker to get the display name.

    if( !m_cMoniker.GetDisplayName( wszDisplayName, pmnkReduced ))
        EXIT( L"Could not get the display name" );

    // Validate the display name.

    if( _wcsicmp( wszDisplayName, m_cMoniker.GetTemporaryStorageName() ))
        EXIT( L"Failed" );
    

    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    m_cMoniker.DeleteTemporaryStorage();

    DisplayErrors( bSuccess, L"CTest::CreateFileMonikerEx()" );
    return( bSuccess );

}   // CTest::CreateFileMonikerEx()


//+--------------------------------------------------------------------------
//
//  Function:   CTest::GetDisplayName
//
//  Synopsis:   Create a tracking file moniker, get its display name,
//              rename the link source file, and get the display name again.
//              The value of the second display name will depend on whether
//              or not the original and final link source are within the set
//              of local indexed volumes.
//
//  Inputs:     None.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+--------------------------------------------------------------------------


BOOL CTest::GetDisplayName( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    WCHAR wszFinalDisplayName[ MAX_PATH + sizeof( L'\0' ) ];
    WCHAR wszOriginalDisplayName[ MAX_PATH + sizeof( L'\0' ) ];

    //  -----
    //  Begin
    //  -----

    wprintf( L"GetDisplayName()\n" );
    wprintf( L"   Create a tracking file moniker, move the represented file,\n"
             L"   and perform a GetDisplayName on the moniker.  If the original\n"
             L"   and final locations of the source file are within the set of local\n"
             L"   indexed drives, the display name will represent the final file name.\n"
             L"   Otherwise, it will represent the original display name.\n" );

    // Create a tracking file moniker.

    if( !m_cMoniker.CreateFileMonikerEx(  ) )
        EXIT( L"Could not CreateFileMonikerEx" );

    // Get its display name.

    if( !m_cMoniker.GetDisplayName( wszOriginalDisplayName ))
        EXIT( L"Could not get the original display name" );

    // Rename the link source.

    if( !m_cMoniker.RenameTemporaryStorage() )
        EXIT( L"Could not rename the temporary storage file" );

    // Get the renamed moniker's display name.

    if( !m_cMoniker.GetDisplayName( wszFinalDisplayName ))
        EXIT( L"Could not get the final display name" );

    // Was and is the link source on a local, indexed volume?

    if( ( m_pcDirectoryOriginal->GetFileSystemType() == fstOFS )
        &&
        ( m_pcDirectoryOriginal->GetFileSystemType() == fstOFS )
      )
    {
        // Yes, so the GetDisplayName should have tracked the rename.

        if( _wcsicmp( wszFinalDisplayName, m_cMoniker.GetTemporaryStorageName() ))
            EXIT( L"Failed" );
    }
    else
    {
        // No, so the GetDisplayName should have returned the original name.

        if( _wcsicmp( wszOriginalDisplayName, wszFinalDisplayName ))
            EXIT( L"Failed" );
    }

    
    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    m_cMoniker.DeleteTemporaryStorage();

    DisplayErrors( bSuccess, L"CTest::GetDisplayName()" );
    return( bSuccess );

}   // CTest::GetDisplayName()



//+--------------------------------------------------------------------------
//
//  Function:   CTest::GetTimeOfLastChange
//
//  Synopsis:   Create a tracking file moniker, rename it, sleep, and
//              touch it.  If the original and final link sources are
//              on local, indexed volumes, then a GetDisplayName should
//              return the final link source's time.  Otherwise, it should
//              return the original link source's time.
//
//  Inputs:     None.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+--------------------------------------------------------------------------


BOOL CTest::GetTimeOfLastChange( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    FILETIME ftOriginal;
    FILETIME ftFinal;
    FILETIME ftMoniker;

    //  -----
    //  Begin
    //  -----

    wprintf( L"GetTimeOfLastChange()\n" );
    wprintf( L"   Create a tracking file moniker and move it.  Then touch (set the Access\n"
             L"   time) on the link source, and perform a GetTimeOfLastChange on the Moniker.\n"
             L"   If the original and final location of the link source is within the set\n"
             L"   of local indexed volumes, then the time returned from the moniker should\n"
             L"   match that of the post-touch link source.  Otherwise it should match the\n"
             L"   link sources original time.\n" );

    // Create a tracking file moniker.

    if( !m_cMoniker.CreateFileMonikerEx( TRACK_LOCALONLY ) )
        EXIT( L"Could not CreateFileMonikerEx" );

    // Get the link source's current time.

    if( !m_cMoniker.GetTemporaryStorageTime( &ftOriginal ))
        EXIT( L"Could not get original file time" );

    // Move the link source.

    if( !m_cMoniker.RenameTemporaryStorage() )
        EXIT( L"Could not rename the temporary storage file" );

    // Delay so that when we touch the final link source, its time
    // will be noticably different from the original link source's time.

    {
        wprintf( L"   Sleeping to let the time change:  " );
        for( int i = 0; i < 10; i++ )   // Sleep for 5 seconds
        {
            wprintf( L"z" );
            Sleep( 500 );   // 1/2 second
        }
        wprintf( L"\n" );
    }

    // Touch the final link source.

    if( !m_cMoniker.TouchTemporaryStorage())
        EXIT( L"Could not touch temporary storage" );

    // Get the final link source's time from the file system.

    if( !m_cMoniker.GetTemporaryStorageTime( &ftFinal ))
        EXIT( L"could not get final file time" );

    // Get the final link source's time from the moniker.

    if( !m_cMoniker.GetTimeOfLastChange( &ftMoniker ))
        EXIT( L"Could not get the time of last change" );

    // Is the original & final location of the link source file
    // in the set of local, indexed volumes?

    if( ( m_pcDirectoryOriginal->GetFileSystemType() == fstOFS )
        &&
        ( m_pcDirectoryOriginal->GetFileSystemType() == fstOFS )
      )
    {
        // Yes.  GetTimeOfLastChange should therefore have found
        // the time of the final link source file.

        if( memcmp( &ftFinal, &ftMoniker, sizeof( FILETIME ) ))
            EXIT( L"Failed" );
    }
    else
    {
        // No.  GetTimeOfLastChange should therefore have returned
        // the time of the original link source file.

        if( memcmp( &ftOriginal, &ftMoniker, sizeof( FILETIME ) ))
            EXIT( L"Failed" );
    }


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    m_cMoniker.DeleteTemporaryStorage();

    DisplayErrors( bSuccess, L"CTest::GetTimeOfLastChange()" );
    return( bSuccess );

}   // CTest::GetTimeOfLastChange()


//+--------------------------------------------------------------------
//
//  Function:   CTest::BindToObject
//
//  Synopsis:   Create a tracking file moniker, move the link source,
//              and attempt to bind to it with a BindToObject.
//              Since presumably the temporary file we're using as a link
//              source has no server, this will fail.  But any failure
//              downstream of locating the link source file will be
//              ignored.
//
//  Inputs:     None.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+--------------------------------------------------------------------


BOOL CTest::BindToObject( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    //  -----
    //  Begin
    //  -----

    wprintf( L"BindToObject()\n" );
    wprintf( L"   Create a tracking file moniker, moved the represented file,\n"
             L"   and attempt a BindToStorage() (which should succeed).\n" );

    // Create a tracking file moniker.

    if( !m_cMoniker.CreateFileMonikerEx( ) )
        EXIT( L"Could not CreateFileMonikerEx" );

    // Move the link source file.

    if( !m_cMoniker.RenameTemporaryStorage() )
        EXIT( L"Could not rename the temporary storage file" );

    // Attempt a bind.

    if( !m_cMoniker.BindToObject( ))
        EXIT( L"Could not bind to Object" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----
Exit:

    m_cMoniker.DeleteTemporaryStorage();

    DisplayErrors( bSuccess, L"CTest::BindToObject()" );
    return( bSuccess );

}   // CTest::BindToObject()


//+-----------------------------------------------------------
//
//  Function:   CTest::IPersist
//
//  Synopsis:   Create a tracking file moniker, move the link
//              source, and perform the CMoniker::SaveDeleteLoad
//              test.
//
//  Inputs:     None.
//
//  Output:     TRUE if successful, FALSE otherwise
//
//  Effects:    None.
//
//+-----------------------------------------------------------


BOOL CTest::IPersist( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    //  -----
    //  Begin
    //  -----

    wprintf( L"IPersist()\n" );
    wprintf( L"  Create a tracking file moniker (using CreateFileMonikerEx), and\n"
             L"  save it to a Stream.  Delete the moniker, create a new one using\n"
             L"  CreateFileMoniker, load it from the Stream, and verify that the resulting\n"
             L"  file moniker is tracking.\n" );

    // Create a tracking file moniker.

    if( !m_cMoniker.CreateFileMonikerEx( ) )
        EXIT( L"Could not CreateFileMonikerEx" );

    // Rename the link source.

    if( !m_cMoniker.RenameTemporaryStorage() )
        EXIT( L"Could not rename the temporary storage file" );

    // Save the moniker, deleted, create a new moniker, and reload it.

    if( !m_cMoniker.SaveDeleteLoad( ))
        EXIT( L"Failed SaveDeleteLoad" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    m_cMoniker.DeleteTemporaryStorage();

    DisplayErrors( bSuccess, L"CTest::IPersist()" );
    return( bSuccess );

}   // CTest::IPersist()


//+----------------------------------------------------------------------
//
//  Function:   CTest::ComposeWith
//
//  Synopsis:   Create a tracking file moniker, and use it in the 
//              CMoniker::ComposeWith operation.
//
//  Inputs:     None.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+----------------------------------------------------------------------

BOOL CTest::ComposeWith( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    IMoniker* pmnkReduced = NULL;
    WCHAR wszDisplayName[ MAX_PATH + sizeof( L'\0' )];

    //  -----
    //  Begin
    //  -----

    m_lError = 0;

    wprintf( L"ComposeWith()\n" );
    wprintf( L"   Create a tracking file moniker, and compose it with a non-tracking\n"
             L"   file moniker on the right.  The resulting moniker should be tracking.\n" );

    // Create the tracking file moniker.

    if( !m_cMoniker.CreateFileMonikerEx( ) )
        EXIT( L"Could not CreateFileMonikerEx" );

    // Perform the ComposeWith operation.

    if( !m_cMoniker.ComposeWith( ))
        EXIT( L"Failed ComposeWith" );

    // Move the link source file.

    if( !m_cMoniker.RenameTemporaryStorage() )
        EXIT( L"Could not rename the temporary storage file" );

    // Reduce the composed moniker.

    if( !m_cMoniker.Reduce( INFINITE, &pmnkReduced ))
	EXIT( L"Could not reduce the moniker" );

    // Get the display name on the reduced moniker.

    if( !m_cMoniker.GetDisplayName( wszDisplayName, pmnkReduced ))
        EXIT( L"Could not get the display name" );

    // Verify that the name from the moniker is the actual link source
    // file's new name.

    if( _wcsicmp( wszDisplayName, m_cMoniker.GetTemporaryStorageName() ))
        EXIT( L"Failed" );

    
    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    m_cMoniker.DeleteTemporaryStorage();

    DisplayErrors( bSuccess, L"CTest::ComposeWith()" );
    return( bSuccess );

}   // CTest::ComposeWith()


//+------------------------------------------------------------------
//
//  Function:   CTest::BindToStorage
//
//  Synopsis:   Create a tracking file moniker, and perform the
//              CMoniker::BindToStorage operation.
//
//  Inputs:     None.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//+------------------------------------------------------------------


BOOL CTest::BindToStorage( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    //  -----
    //  Begin
    //  -----

    m_lError = 0;

    wprintf( L"BindToStorage()\n" );
    wprintf( L"   Create a tracking file moniker (using CreateFileMonikerEx),\n"
             L"   move the represented file, Reduce the moniker, and get\n"
	     L"   the display name from the reduced moniker.  It should be the\n"
	     L"   new file name.  This test covers both CreateFileMonikerEx and\n"
             L"   Reduce.\n" );

    // Create the tracking file moniker.

    if( !m_cMoniker.CreateFileMonikerEx( ) )
        EXIT( L"Could not CreateFileMonikerEx" );

    // Move the link source file.

    if( !m_cMoniker.RenameTemporaryStorage() )
        EXIT( L"Could not rename the temporary storage file" );

    // Bind to the Storage

    if( !m_cMoniker.BindToStorage( ))
        EXIT( L"Could not bind to Storage" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    m_cMoniker.DeleteTemporaryStorage();

    DisplayErrors( bSuccess, L"CTest::BindToStorage()" );
    return( bSuccess );

}   // CTest::BindToStorage()


//+--------------------------------------------------------------------------
//
//  Function:   CTest::DeleteLinkSource
//
//  Synopsis:   Create a tracking file moniker, delete the link source,
//              and attempt a Reduce.  The Reduce should not fail, but
//              it should return an HResult of MK_S_REDUCED_TO_SELF.
//
//  Inputs:     Tick count limit on the length of the Reduce operation.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+--------------------------------------------------------------------------

BOOL CTest::DeleteLinkSource( DWORD dwDelay )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    WCHAR wszTimeout[ 80 ];

    //  -----
    //  Begin
    //  -----

    m_lError = 0L;

    // Generate a string which shows what the delay is.

    switch( dwDelay )
    {
        case 0:
            wcscpy( wszTimeout, L"instant timeout" );
            break;

        case INFINITE:
            wcscpy( wszTimeout, L"infinite timeout" );
            break;

        default:
            wsprintf( wszTimeout, L"%d ms timeout", dwDelay );
    }

    // Display a header.

    wprintf( L"Delete Link Source (%s)\n",
             wszTimeout );
    wprintf( L"   Create a tracking file moniker, then delete the link source, and\n"
             L"   attempt a reduce with a %s.\n",
             wszTimeout );

    // Create a tracking file moniker.

    if( !m_cMoniker.CreateFileMonikerEx( ) )
        EXIT( L"Could not CreateFileMonikerEx" );

    // Delete the link source file.

    if( !m_cMoniker.DeleteTemporaryStorage() )
        EXIT( L"Could not delete temporary storage" );

    // Tell CMoniker not to alarm the user with error messages.

    m_cMoniker.SuppressErrorMessages( TRUE );

    // Reduce the moniker, and verify it returns the proper Success code.

    if( !m_cMoniker.Reduce( dwDelay )
        ||
        m_cMoniker.GetHResult() != MK_S_REDUCED_TO_SELF
      )
	EXIT( L"Failed" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    m_cMoniker.DeleteTemporaryStorage();
    m_cMoniker.SuppressErrorMessages( FALSE );

    DisplayErrors( bSuccess, L"CTest::DeleteLinkSource()" );
    return( bSuccess );

}   // CTest::DeleteLinkSource()


//+------------------------------------------------------------------
//
//  Function:   CTest::GetOversizedBindOpts
//
//  Synopsis:   Test a bind context's ability to return a BIND_OPTS
//              which is larger than expected.
//
//              First, initialize the default BIND_OPTS in the bind
//              context to 1s.  Then, ask for a large BIND_OPTS.
//              The resulting buffer should have 1s up to the size of
//              the normal BIND_OPTS, and 0s for the remainder of the
//              buffer.  The length, however, should be that of the large
//              buffer.
//
//  Inputs:     None.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+------------------------------------------------------------------


BOOL CTest::GetOversizedBindOpts( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    BIND_OPTS   bind_opts;
    LPBIND_OPTS pbind_optsLarge    = (LPBIND_OPTS) new BYTE[ SIZE_OF_LARGE_BIND_OPTS ];
    LPBIND_OPTS pbind_optsExpected = (LPBIND_OPTS) new BYTE[ SIZE_OF_LARGE_BIND_OPTS ];

    //  -----
    //  Begin
    //  -----

    m_lError = 0L;

    wprintf( L"Get Oversized BindOpts\n" );
    wprintf( L"   Create a buffer which is much larger than a normal BIND_OPTS, and\n"
             L"   use it to request the BIND_OPTS from a bind context.  The length\n"
             L"   of the resulting buffer should be the large value, and the extra\n"
             L"   room in the buffer should be all 0s.\n" );


    // Validate our 'new' operations.

    if( pbind_optsLarge == NULL )
        EXIT( L"Could not allocate pbind_optsLarge" );
    pbind_optsLarge->cbStruct = SIZE_OF_LARGE_BIND_OPTS;

    if( pbind_optsExpected == NULL )
        EXIT( L"Could not allocate pbind_optsExpected" );
    pbind_optsExpected->cbStruct = SIZE_OF_LARGE_BIND_OPTS;


    // Initialize the bind_opts (normal sized) in the bind context to 1s.

    if( !m_cMoniker.InitializeBindContext() )
        EXIT( L"Could not initialize the bind context" );

    memset( &bind_opts, 1, sizeof( bind_opts ));
    bind_opts.cbStruct = sizeof( bind_opts );;

    m_lError = m_cMoniker.GetBindCtx()->SetBindOptions( &bind_opts );
    if( FAILED( m_lError )) EXIT( L"Could not set original bind options" );

    // Initialize the large bind_opts to 2s, then retrieve the bind_opts into
    // this structure.  This is done to verify that the GetBindOptions below
    // fills in the entire requested buffer (overwirting all of the 2s).

    memset( pbind_optsLarge, 2, SIZE_OF_LARGE_BIND_OPTS );
    pbind_optsLarge->cbStruct = SIZE_OF_LARGE_BIND_OPTS;

    m_lError = m_cMoniker.GetBindCtx()->GetBindOptions( pbind_optsLarge );
    if( FAILED( m_lError )) EXIT( L"Could not get large bind options" );

    // The returned structure should have the large cbStruct, 1s up to
    // the length of BIND_OPTS, and 0s after that.

    memset( pbind_optsExpected, 0, SIZE_OF_LARGE_BIND_OPTS );
    memset( pbind_optsExpected, 1, sizeof( bind_opts ));
    pbind_optsExpected->cbStruct = SIZE_OF_LARGE_BIND_OPTS;

    if( memcmp( pbind_optsLarge, pbind_optsExpected, SIZE_OF_LARGE_BIND_OPTS ))
      EXIT( L"Failed" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CTest::GetOversizedBindOpts()" );
    return( bSuccess );

}   // CTest::GetOversizeBindOpts()



//+----------------------------------------------------------------
//
//  Function:   CTest::GetUndersizedBindOpts
//
//  Synopsis:   Create a bind context, and initialize the data in its
//              BIND_OPTS to 1s.  Create a normal BIND_OPTS-sized buffer,
//              initialize it to 2s, then use it to get a small-sized
//              BIND_OPTS from the bind context.  The resulting buffer
//              should have a small length, a small number of 1s,
//              and 2s for the remainder of the buffer.
//
//  Inputs:     None.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+----------------------------------------------------------------



BOOL CTest::GetUndersizedBindOpts( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    LPBIND_OPTS pbind_optsSmall    = (LPBIND_OPTS) new BYTE[ SIZE_OF_LARGE_BIND_OPTS ];
    LPBIND_OPTS pbind_optsExpected = (LPBIND_OPTS) new BYTE[ SIZE_OF_LARGE_BIND_OPTS ];
    BIND_OPTS   bind_opts;
    bind_opts.cbStruct = sizeof( bind_opts );

    //  -----
    //  Begin
    //  -----

    m_lError = 0L;

    wprintf( L"Get Undersized BindOpts\n" );
    wprintf( L"   Get the BIND_OPTS from a bind context, but only providing a small\n"
             L"   buffer, and verify that only that portion of the actual BIND_OPTS\n"
             L"   is returned.\n" );

    // Validate our 'new's.

    if( pbind_optsSmall == NULL )
        EXIT( L"Could not allocate pbind_optsSmall" );
    pbind_optsSmall->cbStruct = SIZE_OF_SMALL_BIND_OPTS;

    if( pbind_optsExpected == NULL )
        EXIT( L"Could not allocate pbind_optsExpected" );
    pbind_optsExpected->cbStruct = SIZE_OF_SMALL_BIND_OPTS;


    // Initialize the bind_opts (normal sized) in the bind context to 1s.

    if( !m_cMoniker.InitializeBindContext() )
        EXIT( L"Could not initialize the bind context" );

    memset( &bind_opts, 1, sizeof( bind_opts ));
    bind_opts.cbStruct = sizeof( bind_opts );;

    m_lError = m_cMoniker.GetBindCtx()->SetBindOptions( &bind_opts );
    if( FAILED( m_lError )) EXIT( L"Could not set original bind options" );


    // Initialize the small bind_opts to 2s, then retrieve the bind_opts into
    // this structure.

    memset( pbind_optsSmall, 2, SIZE_OF_LARGE_BIND_OPTS );
    pbind_optsSmall->cbStruct = SIZE_OF_SMALL_BIND_OPTS;

    m_lError = m_cMoniker.GetBindCtx()->GetBindOptions( pbind_optsSmall );
    if( FAILED( m_lError )) EXIT( L"Could not get small bind options" );

    // The returned structure should have the small cbStruct, 1s up to
    // the end of the small buffer, and 2s to the end of the real buffer.

    memset( pbind_optsExpected, 2, SIZE_OF_LARGE_BIND_OPTS );
    memset( pbind_optsExpected, 1, SIZE_OF_SMALL_BIND_OPTS );
    pbind_optsExpected->cbStruct = SIZE_OF_SMALL_BIND_OPTS;

    if( memcmp( pbind_optsSmall, pbind_optsExpected, SIZE_OF_LARGE_BIND_OPTS ))
        EXIT( L"Failed" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CTest::GetUndersizedBindOpts()" );
    return( bSuccess );

}   // CTest::GetUndersizedBindOpts()


//+----------------------------------------------------------------
//
//  Function:   CTest::SetOversizedBindOpts
//
//  Synopsis:   Create a large BIND_OPTS buffer, set it in
//              a bind context, and verify that it can be read back.
//
//  Inputs:     None.
//
//  Outputs:    TRUE if successful, FALSE otherwise.
//
//  Effects:    None.
//
//+----------------------------------------------------------------

BOOL CTest::SetOversizedBindOpts( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    LPBIND_OPTS pbind_optsLarge    = (LPBIND_OPTS) new BYTE[ SIZE_OF_LARGE_BIND_OPTS ];
    LPBIND_OPTS pbind_optsExpected = (LPBIND_OPTS) new BYTE[ SIZE_OF_LARGE_BIND_OPTS ];

    //  -----
    //  Begin
    //  -----

    wprintf( L"Set Oversized BindOpts\n" );
    wprintf( L"   Set a larger-than-usual BIND_OPTS in a bind context, and verify\n"
             L"   that it can be read back in its entirety.\n" );

    // Validate our 'new's.

    if( pbind_optsLarge == NULL )
        EXIT( L"Could not allocate pbind_optsLarge" );
    pbind_optsLarge->cbStruct = SIZE_OF_LARGE_BIND_OPTS;

    if( pbind_optsExpected == NULL )
        EXIT( L"Could not allocate pbind_optsExpected" );
    pbind_optsExpected->cbStruct = SIZE_OF_LARGE_BIND_OPTS;

    // Initialize the large bind_opts to 1s, then set the large BIND_OPTS
    // into the bind context.

    if( !m_cMoniker.InitializeBindContext() )
        EXIT( L"Could not initialize the bind context" );

    memset( pbind_optsLarge, 1, SIZE_OF_LARGE_BIND_OPTS );
    pbind_optsLarge->cbStruct = SIZE_OF_LARGE_BIND_OPTS;

    m_lError = m_cMoniker.GetBindCtx()->SetBindOptions( pbind_optsLarge );
    if( FAILED( m_lError )) EXIT( L"Could not set large bind options" );

    // Get the BIND_OPTS back from the bind context, and verify that it's
    // what we set.

    memset( pbind_optsLarge, 0, SIZE_OF_LARGE_BIND_OPTS );
    pbind_optsLarge->cbStruct = SIZE_OF_LARGE_BIND_OPTS;
    m_lError = m_cMoniker.GetBindCtx()->GetBindOptions( pbind_optsLarge );

    memset( pbind_optsExpected, 1, SIZE_OF_LARGE_BIND_OPTS );
    pbind_optsExpected->cbStruct = SIZE_OF_LARGE_BIND_OPTS;

    if( memcmp( pbind_optsLarge, pbind_optsExpected, SIZE_OF_LARGE_BIND_OPTS ))
      EXIT( L"Failed" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CTest::SetOversizedBindOpts()" );
    return( bSuccess );

}   // CTest::SetOversizeBindOpts()


//+------------------------------------------------------------
//
//  Function:   CTest::SetUndersizedBindOpts
//
//  Synopsis:   Create a bind context, and initialize its BIND_OPTS to
//              all 1s.  Then, set a small BIND_OPTS in the bind context
//              which is set to 2s.  Read back the whold BIND_OPTS, and
//              verify that it has the normal length, 2s at the
//              beginning, and 1s to the end.
//
//  Inputs:     None.
//
//  Output:     TRUE if successful, FALSE otherwise.
//
//+------------------------------------------------------------


BOOL CTest::SetUndersizedBindOpts( )
{
    //  ---------------
    //  Local Variables
    //  ---------------

    BOOL bSuccess = FALSE;

    BIND_OPTS bind_opts;
    BIND_OPTS bind_optsExpected;

    //  -----
    //  Begin
    //  -----

    m_lError = 0L;

    wprintf( L"Set Undersized BindOpts\n" );
    wprintf( L"   Initialize a BIND_OPTS in a bind context to 1s, then set a smaller\n"
             L"   BIND_OPTS in it set to 2s.  When the buffer is read back, it should\n"
             L"   have 2s up to the small buffer size, followed by 1s.\n" );

    // Initialize the bind context's BIND_OPTS (normal sized) to 1s.

    if( !m_cMoniker.InitializeBindContext() )
        EXIT( L"Could not initialize the bind context" );

    memset( &bind_opts, 1, sizeof( bind_opts ));
    bind_opts.cbStruct = sizeof( bind_opts );
    m_lError = m_cMoniker.GetBindCtx()->SetBindOptions( &bind_opts );
    if( FAILED( m_lError )) EXIT( L"Could not set initial BIND_OPTS" );

    // Now set a smaller BIND_OPTS.  But initialize the local BIND_OPTS to all
    // 2s, so that we can verify that only part of the buffer is put into the
    // bind context.

    memset( &bind_opts, 2, sizeof( bind_opts ) );
    bind_opts.cbStruct = SIZE_OF_SMALL_BIND_OPTS;
    m_lError = m_cMoniker.GetBindCtx()->SetBindOptions( &bind_opts );
    if( FAILED( m_lError )) EXIT( L"Could not set small BIND_OPTS" );

    // The resulting BIND_OPTS in the bind context should have 2s up
    // to SIZE_OF_SMALL_BIND_OPTS, and 1s for the remainder of the buffer.

    bind_opts.cbStruct = sizeof( bind_opts );
    m_lError = m_cMoniker.GetBindCtx()->GetBindOptions( &bind_opts );
    if( FAILED( m_lError )) EXIT( L"Could not get BIND_OPTS" );

    memset( &bind_optsExpected, 1, sizeof( bind_opts ));
    memset( &bind_optsExpected, 2, SIZE_OF_SMALL_BIND_OPTS );
    bind_optsExpected.cbStruct = sizeof( bind_opts );

    if( memcmp( &bind_opts, &bind_optsExpected, sizeof( bind_opts )))
      EXIT( L"Failed" );


    bSuccess = TRUE;

    //  ----
    //  Exit
    //  ----

Exit:

    DisplayErrors( bSuccess, L"CTest::SetUndersizedBindOpts()" );
    return( bSuccess );

}   // CTest::SetUndersizedBindOpts()


#ifdef _FUTURE_

BOOL CTest::CFMWithRegistryClear( )
{
    BOOL bSuccess = FALSE;
    WCHAR wszDisplayName[ MAX_PATH + sizeof( L'\0' ) ];

    if( !m_cMoniker.SaveRegistryTrackFlags() )
        EXIT( L"Could not save the existing track flags in the registry" );

    if( !m_cMoniker.DeleteRegistryTrackFlags() )
        EXIT( L"Could not delete the existing track flags in the registry" );

    if( !m_cMoniker.CreateFileMoniker() )
        EXIT( L"Could not CreateFileMoniker" );

    if( !m_cMoniker.RenameTemporaryStorage() )
        EXIT( L"Could not rename the temporary storage file" );

    if( !m_cMoniker.GetDisplayName( wszDisplayName ))
        EXIT( L"Could not get the display name" );

    if( !_wcsicmp( wszDisplayName, m_cMoniker.GetTemporaryStorageName() ))
        EXIT( L"Test failed:  A moniker was created using CreateFileMoniker, after\n"
              L"              the Track Flags had been cleared from the Registry.\n"
              L"              The underlying root storage was then renamed.\n"
              L"              But a GetDisplayName then showed the new name, implying\n"
              L"              that the created moniker is using tracking (which it\n"
              L"              should not, because without the Track Flags set there\n"
              L"              should be no tracking).\n" );
    

    bSuccess = TRUE;

Exit:

    m_cMoniker.DeleteTemporaryStorage();

    if( !m_cMoniker.RestoreRegistryTrackFlags() )
        ERROR_IN_EXIT( L"Could not restore Track Flags in Registry" );


    DisplayErrors( bSuccess, L"CTest::CFMWithRegistryClear" );
    return( bSuccess );

}   // CTest::CFMWithRegistryClear




BOOL CTest::CFMWithRegistrySet( )
{
    BOOL bSuccess = FALSE;
    WCHAR wszDisplayName[ MAX_PATH + sizeof( L'\0' ) ];

    if( !m_cMoniker.SaveRegistryTrackFlags() )
        EXIT( L"Could not save the existing track flags in the registry" );

    if( !m_cMoniker.SetTrackFlagsInRegistry( TRACK_LOCALONLY ) )
        EXIT( L"Could not set track flags in the registry" );

    if( !m_cMoniker.CreateFileMoniker() )
        EXIT( L"Could not CreateFileMoniker" );

    if( !m_cMoniker.RenameTemporaryStorage() )
        EXIT( L"Could not rename the temporary storage file" );

    if( !m_cMoniker.GetDisplayName( wszDisplayName ))
        EXIT( L"Could not get the display name" );

    if( _wcsicmp( wszDisplayName, m_cMoniker.GetTemporaryStorageName() ))
        EXIT( L"Test failed:  A moniker was created using CreateFileMoniker, after\n"
              L"              setting the TRACK_LOCALONLY flag in the Registry.\n"
              L"              However, after moving the linked file, GetDisplayName\n"
              L"              did not return the new name.\n" );
    

    bSuccess = TRUE;

Exit:

    m_cMoniker.DeleteTemporaryStorage();

    if( !m_cMoniker.RestoreRegistryTrackFlags() )
        ERROR_IN_EXIT( L"Could not restore Track Flags in Registry" );


    DisplayErrors( bSuccess, L"CTest::CFMWithRegistrySet()" );
    return( bSuccess );

}   // CTest::CFMWithRegistrySet


#endif // _FUTURE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\channel\async\async.h ===
#ifndef __async_h__
#define __async_h__

#include "rpc.h"
#include "rpcndr.h"
#include "windows.h"
#include "ole2.h"

class IAsync : public IUnknown
{
  public:
    virtual HRESULT STDMETHODCALLTYPE Async( IAsyncManager **pCall,
                                             BOOL late, BOOL sleep,
                                             BOOL fail ) = 0;
    virtual HRESULT STDMETHODCALLTYPE RecurseAsync( IAsyncManager **pCall,
                                                    IAsync *callback,
                                                    DWORD depth ) = 0;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\channel\hook\hook.h ===
#ifndef __hook_h__
#define __hook_h__

#include "rpc.h"
#include "rpcndr.h"
#include "windows.h"
#include "ole2.h"

class IWhichHook : public IUnknown
{
  public:
    virtual HRESULT STDMETHODCALLTYPE Me( REFIID ) = 0;
    virtual HRESULT STDMETHODCALLTYPE Hooked( REFIID ) = 0;
    virtual HRESULT STDMETHODCALLTYPE Clear() = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\channel\app\app_i.c ===
#pragma warning(disable:4101)    // Ignore variable not use warning

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: iperf_i.c
//
//  Contents: IID_IPerf
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.83
//
//--------------------------------------------------------------------------
typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;


const IID CLSID_ITest =
{0x60000430, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}};

const IID CLSID_ITestMulti =
{0x25724a70, 0x283f, 0x11ce, {0x95, 0x31, 0x08, 0x00, 0x2b, 0x2a, 0xb6, 0x12}};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\channel\hook\hook.cxx ===
//--------------------------------------------------------------
//
// File:        hook.cxx
//
// Contents:    Test channel hooks
//
//---------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>
#include <malloc.h>

#include <ole2.h>
#include <coguid.h>
#include "hook.h"

class CWhichHook : public IWhichHook
{
  public:
    // Constructor/Destructor
    CWhichHook();
    ~CWhichHook() {};

    // IUnknown
    STDMETHOD (QueryInterface)   (REFIID iid, void FAR * FAR * ppv);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    // IWhichHook
    STDMETHOD (Me)    ( REFIID riid );
    STDMETHOD (Hooked)( REFIID riid );
    STDMETHOD (Clear) ();

  private:
    DWORD       _iRef;
    static BOOL _f1;
    static BOOL _f2;
};

class CDllHook : public IChannelHook
{
    public:
      CDllHook( REFGUID );
      ~CDllHook() {};

      STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
      STDMETHOD_(ULONG,AddRef)     ( void );
      STDMETHOD_(ULONG,Release)    ( void );

      STDMETHOD_(void,ClientGetSize)   ( REFGUID, REFIID, ULONG *DataSize );
      STDMETHOD_(void,ClientFillBuffer)( REFGUID, REFIID, ULONG *DataSize, void *DataBuffer );
      STDMETHOD_(void,ClientNotify)    ( REFGUID, REFIID, ULONG DataSize, void *DataBuffer,
                                         DWORD DataRep, HRESULT );
      STDMETHOD_(void,ServerNotify)    ( REFGUID, REFIID, ULONG DataSize, void *DataBuffer,
                                         DWORD DataRep );
      STDMETHOD_(void,ServerGetSize)   ( REFGUID, REFIID, HRESULT, ULONG *DataSize );
      STDMETHOD_(void,ServerFillBuffer)( REFGUID, REFIID, ULONG *DataSize, void *DataBuffer, HRESULT );

    private:
      ULONG       _iRef;
      GUID        _extent;
      CWhichHook  _cWhich;
};

class CHookCF: public IClassFactory
{
  public:

    // Constructor/Destructor
    CHookCF( CLSID );
    ~CHookCF() {};

    // IUnknown
    STDMETHOD (QueryInterface)   (REFIID iid, void FAR * FAR * ppv);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    // IClassFactory
    STDMETHODIMP        CreateInstance(
                            IUnknown FAR* pUnkOuter,
                            REFIID iidInterface,
                            void FAR* FAR* ppv);

    STDMETHODIMP        LockServer(BOOL fLock);

  private:
    ULONG _iRef;
    CLSID _class;
};

const CLSID CLSID_Hook1     = {0x60000400, 0x76d7, 0x11cf, {0x9a, 0xf1, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}};
const CLSID CLSID_Hook2     = {0x60000401, 0x76d7, 0x11cf, {0x9a, 0xf1, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}};
const CLSID CLSID_WhichHook = {0x60000402, 0x76d7, 0x11cf, {0x9a, 0xf1, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}};
const IID   IID_IWhichHook  = {0x60000403, 0x76d7, 0x11cf, {0x9a, 0xf1, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}};

BOOL CWhichHook::_f1 = FALSE;
BOOL CWhichHook::_f2 = FALSE;

//+-------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Dll entry point
//
//--------------------------------------------------------------------------

STDAPI  DllCanUnloadNow()
{
    return S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Dll entry point
//
//--------------------------------------------------------------------------

STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    CHookCF *pFactory;

    // Check for IPSFactoryBuffer
    if ((clsid == CLSID_Hook1 || clsid == CLSID_Hook2 || clsid == CLSID_WhichHook)
        && iid == IID_IClassFactory)
    {
        pFactory = new CHookCF( clsid );
        *ppv = pFactory;
        if (pFactory == NULL)
            return E_OUTOFMEMORY;
        else
            return S_OK;
    }
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------
//
//  Member:     CHookCF::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHookCF::AddRef()
{
    InterlockedIncrement( (long *) &_iRef );
    return _iRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CHookCF::CHookCF
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CHookCF::CHookCF( CLSID clsid )
{
    _iRef  = 1;
    _class = clsid;
}

//+-------------------------------------------------------------------
//
//  Member:     CHookCF::CreateInstance, public
//
//  Synopsis:   Create an instance of the requested class
//
//--------------------------------------------------------------------
STDMETHODIMP CHookCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
  IUnknown *pUnk;
  HRESULT   hr;
  *ppv = NULL;
  if (pUnkOuter != NULL)
  {
      printf( "Create instance failed, attempted agregation.\n" );
      return E_FAIL;
  }

  // Create the right class.
  if (_class == CLSID_WhichHook)
      pUnk = new CWhichHook();
  else
      pUnk = new CDllHook( _class );

  // Query for the requested interface.
  hr = pUnk->QueryInterface( iidInterface, ppv );
  pUnk->Release();
  return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CHookCF::LockServer, public
//
//--------------------------------------------------------------------
STDMETHODIMP CHookCF::LockServer(BOOL fLock)
{
    return E_FAIL;
}


//+-------------------------------------------------------------------
//
//  Member:     CHookCF::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CHookCF::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
        *ppvObj = (IClassFactory *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CHookCF::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CHookCF::Release()
{
    ULONG lRef = _iRef - 1;

    if (InterlockedDecrement( (long*) &_iRef ) == 0)
    {
        delete this;
        return 0;
    }
    else
        return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CDllHook::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDllHook::AddRef()
{
    InterlockedIncrement( (long *) &_iRef );
    return _iRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CDllHook::CDllHook, public
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CDllHook::CDllHook( REFGUID rExtent )
{
    _iRef      = 1;
    _extent    = rExtent;
}

//+-------------------------------------------------------------------
//
//  Member:     CDllHook::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CDllHook::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IChannelHook))
        *ppvObj = (IChannelHook *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CDllHook::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CDllHook::Release()
{
    ULONG lRef = _iRef - 1;

    if (InterlockedDecrement( (long*) &_iRef ) == 0)
    {
        delete this;
        return 0;
    }
    else
        return lRef;
}

/***************************************************************************/
STDMETHODIMP_(void) CDllHook::ClientGetSize( REFGUID ext, REFIID riid,
                                          ULONG *size )
{
    _cWhich.Me( _extent );
    *size = sizeof(DWORD);
}

/***************************************************************************/
STDMETHODIMP_(void) CDllHook::ClientFillBuffer( REFGUID ext, REFIID riid,
                                             ULONG *max, void *buffer )
{
    _cWhich.Me( _extent );
    *max = sizeof(DWORD);
    if (_extent == CLSID_Hook1)
        *((DWORD *) buffer) = 'Blue';
    else
        *((DWORD *) buffer) = 'Grn';
}

/***************************************************************************/
STDMETHODIMP_(void) CDllHook::ClientNotify( REFGUID ext, REFIID riid,
                                         ULONG size, void *buffer,
                                         DWORD data_rep, HRESULT result )
{
    _cWhich.Me( _extent );
}

/***************************************************************************/
STDMETHODIMP_(void) CDllHook::ServerNotify( REFGUID ext, REFIID riid,
                                         ULONG size, void *buffer,
                                         DWORD data_rep )
{
    _cWhich.Me( _extent );
}

/***************************************************************************/
STDMETHODIMP_(void) CDllHook::ServerGetSize( REFGUID ext, REFIID riid, HRESULT hr,
                                          ULONG *size )
{
    _cWhich.Me( _extent );
    *size = sizeof(DWORD);
}

/***************************************************************************/
STDMETHODIMP_(void) CDllHook::ServerFillBuffer( REFGUID ext, REFIID riid,
                                             ULONG *max, void *buffer, HRESULT hr )
{
    _cWhich.Me( _extent );
    *max = sizeof(DWORD);
    if (_extent == CLSID_Hook1)
        *((DWORD *) buffer) = 'Blue';
    else
        *((DWORD *) buffer) = 'Grn';
}

//+-------------------------------------------------------------------
//
//  Member:     CWhichHook::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWhichHook::AddRef()
{
    InterlockedIncrement( (long *) &_iRef );
    return _iRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CWhichHook::CWhichHook, public
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CWhichHook::CWhichHook()
{
    _iRef      = 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CWhichHook::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CWhichHook::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IWhichHook))
        *ppvObj = (IWhichHook *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CWhichHook::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CWhichHook::Release()
{
    ULONG lRef = _iRef - 1;

    if (InterlockedDecrement( (long*) &_iRef ) == 0)
    {
        delete this;
        return 0;
    }
    else
        return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CWhichHook::Me, public
//
//  Synopsis:   Flags a hook as used.
//
//--------------------------------------------------------------------
STDMETHODIMP CWhichHook::Me( REFIID riid )
{
    if (riid == CLSID_Hook1)
        _f1 = TRUE;
    else if (riid == CLSID_Hook2)
        _f2 = TRUE;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CWhichHook::Hooked, public
//
//  Synopsis:   Succeeds if the specified hook has been used.
//
//--------------------------------------------------------------------
STDMETHODIMP CWhichHook::Hooked( REFIID riid )
{
    if (riid == CLSID_Hook1)
        return _f1 ? S_OK : E_FAIL;
    else if (riid == CLSID_Hook2)
        return _f2 ? S_OK : E_FAIL;
    return E_INVALIDARG;
}

//+-------------------------------------------------------------------
//
//  Member:     CWhichHook::Clear, public
//
//  Synopsis:   Clears the used flags.
//
//--------------------------------------------------------------------
STDMETHODIMP CWhichHook::Clear()
{
    _f1 = FALSE;
    _f2 = FALSE;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\channel\async\async.cxx ===
//--------------------------------------------------------------
//
// File:        async.cxx
//
// Contents:    Test proxy and stub for async
//
//---------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>
#include <malloc.h>

#include <ole2.h>
#include <coguid.h>
#include "async.h"

typedef struct SAsyncData
{
    BOOL bLate;
    BOOL bSleep;
    BOOL bFail;
};

class CProxy;
class CProxyComplete;
class CStubComplete;

class CPCInnerUnknown : public IUnknown
{
  public:
    // IUnknown methods
    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    // Constructor
    CPCInnerUnknown( CProxyComplete *pParent );

    DWORD           _iRef;
    CProxyComplete *_pParent;
};

class CProxyComplete : public IAsyncManager, public ICancelMethodCalls
{
  public:
    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );
    STDMETHOD (Cancel)           ( void );
    STDMETHOD (TestCancel)       ( void );
    STDMETHOD (CompleteCall)     ( HRESULT result );
    STDMETHOD (GetCallContext)   ( REFIID riid, void **pInterface );
    STDMETHOD (GetState)         ( DWORD *pState );
    STDMETHOD (SetCancelTimeout) ( ULONG lSec ) { return E_NOTIMPL; }
    CProxyComplete( IUnknown *pControl, BOOL fAutoComplete, HRESULT *hr );
    ~CProxyComplete();

    CPCInnerUnknown     _Inner;
    IUnknown           *_pSyncInner;
    IUnknown           *_pControl;
    RPCOLEMESSAGE       _Message;
    BOOL                _fAutoComplete;
    IRpcChannelBuffer3 *_pChannel;
};

class CSCInnerUnknown : public IUnknown
{
  public:
    // IUnknown methods
    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    // Constructor
    CSCInnerUnknown( CStubComplete *pParent );

    DWORD          _iRef;
    CStubComplete *_pParent;
};

class CStubComplete : public IAsyncManager, public IAsyncSetup,
                      public ICancelMethodCalls
{
  public:
    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );
    STDMETHOD (Cancel)           ( void );
    STDMETHOD (CompleteCall)     ( HRESULT result );
    STDMETHOD (GetCallContext)   ( REFIID riid, void **pInterface );
    STDMETHOD (GetState)         ( DWORD *pState );
    STDMETHOD (SetCancelTimeout) ( ULONG lSec ) { return E_NOTIMPL; }
    STDMETHOD (TestCancel)       ( void );
    STDMETHOD (GetAsyncManager)  ( REFIID riid,
                                   IUnknown *pOuter,
                                   DWORD dwFlags,
                                   IUnknown       **pInner,
                                   IAsyncManager **pComplete );
    CStubComplete( IUnknown *pControl, IRpcChannelBuffer3 *, RPCOLEMESSAGE *,
                   HRESULT *hr );
    ~CStubComplete();

    CSCInnerUnknown     _Inner;
    IUnknown           *_pSyncInner;
    IUnknown           *_pControl;
    RPCOLEMESSAGE       _Message;
    IRpcChannelBuffer3 *_pChannel;
};

class CAsync : public IAsync
{
  public:
    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );
    STDMETHOD (Async)            ( IAsyncManager **pCall, BOOL, BOOL, BOOL );
    STDMETHOD (RecurseAsync)     ( IAsyncManager **pCall, IAsync *, DWORD );
    CAsync( IUnknown *pControl, CProxy *pProxy );
    ~CAsync();

  private:
    IUnknown *_pControl;
    CProxy   *_pProxy;
};

class CProxy: public IRpcProxyBuffer, IAsyncSetup
{
  public:
    STDMETHOD (QueryInterface) ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)   ( void );
    STDMETHOD_(ULONG,Release)  ( void );
    STDMETHOD (Connect)        ( IRpcChannelBuffer *pRpcChannelBuffer );
    STDMETHOD_(void,Disconnect)( void );
    STDMETHOD (GetAsyncManager)( REFIID riid,
                                 IUnknown *pOuter,
                                 DWORD dwFlags,
                                 IUnknown       **pInner,
                                 IAsyncManager **pComplete );
    CProxy( IUnknown *pControl );

    CAsync _Async;
    DWORD               _iRef;
    IRpcChannelBuffer3 *_pChannel;
};

class CStub : public IRpcStubBuffer
{
  public:
    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );
    STDMETHOD (Connect)          ( IUnknown *pServer );
    STDMETHOD_(void, Disconnect) ( void );
    STDMETHOD (Invoke)           ( RPCOLEMESSAGE *pMessage,
                                   IRpcChannelBuffer *pChannel );
    STDMETHOD_(IRpcStubBuffer *,IsIIDSupported)( REFIID riid );
    STDMETHOD_(ULONG,CountRefs)  ( void );
    STDMETHOD (DebugServerQueryInterface) ( void **ppv );
    STDMETHOD_(void,DebugServerRelease)   ( void *ppv );
    CStub( IAsync *pServer );

  private:
    DWORD   _iRef;
    IAsync *_pAsync;
};

class CPSFactory : public IPSFactoryBuffer
{
  public:
    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );
    STDMETHOD (CreateProxy)      ( IUnknown *pUnkOuter,
                                   REFIID riid,
                                   IRpcProxyBuffer **ppProxy,
                                   void **ppv );
    STDMETHOD (CreateStub)       ( REFIID riid,
                                   IUnknown *pUnkServer,
                                   IRpcStubBuffer **ppStub );
    CPSFactory();

  private:
    DWORD _iRef;
};

const IID IID_IAsync = {0x70000000,0x76d7,0x11Cf,{0x9a,0xf1,0x00,0x20,0xaf,0x6e,0x72,0xf4}};

//+-------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Dll entry point
//
//--------------------------------------------------------------------------

STDAPI  DllCanUnloadNow()
{
    return S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Dll entry point
//
//--------------------------------------------------------------------------

STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void **ppv)
{
    CPSFactory *pFactory;

    // Check for IPSFactoryBuffer
    if (clsid == IID_IAsync && iid == IID_IPSFactoryBuffer)
    {
        pFactory = new CPSFactory();
        *ppv = pFactory;
        if (pFactory == NULL)
            return E_OUTOFMEMORY;
        else
            return S_OK;
    }
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------
//
//  Member:     CPSFactory::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPSFactory::AddRef()
{
    InterlockedIncrement( (long *) &_iRef );
    return _iRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CPSFactory::CPSFactory
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CPSFactory::CPSFactory()
{
    _iRef = 1;
}

//+-------------------------------------------------------------------
//
//  Member:     CPSFactory::CreateProxy, public
//
//  Synopsis:   Create an instance of the requested proxy
//
//--------------------------------------------------------------------
STDMETHODIMP CPSFactory::CreateProxy( IUnknown *pUnkOuter, REFIID riid,
                                      IRpcProxyBuffer **ppProxy, void **ppv )
{
    CProxy  *pProxy;

    // Validate the parameters.
    if (ppv == NULL || riid != IID_IAsync || pUnkOuter == NULL)
        return E_INVALIDARG;
    *ppv = NULL;

    // Create a proxy.
    pProxy = new CProxy( pUnkOuter );
    if (pProxy == NULL)
        return E_OUTOFMEMORY;
    *ppProxy = pProxy;
    *ppv     = &pProxy->_Async;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CPSFactory::CreateStub, public
//
//  Synopsis:   Create an instance of the requested stub
//
//--------------------------------------------------------------------
STDMETHODIMP CPSFactory::CreateStub( REFIID riid, IUnknown *pUnkServer,
                                     IRpcStubBuffer **ppStub )
{
    IAsync  *pAsync;
    CStub   *pStub;
    HRESULT  hr;

    // Validate the parameters.
    if (riid != IID_IAsync)
        return E_INVALIDARG;

    // Get the IAsync interface.
    hr = pUnkServer->QueryInterface( IID_IAsync, (void **) &pAsync );
    if (FAILED(hr))
        return hr;

    // Create a stub.
    pStub = new CStub( pAsync );
    pAsync->Release();
    if (pStub == NULL)
        return E_OUTOFMEMORY;
    *ppStub = pStub;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CPSFactory::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CPSFactory::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPSFactoryBuffer))
        *ppvObj = (IPSFactoryBuffer *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CPSFactory::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPSFactory::Release()
{
    ULONG lRef = _iRef - 1;

    if (InterlockedDecrement( (long*) &_iRef ) == 0)
    {
        delete this;
        return 0;
    }
    else
        return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CProxy::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CProxy::AddRef()
{
    InterlockedIncrement( (long *) &_iRef );
    return _iRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CProxy::Connect, public
//
//  Synopsis:   Connects the proxy to a channel
//
//--------------------------------------------------------------------
STDMETHODIMP CProxy::Connect( IRpcChannelBuffer *pChannel )
{
    HRESULT             hr;

    // Get the other channel buffer interface.
    hr = pChannel->QueryInterface( IID_IRpcChannelBuffer3, (void **) &_pChannel );
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CProxy::Disconnect, public
//
//  Synopsis:   Disconnects the proxy from a channel
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CProxy::Disconnect()
{
    if (_pChannel != NULL)
    {
        _pChannel->Release();
        _pChannel = NULL;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CProxy::CProxy, public
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CProxy::CProxy( IUnknown *pControl ) :
    _Async( pControl, this )
{
    _iRef      = 1;
    _pChannel  = NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     CProxy::GetAsyncManager, public
//
//  Synopsis:   Creates a proxy completion object
//
//--------------------------------------------------------------------
STDMETHODIMP CProxy::GetAsyncManager( REFIID        riid,
                                      IUnknown     *pOuter,
                                      DWORD         dwFlags,
                                      IUnknown    **ppInner,
                                      IAsyncManager **ppComplete )
{
    HRESULT         hr;
    CProxyComplete *pComplete;

    // Create a new proxy completion object.
    pComplete = new CProxyComplete( pOuter, FALSE, &hr );
    if (pComplete == NULL)
        return E_OUTOFMEMORY;
    else if (FAILED(hr))
    {
        delete pComplete;
        return hr;
    }

    // Get IAsyncManager.
    *ppComplete = (IAsyncManager *) pComplete;
    *ppInner    = (IUnknown *) &pComplete->_Inner;
    pComplete->AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CProxy::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CProxy::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IRpcProxyBuffer))
        *ppvObj = (IRpcProxyBuffer *) this;
    else if (IsEqualIID(riid, IID_IAsyncSetup))
        *ppvObj = (IAsyncSetup *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CProxy::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CProxy::Release()
{
    ULONG lRef = _iRef - 1;

    if (InterlockedDecrement( (long*) &_iRef ) == 0)
    {
        delete this;
        return 0;
    }
    else
        return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CAsync::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsync::AddRef()
{
    return _pControl->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CAsync::Async, public
//
//  Synopsis:   Marshal parameters for an async call.
//
//--------------------------------------------------------------------
STDMETHODIMP CAsync::Async( IAsyncManager **ppCall, BOOL bLate,
                            BOOL bSleep, BOOL bFail )
{
    HRESULT         hr;
    CProxyComplete *pComplete;
    BOOL            fFreeComplete = FALSE;
    DWORD           lIgnore;
    SAsyncData     *pData;
    DWORD           fFlags = RPC_BUFFER_ASYNC;

    // If there is no async complete, create one.  Aggregate in the
    // correct ISignal.
    if (ppCall == NULL || *ppCall == NULL)
    {
        // Initialize the out parameters.
        if (ppCall != NULL)
            *ppCall = NULL;
        else
            fFlags |= RPCFLG_AUTO_COMPLETE;

        // Create a new proxy complete object.
        pComplete = new CProxyComplete( NULL, ppCall == NULL, &hr );
        if (pComplete == NULL)
            return E_OUTOFMEMORY;
        if (FAILED(hr))
        {
            delete pComplete;
            return hr;
        }
        fFreeComplete = TRUE;
        if (ppCall != NULL)
            *ppCall = pComplete;
    }

    // Otherwise the passed in completion object should be one of ours.
    else
    {
        pComplete = (CProxyComplete *) *ppCall;
        if (pComplete->_pChannel != NULL)
            return E_FAIL;
    }

    // Get a buffer.
    memset( &pComplete->_Message, 0, sizeof(pComplete->_Message) );
    pComplete->_Message.cbBuffer           = sizeof( SAsyncData );
    pComplete->_Message.dataRepresentation = 0x10;
    pComplete->_Message.iMethod            = 3;
    pComplete->_Message.rpcFlags           = fFlags;
    hr = _pProxy->_pChannel->GetBuffer( &pComplete->_Message, IID_IAsync );
    if (FAILED(hr)) goto Done;

    // Register async.
    hr = _pProxy->_pChannel->RegisterAsync( &pComplete->_Message,
                                            (IAsyncManager *) pComplete );
    if (FAILED(hr))
    {
        // Register async shouldn't fail.
        DebugBreak();
    }

    // Fill in the buffer.
    pData         = (SAsyncData *) pComplete->_Message.Buffer;
    pData->bLate  = bLate;
    pData->bSleep = bSleep;
    pData->bFail  = bFail;

    // Send the buffer.
    pComplete->_pChannel = _pProxy->_pChannel;
    _pProxy->_pChannel->AddRef();
    hr = _pProxy->_pChannel->Send( &pComplete->_Message, &lIgnore );

Done:
    if (FAILED(hr))
    {
        if (pComplete->_pChannel != NULL)
        {
            pComplete->_pChannel = NULL;
            _pProxy->_pChannel->Release();
        }
        if (fFreeComplete)
        {
            delete pComplete;
            if (ppCall != NULL)
                *ppCall = NULL;
        }
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CAsync::CAsync, public
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CAsync::CAsync( IUnknown *pControl, CProxy *pProxy )
{
    _pControl = pControl;
    _pProxy   = pProxy;
    _pControl->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CAsync::~CAsync, public
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------
CAsync::~CAsync()
{
    _pControl->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CAsync::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CAsync::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    return _pControl->QueryInterface( riid, ppvObj );
}

//+-------------------------------------------------------------------
//
//  Member:     CAsync::RecurseAsync, public
//
//  Synopsis:   Marshal parameters for a RecurseAsync call.
//
//--------------------------------------------------------------------
STDMETHODIMP CAsync::RecurseAsync( IAsyncManager **ppCall, IAsync *pCallback,
                                   DWORD depth )
{
    HRESULT         hr;
    CProxyComplete *pComplete;
    BOOL            fFreeComplete = FALSE;
    DWORD           lIgnore;
    HANDLE          memory        = NULL;
    ULONG           size;
    IStream        *pStream       = NULL;
    LARGE_INTEGER   pos;
    DWORD          *pBuffer;
    DWORD           dwDestCtx;
    VOID           *pvDestCtx     = NULL;
    BOOL            fFlags        = RPC_BUFFER_ASYNC;

    // If there is no async complete, create one.  Aggregate in the
    // correct ISignal.
    if (ppCall == NULL || *ppCall == NULL)
    {
        // Initialize the out parameters.
        if (ppCall != NULL)
            *ppCall = NULL;
        else
            fFlags |= RPCFLG_AUTO_COMPLETE;

        // Create a new proxy complete object.
        pComplete = new CProxyComplete( NULL, ppCall == NULL, &hr );
        if (pComplete == NULL)
            return E_OUTOFMEMORY;
        if (FAILED(hr))
        {
            delete pComplete;
            return hr;
        }
        fFreeComplete = TRUE;
        if (ppCall != NULL)
            *ppCall = pComplete;
    }

    // Otherwise the passed in completion object should be one of ours.
    else
    {
        pComplete = (CProxyComplete *) *ppCall;
        if (pComplete->_pChannel != NULL)
            return E_FAIL;
    }

    // Get the destination context.
    hr = _pProxy->_pChannel->GetDestCtx( &dwDestCtx, &pvDestCtx );

    // Find out how much memory to allocate.
    hr = CoGetMarshalSizeMax( &size, IID_IAsync, pCallback, dwDestCtx,
                              pvDestCtx, MSHLFLAGS_NORMAL );
    if (FAILED(hr))
        goto Done;

    // Allocate memory.
    memory = GlobalAlloc( GMEM_FIXED, size );
    if (memory == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Done;
    }

    // Create a stream.
    hr = CreateStreamOnHGlobal( memory, TRUE, &pStream );
    if (FAILED(hr))
        goto Done;
    memory = NULL;

    // Marshal the object.
    hr = CoMarshalInterface( pStream, IID_IAsync, pCallback, dwDestCtx,
                             pvDestCtx, MSHLFLAGS_NORMAL );
    if (FAILED(hr))
        goto Done;

    // Seek back to the start of the stream.
    pos.QuadPart = 0;
    hr = pStream->Seek( pos, STREAM_SEEK_SET, NULL );
    if (FAILED(hr))
        goto Done;

    // Get a buffer.
    memset( &pComplete->_Message, 0, sizeof(pComplete->_Message) );
    pComplete->_Message.cbBuffer           = sizeof(depth) + size;
    pComplete->_Message.dataRepresentation = 0x10;
    pComplete->_Message.iMethod            = 4;
    pComplete->_Message.rpcFlags           = fFlags;
    hr = _pProxy->_pChannel->GetBuffer( &pComplete->_Message, IID_IAsync );
    if (FAILED(hr)) goto Done;

    // Register async.
    hr = _pProxy->_pChannel->RegisterAsync( &pComplete->_Message,
                                            (IAsyncManager *) pComplete );
    if (FAILED(hr))
    {
        // Register async shouldn't fail.
        DebugBreak();
    }

    // Fill in the buffer.
    pBuffer = (DWORD *) pComplete->_Message.Buffer;
    *pBuffer = depth;
    pBuffer += 1;
    hr = pStream->Read( (void *) pBuffer, size, NULL );
    if (FAILED(hr))
        goto Done;

    // Send the buffer.
    pComplete->_pChannel = _pProxy->_pChannel;
    _pProxy->_pChannel->AddRef();
    hr = _pProxy->_pChannel->Send( &pComplete->_Message, &lIgnore );

Done:
    if (pStream != NULL)
        pStream->Release();
    if (memory != NULL)
        GlobalFree( memory );
    if (FAILED(hr))
    {
        if (pComplete->_pChannel != NULL)
        {
            pComplete->_pChannel = NULL;
            _pProxy->_pChannel->Release();
        }
        if (fFreeComplete)
        {
            delete pComplete;
            if (ppCall != NULL)
                *ppCall = NULL;
        }
    }
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CAsync::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CAsync::Release()
{
    return _pControl->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CPCInnerUnknown::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPCInnerUnknown::AddRef()
{
    InterlockedIncrement( (long *) &_iRef );
    return _iRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CPCInnerUnknown::CPCInnerUnknown
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CPCInnerUnknown::CPCInnerUnknown( CProxyComplete *pParent )
{
    _iRef = 1;
    _pParent   = pParent;
}

//+-------------------------------------------------------------------
//
//  Member:     CPCInnerUnknown::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CPCInnerUnknown::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown *pUnk;

    if (IsEqualIID(riid, IID_IUnknown))
        pUnk = (IUnknown *) this;
    else if (IsEqualIID(riid, IID_IAsyncManager))
        pUnk = (IAsyncManager *) _pParent;
    else if (IsEqualIID(riid, IID_ICancelMethodCalls))
        pUnk = (ICancelMethodCalls *) _pParent;
    else if (_pParent->_pSyncInner != NULL)
        return _pParent->_pSyncInner->QueryInterface( riid, ppvObj );

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CPCInnerUnknown::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CPCInnerUnknown::Release()
{
    ULONG lRef = _iRef - 1;

    if (InterlockedDecrement( (long*) &_iRef ) == 0)
    {
        delete _pParent;
        return 0;
    }
    else
        return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CProxyComplete::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CProxyComplete::AddRef()
{
    return _pControl->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CProxyComplete::Cancel, public
//
//  Synopsis:   Forward cancel to the channel
//
//--------------------------------------------------------------------
STDMETHODIMP CProxyComplete::Cancel()
{
    HRESULT hr;

    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;
    hr = _pChannel->Cancel( &_Message );
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CProxyComplete::CompleteCall, public
//
//  Synopsis:   Receive the reply and parse the out parameters
//
//--------------------------------------------------------------------
STDMETHODIMP CProxyComplete::CompleteCall( HRESULT result )
{
    HRESULT  hr;
    HRESULT  temp;
    DWORD    lIgnore;

    // Fail if there is no call.
    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;

    // Call receive.
    hr = _pChannel->Receive( &_Message, 0, &lIgnore );
    if (hr == RPC_S_CALLPENDING || hr == 0x15)
        return hr;
    if (FAILED(hr))
        goto Done;

    // Unmarshal the results.
    if (_Message.cbBuffer < sizeof(HRESULT))
    {
        hr = RPC_E_INVALID_DATAPACKET;
        goto Done;
    }
    temp = *((HRESULT *) _Message.Buffer);

    // Free the buffer.
    hr = _pChannel->FreeBuffer( &_Message );
    if (SUCCEEDED(hr))
        hr = temp;

    // If auto complete, self release.
Done:
    _pChannel->Release();
    _pChannel = NULL;
    if (_fAutoComplete)
        _Inner.Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CProxyComplete::CProxyComplete
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CProxyComplete::CProxyComplete( IUnknown *pControl, BOOL fAutoComplete,
                                HRESULT *hr) :
    _Inner( this )
{
    // Save the easy fields
    _pSyncInner    = NULL;
    _fAutoComplete = fAutoComplete;
    _pChannel      = NULL;
    if (pControl == NULL)
        _pControl = &_Inner;
    else
    {
        _pControl = pControl;
        _pControl->AddRef();
    }

    // Aggregate in an ISynchronize.
    if (fAutoComplete)
        *hr = CoCreateInstance( CLSID_Synchronize_AutoComplete,
                                &_Inner,
                                CLSCTX_INPROC_SERVER, IID_IUnknown,
                                (void **) &_pSyncInner );
    else
        *hr = CoCreateInstance( CLSID_Synchronize_ManualResetEvent,
                                &_Inner,
                                CLSCTX_INPROC_SERVER, IID_IUnknown,
                                (void **) &_pSyncInner );
    if (SUCCEEDED(*hr))
    {
        // Aggregation requires some weird reference counting.
        Release();
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CProxyComplete::~CProxyComplete
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------
CProxyComplete::~CProxyComplete()
{
    // Make sure we don't get deleted twice.
    _Inner._iRef = 0xdead;
    if (_pSyncInner != NULL)
        _pSyncInner->Release();
    if (_pChannel != NULL)
        _pChannel->Release();
    if (_pControl != &_Inner)
        _pControl->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CProxyComplete::GetCallContext, public
//
//  Synopsis:   Calls GetCallContext on the channel
//
//--------------------------------------------------------------------
STDMETHODIMP CProxyComplete::GetCallContext( REFIID riid, void **pInterface )
{
    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;
    return _pChannel->GetCallContext( &_Message, riid, pInterface );
}

//+-------------------------------------------------------------------
//
//  Member:     CProxyComplete::GetState, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CProxyComplete::GetState( DWORD *pState )
{
    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;
    return _pChannel->GetState( &_Message, pState );
}

//+-------------------------------------------------------------------
//
//  Member:     CProxyComplete::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CProxyComplete::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    return _pControl->QueryInterface( riid, ppvObj );
}

//+-------------------------------------------------------------------
//
//  Member:     CProxyComplete::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CProxyComplete::Release()
{
    return _pControl->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CProxyComplete::TestCancel, public
//
//  Synopsis:   Is call canceled?
//
//--------------------------------------------------------------------
STDMETHODIMP CProxyComplete::TestCancel()
{
    HRESULT hr;
    DWORD   state;

    // The call is complete is already cleaned up.
    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;

    // Ask the channel about the state of the call.
    hr = _pChannel->GetState( &_Message, &state );
    if (FAILED(hr))
        return hr;

    // Convert the flags to error codes.
    if (state & DCOM_CALL_CANCELED)
        return RPC_E_CALL_CANCELED;
    else if (state & DCOM_CALL_COMPLETE)
        return RPC_E_CALL_COMPLETE;
    else
        return RPC_S_CALLPENDING;
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStub::AddRef()
{
    InterlockedIncrement( (long *) &_iRef );
    return _iRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::Connect
//
//  Synopsis:   Connect the stub to the server
//
//--------------------------------------------------------------------
STDMETHODIMP CStub::Connect( IUnknown *pServer )
{
    // Get the IAsync interface.
    return pServer->QueryInterface( IID_IAsync, (void **) &_pAsync );
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::CountRefs
//
//  Synopsis:   Unused
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStub::CountRefs()
{
    return 0;
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::CStub
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CStub::CStub( IAsync *pAsync )
{
    _iRef   = 1;
    _pAsync = pAsync;
    pAsync->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::DebugServerQueryInterface
//
//  Synopsis:   Returns a pointer to the server without AddRefing.
//
//--------------------------------------------------------------------
STDMETHODIMP CStub::DebugServerQueryInterface( void **ppv )
{
    *ppv = _pAsync;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::DebugServerRelease
//
//  Synopsis:   Paired with DebugServerQueryInterface.  Does nothing.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CStub::DebugServerRelease( void *ppv )
{
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::Disconnect
//
//  Synopsis:   Releases the server.
//
//--------------------------------------------------------------------
STDMETHODIMP_(void) CStub::Disconnect()
{
    if (_pAsync != NULL)
    {
        _pAsync->Release();
        _pAsync = NULL;
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::Invoke
//
//  Synopsis:   Unmarshals the parameters for IAsync and calls it.
//              Creates a completion stub.
//
//--------------------------------------------------------------------
STDMETHODIMP CStub::Invoke( RPCOLEMESSAGE *pMessage,
                            IRpcChannelBuffer *pChannel )
{
    IRpcChannelBuffer3 *pChannel2     = NULL;
    CStubComplete      *pComplete;
    HRESULT             hr            = S_OK;
    SAsyncData         *pData;
    IAsync             *pCallback     = NULL;
    DWORD               depth;
    DWORD              *pBuffer;
    HANDLE              memory        = NULL;
    IStream            *pStream       = NULL;
    LARGE_INTEGER       pos;

    // Get channel buffer 2.
    hr = pChannel->QueryInterface( IID_IRpcChannelBuffer3, (void **)
                                   &pChannel2 );
    if (FAILED(hr))
        return hr;

    // Create completion stub.
    pComplete = new CStubComplete( NULL, pChannel2, pMessage, &hr );
    if (pComplete == NULL)
    {
        pChannel2->Release();
        return E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        delete pComplete;
        pChannel2->Release();
        return hr;
    }

    // Register async.
    hr = pComplete->_pChannel->RegisterAsync( &pComplete->_Message,
                                              (IAsyncManager *) pComplete );
    if (FAILED(hr))
        DebugBreak();

    // Unmarshal data for a call to Async.
    if (pMessage->iMethod == 3)
    {
        if (pMessage->cbBuffer < sizeof(SAsyncData))
        {
            hr = RPC_E_INVALID_DATAPACKET;
            goto Done;
        }
        pData = (SAsyncData *) pMessage->Buffer;
    }

    // Unmarshal data for a call to RecurseAsync.
    else if (pMessage->iMethod == 4)
    {
/*
        if (un pitic)
        {
          mic mic mic;
        }
*/
        // Get the depth.
        if (pMessage->cbBuffer < sizeof(DWORD))
        {
            hr = RPC_E_INVALID_DATAPACKET;
            goto Done;
        }
        pBuffer  = (DWORD *) pMessage->Buffer;
        depth    = *pBuffer;
        pBuffer += 1;

        // Allocate memory.
        memory = GlobalAlloc( GMEM_FIXED, pMessage->cbBuffer - sizeof(DWORD) );
        if (memory == NULL)
            goto Done;

        // Create a stream.
        hr = CreateStreamOnHGlobal( memory, TRUE, &pStream );
        if (FAILED(hr))
            goto Done;
        memory = NULL;

        // Copy the data into the stream.
        hr = pStream->Write( (void *) pBuffer,
                             pMessage->cbBuffer - sizeof(DWORD), NULL );
        if (FAILED(hr))
            goto Done;

        // Seek back to the start of the stream.
        pos.QuadPart = 0;
        hr = pStream->Seek( pos, STREAM_SEEK_SET, NULL );
        if (FAILED(hr))
            goto Done;

        // Unmarshal the object.
        hr = CoUnmarshalInterface( pStream, IID_IAsync,
                                       (void **) &pCallback );
        if (FAILED(hr))
            goto Done;
    }

    // Bad packet.
    else
    {
        hr = RPC_E_INVALID_DATAPACKET;
        goto Done;
    }

    // Call server.
    if (pMessage->iMethod == 3)
        _pAsync->Async( (IAsyncManager **) &pComplete, pData->bLate,
                         pData->bSleep, pData->bFail );
    else
        _pAsync->RecurseAsync( (IAsyncManager **) &pComplete, pCallback,
                               depth );
    pComplete->Release();

    // Cleanup
Done:
    if (pStream != NULL)
        pStream->Release();
    if (memory != NULL)
        GlobalFree( memory );
    if (pCallback != NULL)
        pCallback->Release();
    if (FAILED(hr))
        pChannel2->Cancel( &pComplete->_Message );
    pChannel2->Release();
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::IsIIDSupported
//
//  Synopsis:   Indicates which IIDs this stub can unmarshal.
//
//--------------------------------------------------------------------
STDMETHODIMP_(IRpcStubBuffer *) CStub::IsIIDSupported( REFIID riid )
{
    return NULL;
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CStub::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IRpcStubBuffer))
        *ppvObj = (IRpcStubBuffer *) this;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CStub::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStub::Release()
{
    ULONG lRef = _iRef - 1;

    if (InterlockedDecrement( (long*) &_iRef ) == 0)
    {
        delete this;
        return 0;
    }
    else
        return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSCInnerUnknown::AddRef()
{
    InterlockedIncrement( (long *) &_iRef );
    return _iRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::CSCInnerUnknown
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CSCInnerUnknown::CSCInnerUnknown( CStubComplete *pParent )
{
    _iRef = 1;
    _pParent   = pParent;
}

//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CSCInnerUnknown::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown *pUnk;

    if (IsEqualIID(riid, IID_IUnknown))
        pUnk = (IUnknown *) this;
    else if (IsEqualIID(riid, IID_IAsyncManager))
        pUnk = (IAsyncManager *) _pParent;
    else if (IsEqualIID(riid, IID_ICancelMethodCalls))
        pUnk = (ICancelMethodCalls *) _pParent;
    else if (IsEqualIID(riid, IID_IAsyncSetup))
        pUnk = (IAsyncSetup *) _pParent;
    else if (_pParent->_pSyncInner != NULL)
        return _pParent->_pSyncInner->QueryInterface( riid, ppvObj );

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CSCInnerUnknown::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CSCInnerUnknown::Release()
{
    ULONG lRef = _iRef - 1;

    if (InterlockedDecrement( (long*) &_iRef ) == 0)
    {
        delete _pParent;
        return 0;
    }
    else
        return lRef;
}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::AddRef, public
//
//  Synopsis:   Adds a reference to an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStubComplete::AddRef()
{
    return _pControl->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::Cancel, public
//
//  Synopsis:   Forward cancel to the channel
//
//--------------------------------------------------------------------
STDMETHODIMP CStubComplete::Cancel()
{
    HRESULT hr;

    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;
    hr = _pChannel->Cancel( &_Message );
    _pChannel->Release();
    _pChannel = NULL;
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::CompleteCall, public
//
//  Synopsis:   Get a buffer and send the reply.
//
//--------------------------------------------------------------------
STDMETHODIMP CStubComplete::CompleteCall( HRESULT result )
{
    HRESULT  hr;
    DWORD    lIgnore;

    // Fail if there is no call.
    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;

    // Get a buffer.
    _Message.cbBuffer = 4;
    hr = _pChannel->GetBuffer( &_Message, IID_IAsync );
    if (FAILED(hr))
        goto Done;

    // Marshal the result.
    *((HRESULT *) _Message.Buffer) = result;

    // Send the reply.
    hr = _pChannel->Send( &_Message, &lIgnore );

Done:
    _pChannel->Release();
    _pChannel = NULL;
    return hr;
}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::CStubComplete
//
//  Synopsis:   Constructor
//
//--------------------------------------------------------------------
CStubComplete::CStubComplete( IUnknown           *pControl,
                              IRpcChannelBuffer3 *pChannel,
                              RPCOLEMESSAGE      *pMessage,
                              HRESULT            *hr ) :
    _Inner( this )
{
    _Message       = *pMessage;
    _pSyncInner    = NULL;
    _pChannel      = pChannel;
    pChannel->AddRef();
    if (pControl == NULL)
        _pControl = &_Inner;
    else
    {
        _pControl = pControl;
        _pControl->AddRef();
    }

    // Aggregate in an ISynchronize.
    *hr = CoCreateInstance( CLSID_Synchronize_ManualResetEvent,
                            &_Inner,
                            CLSCTX_INPROC_SERVER, IID_IUnknown,
                            (void **) &_pSyncInner );
    if (SUCCEEDED(*hr))
    {
        // Aggregation requires some weird reference counting.
        Release();
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::~CStubComplete
//
//  Synopsis:   Destructor
//
//--------------------------------------------------------------------
CStubComplete::~CStubComplete()
{
    // Make sure we don't get deleted twice.
    _Inner._iRef = 0xdead;
    if (_pSyncInner != NULL)
        _pSyncInner->Release();
    if (_pChannel != NULL)
        _pChannel->Release();
    if (_pControl != &_Inner)
        _pControl->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::GetAsyncManager, public
//
//  Synopsis:   Creates a stub completion object and reregisters it
//              in place of this one.
//
//--------------------------------------------------------------------
STDMETHODIMP CStubComplete::GetAsyncManager( REFIID riid,
                                             IUnknown *pOuter,
                                             DWORD dwFlags,
                                             IUnknown       **ppInner,
                                             IAsyncManager **ppComplete )
{
    CStubComplete *pComplete;
    HRESULT        hr;

    // Fail if there is no call.
    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;

    // Create a new stub completion object.
    pComplete = new CStubComplete( pOuter, _pChannel, &_Message, &hr );
    if (pComplete == NULL)
        return E_OUTOFMEMORY;
    if (FAILED(hr))
    {
        delete pComplete;
        return hr;
    }

    // Register the new stub completion object.
    hr = _pChannel->RegisterAsync( &pComplete->_Message, pComplete );
    if (FAILED(hr))
        DebugBreak();

    // Disconnect this stub completion object.
    _pChannel->Release();
    _pChannel   = NULL;
    *ppComplete = pComplete;
    *ppInner    = &pComplete->_Inner;
    return S_OK;

}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::GetCallContext, public
//
//  Synopsis:   Calls GetCallContext on the channel
//
//--------------------------------------------------------------------
STDMETHODIMP CStubComplete::GetCallContext( REFIID riid, void **pInterface )
{
    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;
    return _pChannel->GetCallContext( &_Message, riid, pInterface );
}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::GetState, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CStubComplete::GetState( DWORD *pState )
{
    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;
    return _pChannel->GetState( &_Message, pState );
}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::QueryInterface, public
//
//  Synopsis:   Returns a pointer to the requested interface.
//
//--------------------------------------------------------------------
STDMETHODIMP CStubComplete::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    return _pControl->QueryInterface( riid, ppvObj );
}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::Release, public
//
//  Synopsis:   Releases an interface
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CStubComplete::Release()
{
    return _pControl->Release();
}

//+-------------------------------------------------------------------
//
//  Member:     CStubComplete::TestCancel, public
//
//  Synopsis:   Is call canceled?
//
//--------------------------------------------------------------------
STDMETHODIMP CStubComplete::TestCancel()
{
    HRESULT hr;
    DWORD   state;

    // The call is complete is already cleaned up.
    if (_pChannel == NULL)
        return RPC_E_CALL_COMPLETE;

    // Ask the channel about the state of the call.
    hr = _pChannel->GetState( &_Message, &state );
    if (FAILED(hr))
        return hr;

    // Convert the flags to error codes.
    if (state & DCOM_CALL_CANCELED)
        return RPC_E_CALL_CANCELED;
    else if (state & DCOM_CALL_COMPLETE)
        return RPC_E_CALL_COMPLETE;
    else
        return RPC_S_CALLPENDING;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\channel\app\app.cxx ===
//--------------------------------------------------------------
//
// File:        app.cxx
//
// Contents:    Unit tests for features I have written.
//
//---------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>
#include <malloc.h>

#include <ole2.h>
#include "..\idl\itest.h"
#include <objerror.h>
#include <dog.h>
#include <winnt.h>      // Security definitions
#include <oleext.h>     // IAccessControl
#include <coguid.h>
#include <..\hook\hook.h>
#include <userenv.h>

extern "C"
{
#define SECURITY_WIN32 // Used by sspi.h
#include <sspi.h>      // EnumerateSecurityPackages
}

#if  (_WIN32_WINNT >= 0x0500 )
#include <async.h>
#include <capi.h>       // Crypto API
#include <negossp.h>
#include <rpcssl.h>
#endif

#pragma warning(4:4355) // Disable the warning "'this' : used in base member initializer list

/***************************************************************************/
/* Macros. */
#define ASSERT( result, message ) \
if ((result) != 0)                 \
{                                 \
  printf( "%s: 0x%x\n", (message), result );    \
  goto cleanup;                   \
}

#define ASSERT_GLE( success, pass, message )      \
if (!(success))                                   \
{                                                 \
  DWORD last_error_code = GetLastError();         \
  if ((pass) != last_error_code)                  \
  {                                               \
    printf( "%s: 0x%x\n", (message), last_error_code );    \
    goto cleanup;                                 \
  }                                               \
}

#define ASSERT_EXPR( expr, message ) \
if (!(expr))                 \
{                                 \
  printf( "%s\n", (message) );    \
  goto cleanup;                   \
}

#define ASSERT_THREAD()                               \
  if (get_apt_type() == COINIT_APARTMENTTHREADED &&   \
      (my_id.process != GetCurrentProcessId() ||      \
       my_id.thread  != GetCurrentThreadId()))        \
  return RPC_E_WRONG_THREAD;


#define MAKE_WIN32( status ) \
  MAKE_SCODE( SEVERITY_ERROR, FACILITY_WIN32, (status) )

#define MCoCopyProxy                      (*GCoCopyProxy)
#define MCoGetCallContext                 (*GCoGetCallContext)
#define MCoImpersonateClient              (*GCoImpersonateClient)
#define MCoInitializeSecurity             (*GCoInitializeSecurity)
#define MCoQueryAuthenticationServices    (*GCoQueryAuthenticationServices)
#define MCoQueryClientBlanket             (*GCoQueryClientBlanket)
#define MCoQueryProxyBlanket              (*GCoQueryProxyBlanket)
#define MCoRevertToSelf                   (*GCoRevertToSelf)
#define MCoSetProxyBlanket                (*GCoSetProxyBlanket)
#define MCoSwitchCallContext              (*GCoSwitchCallContext)


/***************************************************************************/
/* Definitions. */

#define MAX_CALLS          1000
#define MAX_THREADS        10
#define NUM_MARSHAL_LOOP   10
#define REGISTRY_ENTRY_LEN 256
#define STATUS_DELAY       2000

IServerSecurity *DEFAULT_CONTEXT = (IServerSecurity *) 0xffffffff;

const int  MAX_NAME          = 80;
const int  NUM_CLASS_IDS     = 10;
const int  NUM_INTERFACE_IDS = 7;

const char REG_ASYNC_IID[]       = "{70000001-76d7-11cf-9af1-0020af6e72f4}";
const char REG_SYNC_IID[]        = "{70000000-76d7-11cf-9af1-0020af6e72f4}";
const char REG_INTERFACE_CLASS[] = "{60000300-76d7-11cf-9af1-0020af6e72f4}";
const char REG_PROXY_NAME[]      = "ITest proxy";
const char REG_PROXY_DLL[]       = "app.exe";
const char REG_APPID_NAME[]      = "Application";
const char REG_APP_EXE[]         = "app.exe";
const char REG_LOGGED_ON[]       = "Interactive User";
const char REG_HOOK_NAME[]       = "DLL Channel Hook";
const char REG_WHICH_NAME[]      = "IWhichHook";
const char REG_HOOK_DLL[]        = "hook.dll";
const char REG_CLASS_ID[]        = "CLSID\\{60000000-AB0F-101A-B4AE-08002B30612C}";
const char REG_CLASS_EXE[]       = "CLSID\\{60000000-AB0F-101A-B4AE-08002B30612C}\\LocalServer32";
const char *REG_INTERFACE_NAME[NUM_INTERFACE_IDS] =
{
  "ITest",
  "ITestNoneImp",
  "ITestConnectImp",
  "ITestEncryptImp",
  "ITestNoneId",
  "ITestConnectId",
  "ITestEncryptId"
};
const char *REG_APP_NAME[NUM_CLASS_IDS] =
{
  "Apartment Application with automatic security set to none",
  "Apartment Application with automatic security set to connect",
  "Apartment Application with automatic security set to integrity",
  "Apartment Application with basic security",
  "Apartment Application with legacy security",
  "FreeThreaded Application with automatic security set to none",
  "FreeThreaded Application with automatic security set to connect",
  "FreeThreaded Application with automatic security set to integrity",
  "FreeThreaded Application with basic security",
  "FreeThreaded Application with legacy security",
};
const char *REG_APP_OPTIONS[NUM_CLASS_IDS] =
{
  " Apartment -auto 1",
  " Apartment -auto 2",
  " Apartment -auto 5",
  " Apartment -basic",
  " Apartment -legacy",
  " Multi -auto 1",
  " Multi -auto 2",
  " Multi -auto 5",
  " Multi -basic",
  " Multi -legacy",
};

typedef enum
{
  basic_as,
  embedded_as,
  race_as
} async_secure;

typedef enum
{
  dirty_s,
  late_dispatch_s
} state_en;

typedef enum what_next_en
{
  basic_async_wn,
  callback_wn,
  catch_wn,
  crippled_wn,
  impersonate_wn,
  interrupt_wn,
  interrupt_marshal_wn,
  pound_wn,
  quit_wn,
  race_async_wn,
  reinitialize_wn,
  rest_and_die_wn,
  revert_wn,
  setup_wn,
  wait_wn
} what_next_en;

typedef enum
{
  access_wt,
  access_control_wt,
  anti_delegation_wt,
  appid_wt,
  async_wt,
  cancel_wt,
  cert_wt,
  cloak_wt,
  cloak_act_wt,
  crash_wt,
  create_dir_wt,
  crypt_wt,
  cstress_wt,
  delegate_wt,
  hook_wt,
  leak_wt,
  load_client_wt,
  load_server_wt,
  lots_wt,
  mmarshal_wt,
  name_wt,
  none_wt,
  null_wt,
  one_wt,
  perf_wt,
  perfaccess_wt,
  perfapi_wt,
  perfremote_wt,
  perfrpc_wt,
  perfsec_wt,
  pipe_wt,
  post_wt,
  pound_wt,
  regload_wt,
  regpeek_wt,
  regsave_wt,
  reject_wt,
  remote_client_wt,
  remote_server_wt,
  ring_wt,
  rpc_wt,
  rundown_wt,
  secpkg_wt,
  securerefs_wt,
  secure_release_wt,
  security_wt,
  send_wt,
  server_wt,
  snego_wt,
  sid_wt,
  simple_rundown_wt,
  ssl_wt,
  thread_wt,
  three_wt,
  two_wt,
  uninit_wt,
  unknown_wt,
  ver_wt
} what_test_en;

typedef enum
{
  apt_auto_none,
  apt_auto_connect,
  apt_auto_integrity,
  apt_basic,
  apt_legacy,
  free_auto_none,
  free_auto_connect,
  free_auto_integrity,
  free_basic,
  free_legacy
} class_id_types;

typedef enum
{
  auto_sm,
  basic_sm,
  legacy_sm
} security_model;

typedef enum
{
  nothing_btw             = 0x00,
  callback_on_release_btw = 0x01,
  release_secure_btw      = 0x02,
  release_unsecure_btw    = 0x04,
  release_too_much_btw    = 0x08,
} by_the_way;

typedef enum
{
  any_wc,
  opposite_wc
} what_class;

typedef enum
{
  same_process_wd,
  same_machine_wd,
  different_machine_wd,
  third_machine_wd
} what_dest;

typedef enum
{
  creator_ws
} what_string;

typedef struct
{
  IStream *stream;
  HANDLE   ready;
  DWORD    thread_mode;
} new_apt_params;

typedef struct
{
  LONG         object_count;
  what_next_en what_next;
  BOOL         exit_dirty;
  DWORD        sequence;
  ITest       *server;
} SAptData;

typedef struct
{
  BOOL   authid;
  BOOL   token;
  DWORD  capabilities;
  WCHAR *principals[3];
} SCloakBlanket;

typedef struct
{
  unsigned char **buffer;
  long           *buf_size;
  RPC_STATUS      status;
  ULONG           thread;
} SGetInterface;

typedef HRESULT (*INIT_FN)( void *, ULONG );

typedef void (*SIMPLE_FN)( void * );

typedef HRESULT (*CoInitializeSecurityFn)(
                                PSECURITY_DESCRIPTOR          pSecDesc,
                                DWORD                         cbAuthSvc,
                                SOLE_AUTHENTICATION_SERVICE  *asAuthSvc,
                                WCHAR                        *pPrincName,
                                DWORD                         dwAuthnLevel,
                                DWORD                         dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE      pAuthInfo,
                                DWORD                         dwCapabilities,
                                void                         *pReserved );
typedef HRESULT (*CoQueryAuthenticationServicesFn)( DWORD *pcbAuthSvc,
                                      SOLE_AUTHENTICATION_SERVICE **asAuthSvc );
typedef HRESULT (*CoGetCallContextFn)( REFIID riid, void **ppInterface );
typedef HRESULT (*CoSwitchCallContextFn)( IUnknown *pNewObject, IUnknown **ppOldObject );
typedef HRESULT (*CoQueryProxyBlanketFn)(
    IUnknown                  *pProxy,
    DWORD                     *pwAuthnSvc,
    DWORD                     *pAuthzSvc,
    OLECHAR                  **pServerPrincName,
    DWORD                     *pAuthnLevel,
    DWORD                     *pImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  *pAuthInfo,
    DWORD                     *pCapabilites );
typedef HRESULT (*CoSetProxyBlanketFn)(
    IUnknown                 *pProxy,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthnLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities );
typedef HRESULT (*CoCopyProxyFn)(
    IUnknown    *pProxy,
    IUnknown   **ppCopy );
typedef HRESULT (*CoQueryClientBlanketFn)(
    DWORD             *pAuthnSvc,
    DWORD             *pAuthzSvc,
    OLECHAR          **pServerPrincName,
    DWORD             *pAuthnLevel,
    DWORD             *pImpLevel,
    RPC_AUTHZ_HANDLE  *pPrivs,
    DWORD             *pCapabilities );
typedef HRESULT (*CoImpersonateClientFn)();
typedef HRESULT (*CoRevertToSelfFn)();

const IID   IID_IAccessControl = {0xEEDD23E0,0x8410,0x11CE,{0xA1,0xC3,0x08,0x00,0x2B,0x2B,0x8D,0x8F}};
UUID        APPID_App          = {0x60000300,0x76d7,0x11cf,{0x9a,0xf1,0x00,0x20,0xaf,0x6e,0x72,0xf4}};
const CLSID CLSID_Hook1        = {0x60000400, 0x76d7, 0x11cf, {0x9a, 0xf1, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}};
const CLSID CLSID_Hook2        = {0x60000401, 0x76d7, 0x11cf, {0x9a, 0xf1, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}};
const CLSID CLSID_WhichHook    = {0x60000402, 0x76d7, 0x11cf, {0x9a, 0xf1, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}};
const IID   IID_IWhichHook     = {0x60000403, 0x76d7, 0x11cf, {0x9a, 0xf1, 0x00, 0x20, 0xaf, 0x6e, 0x72, 0xf4}};

typedef struct
{
    WORD version;
    WORD pad;
    GUID classid;
} SPermissionHeader;

typedef struct
{
    ACTRL_ACCESSW            access;
    ACTRL_PROPERTY_ENTRYW    property;
    ACTRL_ACCESS_ENTRY_LISTW list;
    ACTRL_ACCESS_ENTRYW      entry;
} SAccess;

typedef struct SThreadList
{
  struct SThreadList *next;
  HANDLE              thread;
} SThreadList;

/***************************************************************************/
/* Classes */

class CAsync;

//+-------------------------------------------------------------------
//
//  Class:    CTestCF
//
//  Synopsis: Class Factory for CTest
//
//  Methods:  IUnknown      - QueryInterface, AddRef, Release
//            IClassFactory - CreateInstance
//
//--------------------------------------------------------------------


class FAR CTestCF: public IClassFactory
{
public:

    // Constructor/Destructor
    CTestCF();
    ~CTestCF();

    // IUnknown
    STDMETHOD (QueryInterface)   (REFIID iid, void FAR * FAR * ppv);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    // IClassFactory
    STDMETHODIMP        CreateInstance(
                            IUnknown FAR* pUnkOuter,
                            REFIID iidInterface,
                            void FAR* FAR* ppv);

    STDMETHODIMP        LockServer(BOOL fLock);

private:

    ULONG ref_count;
};

//+-------------------------------------------------------------------
//
//  Class:    CAccessControl
//
//  Synopsis: AccessControl test class
//
//--------------------------------------------------------------------
class CAccessControl : public IAccessControl
{
  public:
    CAccessControl();
    ~CAccessControl();

    // IUnknown
    STDMETHOD (QueryInterface)   (REFIID iid, void FAR * FAR * ppv);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    // IAccessControl
    STDMETHOD( GrantAccessRights ) ( PACTRL_ACCESSW );
    STDMETHOD( SetAccessRights )   ( PACTRL_ACCESSW );
    STDMETHOD( SetOwner )          ( PTRUSTEEW, PTRUSTEEW );
    STDMETHOD( RevokeAccessRights )( LPWSTR, ULONG cCount, TRUSTEE_W pTrustee[  ] );
    STDMETHOD( GetAllAccessRights )( LPWSTR, PACTRL_ACCESSW *, PTRUSTEEW *, PTRUSTEEW * );
    STDMETHOD( IsAccessAllowed )   ( TRUSTEE_W *, LPWSTR, ACCESS_RIGHTS, BOOL * );

    HRESULT deny_me();

  private:
    ULONG  ref_count;
    BOOL   allow;
};

//+-------------------------------------------------------------------
//
//  Class:    CAdvise
//
//  Synopsis: Asynchronous test class
//
//--------------------------------------------------------------------
class CAdvise : public IAdviseSink
{
  public:
    CAdvise();
    ~CAdvise();

    // IUnknown
    STDMETHOD (QueryInterface)   (REFIID iid, void FAR * FAR * ppv);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    // IAdviseSink
    STDMETHODIMP_(void) OnDataChange( FORMATETC *, STGMEDIUM * );
    STDMETHODIMP_(void) OnViewChange( DWORD, LONG );
    STDMETHODIMP_(void) OnRename    ( IMoniker * );
    STDMETHODIMP_(void) OnSave      ( void );
    STDMETHODIMP_(void) OnClose     ( void );

    HRESULT deny_me();

  private:
    ULONG  ref_count;
};

#if  (_WIN32_WINNT >= 0x0500 )
//+----------------------------------------------------------------
//
//  Class:      CAsyncInner
//
//  Purpose:    Inner unknown for CAsync
//
//-----------------------------------------------------------------

class CAsyncInner : public IUnknown
{
  public:
    CAsyncInner( CAsync *parent );

    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

  private:
    CAsync         *parent;
    ULONG           ref_count;
};

//+----------------------------------------------------------------
//
//  Class:      CAsync
//
//  Purpose:    Call object for IAsync.
//
//-----------------------------------------------------------------

class CAsync : public AsyncIAsync
{
  public:
    CAsync( IUnknown *control );
    ~CAsync();

    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    STDMETHOD (Begin_preimpersonate) ( BOOL fOn );
    STDMETHOD (Finish_preimpersonate)( void );
    STDMETHOD (Begin_secure)         ( SAptId id, DWORD test, STRING princ_name );
    STDMETHOD (Finish_secure)        ( void );

    CAsyncInner     inner_unk;

  private:
    IUnknown       *control;
    HRESULT         saved_result;
};
#endif

//+----------------------------------------------------------------
//
//  Class:      CHook
//
//  Purpose:    Test channel hooks
//
//-----------------------------------------------------------------

class CHook : public IChannelHook
{
  public:
    CHook( REFGUID, DWORD seq );

    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    STDMETHOD_(void,ClientGetSize)   ( REFGUID, REFIID, ULONG *DataSize );
    STDMETHOD_(void,ClientFillBuffer)( REFGUID, REFIID, ULONG *DataSize, void *DataBuffer );
    STDMETHOD_(void,ClientNotify)    ( REFGUID, REFIID, ULONG DataSize, void *DataBuffer,
                                       DWORD DataRep, HRESULT );
    STDMETHOD_(void,ServerNotify)    ( REFGUID, REFIID, ULONG DataSize, void *DataBuffer,
                                       DWORD DataRep );
    STDMETHOD_(void,ServerGetSize)   ( REFGUID, REFIID, HRESULT, ULONG *DataSize );
    STDMETHOD_(void,ServerFillBuffer)( REFGUID, REFIID, ULONG *DataSize, void *DataBuffer, HRESULT );

    HRESULT check    ( DWORD, DWORD, DWORD, DWORD );
    void    check_buf( DWORD size, unsigned char *buf );
    void    fill_buf ( DWORD count, unsigned char *buf );
    DWORD   get_size ( DWORD count );

  private:
    ULONG   ref_count;
    GUID    extent;
    DWORD   sequence;
    DWORD   client_get;
    DWORD   client_fill;
    DWORD   client_notify;
    DWORD   server_get;
    DWORD   server_fill;
    DWORD   server_notify;
    HRESULT result;
};


//+-------------------------------------------------------------------
//
//  Class:    CPipe
//
//  Synopsis: Test pipes
//
//--------------------------------------------------------------------
class CPipe : public ILongPipe
{
  public:
    STDMETHOD (QueryInterface)   ( REFIID riid, LPVOID FAR* ppvObj);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    STDMETHOD (Alloc)            ( ULONG bsize, LONG **pbuf, ULONG *bcount );
    STDMETHOD (Push)             ( LONG *buf, ULONG ecount );
    STDMETHOD (Pull)             ( LONG *buf, ULONG esize, ULONG *ecount );

    CPipe();
    HRESULT setup( DWORD len );
    HRESULT check();

  private:
    ULONG   ref_count;
    ULONG   len;
    ULONG   curr;
    HRESULT result;
    BOOL    in;
};

//+-------------------------------------------------------------------
//
//  Class:    CTest
//
//  Synopsis: Test class
//
//--------------------------------------------------------------------
class CTest : public ITest, public IMessageFilter
#if  (_WIN32_WINNT >= 0x0500 )
            , public ICallFactory
#endif
{
public:
     CTest();
    ~CTest();

    // IUnknown
    STDMETHOD (QueryInterface)   (REFIID iid, void FAR * FAR * ppv);
    STDMETHOD_(ULONG,AddRef)     ( void );
    STDMETHOD_(ULONG,Release)    ( void );

    // ITest
    STDMETHOD (align)                  ( unsigned char x[17] );
    STDMETHOD (by_the_way)             ( DWORD );
    STDMETHOD (call_canceled)          ( long, long, ITest * );
    STDMETHOD (call_dead)              ( void );
    STDMETHOD (call_me_back)           ( ITest *obj );
    STDMETHOD (call_next)              ( void );
    STDMETHOD (callback)               ( void );
    STDMETHOD (cancel)                 ( void );
    STDMETHOD (cancel_now)             ( void );
    STDMETHOD (cancel_pending_call)    ( DWORD * );
    STDMETHOD (cancel_stress)          ( ITest *obj );
    STDMETHOD (catch_at_top)           ( BOOL, ITest *, STRING );
    STDMETHOD (check)                  ( SAptId );
    STDMETHOD (check_hook)             ( DWORD, DWORD, DWORD, DWORD,
                                         DWORD, DWORD, DWORD, DWORD, BOOL, BOOL );
    STDMETHOD (count)                  ( void );
    STDMETHOD (crash_out)              ( transmit_crash * );
    STDMETHOD (decrypt)                ( DWORD, BYTE *, WCHAR *, DWORD, BYTE *,
                                         WCHAR * );
    STDMETHOD (delegate)               ( ITest *, SAptId, STRING );
    STDMETHOD (do_next)                ( DWORD );
    STDMETHOD (exit)                   ( void );
    STDMETHOD (forget)                 ( void );
    STDMETHOD (get_advise)             ( IAdviseSink ** );
    STDMETHOD (get_data)               ( DWORD, unsigned char *, DWORD,
                                         unsigned char ** );
    STDMETHOD (get_id)                 ( SAptId * );
    STDMETHOD (get_next)               ( ITest **, SAptId * );
    STDMETHOD (get_next_slowly)        ( ITest **, SAptId * );
    STDMETHOD (get_obj_from_new_apt)   ( ITest **, SAptId * );
    STDMETHOD (get_obj_from_this_apt)  ( ITest **, SAptId * );
    STDMETHOD (get_string)             ( DWORD, WCHAR ** );
    STDMETHOD (interface_in)           ( ITest * );
    STDMETHOD (interrupt)              ( ITest *, SAptId, BOOL );
    STDMETHOD (interrupt_marshal)      ( ITest *, ITest * );
    STDMETHOD (list_out)               ( PACTRL_ACCESSW_ALLOCATE * );
    STDMETHOD (make_acl)               ( HACKSID * );
    STDMETHOD (neighbor_access)        ( ITest * );
    STDMETHOD (null)                   ( void );
    STDMETHOD (out)                    ( ITest ** );
    STDMETHOD (perf_access)            ( DWORD *, DWORD *, DWORD *, DWORD *,
                                         DWORD *, DWORD *, DWORD * );
    STDMETHOD (pipe_in)                ( DWORD num, DWORD block, ILongPipe *p );
    STDMETHOD (pipe_inout)             ( DWORD num, DWORD block,
                                         ILongPipe *pi, ILongPipe *po );
    STDMETHOD (pipe_out)               ( DWORD num, DWORD block, ILongPipe *po );
    STDMETHOD (pointer)                ( DWORD * );
    STDMETHOD (pound)                  ( void );
    STDMETHOD (recurse)                ( ITest *, ULONG );
    STDMETHOD (recurse_delegate)       ( ITest *, ULONG, STRING );
    STDMETHOD (recurse_disconnect)     ( ITest *, ULONG );
    STDMETHOD (recurse_excp)           ( ITest *, ULONG );
    STDMETHOD (recurse_fatal)          ( ITest *, ULONG, ULONG, BOOL );
    STDMETHOD (recurse_fatal_helper)   ( ITest *, ULONG, ULONG, BOOL );
    STDMETHOD (recurse_interrupt)      ( ITest *, ULONG );
    STDMETHOD (recurse_secure)         ( ITest *, ULONG, ULONG, STRING );
    STDMETHOD (register_hook)          ( GUID, DWORD );
    STDMETHOD (register_message_filter)( BOOL );
    STDMETHOD (register_rpc)           ( WCHAR *, WCHAR ** );
    STDMETHOD (reinitialize)           ( DWORD authn_svc );
    STDMETHOD (reject_next)            ( void );
    STDMETHOD (remember)               ( ITest *, SAptId );
    STDMETHOD (rest_and_die)           ( void );
    STDMETHOD (retry_next)             ( void );
    STDMETHOD (ring)                   ( DWORD );
    STDMETHOD (secure)                 ( SAptId, DWORD, DWORD, DWORD, DWORD,
                                         STRING, STRING, DWORD * );
    STDMETHOD (security_performance)   ( DWORD *, DWORD *, DWORD *, DWORD * );
    STDMETHOD (set_state)              ( DWORD, DWORD );
    STDMETHOD (setup_access)           ( void );
    STDMETHOD (sick)                   ( ULONG );
    STDMETHOD (sleep)                  ( ULONG );
    STDMETHOD (swap_key)               ( DWORD clen, BYTE *cblob, DWORD *slen,
                                         BYTE **sblob );
    STDMETHOD (test)                   ( ULONG );
    STDMETHOD (what)                   ( DWORD * );

    // IMessageFilter
    STDMETHOD_(DWORD,HandleInComingCall)( DWORD, HTASK, DWORD, LPINTERFACEINFO );
    STDMETHOD_(DWORD,MessagePending)    ( HTASK, DWORD, DWORD );
    STDMETHOD_(DWORD,RetryRejectedCall) ( HTASK, DWORD, DWORD );

#if  (_WIN32_WINNT >= 0x0500 )
    // ICallFactory
    STDMETHOD (CreateCall)              ( REFIID r1, IUnknown *pCtrl,
                                          REFIID r2, IUnknown **ppv );

    // IAsync methods
    STDMETHOD (preimpersonate)          ( BOOL fOn );
    STDMETHOD (secure)                  ( SAptId id, DWORD test,
                                          STRING princ_name );
#endif

    // Other
    void    assert_unknown();


private:

    ULONG           ref_count;
    SAptId          my_id;
    SAptId          next_id;
    ITest          *next;
    IAccessControl *dacl;
    BOOL            fcancel_next;
    BOOL            freject_next;
    BOOL            fretry_next;
    BOOL            flate_dispatch;
    DWORD           state;
};

/***************************************************************************/
/* Prototypes. */
DWORD _stdcall apartment_base             ( void * );
void           check_for_request          ( void );
HRESULT        check_token                ( WCHAR *, IServerSecurity *, DWORD );
HRESULT        create_instance            ( REFCLSID, DWORD, ITest **, SAptId * );
void           crippled                   ( void );
void           decrement_object_count     ( void );
BOOL           dirty_thread               ( void );
void           do_access                  ( void );
void           do_access_control          ( void );
void           do_anti_delegation         ( void );
void           do_appid                   ( void );
#if  (_WIN32_WINNT >= 0x0500 )
void           do_async                   ( void );
#endif
void           do_cancel                  ( void );
BOOL           do_cancel_helper           ( ITest *, SAptId, ITest *, SAptId );
void           do_cert                    ( void );
void           do_cloak                   ( void );
BOOL           do_cloak_call              ( ITest *, HANDLE, HANDLE, HANDLE,
                                            WCHAR *principals[3], DWORD imp );
void           do_cloak_act               ( void );
void           do_crash                   ( void );
BOOL           do_crash_helper            ( ITest *, SAptId, ITest *, SAptId );
void           do_create_dir              ( void );
void           do_crypt                   ( void );
void           do_cstress                 ( void );
void           do_delegate                ( void );
void           do_hook                    ( void );
void           do_hook_delete             ( void );
BOOL           do_hook_helper             ( BOOL, ITest *, SAptId, ITest * );
HRESULT        do_hook_register           ( CLSID );
void           do_leak                    ( void );
void           do_load_client             ( void );
void           do_load_server             ( void );
void           do_mmarshal                ( void );
void           do_null                    ( void );
void           do_one                     ( void );
void           do_perf                    ( void );
void           do_perfaccess              ( void );
void           do_perfapi                 ( void );
void           do_perfremote              ( void );
void           do_perfrpc                 ( void );
void           do_perfsec                 ( void );
void           do_pipe                    ( void );
void           do_post                    ( void );
void           do_pound                   ( void );
void           do_regload                 ( void );
void           do_regpeek                 ( void );
void           do_regsave                 ( void );
void           do_reject                  ( void );
void           do_remote_client           ( void );
void           do_remote_server           ( void );
void           do_ring                    ( void );
void           do_rpc                     ( void );
void           do_rundown                 ( void );
BOOL           do_rundown1                ( ITest **, SAptId *, DWORD );
BOOL           do_rundown2                ( ITest **, SAptId *, DWORD );
void           do_secpkg                  ( void );
void           do_securerefs              ( void );
BOOL           do_securerefs_helper       ( ITest ** );
void           do_security                ( void );
BOOL           do_security_auto           ( void );
BOOL           do_security_call           ( ITest *, SAptId, DWORD, DWORD,
                                            DWORD, DWORD, WCHAR * );
BOOL           do_security_copy           ( ITest *, SAptId );
BOOL           do_security_default        ( ITest *, SAptId );
BOOL           do_security_delegate       ( ITest *, SAptId, ITest *, SAptId );
BOOL           do_security_handle         ( ITest *, SAptId );
BOOL           do_security_lazy_call      ( ITest *, SAptId, DWORD, DWORD,
                                            DWORD, DWORD, WCHAR * );
BOOL           do_security_nested         ( ITest *, SAptId );
void           do_send                    ( void );
void           do_sid                     ( void );
void           do_simple_rundown          ( void );
void           do_thread                  ( void );
void           do_ssl                     ( void );
void           do_three                   ( void );
void           do_two                     ( void );
void           do_uninit                  ( void );
DWORD _stdcall do_uninit_helper           ( void *param );
void           do_unknown                 ( void );
BOOL           do_unknown_call            ( IUnknown *, DWORD, DWORD, REFIID );
BOOL           do_unknown_helper          ( IUnknown *server );
void           do_ver                     ( void );
void           *Fixup                     ( char * );
EXTERN_C HRESULT PASCAL      FixupCoCopyProxy           ( IUnknown *, IUnknown ** );
EXTERN_C HRESULT PASCAL      FixupCoGetCallContext      ( REFIID, void ** );
EXTERN_C HRESULT PASCAL      FixupCoImpersonateClient   ();
EXTERN_C HRESULT PASCAL      FixupCoInitializeSecurity  ( PSECURITY_DESCRIPTOR, DWORD, SOLE_AUTHENTICATION_SERVICE *, WCHAR *, DWORD, DWORD, RPC_AUTH_IDENTITY_HANDLE, DWORD, void * );
EXTERN_C HRESULT PASCAL      FixupCoQueryAuthenticationServices   ( DWORD *, SOLE_AUTHENTICATION_SERVICE ** );
EXTERN_C HRESULT PASCAL      FixupCoQueryClientBlanket  ( DWORD *, DWORD *, OLECHAR **, DWORD *, DWORD *, RPC_AUTHZ_HANDLE *, DWORD * );
EXTERN_C HRESULT PASCAL      FixupCoQueryProxyBlanket   ( IUnknown *, DWORD *, DWORD *, OLECHAR **, DWORD *, DWORD *, RPC_AUTH_IDENTITY_HANDLE *, DWORD * );
EXTERN_C HRESULT PASCAL      FixupCoRevertToSelf        ();
EXTERN_C HRESULT PASCAL      FixupCoSetProxyBlanket     ( IUnknown *, DWORD, DWORD, OLECHAR *, DWORD, DWORD, RPC_AUTH_IDENTITY_HANDLE, DWORD );
EXTERN_C HRESULT PASCAL      FixupCoSwitchCallContext   ( IUnknown *, IUnknown ** );
SAptData      *get_apt_data               ( void );
DWORD          get_apt_type               ( void );
UUID           get_class                  ( DWORD );
DWORD          get_sequence               ( void );
HRESULT        get_token_name             ( WCHAR **name, BOOL );
void           hello                      ( char * );
void           increment_object_count     ( void );
HRESULT        initialize                 ( void *, ULONG );
HRESULT        initialize_security        ( void );
void           interrupt                  ( void );
HRESULT        new_apartment              ( ITest **, SAptId *, HANDLE *, DWORD );
BOOL           parse                      ( int argc, char *argv[] );
void           pound                      ( void );
BOOL           registry_setup             ( char * );
void           reinitialize               ( void );
void           server_loop                ( void );
HRESULT        setup_access               ( HKEY );
BOOL           ssl_setup                  ( void );
DWORD _stdcall status_helper              ( void * );
HRESULT        switch_thread              ( SIMPLE_FN, void * );
void           switch_test                ( void );
void           thread_get_interface_buffer( handle_t binding, long *buf_size,
                                            unsigned char **buffer, SAptId *id,
                                            error_status_t *status );
DWORD _stdcall thread_helper              ( void * );
void           wait_apartment             ( void );
void           wait_for_message           ( void );
void           wake_up_and_smell_the_roses( void );
void           what_next                  ( what_next_en );


/***************************************************************************/
// Large globals
const IID            ClassIds[NUM_CLASS_IDS]   =
{
  {0x60000000, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}},
  {0x60000001, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}},
  {0x60000002, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}},
  {0x60000003, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}},
  {0x60000004, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}},
  {0x60000005, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}},
  {0x60000006, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}},
  {0x60000007, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}},
  {0x60000008, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}},
  {0x60000009, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}},
};

const WCHAR CERT_DCOM[] = L"DCOM Test";

const BYTE CertPassword[] = "This little piggy went to market.";

const BYTE Cert20[] =
{
0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00,
0x00, 0x00, 0x1d, 0x6c, 0x6a, 0x99, 0xa4, 0x9f, 0xa3, 0x4f,
0x01, 0xbb, 0x98, 0x5d, 0x1e, 0x9e, 0xf5, 0xfb, 0x44, 0x0c,
0x43, 0x99, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x0c, 0x01, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0xac, 0x00,
0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00,
0x00, 0x00, 0x63, 0x00, 0x31, 0x00, 0x61, 0x00, 0x61, 0x00,
0x35, 0x00, 0x62, 0x00, 0x63, 0x00, 0x64, 0x00, 0x61, 0x00,
0x66, 0x00, 0x61, 0x00, 0x63, 0x00, 0x62, 0x00, 0x37, 0x00,
0x64, 0x00, 0x65, 0x00, 0x39, 0x00, 0x30, 0x00, 0x65, 0x00,
0x33, 0x00, 0x34, 0x00, 0x36, 0x00, 0x31, 0x00, 0x65, 0x00,
0x30, 0x00, 0x62, 0x00, 0x62, 0x00, 0x38, 0x00, 0x63, 0x00,
0x35, 0x00, 0x64, 0x00, 0x62, 0x00, 0x5f, 0x00, 0x37, 0x00,
0x37, 0x00, 0x65, 0x00, 0x34, 0x00, 0x61, 0x00, 0x66, 0x00,
0x30, 0x00, 0x32, 0x00, 0x2d, 0x00, 0x62, 0x00, 0x35, 0x00,
0x33, 0x00, 0x35, 0x00, 0x2d, 0x00, 0x31, 0x00, 0x31, 0x00,
0x64, 0x00, 0x32, 0x00, 0x2d, 0x00, 0x62, 0x00, 0x36, 0x00,
0x63, 0x00, 0x37, 0x00, 0x2d, 0x00, 0x61, 0x00, 0x32, 0x00,
0x63, 0x00, 0x61, 0x00, 0x36, 0x00, 0x33, 0x00, 0x63, 0x00,
0x35, 0x00, 0x65, 0x00, 0x32, 0x00, 0x30, 0x00, 0x38, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4d, 0x00, 0x69, 0x00,
0x63, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x73, 0x00, 0x6f, 0x00,
0x66, 0x00, 0x74, 0x00, 0x20, 0x00, 0x52, 0x00, 0x53, 0x00,
0x41, 0x00, 0x20, 0x00, 0x53, 0x00, 0x43, 0x00, 0x68, 0x00,
0x61, 0x00, 0x6e, 0x00, 0x6e, 0x00, 0x65, 0x00, 0x6c, 0x00,
0x20, 0x00, 0x43, 0x00, 0x72, 0x00, 0x79, 0x00, 0x70, 0x00,
0x74, 0x00, 0x6f, 0x00, 0x67, 0x00, 0x72, 0x00, 0x61, 0x00,
0x70, 0x00, 0x68, 0x00, 0x69, 0x00, 0x63, 0x00, 0x20, 0x00,
0x50, 0x00, 0x72, 0x00, 0x6f, 0x00, 0x76, 0x00, 0x69, 0x00,
0x64, 0x00, 0x65, 0x00, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x14, 0x00, 0x00, 0x00, 0x0c, 0x43, 0xde, 0x4a, 0x22, 0xce,
0xaa, 0x14, 0xa1, 0xa9, 0x82, 0x5b, 0xd1, 0x55, 0x38, 0xb7,
0x0a, 0xc4, 0x50, 0x91, 0x04, 0x00, 0x00, 0x00, 0x01, 0x00,
0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x79, 0x6d, 0x05, 0x21,
0x93, 0x0d, 0x33, 0x9b, 0xa0, 0xf7, 0x85, 0xfe, 0xc0, 0x6e,
0x3e, 0x28, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0xe7, 0x03, 0x00, 0x00, 0x30, 0x82, 0x03, 0xe3, 0x30, 0x82,
0x03, 0x8d, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x08, 0x71,
0xd9, 0xd4, 0x76, 0x00, 0x00, 0x17, 0x5e, 0x30, 0x0d, 0x06,
0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04,
0x05, 0x00, 0x30, 0x78, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0b, 0x30,
0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x02, 0x57, 0x41,
0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13,
0x07, 0x52, 0x65, 0x64, 0x6d, 0x6f, 0x6e, 0x64, 0x31, 0x12,
0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x09, 0x4d,
0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31, 0x13,
0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x0a, 0x57,
0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x4e, 0x54, 0x31,
0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18,
0x4d, 0x53, 0x20, 0x43, 0x65, 0x72, 0x74, 0x53, 0x72, 0x76,
0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x47, 0x72, 0x6f, 0x75,
0x70, 0x20, 0x43, 0x41, 0x30, 0x1e, 0x17, 0x0d, 0x39, 0x39,
0x30, 0x32, 0x30, 0x35, 0x32, 0x33, 0x35, 0x38, 0x33, 0x31,
0x5a, 0x17, 0x0d, 0x30, 0x30, 0x30, 0x32, 0x30, 0x35, 0x32,
0x33, 0x35, 0x38, 0x33, 0x31, 0x5a, 0x30, 0x81, 0x8b, 0x31,
0x21, 0x30, 0x1f, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
0x0d, 0x01, 0x09, 0x01, 0x16, 0x12, 0x64, 0x63, 0x6f, 0x6d,
0x40, 0x6d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74,
0x2e, 0x63, 0x6f, 0x6d, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03,
0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0b, 0x30,
0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x02, 0x57, 0x41,
0x31, 0x11, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13,
0x08, 0x52, 0x65, 0x64, 0x6d, 0x6f, 0x6e, 0x64, 0x6e, 0x31,
0x0c, 0x30, 0x0a, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x03,
0x43, 0x4f, 0x4d, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55,
0x04, 0x0b, 0x13, 0x0b, 0x44, 0x69, 0x73, 0x74, 0x72, 0x69,
0x62, 0x75, 0x74, 0x65, 0x64, 0x31, 0x15, 0x30, 0x13, 0x06,
0x03, 0x55, 0x04, 0x03, 0x13, 0x0c, 0x44, 0x43, 0x4f, 0x4d,
0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x32, 0x31, 0x30, 0x5c,
0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,
0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x4b, 0x00, 0x30, 0x48,
0x02, 0x41, 0x00, 0x96, 0x98, 0x20, 0xe0, 0x18, 0x54, 0x04,
0x49, 0x72, 0x1d, 0xb7, 0x1f, 0x6b, 0x1c, 0x1a, 0x3f, 0x2a,
0x88, 0x8c, 0xbe, 0xdd, 0x06, 0x53, 0x6a, 0x99, 0xab, 0x16,
0x44, 0x96, 0x90, 0x65, 0xc1, 0x93, 0x04, 0xfe, 0x82, 0x0a,
0x5d, 0x10, 0x2d, 0xef, 0x50, 0xa4, 0xf9, 0xe9, 0xea, 0x5d,
0x1e, 0x15, 0xb0, 0xb2, 0x0c, 0x57, 0x9e, 0xf8, 0x53, 0xcd,
0xed, 0x14, 0x72, 0x79, 0x4d, 0x20, 0xcb, 0x02, 0x03, 0x01,
0x00, 0x01, 0xa3, 0x82, 0x01, 0xe5, 0x30, 0x82, 0x01, 0xe1,
0x30, 0x0b, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x04, 0x04, 0x03,
0x02, 0x00, 0xb8, 0x30, 0x13, 0x06, 0x03, 0x55, 0x1d, 0x25,
0x04, 0x0c, 0x30, 0x0a, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05,
0x05, 0x07, 0x03, 0x02, 0x30, 0x81, 0xb1, 0x06, 0x03, 0x55,
0x1d, 0x23, 0x04, 0x81, 0xa9, 0x30, 0x81, 0xa6, 0x80, 0x14,
0x2a, 0x58, 0x20, 0x26, 0x5b, 0x9f, 0xcf, 0xb1, 0xe3, 0x28,
0xf4, 0x2a, 0xea, 0x4d, 0xf8, 0xca, 0x19, 0xcb, 0xf3, 0xc4,
0xa1, 0x7c, 0xa4, 0x7a, 0x30, 0x78, 0x31, 0x0b, 0x30, 0x09,
0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x02,
0x57, 0x41, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04,
0x07, 0x13, 0x07, 0x52, 0x65, 0x64, 0x6d, 0x6f, 0x6e, 0x64,
0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,
0x09, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74,
0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13,
0x0a, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x4e,
0x54, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x03,
0x13, 0x18, 0x4d, 0x53, 0x20, 0x43, 0x65, 0x72, 0x74, 0x53,
0x72, 0x76, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x47, 0x72,
0x6f, 0x75, 0x70, 0x20, 0x43, 0x41, 0x82, 0x10, 0x11, 0x13,
0x61, 0x00, 0xaa, 0x00, 0x2b, 0x86, 0x11, 0xd2, 0x5e, 0xf8,
0xdd, 0xa0, 0x99, 0xb4, 0x30, 0x81, 0x99, 0x06, 0x03, 0x55,
0x1d, 0x1f, 0x04, 0x81, 0x91, 0x30, 0x81, 0x8e, 0x30, 0x44,
0xa0, 0x42, 0xa0, 0x40, 0x86, 0x3e, 0x68, 0x74, 0x74, 0x70,
0x3a, 0x2f, 0x2f, 0x43, 0x45, 0x52, 0x54, 0x53, 0x52, 0x56,
0x2f, 0x43, 0x65, 0x72, 0x74, 0x53, 0x72, 0x76, 0x2f, 0x43,
0x65, 0x72, 0x74, 0x45, 0x6e, 0x72, 0x6f, 0x6c, 0x6c, 0x2f,
0x4d, 0x53, 0x20, 0x43, 0x65, 0x72, 0x74, 0x53, 0x72, 0x76,
0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x47, 0x72, 0x6f, 0x75,
0x70, 0x20, 0x43, 0x41, 0x2e, 0x63, 0x72, 0x6c, 0x30, 0x46,
0xa0, 0x44, 0xa0, 0x42, 0x86, 0x40, 0x66, 0x69, 0x6c, 0x65,
0x3a, 0x2f, 0x2f, 0x5c, 0x5c, 0x43, 0x45, 0x52, 0x54, 0x53,
0x52, 0x56, 0x5c, 0x43, 0x65, 0x72, 0x74, 0x53, 0x72, 0x76,
0x5c, 0x43, 0x65, 0x72, 0x74, 0x45, 0x6e, 0x72, 0x6f, 0x6c,
0x6c, 0x5c, 0x4d, 0x53, 0x20, 0x43, 0x65, 0x72, 0x74, 0x53,
0x72, 0x76, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x47, 0x72,
0x6f, 0x75, 0x70, 0x20, 0x43, 0x41, 0x2e, 0x63, 0x72, 0x6c,
0x30, 0x09, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x04, 0x02, 0x30,
0x00, 0x30, 0x62, 0x06, 0x08, 0x2b, 0x06, 0x01, 0x05, 0x05,
0x07, 0x01, 0x01, 0x04, 0x56, 0x30, 0x54, 0x30, 0x52, 0x06,
0x08, 0x2b, 0x06, 0x01, 0x05, 0x05, 0x07, 0x30, 0x02, 0x86,
0x46, 0x68, 0x74, 0x74, 0x70, 0x3a, 0x2f, 0x2f, 0x43, 0x45,
0x52, 0x54, 0x53, 0x52, 0x56, 0x2f, 0x43, 0x65, 0x72, 0x74,
0x53, 0x72, 0x76, 0x2f, 0x43, 0x65, 0x72, 0x74, 0x45, 0x6e,
0x72, 0x6f, 0x6c, 0x6c, 0x2f, 0x43, 0x45, 0x52, 0x54, 0x53,
0x52, 0x56, 0x5f, 0x4d, 0x53, 0x20, 0x43, 0x65, 0x72, 0x74,
0x53, 0x72, 0x76, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x47,
0x72, 0x6f, 0x75, 0x70, 0x20, 0x43, 0x41, 0x2e, 0x63, 0x72,
0x74, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,
0x0d, 0x01, 0x01, 0x04, 0x05, 0x00, 0x03, 0x41, 0x00, 0x35,
0x16, 0x55, 0x9b, 0xd8, 0x74, 0x6d, 0x12, 0xc0, 0xf9, 0x3e,
0xec, 0xab, 0xa1, 0xcc, 0x84, 0xb5, 0x08, 0x02, 0x69, 0xd0,
0x3f, 0xf5, 0x8d, 0x6e, 0x5c, 0xb4, 0x22, 0xfd, 0x3f, 0xec,
0x72, 0xb7, 0xae, 0xc8, 0xea, 0xbf, 0x1f, 0x9b, 0x61, 0x48,
0xff, 0x4e, 0x71, 0x76, 0x46, 0x8c, 0x9e, 0x47, 0x13, 0x88,
0x40, 0x6a, 0xfc, 0x4d, 0x37, 0xac, 0x02, 0x9f, 0x57, 0x70,
0x3d, 0xae, 0xa2,
};

const BYTE Cert20_Private[] =
{
0x07, 0x02, 0x00, 0x00, 0x00, 0xa4, 0x00, 0x00, 0x52, 0x53,
0x41, 0x32, 0x00, 0x02, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00,
0xcb, 0x20, 0x4d, 0x79, 0x72, 0x14, 0xed, 0xcd, 0x53, 0xf8,
0x9e, 0x57, 0x0c, 0xb2, 0xb0, 0x15, 0x1e, 0x5d, 0xea, 0xe9,
0xf9, 0xa4, 0x50, 0xef, 0x2d, 0x10, 0x5d, 0x0a, 0x82, 0xfe,
0x04, 0x93, 0xc1, 0x65, 0x90, 0x96, 0x44, 0x16, 0xab, 0x99,
0x6a, 0x53, 0x06, 0xdd, 0xbe, 0x8c, 0x88, 0x2a, 0x3f, 0x1a,
0x1c, 0x6b, 0x1f, 0xb7, 0x1d, 0x72, 0x49, 0x04, 0x54, 0x18,
0xe0, 0x20, 0x98, 0x96, 0x1f, 0xa2, 0x9c, 0x9c, 0xad, 0x28,
0x9b, 0x2a, 0xdd, 0xd8, 0xe1, 0x8f, 0xd7, 0x65, 0x1d, 0xd9,
0x62, 0x2f, 0xa5, 0xd4, 0x0d, 0xcb, 0x6f, 0x13, 0x5c, 0x32,
0x1b, 0x49, 0x8e, 0x13, 0xe7, 0xc7, 0xd5, 0x23, 0x30, 0x45,
0xdb, 0x86, 0x9a, 0x65, 0x61, 0xa0, 0x12, 0x0a, 0x4d, 0x2f,
0x22, 0x53, 0xee, 0xf2, 0x41, 0x11, 0xa1, 0x0f, 0xcc, 0x4d,
0x0b, 0x3f, 0x1f, 0x94, 0xed, 0xc1, 0xda, 0xc0, 0xb5, 0x9c,
0x38, 0x0f, 0xd6, 0xf9, 0xf3, 0x25, 0x87, 0x40, 0x87, 0x37,
0xf4, 0x28, 0x34, 0x62, 0x06, 0x6b, 0xfb, 0xa4, 0x99, 0x53,
0x95, 0x81, 0x1d, 0x58, 0x6c, 0x84, 0x51, 0x6c, 0xb5, 0x76,
0xb9, 0x16, 0xf1, 0x7f, 0x3a, 0xab, 0x34, 0x5a, 0xdc, 0x6a,
0xa4, 0x91, 0x2f, 0x03, 0x4e, 0xa2, 0xc2, 0x8e, 0x05, 0x3e,
0xa6, 0x36, 0xb4, 0xf7, 0xed, 0xf4, 0x58, 0xe5, 0xe6, 0x52,
0x62, 0xa4, 0x49, 0xdd, 0x8f, 0x98, 0x84, 0xdf, 0xbf, 0x8c,
0x2d, 0xc0, 0x4f, 0x87, 0xb5, 0xdb, 0x4b, 0xf4, 0xe2, 0x9a,
0x5a, 0xbf, 0xbc, 0xb5, 0x06, 0x63, 0x8a, 0x77, 0xae, 0x01,
0x9d, 0x53, 0xb6, 0x9f, 0x59, 0x9e, 0x12, 0x6f, 0x8c, 0x24,
0x97, 0x8f, 0x61, 0x9e, 0x43, 0x56, 0x4b, 0xd9, 0xfa, 0x20,
0x74, 0xb6, 0xdc, 0x9d, 0x30, 0x01, 0xc4, 0xc5, 0xad, 0x9d,
0x5f, 0x06, 0x64, 0xfb, 0x51, 0x4d, 0xcf, 0xe7, 0x43, 0x1d,
0xd7, 0x6f, 0x99, 0x52, 0x8d, 0x0c, 0xd2, 0xf5, 0x17, 0x33,
0x4b, 0x10, 0xa6, 0xf7, 0xda, 0x24, 0x3b, 0x1b, 0x42, 0xc0,
0x6c, 0xb4, 0x90, 0x8f, 0x52, 0x5f, 0x99, 0x31, 0x41, 0xda,
};

const BYTE CertSrv2[] =
{
0x04, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x10, 0x00,
0x00, 0x00, 0xa6, 0xdc, 0x2b, 0x13, 0x28, 0x02, 0x40, 0x96,
0x0d, 0xe4, 0x64, 0xfd, 0xd1, 0x7a, 0xa1, 0xf4, 0x03, 0x00,
0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00, 0x00, 0x00,
0x06, 0xa9, 0xef, 0xb5, 0x0c, 0xe1, 0xb4, 0x07, 0x64, 0xef,
0x9d, 0x77, 0xa2, 0x73, 0x3c, 0x4e, 0xda, 0x55, 0xa5, 0xf9,
0x14, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x14, 0x00,
0x00, 0x00, 0x2a, 0x58, 0x20, 0x26, 0x5b, 0x9f, 0xcf, 0xb1,
0xe3, 0x28, 0xf4, 0x2a, 0xea, 0x4d, 0xf8, 0xca, 0x19, 0xcb,
0xf3, 0xc4, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
0x30, 0x02, 0x00, 0x00, 0x30, 0x82, 0x02, 0x2c, 0x30, 0x82,
0x01, 0xd6, 0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x10, 0x11,
0x13, 0x61, 0x00, 0xaa, 0x00, 0x2b, 0x86, 0x11, 0xd2, 0x5e,
0xf8, 0xdd, 0xa0, 0x99, 0xb4, 0x30, 0x0d, 0x06, 0x09, 0x2a,
0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01, 0x04, 0x05, 0x00,
0x30, 0x78, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04,
0x06, 0x13, 0x02, 0x55, 0x53, 0x31, 0x0b, 0x30, 0x09, 0x06,
0x03, 0x55, 0x04, 0x08, 0x13, 0x02, 0x57, 0x41, 0x31, 0x10,
0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x07, 0x13, 0x07, 0x52,
0x65, 0x64, 0x6d, 0x6f, 0x6e, 0x64, 0x31, 0x12, 0x30, 0x10,
0x06, 0x03, 0x55, 0x04, 0x0a, 0x13, 0x09, 0x4d, 0x69, 0x63,
0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74, 0x31, 0x13, 0x30, 0x11,
0x06, 0x03, 0x55, 0x04, 0x0b, 0x13, 0x0a, 0x57, 0x69, 0x6e,
0x64, 0x6f, 0x77, 0x73, 0x20, 0x4e, 0x54, 0x31, 0x21, 0x30,
0x1f, 0x06, 0x03, 0x55, 0x04, 0x03, 0x13, 0x18, 0x4d, 0x53,
0x20, 0x43, 0x65, 0x72, 0x74, 0x53, 0x72, 0x76, 0x20, 0x54,
0x65, 0x73, 0x74, 0x20, 0x47, 0x72, 0x6f, 0x75, 0x70, 0x20,
0x43, 0x41, 0x30, 0x1e, 0x17, 0x0d, 0x39, 0x38, 0x31, 0x30,
0x30, 0x38, 0x32, 0x31, 0x35, 0x31, 0x35, 0x31, 0x5a, 0x17,
0x0d, 0x30, 0x33, 0x31, 0x30, 0x30, 0x38, 0x32, 0x31, 0x35,
0x31, 0x35, 0x31, 0x5a, 0x30, 0x78, 0x31, 0x0b, 0x30, 0x09,
0x06, 0x03, 0x55, 0x04, 0x06, 0x13, 0x02, 0x55, 0x53, 0x31,
0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x02,
0x57, 0x41, 0x31, 0x10, 0x30, 0x0e, 0x06, 0x03, 0x55, 0x04,
0x07, 0x13, 0x07, 0x52, 0x65, 0x64, 0x6d, 0x6f, 0x6e, 0x64,
0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,
0x09, 0x4d, 0x69, 0x63, 0x72, 0x6f, 0x73, 0x6f, 0x66, 0x74,
0x31, 0x13, 0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x0b, 0x13,
0x0a, 0x57, 0x69, 0x6e, 0x64, 0x6f, 0x77, 0x73, 0x20, 0x4e,
0x54, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04, 0x03,
0x13, 0x18, 0x4d, 0x53, 0x20, 0x43, 0x65, 0x72, 0x74, 0x53,
0x72, 0x76, 0x20, 0x54, 0x65, 0x73, 0x74, 0x20, 0x47, 0x72,
0x6f, 0x75, 0x70, 0x20, 0x43, 0x41, 0x30, 0x5c, 0x30, 0x0d,
0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
0x01, 0x05, 0x00, 0x03, 0x4b, 0x00, 0x30, 0x48, 0x02, 0x41,
0x00, 0xb9, 0xb5, 0xd1, 0x63, 0xaf, 0x3f, 0xd4, 0x4c, 0x69,
0x3a, 0xaa, 0xff, 0x1d, 0x8c, 0x0f, 0xbd, 0xa5, 0x44, 0x9a,
0xd1, 0x23, 0x36, 0x9d, 0x19, 0xd8, 0x12, 0xa4, 0x37, 0xe8,
0x9d, 0x33, 0x94, 0x39, 0x1e, 0x5d, 0xad, 0xe7, 0x21, 0x5e,
0x09, 0x8e, 0x1b, 0x9a, 0xde, 0x8e, 0x74, 0xfe, 0x66, 0x47,
0xe2, 0x8c, 0xa7, 0xc8, 0x83, 0xb6, 0x05, 0x92, 0xf9, 0x78,
0x88, 0x86, 0x08, 0x56, 0x11, 0x02, 0x03, 0x01, 0x00, 0x01,
0xa3, 0x3c, 0x30, 0x3a, 0x30, 0x0b, 0x06, 0x03, 0x55, 0x1d,
0x0f, 0x04, 0x04, 0x03, 0x02, 0x00, 0xc4, 0x30, 0x0c, 0x06,
0x03, 0x55, 0x1d, 0x13, 0x04, 0x05, 0x30, 0x03, 0x01, 0x01,
0xff, 0x30, 0x1d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16,
0x04, 0x14, 0x2a, 0x58, 0x20, 0x26, 0x5b, 0x9f, 0xcf, 0xb1,
0xe3, 0x28, 0xf4, 0x2a, 0xea, 0x4d, 0xf8, 0xca, 0x19, 0xcb,
0xf3, 0xc4, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86,
0xf7, 0x0d, 0x01, 0x01, 0x04, 0x05, 0x00, 0x03, 0x41, 0x00,
0x52, 0xa4, 0xd0, 0x89, 0x5e, 0x93, 0x1b, 0x3c, 0xa2, 0x19,
0x1d, 0xbc, 0x38, 0xae, 0xac, 0xc8, 0x5c, 0xc4, 0x56, 0x2d,
0x42, 0x60, 0x76, 0xf6, 0xfa, 0xfa, 0x15, 0x5a, 0x6e, 0xfd,
0x23, 0x67, 0xa0, 0xe1, 0xd9, 0xf8, 0x30, 0xd3, 0x92, 0x95,
0x92, 0x96, 0xbc, 0x7c, 0x99, 0x42, 0xc4, 0xf6, 0x1e, 0xef,
0xfa, 0x7b, 0xa2, 0x02, 0x57, 0x59, 0x30, 0x88, 0x98, 0xe9,
0xe2, 0x2a, 0x51, 0x9c
};


#if  (_WIN32_WINNT >= 0x0500 )
SCloakBlanket CloakBlanket[9] =
{
  { TRUE,  FALSE, EOAC_NONE,             { L"redmond\\oleadmin", L"redmond\\oleadmin", L"redmond\\oleadmin" } },
  { FALSE, TRUE,  EOAC_NONE,             { NULL,  NULL,  NULL } },
  { FALSE, FALSE, EOAC_NONE,             { NULL,  NULL,  NULL } },
  { TRUE,  FALSE, EOAC_STATIC_CLOAKING,  { L"redmond\\oleadmin", L"redmond\\oleadmin", L"redmond\\oleadmin" } },
  { FALSE, TRUE,  EOAC_STATIC_CLOAKING,  { L"redmond\\oleadmin", L"redmond\\oleadmin", L"redmond\\oleadmin" } },
  { FALSE, FALSE, EOAC_STATIC_CLOAKING,  { NULL,  NULL,  NULL } },
  { TRUE,  FALSE, EOAC_DYNAMIC_CLOAKING, { L"redmond\\oleadmin", L"redmond\\oleadmin", L"redmond\\oleadmin" } },
  { FALSE, TRUE,  EOAC_DYNAMIC_CLOAKING, { L"redmond\\oleuser",  L"redmond\\oleuser1", L"redmond\\oleuser2" } },
  { FALSE, FALSE, EOAC_DYNAMIC_CLOAKING, { L"redmond\\oleuser",  L"redmond\\oleuser1", L"redmond\\oleuser2" } },
};
#endif


/* Globals. */
#if  (_WIN32_WINNT >= 0x0500 )
ISynchronize          *Call                    = NULL;
#endif
WCHAR                  CallUser[MAX_NAME]      = L"";
BOOL                   Change                  = FALSE;
CTestCF               *ClassFactory;
#if  (_WIN32_WINNT >= 0x0500 )
IAsyncManager           *Complete;
HCRYPTPROV             CryptProvider           = 0;
#endif
WCHAR                 *Creator                 = NULL;
char                   Debugger[MAX_PATH+MAX_PATH] = "";
WCHAR                 *DomainUser              = NULL;
HANDLE                 Done;
#if  (_WIN32_WINNT >= 0x0500 )
HCRYPTKEY              ExchangeKey             = 0;
#endif
CoCopyProxyFn          GCoCopyProxy            = FixupCoCopyProxy;
CoGetCallContextFn     GCoGetCallContext       = FixupCoGetCallContext;
CoImpersonateClientFn  GCoImpersonateClient    = FixupCoImpersonateClient;
CoInitializeSecurityFn GCoInitializeSecurity   = FixupCoInitializeSecurity;
CoQueryAuthenticationServicesFn GCoQueryAuthenticationServices = FixupCoQueryAuthenticationServices;
CoQueryClientBlanketFn GCoQueryClientBlanket   = FixupCoQueryClientBlanket;
CoQueryProxyBlanketFn  GCoQueryProxyBlanket    = FixupCoQueryProxyBlanket;
CoRevertToSelfFn       GCoRevertToSelf         = FixupCoRevertToSelf;
CoSetProxyBlanketFn    GCoSetProxyBlanket      = FixupCoSetProxyBlanket;
CoSwitchCallContextFn  GCoSwitchCallContext    = FixupCoSwitchCallContext;
DWORD                  GlobalAuthnLevel        = RPC_C_AUTHN_LEVEL_NONE;
DWORD                  GlobalAuthnSvc          = RPC_C_AUTHN_WINNT;
SAptId                 GlobalApt;
WCHAR                 *GlobalBinding;
BOOL                   GlobalBool;
long                   GlobalCalls              = 0;
long                   GlobalClients            = 0;
LONG                   GlobalFirst              = TRUE;
DWORD                 *GlobalHex                = NULL;
CHook                 *GlobalHook1              = NULL;
CHook                 *GlobalHook2              = NULL;
BOOL                   GlobalInterruptTest;
SECURITY_DESCRIPTOR   *GlobalSecurityDescriptor = NULL;
security_model         GlobalSecurityModel      = auto_sm;
ITest                 *GlobalTest     = NULL;
ITest                 *GlobalTest2    = NULL;
ULONG                  GlobalThreadId = 0;
long                   GlobalTotal    = 0;
BOOL                   GlobalWaiting  = FALSE;
DWORD                  MainThread;
HANDLE                 ManualReset    = NULL;
BOOL                   Multicall_Test;
WCHAR                  Name[MAX_NAME]  = L"";
WCHAR                  Name2[MAX_NAME] = L"";
DWORD                  NestedCallCount = 0;
BOOL                   NT5             = FALSE;
DWORD                  NumClass        = 1;
int                    NumElements     = 7;
DWORD                  NumIterations   = 20;
DWORD                  NumObjects      = 2;
DWORD                  NumProcesses    = 2;
DWORD                  NumRecursion    = 2;
DWORD                  NumThreads      = 2;
WCHAR                 *OleUserPassword       = L"July1999";
WCHAR                  PackageList[MAX_NAME] = L"kerberos,NTLM";
BOOL                   Popup                 = FALSE;
WCHAR                 *Preimpersonate        = NULL;
SAptData               ProcessAptData;
unsigned char          ProcessName[MAX_NAME];
SID                   *ProcessSid            = NULL;
HANDLE                 RawEvent              = NULL;
HRESULT                RawResult;
DWORD                  Registration;
IServerSecurity       *Security              = NULL;
UUID                   ServerClsid[2];
WCHAR                  TestProtseq[MAX_NAME] = L"ncadg_ip_udp";
WCHAR                  ThisMachine[MAX_NAME] = L"";
SThreadList            ThreadList            = { &ThreadList, NULL };
DWORD                  ThreadMode            = COINIT_APARTMENTTHREADED;
DWORD                  TlsIndex;
WCHAR                  UserName[MAX_NAME]    = L"";
BOOL                   Verbose               = FALSE;
what_test_en           WhatTest;
what_dest              WhatDest              = same_machine_wd;
BOOL                   Win95;
BOOL                   WriteCert             = FALSE;
BOOL                   WriteClass            = FALSE;


/***************************************************************************/
STDMETHODIMP_(ULONG) CAccessControl::AddRef( )
{
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CAccessControl::CAccessControl()
{
  ref_count = 1;
  allow     = TRUE;
}

/***************************************************************************/
CAccessControl::~CAccessControl()
{
}

/***************************************************************************/
HRESULT CAccessControl::deny_me()
{
  allow = FALSE;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CAccessControl::GetAllAccessRights( LPWSTR lpProperty,
                                                 PACTRL_ACCESSW *ppAccessList,
                                                 PTRUSTEEW *ppOwner,
                                                 PTRUSTEEW *ppGroup )
{
  return E_NOTIMPL;
}

/***************************************************************************/
STDMETHODIMP CAccessControl::GrantAccessRights( PACTRL_ACCESSW pAccessList )
{
  return E_NOTIMPL;
}

/***************************************************************************/
STDMETHODIMP CAccessControl::IsAccessAllowed( TRUSTEE_W *Trustee,
                                              LPWSTR lpProperty,
                                              ACCESS_RIGHTS AccessRights,
                                              BOOL *pfAccessAllowed )
{
  WCHAR  bufferw[80];
  char   buffera[80];
  DWORD  len = 80;
  BOOL   me;
  BOOL   system;
  WCHAR *user;

  // Initialize the access flag.
  if (pfAccessAllowed != NULL)
    *pfAccessAllowed = FALSE;

  // Validate the fields of the trustee.
  if (Trustee->pMultipleTrustee != NULL                        ||
      Trustee->MultipleTrusteeOperation != NO_MULTIPLE_TRUSTEE ||
      Trustee->TrusteeForm != TRUSTEE_IS_NAME                  ||
      Trustee->TrusteeType != TRUSTEE_IS_USER                  ||
      Trustee->ptstrName == NULL                               ||
      lpProperty != NULL                                       ||
      AccessRights != COM_RIGHTS_EXECUTE)
    return E_INVALIDARG;

  // Lookup the process user.
  if (!GetUserNameA( buffera, &len ))
    return MAKE_WIN32( GetLastError() );

  // Convert the name to unicode.
  if (!MultiByteToWideChar( CP_ACP, 0, buffera, strlen(buffera)+1, bufferw,
                            80 ))
    return MAKE_WIN32( GetLastError() );

  // Skip the domain name because I don't feel like looking it up.
  user = wcsstr( Trustee->ptstrName, L"\\" );
  user += 1;

  // Always allow calls from local system.
  system = wcscmp( L"SYSTEM", user ) == 0;
  // system = wcscmp( L"NT AUTHORITY", user ) == 0;

  // Compare the trustee to the process user.
  me = _wcsicmp( bufferw, user ) == 0;
  if (system || (me && allow) || (!me && !allow))
  {
    if (pfAccessAllowed != NULL)
      *pfAccessAllowed = TRUE;
    return S_OK;
  }
  else
    return E_ACCESSDENIED;
}

/***************************************************************************/
STDMETHODIMP CAccessControl::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_IAccessControl))
  {
    *ppvObj = (IUnknown *) (IAccessControl *) this;
    AddRef();
    return S_OK;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CAccessControl::Release( )
{
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    decrement_object_count();
    delete this;
    return 0;
  }
  else
    return ref_count;
}

/***************************************************************************/
STDMETHODIMP CAccessControl::RevokeAccessRights( LPWSTR lpProperty,
                                                 ULONG cTrustees,
                                                 TRUSTEEW *pTrustees )
{
  return E_NOTIMPL;
}

/***************************************************************************/
STDMETHODIMP CAccessControl::SetOwner( PTRUSTEEW pOwner, PTRUSTEEW pGroup )
{
  return E_NOTIMPL;
}

/***************************************************************************/
STDMETHODIMP CAccessControl::SetAccessRights( PACTRL_ACCESSW pAccessList )
{
  return E_NOTIMPL;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CAdvise::AddRef( THIS )
{
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CAdvise::CAdvise()
{
  ref_count      = 1;
  increment_object_count();
}

/***************************************************************************/
CAdvise::~CAdvise()
{
}

/***************************************************************************/
STDMETHODIMP_(void) CAdvise::OnClose( void )
{
}

/***************************************************************************/
STDMETHODIMP_(void) CAdvise::OnDataChange( FORMATETC *format, STGMEDIUM *stg )
{
}

/***************************************************************************/
STDMETHODIMP_(void) CAdvise::OnRename( IMoniker *moniker )
{
}

/***************************************************************************/
STDMETHODIMP_(void) CAdvise::OnSave( void )
{
}

/***************************************************************************/
STDMETHODIMP_(void) CAdvise::OnViewChange( DWORD aspect, LONG index )
{
}

/***************************************************************************/
STDMETHODIMP CAdvise::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_IAdviseSink))
  {
    *ppvObj = (IUnknown *) (IAdviseSink *) this;
    AddRef();
    return S_OK;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CAdvise::Release( THIS )
{
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    decrement_object_count();
    delete this;
    return 0;
  }
  else
    return ref_count;
}

#if  (_WIN32_WINNT >= 0x0500 )

/***************************************************************************/
STDMETHODIMP_(ULONG) CAsyncInner::AddRef()
{
    return InterlockedIncrement( (long *) &ref_count );
}

/***************************************************************************/
CAsyncInner::CAsyncInner( CAsync *pParent )
{
    ref_count = 1;
    parent    = pParent;
}

/***************************************************************************/
STDMETHODIMP CAsyncInner::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    IUnknown *pUnk;

    if (IsEqualIID(riid, IID_IUnknown))
        pUnk = (IUnknown *) this;
    else if (IsEqualIID(riid, IID_AsyncIAsync))
        pUnk = (AsyncIAsync *) parent;
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    pUnk->AddRef();
    *ppvObj = pUnk;
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CAsyncInner::Release()
{
    ULONG lRef = InterlockedDecrement( (long*) &ref_count );

    if (lRef == 0)
    {
        delete parent;
    }

    return lRef;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CAsync::AddRef()
{
    return control->AddRef();
}

/***************************************************************************/
HRESULT CAsync::Begin_preimpersonate( BOOL fOn )
{
  ISynchronize *sync = NULL;
  HRESULT       result;
  BOOL          success;

  // Tell the main thread to start or stop impersonating.
  if (fOn)
    what_next( impersonate_wn );
  else
    what_next( revert_wn );
  wake_up_and_smell_the_roses();

  // Get ISynchronize.
  result = QueryInterface( IID_ISynchronize, (void **) &sync );
  ASSERT( result, "Could not get ISynchronize" );

  // Complete the call.
  result = sync->Signal();
  ASSERT( result, "Could not signal" );

cleanup:
  if (sync != NULL)
    sync->Release();
  saved_result = result;
  return result;
}

/***************************************************************************/
HRESULT CAsync::Begin_secure( SAptId id, DWORD test, STRING princ_name )
{
  ISynchronize *sync = NULL;
  HRESULT       result;
  WCHAR        *preuser;

  // Get ISynchronize.
  result = QueryInterface( IID_ISynchronize, (void **) &sync );
  ASSERT( result, "Could not get ISynchronize" );

  // Verify the current thread token.
  if (Preimpersonate)
    if (ThreadMode == COINIT_APARTMENTTHREADED)
      preuser = Preimpersonate;
    else
      preuser = DomainUser;
  else
    preuser = DomainUser;
  result = check_token( preuser, NULL, RPC_C_IMP_LEVEL_IMPERSONATE );
  ASSERT( result, "Wrong token at start of Begin_secure" );

  // Impersonate.
  result = MCoImpersonateClient();
  ASSERT( result, "Could not impersonate in Begin_secure" );

  // Verify the current thread token.
  result = check_token( princ_name, DEFAULT_CONTEXT, RPC_C_IMP_LEVEL_IMPERSONATE );
  ASSERT( result, "Wrong impersonation token in Begin_secure" );

  // Revert.
  result = MCoRevertToSelf();
  ASSERT( result, "Could not revert to self in Begin_secure" );

  // Verify the current thread token.
  result = check_token( preuser, NULL, RPC_C_IMP_LEVEL_IMPERSONATE );
  ASSERT( result, "Wrong token at start of Begin_secure" );

  // For the embedded test, complete the call now.
  wcsncpy( CallUser, princ_name, MAX_NAME );
  if (test == embedded_as)
  {
    // Complete the call.
    result = sync->Signal();
    ASSERT( result, "Could not signal" );

    // Verify the current thread token.
    result = check_token( preuser, NULL, RPC_C_IMP_LEVEL_IMPERSONATE );
    ASSERT( result, "Wrong token at end of Begin_secure" );

    // Impersonate.
    result = MCoImpersonateClient();
    ASSERT( result, "Could not impersonate in Begin_secure" );

    // Verify the current thread token.
    result = check_token( princ_name, DEFAULT_CONTEXT, RPC_C_IMP_LEVEL_IMPERSONATE );
    ASSERT( result, "Wrong impersonation token in Begin_secure" );

    // Revert.
    result = MCoRevertToSelf();
    ASSERT( result, "Could not revert to self in Begin_secure" );

    // Verify the current thread token.
    result = check_token( preuser, NULL, RPC_C_IMP_LEVEL_IMPERSONATE );
    ASSERT( result, "Wrong token at end of Begin_secure" );
  }

  // Otherwise instruct the main thread how to complete the call.
  else
  {
    // Save IServerSecurity.
    result = CoGetCallContext( IID_IServerSecurity, (void **) &Security );
    ASSERT( result, "Could not get call context" );

    // Save the call object.
    Call = sync;
    Call->AddRef();

    // Wake up the main thread to complete the call.
    if (test == basic_as)
      what_next( basic_async_wn );
    else
      what_next( race_async_wn );
    wake_up_and_smell_the_roses();
  }

cleanup:
  if (sync != NULL)
    sync->Release();
  saved_result = result;
  return result;
}

/***************************************************************************/
CAsync::CAsync( IUnknown *pControl ) :
    inner_unk( this )
{
  saved_result = S_OK;
  if (pControl != NULL)
    control = pControl;
  else
    control = &inner_unk;
}

/***************************************************************************/
CAsync::~CAsync( )
{
}

/***************************************************************************/
HRESULT CAsync::Finish_preimpersonate( void )
{
  return saved_result;
}

/***************************************************************************/
HRESULT CAsync::Finish_secure( void )
{
  WCHAR        *preuser;
  HRESULT       result;

  // Verify the current thread token.
  if (Preimpersonate)
    preuser = Preimpersonate;
  else
    preuser = DomainUser;
  result = check_token( preuser, NULL, RPC_C_IMP_LEVEL_IMPERSONATE );
  ASSERT( result, "Wrong token at start of Finish_secure" );

  // Impersonate.
  result = MCoImpersonateClient();
  ASSERT( result, "Could not impersonate in Finish_secure" );

  // Verify the current thread token.
  result = check_token( CallUser, DEFAULT_CONTEXT, RPC_C_IMP_LEVEL_IMPERSONATE );
  ASSERT( result, "Wrong impersonation token in Finish_secure" );

  // Revert.
  result = MCoRevertToSelf();
  ASSERT( result, "Could not revert to self in Finish_secure" );

  // Verify the current thread token.
  result = check_token( preuser, NULL, RPC_C_IMP_LEVEL_IMPERSONATE );
  ASSERT( result, "Wrong token at end of Finish_secure" );

cleanup:
  if (FAILED(result))
    return result;
  else return saved_result;
}

/***************************************************************************/
STDMETHODIMP CAsync::QueryInterface( REFIID riid, LPVOID FAR* ppvObj)
{
    return control->QueryInterface( riid, ppvObj );
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CAsync::Release()
{
    return control->Release();
}
#endif

/***************************************************************************/
STDMETHODIMP_(ULONG) CHook::AddRef( THIS )
{
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
HRESULT CHook::check( DWORD cget, DWORD cnot, DWORD sget, DWORD snot )
{
  if (result != S_OK)
    return result;
  if (cget != client_get || cnot != client_notify ||
      sget != server_get || snot != server_notify)
    return E_INVALIDARG;
  return S_OK;
}

/***************************************************************************/
void CHook::check_buf( DWORD size, unsigned char *buf )
{
  DWORD i;

  if (sequence == 1)
  {
    if (size == 1)
    {
      if (*buf != 1)
        goto error;
    }
    else if (size == 1000)
    {
      for (i = 0; i < size; i++)
        if (buf[i] != 255)
          goto error;
    }
    else if (size != 0)
      goto error;
  }
  else if (sequence == 2)
  {
    for (i = 0; i < size; i++)
      if (buf[i] != (unsigned char) i)
        goto error;
  }
  else
  {
    if (size != 42)
      goto error;
    i = 0;
    while (i < 42)
      if (buf[i++] != '4' || buf[i++] != '2')
        goto error;
  }

  return;
error:
  printf( "Hook got bad data.\n" );
  result = E_UNEXPECTED;
}

/***************************************************************************/
CHook::CHook( REFGUID ext, DWORD seq )
{
  extent        = ext;
  sequence      = seq;
  ref_count     = 1;
  client_get    = 0;
  client_fill   = 0;
  client_notify = 0;
  server_get    = 0;
  server_fill   = 0;
  server_notify = 0;
  result        = S_OK;
}

/***************************************************************************/
STDMETHODIMP_(void) CHook::ClientGetSize( REFGUID ext, REFIID riid,
                                          ULONG *size )
{
  //printf( "ClientGetSize: 0x%x\n", GetCurrentThreadId() );

  // Check the parameters.
  if (extent != ext)
  {
    printf( "Hook received the wrong extent.\n" );
    result = E_FAIL;
  }

  // Return the correct size for each sequence.
  client_get += 1;
  *size = get_size( client_get );
}

/***************************************************************************/
STDMETHODIMP_(void) CHook::ClientFillBuffer( REFGUID ext, REFIID riid,
                                             ULONG *max, void *buffer )
{
  DWORD size = get_size( client_get );

  //printf( "ClientFillBuffer: 0x%x\n", GetCurrentThreadId() );

  // Check the parameters.
  if (extent != ext)
  {
    printf( "Hook received the wrong extent.\n" );
    result = E_FAIL;
  }
  else if (*max < size)
  {
    printf( "Hook lost space.\n" );
    result = E_OUTOFMEMORY;
  }

  // Fill the buffer.
  *max = size;
  client_fill += 1;
  fill_buf( client_get, (unsigned char *) buffer );
}

/***************************************************************************/
STDMETHODIMP_(void) CHook::ClientNotify( REFGUID ext, REFIID riid,
                                         ULONG size, void *buffer,
                                         DWORD data_rep, HRESULT result )
{
  //printf( "ClientNotify: 0x%x\n", GetCurrentThreadId() );

  // Verify the parameters.
  if (extent != ext)
  {
    printf( "Hook received the wrong extent.\n" );
    result = E_FAIL;
  }

  // Verify the data.
  client_notify += 1;
  if (result == S_OK && buffer != NULL)
    check_buf( size, (unsigned char *) buffer );
}

/***************************************************************************/
void CHook::fill_buf( DWORD count, unsigned char *buffer )
{
  DWORD size = get_size( count );
  DWORD i;

  if (sequence == 1)
  {
    if (size == 1)
      *buffer = 1;
    else
      for (i = 0; i < size; i++)
        buffer[i] = 255;
  }
  else if (sequence == 2)
  {
    for (i = 0; i < size; i++)
      buffer[i] = (UCHAR) i;
  }
  else
  {
    i = 0;
    while (i < 42)
    {
      buffer[i++] = '4';
      buffer[i++] = '2';
    }
  }
}

/***************************************************************************/
DWORD CHook::get_size( DWORD count )
{
  DWORD size;

  if (sequence == 1)
  {
    size = count % 3;
    if (size == 2)
      size = 1000;
    return size;
  }
  else if (sequence == 2)
    return count;
  else
    return 42;
}

/***************************************************************************/
STDMETHODIMP CHook::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_IChannelHook))
  {
    *ppvObj = (IUnknown *) this;
    AddRef();
    return S_OK;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CHook::Release( THIS )
{
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;
}

/***************************************************************************/
STDMETHODIMP_(void) CHook::ServerNotify( REFGUID ext, REFIID riid,
                                         ULONG size, void *buffer,
                                         DWORD data_rep )
{
  //printf( "ServerNotify: 0x%x\n", GetCurrentThreadId() );

  // Verify the parameters.
  if (extent != ext)
  {
    printf( "Hook received the wrong extent.\n" );
    result = E_FAIL;
  }

  // Verify the data.
  server_notify += 1;
  if (result == S_OK && buffer != NULL)
    check_buf( size, (unsigned char *) buffer );
}

/***************************************************************************/
STDMETHODIMP_(void) CHook::ServerGetSize( REFGUID ext, REFIID riid, HRESULT hr,
                                          ULONG *size )
{
  //printf( "ServerGetSize: 0x%x\n", GetCurrentThreadId() );

  // Check the parameters.
  if (extent != ext)
  {
    printf( "Hook received the wrong extent.\n" );
    result = E_FAIL;
  }

  // Return the correct size for each sequence.
  server_get += 1;
  *size = get_size( server_get );
}

/***************************************************************************/
STDMETHODIMP_(void) CHook::ServerFillBuffer( REFGUID ext, REFIID riid,
                                             ULONG *max, void *buffer, HRESULT hr )
{
  //printf( "ServerFillBuffer: 0x%x\n", GetCurrentThreadId() );

  DWORD size = get_size( server_get );

  // Check the parameters.
  if (extent != ext)
  {
    printf( "Hook received the wrong extent.\n" );
    result = E_FAIL;
  }
  else if (*max < size)
  {
    printf( "Hook lost space.\n" );
    result = E_OUTOFMEMORY;
  }

  // Fill the buffer.
  *max = size;
  server_fill += 1;
  fill_buf( server_get, (unsigned char *) buffer );
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CPipe::AddRef( THIS )
{
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
STDMETHODIMP CPipe::Alloc( ULONG bsize, LONG **pbuf, ULONG *bcount )
{
  *pbuf = (LONG *) CoTaskMemAlloc( bsize );
  if (*pbuf == NULL)
  {
    *bcount = 0;
    return E_OUTOFMEMORY;
  }
  else
  {
    *bcount = bsize;
    return S_OK;
  }
}

/***************************************************************************/
HRESULT CPipe::check()
{
  if (curr != len)
    return E_FAIL;
  else
    return result;
}

/***************************************************************************/
CPipe::CPipe()
{
  ref_count = 1;
}

/***************************************************************************/
STDMETHODIMP CPipe::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_ILongPipe))
  {
    *ppvObj = (ILongPipe *) this;
    AddRef();
    return S_OK;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }
}

/***************************************************************************/
STDMETHODIMP CPipe::Pull( LONG *buf, ULONG esize, ULONG *ecount )
{
  ULONG i;

  // Stop when there is no more data.
  if (esize+curr > len)
    esize = len-curr;
  *ecount = esize;

  // Generate the data.
  for (i = 0; i < esize; i++)
    buf[i] = curr++;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CPipe::Push( LONG *buf, ULONG ecount )
{
  ULONG i;

  // Reset the count on the first receive.
  if (in)
  {
    curr = 0;
    in = FALSE;
  }

  // Return an error if there is too much data.
  if (ecount+curr > len)
  {
    result = E_ABORT;
    return result;
  }

  // Check the data.
  for (i = 0; i < ecount; i++)
    if (buf[i] != (LONG) curr++)
    {
      result = E_INVALIDARG;
      return result;
    }
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CPipe::Release( THIS )
{
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;
}

/***************************************************************************/
HRESULT CPipe::setup( DWORD new_len )
{
  len    = new_len;
  curr   = 0;
  result = S_OK;
  in     = TRUE;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CTest::AddRef( THIS )
{
  assert_unknown();
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
STDMETHODIMP CTest::align( unsigned char x[17] )
{
  ASSERT_THREAD();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::by_the_way( DWORD what )
{
  HRESULT            result           = S_OK;
  IServerSecurity   *pSec             = NULL;

  ASSERT_THREAD();
  state = what;

  // Try to release IServerSecurity too many times.
  if (what == release_too_much_btw)
  {
    // Get IServerSecurity.
    result = CoGetCallContext( IID_IServerSecurity, (void **) &pSec );
    ASSERT( result, "Could not get call context" );

    // Release it twice.
    pSec->Release();
    pSec->Release();
  }

cleanup:
  return result;
}

/***************************************************************************/
void CTest::assert_unknown()
{
  if (get_apt_type() == COINIT_APARTMENTTHREADED &&
      (my_id.process != GetCurrentProcessId() ||
       my_id.thread  != GetCurrentThreadId()))
  {
    printf( "**************************************************************\n" );
    printf( "**************************************************************\n" );
    printf( "*                    Unknown called on wrong thread.         *\n" );
    printf( "**************************************************************\n" );
    printf( "**************************************************************\n" );
  }
}

/***************************************************************************/
STDMETHODIMP CTest::call_canceled( long recurse, long cancel,
                                   ITest *callback )
{
  HRESULT result = S_OK;
  DWORD   wakeup;
  DWORD   sleep;
  DWORD   reason;
  MSG     msg;
  ASSERT_THREAD();

  // If the recursion count isn't zero, call back.
  if (recurse > 0)
  {
    result = callback->call_canceled( recurse-1, cancel, this );
    if (recurse <= cancel)
    {
      if (result != RPC_E_CALL_CANCELED &&
          result != MAKE_WIN32( RPC_S_CALL_CANCELLED ))
        if (result == S_OK)
          return E_FAIL;
        else
          return result;
      result = S_OK;
    }
    else if (result != S_OK)
      return result;
  }

  // If the cancel count is greater then the recursion count, cancel the
  // object that called me.
  if (cancel > recurse)
  {
    // Give the other object a chance to finish canceling me before I cancel
    // him.
    printf( "Waiting 10 seconds before canceling.\n" );
    Sleep(10000);
    result = next->cancel();

    // Give the cancel a chance to complete before returning.
    printf( "Waiting 5 seconds for cancel to complete.\n" );
    wakeup = GetCurrentTime() + 5000;
    sleep = 5000;
    do
    {
      reason = MsgWaitForMultipleObjects( 0, NULL, FALSE, sleep, QS_ALLINPUT );
      sleep = wakeup - GetCurrentTime();
      if (sleep > 5000)
        sleep = 0;
      if (reason != WAIT_TIMEOUT)
        if (GetMessageA( &msg, NULL, 0, 0 ))
        {
          TranslateMessage (&msg);
          DispatchMessageA (&msg);
        }
    } while (sleep != 0);
  }
  return result;
}

/***************************************************************************/
STDMETHODIMP CTest::call_dead( void )
{
  HRESULT result;
  ASSERT_THREAD();

  // Call the server, who is dead by now.
  result = next->check( next_id );
  next->Release();
  next = NULL;
  if (SUCCEEDED(result))
    return E_FAIL;
  else
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::call_me_back( ITest *test )
{
  ASSERT_THREAD();

  // Save the global object and tell the driver loop what to do next.
  test->AddRef();
  GlobalTest = test;
  what_next( callback_wn );
  wake_up_and_smell_the_roses();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::call_next( void )
{
  HRESULT result;
  ASSERT_THREAD();

  // Call the neighbor.
  return next->check( next_id );
}

/***************************************************************************/
STDMETHODIMP CTest::callback( void )
{
  ASSERT_THREAD();
  GlobalWaiting = FALSE;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::cancel()
{
  HRESULT result;
  DWORD   thread;
  ASSERT_THREAD();

  // Tell my neighbor to cancel the current call next time he receives a
  // message on his message queue.
  result = next->cancel_pending_call( &thread );

  // Put a message on my neighbor's message queue.
  if (result == S_OK)
  {
    if (!PostThreadMessageA( thread, WM_USER, 0, 0 ))
      return E_FAIL;
  }
  return result;
}

/***************************************************************************/
STDMETHODIMP CTest::cancel_now()
{
  HRESULT result;

  return next->cancel();
}

/***************************************************************************/
STDMETHODIMP CTest::cancel_pending_call( DWORD *thread )
{
  ASSERT_THREAD();
  fcancel_next = TRUE;
  *thread = GetCurrentThreadId();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::cancel_stress( ITest *obj )
{
  HRESULT result;

  ASSERT_THREAD();

  // If there is an object, ask it to cancel the call to it.
  if (obj != NULL)
    result = obj->cancel_now();

  // Otherwise ask my neighbor to cancel the call to him.
  else
    // This only works locally.
    result = next->cancel();

  // Although the call should have been canceled, sometimes it completes
  // before the cancel does.
  if (result == S_OK || result == RPC_E_CALL_CANCELED ||
      result == MAKE_WIN32( RPC_S_CALL_CANCELLED ))
    return S_OK;
  else
    return result;
}

/***************************************************************************/
STDMETHODIMP CTest::catch_at_top( BOOL catchme, ITest *callback, STRING binding )
{
  // Save the callback object and the binding.
  callback->AddRef();
  GlobalTest    = callback;
  GlobalBinding = binding;

  // If the catch flag is true, tell the top level message loop to catch
  // exceptions.
  what_next( catch_wn );
  wake_up_and_smell_the_roses();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::check( SAptId id )
{
  ASSERT_THREAD();
  if (my_id.process == id.process && my_id.thread == id.thread &&
      my_id.sequence == id.sequence)
    return S_OK;
  else
    return E_FAIL;
}

/***************************************************************************/
STDMETHODIMP CTest::check_hook( DWORD cg1, DWORD cn1, DWORD sg1, DWORD sn1,
                                DWORD cg2, DWORD cn2, DWORD sg2, DWORD sn2,
                                BOOL dh1, BOOL dh2 )
{
  HRESULT     result = S_OK;
  IWhichHook *which  = NULL;
  ASSERT_THREAD();

  if (GlobalHook1 != NULL)
  {
    result = GlobalHook1->check( cg1, cn1, sg1, sn1 );
    if (result == S_OK && GlobalHook2 != NULL)
      result = GlobalHook2->check( cg2, cn2, sg2, sn2 );
  }

  if (result == S_OK)
  {
    result = CoCreateInstance( CLSID_WhichHook, NULL, CLSCTX_INPROC_SERVER,
                                 IID_IWhichHook, (void **) &which );
    if (which != NULL)
    {
      result = which->Hooked( CLSID_Hook1 );
      if ((result != S_OK && dh1) ||
          (result == S_OK && !dh1))
        result = E_FAIL;
      else
      {
        result = which->Hooked( CLSID_Hook2 );
        if ((result != S_OK && dh2) ||
            (result == S_OK && !dh2))
          result = E_FAIL;
        else
          result = S_OK;
      }
    }
  }
  return result;
}

/***************************************************************************/
STDMETHODIMP CTest::count()
{
  InterlockedIncrement( &GlobalCalls );
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::crash_out( transmit_crash *x )
{
  *x = 0;
  return S_OK;
}

/***************************************************************************/
#if  (_WIN32_WINNT >= 0x0500 )
HRESULT CTest::CreateCall( REFIID r1, IUnknown *pCtrl, REFIID r2,
                           IUnknown **ppv )
{
  HRESULT result;
  CAsync *async;
  *ppv = NULL;

  // Create a call object for the interface IAsync.
  if (r1 == IID_AsyncIAsync)
  {
    async = new CAsync( pCtrl );
    if (async == NULL)
      return E_OUTOFMEMORY;
    else
    {
      result = async->inner_unk.QueryInterface( r2, (void **) ppv );
      async->inner_unk.Release();
      return result;
    }
  }

  // Don't support any other interfaces asynchronously.
  return E_NOINTERFACE;
}
#endif

/***************************************************************************/
CTest::CTest()
{
  ref_count      = 1;
  next           = NULL;
  dacl           = NULL;
  fcancel_next   = FALSE;
  freject_next   = FALSE;
  fretry_next    = FALSE;
  flate_dispatch = FALSE;
  my_id.sequence = get_sequence();
  my_id.thread   = GetCurrentThreadId();
  my_id.process  = GetCurrentProcessId();
  state          = nothing_btw;
  increment_object_count();
}

/***************************************************************************/
CTest::~CTest()
{
  DWORD   query_authn_level;
  DWORD   what;
  HRESULT result;

  // Check the caller of release.
  if (state & callback_on_release_btw)
  {
    // Get the authentication information.
    result = MCoQueryClientBlanket( NULL, NULL, NULL, &query_authn_level,
                                    NULL, NULL, NULL );
    if (SUCCEEDED(result))
      if (query_authn_level == RPC_C_AUTHN_LEVEL_NONE)
        what = release_unsecure_btw;
      else
        what = release_secure_btw;
    else
      what = release_unsecure_btw;

    // Tell somebody about the release;
    if (next != NULL)
    {
      result = next->by_the_way( what );
      if (result != S_OK)
        printf( "Could not call by the way in release: 0x%x\n", result );
    }
  }

  // Clean up resources.
  if (dacl != NULL)
    dacl->Release();
  if (next != NULL)
    if (!dirty_thread())
      next->Release();
}

/***************************************************************************/
STDMETHODIMP CTest::decrypt( DWORD cryptlen, BYTE *crypt, WCHAR *orig,
                             DWORD keylen, BYTE *keyblob, WCHAR *password )
{
#if  (_WIN32_WINNT >= 0x0500 )
  HRESULT     result      = S_OK;
  DWORD       i;
  DWORD       j;
  DWORD       k;
  DWORD       len;
  BOOL        success     = FALSE;
  HCRYPTKEY   session     = 0;
  BYTE       *buffer;
  HCRYPTHASH  hash        = 0;
  DWORD       blen;

  // If there is a password, derive a session key.
  if (password != NULL)
  {
    // Create a hash object.
    success = CryptCreateHash( CryptProvider, CALG_MD5, NULL, 0, &hash );
    ASSERT_GLE( success, S_OK, "Could not create hash" );
    success = FALSE;

    // Hash the user name.
    success = CryptHashData( hash, (UCHAR *) password,
                             wcslen(password)*sizeof(WCHAR), 0 );
    ASSERT_GLE( success, S_OK, "Could not hash user name" );
    success = FALSE;

    // Derive the session key from the password hash.
    success = CryptDeriveKey( CryptProvider, CALG_RC4, hash, 0, &session );
    ASSERT_GLE( success, S_OK, "Could not derive key" );
    success = FALSE;
  }

  // Otherwise import the session key.
  else
  {
    success = CryptImportKey( CryptProvider, keyblob, keylen, NULL, 0, &session );
    ASSERT_GLE( success, S_OK, "Could not import server key" );
    success = FALSE;
  }

  // Verify that the data is encrypted.
  len = wcslen(orig)*sizeof(WCHAR) + sizeof(WCHAR);
  i = memcmp( crypt, orig, len );
  ASSERT_EXPR( i != 0, "Data not encrypted" );

  // Copy the data.
  buffer = (BYTE *) _alloca(cryptlen);
  memcpy( buffer, crypt, cryptlen );
  blen = cryptlen;

  // Decrypt the data.
  success = CryptDecrypt( session, NULL, TRUE, 0, buffer, &blen);
  ASSERT_GLE( success, S_OK, "Could not decrypt the data" );
  success = FALSE;
  i = wcscmp( orig, (WCHAR *) buffer );
  ASSERT_EXPR( i == 0 && blen == len, "Decrypted wrong data." );

  // Delete the old session key.
  success = CryptDestroyKey( session );
  ASSERT_GLE( success, S_OK, "Could not destroy session key" );
  session = 0;
  success = FALSE;

  // If there is a password, derive a session key.
  if (password != NULL)
  {
    // Create a hash object.
    success = CryptCreateHash( CryptProvider, CALG_MD5, NULL, 0, &hash );
    ASSERT_GLE( success, S_OK, "Could not create hash" );
    success = FALSE;

    // Hash the user name.
    success = CryptHashData( hash, (UCHAR *) password,
                             wcslen(password)*sizeof(WCHAR), 0 );
    ASSERT_GLE( success, S_OK, "Could not hash user name" );
    success = FALSE;

    // Derive the session key from the password hash.
    success = CryptDeriveKey( CryptProvider, CALG_RC4, hash, 0, &session );
    ASSERT_GLE( success, S_OK, "Could not derive key" );
    success = FALSE;
  }

  // Otherwise import the session key.
  else
  {
    success = CryptImportKey( CryptProvider, keyblob, keylen, NULL, 0, &session );
    ASSERT_GLE( success, S_OK, "Could not import server key" );
    success = FALSE;
  }

  // Decrypt the wrong data.
  blen = cryptlen;
  memset( buffer, 'x', blen );
  success = CryptDecrypt( session, NULL, TRUE, 0, buffer, &blen);
  ASSERT_GLE( success, S_OK, "Could not decrypt the data" );
  success = FALSE;
  i = wcscmp( orig, (WCHAR *) buffer );
  ASSERT_EXPR( i != 0, "Decrypted generated correct results from wrong input." );

  // Delete the old session key.
  success = CryptDestroyKey( session );
  ASSERT_GLE( success, S_OK, "Could not destroy session key" );
  session = 0;
  success = FALSE;

  // Generate a session key.
  success = CryptGenKey( CryptProvider, CALG_RC4, CRYPT_EXPORTABLE, &session );
  ASSERT_GLE( success, S_OK, "Could not generate session key" );
  success = FALSE;

  // Copy the data.
  memcpy( buffer, crypt, cryptlen );
  blen = cryptlen;

  // Decrypt with the wrong key.
  success = CryptDecrypt( session, NULL, TRUE, 0, buffer, &blen);
  ASSERT_GLE( success, S_OK, "Could not decrypt the data" );
  success = FALSE;
  i = wcscmp( orig, (WCHAR *) buffer );
  ASSERT_EXPR( i != 0, "Decrypted generated correct results from wrong key." );

  success = TRUE;
cleanup:
  if (session != 0)
    CryptDestroyKey( session );
  if (!success && result == S_OK)
    result = E_FAIL;
  return result;
#else
  return E_FAIL;
#endif
}

/***************************************************************************/
STDMETHODIMP CTest::delegate( ITest *obj, SAptId id, STRING caller )
{
  HRESULT result           = S_OK;
  DWORD   ignore;

  ASSERT_THREAD();

  // Impersonate.
  if (!Win95)
  {
    result = MCoImpersonateClient();
    ASSERT( result, "Could not impersonate" );
  }

  // Set the security for the next call.
  result = MCoSetProxyBlanket( obj, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Revert.
  if (!Win95)
  {
    result = MCoRevertToSelf();
    ASSERT( result, "Could not revert" );
  }

  // Call the final server.
  result = obj->secure( id, RPC_C_AUTHN_LEVEL_CONNECT,
                        RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                        RPC_C_AUTHZ_NONE, NULL, DomainUser,
                        &ignore );
  ASSERT( result, "Could not make delegate call" );

cleanup:
  return result;
}

/***************************************************************************/
STDMETHODIMP CTest::do_next( DWORD next )
{
  what_next( (enum what_next_en) next );
  wake_up_and_smell_the_roses();
  ASSERT_THREAD();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::exit( void )
{
  what_next( quit_wn );
  wake_up_and_smell_the_roses();
  ASSERT_THREAD();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::forget( void )
{
  ASSERT_THREAD();
  if (next != NULL)
  {
    next->Release();
    next = NULL;
  }
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::get_advise( IAdviseSink **obj )
{
  *obj = (IAdviseSink *) new CTest;
  return S_OK;
/*
  *obj = NULL;
  ASSERT_THREAD();
  *obj = new CAdvise;
  if (*obj!= NULL)
    return S_OK;
  else
    return E_FAIL;
*/
}

/***************************************************************************/
STDMETHODIMP CTest::get_data( DWORD isize, unsigned char *idata, DWORD osize,
                              unsigned char **odata )
{
  *odata = (unsigned char *) CoTaskMemAlloc( 1 );
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::get_id( SAptId *id )
{
  ASSERT_THREAD();
  *id = my_id;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::get_next( ITest **obj, SAptId *id )
{
  *obj = NULL;
  ASSERT_THREAD();
  *id  = next_id;
  *obj = next;
  if (next != NULL)
    next->AddRef();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::get_next_slowly( ITest **obj, SAptId *id )
{
  *obj = NULL;
  ASSERT_THREAD();
  *id  = next_id;
  *obj = next;
  if (next != NULL)
    next->AddRef();

  // Start shutting down.
  exit();

  // Wait a while.
  SetEvent( RawEvent );
  Sleep( 5000 );
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::get_obj_from_new_apt( ITest **obj, SAptId *id )
{
  *obj = NULL;
  ASSERT_THREAD();
  return new_apartment( obj, id, NULL, ThreadMode );
}

/***************************************************************************/
STDMETHODIMP CTest::get_obj_from_this_apt( ITest **obj, SAptId *id )
{
  *obj = NULL;
  ASSERT_THREAD();
  *obj = new CTest;
  if (*obj!= NULL)
    return (*obj)->get_id( id );
  else
    return E_FAIL;
}

/***************************************************************************/
STDMETHODIMP CTest::get_string( DWORD what, WCHAR **str )
{
  // Return the creator string.
  if (what == creator_ws)
  {
    if (Creator == NULL)
      *str = NULL;
    else
    {
      *str = (WCHAR *) CoTaskMemAlloc( sizeof(WCHAR) * (wcslen(Creator)+1) );
      wcscpy( *str, Creator );
    }
    return S_OK;
  }

  // Unknown request.
  else
    return E_INVALIDARG;
}

/***************************************************************************/
STDMETHODIMP_(DWORD) CTest::HandleInComingCall( DWORD type, HTASK task,
                                                DWORD tick,
                                                LPINTERFACEINFO info )
{
  if (freject_next)
  {
    freject_next = FALSE;
    return SERVERCALL_REJECTED;
  }

  // Accept everything.
  else
    return SERVERCALL_ISHANDLED;
}

/***************************************************************************/
STDMETHODIMP CTest::interface_in( ITest *test )
{
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::interrupt( ITest *param, SAptId id, BOOL go )
{
  ASSERT_THREAD();
  GlobalInterruptTest = go;
  if (go)
  {
    GlobalTest = param;
    GlobalApt  = id;
    GlobalTest->AddRef();
    what_next( interrupt_wn );
    wake_up_and_smell_the_roses();
  }
  else
    what_next( wait_wn );
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::interrupt_marshal( ITest *obj1, ITest *obj2 )
{
  ASSERT_THREAD();
  GlobalTest = obj1;
  GlobalTest2 = obj2;
  GlobalTest->AddRef();
  GlobalTest2->AddRef();
  what_next( interrupt_marshal_wn );
  wake_up_and_smell_the_roses();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::list_out( PACTRL_ACCESSW_ALLOCATE *list )
{
  HRESULT            result;
  SAccess            big;
  IAccessControl    *access           = NULL;

  // Create an IAccessControl
  *list = NULL;
  result = CoCreateInstance( CLSID_DCOMAccessControl, NULL,
                       CLSCTX_INPROC_SERVER,
                       IID_IAccessControl, (void **) &access );
  ASSERT( result, "Could not create DCOM access control." );

  // Test set everyone.
  big.access.cEntries                        = 1;
  big.access.pPropertyAccessList             = &big.property;
  big.property.lpProperty                    = NULL;
  big.property.pAccessEntryList              = &big.list;
  big.property.fListFlags                    = 0;
  big.list.cEntries                          = 1;
  big.list.pAccessList                       = &big.entry;
  big.entry.fAccessFlags                     = ACTRL_ACCESS_ALLOWED;
  big.entry.Access                           = COM_RIGHTS_EXECUTE;
  big.entry.ProvSpecificAccess               = 0;
  big.entry.Inheritance                      = NO_INHERITANCE;
  big.entry.lpInheritProperty                = NULL;
  big.entry.Trustee.pMultipleTrustee         = NULL;
  big.entry.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
  big.entry.Trustee.TrusteeForm              = TRUSTEE_IS_NAME;
  big.entry.Trustee.TrusteeType              = TRUSTEE_IS_GROUP;
  big.entry.Trustee.ptstrName                = L"*";
  result = access->SetAccessRights( &big.access );
  ASSERT( result, "Could not set access" );

  // Get the access list
  result = access->GetAllAccessRights( NULL, list, NULL, NULL );
  ASSERT( result, "Could not get rights" );

cleanup:
  if (access != NULL)
    access->Release();
  return result;
}

/***************************************************************************/
STDMETHODIMP CTest::make_acl( HACKSID *allow )
{
  BOOL                 success       = FALSE;
  BOOL                 call_success  = FALSE;
  PACL                 pACLNew       = NULL;
  DWORD                cbACL         = 1024;
  PRIVILEGE_SET        set;
  DWORD                granted_access;
  BOOL                 access;
  DWORD                privilege_size;
  HRESULT              result        = E_FAIL;
  TOKEN_PRIVILEGES     privilege;
  SID                 *copy          = NULL;
  DWORD                length;

  // Copy the SID.
  length = GetLengthSid( (SID *) allow );
  copy   = (SID *) malloc( length );
  ASSERT_EXPR( copy != NULL, "Could not allocate memory." );
  memcpy( copy, allow, length );

  // Initialize a new security descriptor.
  GlobalSecurityDescriptor = (SECURITY_DESCRIPTOR *) LocalAlloc(LPTR,
      SECURITY_DESCRIPTOR_MIN_LENGTH);
  ASSERT_EXPR( GlobalSecurityDescriptor != NULL, "Could not allocate memory for the security descriptor." );
  call_success = InitializeSecurityDescriptor(GlobalSecurityDescriptor,
          SECURITY_DESCRIPTOR_REVISION);
  ASSERT_EXPR( call_success, "InitializeSecurityDescriptor" );

  // Initialize a new ACL.
  pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
  ASSERT_EXPR( pACLNew != NULL, "LocalAlloc" );
  call_success = InitializeAcl(pACLNew, cbACL, ACL_REVISION2);
  ASSERT_EXPR( call_success, "InitializeAcl" );

  // Allow read but not write access to the file.
  call_success = AddAccessAllowedAce( pACLNew, ACL_REVISION2, READ_CONTROL,
                                      copy );
  ASSERT_EXPR( call_success, "AddAccessAllowedAce failed." );

  // Add a new ACL to the security descriptor.
  call_success = SetSecurityDescriptorDacl(GlobalSecurityDescriptor,
          TRUE,              /* fDaclPresent flag  */
          pACLNew,
          FALSE);
  ASSERT_EXPR( call_success, "SetSecurityDescriptorDacl failed." );

  // Set the group.
  call_success = SetSecurityDescriptorGroup( GlobalSecurityDescriptor,
                                             copy, FALSE );
  ASSERT_EXPR( call_success, "SetSecurityDescriptorGroup failed." );

  // Set the owner.
  call_success = SetSecurityDescriptorOwner( GlobalSecurityDescriptor,
                                             copy, FALSE );
  ASSERT_EXPR( call_success, "SetSecurityDescriptorOwner failed." );

  // Check the security descriptor.
  call_success = IsValidSecurityDescriptor( GlobalSecurityDescriptor );
  ASSERT_EXPR( call_success, "IsValidSecurityDescriptor failed." );

  success = TRUE;
cleanup:
  if (!success)
  {
    if(GlobalSecurityDescriptor != NULL)
      LocalFree((HLOCAL) GlobalSecurityDescriptor);
    if(pACLNew != NULL)
      LocalFree((HLOCAL) pACLNew);
    if (copy != NULL)
      free( copy );
  }

  if (success)
    return S_OK;
  else if (result != S_OK)
    return result;
  else
    return E_FAIL;
}

/***************************************************************************/
STDMETHODIMP_(DWORD) CTest::MessagePending( HTASK callee, DWORD tick,
                                            DWORD type )
{
  if (fcancel_next)
  {
    fcancel_next = FALSE;
    return PENDINGMSG_CANCELCALL;
  }
  else
    return PENDINGMSG_WAITDEFPROCESS;
}

/***************************************************************************/
STDMETHODIMP CTest::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  HRESULT            result           = S_OK;
  DWORD              query_authn_level;
  BOOL               success;
  char               value[REGISTRY_ENTRY_LEN];
  LONG               value_size = sizeof(value);
  HANDLE             token;

  ASSERT_THREAD();
  *ppvObj = NULL;

  // Return the normal interfaces.
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_ITest))
  {
    *ppvObj = (IUnknown *) (ITest *) this;
    AddRef();
    return S_OK;
  }

  // Return the message filter.
  else if (IsEqualIID(riid, IID_IMessageFilter))
  {
    *ppvObj = (IUnknown *) (IMessageFilter *) this;
    AddRef();
    return S_OK;
  }

#if  (_WIN32_WINNT >= 0x0500 )
  // Return ICallFactory
  else if (IsEqualIID(riid, IID_ICallFactory))
  {
    *ppvObj = (IUnknown *) (ICallFactory *) this;
    AddRef();
    return S_OK;
  }

  // Return IAsync
  else if (IsEqualIID(riid, IID_IAsync))
  {
    *ppvObj = (IUnknown *) (IAsync *) this;
    AddRef();
    return S_OK;
  }
#endif

  // Check security and return ITest.
  else if (IsEqualIID( riid, IID_ITestNoneImp )    ||
           IsEqualIID( riid, IID_ITestConnectImp ) ||
           IsEqualIID( riid, IID_ITestEncryptImp ) ||
           IsEqualIID( riid, IID_ITestNoneId )     ||
           IsEqualIID( riid, IID_ITestConnectId )  ||
           IsEqualIID( riid, IID_ITestEncryptId ))
  {
    // Get the authentication information.
    result = MCoQueryClientBlanket( NULL, NULL, NULL, &query_authn_level,
                                    NULL, NULL, NULL );
    // Impersonate.
    if (SUCCEEDED(result))
    {
      result = MCoImpersonateClient();
      if (query_authn_level != RPC_C_AUTHN_LEVEL_NONE && FAILED(result))
        return result;
    }

    // Look at the IID to determine the proper results.
    if (IsEqualIID( riid, IID_ITestNoneImp ))
    {
      // If there is a token, should not be able to read the registry.
      success = OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &token );
      if (success)
      {
        result = RegQueryValueA( HKEY_CLASSES_ROOT, REG_CLASS_EXE, value, &value_size );
        if (result != ERROR_SUCCESS)
          goto exit;
      }
      *ppvObj = (ITest *) this;
      AddRef();
      result = S_OK;
      goto exit;
    }
    if (IsEqualIID( riid, IID_ITestConnectImp ))
    {
      // The query and impersonate should have succeeded.
      if (FAILED(result)) return result;

      // Should be able to read the registry.
      if (query_authn_level < RPC_C_AUTHN_LEVEL_CONNECT)
      {
        result = E_FAIL;
        goto exit;
      }
      result = RegQueryValueA( HKEY_CLASSES_ROOT, REG_CLASS_EXE, value, &value_size );
      if (result != ERROR_SUCCESS)
        goto exit;
      *ppvObj = (ITest *) this;
      AddRef();
      result = S_OK;
      goto exit;
    }
    if (IsEqualIID( riid, IID_ITestEncryptImp ))
    {
      // The query and impersonate should have succeeded.
      if (FAILED(result)) return result;

      // Should be able to read the registry.
      if (query_authn_level < RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
      {
        result = E_FAIL;
        goto exit;
      }
      result = RegQueryValueA( HKEY_CLASSES_ROOT, REG_CLASS_EXE, value, &value_size );
      if (result != ERROR_SUCCESS)
        goto exit;
      *ppvObj = (ITest *) this;
      AddRef();
      result = S_OK;
      goto exit;
    }
    if (IsEqualIID( riid, IID_ITestNoneId ))
    {
      // If there is a token, should not be able to read the registry.
      success = OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &token );
      if (success)
      {
        result = RegQueryValueA( HKEY_CLASSES_ROOT, REG_CLASS_EXE, value, &value_size );
        if (result != ERROR_BAD_IMPERSONATION_LEVEL)
        {
          result = E_FAIL;
          goto exit;
        }
      }
      *ppvObj = (ITest *) this;
      AddRef();
      result = S_OK;
      goto exit;
    }
    if (IsEqualIID( riid, IID_ITestConnectId ))
    {
      // The query and impersonate should have succeeded.
      if (FAILED(result)) return result;

      // Should not be able to read the registry.
      if (query_authn_level < RPC_C_AUTHN_LEVEL_CONNECT)
      {
        result = E_FAIL;
        goto exit;
      }
      result = RegQueryValueA( HKEY_CLASSES_ROOT, REG_CLASS_EXE, value, &value_size );
      if (result != ERROR_BAD_IMPERSONATION_LEVEL)
      {
        result = E_FAIL;
        goto exit;
      }
      *ppvObj = (ITest *) this;
      AddRef();
      result = S_OK;
      goto exit;
    }
    if (IsEqualIID( riid, IID_ITestEncryptId ))
    {
      // The query and impersonate should have succeeded.
      if (FAILED(result)) return result;

      // Should be able to read the registry.
      if (query_authn_level < RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
      {
        result = E_FAIL;
        goto exit;
      }
      result = RegQueryValueA( HKEY_CLASSES_ROOT, REG_CLASS_EXE, value, &value_size );
      if (result != ERROR_BAD_IMPERSONATION_LEVEL)
      {
        result = E_FAIL;
        goto exit;
      }
      *ppvObj = (ITest *) this;
      AddRef();
      result = S_OK;
      goto exit;
    }
exit:
    CoRevertToSelf();
    return result;
  }
  return E_NOINTERFACE;
}

/***************************************************************************/
STDMETHODIMP CTest::neighbor_access( ITest *neighbor )
{
  return neighbor->setup_access();
}

/***************************************************************************/
STDMETHODIMP CTest::null()
{
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::out( ITest **obj )
{
  *obj = this;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::perf_access( DWORD *grant, DWORD *revoke, DWORD *set,
                                 DWORD *get, DWORD *generate, DWORD *check,
                                 DWORD *cache )
{
  SAccess         big;
  TRUSTEE_W       someone;
  BOOL            allowed;
  WCHAR          *caller = NULL;
  LARGE_INTEGER   freq;
  LARGE_INTEGER   start;
  LARGE_INTEGER   end;
  ACTRL_ACCESSW  *list   = NULL;
  HRESULT         result;

  ASSERT_THREAD();

  // Find out who the caller is.
  result = MCoQueryClientBlanket( NULL, NULL, NULL, NULL, NULL,
                                  (void **) &caller, NULL );
  ASSERT( result, "Could not query blanket" );

  // Measure performance of an access check.
  QueryPerformanceFrequency( &freq );
  someone.pMultipleTrustee         = NULL;
  someone.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
  someone.TrusteeForm              = TRUSTEE_IS_NAME;
  someone.TrusteeType              = TRUSTEE_IS_USER;
  someone.ptstrName                = caller;
  allowed                          = FALSE;
  QueryPerformanceCounter( &start );
  result = dacl->IsAccessAllowed( &someone, NULL, COM_RIGHTS_EXECUTE, &allowed );
  QueryPerformanceCounter( &end );
  *check = 1000000 * (DWORD) ((end.QuadPart - start.QuadPart) / freq.QuadPart);
  ASSERT( result, "IsAcessAllowed failed" );
  if (!allowed)
  {
    result = E_FAIL;
    ASSERT( result, "IsAccessAllowed denied me" );
  }

  // Measure performance of a cached access check.
  allowed                          = FALSE;
  QueryPerformanceCounter( &start );
  result = dacl->IsAccessAllowed( &someone, NULL, COM_RIGHTS_EXECUTE, &allowed );
  QueryPerformanceCounter( &end );
  *cache = 1000000 * (DWORD) ((end.QuadPart - start.QuadPart) / freq.QuadPart);
  ASSERT( result, "IsAcessAllowed failed" );
  if (!allowed)
  {
    result = E_FAIL;
    ASSERT( result, "IsAccessAllowed denied me" );
  }

  // Measure performance of grant.
  big.access.cEntries                        = 1;
  big.access.pPropertyAccessList             = &big.property;
  big.property.lpProperty                    = NULL;
  big.property.pAccessEntryList              = &big.list;
  big.property.fListFlags                    = 0;
  big.list.cEntries                          = 1;
  big.list.pAccessList                       = &big.entry;
  big.entry.fAccessFlags                     = ACTRL_ACCESS_ALLOWED;
  big.entry.Access                           = COM_RIGHTS_EXECUTE;
  big.entry.ProvSpecificAccess               = 0;
  big.entry.Inheritance                      = NO_INHERITANCE;
  big.entry.lpInheritProperty                = NULL;
  big.entry.Trustee.pMultipleTrustee         = NULL;
  big.entry.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
  big.entry.Trustee.TrusteeForm              = TRUSTEE_IS_NAME;
  big.entry.Trustee.TrusteeType              = TRUSTEE_IS_GROUP;
  big.entry.Trustee.ptstrName                = L"*";
  QueryPerformanceCounter( &start );
  result = dacl->GrantAccessRights( &big.access );
  QueryPerformanceCounter( &end );
  *grant = 1000000 * (DWORD) ((end.QuadPart - start.QuadPart) / freq.QuadPart);
  ASSERT( result, "Could not grant access" );

  // Measure performance of generate access check.
  allowed                          = FALSE;
  QueryPerformanceCounter( &start );
  result = dacl->IsAccessAllowed( &someone, NULL, COM_RIGHTS_EXECUTE, &allowed );
  QueryPerformanceCounter( &end );
  *generate = 1000000 * (DWORD) ((end.QuadPart - start.QuadPart) / freq.QuadPart);
  ASSERT( result, "IsAcessAllowed failed" );
  if (!allowed)
  {
    result = E_FAIL;
    ASSERT( result, "IsAccessAllowed denied me" );
  }

  // Measure performance of revoke.
  QueryPerformanceCounter( &start );
  result = dacl->RevokeAccessRights( NULL, 1, &someone );
  QueryPerformanceCounter( &end );
  *revoke = 1000000 * (DWORD) ((end.QuadPart - start.QuadPart) / freq.QuadPart);
  ASSERT( result, "Could not revoke access" );

  // Measure performance of set.
  QueryPerformanceCounter( &start );
  result = dacl->SetAccessRights( &big.access );
  QueryPerformanceCounter( &end );
  *set = 1000000 * (DWORD) ((end.QuadPart - start.QuadPart) / freq.QuadPart);
  ASSERT( result, "Could not set access" );

  // Measure performance of get.
  QueryPerformanceCounter( &start );
  result = dacl->GetAllAccessRights( NULL, &list, NULL, NULL );
  QueryPerformanceCounter( &end );
  *get = 1000000 * (DWORD) ((end.QuadPart - start.QuadPart) / freq.QuadPart);
  ASSERT( result, "Could not get access" );

cleanup:
  if (list != NULL)
    CoTaskMemFree( list );
  return result;
}

/***************************************************************************/
STDMETHODIMP CTest::pipe_in( DWORD num, DWORD block, ILongPipe *pi )
{
  ULONG    i;
  HRESULT  result;
  LONG     buf[1000];
  ULONG    j;
  ULONG    k;

  // Read the data.
  i = 0;
  while (i < num)
  {
    // Read some data.
    result = pi->Pull( buf, block, &j );
    if (result != S_OK)
      return result;

    // Verify the length.
    if (i+j > num)
      return E_FAIL;

    // Verify the data.
    for (k = 0; k < j; k++)
      if (buf[k] != (LONG) i++)
        return E_FAIL;
  }

  // The next read should return zero elements.
  result = pi->Pull( buf, block, &j );
  if (result != S_OK)
    return result;
  if (j != 0)
    return E_FAIL;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::pipe_inout( DWORD num, DWORD block,
                                ILongPipe *pi, ILongPipe *po )
{
  ULONG    i;
  HRESULT  result;
  LONG     buf[1000];
  ULONG    j;
  ULONG    k;

  // Read the data.
  i = 0;
  while (i < num)
  {
    // Read some data.
    result = pi->Pull( buf, block, &j );
    if (result != S_OK)
      return result;

    // Verify the length.
    if (i+j > num)
      return E_FAIL;

    // Verify the data.
    for (k = 0; k < j; k++)
      if (buf[k] != (LONG) i++)
        return E_FAIL;
  }

  // The next read should return zero elements.
  result = pi->Pull( buf, block, &j );
  if (result != S_OK)
    return result;
  if (j != 0)
    return E_FAIL;

  // Write the out data.
  i = 0;
  while (i < num)
  {
    // Compute the size to send.
    if (i+block > num)
      k = num - i;
    else
      k = block;

    // Generate the next block.
    for (j = 0; j < k; j++)
      buf[j] = i++;

    // Send it.
    result = po->Push( buf, k );
    if (result != S_OK)
      return result;
  }

  // End the pipe.
  result = po->Push( buf, 0 );
  if (result != S_OK)
    return result;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::pipe_out( DWORD num, DWORD block, ILongPipe *po )
{
  ULONG    i;
  HRESULT  result;
  LONG     buf[1000];
  ULONG    j;
  ULONG    k;
  // Write the out data.
  i = 0;
  while (i < num)
  {
    // Compute the size to send.
    if (i+block > num)
      k = num - i;
    else
      k = block;

    // Generate the next block.
    for (j = 0; j < k; j++)
      buf[j] = i++;

    // Send it.
    result = po->Push( buf, k );
    if (result != S_OK)
      return result;
  }

  // End the pipe.
  result = po->Push( buf, 0 );
  if (result != S_OK)
    return result;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::pointer( DWORD *p )
{
  ASSERT_THREAD();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::pound( )
{
  SAptId    id;
  HRESULT   result;
  SAptData *apt    = get_apt_data();
  ASSERT_THREAD();

  // Create a server.
  result = create_instance( get_class(any_wc), WhatDest, &apt->server, &id );
  ASSERT( result, "Could not create server" );

  // Tell the server loop to pound.
  what_next( pound_wn );
  wake_up_and_smell_the_roses();

cleanup:
  return result;
}

/***************************************************************************/
#if  (_WIN32_WINNT >= 0x0500 )
HRESULT CTest::preimpersonate( BOOL fOn )
{
  // The async routine should be called instead of this one.
  return E_FAIL;
}
#endif

/***************************************************************************/
STDMETHODIMP CTest::recurse( ITest *callback, ULONG depth )
{
  ASSERT_THREAD();
  if (depth == 0)
    return S_OK;
  else
    return callback->recurse( this, depth-1 );
}

/***************************************************************************/
STDMETHODIMP CTest::recurse_delegate( ITest *callback, ULONG depth,
                                      STRING caller )
{
  HRESULT            result;
  DWORD              authn_svc_out;
  OLECHAR           *princ_name_out = NULL;
  ASSERT_THREAD();
#if  (_WIN32_WINNT >= 0x0500 )

  // Impersonate
  if (!Win95)
  {
    result = MCoImpersonateClient();
    ASSERT( result, "Could not impersonate" );
  }

  if (depth != 0)
  {
    // Get the principal name and authentication service.
    result = MCoQueryProxyBlanket( callback, &authn_svc_out, NULL,
                                   &princ_name_out, NULL,
                                   NULL, NULL, NULL );
    ASSERT( result, "Could not query blanket" );

    // Pick up the token for the next call.
    result = MCoSetProxyBlanket( callback, authn_svc_out,
                                 RPC_C_AUTHZ_NONE,
                                 princ_name_out, RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_IMP_LEVEL_DELEGATE, NULL,
                                 EOAC_STATIC_CLOAKING );
    ASSERT( result, "Could not set blanket" );
  }

  // If not deep enough, continue to recurse.
  if (depth != 0)
  {
    result = callback->recurse_delegate( this, depth-1, caller );
    ASSERT( result, "Could not recurse" );
  }

  // Get the name from the thread token.
  if (!Win95)
  {
    result = check_token( caller, DEFAULT_CONTEXT, RPC_C_IMP_LEVEL_DELEGATE );
    ASSERT( result, "Wrong impersonation name." );
  }

  // Revert.
  if (!Win95)
  {
    result = MCoRevertToSelf();
    ASSERT( result, "Could not revert" );
    result = check_token( DomainUser, NULL, -1 );
    ASSERT( result, "Token not restored after revert" );
  }
#endif
  result = S_OK;
cleanup:
  return result;
}

/***************************************************************************/
STDMETHODIMP CTest::recurse_disconnect( ITest *callback, ULONG depth )
{
  ASSERT_THREAD();

  HRESULT result;

  if (depth == 0)
  {
    result = CoDisconnectObject( (ITest *) this, 0 );
    return result;
  }
  else
  {
    result = callback->recurse_disconnect( this, depth-1 );
    return result;
  }
}

/***************************************************************************/
STDMETHODIMP CTest::recurse_excp( ITest *callback, ULONG depth )
{
  ASSERT_THREAD();
  if (depth == 0)
  {
    RaiseException( E_FAIL, 0, 0, NULL );
    return E_FAIL;
  }
  else
    return callback->recurse_excp( this, depth-1 );
}

/***************************************************************************/
STDMETHODIMP CTest::recurse_fatal( ITest *callback, ULONG catch_depth,
                                   ULONG throw_depth, BOOL cancel )
{
  ASSERT_THREAD();
  if (catch_depth == 0)
  {
    __try
    {
      return recurse_fatal_helper( callback, catch_depth, throw_depth, cancel );
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
      printf( "Exception on thread 0x%x\n", GetCurrentThreadId() );
      what_next( crippled_wn );
      wake_up_and_smell_the_roses();
      return S_OK;
    }
  }
  else
    return recurse_fatal_helper( callback, catch_depth, throw_depth, cancel );
}

/***************************************************************************/
STDMETHODIMP CTest::recurse_fatal_helper( ITest *callback, ULONG catch_depth,
                                          ULONG throw_depth, BOOL cancel )
{
  volatile void **p = (volatile void **) 0xffffffff;

  if (throw_depth == 0)
  {
    // If the cancel flag is set, tell the helper to tell the caller to cancel
    // the call to this object.
    if (cancel)
      next->cancel();

    // Die a horrible death.
    return (HRESULT) *p;
  }
  else
    return callback->recurse_fatal( this, catch_depth-1, throw_depth-1, cancel );
}

/***************************************************************************/
STDMETHODIMP CTest::recurse_interrupt( ITest *callback, ULONG depth )
{
  MSG msg;

  ASSERT_THREAD();
  if (PeekMessageA( &msg, NULL, 0, 0, PM_REMOVE ))
  {
    TranslateMessage (&msg);
    DispatchMessageA (&msg);
  }

  if (depth == 0)
    return S_OK;
  else
    return callback->recurse( this, depth-1 );
}

/***************************************************************************/
STDMETHODIMP CTest::recurse_secure( ITest *callback, ULONG depth,
                                    ULONG imp_depth, STRING caller )
{
  HRESULT            result;
  WCHAR             *orig_name = NULL;
  ASSERT_THREAD();

  if (depth != 0)
  {
    // Set the authentication level to connect.
    result = MCoSetProxyBlanket( callback, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                EOAC_NONE );
    ASSERT( result, "Could not set blanket" );
  }

  // Determine the original token.
  if (!Win95)
  {
    result = get_token_name( &orig_name, FALSE );
    ASSERT( result, "Could not lookup original token name" );
  }

  // Impersonate if necessary.
  if (Win95)
    imp_depth += 1;
  else if (imp_depth == 0)
  {
    result = MCoImpersonateClient();
    ASSERT( result, "Could not impersonate" );

    // Verify the impersonation.
    result = check_token( caller, DEFAULT_CONTEXT, RPC_C_IMP_LEVEL_IMPERSONATE );
    ASSERT( result, "Wrong impersonation name." );
  }

  // If not deep enough, continue to recurse.
  if (depth != 0)
  {
    result = callback->recurse_secure( this, depth-1, imp_depth-1,
                                       DomainUser );
    ASSERT( result, "Could not recurse" );
  }

  if (!Win95)
  {
    // Verify the impersonation.
    if (imp_depth == 0)
      result = check_token( caller, DEFAULT_CONTEXT, RPC_C_IMP_LEVEL_IMPERSONATE );
    else
      result = check_token( orig_name, NULL, RPC_C_IMP_LEVEL_IMPERSONATE );
    ASSERT( result, "Wrong impersonation name." );

    // Revert.
    if (imp_depth == 0)
    {
      result = MCoRevertToSelf();
      ASSERT( result, "Could not revert" );

      // Verify the original token.
      result = check_token( orig_name, NULL, RPC_C_IMP_LEVEL_IMPERSONATE );
      ASSERT( result, "Token not restored after revert" );
    }
  }

  result = S_OK;
cleanup:
  CoTaskMemFree( orig_name );
  return result;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CTest::Release( THIS )
{
  DWORD status;

  assert_unknown();
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    decrement_object_count();
    if (flate_dispatch)
    {
      status = WaitForSingleObject( RawEvent, INFINITE );
      if (status != WAIT_OBJECT_0)
        printf( "WaitForSingleObject failed.\n" );
    }
    delete this;
    return 0;
  }
  else
    return ref_count;
}

/***************************************************************************/
STDMETHODIMP CTest::register_hook( GUID ext, DWORD seq )
{
  CHook *hook;
  ASSERT_THREAD();

  // Create a new hook.
  hook = new CHook( ext, seq );
  if (hook == NULL)
    return E_OUTOFMEMORY;
  if (GlobalHook1 == NULL)
    GlobalHook1 = hook;
  else
    GlobalHook2 = hook;

  // Register it.
  return CoRegisterChannelHook( ext, hook );
}

/***************************************************************************/
STDMETHODIMP CTest::register_message_filter( BOOL reg )
{
  ASSERT_THREAD();

  if (reg)
    return CoRegisterMessageFilter( this, NULL );
  else
    return CoRegisterMessageFilter( NULL, NULL );
}

/***************************************************************************/
STDMETHODIMP CTest::register_rpc( WCHAR *protseq, WCHAR **binding )
{
  ASSERT_THREAD();

  RPC_STATUS          status;
  RPC_BINDING_VECTOR *bindings;
  WCHAR              *string;
  DWORD               i;
  WCHAR              *binding_protseq;
  BOOL                found;

  *binding = NULL;
  status = RpcServerUseProtseq( protseq, 20, NULL );
  if (status != RPC_S_OK)
    return MAKE_WIN32( status );

  status = RpcServerRegisterIf(xIDog_v0_1_s_ifspec,
                               NULL,   // MgrTypeUuid
                               NULL);  // MgrEpv; null means use default
  if (status != RPC_S_OK)
    return MAKE_WIN32( status );

  status = RpcServerRegisterAuthInfo( L"none", RPC_C_AUTHN_WINNT, 0, 0 );
  if (status != RPC_S_OK)
    return MAKE_WIN32( status );

  status = RpcServerListen( 1, 1235, TRUE );
  if (status != RPC_S_OK && status != RPC_S_ALREADY_LISTENING)
    return MAKE_WIN32( status );

  // Inquire the string bindings.
  status = RpcServerInqBindings( &bindings );
  if (status != RPC_S_OK)
    return MAKE_WIN32( status );
  if (bindings->Count == 0)
  {
    RpcBindingVectorFree( &bindings );
    return E_FAIL;
  }

  // Look for ncalrpc.
  for (i = 0; i < bindings->Count; i++)
  {

    // Convert the binding handle to a string binding, copy it, and free it.
    status = RpcBindingToStringBinding( bindings->BindingH[i], &string );
    if (status == RPC_S_OK)
    {
      // Look up the protseq.
      status = RpcStringBindingParse( string, NULL, &binding_protseq,
                                      NULL, NULL, NULL );
      if (status == RPC_S_OK)
      {
        found = wcscmp( binding_protseq, protseq ) == 0;
        RpcStringFree( &binding_protseq );
        if (found)
        {
          *binding = (WCHAR *) CoTaskMemAlloc( (wcslen(string)+1) * sizeof(WCHAR) );
          if (*binding != NULL)
            wcscpy( *binding, string );
          else
            status = RPC_S_OUT_OF_RESOURCES;
          RpcStringFree( &string );
          break;
        }
      }
      RpcStringFree( &string );
    }
  }
  if (*binding == NULL)
    status = E_FAIL;

  // Free the binding vector.
  RpcBindingVectorFree( &bindings );
  return status;
}

/***************************************************************************/
STDMETHODIMP CTest::reject_next()
{
  freject_next = TRUE;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::reinitialize( DWORD authn_svc )
{
  ASSERT_THREAD();
  if (authn_svc == RPC_C_AUTHN_DEFAULT)
    GlobalSecurityModel = legacy_sm;
  else
  {
    GlobalSecurityModel = basic_sm;
    GlobalAuthnSvc      = authn_svc;
  }
  what_next( reinitialize_wn );
  wake_up_and_smell_the_roses();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::remember( ITest *neighbor, SAptId id )
{
  ASSERT_THREAD();

  // Save this interface pointer.
  if (next != NULL)
    next->Release();
  next_id = id;
  next    = neighbor;
  next->AddRef();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::rest_and_die()
{
  ASSERT_THREAD();
  what_next( rest_and_die_wn );
  wake_up_and_smell_the_roses();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::retry_next()
{
  fretry_next = TRUE;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP_(DWORD) CTest::RetryRejectedCall( HTASK callee, DWORD tick,
                                               DWORD reject )
{
  if (fretry_next)
  {
    fretry_next = FALSE;
    return 0;
  }

  // Never retry.
  else
    return 0xffffffff;
}

/***************************************************************************/
STDMETHODIMP CTest::ring( DWORD length )
{
  DWORD   i = 0;
  ITest  *ring;
  ITest  *ring_next;
  SAptId  ring_id;
  HRESULT result;

  ASSERT_THREAD();

  // Call all the neighbors in the ring.
  ring    = next;
  ring_id = next_id;
  next->AddRef();
  while (ring != this)
  {
    result = ring->check( ring_id );
    if (FAILED(result))
    {
      ring->Release();
      return result;
    }
    result = ring->get_next( &ring_next, &ring_id );
    if (FAILED(result))
    {
      ring->Release();
      return result;
    }
    ring->Release();
    ring = ring_next;
    i++;
  }

  // Check to make sure the ring is correct.
  ring->Release();
  if (i+1 != length || ring_id.process != my_id.process ||
      ring_id.thread != my_id.thread || ring_id.sequence != my_id.sequence)
    return E_FAIL;
  else
    return S_OK;
}

/***************************************************************************/
#if  (_WIN32_WINNT >= 0x0500 )
HRESULT CTest::secure( SAptId id, DWORD test, STRING princ_name )
{
  // The async routine should be called instead of this one.
  return E_FAIL;
}
#endif

/***************************************************************************/
STDMETHODIMP CTest::secure( SAptId id, DWORD authn_level, DWORD imp_level,
                            DWORD authn_svc, DWORD authz_svc,
                            STRING princ_name, STRING caller,
                            DWORD *authn_level_out )
{
    HRESULT            result           = S_OK;
    DWORD              query_authn_level;
    DWORD              query_imp_level;
    DWORD              query_authn_svc;
    DWORD              query_authz_svc;
    STRING             query_princ_name = NULL;
    WCHAR             *query_priv;

    *authn_level_out = RPC_C_AUTHN_LEVEL_NONE;

    ASSERT_THREAD();
    if  (id.process != 0 && id.thread != 0 && id.sequence != 0)
      if (my_id.process != id.process || my_id.thread != id.thread ||
          my_id.sequence != id.sequence)
      return E_FAIL;

    // Query for the authentication information.
    result = MCoQueryClientBlanket( &query_authn_svc, &query_authz_svc,
                                    &query_princ_name, &query_authn_level,
                                    &query_imp_level, (void **) &query_priv, NULL );
    *authn_level_out = query_authn_level;

    // Sometimes query blanket fails for unsecure calls.
    if (result != S_OK)
    {
      ASSERT_EXPR( authn_level == RPC_C_AUTHN_LEVEL_NONE, "Query blanket failed." );
    }

    // For unsecure calls, all the other fields should be clear.
    else if (query_authn_level == RPC_C_AUTHN_LEVEL_NONE)
    {
      if (query_authn_level < authn_level)
      {
          result = E_INVALIDARG;
          goto cleanup;
      }
      // The impersonation level can't be determined on the server.
      // if (query_imp_level != RPC_C_IMP_LEVEL_IMPERSONATE)
      if (query_imp_level != RPC_C_IMP_LEVEL_ANONYMOUS)
      {
          result = E_INVALIDARG;
          goto cleanup;
      }
      if (query_authn_svc != RPC_C_AUTHN_NONE &&
          query_authn_svc != RPC_C_AUTHN_WINNT)
      {
          result = E_INVALIDARG;
          goto cleanup;
      }
      if (query_authz_svc != RPC_C_AUTHZ_NONE)
      {
          result = E_INVALIDARG;
          goto cleanup;
      }
      if (princ_name != NULL && query_princ_name != NULL &&
          _wcsicmp(princ_name, query_princ_name) != 0)
      {
          result = E_INVALIDARG;
          goto cleanup;
      }
    }

    // For secure calls, verify all the authentication info.
    else
    {
        ASSERT( result, "Could not query client blanket" );
        if (query_authn_level < authn_level)
        {
            result = E_INVALIDARG;
            goto cleanup;
        }
        // The impersonation level can't be determined on the server.
        //if (query_imp_level != imp_level)
        if (query_imp_level != RPC_C_IMP_LEVEL_ANONYMOUS)
        {
            result = E_INVALIDARG;
            goto cleanup;
        }
        // Sometimes ncalrpc doesn't set the authentication service.
        if (authn_svc       != RPC_C_AUTHN_NONE &&
            query_authn_svc != authn_svc        &&
            authn_svc       != -1)
        {
            result = E_INVALIDARG;
            goto cleanup;
        }
        if (query_authz_svc != authz_svc)
            if (query_authz_svc != RPC_C_AUTHZ_NAME ||
                authz_svc != RPC_C_AUTHZ_NONE)
            {
                result = E_INVALIDARG;
                goto cleanup;
            }
        if (princ_name != NULL && query_princ_name != NULL &&
            _wcsicmp(princ_name, query_princ_name) != 0)
        {
            result = E_INVALIDARG;
            goto cleanup;
        }
    }

    // Check the thread's token.
    if (!Win95)
    {
      result = check_token( DomainUser, NULL, -1 );
      ASSERT( result, "Wrong token before impersonating" );

      // Impersonate.
      result = MCoImpersonateClient();

      // For unsecure calls and calls using SSL the impersonate should fail.
      if (authn_level == RPC_C_AUTHN_LEVEL_NONE
#if  (_WIN32_WINNT >= 0x0500 )
          || authn_svc == RPC_C_AUTHN_GSS_SCHANNEL
#endif
          )
      {
        // Some unsecure impersonations succeed without setting the thread token.
/*
        if (result == S_OK)
        {
          result = E_FAIL;
          goto cleanup;
        }
*/
        result = S_OK;
      }

      // For secure calls, compare the new thread token sid to the passed
      // in sid.
      else
      {
        ASSERT( result, "Could not impersonate" );

        // Check the thread's token.
        result = check_token( caller, DEFAULT_CONTEXT, imp_level );
        ASSERT( result, "Wrong token after impersonating" );
      }

      // Revert.
      result = MCoRevertToSelf();
      ASSERT( result, "Could not revert" );

      // Check the thread's token.
      result = check_token( DomainUser, NULL, -1 );
      ASSERT( result, "Wrong token after reverting" );
    }

cleanup:
    CoTaskMemFree( query_princ_name );
    return result;
}

/***************************************************************************/
STDMETHODIMP CTest::security_performance( DWORD *get_call, DWORD *query_client,
                                          DWORD *impersonate, DWORD *revert )
{
  LARGE_INTEGER        start;
  LARGE_INTEGER        qget_call;
  LARGE_INTEGER        qquery_client;
  LARGE_INTEGER        qimpersonate;
  LARGE_INTEGER        qrevert;
  LARGE_INTEGER        freq;
  IServerSecurity     *server_sec = NULL;
  HRESULT              result;
  DWORD                authn_svc;
  DWORD                authz_svc;
  DWORD                authn_level;
  DWORD                imp_level;
  DWORD                capabilities;
  WCHAR               *principal        = NULL;
  void                *privs;

  // Import the security APIs.
  GCoGetCallContext     = (CoGetCallContextFn)     Fixup( "CoGetCallContext" );
  GCoImpersonateClient  = (CoImpersonateClientFn)  Fixup( "CoImpersonateClient" );
  GCoQueryClientBlanket = (CoQueryClientBlanketFn) Fixup( "CoQueryClientBlanket" );
  GCoRevertToSelf       = (CoRevertToSelfFn)       Fixup( "CoRevertToSelf" );
  if (GCoGetCallContext     == NULL ||
      GCoImpersonateClient  == NULL ||
      GCoQueryClientBlanket == NULL ||
      GCoRevertToSelf       == NULL)
    return E_NOTIMPL;

  // Measure the performance of get call context.
  QueryPerformanceFrequency( &freq );
  QueryPerformanceCounter( &start );
  result = MCoGetCallContext( IID_IServerSecurity, (void **) &server_sec );
  QueryPerformanceCounter( &qget_call );
  qget_call.QuadPart = 1000000 * (qget_call.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not get call context" );
  server_sec->Release();

  // Measure the performance of query client.
  QueryPerformanceCounter( &start );
  result = MCoQueryClientBlanket( &authn_svc, &authz_svc, &principal,
                                 &authn_level, &imp_level, &privs, &capabilities );
  QueryPerformanceCounter( &qquery_client );
  qquery_client.QuadPart = 1000000 * (qquery_client.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not query client blanket" );
  CoTaskMemFree( principal );

  // Measure the performance of impersonate.
  QueryPerformanceCounter( &start );
  result = MCoImpersonateClient();
  QueryPerformanceCounter( &qimpersonate );
  qimpersonate.QuadPart = 1000000 * (qimpersonate.QuadPart - start.QuadPart) / freq.QuadPart;
  if (Win95)
    result = S_OK;
  ASSERT( result, "Could not impersonate" );

  // Measure the performance of revert.
  QueryPerformanceCounter( &start );
  result = MCoRevertToSelf();
  QueryPerformanceCounter( &qrevert );
  qrevert.QuadPart = 1000000 * (qrevert.QuadPart - start.QuadPart) / freq.QuadPart;
  if (Win95)
    result = S_OK;
  ASSERT( result, "Could not revert" );

  // Return the results.
  *get_call     = qget_call.u.LowPart;
  *query_client = qquery_client.u.LowPart;
  *impersonate  = qimpersonate.u.LowPart;
  *revert       = qrevert.u.LowPart;

cleanup:
  return result;
}

/***************************************************************************/
STDMETHODIMP CTest::set_state( DWORD state, DWORD priority )
{
  BOOL success;
  SAptData *apt = get_apt_data();
  ASSERT_THREAD();

  // Save dirty flag per apartment.
  if (state & dirty_s)
    apt->exit_dirty = TRUE;

  // Save the late dispatch flag per object.
  if (state & late_dispatch_s)
    flate_dispatch = TRUE;

  // Set the priority.
  success = SetThreadPriority( GetCurrentThread(), priority );
  if (success)
    return S_OK;
  else
    return E_FAIL;
}

/***************************************************************************/
STDMETHODIMP CTest::setup_access()
{
  SAccess         big;
  TRUSTEE_W       someone;
  BOOL            allowed;
  WCHAR          *caller = NULL;
  HRESULT         result;

  ASSERT_THREAD();

  // Create an IAccessControl
  result = CoCreateInstance( CLSID_DCOMAccessControl, NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IAccessControl, (void **) &dacl );
  ASSERT( result, "Could not create DCOM access control." );

  // Give everyone access.
  big.access.cEntries                        = 1;
  big.access.pPropertyAccessList             = &big.property;
  big.property.lpProperty                    = NULL;
  big.property.pAccessEntryList              = &big.list;
  big.property.fListFlags                    = 0;
  big.list.cEntries                          = 1;
  big.list.pAccessList                       = &big.entry;
  big.entry.fAccessFlags                     = ACTRL_ACCESS_ALLOWED;
  big.entry.Access                           = COM_RIGHTS_EXECUTE;
  big.entry.ProvSpecificAccess               = 0;
  big.entry.Inheritance                      = NO_INHERITANCE;
  big.entry.lpInheritProperty                = NULL;
  big.entry.Trustee.pMultipleTrustee         = NULL;
  big.entry.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
  big.entry.Trustee.TrusteeForm              = TRUSTEE_IS_NAME;
  big.entry.Trustee.TrusteeType              = TRUSTEE_IS_GROUP;
  big.entry.Trustee.ptstrName                = L"*";
  result = dacl->SetAccessRights( &big.access );
  ASSERT( result, "Could not set access" );

  // Find out who the caller is.
  result = MCoQueryClientBlanket( NULL, NULL, NULL, NULL, NULL,
                                  (void **) &caller, NULL );
  ASSERT( result, "Could not query blanket" );

  // Make it generate the ACL.
  someone.pMultipleTrustee         = NULL;
  someone.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
  someone.TrusteeForm              = TRUSTEE_IS_NAME;
  someone.TrusteeType              = TRUSTEE_IS_USER;
  someone.ptstrName                = caller;
  allowed                          = FALSE;
  result = dacl->IsAccessAllowed( &someone, NULL, COM_RIGHTS_EXECUTE, &allowed );
  ASSERT( result, "IsAcessAllowed failed" );
  if (!allowed)
  {
    result = E_FAIL;
    ASSERT( result, "IsAccessAllowed denied me" );
  }

cleanup:
  return result;
}

/***************************************************************************/
STDMETHODIMP CTest::sick( ULONG val )
{
  ASSERT_THREAD();
  __try
  {
    RaiseException( val, 0, 0, NULL );
  }
  __except(EXCEPTION_EXECUTE_HANDLER)
  {
  }
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::sleep( ULONG time )
{
  ASSERT_THREAD();

  NestedCallCount += 1;
  printf( "Sleeping on thread %d for the %d time concurrently.\n",
          GetCurrentThreadId(), NestedCallCount );

  // For multithreaded mode, verify that this is not the main thread.
  if (get_apt_type() == COINIT_MULTITHREADED)
  {
    if (GetCurrentThreadId() == MainThread)
    {
      printf( "Sleep called on the main thread in multi threaded mode.\n" );
      NestedCallCount -= 1;
      return FALSE;
    }
  }

  // For single threaded mode, verify that this is the only call on the
  // main thread.
  else
  {
    if (GetCurrentThreadId() != MainThread)
    {
      printf( "Sleep called on the wrong thread in single threaded mode.\n" );
      NestedCallCount -= 1;
      return FALSE;
    }
    else if (NestedCallCount != 1)
    {
      printf( "Sleep nested call count is %d instead of not 1 in single threaded mode.\n",
              NestedCallCount );
      NestedCallCount -= 1;
      return FALSE;
    }
  }

  Sleep( time );
  NestedCallCount -= 1;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::swap_key( DWORD clen, BYTE *cblob, DWORD *slen,
                              BYTE **sblob )
{
#if  (_WIN32_WINNT >= 0x0500 )
  HRESULT     result      = S_OK;
  BOOL        success     = FALSE;

  // Get the default full provider.
  *sblob  = NULL;
  *slen   = 0;
  success = CryptAcquireContext( &CryptProvider, NULL, NULL, PROV_RSA_FULL, 0 );
  ASSERT_GLE( success, NTE_BAD_KEYSET, "Could not acqure full context." );

  // If there is no container, create one.
  if (!success)
  {
    success = CryptAcquireContext( &CryptProvider, NULL, NULL, PROV_RSA_FULL,
                                   CRYPT_NEWKEYSET );
    ASSERT_GLE( success, S_OK, "Could not acqure full context." );
  }
  success = FALSE;

  // Get the exchange public key.
  success = CryptGetUserKey( CryptProvider, AT_KEYEXCHANGE, &ExchangeKey );
  ASSERT_GLE( success, NTE_NO_KEY, "Could not open exchange key" );

  // Generate the exchange key if there wasn't one.
  if (!success)
  {
    success = CryptGenKey( CryptProvider, AT_KEYEXCHANGE, CRYPT_EXPORTABLE,
                           &ExchangeKey );
    ASSERT_GLE( success, S_OK, "Could not create exchange key" );
  }
  success = FALSE;

  // Compute the size of the public key.
  *slen = 0;
  success = CryptExportKey( ExchangeKey, NULL, PUBLICKEYBLOB, 0, NULL, slen );
  ASSERT_GLE( success, S_OK, "Could not size public key" );

  // Allocate memory to hold the public key.
  *sblob = (BYTE *) CoTaskMemAlloc( *slen );
  ASSERT_EXPR( *sblob != NULL, "Could not allocate memory." );

  // Export a public blob.
  success = CryptExportKey( ExchangeKey, NULL, PUBLICKEYBLOB, 0, *sblob, slen );
  ASSERT_GLE( success, S_OK, "Could not export public key" );

  success = TRUE;
cleanup:
  if (!success && result == S_OK)
    result = E_FAIL;
  return result;
#else
  return E_FAIL;
#endif
}

/***************************************************************************/
STDMETHODIMP CTest::test( ULONG gronk )
{
  IStream *stream = (IStream *) gronk;
  ITest   *server = NULL;
  HRESULT  result;

  // Unmarshal from the stream.
  result = CoGetInterfaceAndReleaseStream( stream, IID_ITest, (void **) &server );
  if (result != S_OK)
    return result;

  // Release the server.
  server->Release();
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::what( DWORD *what )
{
  ASSERT_THREAD();
  *what = state;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CTestCF::AddRef( THIS )
{
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CTestCF::CTestCF()
{
  ref_count = 1;
}

/***************************************************************************/
CTestCF::~CTestCF()
{
}

/***************************************************************************/
STDMETHODIMP CTestCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
  HRESULT result;

  *ppv = NULL;
  if (pUnkOuter != NULL)
  {
      printf( "Create instance failed, attempted agregation.\n" );
      return E_FAIL;
  }

  // Impersonate the caller and save the creator's name.
  result = CoImpersonateClient();
  if (SUCCEEDED(result))
  {
    get_token_name( &Creator, TRUE );
    CoRevertToSelf();
  }

  if (IsEqualIID( iidInterface, IID_ITest ) ||
      IsEqualIID( iidInterface, IID_IUnknown ))
  {
    CTest *Test = new FAR CTest();

    if (Test == NULL)
    {
        printf( "Create interface failed, no memory.\n" );
        return E_OUTOFMEMORY;
    }

    *ppv = Test;
    printf( "Created instance.\n" );
    return S_OK;
  }

  if (IsEqualIID( iidInterface, IID_IAdviseSink ))
  {
    CAdvise *Test = new FAR CAdvise();

    if (Test == NULL)
    {
        printf( "Create interface failed, no memory.\n" );
        return E_OUTOFMEMORY;
    }

    *ppv = Test;
    printf( "Created instance.\n" );
    return S_OK;
  }

  printf( "Create interface failed, wrong interface.\n" );
  return E_NOINTERFACE;
}

/***************************************************************************/
STDMETHODIMP CTestCF::LockServer(BOOL fLock)
{
    return E_FAIL;
}


/***************************************************************************/
STDMETHODIMP CTestCF::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_IClassFactory))
  {
    *ppvObj = (IUnknown *) this;
    AddRef();
    return S_OK;
  }

  *ppvObj = NULL;
  return E_NOINTERFACE;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CTestCF::Release( THIS )
{
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;
}

/***************************************************************************/
DWORD _stdcall apartment_base( void *param )
{
  new_apt_params *nap = (new_apt_params *) param;
  CTestCF        *factory;
  ULONG           size;
  HRESULT         result;
  HANDLE          memory;
  BOOL            success;
  SAptData        tls_data;

  // In the single threaded mode, stick a pointer to the object count
  // in TLS.
  if (nap->thread_mode == COINIT_APARTMENTTHREADED)
  {
    tls_data.object_count = 0;
    tls_data.what_next    = setup_wn;
    tls_data.exit_dirty   = FALSE;
    tls_data.sequence     = 0;
    tls_data.server       = NULL;
    TlsSetValue( TlsIndex, &tls_data );
  }

  // Initialize OLE.
  if (nap->thread_mode == COINIT_APARTMENTTHREADED)
    printf( "Initializing thread 0x%x in apartment threaded mode.\n", GetCurrentThreadId() );
  else
    printf( "Initializing thread 0x%x in multithreaded mode.\n", GetCurrentThreadId() );
  result = initialize(NULL,nap->thread_mode);
  if (SUCCEEDED(result))
  {

    // Create a class factory.
    factory = new CTestCF;

    if (factory != NULL)
    {
      // Find out how much memory to allocate.
      result = CoGetMarshalSizeMax( &size, IID_IClassFactory, factory, 0, NULL,
                                    MSHLFLAGS_NORMAL );

      if (SUCCEEDED(result))
      {
        // Allocate memory.
        memory = GlobalAlloc( GMEM_FIXED, size );

        if (memory != NULL)
        {
          // Create a stream.
          result = CreateStreamOnHGlobal( memory, TRUE, &nap->stream );
          if (FAILED(result))
          {
            nap->stream = NULL;
            GlobalFree( memory );
          }

          // Marshal the class factory.
          else
          {
            result = CoMarshalInterface( nap->stream, IID_IClassFactory,
                                         factory, 0, NULL, MSHLFLAGS_NORMAL );

            // Seek back to the start of the stream.
            if (SUCCEEDED(result))
            {
              LARGE_INTEGER    pos;
              LISet32(pos, 0);
              result = nap->stream->Seek( pos, STREAM_SEEK_SET, NULL );
            }

            if (FAILED(result))
            {
              nap->stream->Release();
              nap->stream = NULL;
            }
          }
        }
      }
    }
  }

  // Pass it back to the creator.
  success = nap->stream != NULL;
  SetEvent( nap->ready );

  // Loop till it is time to go away.
  if (success)
    server_loop();
  if (!dirty_thread())
  {
    printf( "Uninitializing thread 0x%x\n", GetCurrentThreadId() );
    CoUninitialize();
  }
  else
    printf( "Did not uninitialize thread 0x%x\n", GetCurrentThreadId() );
  TlsSetValue( TlsIndex, NULL );
  return 0;
}

/***************************************************************************/
void callback()
{
  HRESULT result;

  // Call the client back.
  Sleep(1);
  result = GlobalTest->callback();
  if (result != S_OK)
    printf( "Could not callback client: 0x%x\n", result );

  // Release the client.
  GlobalTest->Release();
  GlobalTest = NULL;
}

/***************************************************************************/
void check_for_request()
{
  MSG msg;

  if (get_apt_type() == COINIT_APARTMENTTHREADED)
  {
    if (PeekMessageA( &msg, NULL, 0, 0, PM_REMOVE ))
    {
      TranslateMessage (&msg);
      DispatchMessageA (&msg);
    }
  }
}

/***************************************************************************/
HRESULT check_token( WCHAR *name, IServerSecurity *context, DWORD imp_level )
{
  TOKEN_USER        *token_info       = NULL;
  DWORD              info_size        = 1024;
  HANDLE             token            = NULL;
  HRESULT            result           = E_FAIL;
  DWORD              lNameLen         = 1000;
  DWORD              lDomainLen       = 1000;
  DWORD              lIgnore;
  WCHAR              token_name[1000];
  WCHAR              domain[1000];
  WCHAR              full_name[1000];
  SID_NAME_USE       sIgnore;
  BOOL               success;
  DWORD              imp_level_out;

  success = OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &token );
  if (context != NULL)
  {
    ASSERT_GLE( success, S_OK, "Could not open thread token while impersonating" );
  }
  else
  {
    ASSERT_GLE( success, ERROR_NO_TOKEN, "Could not OpenThreadToken" );
    if (GetLastError() == ERROR_NO_TOKEN)
      return S_OK;
  }

  // Get memory for the token information.
  token_info = (TOKEN_USER *) malloc( info_size );
  ASSERT_EXPR( token_info != NULL, "Could not allocate memory." );

  // Get the token sid.
  success = GetTokenInformation( token, TokenUser, token_info, info_size, &info_size );
  ASSERT_GLE( success, S_OK, "Could not GetTokenInformation" );

  // Temporarily revert.
  if (context == DEFAULT_CONTEXT)
    CoRevertToSelf();
  else if (context != NULL)
    context->RevertToSelf();

  // Get the user name.
  success = LookupAccountSid( NULL, token_info->User.Sid, token_name,
                              &lNameLen, domain, &lDomainLen, &sIgnore );
  ASSERT_GLE( success, S_OK, "Could not LookupAccountSid" );

  // Reimpersonate.
  if (context != NULL)
  {
    if (context == DEFAULT_CONTEXT)
      result = CoImpersonateClient();
    else
      result = context->ImpersonateClient();
    ASSERT( result, "Could not reimpersonate" );
    result = E_FAIL;
  }

  // Stick the domain and user names together.
  wcscpy( full_name, domain );
  wcscat( full_name, L"\\" );
  wcscat( full_name, token_name );

  // Check the user name in the thread token.
  if (context != NULL)
  {
    if (_wcsicmp( full_name, name ) != 0)
    {
      printf( "Token contains <%ws> instead of <%ws>.\n", full_name, name );

      // See if the domain is supposed to be ntdev.
      if (_wcsicmp( domain, L"redmond" ) == 0)
      {
        wcscpy( full_name, L"ntdev\\" );
        wcscat( full_name, token_name );
        ASSERT_EXPR( _wcsicmp( full_name, name ) == 0, "Wrong name in token." );
        printf( "***** \010 NTDEV to REDMOND hack \010*****\n" );

      }
      else
        ASSERT_EXPR( FALSE, "Wrong name in token." );
    }
    else
      printf( "Check_token well impersonating <%ws>\n", full_name );
  }
  else
    ASSERT_EXPR( _wcsicmp( full_name, name ) == 0, "Wrong name in token." );

  // Get the token impersonation level.
  success = GetTokenInformation( token, TokenImpersonationLevel, &imp_level_out,
                                 sizeof(imp_level_out), &info_size );
  ASSERT_GLE( success, S_OK, "Could not GetTokenInformation for impersonation level" );

  // Convert from SECURITY_IMPERSONATION_LEVEL to RPC_C_IMP and
  // check the impersonation level.
  ASSERT_EXPR( imp_level == -1 || imp_level_out+1 == imp_level, "Bad impersonation level." );

  result = S_OK;
cleanup:
  if (token_info != NULL)
    free(token_info);
  if (token != NULL)
    CloseHandle( token );
  return result;
}

/***************************************************************************/
HRESULT create_instance( REFCLSID class_id, DWORD dest, ITest **instance,
                         SAptId *id )
{
  COSERVERINFO       server_machine;
  MULTI_QI           server_instance;
  char               machinea[MAX_NAME];
  HRESULT            result;

  // If the server is this process, create a new thread.
  *instance = NULL;
  if (dest == same_process_wd)
    result = new_apartment( instance, id, NULL, COINIT_APARTMENTTHREADED );

  // If the server is this machine, just call CoCreateInstance.
  else if (dest == same_machine_wd ||
           (dest == third_machine_wd && Name2[0] == 0))
    result = CoCreateInstance( class_id, NULL, CLSCTX_LOCAL_SERVER,
                               IID_ITest, (void **) instance );

  // Otherwise call CoCreateInstanceEx.
  else
  {
    if (dest == third_machine_wd)
      server_machine.pwszName       = Name2;
    else
      server_machine.pwszName       = Name;
    server_machine.dwReserved1    = 0;
    server_machine.pAuthInfo      = 0;
    server_machine.dwReserved2    = 0;
    server_instance.pIID          = &IID_ITest;
    server_instance.pItf          = NULL;
    server_instance.hr            = S_OK;
    result = CoCreateInstanceEx( class_id, NULL, CLSCTX_REMOTE_SERVER,
                                 &server_machine, 1, &server_instance );
    *instance = (ITest *) server_instance.pItf;
  }

  // Get the server's id.
  if (SUCCEEDED(result) && *instance != NULL && id != NULL)
    result = (*instance)->get_id( id );
  return result;
}

/***************************************************************************/
void crippled()
{
  HRESULT             result;
  SAptData           *mine   = get_apt_data();
  SAptId              id;
  RPC_BINDING_HANDLE  handle = NULL;
  RPC_STATUS          status;
  CTest               local;

  // Tell the apartment to quit.
  mine->what_next = quit_wn;

  // Try to make a call out.
  id.process  = 0;
  id.thread   = 0;
  id.sequence = 0;
  result = GlobalTest->check( id );
#if 0
  if (result != RPC_E_CRIPPLED)
  {
    printf( "Expected RPC_E_CRIPPLED making call: 0x%x\n", result );
    result = E_FAIL;
    goto cleanup;
  }
#endif

  // Try to reinitialize.
  CoUninitialize();
  result = initialize(NULL,get_apt_type());
  if (result != CO_E_INIT_RPC_CHANNEL)
  {
    printf( "Expected CO_E_INIT_RPC_CHANNEL reinitializing: 0x%x\n", result );
    result = E_FAIL;
    goto cleanup;
  }

  // Success.
  result = S_OK;
cleanup:

  // Make the server loop quit.
  mine->what_next = quit_wn;
  mine->object_count = 0;

  // Create a binding handle.
  status = RpcBindingFromStringBinding( GlobalBinding, &handle );
  if (status != RPC_S_OK)
  {
    printf( "Could not make binding handle form string binding: 0x%x\n" );
    return;
  }

  // Make a raw RPC call to report the results.
  set_status( handle, result, (unsigned long *) &status );
  if (status != RPC_S_OK)
  {
    printf( "Could not make RPC call: 0x%x\n", status );
    return;
  }
  local.set_state( dirty_s, THREAD_PRIORITY_NORMAL );
}

/***************************************************************************/
void decrement_object_count()
{
  SAptData *apt   = get_apt_data();
  DWORD     count = InterlockedDecrement( &apt->object_count );

  if (get_apt_type() == COINIT_MULTITHREADED)
  {
    if (count == 0)
      wake_up_and_smell_the_roses();
  }
}

/***************************************************************************/
BOOL dirty_thread()
{
  SAptData *apt = get_apt_data();
  return apt->exit_dirty;
}

/***************************************************************************/
void do_access()
{
  BOOL               success          = FALSE;
  ITest             *server           = NULL;
  SAptId             id_server;
  CTest              local;
  CAccessControl     access;
  HRESULT            result;
  DWORD              i;

  // Initialize OLE.
  hello( "access" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Initialize security incorrectly
  result = MCoInitializeSecurity( &access, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  ASSERT_EXPR( result != 0, "Could initialize security incorrectly" );

  // Initialize security
  result = MCoInitializeSecurity( &access, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_ACCESS_CONTROL, NULL );
  ASSERT( result, "Could not initialize security" );

  // Create a possibly remote object.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result, "Could not create server" );

  // Tell the remote object to call the local object.
  result = server->recurse( &local, 1 );
  ASSERT( result, "Could not callback" );

  // Reinitialize.
  server->Release();
  server = NULL;
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Change IAccessControl to deny access.
  result = access.deny_me();
  ASSERT( result, "Could not modify access" );

  // Initialize security
  result = MCoInitializeSecurity( (SECURITY_DESCRIPTOR *) &access, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_ACCESS_CONTROL, NULL );
  ASSERT( result, "Could not initialize security" );

  // Create a possibly remote object.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result, "Could not create server" );

  // Tell the remote object to call the local object.
  result = server->recurse( &local, 1 );
  ASSERT_EXPR( Win95 || result != S_OK, "Callback should have been denied." );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server != NULL)
    server->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nAccess Test Passed.\n" );
  else
    printf( "\n\nAccess Test Failed.\n" );
}

/***************************************************************************/
void do_access_control()
{
  BOOL               success          = FALSE;
  ITest             *server           = NULL;
  SAptId             id_server;
  HRESULT            result;
  DWORD              i;
  char               buffer[80];
  DWORD              len              = 80;
  IAccessControl    *access           = NULL;
  TRUSTEE_W          someone;
  IPersistStream    *persist          = NULL;
  ULARGE_INTEGER     size;
  HANDLE             memory;
  IStream           *stream           = NULL;
  SPermissionHeader  header;
  HKEY               key              = NULL;
  DWORD              ignore;
  SAccess            big;
  BOOL               allowed;
  SID                everyone         = {1, 1, {0, 0, 0, 0, 0, 5}, 0x12};
  ACTRL_ACCESSW     *list             = NULL;

  // Initialize OLE.
  hello( "access control" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Get the user name.
  ignore = sizeof(buffer);
  success = GetUserNameA( buffer, &ignore );
  ASSERT_EXPR( success, "Could not get user name." );
  printf( "You are <%s>\n", buffer );
  success = FALSE;

  // Create an IAccessControl.
  result = CoCreateInstance( CLSID_DCOMAccessControl, NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IAccessControl, (void **) &access );
  ASSERT( result, "Could not create DCOM access control." );

  // Query for IPersistStream
  result = access->QueryInterface( IID_IPersistStream, (void **) &persist );
  ASSERT( result, "Could not get IPersistStream" );

  // Test set with nothing.
  big.access.cEntries                        = 1;
  big.access.pPropertyAccessList             = &big.property;
  big.property.lpProperty                    = NULL;
  big.property.pAccessEntryList              = &big.list;
  big.property.fListFlags                    = 0;
  big.list.cEntries                          = 1;
  big.list.pAccessList                       = &big.entry;
  big.entry.fAccessFlags                     = ACTRL_ACCESS_ALLOWED;
  big.entry.Access                           = COM_RIGHTS_EXECUTE;
  big.entry.ProvSpecificAccess               = 0;
  big.entry.Inheritance                      = NO_INHERITANCE;
  big.entry.lpInheritProperty                = NULL;
  big.entry.Trustee.pMultipleTrustee         = NULL;
  big.entry.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
  big.entry.Trustee.TrusteeForm              = TRUSTEE_IS_NAME;
  big.entry.Trustee.TrusteeType              = TRUSTEE_IS_GROUP;
  big.entry.Trustee.ptstrName                = L"*";
  big.list.cEntries                          = 0;
  result = access->SetAccessRights( &big.access );
  ASSERT( result, "Could not set access" );
  big.list.cEntries                          = 1;

  // Test Grant
  result = access->GrantAccessRights( &big.access );
  ASSERT( result, "Could not grant access" );

  // Test grant of a sid.
  if (!Win95)
  {
    big.entry.Trustee.TrusteeForm              = TRUSTEE_IS_SID;
    big.entry.Trustee.TrusteeType              = TRUSTEE_IS_USER;
    big.entry.Trustee.ptstrName                = (WCHAR *) &everyone;
    result = access->GrantAccessRights( &big.access );
    ASSERT( result, "Could not grant access" );
  }

  // Test Deny
  big.entry.fAccessFlags                     = ACTRL_ACCESS_DENIED;
  big.entry.Trustee.TrusteeForm              = TRUSTEE_IS_NAME;
  big.entry.Trustee.TrusteeType              = TRUSTEE_IS_USER;
  big.entry.Trustee.ptstrName                = L"redmond\\shannonc";
  result = access->GrantAccessRights( &big.access );
  ASSERT( result, "Could not deny access" );

  // Test bad Grant
  big.entry.fAccessFlags                     = ACTRL_ACCESS_ALLOWED;
  big.entry.Trustee.ptstrName                = L"foo\\bar";
  result = access->GrantAccessRights( &big.access );
  ASSERT_EXPR( Win95 || result != S_OK, "Bad grant succeeded." );
/*
  // Test Grant interactive
  big.entry.Trustee.TrusteeType              = TRUSTEE_IS_GROUP;
  big.entry.Trustee.ptstrName                = L"nt authority\\interactive";
  result = access->GrantAccessRights( &big.access );
  ASSERT( result, "Could not grant access to interactive" );
*/
  // Test Grant system
  big.entry.Trustee.TrusteeType              = TRUSTEE_IS_USER;
  big.entry.Trustee.ptstrName                = L"nt authority\\system";
  result = access->GrantAccessRights( &big.access );
  ASSERT( result, "Could not grant access to system" );

  // Test bad IsAccessPermitted.
  someone.pMultipleTrustee         = NULL;
  someone.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
  someone.TrusteeForm              = TRUSTEE_IS_NAME;
  someone.TrusteeType              = TRUSTEE_IS_USER;
  someone.ptstrName                = L"redmond\\alexmit";
  allowed                          = TRUE;
  result = access->IsAccessAllowed( &someone, NULL, COM_RIGHTS_EXECUTE, &allowed );
  ASSERT_EXPR( result != S_OK && allowed != TRUE,
               "Bad IsAccessPermitted succeeded." );

  // Get the access rights.
  result = access->GetAllAccessRights( NULL, &list, NULL, NULL );
  ASSERT( result, "Could not get rights" );
  ASSERT_EXPR( list != NULL                                                 &&
               list->cEntries == 1                                          &&
               list->pPropertyAccessList != NULL                            &&
               list->pPropertyAccessList->pAccessEntryList != NULL          &&
               (list->pPropertyAccessList->pAccessEntryList->cEntries == 4 ||
                list->pPropertyAccessList->pAccessEntryList->cEntries == 4) &&
               list->pPropertyAccessList->pAccessEntryList->pAccessList != NULL,
               "Bad access list" );
  CoTaskMemFree( list );
  list = NULL;

  // Create a possibly remote object.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result, "Could not create server" );

  // Ask it for an access list.
  result = server->list_out( &list );
  ASSERT( result, "Could get access list from server" );
  server->Release();
  server = NULL;

  // Test Set.
  big.entry.Trustee.TrusteeForm              = TRUSTEE_IS_NAME;
  big.entry.Trustee.TrusteeType              = TRUSTEE_IS_GROUP;
  big.entry.Trustee.ptstrName                = L"*";
  result = access->SetAccessRights( &big.access );
  ASSERT( result, "Could not set access" );

  // Find out how big the ACL is.
  result = persist->GetSizeMax( &size );
  ASSERT( result, "Could not get size" );
  size.QuadPart += sizeof(SPermissionHeader);

  // Create a stream on memory.  Don't free the memory.  Releasing the
  // stream frees it.
  memory = GlobalAlloc( GMEM_FIXED, size.LowPart );
  ASSERT_EXPR( memory != NULL, "Could not get memory." );
  result = CreateStreamOnHGlobal( memory, TRUE, &stream );
  ASSERT( result, "Could not create stream" );

  // Write the header.
  header.version = 2;
  header.classid = CLSID_DCOMAccessControl;
  result = stream->Write( &header, sizeof(header), NULL );
  ASSERT( result, "Could not write header to stream" );

  // Write the ACL to memory.
  result = persist->Save( stream, TRUE );
  ASSERT( result, "Could not save" );

  // Open the app id key.
  result = RegCreateKeyExA( HKEY_CLASSES_ROOT,
             "AppID\\{60000300-76d7-11cf-9af1-0020af6e72f4}",
             NULL,
             NULL,
             REG_OPTION_NON_VOLATILE,
             KEY_READ | KEY_WRITE,
             NULL,
             &key,
             &ignore );
  ASSERT( result, "Could not create app id key" );

  // Write the ACL to the registry.
  result = RegSetValueExA(
             key,
             "AccessPermission",
             NULL,
             REG_BINARY,
             (UCHAR *) memory,
             size.LowPart );
  ASSERT( result, "Could not set access permissions" );

  // Activate a legacy server locally.
  result = CoCreateInstance( ClassIds[apt_legacy], NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &server );

  // Delete the access permission value.
  result = RegDeleteValueA( key, "AccessPermission" );
  ASSERT( result, "Could not delete access permission value" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server != NULL)
    server->Release();
  if (access != NULL)
    access->Release();
  if (persist != NULL)
    persist->Release();
  if (stream != NULL)
    stream->Release();
  if (key != NULL)
    RegCloseKey( key );
  if (list != NULL)
    CoTaskMemFree( list );
  CoUninitialize();

  if (success)
    printf( "\n\nAccess Control Test Passed.\n" );
  else
    printf( "\n\nAccess Control Test Failed.\n" );
}

/***************************************************************************/
void do_anti_delegation()
{
  BOOL               success          = FALSE;
  ITest             *server           = NULL;
  ITest             *server2          = NULL;
  ITest             *server3          = NULL;
  ITest             *server4          = NULL;
  ITest             *server5          = NULL;
  ITest             *local            = NULL;
  SAptId             id_server;
  SAptId             id_server2;
  SAptId             id_server3;
  SAptId             id_server4;
  SAptId             id_server5;
  SAptId             id_null          = { 0, 0, 0 };
  HRESULT            result;
  IStream           *stream           = NULL;
  HANDLE             process          = NULL;
  HANDLE             process2         = NULL;
  HANDLE             oleuser          = NULL;
  HANDLE             oleadmin         = NULL;
  DWORD              ignore;
  DWORD              cls              = Change ? opposite_wc : any_wc;

  DWORD    authn_level_out;
  DWORD    imp_level_out;
  DWORD    authn_svc_out;
  DWORD    authz_svc_out;
  OLECHAR *princ_name_out = NULL;

  // Initialize OLE.
  hello( "anti_delegation" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );
  result = initialize_security();
  ASSERT( result, "Could not initialize security" );

  // Create a client.
  result = create_instance( get_class(cls), WhatDest, &server, NULL );
  ASSERT( result,  "Could not create instance of test server" );

  // Create a client.
  result = create_instance( get_class(cls), WhatDest, &server2, NULL );
  ASSERT( result,  "Could not create instance of test server" );

  // Create a client.
  result = create_instance( get_class(cls), WhatDest, &server3, NULL );
  ASSERT( result,  "Could not create instance of test server" );

  // Create a client.
  result = create_instance( get_class(cls), WhatDest, &server4, NULL );
  ASSERT( result,  "Could not create instance of test server" );

  // Create a client.
  result = create_instance( get_class(cls), WhatDest, &server5, NULL );
  ASSERT( result,  "Could not create instance of test server" );

  // Create a test object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not create object" );

  // Get the process token
  success = OpenProcessToken( GetCurrentProcess(), TOKEN_DUPLICATE, &process );
  ASSERT_GLE( success, S_OK, "Could not open process token" );
  success = FALSE;
  success = DuplicateToken( process, SecurityImpersonation, &process2 );
  ASSERT_GLE( success, S_OK, "Could not duplicate process token" );
  success = FALSE;

  // Logon oleuser
  success = LogonUser( L"oleuser", L"redmond", OleUserPassword, LOGON32_LOGON_BATCH,
                       LOGON32_PROVIDER_DEFAULT, &oleuser );
  ASSERT_GLE( success, S_OK, "Could not log on oleuser" );
  success = FALSE;

  // Logon oleadmin
  success = LogonUser( L"oleadmin", L"redmond", OleUserPassword, LOGON32_LOGON_BATCH,
                       LOGON32_PROVIDER_DEFAULT, &oleadmin );
  ASSERT_GLE( success, S_OK, "Could not log on oleadmin" );
  success = FALSE;

  // Make a call.
  result = server->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser,
                           &ignore );
  ASSERT( result, "Did not ignore oleuser token" );

  // Set the oleuser token.
  success = ImpersonateLoggedOnUser( oleuser );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser" );
  success = FALSE;

  // Make a call.
  result = server2->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE, NULL, DomainUser,
                            &ignore );
  ASSERT( result, "Did not ignore oleuser token" );

  // Make a call.
  result = server2->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE, NULL, DomainUser,
                            &ignore );
  ASSERT( result, "Did not ignore oleuser token" );

  // Set the security.
  result = MCoSetProxyBlanket( server3, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server3->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE, NULL, DomainUser,
                            &ignore );
  ASSERT( result, "Did not ignore oleuser token" );

  // Set the process token.
  success = SetThreadToken( NULL, NULL );
  ASSERT_GLE( success, S_OK, "Could not remove thread token" );
  success = FALSE;

  // Set blanket
  result = MCoSetProxyBlanket( server4, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server4->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE, NULL, DomainUser,
                            &ignore );
  ASSERT( result, "Did not use process token" );

  // Set blanket
  result = MCoSetProxyBlanket( server5, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Set the oleuser token.
  success = ImpersonateLoggedOnUser( oleuser );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser" );
  success = FALSE;

  // Make a call.
  result = server5->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE, NULL, DomainUser,
                            &ignore );
  ASSERT( result, "Did not ignore oleuser token: 0x%x\n" );

  // Make a recursive call
  result = server->recurse_secure( local, 6, 3, DomainUser );
  ASSERT( result, "Could not make recursive call with impersonation." );

  // Make a call.
  result = server->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser,
                           &ignore );
  ASSERT( result, "Did not ignore oleuser token" );

  // Set the security.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser,
                           &ignore );
  ASSERT( result, "Did not ignore oleuser token" );

  // Set the process token.
  success = SetThreadToken( NULL, process2 );
  ASSERT_GLE( success, S_OK, "Could not impersonate process" );
  success = FALSE;

  // Make a call.
  result = server->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser,
                           &ignore );
  ASSERT( result, "Did not ignore process token" );

  // Set the security.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser,
                           &ignore );
  ASSERT( result, "Did not ignore process token" );

  // Set the oleadmin token.
  success = ImpersonateLoggedOnUser( oleadmin );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleadmin" );
  success = FALSE;

  // Make a call.
  result = server->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser,
                           &ignore );
  ASSERT( result, "Did not ignore oleadmin token" );

  // Set the security.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser,
                           &ignore );
  ASSERT( result, "Did not ignore oleadmin token" );

  // Make a recursive call
  result = server->recurse_secure( local, 6, 3, DomainUser );
  ASSERT( result, "Could not make recursive call with impersonation." );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server != NULL)
    server->Release();
  if (server2 != NULL)
    server2->Release();
  if (server3 != NULL)
    server3->Release();
  if (server4 != NULL)
    server4->Release();
  if (server5 != NULL)
    server5->Release();
  if (stream != NULL)
    stream->Release();
  if (local != NULL)
    local->Release();
  if (process != NULL)
    CloseHandle( process );
  if (process2 != NULL)
    CloseHandle( process2 );
  if (oleadmin != NULL)
    CloseHandle( oleadmin );
  if (oleuser != NULL)
    CloseHandle( oleuser );

  if (success)
    printf( "\n\nAnti Delegation Test Passed.\n" );
  else
    printf( "\n\nAnti Delegation Failed.\n" );
}

/***************************************************************************/
void do_appid()
{
  BOOL               success          = FALSE;
  HRESULT            result;
  UUID               uuid;
  HKEY               key              = NULL;
  DWORD              authn            = RPC_C_AUTHN_LEVEL_NONE;
  ITest             *server           = NULL;
  SAptId             id;
  DWORD              ignore;
  IAccessControl    *access           = NULL;
  IPersistStream    *persist          = NULL;
  ULARGE_INTEGER     size;
  HANDLE             memory           = NULL;
  IStream           *stream           = NULL;
  SPermissionHeader  header;
  void              *data             = NULL;
  SAccess            big;

  // Initialize OLE.
  hello( "appid" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create an IAccessControl.
  result = CoCreateInstance( CLSID_DCOMAccessControl, NULL,
                             CLSCTX_INPROC_SERVER,
                             IID_IAccessControl, (void **) &access );
  ASSERT( result, "Could not create DCOM access control." );

  // Query for IPersistStream
  result = access->QueryInterface( IID_IPersistStream, (void **) &persist );
  ASSERT( result, "Could not get IPersistStream" );

  // Give everyone access.
  big.access.cEntries                        = 1;
  big.access.pPropertyAccessList             = &big.property;
  big.property.lpProperty                    = NULL;
  big.property.pAccessEntryList              = &big.list;
  big.property.fListFlags                    = 0;
  big.list.cEntries                          = 1;
  big.list.pAccessList                       = &big.entry;
  big.entry.fAccessFlags                     = ACTRL_ACCESS_ALLOWED;
  big.entry.Access                           = COM_RIGHTS_EXECUTE;
  big.entry.ProvSpecificAccess               = 0;
  big.entry.Inheritance                      = NO_INHERITANCE;
  big.entry.lpInheritProperty                = NULL;
  big.entry.Trustee.pMultipleTrustee         = NULL;
  big.entry.Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
  big.entry.Trustee.TrusteeForm              = TRUSTEE_IS_NAME;
  big.entry.Trustee.TrusteeType              = TRUSTEE_IS_GROUP;
  big.entry.Trustee.ptstrName                = L"*";
  big.list.cEntries                          = 1;
  result = access->SetAccessRights( &big.access );
  ASSERT( result, "Could not set access" );

  // Find out how big the ACL is.
  result = persist->GetSizeMax( &size );
  ASSERT( result, "Could not get size" );
  size.QuadPart += sizeof(SPermissionHeader);

  // Create a stream on memory.
  memory = GlobalAlloc( GMEM_FIXED, size.LowPart );
  ASSERT_EXPR( memory != NULL, "Could not get memory." );
  result = CreateStreamOnHGlobal( memory, FALSE, &stream );
  ASSERT( result, "Could not create stream" );

  // Write the header.
  header.version = 2;
  header.classid = CLSID_DCOMAccessControl;
  result = stream->Write( &header, sizeof(header), NULL );
  ASSERT( result, "Could not write header to stream" );

  // Write the ACL to memory.
  result = persist->Save( stream, TRUE );
  ASSERT( result, "Could not save" );

  // Free these classes.
  access->Release();
  persist->Release();
  stream->Release();
  access  = NULL;
  persist = NULL;
  stream  = NULL;

  // Get the address of the access control data.
  data = GlobalLock( memory );
  ASSERT_EXPR( data != NULL, "Could not lock HGLOBAL.\n" );

  // Create a UUID.
  result = UuidCreate( &uuid );
  ASSERT( result, "Could not create UUID" );

  // Initialize security with a bad app id.
  result = MCoInitializeSecurity( &uuid, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_APPID, NULL );
  ASSERT( result, "CoInitializeSecurity failed with bad appid" );

  // Uninitialize.
  CoUninitialize();

  // Reinitialize.
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Open the app id key.
  result = RegCreateKeyExA( HKEY_CLASSES_ROOT,
             "AppID\\{60000300-76d7-11cf-9af1-0020af6e72f4}",
             NULL,
             NULL,
             REG_OPTION_NON_VOLATILE,
             KEY_READ | KEY_WRITE,
             NULL,
             &key,
             &ignore );
  ASSERT( result, "Could not create app id key" );

  // Delete the access permission.
  RegDeleteValueA( key, "AccessPermission" );

  // Delete the authentication level.
  RegDeleteValueA( key, "AuthenticationLevel" );

  // Initialize security.
  result = MCoInitializeSecurity( &APPID_App, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_APPID, NULL );
  ASSERT( result, "Could not CoInitializeSecurity with app id" );

  // Reinitialize.
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Write the authentication level.
  authn = RPC_C_AUTHN_LEVEL_CONNECT;
  result = RegSetValueExA(
             key,
             "AuthenticationLevel",
             NULL,
             REG_DWORD,
             (UCHAR *) &authn,
             sizeof(authn) );
  ASSERT( result, "Could not set authentication level" );

  // Initialize security.
  result = MCoInitializeSecurity( &APPID_App, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_APPID, NULL );
  ASSERT( result, "Could not CoInitializeSecurity with app id" );

  // Reinitialize.
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Write the access permissions.
  result = RegSetValueExA(
             key,
             "AccessPermission",
             NULL,
             REG_BINARY,
             (UCHAR *) data,
             size.LowPart );
  ASSERT( result, "Could not set access permissions" );

  // Initialize security.
  result = MCoInitializeSecurity( &APPID_App, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_APPID, NULL );
  ASSERT( result, "Could not CoInitializeSecurity with app id" );

  // Reinitialize.
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Delete the authentication level.
  RegDeleteValueA( key, "AuthenticationLevel" );

  // Initialize security.
  result = MCoInitializeSecurity( &APPID_App, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_APPID, NULL );
  ASSERT( result, "Could not CoInitializeSecurity with app id" );

  // Reinitialize.
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Restore the access permission.
  result = setup_access( key );
  ASSERT( result, "Could not restore access permission" );

  // Set the authentication level to encrypt.
  authn = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
  result = RegSetValueExA(
             key,
             "AuthenticationLevel",
             NULL,
             REG_DWORD,
             (UCHAR *) &authn,
             sizeof(authn) );
  ASSERT( result, "Could not set authentication level" );

  result = MCoInitializeSecurity( &APPID_App, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_APPID, NULL );
  ASSERT( result, "Could not CoInitializeSecurity with app id" );

  // Create a server.
  result = create_instance( ClassIds[apt_auto_none], WhatDest, &server, &id );
  ASSERT( result, "Could not create server" );

  // Query the security blanket.
  result = MCoQueryProxyBlanket( server, NULL, NULL, NULL, &authn,
                                 NULL, NULL, NULL );
  ASSERT( result, "Could not query blanket" );

  // Verify the authentication level.
  ASSERT_EXPR( authn == RPC_C_AUTHN_LEVEL_PKT_PRIVACY, "Wrong authentication level." );

  // Release the server.
  server->Release();
  server = NULL;

  // Reinitialize.
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Set the authentication level to none.
  authn = RPC_C_AUTHN_LEVEL_NONE;
  result = RegSetValueExA(
             key,
             "AuthenticationLevel",
             NULL,
             REG_DWORD,
             (UCHAR *) &authn,
             sizeof(authn) );
  ASSERT( result, "Could not set authentication level" );

  // Initialize security with our app id.
  result = MCoInitializeSecurity( &APPID_App, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_APPID, NULL );
  ASSERT( result, "Could not CoInitializeSecurity with app id" );

  // Create a server.
  result = create_instance( ClassIds[apt_auto_none], WhatDest, &server, &id );
  ASSERT( result, "Could not create server" );

  // Query the security blanket.
  result = MCoQueryProxyBlanket( server, NULL, NULL, NULL, &authn,
                                 NULL, NULL, NULL );
  ASSERT_EXPR( result == S_OK || result == 0x800706d2, "Could not query blanket" );
  if (result == 0x800706d2)
      authn = RPC_C_AUTHN_LEVEL_NONE;

  // Verify the authentication level.
  ASSERT_EXPR( authn == RPC_C_AUTHN_LEVEL_NONE, "Wrong authentication level." );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (access != NULL)
    access->Release();
  if (persist != NULL)
    persist->Release();
  if (stream != NULL)
    stream->Release();
  if (data != NULL)
    GlobalUnlock( memory );
  if (memory != NULL)
    GlobalFree( memory );
  if (server != NULL)
    server->Release();
  CoUninitialize();
  if (key != NULL)
  {
    RegDeleteValueA( key, "AuthenticationLevel" );
    RegCloseKey( key );
  }

  if (success)
    printf( "\n\nAppid Test Passed.\n" );
  else
    printf( "\n\nAppid Test Failed.\n" );
}

/***************************************************************************/
#if  (_WIN32_WINNT >= 0x0500 )
void do_async()
{
  BOOL               success          = FALSE;
  ITest             *server           = NULL;
  IAsync            *async            = NULL;
  SAptId             id;
  HRESULT            result;
  HANDLE             oleuser1         = NULL;

  // Initialize OLE.
  hello( "async" );
  ASSERT( E_FAIL, "This test is out of date" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a possibly remote object.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id );
  ASSERT( result, "Could not create server" );

  // Get the async interface.
  result = server->QueryInterface( IID_IAsync, (void **) &async );
  ASSERT( result, "Could not get async interface" );

  // Enable cloaking.
  result = MCoSetProxyBlanket( async, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_DYNAMIC_CLOAKING );
  ASSERT( result, "Could not set blanket" );

  // Get a token for redmond\oleuser1.
  success = LogonUser( L"oleuser1", L"redmond", OleUserPassword, LOGON32_LOGON_BATCH,
                       LOGON32_PROVIDER_DEFAULT, &oleuser1 );
  ASSERT_GLE( success, S_OK, "Could not log on oleuser1" );
  success = FALSE;

  // Test basic async impersonation.
  result = async->secure( id, basic_as, DomainUser );
  ASSERT( result, "Could not make basic secure async call" );

  // Impersonate oleuser1.
  success = ImpersonateLoggedOnUser( oleuser1 );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser1" );
  success = FALSE;

  // Test basic async impersonation while cloaking.
  result = async->secure( id, basic_as, L"redmond\\oleuser1" );
  ASSERT( result, "Could not make basic secure async call while cloaking" );

  // Remove the thread token.
  success = SetThreadToken( NULL, NULL );
  ASSERT_GLE( success, S_OK, "Could not remove thread token" );
  success = FALSE;

  // Test embedding async impersonation.
  result = async->secure( id, embedded_as, DomainUser );
  ASSERT( result, "Could not make embedding secure async call" );

  // Impersonate oleuser1.
  success = ImpersonateLoggedOnUser( oleuser1 );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser1" );
  success = FALSE;

  // Test embedded async impersonation while cloaking.
  result = async->secure( id, embedded_as, L"redmond\\oleuser1" );
  ASSERT( result, "Could not make embedded secure async call while cloaking" );

  // Remove the thread token.
  success = SetThreadToken( NULL, NULL );
  ASSERT_GLE( success, S_OK, "Could not remove thread token" );
  success = FALSE;

  // Tell the server to preimpersonate.
  result = async->preimpersonate( TRUE );
  ASSERT( result, "Could not preimpersonate" );

  // Test embedded async impersonation with preimpersonation.
  result = async->secure( id, embedded_as, DomainUser );
  ASSERT( result, "Could not make embedded secure async call with preimpersonation" );

  // Impersonate oleuser1.
  success = ImpersonateLoggedOnUser( oleuser1 );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser1" );
  success = FALSE;

  // Test embedded async impersonation while cloaking with preimpersonation.
  result = async->secure( id, embedded_as, L"redmond\\oleuser1" );
  ASSERT( result, "Could not make embedded secure async call while cloaking with preimpersonation" );

  // Remove the thread token.
  success = SetThreadToken( NULL, NULL );
  ASSERT_GLE( success, S_OK, "Could not remove thread token" );
  success = FALSE;

  // Tell the server to stop preimpersonating.
  result = async->preimpersonate( FALSE );
  ASSERT( result, "Could not stop preimpersonating" );

  // Test race async impersonation.
  result = async->secure( id, race_as, DomainUser );
  ASSERT( result, "Could not make race secure async call" );

  // Impersonate oleuser1.
  success = ImpersonateLoggedOnUser( oleuser1 );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser1" );
  success = FALSE;

  // Test race async impersonation while cloaking
  result = async->secure( id, race_as, L"redmond\\oleuser1" );
  ASSERT( result, "Could not make race secure async call while cloaking" );

  // Remove the thread token.
  success = SetThreadToken( NULL, NULL );
  ASSERT_GLE( success, S_OK, "Could not remove thread token" );
  success = FALSE;

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server != NULL)
    server->Release();
  if (async != NULL)
    async->Release();
  if (oleuser1 != NULL)
    CloseHandle( oleuser1 );
  CoUninitialize();

  if (success)
    printf( "\n\nAsync Test Passed.\n" );
  else
    printf( "\n\nAsync Test Failed.\n" );
}
#endif

/***************************************************************************/
void do_cancel()
{
  BOOL      success = FALSE;
  ITest    *obj1    = NULL;
  ITest    *obj2    = NULL;
  SAptId    id1;
  SAptId    id2;
  HRESULT   result;

  // Initialize OLE.
  hello( "cancel" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &obj1 );
  ASSERT( result,  "Could not create instance of test server" );
  result = obj1->get_id( &id1 );
  ASSERT( result, "Could not get client id" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &obj2 );
  ASSERT( result,  "Could not create instance of test server" );
  result = obj2->get_id( &id2 );
  ASSERT( result, "Could not get client id" );

  // Run test between two remote objects.
  success = do_cancel_helper( obj1, id1, obj2, id2 );
  obj1 = NULL;
  obj2 = NULL;
  if (!success)
    goto cleanup;
  success = FALSE;

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &obj1 );
  ASSERT( result,  "Could not create instance of test server" );
  result = obj1->get_id( &id1 );
  ASSERT( result, "Could not get client id" );

  // Create in process server.
  result = obj1->get_obj_from_new_apt( &obj2, &id2 );
  ASSERT( result, "Could not get in process server" );

  // Run test between two local objects.
  success = do_cancel_helper( obj1, id1, obj2, id2 );
  obj1 = NULL;
  obj2 = NULL;
  if (!success)
    goto cleanup;

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (obj1 != NULL)
    obj1->Release();
  if (obj2 != NULL)
    obj2->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nCancel Test Passed.\n" );
  else
    printf( "\n\nCancel Test Failed.\n" );
}

/***************************************************************************/
BOOL do_cancel_helper( ITest *obj1, SAptId id1, ITest *obj2, SAptId id2 )
{
  BOOL     success = FALSE;
  HRESULT  result;
  ITest   *helper1 = NULL;
  ITest   *helper2 = NULL;
  SAptId   hid1;
  SAptId   hid2;

  // Create first helper.
  result = obj1->get_obj_from_new_apt( &helper1, &hid1 );
  ASSERT( result, "Could not get in process server" );

  // Create second helper.
  result = obj2->get_obj_from_new_apt( &helper2, &hid2 );
  ASSERT( result, "Could not get in process server" );

  // Register first message filter.
  result = obj1->register_message_filter( TRUE );
  ASSERT( result, "Could not register message filter." );

  // Register second message filter.
  result = obj2->register_message_filter( TRUE );
  ASSERT( result, "Could not register message filter." );

  // Tell everybody who their neighbor is.
  result = obj1->remember( helper2, hid2 );
  ASSERT( result, "Could not remember object" );
  result = helper2->remember( obj2, id2 );
  ASSERT( result, "Could not remember object" );
  result = obj2->remember( helper1, hid1 );
  ASSERT( result, "Could not remember object" );
  result = helper1->remember( obj1, id1 );
  ASSERT( result, "Could not remember object" );

  // Cancel one call.
  result = obj1->call_canceled( 1, 1, obj2 );
  ASSERT( result, "Cancel test failed" );

  // Cancel after recursing.
  result = obj1->call_canceled( 5, 1, obj2 );
  ASSERT( result, "Cancel after recusing failed" );

  // Make a recursive call and cancel several times.
  result = obj1->call_canceled( 5, 3, obj2 );
  ASSERT( result, "Multiple cancel test failed" );

  // Tell everybody to forget their neighbor.
  result = obj1->forget();
  ASSERT( result, "Could not forget neighbor" );
  result = obj2->forget();
  ASSERT( result, "Could not forget neighbor" );
  result = helper1->forget();
  ASSERT( result, "Could not forget neighbor" );
  result = helper2->forget();
  ASSERT( result, "Could not forget neighbor" );

  // Release first message filter.
  result = obj1->register_message_filter( FALSE );
  ASSERT( result, "Could not deregister message filter." );

  // Release second message filter.
  result = obj2->register_message_filter( FALSE );
  ASSERT( result, "Could not deregister message filter." );

  success = TRUE;
cleanup:
  if (helper1 != NULL)
    helper1->Release();
  if (helper2 != NULL)
    helper2->Release();
  if (obj2 != NULL)
    obj2->Release();
  if (obj1 != NULL)
    obj1->Release();
  return success;
}

/***************************************************************************/
void do_cert()
{
#if  (_WIN32_WINNT >= 0x0500 )
  BOOL              success     = FALSE;
  HRESULT           result;
  HCRYPTPROV        prov        = 0;
  DWORD             len;
  HCERTSTORE        cert_store  = NULL;
  HCERTSTORE        root_store  = NULL;
  PCCERT_CONTEXT    prev_cert   = NULL;
  PCCERT_CONTEXT    cert        = NULL;
  PCCERT_CONTEXT    parent      = NULL;
  PCCERT_CONTEXT    last        = NULL;
  CERT_NAME_BLOB   *subject;
  CERT_NAME_BLOB   *issuer;
  WCHAR            *name        = NULL;
  DWORD             ignore;
  UCHAR            *buffer      = NULL;
  BOOL              top;
  WCHAR            *principal   = NULL;
  DWORD             i;
  DWORD             j;
  HCRYPTPROV        cert_prov   = NULL;
  HCRYPTKEY         cert_key    = NULL;
  DWORD             size;
  UCHAR            *key_buffer  = NULL;
  CERT_KEY_CONTEXT  key_context;

  // Only run on NT 5.
  if (!NT5)
  {
    printf( "Cert test can only run on NT 5.\n" );
    return;
  }

  // Initialize OLE.
  hello( "cert" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );
  result = initialize_security();
  ASSERT( result, "Could not initialize security" );

  // Get the default full provider.
  success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL, 0 );
  ASSERT_GLE( success, NTE_BAD_KEYSET, "Could not acqure full context." );

  // If there is no container, create one.
  if (!success)
  {
    success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET );
    ASSERT_GLE( success, S_OK, "Could not acqure full context." );
  }
  success = FALSE;
/*
  // Call CertOpenSystemStore to open the store.
  cert_store = CertOpenSystemStore(prov, UserName );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting System Store Handle" );
*/
/*
    CERT_SYSTEM_STORE_CURRENT_USER       1
    CERT_SYSTEM_STORE_LOCAL_MACHINE      2
    CERT_SYSTEM_STORE_CURRENT_SERVICE    4
    CERT_SYSTEM_STORE_SERVICES           5
    CERT_SYSTEM_STORE_USERS              6
*/
  // Open the store with the new API.
  cert_store = CertOpenStore( CERT_STORE_PROV_SYSTEM, 0, NULL,
                              CERT_STORE_OPEN_EXISTING_FLAG |
                                 (NumElements << CERT_SYSTEM_STORE_LOCATION_SHIFT),
                              UserName );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting System Store Handle" );

  // Call CertOpenSystemStore to open the root store.
  root_store = CertOpenSystemStore(prov, L"root" );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting root Store Handle" );
  prov = 0;

  // Loop over all certificates in the store.
  do
  {
    // Ask for another certificate.
    cert      = CertEnumCertificatesInStore( cert_store, prev_cert );
    prev_cert = NULL;

    // If there was one, print the name.
    if (cert != NULL)
    {
      // Print the standard principal name for the certificate.
      result = RpcCertGeneratePrincipalName( cert, 0, &principal );
      if (result != 0)
        printf( "Could not generate standard principal name: 0x%x\n", result );
      else
        printf( "Standard: <%ws>\n", principal );

      // Free the string.
      result = RpcStringFree( &principal );
      ASSERT( result, "Could not free principal" );

      // Print the fullsic principal name for the certificate.
      result = RpcCertGeneratePrincipalName( cert, RPC_C_FULL_CERT_CHAIN, &principal );
      if (result != 0)
        printf( "Could not generate fullsic principal name: 0x%x\n", result );
      else
        printf( "Fullsic: <%ws>\n", principal );

      // Free the string.
      result = RpcStringFree( &principal );
      ASSERT( result, "Could not free principal" );

      // Print the issuer chain.
      subject   = &cert->pCertInfo->Subject;
      issuer    = &cert->pCertInfo->Issuer;
      parent    = NULL;
      last      = NULL;
      top       = FALSE;
      prev_cert = cert;
      while (!top)
      {
        // Get the name length.
        len = 0;
        len = CertNameToStr( (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING), subject,
                              CERT_X500_NAME_STR, NULL, len );
        ASSERT_EXPR( len > 0, "Couldn't get cert name." );

        // Allocate memory for the issuer string.
        name = (WCHAR *) CoTaskMemAlloc( len*sizeof(WCHAR) );
        ASSERT_EXPR( name != NULL, "Could not allocate string." );

        // Get the name.
        len = CertNameToStr( (PKCS_7_ASN_ENCODING | X509_ASN_ENCODING), subject,
                             CERT_X500_NAME_STR, name, len );
        ASSERT_EXPR( len > 0, "Couldn't get cert name." );

        // Print the name.
        printf( "%ws\n", name );
        CoTaskMemFree( name );
        name = NULL;

        // Get the size of the serialized certificate.
        len = 0;
        CertSerializeCertificateStoreElement( prev_cert, 0, NULL, &len );
        ASSERT_GLE( len != 0, S_OK, "Could not get length of serialized certificate" );

        // Allocate memory.
        buffer = (UCHAR *) CoTaskMemAlloc( len );
        ASSERT_EXPR( buffer != NULL, "Could not allocate memory." );

        // Serialize it.
        success = CertSerializeCertificateStoreElement( prev_cert, 0, buffer,
                                                        &len );
        ASSERT_GLE( success, S_OK, "Could not serialize certificate" );
        success = FALSE;

        if (Verbose)
        {
          // Print the whole certificate.
          printf( "{\n" );
          for (i = 0; i < len; i += 10)
          {
            for (j = i; j < i+10 && j < len; j++)
              printf( "0x%02x, ", buffer[j] );
            printf( "\n" );
          }
          printf( "};\n" );

          // Get a provider for this certificate.
          success = CryptAcquireCertificatePrivateKey( prev_cert, 0, NULL,
                                                       &cert_prov, NULL, NULL );
          if (!success)
            printf( "Could not acquire certificate private key: 0x%x\n",
                    GetLastError() );

          else
          {
            // Get a key from the provider.
            success = CryptGetUserKey( cert_prov, AT_KEYEXCHANGE, &cert_key );
            if (!success)
              printf( "Could not get user key: 0x%x\n", GetLastError() );

            else
            {
              // Determine the size of the key blob.
              size = 0;
              success = CryptExportKey( cert_key, NULL, PRIVATEKEYBLOB, 0, NULL,
                                        &size );

              // Allocate memory to hold the blob.
              key_buffer = (UCHAR *) CoTaskMemAlloc( size );
              ASSERT_EXPR( key_buffer != NULL, "Could not allocate key buffer." );

              // Get a key blob from the key.
              success = CryptExportKey( cert_key, NULL, PRIVATEKEYBLOB, 0,
                                        key_buffer, &size );
              if (!success)
                printf( "Could not export certificate key: 0x%x\n", GetLastError() );


              else
              {
                // Print the key blob.
                printf( "CryptAcquireCertificatePrivateKey {\n" );
                for (i = 0; i < size; i += 10)
                {
                  for (j = i; j < i+10 && j < len; j++)
                    printf( "0x%02x, ", key_buffer[j] );
                  printf( "\n" );
                }
                printf( "};\n" );
                success = FALSE;
              }

              CoTaskMemFree( key_buffer );
              key_buffer = NULL;
              CryptDestroyKey( cert_key );
              cert_key = NULL;
            }

            // Release the certificate provider.
            CryptReleaseContext( cert_prov, 0 );
            cert_prov = NULL;
          }

          // Get the private key from the context property.
          size               = sizeof(key_context);
          key_context.cbSize = sizeof(key_context);
          success = CertGetCertificateContextProperty( cert,
                                                       CERT_KEY_CONTEXT_PROP_ID,
                                                       &key_context,
                                                       &size );
          ASSERT_GLE( success, S_OK, "Could not get certificate context property" );
          printf( "Context Property\n" );
          printf( "cbSize: 0x%x\n", key_context.cbSize );
          printf( "hCryptProv: 0x%x\n", key_context.hCryptProv );
          printf( "dwKeySpec: 0x%x\n", key_context.dwKeySpec );
        }

        // Free the memory.
        CoTaskMemFree( buffer );
        buffer = NULL;

        // Determine if this is the top of the chain.
        top = CertCompareCertificateName( X509_ASN_ENCODING, subject, issuer );

        // Search for the next issuer.
        if (!top)
        {
          prev_cert = parent;
          ignore    = 0;
          parent    = CertGetIssuerCertificateFromStore( cert_store, cert,
                                                         prev_cert, &ignore );
//          ASSERT_GLE( parent != NULL, S_OK, "Could not find cert for issuer" );

          // If we couldn't find the parent that way, try another.
          if (parent == NULL)
          {
            printf( "Could not find parent with CertGetIssuerCertificateFromStore: 0x%x\n",
                    GetLastError() );

            // Search for the issuer name.
            prev_cert = NULL;
            last      = parent;
            parent    = CertFindCertificateInStore( root_store,
                                                    X509_ASN_ENCODING,
                                                    0,
                                                    CERT_FIND_SUBJECT_NAME,
                                                    issuer,
                                                    prev_cert );
            if (parent == NULL)
            {
              printf( "Could not find parent with CertFindCertificateInStore: 0x%x\n",
                      GetLastError() );
              break;
            }
//            ASSERT_GLE( parent != NULL, S_OK, "Could not find cert for issuer" );

            // Free the previous level.
            if (last != NULL)
              CertFreeCertificateContext(last);
            last = NULL;
          }

          // Update the loop variables.
          issuer    = &parent->pCertInfo->Issuer;
          subject   = &parent->pCertInfo->Subject;
          prev_cert = parent;
        }
      }
      prev_cert = NULL;
      printf( "\n" );

      // Free the top level authority cert.
      if (parent != NULL)
        CertFreeCertificateContext(parent);
      parent = NULL;

      // Go on to the next certificate.
      prev_cert = cert;
      cert      = NULL;
    }
  }
  while (prev_cert != NULL);
/*
  // Write the test certificate to the store.
  success = CertAddSerializedElementToStore( cert_store,
                                       Cert9,
                                       sizeof(Cert9),
                                       CERT_STORE_ADD_REPLACE_EXISTING,
                                       0,
                                       CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                       NULL,
                                       (const void **) &cert );
  ASSERT_GLE( success, S_OK, "Could not add serialized certificate to store" );
  success = FALSE;

  // Write the test certificate issuer to the cert store.
  success = CertAddSerializedElementToStore( cert_store,
                                       CertSrv,
                                       sizeof(CertSrv),
                                       CERT_STORE_ADD_REPLACE_EXISTING,
                                       0,
                                       CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                       NULL,
                                       NULL );
  ASSERT_GLE( success, S_OK, "Could not add serialized certificate to store" );
  success = FALSE;

  // Print the standard principal name for the certificate.
  result = RpcCertGeneratePrincipalName( cert, 0, &principal );
  if (result != 0)
    printf( "Could not generate standard principal name: 0x%x\n", result );
  else
    printf( "Standard: <%ws>\n", principal );

  // Free the string.
  result = RpcStringFree( &principal );
  ASSERT( result, "Could not free principal" );

  // Print the fullsic principal name for the certificate.
  result = RpcCertGeneratePrincipalName( cert, RPC_C_FULL_CERT_CHAIN, &principal );
  if (result != 0)
    printf( "Could not generate fullsic principal name: 0x%x\n", result );
  else
    printf( "Fullsic: <%ws>\n", principal );

  // Free the string.
  result = RpcStringFree( &principal );
  ASSERT( result, "Could not free principal" );
*/

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (buffer != NULL)
    CoTaskMemFree( buffer );
  if (cert != NULL)
    CertFreeCertificateContext(cert);
  if (parent != NULL)
    CertFreeCertificateContext(parent);
  if (prev_cert != NULL)
    CertFreeCertificateContext(prev_cert);
  if (last != NULL)
    CertFreeCertificateContext(last);
  if (cert_store != NULL)
    CertCloseStore( cert_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (root_store != NULL)
    CertCloseStore( root_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (prov != 0 )
    CryptReleaseContext( prov, 0 );
  CoUninitialize();

  if (success)
    printf( "\n\nCert Test Passed.\n" );
  else
    printf( "\n\nCert Test Failed.\n" );
#else
  printf( "Cert test can only run on NT 5.\n" );
#endif
}

/***************************************************************************/
void do_cloak()
{
#if  (_WIN32_WINNT >= 0x0500 )
  BOOL               success          = FALSE;
  ITest             *server           = NULL;
  ITest             *local            = NULL;
  SAptId             lid;
  HRESULT            result;
  HANDLE             oleadmin         = NULL;
  HANDLE             oleuser          = NULL;
  HANDLE             oleuser1         = NULL;
  HANDLE             oleuser2         = NULL;
  DWORD              ignore;
  DWORD              cls              = Change ? opposite_wc : any_wc;
  WCHAR             *principals[3];
  DWORD              i;
  DWORD              j;
  SEC_WINNT_AUTH_IDENTITY_W authid;
  void              *pauthid;
  DWORD              cap;

  // Only run on NT 5.
  if (!NT5)
  {
    printf( "Cloak test can only run on NT 5.\n" );
    return;
  }

  // Put the user's name in the empty spots in CloakBlanket.
  for (i = 0; i < 9; i++)
    for (j = 0; j < 3; j++)
      if (CloakBlanket[i].principals[j] == NULL)
        CloakBlanket[i].principals[j] = DomainUser;

  // Initialize OLE.
  hello( "cloak" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Initialize the auth info.
  authid.User           = L"oleadmin";
  authid.UserLength     = wcslen(authid.User);
  authid.Domain         = L"redmond";
  authid.DomainLength   = wcslen(authid.Domain);
  authid.Password       = OleUserPassword;
  authid.PasswordLength = wcslen(authid.Password);
  authid.Flags          = SEC_WINNT_AUTH_IDENTITY_UNICODE;

  // Logon oleadmin
  success = LogonUser( L"oleadmin", L"redmond", OleUserPassword, LOGON32_LOGON_BATCH,
                       LOGON32_PROVIDER_DEFAULT, &oleadmin );
  ASSERT_GLE( success, S_OK, "Could not log on oleadmin" );
  success = FALSE;

  // Logon oleuser
  success = LogonUser( L"oleuser", L"redmond", OleUserPassword, LOGON32_LOGON_BATCH,
                       LOGON32_PROVIDER_DEFAULT, &oleuser );
  ASSERT_GLE( success, S_OK, "Could not log on oleuser" );
  success = FALSE;

  // Logon oleuser1
  success = LogonUser( L"oleuser1", L"redmond", OleUserPassword, LOGON32_LOGON_BATCH,
                       LOGON32_PROVIDER_DEFAULT, &oleuser1 );
  ASSERT_GLE( success, S_OK, "Could not log on oleuser1" );
  success = FALSE;

  // Logon oleuser2
  success = LogonUser( L"oleuser2", L"redmond", OleUserPassword, LOGON32_LOGON_BATCH,
                       LOGON32_PROVIDER_DEFAULT, &oleuser2 );
  ASSERT_GLE( success, S_OK, "Could not log on oleuser2" );
  success = FALSE;

  // Initialize security with dynamic cloaking.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL,
                                  RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_DYNAMIC_CLOAKING, NULL );
  ASSERT( result, "Could not initialize dynamic cloaking" );

  // Create another apartment.
  result = new_apartment( &local, &lid, NULL, COINIT_APARTMENTTHREADED );
  ASSERT( result, "Could not create local server" );

  // Test cloaking.
  principals[0] = L"redmond\\oleuser";
  principals[1] = L"redmond\\oleuser1";
  principals[2] = L"redmond\\oleuser2";
  success = do_cloak_call( local, oleuser, oleuser1, oleuser2, principals,
                           RPC_C_IMP_LEVEL_IMPERSONATE );
  if (!success) goto cleanup;
  success = FALSE;
  local->Release();
  local = NULL;

  // Create another apartment.
  result = new_apartment( &local, &lid, NULL, COINIT_APARTMENTTHREADED );
  ASSERT( result, "Could not create local server" );

  // Test cloaking.
  principals[0] = L"redmond\\oleuser";
  principals[1] = L"redmond\\oleuser1";
  principals[2] = L"redmond\\oleuser2";
  success = do_cloak_call( local, oleuser, oleuser1, oleuser2, principals,
                           RPC_C_IMP_LEVEL_IMPERSONATE );
  if (!success) goto cleanup;
  success = FALSE;
  local->Release();
  local = NULL;

  // Create a server.
  result = create_instance( get_class(cls), WhatDest, &server, NULL );
  ASSERT( result,  "Could not create instance of test server" );

  // Test cloaking.
  principals[0] = L"redmond\\oleuser";
  principals[1] = L"redmond\\oleuser1";
  principals[2] = L"redmond\\oleuser2";
  success = do_cloak_call( server, oleuser, oleuser1, oleuser2, principals,
                           RPC_C_IMP_LEVEL_IMPERSONATE );
  if (!success) goto cleanup;
  success = FALSE;

  // Reinitialize security with static cloaking.
  server->Release();
  server = NULL;
  wait_apartment();
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL,
                                  RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_STATIC_CLOAKING, NULL );
  ASSERT( result, "Could not initialize static cloaking" );

  // Create a server.
  result = create_instance( get_class(cls), WhatDest, &server, NULL );
  ASSERT( result,  "Could not create instance of test server" );

  // Test cloaking.
  principals[0] = L"redmond\\oleuser";
  principals[1] = L"redmond\\oleuser";
  principals[2] = L"redmond\\oleuser";
  success = do_cloak_call( server, oleuser, oleuser1, oleuser2, principals,
                           RPC_C_IMP_LEVEL_IMPERSONATE );
  if (!success) goto cleanup;
  success = FALSE;

  // Reinitialize security with no cloaking.
  server->Release();
  server = NULL;
  wait_apartment();
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL,
                                  RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  ASSERT( result, "Could not initialize static cloaking" );

  // Create a server.
  result = create_instance( get_class(cls), WhatDest, &server, NULL );
  ASSERT( result,  "Could not create instance of test server" );

  // Test cloaking.
  principals[0] = DomainUser;
  principals[1] = DomainUser;
  principals[2] = DomainUser;
  success = do_cloak_call( server, oleuser, oleuser1, oleuser2, principals,
                           RPC_C_IMP_LEVEL_IMPERSONATE );
  if (!success) goto cleanup;
  success = FALSE;

  // Release the server.
  server->Release();
  server = NULL;

  // Loop over set blanket options.
  for (i = 0; i < 9; i++)
  {
    // Skip tests using auth id on the local machine.
    if (WhatDest != different_machine_wd && CloakBlanket[i].authid)
      continue;

    // Create a server.
    result = create_instance( get_class(cls), WhatDest, &server, NULL );
    ASSERT( result,  "Could not create instance of test server" );

    // Compute the auth id.
    if (CloakBlanket[i].authid)
    {
      pauthid = &authid;
      cap     = EOAC_NONE;
    }
    else
    {
      pauthid = NULL;
      cap     = CloakBlanket[i].capabilities;
    }

    // Set the thread token.
    if (CloakBlanket[i].token)
    {
      success = ImpersonateLoggedOnUser( oleadmin );
      ASSERT_GLE( success, S_OK, "Could not impersonate oleadmin" );
      success = FALSE;
    }

    // Set blanket.
    result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                 NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_IMP_LEVEL_IMPERSONATE, pauthid, cap );
    ASSERT( result, "Could not set blanket" );

    // Remove the thread token.
    success = SetThreadToken( NULL, NULL );
    ASSERT_GLE( success, S_OK, "Could not remove thread token" );

    // Test cloaking.
    success = do_cloak_call( server, oleuser, oleuser1,
                             oleuser2, CloakBlanket[i].principals,
                             RPC_C_IMP_LEVEL_IMPERSONATE );
    if (!success) goto cleanup;
    success = FALSE;

    // Release the server.
    server->Release();
    server = NULL;
  }

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (local != NULL)
    local->Release();
  if (server != NULL)
    server->Release();
  if (oleadmin != NULL)
    CloseHandle( oleadmin );
  if (oleuser != NULL)
    CloseHandle( oleuser );
  if (oleuser1 != NULL)
    CloseHandle( oleuser1 );
  if (oleuser2 != NULL)
    CloseHandle( oleuser2 );

  if (success)
    printf( "\n\nCloak Test Passed.\n" );
  else
    printf( "\n\nCloak Failed.\n" );
#else
  printf( "Cloak test can only run on NT 5.\n" );
#endif
}

/***************************************************************************/
#if  (_WIN32_WINNT >= 0x0500 )
BOOL do_cloak_call( ITest *server, HANDLE tc, HANDLE td, HANDLE te,
                    WCHAR *principals[3], DWORD imp )
{
  HRESULT            result;
  BOOL               success          = FALSE;
  SAptId             id_null          = { 0, 0, 0 };
  DWORD              ignore;

  // Set the oleuser token.
  SetThreadToken( NULL, NULL );
  success = ImpersonateLoggedOnUser( tc );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser" );
  success = FALSE;

  // Make a call.
  result = server->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                           imp, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, principals[0],
                           &ignore );
  ASSERT( result, "Could not make secure call with oleuser thread token" );

  // Set the oleuser1 token.
  SetThreadToken( NULL, NULL );
  success = ImpersonateLoggedOnUser( td );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser1" );
  success = FALSE;

  // Make a call.
  result = server->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                           imp, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, principals[1],
                           &ignore );
  ASSERT( result, "Could not make secure call with oleuser1 thread token" );

  // Set the oleuser2 token.
  SetThreadToken( NULL, NULL );
  success = ImpersonateLoggedOnUser( te );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser2" );
  success = FALSE;

  // Make a call.
  result = server->secure( id_null, RPC_C_AUTHN_LEVEL_CONNECT,
                           imp, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, principals[2],
                           &ignore );
  ASSERT( result, "Could not make secure call with oleuser2 thread token" );

  success = TRUE;
cleanup:
  SetThreadToken( NULL, NULL );
  return success;
}
#endif

/***************************************************************************/
#if  (_WIN32_WINNT >= 0x0500 )
void do_cloak_act()
{
  BOOL                 success          = FALSE;
  ITest               *server           = NULL;
  ITest               *server1          = NULL;
  IUnknown            *unknown          = NULL;
  SAptId               id_server;
  SAptId               id_server1;
  HRESULT              result;
  HANDLE               oleuser1         = NULL;
  HANDLE               oleuser2         = NULL;
  WCHAR               *creator          = NULL;

  // Initialize OLE.
  hello( "cloak_act" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Initialize security with dynamic cloaking.
  result = MCoInitializeSecurity( NULL, -1, NULL,
                                  NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_DYNAMIC_CLOAKING, NULL );
  ASSERT( result, "Could not initialize security with dynamic cloaking" );

  // Get the token for oleuser1.
  success = LogonUser( L"oleuser1", L"redmond", OleUserPassword, LOGON32_LOGON_BATCH,
                       LOGON32_PROVIDER_DEFAULT, &oleuser1 );
  ASSERT_GLE( success, S_OK, "Could not log on oleuser1" );
  success = FALSE;

  // Get the token for oleuser2.
  success = LogonUser( L"oleuser2", L"redmond", OleUserPassword, LOGON32_LOGON_BATCH,
                       LOGON32_PROVIDER_DEFAULT, &oleuser2 );
  ASSERT_GLE( success, S_OK, "Could not log on oleuser2" );
  success = FALSE;

  // Set the token for oleuser1.
  success = ImpersonateLoggedOnUser( oleuser1 );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser1" );
  success = FALSE;

  // Create a server.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result, "Could not create server while impersonating oleuser1" );

  // Ask who started the server.
  result = server->get_string( creator_ws, &creator );
  ASSERT( result, "Could not get creator name for server" );
  ASSERT_EXPR( creator != NULL, "No creator name for server" );
  if (_wcsicmp( creator, L"redmond\\oleuser1" ) != 0 )
  {
    printf( "Server not created by oleuser1: <%ws>\n", creator );
    goto cleanup;
  }
  CoTaskMemFree( creator );
  creator = NULL;

  // Set the token for oleuser2.
  success = ImpersonateLoggedOnUser( oleuser2 );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleuser2" );
  success = FALSE;

  // Create a server.
  result = create_instance( get_class(any_wc), WhatDest, &server1, &id_server1 );
  ASSERT( result, "Could not create server while impersonating oleuser2" );

  // Ask who started the server.
  result = server1->get_string( creator_ws, &creator );
  ASSERT( result, "Could not get creator name for server1" );
  ASSERT_EXPR( creator != NULL, "No creator name for server1" );
  if (_wcsicmp( creator, L"redmond\\oleuser2" ) != 0 )
  {
    printf( "Server1 not created by oleuser2: <%ws>\n", creator );
    goto cleanup;
  }

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server != NULL)
    server->Release();
  if (server1 != NULL)
    server1->Release();
  if (oleuser1 != NULL)
    CloseHandle( oleuser1 );
  if (oleuser2 != NULL)
    CloseHandle( oleuser2 );
  if (creator != NULL)
    CoTaskMemFree( creator );

  if (success)
    printf( "\n\nCloak_Act Test Passed.\n" );
  else
    printf( "\n\nCloak_Act Test Failed.\n" );
}
#endif

/***************************************************************************/
void do_crash()
{
  HRESULT  result;
  int      i;
  BOOL     success = FALSE;
  HANDLE   helper[MAX_THREADS];
  DWORD    thread_id;
  DWORD    status;
  ITest   *test    = NULL;
  ITest   *another = NULL;
  ITest   *local   = NULL;
  SAptId   local_id;
  SAptId   test_id;
  SAptId   another_id;
  unsigned char c[17];
  WCHAR   *binding = NULL;
/*
  printf( "This test doesn't run.  It tests functionallity that is not checked in.\n" );
  return;
*/
  // Initialize OLE.
  hello( "crash" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );
/*
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Recalling Initialize failed" );
  result = initialize(NULL,xxx);
  if (result == S_OK)
  {
    printf( "Recalling Initialize with wrong thread mode succeeded: %x\n", result );
    goto cleanup;
  }
  CoUninitialize();
  CoUninitialize();
*/

  // Create a local object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not create local instance of test server." );

  // Get a test object.
  result = create_instance( get_class(any_wc), WhatDest, &test, &test_id );
  ASSERT( result, "Could not create instance of test server" );

  // Get another test object.
  result = create_instance( get_class(any_wc), WhatDest, &another, &another_id );
  ASSERT( result, "Could not create another instance of test server" );
  result = another->get_id( &another_id );
  ASSERT( result, "get_id failed calling second test server" );

  // Let the server throw and exception and catch it before returning.
  result = test->sick( 95 );
  ASSERT( result, "Internal server fault was not dealt with correctly." );

  // Throw a non fatal exception on the first call.
  result = test->recurse_excp( local, 0 );
  if (result != RPC_E_SERVERFAULT)
  {
    printf( "Error with top level exception.\n" );
    goto cleanup;
  }

  // Throw a non fatal exception after recursing.
  result = test->recurse_excp( local, 4 );
  if (result != RPC_E_SERVERFAULT)
  {
    printf( "Error with nested exception.\n" );
    goto cleanup;
  }

  // Test alignment of the buffer.
  result = test->align( c );
  ASSERT( result, "Alignment call failed" );

  // Test failure marshalling parameters.
  result = test->pointer( (DWORD *) -1 );
  if (result != STATUS_ACCESS_VIOLATION)
  {
    printf( "Marshalling in parameter failure call failed: 0x%x\n", result );
    goto cleanup;
  }

  // Test a recursive call.
  result = test->recurse( local, 10 );
  ASSERT( result, "Recursive call failed" );

  // Test multiple threads.
  Multicall_Test = TRUE;
  for (i = 0; i < MAX_THREADS; i++)
  {
    helper[i] = CreateThread( NULL, 0, thread_helper, test, 0, &thread_id );
    if (helper[i] == NULL)
    {
      printf( "Could not create helper thread number %d.\n", i );
      goto cleanup;
    }
  }
  result = test->sleep(4000);
  ASSERT( result, "Multiple call failed on main thread" );
  status = WaitForMultipleObjects( MAX_THREADS, helper, TRUE, INFINITE );
  if (status == WAIT_FAILED)
  {
    printf( "Could not wait for helper threads to die: 0x%x\n", status );
    goto cleanup;
  }
  if (!Multicall_Test)
  {
    printf( "Multiple call failed on helper thread.\n" );
    goto cleanup;
  }

  // See if methods can correctly call GetMessage.
  another->interrupt( test, another_id, TRUE );
  result = test->recurse_interrupt( local, 10 );
  ASSERT( result, "Recursive call with interrupts failed" );
  another->interrupt( test, another_id, FALSE );

  // Kill the server on the first call.
  printf( "One of the servers may get a popup now.  Hit Ok.\n" );
  result = test->recurse_fatal( local, 0xffffffff, 0, FALSE );
  ASSERT_EXPR( result != S_OK, "Server still alive after top level exception." );
  test->Release();
  test = NULL;

  // Kill the server after nesting.
  printf( "One of the servers may get a popup now.  Hit Ok.\n" );
  result = another->recurse_fatal( local, 0xffffffff, 4, FALSE );
  if (result == S_OK)
  {
    printf( "Server still alive after nested exception.\n" );
    goto cleanup;
  }
  another->Release();
  another = NULL;
/*
  // Get a test object.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &test );
  ASSERT( result, "Could not create instance of test server" );

  // Register this process to receive raw RPC.
  result = local->register_rpc( TestProtseq, &binding );
  ASSERT( result, "Could not register rpc" );

  // Tell the server to catch the exception at the message loop.
  result = test->catch_at_top( TRUE, local, binding );
  ASSERT( result, "Could not tell server to catch exception at top" );

  // Kill the server on the first call.
  result = test->recurse_fatal( local, 0xffffffff, 0, FALSE );
  if (result == S_OK)
  {
    printf( "Server still alive after exception caught at top.\n" );
    goto cleanup;
  }
  test->Release();
  test = NULL;

  // Check the raw result.
  status = WaitForSingleObject( RawEvent, INFINITE );
  if (status != WAIT_OBJECT_0)
  {
    printf( "Could not wait on RawEvent: 0x%x\n", status );
    goto cleanup;
  }
  ASSERT( RawResult, "Problem after exception" );

  // Get a test object.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &test );
  ASSERT( result, "Could not create instance of test server" );

  // Tell the server to catch the exception at the message loop.
  result = test->catch_at_top( TRUE, local, binding );
  ASSERT( result, "Could not tell server to catch exception at top" );

  // Kill the server after nesting.
  result = test->recurse_fatal( local, 0xffffffff, 6, FALSE );
  if (result == S_OK)
  {
    printf( "Server still alive after exception caught at top.\n" );
    goto cleanup;
  }
  test->Release();
  test = NULL;

  // Check the raw result.
  status = WaitForSingleObject( RawEvent, INFINITE );
  if (status != WAIT_OBJECT_0)
  {
    printf( "Could not wait on RawEvent: 0x%x\n", status );
    goto cleanup;
  }
  ASSERT( RawResult, "Problem after exception" );

  // Get a test object.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &test );
  ASSERT( result, "Could not create instance of test server" );

  // Tell the server not to catch the exception at the message loop.
  result = test->catch_at_top( FALSE, local, binding );
  ASSERT( result, "Could not tell server not to catch exception at top" );

  // Tell the server to catch the exception after nesting, nest some more
  // and then kill it.
  result = test->recurse_fatal( local, 2, 8, FALSE );
  ASSERT( result, "Could not gracefully catch exception" );
  test->Release();
  test = NULL;

  // Check the raw result.
  status = WaitForSingleObject( RawEvent, INFINITE );
  if (status != WAIT_OBJECT_0)
  {
    printf( "Could not wait on RawEvent: 0x%x\n", status );
    goto cleanup;
  }
  ASSERT( RawResult, "Problem after exception" );

  // Get a test object.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &test );
  ASSERT( result, "Could not create instance of test server" );

  // Tell the server not to catch the exception at the message loop.
  result = test->catch_at_top( FALSE, local, binding );
  ASSERT( result, "Could not tell server not to catch exception at top" );

  // Get the object ids.
  result = local->get_id( &local_id );
  ASSERT( result, "Could not get local id" );
  result = test->get_id( &test_id );
  ASSERT( result, "Could not get test id" );

  // Cancel the call to kill the server.
  success = do_crash_helper( local, local_id, test, test_id);
  local = NULL;
  test  = NULL;
  if (!success)
    goto cleanup;
  success = FALSE;
*/
  // Finally, its all over.
  success = TRUE;
cleanup:
  if (test != NULL)
    test->Release();
  if (another != NULL)
    another->Release();
  if (local != NULL)
    local->Release();
  if (binding != NULL)
    CoTaskMemFree( binding );
  CoUninitialize();

  if (success)
    printf( "\n\nCrash Test Passed.\n" );
  else
    printf( "\n\nCrash Test Failed.\n" );
}

/***************************************************************************/
BOOL do_crash_helper( ITest *obj1, SAptId id1, ITest *obj2, SAptId id2 )
{
  BOOL        success = FALSE;
  HRESULT     result;
  ITest      *helper1 = NULL;
  SAptId      hid1;
  RPC_STATUS  status;

  // Create first helper.
  result = obj1->get_obj_from_new_apt( &helper1, &hid1 );
  ASSERT( result, "Could not get in process server" );

  // Register first message filter.
  result = obj1->register_message_filter( TRUE );
  ASSERT( result, "Could not register message filter." );

  // Tell everybody who their neighbor is.
  result = obj2->remember( helper1, hid1 );
  ASSERT( result, "Could not remember object" );
  result = helper1->remember( obj1, id1 );
  ASSERT( result, "Could not remember object" );

  // Tell the server to catch the exception after nesting, nest some more
  // and then kill it, with cancel.
  result = obj2->recurse_fatal( obj1, 2, 8, TRUE );
  if (result == S_OK)
  ASSERT( result, "Could not gracefully catch exception" );
  obj2->Release();
  obj2 = NULL;

  // Check the raw result.
  status = WaitForSingleObject( RawEvent, INFINITE );
  if (status != WAIT_OBJECT_0)
  {
    printf( "Could not wait on RawEvent: 0x%x\n", status );
    goto cleanup;
  }
  ASSERT( RawResult, "Problem after exception" );

  // Tell everybody to forget their neighbor.
  result = helper1->forget();
  ASSERT( result, "Could not forget neighbor" );

  // Release first message filter.
  result = obj1->register_message_filter( FALSE );
  ASSERT( result, "Could not deregister message filter." );

  success = TRUE;
cleanup:
  if (helper1 != NULL)
    helper1->Release();
  if (obj2 != NULL)
    obj2->Release();
  if (obj1 != NULL)
    obj1->Release();
  return success;
}

/***************************************************************************/
void do_create_dir()
{
  HRESULT  result;
  DWORD    i;
  BOOL     success = FALSE;
  WCHAR   *dir     = NULL;
  WCHAR   *end;

  // Initialize
  hello( "create_dir" );

  // Allocate memory for the directory name, leaving space for the extension.
  i = wcslen( Name );
  dir = (WCHAR *) malloc( (i+5) * sizeof(WCHAR) );
  ASSERT_EXPR( dir != NULL, "Could not allocate memory.\n" );

  // Copy in name and find the end.
  wcscpy( dir, Name );
  end  = dir + i;
  *end = '.';
  end += 1;

  // Create the directories.
  for (i = 0; i < NumIterations; i++)
  {
    // Write the suffix to the string.
    ASSERT_EXPR( i < 1000, "Didn't leave enough space in the buffer for more then 3 digits." );
    wsprintf( end, L"%03d", i );

    // Create the directory.
    success = CreateDirectory( dir, NULL );
    ASSERT_GLE( success, S_OK, "Could not create directory." );
  }

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (dir != NULL)
    free( dir );

  if (success)
    printf( "\n\nCreate_Dir Test Passed.\n" );
  else
    printf( "\n\nCreate_Dir Test Failed.\n" );
}

/***************************************************************************/
#if  (_WIN32_WINNT >= 0x0500 )
void do_crypt()
{
  HRESULT     result;
  DWORD       i;
  DWORD       j;
  DWORD       k;
  DWORD       len;
  BOOL        success     = FALSE;
  HCRYPTPROV  prov        = 0;
  UCHAR      *prov_name;
  UCHAR      *container;
  DWORD       version;
  DWORD       flags;
  HCRYPTKEY   exchange    = 0;
  HCRYPTKEY   sign        = 0;
  BYTE        simpleb[256];
  BYTE        publicb[1000];
  BYTE        privateb[5000];
  BLOBHEADER *header;
  RSAPUBKEY  *pubkey;
  BYTE       *modulus;
  DWORD       publen;
  DWORD       privlen;
  DWORD       simplelen;
  ITest      *server      = NULL;
  SAptId      id;
  HCRYPTKEY   server_key  = 0;
  BYTE       *server_blob = NULL;
  HCRYPTKEY   session     = 0;
  BYTE       *buffer;
  HCRYPTHASH  hash        = 0;

  // Initialize OLE.
  hello( "crypt" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Get the default full provider.
  success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL, 0 );
  ASSERT_GLE( success, NTE_BAD_KEYSET, "Could not acqure full context." );

  // If there is no container, create one.
  if (!success)
  {
    success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET );
    ASSERT_GLE( success, S_OK, "Could not acqure full context." );
  }
  success = FALSE;

  // Get the provider name.
  i = 0;
  CryptGetProvParam( prov, PP_NAME, NULL, &i, 0 );
  prov_name = (UCHAR *) _alloca( i );
  success = CryptGetProvParam( prov, PP_NAME, prov_name, &i, 0 );
  ASSERT_GLE( success, S_OK, "Could not get provider name." );
  success = FALSE;

  // Get the provider version.
  i = sizeof(version);
  success = CryptGetProvParam( prov, PP_VERSION, (UCHAR *) &version, &i, 0 );
  ASSERT_GLE( success, S_OK, "Could not get provider version." );
  success = FALSE;

  // Get the container name.
  i = 0;
  CryptGetProvParam( prov, PP_CONTAINER, NULL, &i, 0 );
  container = (UCHAR *) _alloca( i );
  success = CryptGetProvParam( prov, PP_CONTAINER, container, &i, 0 );
  ASSERT_GLE( success, S_OK, "Could not get container name." );
  success = FALSE;

  // Print stuff about the provider.
  if (Verbose)
  {
    printf( "Provider handle:  0x%x\n", prov );
    printf( "Provider name:    %s\n", prov_name );
    printf( "Provider version: 0x%x\n", version );
    printf( "Container name:   %s\n\n", container );
  }

  // Get the maximum container name size.
  i = 0;
  CryptGetProvParam( prov, PP_ENUMCONTAINERS, NULL, &i, CRYPT_FIRST );
  container = (UCHAR *) _alloca( i );

  // Print all containers.
  success = TRUE;
  flags  = CRYPT_FIRST;
  while (success)
  {
    // Get the container name.
    j       = i;
    success = CryptGetProvParam( prov, PP_ENUMCONTAINERS, container, &j, flags );
    ASSERT_GLE( success, ERROR_NO_MORE_ITEMS, "Could not enumerate containers." );
    flags   = 0;
    if (Verbose)
      printf( "%s\n", container );
  }
  success = FALSE;
  if (Verbose)
    printf( "\n" );

  // Get the exchange public key.
  success = CryptGetUserKey( prov, AT_KEYEXCHANGE, &exchange );
  ASSERT_GLE( success, NTE_NO_KEY, "Could not open exchange key" );

  // Generate the exchange key if there wasn't one.
  if (!success)
  {
    success = CryptGenKey( prov, AT_KEYEXCHANGE, CRYPT_EXPORTABLE, &exchange );
    ASSERT_GLE( success, S_OK, "Could not create exchange key" );
  }
  success = FALSE;

  // Get the signature public key.
  success = CryptGetUserKey( prov, AT_SIGNATURE, &sign );
  ASSERT_GLE( success, NTE_NO_KEY, "Could not open signature key" );

  // Generate the signature key if there wasn't one.
  if (!success)
  {
    success = CryptGenKey( prov, AT_SIGNATURE, CRYPT_EXPORTABLE, &sign );
    ASSERT_GLE( success, S_OK, "Could not create signature key" );
  }
  success = FALSE;

  // Export a public blob.
  publen = sizeof(publicb);
  success = CryptExportKey( exchange, NULL, PUBLICKEYBLOB, 0, publicb, &publen );
  ASSERT_GLE( success, S_OK, "Could not export public key" );

  // Export a private blob.
  privlen = sizeof(privateb);
  success = CryptExportKey( exchange, NULL, PRIVATEKEYBLOB, 0, privateb, &privlen );
  if (!success)
    printf( "Private export failed with 0x%x\n", GetLastError() );
  success = FALSE;

  // Print the public key.
  if (Verbose)
  {
    header  = (BLOBHEADER *) publicb;
    pubkey  = (RSAPUBKEY *) (header + 1);
    modulus = (BYTE *) (pubkey + 1);
    printf( "\nType: 0x%x   Version: 0x%x   Reserver: 0x%x   KeyAlg: 0x%x\n",
            header->bType, header->bVersion, header->reserved, header->aiKeyAlg );
    printf( "Magic: 0x%x   Bitlen: 0x%x    Pubexp: 0x%x\n", pubkey->magic,
            pubkey->bitlen, pubkey->pubexp );
    for (i = 0; i < pubkey->bitlen/8; i++)
      if (i%16 == 15)
        printf( "%02x\n", *(modulus++) );
      else
        printf( "%02x ", *(modulus++) );
    ASSERT_EXPR( (DWORD)(modulus-publicb) == publen, "Wrong length for public key." );
  }

  // Print the private key
  if (Verbose)
  {
    header  = (BLOBHEADER *) privateb;
    pubkey  = (RSAPUBKEY *) (header + 1);
    modulus = (BYTE *) (pubkey + 1);
    printf( "\nType: 0x%x   Version: 0x%x   Reserver: 0x%x   KeyAlg: 0x%x\n",
            header->bType, header->bVersion, header->reserved, header->aiKeyAlg );
    printf( "Magic: 0x%x   Bitlen: 0x%x    Pubexp: 0x%x\n", pubkey->magic,
            pubkey->bitlen, pubkey->pubexp );
    printf( "\nModulus\n" );
    for (i = 0; i < pubkey->bitlen/8; i++)
      if (i%16 == 15)
        printf( "%02x\n", *(modulus++) );
      else
        printf( "%02x ", *(modulus++) );
    printf( "\nPrime1\n" );
    for (i = 0; i < pubkey->bitlen/16; i++)
      if (i%16 == 15)
        printf( "%02x\n", *(modulus++) );
      else
        printf( "%02x ", *(modulus++) );
    printf( "\nPrime2\n" );
    for (i = 0; i < pubkey->bitlen/16; i++)
      if (i%16 == 15)
        printf( "%02x\n", *(modulus++) );
      else
        printf( "%02x ", *(modulus++) );
    printf( "\nExponent1\n" );
    for (i = 0; i < pubkey->bitlen/16; i++)
      if (i%16 == 15)
        printf( "%02x\n", *(modulus++) );
      else
        printf( "%02x ", *(modulus++) );
    printf( "\nExponent2\n" );
    for (i = 0; i < pubkey->bitlen/16; i++)
      if (i%16 == 15)
        printf( "%02x\n", *(modulus++) );
      else
        printf( "%02x ", *(modulus++) );
    printf( "\nCoefficient\n" );
    for (i = 0; i < pubkey->bitlen/16; i++)
      if (i%16 == 15)
        printf( "%02x\n", *(modulus++) );
      else
        printf( "%02x ", *(modulus++) );
    printf( "\nPrivate Exponent\n" );
    for (i = 0; i < pubkey->bitlen/8; i++)
      if (i%16 == 15)
        printf( "%02x\n", *(modulus++) );
      else
        printf( "%02x ", *(modulus++) );
    ASSERT_EXPR( (DWORD)(modulus-privateb) == privlen, "Wrong length for private key." );
  }

  // Get a test object.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id );
  ASSERT( result, "Could not create instance of test server" );

  // Get its public key blob.
  result = server->swap_key( publen, publicb, &i, &server_blob );
  ASSERT( result, "Could not get server key blob" );

  // Import the server's public key.
  success = CryptImportKey( prov, server_blob, i, NULL, 0, &server_key );
  ASSERT_GLE( success, S_OK, "Could not import server key" );
  success = FALSE;

  // Make a session key.
  success = CryptGenKey( prov, CALG_RC4, CRYPT_EXPORTABLE, &session );
  ASSERT_GLE( success, S_OK, "Could not generate session key" );
  success = FALSE;

  // Export a simple blob.
  simplelen = sizeof(simpleb);
  success = CryptExportKey( session, server_key, SIMPLEBLOB, 0, simpleb, &simplelen );
  ASSERT_GLE( success, S_OK, "Could not export session key" );
  success = FALSE;

  // Allocate a buffer.
  len    = wcslen(Name2)*sizeof(WCHAR) + sizeof(WCHAR);
  k      = len;
  j      = len + 32;
  buffer = (BYTE *) _alloca( j );
  wcscpy( (WCHAR *) buffer, Name2 );

  // Encrypt some text.
  success = CryptEncrypt( session, NULL, TRUE, 0, buffer, &len, j );
  ASSERT_GLE( success, S_OK, "Could not encrypt data" );
  success = FALSE;

  // Print the text.
  if (Verbose)
  {
    printf( "\nDecrypted: " );
    for (i = 0; i < k; i++)
      printf( "%02x ", ((BYTE *) Name2)[i] );
    printf( "\nEncrypted: " );
    for (i = 0; i < len; i++)
      printf( "%02x ", buffer[i] );
    printf( "\n" );
  }

  // Let the server decrypt it.
  result = server->decrypt( len, buffer, Name2, simplelen, simpleb, NULL );
  ASSERT( result, "Could not decrypt buffer" );

  // Delete the old session key.
  success = CryptDestroyKey( session );
  ASSERT_GLE( success, S_OK, "Could not destroy session key" );
  session = 0;
  success = FALSE;

  // Create a hash object.
  success = CryptCreateHash( prov, CALG_MD5, NULL, 0, &hash );
  ASSERT_GLE( success, S_OK, "Could not create hash" );
  success = FALSE;

  // Hash the user name.
  success = CryptHashData( hash, (UCHAR *) UserName,
                           wcslen(UserName)*sizeof(WCHAR), 0 );
  ASSERT_GLE( success, S_OK, "Could not hash user name" );
  success = FALSE;

  // Derive a session key.
  success = CryptDeriveKey( prov, CALG_RC4, hash, 0, &session );
  ASSERT_GLE( success, S_OK, "Could not derive key" );
  success = FALSE;

  // Encrypt some text.
  wcscpy( (WCHAR *) buffer, Name2 );
  success = CryptEncrypt( session, NULL, TRUE, 0, buffer, &len, j );
  ASSERT_GLE( success, S_OK, "Could not encrypt data" );
  success = FALSE;

  // Print the text.
  if (Verbose)
  {
    printf( "\nDecrypted: " );
    for (i = 0; i < k; i++)
      printf( "%02x ", ((BYTE *) Name2)[i] );
    printf( "\nEncrypted: " );
    for (i = 0; i < len; i++)
      printf( "%02x ", buffer[i] );
    printf( "\n" );
  }

  // Let the server decrypt it.
  result = server->decrypt( len, buffer, Name2, 0, NULL, UserName );
  ASSERT( result, "Could not decrypt buffer" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (exchange != 0)
    CryptDestroyKey( exchange );
  if (sign != 0)
    CryptDestroyKey( sign );
  if (session != 0)
    CryptDestroyKey( session );
  if (hash != 0)
    CryptDestroyHash( hash );
  if (prov != 0 )
    CryptReleaseContext( prov, 0 );
  if (server != NULL)
    server->Release();
  if (server_blob != NULL)
    CoTaskMemFree( server_blob );
  CoUninitialize();

  if (success)
    printf( "\n\nCrypt Test Passed.\n" );
  else
    printf( "\n\nCrypt Test Failed.\n" );
}
#endif

/***************************************************************************/
void do_cstress()
{
  BOOL      success = FALSE;
  ITest    *obj1    = NULL;
  ITest    *obj2    = NULL;
  ITest    *helper  = NULL;
  SAptId    id1;
  SAptId    id2;
  SAptId    hid;
  DWORD     i;
  HRESULT   result;

  // Initialize OLE.
  hello( "cstress" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &obj1 );
  ASSERT( result,  "Could not create instance of test server" );
  result = obj1->get_id( &id1 );
  ASSERT( result, "Could not get client id" );

  // Create helper.
  result = obj1->get_obj_from_new_apt( &helper, &hid );
  ASSERT( result, "Could not get in process server" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &obj2 );
  ASSERT( result,  "Could not create instance of test server" );
  result = obj2->get_id( &hid );
  ASSERT( result, "Could not get client id" );

  // Register the message filter.
  result = obj1->register_message_filter( TRUE );
  ASSERT( result, "Could not register message filter." );

  // Tell everyone to remember their neighbor.
  result = obj1->remember( helper, hid );
  ASSERT( result, "Could not remember object" );
  result = obj2->remember( helper, hid );
  ASSERT( result, "Could not remember object" );
  result = helper->remember( obj1, id1 );
  ASSERT( result, "Could not remember object" );

  // Loop and cancel a lot of calls.
  for (i = 0; i < NumIterations; i++)
  {
    // Cancel remote call.
    result = obj1->cancel_stress( obj2 );
    ASSERT( result, "Remote cancel failed" );

    // Cancel local call.
    result = obj1->cancel_stress( NULL );
    ASSERT( result, "Local cancel failed" );
  }

  // Tell everybody to forget their neighbor.
  result = obj1->forget();
  ASSERT( result, "Could not forget neighbor" );
  result = obj2->forget();
  ASSERT( result, "Could not forget neighbor" );
  result = helper->forget();
  ASSERT( result, "Could not forget neighbor" );

  // Release the message filter.
  result = obj1->register_message_filter( FALSE );
  ASSERT( result, "Could not register message filter." );

  // Create in process server.
  result = obj1->get_obj_from_new_apt( &helper, &hid );
  ASSERT( result, "Could not get in process server" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (helper != NULL)
    helper->Release();
  if (obj1 != NULL)
    obj1->Release();
  if (obj2 != NULL)
    obj2->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nCancel Stress Test Passed.\n" );
  else
    printf( "\n\nCancel Stress Test Failed.\n" );
}

/***************************************************************************/
void do_delegate()
{
#if  (_WIN32_WINNT >= 0x0500 )
  BOOL      success = FALSE;
  ITest    *obj1    = NULL;
  ITest    *obj2    = NULL;
  ITest    *helper  = NULL;
  ITest    *local   = NULL;
  SAptId    id1;
  SAptId    id2;
  SAptId    hid;
  int       i;
  HRESULT   result;
  DWORD     authn_svc_out;
  OLECHAR  *princ_name_out = NULL;

  // Only run on NT 5.
  if (!NT5)
  {
    printf( "Delegate test can only run on NT 5.\n" );
    return;
  }

  // Initialize OLE.
  hello( "delegate" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );
  ASSERT_EXPR( DomainUser != NULL, "Don't know the domain name.\n" );
  ASSERT_EXPR( GlobalSecurityModel != auto_sm ||
               GlobalAuthnLevel != RPC_C_AUTHN_LEVEL_NONE,
               "Delegate test must be run with security enabled.\n" );

  // Make a local object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not create local object." );

  // Create another apartment.
  result = new_apartment( &helper, &hid, NULL, COINIT_APARTMENTTHREADED );
  ASSERT( result, "Could not create local server" );

  // Turn on cloaking.
  result = MCoSetProxyBlanket( helper, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               DomainUser, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_DELEGATE, NULL,
                               EOAC_STATIC_CLOAKING );
  ASSERT( result, "Could not set blanket" );

  // Make a recursive secure call.
  result = helper->recurse_delegate( local, 4, DomainUser );
  ASSERT( result, "Could not make a recursive delegate call" );

  // Create a remote server.
  result = create_instance( get_class(any_wc), WhatDest, &obj1, &id1 );
  ASSERT( result, "Could not create a server" );

  // Get the principal name and authentication service.
  result = MCoQueryProxyBlanket( obj1, &authn_svc_out, NULL,
                                 &princ_name_out, NULL,
                                 NULL, NULL, NULL );
  ASSERT( result, "Could not query blanket" );

  // Turn on cloaking.
  result = MCoSetProxyBlanket( obj1, authn_svc_out, RPC_C_AUTHZ_NONE,
                               princ_name_out, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_DELEGATE, NULL,
                               EOAC_STATIC_CLOAKING );
  ASSERT( result, "Could not set blanket" );

  // Make a recursive secure call.
  result = obj1->recurse_delegate( local, 4, DomainUser );
  ASSERT( result, "Could not make a recursive delegate call" );

  // Remove the token that was added during the recursive call.
  result = MCoSetProxyBlanket( obj1, authn_svc_out, RPC_C_AUTHZ_NONE,
                               princ_name_out, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_DELEGATE, NULL,
                               EOAC_STATIC_CLOAKING );
  ASSERT( result, "Could not set blanket" );

  // Make a secure call
  result = obj1->recurse_delegate( NULL, 0, DomainUser );
  ASSERT( result, "Could not make a delegate call" );

  // Create a remote server.
  result = create_instance( get_class(any_wc), third_machine_wd, &obj2, &id2 );
  ASSERT( result, "Could not create a server" );

  // Make a three machine delegation call.
  result = obj1->recurse_delegate( obj2, 5, DomainUser );
  ASSERT( result, "Could not make a delegate call" );

  // Release the servers.
  helper->Release();
  obj1->Release();
  obj2->Release();
  local->Release();
  helper = NULL;
  obj1   = NULL;
  obj2   = NULL;
  local  = NULL;

  // Uninitialize.
  CoUninitialize();

  // Reinitialize.
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Initialize security with cloaking.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL,
                                  RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_DELEGATE, NULL,
                                  EOAC_STATIC_CLOAKING, NULL );

  // Create a remote server.
  result = create_instance( get_class(any_wc), WhatDest, &obj1, &id1 );
  ASSERT( result, "Could not create a server" );

  // Make a local object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not create local object." );

  // Make a recursive secure call.
  result = obj1->recurse_delegate( local, 4, DomainUser );
  ASSERT( result, "Could not make a recursive delegate call" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (helper != NULL)
    helper->Release();
  if (obj1 != NULL)
    obj1->Release();
  if (obj2 != NULL)
    obj2->Release();
  if (local != NULL)
    local->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nDelegate Test Passed.\n" );
  else
    printf( "\n\nDelegate Test Failed.\n" );
#else
  printf( "Delegate test can only run on NT 5.\n" );
#endif
}

/***************************************************************************/
void do_hook()
{
  BOOL               success   = FALSE;
  ITest             *server    = NULL;
  SAptId             id;
  ITest             *dead      = NULL;
  ITest             *local     = NULL;
  HRESULT            result;
  IWhichHook        *which     = NULL;

  // Delete all hook registry entries.
  do_hook_delete();

  // Initialize OLE.
  hello( "hook" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  if (!Change)
  {
    // Register the first hook.
    result = do_hook_register( CLSID_Hook1 );
    ASSERT( result, "Could not register hook 1" );
    Sleep(10);

    // Get the status object.
    result = CoCreateInstance( CLSID_WhichHook, NULL, CLSCTX_INPROC_SERVER,
                               IID_IWhichHook, (void **) &which );
    ASSERT( result, "Could not get status object" );

    // Create a server.
    result = create_instance( get_class(any_wc), WhatDest, &server, &id );
    ASSERT( result, "Could not create a server" );

    // Verify that only one hook got called.
    result = server->check_hook( 0, 0, 0, 0, 0, 0, 0, 0, TRUE, FALSE );
    ASSERT( result, "Check hook failed" );

    // Verify the local hooks.
    result = which->Hooked( CLSID_Hook1 );
    ASSERT( result, "Hook 1 didn't get called locally" );
    result = which->Hooked( CLSID_Hook2 );
    ASSERT_EXPR( result != S_OK, "Hook 2 got called locally" );

    // Release the server.
    server->Release();
    server = NULL;

    // Register the second hook.
    result = do_hook_register( CLSID_Hook2 );
    ASSERT( result, "Could not register hook 2" );
    Sleep(10);

    // Create a server.
    result = create_instance( get_class(any_wc), WhatDest, &server, &id );
    ASSERT( result, "Could not create a server" );

    // Verify that both hooks got called.
    result = server->check_hook( 0, 0, 0, 0, 0, 0, 0, 0, TRUE, TRUE );
    ASSERT( result, "Check hook failed" );

    // Verify the local hooks.
    result = which->Hooked( CLSID_Hook1 );
    ASSERT( result, "Hook 1 didn't get called locally" );
    result = which->Hooked( CLSID_Hook2 );
    ASSERT_EXPR( result != S_OK, "Hook 2 got called locally" );

    // Release the server.
    server->Release();
    server = NULL;
    which->Release();
    which = NULL;
  }

  // Create a remote server.
  result = create_instance( get_class(any_wc), WhatDest, &dead, &id );
  ASSERT( result, "Could not create a server" );

  // Tell it to die.
  result = dead->exit();
  ASSERT( result, "Could not tell server to die" );

  if (ThreadMode == COINIT_APARTMENTTHREADED)
  {
    // Create a local server.
    result = new_apartment( &local, &id, NULL, ThreadMode );
    ASSERT( result, "Could not create local server" );

    // Test hooks in process.
    success = do_hook_helper( TRUE, local, id, dead );
    if (!success) goto cleanup;
    success = FALSE;

    // Release the local server.
    local->Release();
    local = NULL;
    dead->Release();
    dead = NULL;

    // Uninitialize.
    CoUninitialize();

    // Reinitialize.
    result = initialize(NULL,ThreadMode);
    ASSERT( result, "Initialize failed" );

    // Create a remote server.
    result = create_instance( get_class(any_wc), WhatDest, &dead, &id );
    ASSERT( result, "Could not create a server" );

    // Tell it to die.
    result = dead->exit();
    ASSERT( result, "Could not tell server to die" );
  }

  // Create a remote server.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id );
  ASSERT( result, "Could not create a server" );

  // Test remote hooks.
  success = do_hook_helper( FALSE, server, id, dead );
  if (!success) goto cleanup;
  success = FALSE;

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (local != NULL)
    local->Release();
  if (server != NULL)
    server->Release();
  if (dead != NULL)
    dead->Release();
  if (which != NULL)
    which->Release();
  CoUninitialize();

  // Delete all hook registry entries.
  do_hook_delete();

  if (success)
    printf( "\n\nHook Test Passed.\n" );
  else
    printf( "\n\nHook Test Failed.\n" );
}

/***************************************************************************/
void do_hook_delete()
{
  HKEY    hook;
  HRESULT result;

  // Open the channel hook key.
  result = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                         L"SOFTWARE\\Microsoft\\OLE\\ChannelHook",
                         0, KEY_READ | KEY_WRITE, &hook );
  if (result == ERROR_SUCCESS)
  {
    // Delete the hook 1 value.
    RegDeleteValue( hook, L"{60000400-76d7-11cf-9af1-0020af6e72f4}" );

    // Delete the hook 2 value.
    RegDeleteValue( hook, L"{60000401-76d7-11cf-9af1-0020af6e72f4}" );

    // Close the channel hook key.
    RegCloseKey( hook );
  }
}

/***************************************************************************/
BOOL do_hook_helper( BOOL local, ITest *test, SAptId id, ITest *dead )
{
  CHook         *hook1   = NULL;
  CHook         *hook2   = NULL;
  BOOL           success = FALSE;
  UUID           extent1;
  UUID           extent2;
  UUID           extent3;
  HRESULT        result;
  DWORD          i;
  unsigned char *data    = NULL;
  unsigned char  c;

  // Call the server.
  result = test->check( id );
  ASSERT( result, "Could not check server" );

  // Register a hook.
  result = UuidCreate( &extent1 );
  ASSERT_EXPR( result == RPC_S_OK || result == RPC_S_UUID_LOCAL_ONLY,
               "Could not create uuid." );
  hook1 = new CHook( extent1, 1 );
  ASSERT_EXPR( hook1 != NULL, "Could not create new hook." );
  result = CoRegisterChannelHook( extent1, hook1 );
  ASSERT( result, "Could not register first hook" );

  // Call the server.
  result = test->check( id );
  ASSERT( result, "Could not check server" );

  // Register the hook in the server
  if (!local)
  {
    result = test->register_hook( extent1, 1 );
    ASSERT( result, "Could not register server hook" );
  }

  // Call the server.
  result = test->check( id );
  ASSERT( result, "Could not check server" );

  // Register another hook in the server.
  result = UuidCreate( &extent3 );
  ASSERT_EXPR( result == RPC_S_OK || result == RPC_S_UUID_LOCAL_ONLY,
               "Could not create uuid." );
  result = test->register_hook( extent3, 3 );
  ASSERT( result, "Could not register server hook" );

  // Call the server.
  result = test->check( id );
  ASSERT( result, "Could not check server" );

  // Register another hook in the client.
  result = UuidCreate( &extent2 );
  ASSERT_EXPR( result == RPC_S_OK || result == RPC_S_UUID_LOCAL_ONLY,
               "Could not create uuid." );
  hook2 = new CHook( extent2, 2 );
  ASSERT_EXPR( hook2 != NULL, "Could not create new hook." );
  result = CoRegisterChannelHook( extent2, hook2 );
  ASSERT( result, "Could not register first hook" );

  // Call the server several times.
  for (i = 0; i < NumIterations; i++)
  {
    result = test->check( id );
    ASSERT( result, "Could not check server" );
  }

  // Verify the server's hook state.
  if (local)
    result = test->check_hook( 2+NumIterations, 2+NumIterations,
                               2+NumIterations, 2+NumIterations,
                               0, 0, 0, 0, TRUE, FALSE );
  else
    result = test->check_hook( 0, 0, 4+NumIterations, 4+NumIterations,
                               0, 0, 2+NumIterations, 2+NumIterations,
                               TRUE, TRUE );
  ASSERT( result, "Could not check server hook" );

  // Verify the local hook state.
  if (local)
  {
    result = hook1->check( 5+NumIterations, 5+NumIterations,
                           5+NumIterations, 5+NumIterations );
    ASSERT( result, "Bad state for hook 1" );
    result = hook2->check( 1+NumIterations, 1+NumIterations,
                           1+NumIterations, 1+NumIterations );
    ASSERT( result, "Bad state for hook 2" );
  }
  else
  {
    result = hook1->check( 6+NumIterations, 6+NumIterations, 0, 0 );
    ASSERT( result, "Bad state for hook 1" );
    result = hook2->check( 1+NumIterations, 1+NumIterations, 0, 0 );
    ASSERT( result, "Bad state for hook 2" );
  }

  // Make a call that fails in get buffer.
  data = &c;
  result = test->get_data( 0x7fffffff, data, 0, &data );
  data = NULL;
  ASSERT_EXPR( result != S_OK, "Bad call succeeded." );

  // Make a call that fails in send receive.
  result = dead->check( id );
  ASSERT_EXPR( result != S_OK, "Bad call succeeded." );

  // Make a call that faults.
  result = test->recurse_excp( NULL, 0 );
  ASSERT_EXPR( result != S_OK, "Bad call succeeded." );

  // Make a call that fails in the server get buffer.
  result = test->get_data( 0, NULL, 0x7fffffff, &data );
  ASSERT_EXPR( result != S_OK, "Bad call succeeded." );

  // Make a call that faults in the stub processing out parameters.
  result = test->crash_out( &i );
  ASSERT_EXPR( result != S_OK, "Bad call succeeded." );

  // Make a successful call.
  result = test->check( id );
  ASSERT( result, "Could not check server" );

  // The test succeeded.
  success = TRUE;
cleanup:
  if (hook1 != NULL)
    hook1->Release();
  if (hook2 != NULL)
    hook2->Release();
  if (data != NULL)
    CoTaskMemFree( data );
  return success;
}

/***************************************************************************/
HRESULT do_hook_register( CLSID clsid )
{
  HRESULT result;
  HKEY    hook;
  DWORD   ignore;

  // Open the channel hook key.
  result = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                         L"SOFTWARE\\Microsoft\\OLE\\ChannelHook",
                         0, L"", REG_OPTION_NON_VOLATILE,
                         KEY_READ | KEY_WRITE, NULL, &hook, &ignore );
  if (result == ERROR_SUCCESS)
  {
    // Register the channel hook.
    if (clsid == CLSID_Hook1)
      result = RegSetValueExA(
                 hook,
                 "{60000400-76d7-11cf-9af1-0020af6e72f4}",
                 0,
                 REG_SZ,
                 NULL,
                 0 );
    else
      result = RegSetValueExA(
                 hook,
                 "{60000401-76d7-11cf-9af1-0020af6e72f4}",
                 0,
                 REG_SZ,
                 NULL,
                 0 );
    ASSERT( result, "RegSetValue failed" );

    // Close the channel hook key.
    RegCloseKey( hook );
  }

cleanup:
  return result;
}

/***************************************************************************/
void do_leak()
{
  BOOL               success   = FALSE;
  ITest             *server    = NULL;
  SAptId             id;
  HRESULT            result;
  DWORD              i;

  // Initialize OLE.
  hello( "hook" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Loop
  for (i = 0; i < NumIterations; i++)
  {
    // Create a remote server.
    result = create_instance( get_class(any_wc), WhatDest, &server, &id );
    ASSERT( result, "Could not create a server" );

    // Release the server.
    server->Release();
    server = NULL;
  }

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server != NULL)
    server->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nLeak Test Passed.\n" );
  else
    printf( "\n\nLeak Test Failed.\n" );
}

/***************************************************************************/
void do_load_client()
{
  BOOL               success = FALSE;
  ITest             *server  = NULL;
  HRESULT            result;
  RPC_BINDING_HANDLE handle  = NULL;
  RPC_STATUS         status;
  WCHAR              binding[MAX_NAME];
  void              *buffer  = NULL;
  SAptId             id;
  SAptId             id2;
  HANDLE             memory  = NULL;
  IStream           *stream  = NULL;
  LARGE_INTEGER      pos;
  DWORD              time_null;
  long               buf_size;
  DWORD              i;

  // Initialize OLE.
  hello( "Load_Client" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Build binding handle for the server.
  wsprintf( binding, L"%ws:%ws", TestProtseq, Name );
  status = RpcBindingFromStringBinding( binding, &handle );
  if (status != RPC_S_OK)
  {
    printf( "Could not make binding handle from string binding: 0x%x\n", status );
    goto cleanup;
  }

  // Make a call to the server.
  nullcall( handle );

  if (!Change)
  {
    // Get a marshalled interface from the server over raw RPC.
    get_interface_buffer( handle, &buf_size, (unsigned char **) &buffer, &id,
                          (error_status_t *) &status );
    if (status != RPC_S_OK)
    {
      printf( "Could not get buffer containing interface: 0x%x\n", status );
      goto cleanup;
    }

    // Allocate memory.
    memory = GlobalAlloc( GMEM_FIXED, buf_size );
    ASSERT_EXPR( memory != NULL, "Could not GlobalAlloc." );

    // Create a stream.
    result = CreateStreamOnHGlobal( memory, TRUE, &stream );
    ASSERT( result, "Could not create stream" );

    // Write the data.
    result = stream->Write( buffer, buf_size, NULL );
    ASSERT( result, "Could not write to stream" );

    // Seek back to the start of the stream.
    pos.QuadPart = 0;
    result = stream->Seek( pos, STREAM_SEEK_SET, NULL );
    ASSERT( result, "Could not seek stream to start" );

    // Unmarshal Interface.
    result = CoUnmarshalInterface( stream, IID_ITest, (void **) &server );
    ASSERT( result, "Could not unmarshal interface" );

    // Call once to make sure everything is set up.
    result = server->null();
    ASSERT( result, "Could not make null call" );

    // Make a lot of null calls.
    time_null = GetTickCount();
    for (i = 0; i < NumIterations; i++)
    {
      result = server->count();
      ASSERT( result, "Could not make count call" );
    }
    time_null = GetTickCount() - time_null;

    // Notify the server that we are done.
    release_interface( handle, (error_status_t *) &status );
    if (status != RPC_S_OK)
    {
      printf( "Could not release interface: 0x%x\n", status );
      goto cleanup;
    }
  }

  // Print the results.
  printf( "%d uS / DCOM Null Call\n", time_null*1000/NumIterations );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server != NULL)
    server->Release();
  if (handle != NULL)
    RpcBindingFree( &handle );
  if (buffer != NULL)
    midl_user_free( buffer );
  if (stream != NULL)
    stream->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nLoad_Client Test Passed.\n" );
  else
    printf( "\n\nLoad_Client Test Failed.\n" );
}

/***************************************************************************/
void do_load_server()
{
  BOOL                success = FALSE;
  SAptId              id;
  HRESULT             result;
  RPC_STATUS          status;
  RPC_BINDING_VECTOR *bindings = NULL;
  HANDLE              thread   = NULL;
  DWORD               thread_id;

  // Initialize OLE.
  hello( "Load_Server" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Start the status thread.
  thread = CreateThread( NULL, 0, status_helper, NULL, 0, &thread_id );
  ASSERT_EXPR( thread != 0, "Could not create thread." );

  // Set up thread switching.
  GlobalThreadId = GetCurrentThreadId();

  // Create a local server
  GlobalTest = new CTest;
  ASSERT( !GlobalTest, "Could not create local server" );

  // Register a protseq.
  status = RpcServerUseProtseq( TestProtseq, RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                NULL );
  ASSERT( status, "Could not register protseq" );

  // Register the dog interface.
  status = RpcServerRegisterIf(xIDog_v0_1_s_ifspec,
                               NULL,   // MgrTypeUuid
                               NULL);  // MgrEpv; null means use default
  ASSERT( status, "Could not register RPC interface" );

  // Inquire the endpoints.
  status = RpcServerInqBindings(&bindings);
  ASSERT( status, "Could not inquire bindings" );

  // Register them in the endpoint mapper.
  status = RpcEpRegister( xIDog_v0_1_s_ifspec, bindings, NULL, NULL );
  ASSERT( status, "Could not register with endpoint mapper" );

  // Start RPC listening.
  status = RpcServerListen( 1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE );
  ASSERT( status, "Could not start RPC listening" );

  // Wait until the objects are released.
  server_loop();

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (thread != NULL)
    CloseHandle( thread );
  CoUninitialize();

  if (success)
    printf( "\n\nLoad_Server Test Passed.\n" );
  else
    printf( "\n\nLoad_Server Test Failed.\n" );
}

/***************************************************************************/
void do_lots()
{
  do_cancel();
  do_crash();
  do_null();
  do_ring();
  do_rundown();
}

/***************************************************************************/
void do_mmarshal()
{
  BOOL      success = FALSE;
  ITest    *client1 = NULL;
  ITest    *client2 = NULL;
  ITest    *test    = NULL;
  ITest    *callee  = NULL;
  HRESULT   result;

  // Initialize OLE.
  hello( "mmarshal" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client1 );
  ASSERT( result,  "Could not create instance of test server" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client2 );
  ASSERT( result,  "Could not create instance of test server" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &test );
  ASSERT( result,  "Could not create instance of test server" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &callee );
  ASSERT( result,  "Could not create instance of test server" );

  // Tell the first client to start calling the test object.
  result = client1->interrupt_marshal( test, callee);
  ASSERT( result, "Could not start client" );

  // Tell the first client to start calling the test object.
  result = client2->interrupt_marshal( test, callee);
  ASSERT( result, "Could not start client" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (client1 != NULL)
    client1->Release();
  if (client2 != NULL)
    client2->Release();
  if (test != NULL)
    test->Release();
  if (callee != NULL)
    callee->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nMultiple marshal Test passed if all server processes exit.\n" );
  else
    printf( "\n\nMultiple marshal Test Failed.\n" );
}

/***************************************************************************/
void do_name()
{
  BOOL                 success       = FALSE;
  SID                 *sid           = (SID *) GlobalHex;
  WCHAR               *name          = NULL;
  DWORD                name_len      = 80;
  WCHAR               *domain        = NULL;
  DWORD                domain_len    = 80;
  SID_NAME_USE         sid_use;
  HRESULT              result        = S_OK;

  // Say hello.
  printf( "Looking up name.\n" );

  // Lookup the sid.
  name   = (WCHAR *) CoTaskMemAlloc( name_len );
  domain = (WCHAR *) CoTaskMemAlloc( domain_len );
  ASSERT_EXPR( name != NULL && domain != NULL, "Could not allocate memory." );
  success = LookupAccountSid( NULL, sid, name, &name_len,
                              domain, &domain_len, &sid_use );
  ASSERT_GLE( success, S_OK, "Could not LookupAccountSid" );
  success = FALSE;
  printf( "%ws\\%ws\n", domain, name );
  printf( " SID_NAME_USE: 0x%x\n", sid_use );

  success = TRUE;
cleanup:
  if (name != NULL)
    CoTaskMemFree( name );
  if (domain != NULL)
    CoTaskMemFree( domain );

  if (success)
    printf( "\n\nName succeeded.\n" );
  else
    printf( "\n\nName failed.\n" );
}

/***************************************************************************/
void do_null()
{
  HRESULT  result;
  BOOL     success = FALSE;
  ITest   *test    = NULL;
  SAptId   id;

  // Initialize OLE.
  hello( "null" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Get a test object on another apartment.
  result = new_apartment( &test, &id, NULL, ThreadMode );
  ASSERT( result, "Could not create apartment instance of test server" );

  // Call the test object.
  result = test->check( id );
  ASSERT( result, "Could not call check in another apartment" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (test != NULL)
    test->Release();
  wait_apartment();
  CoUninitialize();

  if (success)
    printf( "\n\nNull Test Passed.\n" );
  else
    printf( "\n\nNull Test Failed.\n" );
}

/***************************************************************************/
void do_one()
{
  BOOL                 success          = FALSE;
  HRESULT              result;
  HANDLE               user             = NULL;
  HANDLE               iuser            = NULL;
  PROFILEINFO          pi;
  WCHAR                whole_name[256];

  // Print a message.
  hello( "one" );

  // Logon the user
  success = LogonUser( Name, Name2, L"", LOGON32_LOGON_INTERACTIVE,
                       LOGON32_PROVIDER_DEFAULT, &user );
  ASSERT_GLE( success, S_OK, "Could not log on user" );
  success = FALSE;

  // Convert it into an impersonation token.
  success = DuplicateTokenEx( user,
                              MAXIMUM_ALLOWED,
                              NULL, SecurityImpersonation, TokenImpersonation,
                              &iuser );
  ASSERT_GLE( success, S_OK, "Could not duplicate token" );

  // Call LoadUserProfile.
  wcsncpy( whole_name, Name2, 256 );
  wcsncat( whole_name, L"\\", 256 );
  wcsncat( whole_name, Name, 256 );
  pi.dwSize        = sizeof(pi);
  pi.dwFlags       = PI_NOUI;
  pi.lpUserName    = whole_name;
  pi.lpProfilePath = NULL;
  pi.lpDefaultPath = NULL;
  pi.lpServerName  = NULL;
  pi.lpPolicyPath  = NULL;
  pi.hProfile      = NULL;
  success = LoadUserProfile( iuser, &pi );
  ASSERT_GLE( success, S_OK, "Could not load user profile" );

  // Finally, its all over.
  success = TRUE;
cleanup:

  if (user != NULL)
    CloseHandle( user );
  if (iuser != NULL)
    CloseHandle( iuser );

  if (success)
    printf( "\n\nOne Test Passed.\n" );
  else
    printf( "\n\nOne Test Failed.\n" );
}

/***************************************************************************/
void do_perf()
{
  BOOL      success = FALSE;
  ITest    *client1 = NULL;
  ITest    *client2 = NULL;
  ITest    *tmp     = NULL;
  CTest    *local   = NULL;
  SAptId    id;
  HRESULT   result;
  DWORD     time_remote = -1;
  DWORD     time_local  = -1;
  DWORD     time_in     = -1;
  DWORD     time_out    = -1;
  DWORD     time_lin    = -1;
  DWORD     time_lout   = -1;
  DWORD     i;

  // Initialize OLE.
  hello( "perf" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client1 );
  ASSERT( result,  "Could not create instance of test server" );
/**/
  // Call once to make sure everything is set up.
  result = client1->null();
  ASSERT( result, "Could not make null call" );

  // Call a lot of times.
  time_remote = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = client1->null();
    ASSERT( result, "Could not make null call" );
  }
  time_remote = GetTickCount() - time_remote;
/**/
  // Create a local client
  result = new_apartment( &client2, &id, NULL, ThreadMode );
  ASSERT( result, "Could not create local client" );
/**/
  // Call once to make sure everything is set up.
  result = client2->null();
  ASSERT( result, "Could not make null call" );

  // Call a lot of times.
  time_local = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = client2->null();
    ASSERT( result, "Could not make null call" );
  }
  time_local = GetTickCount() - time_local;
/**/
  // Create a local object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not create local object" );
/**/
  // Pass it to the server once.
  result = client1->interface_in( local );
  ASSERT( result, "Could not pass in interface" );

  // Pass it to the server a lot of times.
  time_in = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = client1->interface_in( local );
    ASSERT( result, "Could not pass in interface" );
  }
  time_in = GetTickCount() - time_in;

  // Create another remote object.
  result = client1->get_obj_from_this_apt( &tmp, &id );
  ASSERT( result, "Could not get new object." );

  // Have the server remember it.
  result = client1->remember( tmp, id );
  ASSERT( result, "Could not remember object" );
  tmp->Release();
  tmp = NULL;

  // Get and release the remote object a lot of times.
  time_out = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = client1->get_next( &tmp, &id );
    ASSERT( result, "Could not pass out interface" );
    tmp->Release();
    tmp = NULL;
  }
  time_out = GetTickCount() - time_out;
  client1->forget();
/**/
  // Pass the object from this thread to another thread once.
  result = client2->interface_in( local );
  ASSERT( result, "Could not pass in interface" );

  // Pass the object from this thread to another thread.
  time_lin = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = client2->interface_in( local );
    ASSERT( result, "Could not pass in interface" );
  }
  time_lin = GetTickCount() - time_lin;
/**/
  // Create another remote object.
  result = client2->get_obj_from_this_apt( &tmp, &id );
  ASSERT( result, "Could not get new object." );

  // Have the server remember it.
  result = client2->remember( tmp, id );
  ASSERT( result, "Could not remember object" );
  tmp->Release();
  tmp = NULL;

  // Get and release the remote object a lot of times.
  time_lout = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = client2->get_next( &tmp, &id );
    ASSERT( result, "Could not pass out interface" );
    tmp->Release();
    tmp = NULL;
  }
  time_lout = GetTickCount() - time_lout;
  client2->forget();
/**/
  // Print the results.
  printf( "%d uS / Local Call\n", time_local*1000/NumIterations );
  printf( "%d uS / Remote Call\n", time_remote*1000/NumIterations );
  printf( "%d uS / Interface In Call\n", time_in*1000/NumIterations );
  printf( "%d uS / Interface Out Call\n", time_out*1000/NumIterations );
  printf( "%d uS / Local Interface In Call\n", time_lin*1000/NumIterations );
  printf( "%d uS / Local Interface Out Call\n", time_lout*1000/NumIterations );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (tmp != NULL)
    tmp->Release();
  if (client1 != NULL)
    client1->Release();
  if (client2 != NULL)
    client2->Release();
  if (local != NULL)
    local->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nPerf Test Passed.\n" );
  else
    printf( "\n\nPerf Test Failed.\n" );
}

/***************************************************************************/
void do_perfaccess()
{
  BOOL      success = FALSE;
  ITest    *client1 = NULL;
  ITest    *client2 = NULL;
  SAptId    id;
  HRESULT   result;
  DWORD     grant;
  DWORD     revoke;
  DWORD     set;
  DWORD     get;
  DWORD     generate;
  DWORD     check;
  DWORD     cache;

  // Initialize OLE.
  hello( "perfaccess" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a client.
  result = create_instance( get_class(any_wc), WhatDest, &client1, &id );
  ASSERT( result,  "Could not create instance of test server" );

  // Create another client.
  result = create_instance( get_class(any_wc), WhatDest, &client2, &id );
  ASSERT( result,  "Could not create instance of test server" );

  // Call once to make sure everything is set up.
  result = client1->null();
  ASSERT( result, "Could not make null call" );

  // Make the helper call to setup the ACL.
  result = client2->neighbor_access( client1 );
  ASSERT( result, "Could not setup access" );

  // Get the performance data.
  result = client1->perf_access( &grant, &revoke, &set, &get, &generate,
                                 &check, &cache );
  ASSERT( result, "Could not get performance" );

  // Print the results.
  printf( "%d uS - GrantAccessRights\n", grant );
  printf( "%d uS - RevokeAccessRights\n", revoke );
  printf( "%d uS - SetAccessRights\n", set );
  printf( "%d uS - GetAllAccessRights\n", get );
  printf( "%d uS - IsAccessAllowed - Generate ACL\n", generate );
  printf( "%d uS - IsAccessAllowed - Check ACL\n", check );
  printf( "%d uS - IsAccessAllowed - Cached\n", cache );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (client1 != NULL)
    client1->Release();
  if (client2 != NULL)
    client2->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nPerfAccess Test Passed.\n" );
  else
    printf( "\n\nPerfAccess Test Failed.\n" );
}

/***************************************************************************/
void do_perfapi()
{
  BOOL               success          = FALSE;
  ITest             *client1          = NULL;
  SAptId             id1;
  HRESULT            result;
  DWORD              i;
  LARGE_INTEGER      freq;
  LARGE_INTEGER      start;
  LARGE_INTEGER      nothing;
  LARGE_INTEGER      init_sec_none;
  LARGE_INTEGER      open;
  LARGE_INTEGER      get_sid;
  LARGE_INTEGER      set_auth;
  LARGE_INTEGER      reg_auth;
  HANDLE             hToken      = NULL;
  BYTE               aMemory[1024];
  TOKEN_USER        *pTokenUser  = (TOKEN_USER *) &aMemory;
  DWORD              lNameLen    = 1000;
  DWORD              lDomainLen  = 1000;
  DWORD              lIgnore;
  DWORD              lSidLen;
  WCHAR              name[1000];
  WCHAR              domain[1000];
  LARGE_INTEGER      lookup;
  DWORD              xlookup;
  SID_NAME_USE       sIgnore;
  WCHAR              *binding = NULL;
  RPC_BINDING_HANDLE  handle  = NULL;

  // Initialize OLE.
  hello( "perfapi" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Measure the performance of nothing.
  QueryPerformanceFrequency( &freq );
  QueryPerformanceCounter( &start );
  QueryPerformanceCounter( &nothing );
  nothing.QuadPart = 1000000 * (nothing.QuadPart - start.QuadPart) / freq.QuadPart;

  // Open the process's token.
  QueryPerformanceCounter( &start );
  success = OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken );
  QueryPerformanceCounter( &open );
  open.QuadPart = 1000000 * (open.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT_EXPR( success, "Could not open process token." );

  // Lookup SID of process token.
  QueryPerformanceCounter( &start );
  success = GetTokenInformation( hToken, TokenUser, pTokenUser, sizeof(aMemory),
                               &lIgnore );
  QueryPerformanceCounter( &get_sid );
  get_sid.QuadPart = 1000000 * (get_sid.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT_EXPR( success, "Could not get token information." );
  success = FALSE;

  // Lookup the name from the sid.
  QueryPerformanceCounter( &start );
  success = LookupAccountSid( NULL, pTokenUser->User.Sid, name, &lNameLen,
                    domain, &lDomainLen, &sIgnore );
  QueryPerformanceCounter( &lookup );
  lookup.QuadPart = 1000000 * (lookup.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT_EXPR( success, "Could not lookup account sid." );
  success = FALSE;

  // Lookup the name from the sid a lot of times.
  xlookup = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    lNameLen   = 1000;
    lDomainLen = 1000;
    success = LookupAccountSid( NULL, pTokenUser->User.Sid, name, &lNameLen,
                      domain, &lDomainLen, &sIgnore );
    ASSERT_EXPR( success, "Could not lookup account sid." );
    success = FALSE;
  }
  xlookup = (GetTickCount() - xlookup)*1000/NumIterations;

  // Import the security APIs.
  GCoInitializeSecurity = (CoInitializeSecurityFn) Fixup( "CoInitializeSecurity" );
  if (GCoInitializeSecurity == NULL)
    goto cleanup;

  // Measure the performance of initialize.
  QueryPerformanceCounter( &start );
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  QueryPerformanceCounter( &init_sec_none );
  init_sec_none.QuadPart = 1000000 * (init_sec_none.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not initialize security" );

  // Create a possibly remote object.
  result = create_instance( get_class(any_wc), WhatDest, &client1, &id1 );
  ASSERT( result, "Could not create server" );

  // Ask the server to register rpc.
  result = client1->register_rpc( TestProtseq, &binding );
  ASSERT( result, "Could not register rpc interface" );

  // Create a binding handle.
  result = RpcBindingFromStringBinding( binding, &handle );
  ASSERT( result, "Could not make string binding" );

  // Measure setting auth info on a binding handle.
  QueryPerformanceCounter( &start );
  result = RpcBindingSetAuthInfo( handle, L"none", RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
             RPC_C_AUTHN_WINNT, NULL, 0 );
  QueryPerformanceCounter( &set_auth );
  set_auth.QuadPart = 1000000 * (set_auth.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not set auth info" );

  // Measure registering an authentication service.
  QueryPerformanceCounter( &start );
  result = RpcServerRegisterAuthInfo( L"none", RPC_C_AUTHN_WINNT, 0, 0 );
  QueryPerformanceCounter( &reg_auth );
  reg_auth.QuadPart = 1000000 * (reg_auth.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not register auth info" );

  // Ask the server to make an ACL.
  result = client1->make_acl( (HACKSID *) pTokenUser->User.Sid );
  ASSERT( result, "Could not make ACL" );

  // Measure access control.
  result = acl_call( handle );
  ASSERT( result, "Could not measure AccessCheck" );

  // Print the timings.
  printf( "nothing                          took %d uS\n", nothing.u.LowPart );
  printf( "OpenProcessToken                 took %d uS\n", open.u.LowPart );
  printf( "GetTokenInformation              took %d uS\n", get_sid.u.LowPart );
  printf( "LookupAccountSid                 took %d uS\n", lookup.u.LowPart );
  printf( "LookupAccountSid multiple        took %d uS\n", xlookup );
  printf( "CoInitializeSecurity at none     took %d uS\n", init_sec_none.u.LowPart );
  printf( "RpcBindingSetAuthInfo            took %d uS\n", set_auth.u.LowPart );
  printf( "RpcServerRegisterAuthInfo        took %d uS\n", reg_auth.u.LowPart );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (client1 != NULL)
    client1->Release();
  if (binding != NULL)
    CoTaskMemFree( binding );
  if (handle != NULL)
    RpcBindingFree( &handle );
  CoUninitialize();

  if (success)
    printf( "\n\nPerfApi Test Passed.\n" );
  else
    printf( "\n\nPerfApi Test Failed.\n" );
}

/***************************************************************************/
void do_perfremote()
{
  BOOL      success = FALSE;
  ITest    *client1 = NULL;
  SAptId    id;
  HRESULT   result;
  DWORD     time_remote;
  DWORD     i;

  // Initialize OLE.
  hello( "Perf Remote" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client1 );
  ASSERT( result,  "Could not create instance of test server" );

  // Call once to make sure everything is set up.
  result = client1->null();
  ASSERT( result, "Could not make null call" );

  // Call a lot of times.
  time_remote = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = client1->null();
    ASSERT( result, "Could not make null call" );
  }
  time_remote = GetTickCount() - time_remote;

  // Print the results.
  printf( "%d uS / Remote Call\n", time_remote*1000/NumIterations );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (client1 != NULL)
    client1->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nPerf Test Passed.\n" );
  else
    printf( "\n\nPerf Test Failed.\n" );
}

/***************************************************************************/
void do_perfrpc()
{
  BOOL      success = FALSE;
  ITest    *client1 = NULL;
  SAptId    id;
  HRESULT   result;
  DWORD     i;
  WCHAR              *binding = NULL;
  RPC_BINDING_HANDLE  handle  = NULL;
  RPC_BINDING_HANDLE  copy    = NULL;
  RPC_BINDING_HANDLE  object  = NULL;
  RPC_STATUS          status;
  DWORD               time_remote;
  DWORD               time_integrity;
  DWORD               time_copy;
  DWORD               time_copy_secure;
  DWORD               time_object;
  UUID                object_id;

  // Initialize OLE.
  hello( "Perf RPC" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a client.
  result = create_instance( get_class(any_wc), WhatDest, &client1, &id );
  ASSERT( result,  "Could not create instance of test server" );

  // Ask the server to register rpc.
  result = client1->register_rpc( TestProtseq, &binding );
  ASSERT( result, "Could not register rpc interface" );

  // Create a binding handle.
  status = RpcBindingFromStringBinding( binding, &handle );
  if (status != RPC_S_OK)
  {
    printf( "Could not make binding handle form string binding: 0x%x\n", status );
    goto cleanup;
  }

  // Get a binding handle for the object id test.
  status = RpcBindingCopy( handle, &object );
  ASSERT( status, "Could not copy binding" );

  // Copy the binding handle once.
  status = RpcBindingCopy( handle, &copy );
  ASSERT( status, "Could not copy binding" );
  RpcBindingFree( &copy );
  copy = NULL;

  // Time copying the binding handle.
  time_copy = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    status = RpcBindingCopy( handle, &copy );
    ASSERT( status, "Could not copy binding" );
    RpcBindingFree( &copy );
    copy = NULL;
  }
  time_copy = GetTickCount() - time_copy;

  // Make a raw rpc call to make sure everything is set up.
  nullcall( handle );

  // Call a lot of times.
  time_remote = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    nullcall( handle );
  }
  time_remote = GetTickCount() - time_remote;

  // Set the object id.
  result = RpcBindingSetObject( object, &object_id );
  ASSERT( result, "Could not set object id" );

  // Make a raw rpc call to make sure everything is set up.
  nullcall( object );

  // Call a lot of times.
  time_object = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    nullcall( object );
  }
  time_object = GetTickCount() - time_object;

  // Add security.
  status = RpcBindingSetAuthInfo( handle, L"none", RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
             RPC_C_AUTHN_WINNT, NULL, 0 );
  ASSERT( status, "Could not set auth info" );

  // Copy the binding handle once.
  status = RpcBindingCopy( handle, &copy );
  ASSERT( status, "Could not copy binding" );
  RpcBindingFree( &copy );
  copy = NULL;

  // Time copying the binding handle.
  time_copy_secure = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    status = RpcBindingCopy( handle, &copy );
    ASSERT( status, "Could not copy binding" );
    RpcBindingFree( &copy );
    copy = NULL;
  }
  time_copy_secure = GetTickCount() - time_copy_secure;

  // Make a raw rpc call to make sure everything is set up.
  nullcall( handle );

  // Call a lot of times.
  time_integrity = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    nullcall( handle );
  }
  time_integrity = GetTickCount() - time_integrity;

  // Print the results.
  printf( "%d uS / Raw RPC Remote Call\n", time_remote*1000/NumIterations );
  printf( "%d uS / Raw Integrity RPC Remote Call\n", time_integrity*1000/NumIterations );
  printf( "%d uS / Raw RPC with OID Remote Call\n", time_object*1000/NumIterations );
  printf( "%d uS / handle copy\n", time_copy*1000/NumIterations );
  printf( "%d uS / secure handle copy\n", time_copy_secure*1000/NumIterations );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (client1 != NULL)
    client1->Release();
  if (binding != NULL)
    CoTaskMemFree( binding );
  if (copy != NULL)
    RpcBindingFree( &copy );
  if (object != NULL)
    RpcBindingFree( &object );
  if (handle != NULL)
    RpcBindingFree( &handle );
  CoUninitialize();

  if (success)
    printf( "\n\nPerf Test Passed.\n" );
  else
    printf( "\n\nPerf Test Failed.\n" );
}

/***************************************************************************/
void do_perfsec()
{
  BOOL                 success          = FALSE;
  ITest               *server           = NULL;
  ITest               *copy             = NULL;
  SAptId               id;
  HRESULT              result;
  WCHAR               *binding          = NULL;
  //DWORD                time_null;
  DWORD                time_impersonate;
  DWORD                time_acl;
  DWORD                time_audit;
  DWORD                i;
  DWORD                j;
  RPC_BINDING_HANDLE   handle           = NULL;
  RPC_STATUS           status;
  TOKEN_USER          *token_info       = NULL;
  DWORD                info_size        = 1024;
  HANDLE               token            = NULL;
  PSID                 pSID             = NULL;
  DWORD                level[4];
  DWORD                time_rpc[4];
  DWORD                time_null[4];
  DWORD                time_ifin[4];
  DWORD                time_ifout[4];
  CTest                local;
  ITest               *server2          = NULL;
  LARGE_INTEGER        start;
  LARGE_INTEGER        nothing;
  LARGE_INTEGER        init_sec_none;
  LARGE_INTEGER        init_sec_con;
  LARGE_INTEGER        reg_sec;
  LARGE_INTEGER        query_proxy;
  LARGE_INTEGER        set_proxy;
  LARGE_INTEGER        copy_proxy;
  LARGE_INTEGER        freq;
  DWORD                get_call;
  DWORD                query_client;
  DWORD                impersonate;
  DWORD                revert;
  DWORD                get_call2;
  DWORD                query_client2;
  DWORD                impersonate2;
  DWORD                revert2;
  DWORD                authn_svc;
  DWORD                authz_svc;
  DWORD                authn_level;
  DWORD                imp_level;
  DWORD                capabilities;
  WCHAR               *principal        = NULL;
  SOLE_AUTHENTICATION_SERVICE  svc_list;

  // Initialize OLE.
  hello( "perfsec" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Import the security APIs.
  GCoCopyProxy          = (CoCopyProxyFn)          Fixup( "CoCopyProxy" );
  GCoInitializeSecurity = (CoInitializeSecurityFn) Fixup( "CoInitializeSecurity" );
  GCoQueryProxyBlanket  = (CoQueryProxyBlanketFn)  Fixup( "CoQueryProxyBlanket" );
  GCoSetProxyBlanket    = (CoSetProxyBlanketFn)    Fixup( "CoSetProxyBlanket" );
  if (GCoCopyProxy                      == NULL ||
      GCoInitializeSecurity             == NULL ||
      GCoQueryProxyBlanket              == NULL ||
      GCoSetProxyBlanket                == NULL)
    goto cleanup;

  // Measure the performance of nothing.
  QueryPerformanceFrequency( &freq );
  QueryPerformanceCounter( &start );
  QueryPerformanceCounter( &nothing );
  nothing.QuadPart = 1000000 * (nothing.QuadPart - start.QuadPart) / freq.QuadPart;

  // Measure the performance of initialize.
  QueryPerformanceCounter( &start );
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  QueryPerformanceCounter( &init_sec_none );
  init_sec_none.QuadPart = 1000000 * (init_sec_none.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not initialize security" );

  // Reinitialize.
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Reinitialize failed" );

  // Measure the performance of initialize.
  QueryPerformanceCounter( &start );
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  QueryPerformanceCounter( &init_sec_con );
  init_sec_con.QuadPart = 1000000 * (init_sec_con.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not initialize security at connect" );

  // Reinitialize.
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Reinitialize failed" );

  // Measure the performance of register.
  svc_list.dwAuthnSvc     = RPC_C_AUTHN_WINNT;
  svc_list.dwAuthzSvc     = RPC_C_AUTHZ_NONE;
  svc_list.pPrincipalName = NULL;
  QueryPerformanceCounter( &start );
  result = MCoInitializeSecurity( NULL, 1, &svc_list, NULL,
                                  RPC_C_AUTHN_LEVEL_NONE,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  QueryPerformanceCounter( &reg_sec );
  reg_sec.QuadPart = 1000000 * (reg_sec.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not initialize security with authentication services" );

  // Create a client.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id );
  ASSERT( result,  "Could not create instance of test server" );

  // Measure the performance of set proxy.
  QueryPerformanceCounter( &start );
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL, 0 );
  QueryPerformanceCounter( &set_proxy );
  set_proxy.QuadPart = 1000000 * (set_proxy.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not set proxy" );

  // Measure the performance of query proxy
  QueryPerformanceCounter( &start );
  result = MCoQueryProxyBlanket( server, &authn_svc, &authz_svc, &principal,
                                &authn_level, &imp_level, NULL, &capabilities );
  QueryPerformanceCounter( &query_proxy );
  query_proxy.QuadPart = 1000000 * (query_proxy.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not query_proxy" );

  // Measure the performance of copy proxy.
  QueryPerformanceCounter( &start );
  result = MCoCopyProxy( server, (IUnknown **) &copy );
  QueryPerformanceCounter( &copy_proxy );
  copy_proxy.QuadPart = 1000000 * (copy_proxy.QuadPart - start.QuadPart) / freq.QuadPart;
  ASSERT( result, "Could not copy proxy" );

  // Make a call to measure the performance of the server side APIs.
  result = server->security_performance( &get_call, &query_client, &impersonate,
                                         &revert );
  ASSERT( result, "Could not get server API performance" );

  // Make a call to measure the performance of the server side APIs.
  result = server->security_performance( &get_call2, &query_client2, &impersonate2,
                                         &revert2 );
  ASSERT( result, "Could not get server API performance" );

  // Ask the server to register rpc.
  result = server->register_rpc( TestProtseq, &binding );
  ASSERT( result, "Could not register rpc interface" );

  // Create a binding handle.
  status = RpcBindingFromStringBinding( binding, &handle );
  if (status != RPC_S_OK)
  {
    printf( "Could not make binding handle from string binding: 0x%x\n", status );
    goto cleanup;
  }

  // Create another remote object.
  result = server->get_obj_from_this_apt( &server2, &id );
  ASSERT( result, "Could not get new object." );

  // Have the server remember it.
  result = server->remember( server2, id );
  ASSERT( result, "Could not remember object" );
  server2->Release();
  server2 = NULL;

  // Try several security levels.
  level[0] = RPC_C_AUTHN_LEVEL_NONE;
  level[1] = RPC_C_AUTHN_LEVEL_CONNECT;
  level[2] = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
  level[3] = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
  for (j = 0; j < 4; j++)
  {
    // Set security on the RPC binding handle.
    result = RpcBindingSetAuthInfo( handle, NULL, level[j], RPC_C_AUTHN_WINNT,
                                    NULL, RPC_C_AUTHZ_NONE );
    ASSERT( result, "Could not set rpc auth info" );

    // Set security on the proxy.
    result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                NULL, level[j], RPC_C_IMP_LEVEL_IMPERSONATE,
                                NULL, EOAC_NONE );
    ASSERT( result, "Could not set DCOM auth info" );

    // Make a raw rpc call to make sure everything is set up.
    nullcall( handle );

    // Make some raw rpc calls.
    time_rpc[j] = GetTickCount();
    for (i = 0; i < NumIterations; i++)
    {
      nullcall( handle );
    }
    time_rpc[j] = GetTickCount() - time_rpc[j];

    // Make a null dcom call to make sure everything is set up.
    result = server->null();
    ASSERT( result, "Could not make null call" );

    // Put up a popup about the test starting.
    if (Popup)
      MessageBox( NULL, L"Now would be a good time to start ICECAP.",
                  L"Not Me", MB_YESNO | MB_ICONEXCLAMATION );

    // Make some null calls.
    time_null[j] = GetTickCount();
    for (i = 0; i < NumIterations; i++)
    {
      result = server->null();
      ASSERT( result, "Could not make null call" );
    }
    time_null[j] = GetTickCount() - time_null[j];

    // Put up a popup about the test stopping.
    if (Popup)
      MessageBox( NULL, L"Now would be a good time to stop ICECAP.",
                  L"Not Me", MB_YESNO | MB_ICONSTOP );

    // Pass an interface in to set everything up.
    result = server->interface_in( &local );
    ASSERT( result, "Could not make interface_in call" );

    // Make some interface in calls.
    time_ifin[j] = GetTickCount();
    for (i = 0; i < NumIterations; i++)
    {
      result = server->interface_in( &local );
      ASSERT( result, "Could not make interface_in call" );
    }
    time_ifin[j] = GetTickCount() - time_ifin[j];

    // Pass an interface out to set everything up.
    result = server->get_next( &server2, &id );
    ASSERT( result, "Could not make interface out call" );
    server2->Release();
    server2 = NULL;

    // Make some interface_out calls.
    time_ifout[j] = GetTickCount();
    for (i = 0; i < NumIterations; i++)
    {
      result = server->get_next( &server2, &id );
      ASSERT( result, "Could not make interface out call" );
      server2->Release();
      server2 = NULL;
    }
    time_ifout[j] = GetTickCount() - time_ifout[j];
  }

  // Release the second remote object.
  result = server->forget();
  ASSERT( result, "Could not forget" );

  // Print the DCOM call results.
  for (j = 0; j < 4; j++)
  {
    printf( "% 8d uS / Raw RPC Remote Call at level %d\n",
            time_rpc[j]*1000/NumIterations, level[j] );
    printf( "% 8d uS / Null Remote Call at level %d\n",
            time_null[j]*1000/NumIterations, level[j] );
    printf( "% 8d uS / Interface in Remote Call at level %d\n",
            time_ifin[j]*1000/NumIterations, level[j] );
    printf( "% 8d uS / Interface out Remote Call at level %d\n",
            time_ifout[j]*1000/NumIterations, level[j] );
  }

  // Print the API call results.
  printf( "Results in microseconds\n" );
  printf( "nothing                           took %d\n", nothing.u.LowPart );
  printf( "CoInitializeSecurity at none      took %d\n", init_sec_none.u.LowPart );
  printf( "CoInitializeSecurity at connect   took %d\n", init_sec_con.u.LowPart );
  printf( "CoInitializeSecurity with service took %d\n", reg_sec.u.LowPart );
  printf( "CoQueryProxyBlanket               took %d\n", query_proxy.u.LowPart );
  printf( "CoSetProxyBlanket                 took %d\n", set_proxy.u.LowPart );
  printf( "CoCopyProxy                       took %d\n", copy_proxy.u.LowPart );
  printf( "CoGetCallContext                  took %d\n", get_call );
  printf( "CoQueryClientBlanket              took %d\n", query_client );
  printf( "CoImpersonateClient               took %d\n", impersonate );
  printf( "CoRevertToSelf                    took %d\n", revert );
  printf( "CoGetCallContext                  took %d\n", get_call2 );
  printf( "CoQueryClientBlanket              took %d\n", query_client2 );
  printf( "CoImpersonateClient               took %d\n", impersonate2 );
  printf( "CoRevertToSelf                    took %d\n", revert2 );

/*
  // Open the process's token.
  OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &token );
  result = GetLastError();
  ASSERT( result,  "Could not OpenProcessToken" );

  // Lookup SID of process token.
  token_info = (TOKEN_USER *) malloc( info_size );
  GetTokenInformation( token, TokenUser, token_info, info_size, &info_size );
  result = GetLastError();
  ASSERT( result, "Could not GetTokenInformation" );
  pSID = token_info->User.Sid;

  // Make a raw rpc call to make sure everything is set up.
  nullcall( handle );

  // Call a lot of times.
  time_null = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    nullcall( handle );
  }
  time_null = GetTickCount() - time_null;

  // Call a lot of times.
  time_impersonate = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = impersonate_call( handle );
    ASSERT( result, "Could not make impersonate call" );
  }
  time_impersonate = GetTickCount() - time_impersonate;

  // Call a lot of times.
  time_acl = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = acl_call( handle );
    ASSERT( result, "Could not make acl call" );
  }
  time_acl = GetTickCount() - time_acl;

  // Call a lot of times.
  time_audit = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = audit_call( handle );
    ASSERT( result, "Could not make audit call" );
  }
  time_audit = GetTickCount() - time_audit;

  // Print the results.
  printf( "%d uS / Raw RPC Remote Call\n", time_null*1000/NumIterations );
  printf( "%d uS / Raw Impersonate RPC Remote Call\n", time_impersonate*1000/NumIterations );
  printf( "%d uS / Raw ACL RPC Remote Call\n", time_acl*1000/NumIterations );
  printf( "%d uS / Raw audit RPC Remote Call\n", time_audit*1000/NumIterations );
*/
  // Finally, its all over.
  success = TRUE;
cleanup:
  if (principal != NULL)
    CoTaskMemFree( principal );
  if (copy != NULL)
    copy->Release();
  if (server != NULL)
    server->Release();
  if (server2 != NULL)
    server2->Release();
  if (binding != NULL)
    CoTaskMemFree( binding );
  if (handle != NULL)
    RpcBindingFree( &handle );
  if (token_info != NULL)
    free( token_info );
  if (token != NULL)
    CloseHandle( token );
  CoUninitialize();

  if (success)
    printf( "\n\nSec Test Passed.\n" );
  else
    printf( "\n\nSec Test Failed.\n" );
}

/***************************************************************************/
void do_pipe()
{
  BOOL      success = FALSE;
  ITest    *server;
  SAptId    id;
  HRESULT   result;
  CPipe     pipe;

  // Initialize OLE.
  hello( "pipe" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a local client
  result = new_apartment( &server, &id, NULL, ThreadMode );
  ASSERT( result, "Could not create local client" );

  // Tell the pipe how much data to pass.
  result = pipe.setup( NumElements );
  ASSERT( result, "Could not setup pipe" );
/*
  // Make a pipe in call.
  result = server->pipe_in( NumElements, 1, &pipe );
  ASSERT( result, "Could not make pipe in call" );

  // Verify the pipe.
  result = pipe.check();
  ASSERT( result, "Pipe is unhappy after in call" );

  // Tell the pipe how much data to pass.
  result = pipe.setup( NumElements );
  ASSERT( result, "Could not setup pipe" );

  // Make a pipe out call.
  result = server->pipe_out( NumElements, 1, &pipe );
  ASSERT( result, "Could not make pipe out call" );

  // Verify the pipe.
  result = pipe.check();
  ASSERT( result, "Pipe is unhappy after out call" );

  // Tell the pipe how much data to pass.
  result = pipe.setup( NumElements );
  ASSERT( result, "Could not setup pipe" );

  // Make a pipe in out call.
  result = server->pipe_inout( NumElements, 1, &pipe, &pipe );
  ASSERT( result, "Could not make pipe in/out call" );

  // Verify the pipe.
  result = pipe.check();
  ASSERT( result, "Pipe is unhappy after in/out call" );
*/
  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server != NULL)
    server->Release();
  wait_apartment();
  CoUninitialize();

  if (success)
    printf( "\n\nPipe Test Passed.\n" );
  else
    printf( "\n\nPipe Test Failed.\n" );
}

/***************************************************************************/
void do_post()
{
  BOOL      success = FALSE;

  // Say hello.
  printf( "Posting a message to window 0x%x\n", NumIterations );
  success = PostMessageA( (HWND) NumIterations, WM_USER, 0, 0 );

  if (success)
    printf( "\n\nPostMessageA succeeded.\n" );
  else
    printf( "\n\nPostMessageA failed: 0x%x\n", GetLastError() );
}

/***************************************************************************/
void do_pound()
{
  BOOL               success          = FALSE;
  HRESULT            result;
  int                i;
  ITest             *client1          = NULL;
  ITest             *client2          = NULL;
  SAptId             id1;
  SAptId             id2;

  // Initialize OLE.
  hello( "pound" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a global event.
  ManualReset = CreateEventA( NULL, TRUE, FALSE, NULL );
  ASSERT_EXPR( ManualReset != NULL, "Could not create manual reset event." );

  // Create the first client.
  result = new_apartment( &client2, &id2, NULL, ThreadMode );
  ASSERT( result, "Could not create local server" );

  // Tell the client to make a server.
  result = client2->pound();
  ASSERT( result, "Client would not pound server" );

  // Create servers until something fails.
  for (i = 0; TRUE; i++)
  {
    // Create a client.
    result = new_apartment( &client1, &id1, NULL, ThreadMode );
    if (FAILED(result))
    {
      printf( "Failed creating client number %d.\n", i );
      break;
    }

    // Tell it too remember to last client.
    result = client1->remember( client2, id2 );
    if (FAILED(result))
    {
      printf( "Failed reminding client number %d.\n", i );
      break;
    }

    // Tell is to make a server.
    result = client1->pound();
    if (FAILED(result))
    {
      printf( "Failed reminding client number %d.\n", i );
      break;
    }

    // Save this client for the next iteration.
    client2 = client1;
    id2     = id1;
    client1 = NULL;
  }

  // Tell the clients to start making calls.
  SetEvent( ManualReset );

  // Wait
  printf( "Waiting 10 seconds.\n" );
  Sleep( 10000 );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (client1 != NULL)
    client1->Release();
  if (client2 != NULL)
    client2->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nPound Test Passed.\n" );
  else
    printf( "\n\nPound Test Failed.\n" );
}

//---------------------------------------------------------------
typedef struct
{
  TOKEN_PRIVILEGES    tp;
  LUID_AND_ATTRIBUTES luid2;
} TOKEN_PRIVILEGES2;

DWORD EnableBackupPrivilege()
{
  HANDLE            process  = NULL;
  HANDLE            process2 = NULL;
  TOKEN_PRIVILEGES2 tp;
  LUID              backup;
  LUID              restore;
  BOOL              success;
  DWORD             result   = ERROR_SUCCESS;

  // Do nothing on Win9x.
  if (Win95)
    return ERROR_SUCCESS;

  // Get the process token
  success = OpenProcessToken( GetCurrentProcess(),
                              TOKEN_DUPLICATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                              &process );
  if (!success)
  {
    result = GetLastError();
    goto cleanup;
  }

  // Convert it into an impersonation token.
  success = DuplicateTokenEx( process,
                              MAXIMUM_ALLOWED,
                              NULL, SecurityImpersonation, TokenImpersonation,
                              &process2 );
  if (!success)
  {
    result = GetLastError();
    goto cleanup;
  }

  // Get LUID for backup privilege.
  success = LookupPrivilegeValue(
        NULL,            // lookup privilege on local system
        SE_BACKUP_NAME,
        &backup );
  if (!success)
  {
    result = GetLastError();
    goto cleanup;
  }

  // Get LUID for restore privilege.
  success = LookupPrivilegeValue(
        NULL,            // lookup privilege on local system
        SE_RESTORE_NAME,
        &restore );
  if (!success)
  {
    result = GetLastError();
    goto cleanup;
  }

  // Fill in the token privilege structure.
  tp.tp.PrivilegeCount = 2;
  tp.tp.Privileges[0].Luid = backup;
  tp.tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
  tp.tp.Privileges[1].Luid = restore;
  tp.tp.Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;

  // Enable the privilege or disable all privileges.
  success = AdjustTokenPrivileges( process2, FALSE, &tp.tp, 0, NULL, NULL );
  if (!success)
  {
    result = GetLastError();
    goto cleanup;
  }

  // Save the token on the thread.
  success = SetThreadToken( NULL, process2 );
  if (!success)
  {
    result = GetLastError();
    goto cleanup;
  }

  // Close the token handles.
cleanup:
  if (process != NULL)
    CloseHandle( process );
  if (process2 != NULL)
    CloseHandle( process2 );
  return result;
}

/***************************************************************************/
void do_regload()
{
  BOOL         success = FALSE;
  HRESULT      result;

  // Initialize.
  hello( "regload" );

  // Enable backup privilege.
  result = EnableBackupPrivilege();
  ASSERT( result, "Could not enable backup privilege" );

  // Load the registry.
  result = RegLoadKey( HKEY_USERS, L"test_user", Name );
  ASSERT( result, "Could not load key" );

  // Finally, its all over.
  success = TRUE;
cleanup:

  if (success)
    printf( "\n\nRegload Test Passed.\n" );
  else
    printf( "\n\nRegload Test Failed.\n" );
}

/***************************************************************************/
void do_regpeek()
{
  BOOL         success = FALSE;
  HRESULT      result;
  HKEY         key     = NULL;
  DWORD        i;
  DWORD        value;
  DWORD        value_size;

  // Initialize.
  hello( "regpeek" );

  // Open the key.
  result = RegCreateKeyEx( HKEY_USERS, L"test_user\\test_key", 0, NULL,
                           REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                           &key, NULL );
  ASSERT( result, "Could not open key" );

  // Read and write the key for a while.
  for (i = 0; i < NumIterations; i++)
  {
    // Read the value.
    value      = 0;
    value_size = sizeof(value);
    result     = RegQueryValueEx( key, L"test", 0, NULL, (UCHAR *) &value,
                                  &value_size );
    if (result != ERROR_SUCCESS)
      printf( "Could not read value: 0x%x\n", result );
    else
      printf( "Read value 0x%x.\n", value );

    // Write the value plus 1.
    value += 1;
    result = RegSetValueEx( key, L"test", 0, REG_DWORD, (UCHAR *) &value,
                            sizeof(value) );
    ASSERT( result, "Could not save value" );
  }

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (key != NULL)
    RegCloseKey( key );

  if (success)
    printf( "\n\nRegpeek Test Passed.\n" );
  else
    printf( "\n\nRegpeek Test Failed.\n" );
}

/***************************************************************************/
void do_regsave()
{
  BOOL         success = FALSE;
  HRESULT      result;
  HKEY         key     = NULL;

  // Initialize.
  hello( "regsave" );

  // Enable restore privilege.
  result = EnableBackupPrivilege();
  ASSERT( result, "Could not enable restore privilege" );

  // Open the key.
  result = RegOpenKeyEx( HKEY_USERS, L"test_user", 0, KEY_READ, &key );
  ASSERT( result, "Could not open key" );

  // Save the key.
  result = RegSaveKey( key, Name, NULL );
  ASSERT( result, "Could not load key" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (key != NULL)
    RegCloseKey( key );

  if (success)
    printf( "\n\nRegsave Test Passed.\n" );
  else
    printf( "\n\nRegsave Test Failed.\n" );
}

/***************************************************************************/
void do_reject()
{
  BOOL         success = FALSE;
  ITest       *client1 = NULL;
  ITest       *client2 = NULL;
  SAptId       id1;
  SAptId       id2;
  IAdviseSink *advise1 = NULL;
  IAdviseSink *advise2 = NULL;
  HRESULT      result;
  CTest       *local = NULL;

  // Initialize OLE.
  hello( "reject" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a local object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not create local instance of test server." );

  // Create a server
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client1 );
  ASSERT( result,  "Could not create instance of test server" );
  result = client1->get_id( &id1 );
  ASSERT( result, "Could not get id of server" );

  // Register the local message filter.
  result = local->register_message_filter( TRUE );
  ASSERT( result, "Could not register message filter." );

  // Register the remote message filter.
  result = client1->register_message_filter( TRUE );
  ASSERT( result, "Could not register message filter." );

  // Make the server reject the next call.
  result = client1->reject_next();
  ASSERT( result, "Could not reject next call" );

  // Make us retry the next rejected call.
  result = local->retry_next();
  ASSERT( result, "Could not retry next call" );

  // Call check.
  result = client1->check( id1 );
  ASSERT( result, "Could not check server" );

  // Create a local server.
  result = local->get_obj_from_new_apt( &client2, &id2 );
  ASSERT( result, "Could not get in process server" );

  // Register the remote message filter.
  result = client2->register_message_filter( TRUE );
  ASSERT( result, "Could not register message filter." );

  // Make the server reject the next call.
  result = client2->reject_next();
  ASSERT( result, "Could not reject next call" );

  // Make us retry the next rejected call.
  result = local->retry_next();
  ASSERT( result, "Could not retry next call" );

  // Call check.
  result = client2->check( id2 );
  ASSERT( result, "Could not check server" );

  // Release the message filters.
  result = local->register_message_filter( FALSE );
  ASSERT( result, "Could not deregister message filter." );
  result = client1->register_message_filter( FALSE );
  ASSERT( result, "Could not deregister message filter." );
  result = client2->register_message_filter( FALSE );
  ASSERT( result, "Could not deregister message filter." );

  // Create an advise object on another process
  result = client1->get_advise( &advise1 );
  ASSERT( result, "Could not get advise: 0x%x" );

  // Make an async call.
  advise1->OnSave();

  // Create an advise object on another thread
  result = client2->get_advise( &advise2 );
  ASSERT( result, "Could not get advise: 0x%x" );

  // Make an async call.
  advise2->OnSave();

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (advise2 != NULL)
    advise2->Release();
  if (advise1 != NULL)
    advise1->Release();
  if (client2 != NULL)
    client2->Release();
  if (client1 != NULL)
    client1->Release();
  if (local != NULL)
    local->Release();
  wait_apartment();
  CoUninitialize();

  if (success)
    printf( "\n\nReject Test Passed.\n" );
  else
    printf( "\n\nReject Test Failed.\n" );
}

/***************************************************************************/
void do_remote_client()
{
  BOOL               success = FALSE;
  ITest             *server  = NULL;
  ITest             *server2 = NULL;
  HRESULT            result;
  RPC_BINDING_HANDLE handle  = NULL;
  RPC_STATUS         status;
  WCHAR              binding[MAX_NAME];
  void              *buffer  = NULL;
  SAptId             id;
  SAptId             id2;
  HANDLE             memory  = NULL;
  IStream           *stream  = NULL;
  LARGE_INTEGER      pos;
  DWORD              time_rpc;
  DWORD              time_null;
  DWORD              time_marshal;
  long               buf_size;
  DWORD              i;

  // Initialize OLE.
  hello( "RemoteClient" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Build binding handle for the server.
  wsprintf( binding, L"%ws:%ws", TestProtseq, Name );
  status = RpcBindingFromStringBinding( binding, &handle );
  if (status != RPC_S_OK)
  {
    printf( "Could not make binding handle from string binding: 0x%x\n", status );
    goto cleanup;
  }

  // Get a marshalled interface from the server over raw RPC.
  get_interface_buffer( handle, &buf_size, (unsigned char **) &buffer, &id,
                        (error_status_t *) &status );
  if (status != RPC_S_OK)
  {
    printf( "Could not get buffer containing interface: 0x%x\n", status );
    goto cleanup;
  }

  // Allocate memory.
  memory = GlobalAlloc( GMEM_FIXED, buf_size );
  ASSERT_EXPR( memory != NULL, "Could not GlobalAlloc." );

  // Create a stream.
  result = CreateStreamOnHGlobal( memory, TRUE, &stream );
  ASSERT( result, "Could not create stream" );

  // Write the data.
  result = stream->Write( buffer, buf_size, NULL );
  ASSERT( result, "Could not write to stream" );

  // Seek back to the start of the stream.
  pos.QuadPart = 0;
  result = stream->Seek( pos, STREAM_SEEK_SET, NULL );
  ASSERT( result, "Could not seek stream to start" );

  // Unmarshal Interface.
  result = CoUnmarshalInterface( stream, IID_ITest, (void **) &server );
  ASSERT( result, "Could not unmarshal interface" );

  // Call once to make sure everything is set up.
  result = server->null();
  ASSERT( result, "Could not make null call" );

  // Make a lot of null calls.
  time_null = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = server->null();
    ASSERT( result, "Could not make null call" );
  }
  time_null = GetTickCount() - time_null;

  // Make a lot of marshalling calls.
  time_marshal = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    result = server->get_obj_from_this_apt( &server2, &id2);
    ASSERT( result, "Could not make marshal call" );
    server2->Release();
    server2 = NULL;
  }
  time_marshal = GetTickCount() - time_marshal;

  // Make a lot of RPC calls
  nullcall( handle );
  time_rpc = GetTickCount();
  for (i = 0; i < NumIterations; i++)
  {
    nullcall( handle );
  }
  time_rpc = GetTickCount() - time_rpc;

  // Print the results.
  printf( "%d uS / RPC Null Call\n", time_rpc*1000/NumIterations );
  printf( "%d uS / DCOM Null Call\n", time_null*1000/NumIterations );
  printf( "%d uS / DCOM Marshal Call\n", time_marshal*1000/NumIterations );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server2 != NULL)
    server2->Release();
  if (server != NULL)
    server->Release();
  if (handle != NULL)
    RpcBindingFree( &handle );
  if (buffer != NULL)
    midl_user_free( buffer );
  if (stream != NULL)
    stream->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nRemoteClient Test Passed.\n" );
  else
    printf( "\n\nRemoteClient Test Failed.\n" );
}

/***************************************************************************/
void do_remote_server()
{
  BOOL                success = FALSE;
  SAptId              id;
  HRESULT             result;
  RPC_STATUS          status;
  RPC_BINDING_VECTOR *bindings = NULL;

  // Initialize OLE.
  hello( "RemoteServer" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Set up thread switching.
  GlobalThreadId = GetCurrentThreadId();

  // Create a local server
  GlobalTest = new CTest;
  ASSERT( !GlobalTest, "Could not create local server" );

  // Register a protseq.
  status = RpcServerUseProtseq( TestProtseq, RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                NULL );
  ASSERT( status, "Could not register protseq" );

  // Register the dog interface.
  status = RpcServerRegisterIf(xIDog_v0_1_s_ifspec,
                               NULL,   // MgrTypeUuid
                               NULL);  // MgrEpv; null means use default
  ASSERT( status, "Could not register RPC interface" );

  // Inquire the endpoints.
  status = RpcServerInqBindings(&bindings);
  ASSERT( status, "Could not inquire bindings" );

  // Register them in the endpoint mapper.
  status = RpcEpRegister( xIDog_v0_1_s_ifspec, bindings, NULL, NULL );
  ASSERT( status, "Could not register with endpoint mapper" );

  // Start RPC listening.
  status = RpcServerListen( 1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE );
  ASSERT( status, "Could not start RPC listening" );

  // Wait until the objects are released.
  server_loop();

  // Finally, its all over.
  success = TRUE;
cleanup:
  CoUninitialize();

  if (success)
    printf( "\n\nRemoteServer Test Passed.\n" );
  else
    printf( "\n\nRemoteServer Test Failed.\n" );
}

/***************************************************************************/
void do_ring()
{
  BOOL        success  = FALSE;
  ITest     **array    = NULL;
  SAptId     *id_array = NULL;
  HRESULT     result;
  DWORD       i;
  DWORD       j;
  DWORD       k;
  DWORD       l;
  DWORD       num_machines;
  char        machinea[MAX_NAME];
  WCHAR       this_machine[MAX_NAME];
  DWORD       ignore;
  DWORD       pos;
  DWORD       length;
  char        c;

  // Pause.
/*
  printf( "Type a character: " );
  c = getchar();
  printf( "Why did you type <%c>?\n", c );
*/
  // Initialize OLE.
  hello( "ring" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Recalling Initialize failed" );
  result = initialize_security();
  ASSERT( result, "Could not initialize security" );

  // Lookup this machine's name.
  ignore = sizeof(machinea);
  success = GetComputerNameA( machinea, &ignore );
  ASSERT_EXPR( success, "Could not get computer name." );
  success = FALSE;

  // Convert the name to unicode.
  MultiByteToWideChar( CP_ACP, 0, machinea, strlen(machinea)+1, this_machine,
                       MAX_NAME );

  // If the server is this machine, set the number of machines to 1.
  if (wcscmp(this_machine, Name) == 0)
      num_machines = 1;
  else
      num_machines = 2;

  // Allocate memory to hold all the server pointers.
  length = NumProcesses * NumThreads * NumObjects * num_machines;
  array = (ITest **) malloc( sizeof(ITest *) * length );
  ASSERT_EXPR( array != NULL, "Could not allocate array." );
  for (i = 0; i < length; i++)
    array[i] = NULL;

  // Allocate memory to hold all the server ids.
  id_array = (SAptId *) malloc( sizeof(SAptId) * length );
  ASSERT_EXPR( id_array != NULL, "Could not allocate id array." );

  // Loop over all the machines.
  pos = 0;
  for (l = 0; l < num_machines; l++)
  {
    // Loop over all the processes.
    for (i = 0; i < NumProcesses; i++)
    {
      // Create another server.
      if (l == 0)
        result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                                   IID_ITest, (void **) &array[pos] );
      else
        result = create_instance( get_class(any_wc), WhatDest, &array[pos], &id_array[pos] );
      ASSERT( result, "Could not create new server process" );
      result = array[pos]->get_id( &id_array[pos] );
      ASSERT( result, "Could not get id for new process" );
      pos += 1;

      for (j = 0; j < NumThreads; j++)
      {
        if (j != 0)
        {
          result = array[pos-1]->get_obj_from_new_apt( &array[pos],
                                                 &id_array[pos] );
          ASSERT( result, "Could not get in process server" );
          pos += 1;
        }
        for (k = 1; k < NumObjects; k++)
        {
            result = array[pos-1]->get_obj_from_this_apt( &array[pos],
                                                    &id_array[pos] );
            ASSERT( result, "Could not get in thread server" );
            pos += 1;
        }
      }
    }
  }

  // Hook up the ring.
  for (i = 0; i < length-1; i++)
  {
    result = array[i]->remember( array[i+1], id_array[i+1] );
    ASSERT( result, "Could not connect ring" );
  }
  result = array[length-1]->remember( array[0], id_array[0] );
  ASSERT( result, "Could not connect ring" );

  // Call around the ring.
  for (i = 0; i < NumIterations; i++)
  {
    result = array[0]->ring( length );
    ASSERT( result, "Could not call around the ring" );
  }

  // Finally, its all over.
  success = TRUE;
cleanup:

  // Release all the servers.  Start from the end so the main threads do
  // not go away till all the secondary threads are done.
  if (array != NULL)
    for (i = length-1; i < 0xffffffff; i--)
      if (array[i] != NULL)
      {
        result = array[i]->forget();
        if (result != S_OK)
          printf( "Could not forget server %x: 0x%x\n", i, result );
        array[i]->Release();
      }

  // Release the memory holding the interface pointers.
  if (array != NULL)
    free(array);

  // Release the memory for ids.
  if (id_array != NULL)
    free( id_array );
  CoUninitialize();

  // Pause.
/*
  printf( "Type a character: " );
  c = getchar();
  printf( "Why did you type <%c>?\n", c );
*/
  if (success)
    printf( "\n\nRing Test Passed.\n" );
  else
    printf( "\n\nRing Test Failed.\n" );
}

/***************************************************************************/
void do_rpc()
{
  BOOL               success = FALSE;
  ITest             *client1 = NULL;
  CTest             *local   = NULL;
  SAptId             id1;
  SAptId             id2;
  HRESULT            result;
  WCHAR             *binding = NULL;
  RPC_BINDING_HANDLE handle  = NULL;
  RPC_STATUS         status;

  // Initialize OLE.
  hello( "rpc" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a free threaded server.
  result = CoCreateInstance( ClassIds[free_auto_none], NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client1 );
  ASSERT( result,  "Could not create instance of test server" );
  result = client1->get_id( &id1 );
  ASSERT( result, "Could not get id of server" );

  // Ask the server to register rpc.
  result = client1->register_rpc( TestProtseq, &binding );
  ASSERT( result, "Could not register rpc interface" );
  printf( "String binding: %ws\n", binding );

  // Create a binding handle.
  status = RpcBindingFromStringBinding( binding, &handle );
  if (status != RPC_S_OK)
  {
    printf( "Could not make binding handle from string binding: 0x%x\n", status );
    goto cleanup;
  }

  // Make a raw rpc call.
  result = check_client( handle, (unsigned long *) &status );
  if (status != RPC_S_OK)
  {
    printf( "Could not make RPC call: 0x%x\n", status );
    goto cleanup;
  }
  ASSERT( result, "Server could not check client's id" );

  // Create a local object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not create local object." );
  result = local->get_id( &id2 );
  ASSERT( result, "Could not get local id" );

  // Pass an interface through a raw rpc call.
  result = test( handle, local, id2, (unsigned long *) &status );
  ASSERT( status, "Com fault testing interface with raw rpc" );
  ASSERT( result, "Could not pass interface through raw rpc" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (local != NULL)
    local->Release();
  if (client1 != NULL)
    client1->Release();
  if (binding != NULL)
    CoTaskMemFree( binding );
  if (handle != NULL)
    RpcBindingFree( &handle );
  CoUninitialize();

  if (success)
    printf( "\n\nRpc Test Passed.\n" );
  else
    printf( "\n\nRpc Test Failed.\n" );
}

/***************************************************************************/
/*
   This routine tests various cases of the client or server going away.
   All permutations of the following variables are tested.

       Clean exit (release and uninit) vs Dirty exit
       1 COM thread/process vs 2 COM threads/process
       Client dies vs Server dies
       In process death vs Out of process death
*/
void do_rundown()
{
  BOOL      success = FALSE;
  ITest    *client  = NULL;
  ITest    *client2 = NULL;
  SAptId    client_id;
  SAptId    client_id2;
  HRESULT   result;

  // Initialize OLE.
  hello( "rundown" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client );
  ASSERT( result,  "Could not create instance of test server" );
  result = client->get_id( &client_id );
  ASSERT( result, "Could not get client id" );

  // Run clean tests with one thread per process.
  success = do_rundown1( &client, &client_id, 0 );
  if (!success)
    goto cleanup;

  // Run clean tests with two threads per process.
  success = do_rundown2( &client, &client_id, 0 );
  if (!success)
    goto cleanup;

  // Run dirty tests with one thread per process.
  success = do_rundown1( &client, &client_id, dirty_s );
  if (!success)
    goto cleanup;

  // Run dirty tests with two threads per process.
  success = do_rundown2( &client, &client_id, dirty_s );
  if (!success)
    goto cleanup;
  success = FALSE;

  // Create helper.
  result = client->get_obj_from_new_apt( &client2, &client_id2 );
  ASSERT( result, "Could not get in process server" );

  // Start the test.
  result = client->recurse_disconnect( client2, NumRecursion );
  ASSERT( result, "Could not disconnect in a call" );
  client2->Release();
  client2 = NULL;
  client->Release();
  client = NULL;

  // Create a client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client );
  ASSERT( result,  "Could not create instance of test server" );
  result = client->get_id( &client_id );
  ASSERT( result, "Could not get client id" );

  // Tell the client to reinitialize.
  result = client->reinitialize( RPC_C_AUTHN_DEFAULT );
  ASSERT( result, "Could not reinitialize client" );

  // Give the reinitialize a chance to complete before continuing.
  printf( "Waiting 5 seconds for reinitialize to complete.\n" );
  Sleep(5000);

  // Create another object on the same client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client2 );
  ASSERT( result,  "Could not create instance of test server" );

  // Check the client.
  result = client2->get_id( &client_id );
  ASSERT( result, "Could not get_id from client" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (client2 != NULL)
    client2->Release();
  if (client != NULL)
    client->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nRundown Test Passed.\n" );
  else
    printf( "\n\nRundown Test Failed.\n" );
}

/***************************************************************************/
/*
   This is a helper routine for do_rundown.  It always executes with one
   thread per process of each type (thus a process might have one client and
   one server thread).  It takes a parameter to indicate whether to execute
   clean or dirty deaths.  It executes all permuations of the remaining
   variables, listed below.  Note that the order of execution is important
   to reduce the number of process creations.  Note that the routine takes
   a client process on entry and returns a different client process on
   exit.

           Client death vs Server death
           In process vs Out of process
*/
BOOL do_rundown1( ITest **client, SAptId *client_id, DWORD dirty )
{
  BOOL      success = FALSE;
  ITest    *server  = NULL;
  HRESULT   result;
  SAptId    server_id;
/**/
  // Create in process server.
  result = (*client)->get_obj_from_new_apt( &server, &server_id );
  ASSERT( result, "Could not get in process server" );

  // Ping.
  result = (*client)->remember( server, server_id );
  ASSERT( result, "Could not remember server" );
  result = (*client)->call_next();
  ASSERT( result, "Could not call server" );

  // Kill server.
  result = server->set_state( dirty, THREAD_PRIORITY_NORMAL );
  ASSERT( result, "Could not set_state on server" );
  result = server->exit();
  server->Release();
  server = NULL;
  ASSERT( result, "Could not exit server" );

  // Query client.
  result = (*client)->call_dead();
  ASSERT( result, "Wrong error calling dead server" );
/**/
  // Switch the client to server so the process doesn't go away when we kill
  // the client.  Then create an in process client.
  server    = *client;
  server_id = *client_id;
  *client   = NULL;
/**/
  result    = server->get_obj_from_new_apt( client, client_id );
  ASSERT( result, "Could not get in process client" );

  // Ping.
  result = (*client)->remember( server, server_id );
  ASSERT( result, "Could not remember server" );
  result = (*client)->call_next();
  ASSERT( result, "Could not call server" );

  // Kill client.
  result = (*client)->set_state( dirty, THREAD_PRIORITY_NORMAL );
  ASSERT( result, "Could not set_state on client" );
  (*client)->Release();
  *client = NULL;

  // Query server.
  result = server->check( server_id );
  ASSERT( result, "Could not check server" );

  // Create out of process client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) client );
  ASSERT( result,  "Could not create out of process client" );
  result = (*client)->get_id( client_id );
  ASSERT( result, "Could not get client id" );

  // Ping.
  result = (*client)->remember( server, server_id );
  ASSERT( result, "Could not remember server" );
  result = (*client)->call_next();
  ASSERT( result, "Could not call server" );

  // Kill client.
  result = (*client)->set_state( dirty, THREAD_PRIORITY_NORMAL );
  ASSERT( result, "Could not set_state on client" );
  (*client)->Release();
  *client = NULL;

  // Query server.
  result = server->check( server_id );
  ASSERT( result, "Could not check server" );
/**/
  // Create out of process client.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) client );
  ASSERT( result,  "Could not create out of process client" );
  result = (*client)->get_id( client_id );
  ASSERT( result, "Could not get client id" );

  // Ping.
  result = (*client)->remember( server, server_id );
  ASSERT( result, "Could not remember server" );
  result = (*client)->call_next();
  ASSERT( result, "Could not call server" );

  // Kill server.
  result = server->set_state( dirty, THREAD_PRIORITY_NORMAL );
  ASSERT( result, "Could not set_state on server" );
  result = server->exit();
  server->Release();
  server = NULL;
  if ((dirty & dirty_s) == 0)
    ASSERT( result, "Could not exit server" );

  // Query client.
  result = (*client)->call_dead();
  ASSERT( result, "Wrong error calling dead server" );

  success = TRUE;
cleanup:
  if (server != NULL)
    server->Release();
  return success;
}

/***************************************************************************/
/*
   This is a helper routine for do_rundown.  It always executes with two
   threads per process of each type (thus a process might have two client and
   two server threads).  It takes a parameter to indicate whether to execute
   clean or dirty deaths.  It executes all permuations of the remaining
   variables, listed below.  Note that the order of execution is important
   to reduce the number of process creations.  Note that the routine takes
   a client process on entry and returns a different client process on
   exit.

           Client death vs Server death
           In process vs Out of process
*/
BOOL do_rundown2( ITest **client1, SAptId *client1_id, DWORD dirty )
{
  BOOL      success = FALSE;
  ITest    *server1 = NULL;
  ITest    *server2 = NULL;
  ITest    *client2 = NULL;
  SAptId    client2_id;
  SAptId    server1_id;
  SAptId    server2_id;
  HRESULT   result;

  // Create in process client.
  result = (*client1)->get_obj_from_new_apt( &client2, &client2_id );
  ASSERT( result, "Could not get in process client2" );

  // Create in process server.
  result = (*client1)->get_obj_from_new_apt( &server1, &server1_id );
  ASSERT( result, "Could not get in process server1" );

  // Create in process server.
  result = (*client1)->get_obj_from_new_apt( &server2, &server2_id );
  ASSERT( result, "Could not get in process server2" );

  // Ping 1.
  result = (*client1)->remember( server1, server1_id );
  ASSERT( result, "Could not remember server1" );
  result = (*client1)->call_next();
  ASSERT( result, "Could not call server1" );

  // Ping 2.
  result = client2->remember( server2, server2_id );
  ASSERT( result, "Could not remember server2" );
  result = client2->call_next();
  ASSERT( result, "Could not call server2" );

  // Kill server1.
  result = server1->set_state( dirty, THREAD_PRIORITY_NORMAL );
  ASSERT( result, "Could not set_state on server1" );
  result = server1->exit();
  server1->Release();
  server1 = NULL;
  ASSERT( result, "Could not exit server1" );

  // Query client1.
  result = (*client1)->call_dead();
  ASSERT( result, "Wrong error calling dead server1" );

  // Query client2.
  result = client2->call_next();
  ASSERT( result, "Could not call server2" );

  // Query server2.
  result = server2->check( server2_id );
  ASSERT( result, "Could not check server2" );

  // Switch the client1 to server1 so the process doesn't go away when we kill
  // the client1.  Then create an in process client1.
  server1    = *client1;
  server1_id = *client1_id;
  *client1   = NULL;
  result = server1->get_obj_from_new_apt( client1, client1_id );
  ASSERT( result, "Could not get in process client1" );

  // Ping 1.
  result = (*client1)->remember( server1, server1_id );
  ASSERT( result, "Could not remember server1" );
  result = (*client1)->call_next();
  ASSERT( result, "Could not call server1" );

  // Ping 2.
  result = client2->call_next();
  ASSERT( result, "Could not call server2" );

  // Kill client1.
  result = (*client1)->set_state( dirty, THREAD_PRIORITY_NORMAL );
  ASSERT( result, "Could not set_state on client1" );
  (*client1)->Release();
  *client1 = NULL;

  // Query server1.
  result = server1->check( server1_id );
  ASSERT( result, "Could not check server1" );

  // Query server2.
  result = server2->check( server2_id );
  ASSERT( result, "Could not check server2" );

  // Query client2.
  result = client2->call_next();
  ASSERT( result, "Could not call server2" );
  client2->Release();
  client2 = NULL;

  // Create out of process client1.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) client1 );
  ASSERT( result,  "Could not create out of process client1" );
  result = (*client1)->get_id( client1_id );
  ASSERT( result, "Could not get client1 id" );

  // Create in process client 2.
  result = (*client1)->get_obj_from_new_apt( &client2, &client2_id );
  ASSERT( result, "Could not get in process client2" );

  // Ping 1.
  result = (*client1)->remember( server1, server1_id );
  ASSERT( result, "Could not remember server1" );
  result = (*client1)->call_next();
  ASSERT( result, "Could not call server1" );

  // Ping 2.
  result = client2->remember( server2, server2_id );
  ASSERT( result, "Could not remember server2" );
  result = client2->call_next();
  ASSERT( result, "Could not call server2" );

  // Kill client2 so process does not exit.
  result = client2->set_state( dirty, THREAD_PRIORITY_NORMAL );
  ASSERT( result, "Could not set_state on client2" );
  client2->Release();
  client2 = NULL;

  // Query server1.
  result = server1->check( server1_id );
  ASSERT( result, "Could not check server1" );

  // Query server2.
  result = server2->check( server2_id );
  ASSERT( result, "Could not check server2" );

  // Query client1.
  result = (*client1)->call_next();
  ASSERT( result, "Could not call server1" );

  // Create in process client 2.
  result = (*client1)->get_obj_from_new_apt( &client2, &client2_id );
  ASSERT( result, "Could not get in process client2" );

  // Ping 1.
  result = (*client1)->call_next();
  ASSERT( result, "Could not call server1" );

  // Ping 2.
  result = client2->remember( server2, server2_id );
  ASSERT( result, "Could not remember server2" );
  result = client2->call_next();
  ASSERT( result, "Could not call server2" );

  // Kill server2 so the server process does not go away.
  result = server2->set_state( dirty, THREAD_PRIORITY_NORMAL );
  ASSERT( result, "Could not set_state on server2" );
  result = server2->exit();
  server2->Release();
  server2 = NULL;
  if ((dirty & dirty_s) == 0)
    ASSERT( result, "Could not exit server2" );

  // Query client1.
  result = (*client1)->call_next();
  ASSERT( result, "Could not call server1" );

  // Query client2.
  result = client2->call_dead();
  ASSERT( result, "Wrong error calling dead server2" );

  // Query server1.
  result = server1->check( server1_id );
  ASSERT( result, "Could not check server1" );

  success = TRUE;
cleanup:
  if (server1 != NULL)
    server1->Release();
  if (server2 != NULL)
    server2->Release();
  if (client2 != NULL)
    client2->Release();
  return success;
}

/***************************************************************************/
void do_secpkg()
{
  BOOL                 success       = FALSE;
  SecPkgInfo          *pAllPkg;
  SecPkgInfo          *pNext;
  HRESULT              result        = S_OK;
  DWORD                i;
  DWORD                lMaxLen;
  char                 datagram;
  char                 connection;
  char                 client;
  char                 name;

  // Say hello.
  hello( "secpkg" );

  // Get the list of security packages.
  result = EnumerateSecurityPackages( &lMaxLen, &pAllPkg );
  ASSERT( result, "Could not get list of security packages" );

  // Print them.
  pNext = pAllPkg;
  for (i = 0; i < lMaxLen; i++)
  {
    // Determine the package's capabilities.
    if (pNext->fCapabilities & SECPKG_FLAG_DATAGRAM)
      datagram = 'd';
    else
      datagram = ' ';
    if (pNext->fCapabilities & SECPKG_FLAG_CONNECTION)
      connection = 'c';
    else
      connection = ' ';
    if (pNext->fCapabilities & SECPKG_FLAG_CLIENT_ONLY)
      client = 'C';
    else
      client = ' ';
    if (pNext->fCapabilities & SECPKG_FLAG_ACCEPT_WIN32_NAME)
      name = 'N';
    else
      name = ' ';

    // Print the package info.
    printf( "Id: 0x%04x   Ver: 0x%04x  Cap: 0x%08x<%c%c%c%c>  Name: %ws\n",
            pNext->wRPCID, pNext->wVersion, pNext->fCapabilities,
            datagram, connection, client, name, pNext->Name );
    if (Verbose)
      printf( "Comment: %ws\n\n", pNext->Comment );
    pNext++;
  }

  // Print a legend for capabilities.
  printf( "Datagram:    d\n" );
  printf( "Connection:  c\n" );
  printf( "Client:      C\n" );
  printf( "Win32 name:  N\n" );

  success = TRUE;
cleanup:

  if (success)
    printf( "\n\nSecPkg succeeded.\n" );
  else
    printf( "\n\nSecPkg failed.\n" );
}

/***************************************************************************/
void do_securerefs()
{
  BOOL               success          = FALSE;
  ITest             *server           = NULL;
  ITest             *server2          = NULL;
  ITest             *local            = NULL;
  SAptId             id_server;
  SAptId             id_server2;
  SAptId             id_local;
  HRESULT            result;
  SOLE_AUTHENTICATION_SERVICE  svc_list;

  hello( "securerefs" );

  // Try CoInitializeSecurity before CoInit.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  ASSERT_EXPR( result != S_OK, "Initialized security before OLE" );

  // Initialize OLE.
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Set security to automatic none.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  ASSERT( result, "Could not initialize security to none" );

  if (ThreadMode == COINIT_APARTMENTTHREADED)
  {
    // Create a local server
    result = new_apartment( &local, &id_local, NULL, ThreadMode );
    ASSERT( result,  "Could not create local instance of test server" );

    // Call the local server.
    result = local->check( id_local );
    ASSERT( result, "Could not call local server" )

    // Release the local server.
    local->Release();
    local = NULL;
  }

  // Create a server possibly on a remote machine.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result,  "Could not create instance of test server" );
  ASSERT_EXPR( server != NULL, "Create instance returned NULL." );

  // Call the server.
  result = server->check( id_server );
  ASSERT( result, "Could not call local server" )

  // Release the server.
  server->Release();
  server = NULL;

  // Uninitialize.
  CoUninitialize();

  // Reinitialize.
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Reinitialize failed" );

  // Initialize security with secure refs but bad authn level.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_SECURE_REFS, NULL );
  ASSERT_EXPR( result != S_OK, "CoInitializeSecurity succeeded with bad parameters" );

  // Initialize security with secure refs.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_SECURE_REFS, NULL );
  ASSERT( result, "Could not initialize secure refs" );

  if (ThreadMode == COINIT_APARTMENTTHREADED)
  {
    // Create a local server
    result = new_apartment( &local, &id_local, NULL, ThreadMode );
    ASSERT( result,  "Could not create local instance of test server" );

    // Call the local server.
    result = local->check( id_local );
    ASSERT( result, "Could not call local server" )

    // Release the local server.
    local->Release();
    local = NULL;
  }

  // Create a server possibly on a remote machine.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result,  "Could not create instance of test server" );
  ASSERT_EXPR( server != NULL, "Create instance returned NULL." );

  // Call the server.
  result = server->check( id_server );
  ASSERT( result, "Could not call local server" )

  // Release the server.
  server->Release();
  server = NULL;

  // Create a server possibly on a remote machine.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result,  "Could not create instance of test server" );
  ASSERT_EXPR( server != NULL, "Create instance returned NULL." );

  // Create a server on this machine.
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &server2 );
  ASSERT( result,  "Could not create out of process server2" );
  result = server2->get_id( &id_server2 );
  ASSERT( result, "Could not get server2 id" );

  // Have the second server remember the first.
  result = server2->remember( server, id_server );
  ASSERT( result, "Could not remember server" );
  result = server2->call_next();
  ASSERT( result, "Could not call server" );

  // Release some extra public references.
  success = do_securerefs_helper( &server );
  if (!success) goto cleanup;
  success = FALSE;

  // The server should be gone, have the second server try to call.
  result = server2->call_next();
  ASSERT_EXPR( result != S_OK, "Call to dead server succeeded" );

  // Have the second server forget the first.
  result = server2->forget();
  ASSERT( result, "Could not forget server" );

  // Create a possible machine remote server.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result,  "Could not create instance of test server" );
  ASSERT_EXPR( server != NULL, "Create instance returned NULL." );

  // Tell the second server to remember it.
  result = server2->remember( server, id_server );
  ASSERT( result, "Could not remember server" );
  result = server2->call_next();
  ASSERT( result, "Could not call server" );

  // Release all local references.
  server->Release();
  server = NULL;

  // Have the second server call it.
  result = server2->call_next();
  ASSERT( result, "Could not call server" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server2 != NULL)
    server2->Release();
  if (server != NULL)
    server->Release();
  if (local != NULL)
    local->Release();

  CoUninitialize();

  if (success)
    printf( "\n\nSecureRefs Test Passed.\n" );
  else
    printf( "\n\nSecureRefs Test Failed.\n" );
}

/***************************************************************************/
BOOL do_securerefs_helper( ITest **server )
{
  ULONG           size;
  HRESULT         result;
  HANDLE          memory = NULL;
  BOOL            success;
  IStream        *stream = NULL;
  LARGE_INTEGER   pos;

  // Find out how much memory to allocate.
  result = CoGetMarshalSizeMax( &size, IID_ITest, *server, 0, NULL,
                                MSHLFLAGS_NORMAL );
  ASSERT( result, "Could not get marshal size" );

  // Allocate memory.
  memory = GlobalAlloc( GMEM_FIXED, size );
  ASSERT_EXPR( memory != NULL, "Could not get memory." );

  // Create a stream.
  result = CreateStreamOnHGlobal( memory, TRUE, &stream );
  ASSERT( result, "Could not create stream" );

  // Marshal the proxy.
  result = CoMarshalInterface( stream, IID_ITest, *server, 0, NULL,
                               MSHLFLAGS_NORMAL );
  ASSERT( result, "Could not marshal interface" );

  // Release the proxy.
  (*server)->Release();
  *server = NULL;

  // Seek back to the start of the stream.
  pos.QuadPart = 0;
  result = stream->Seek( pos, STREAM_SEEK_SET, NULL );
  ASSERT( result, "Could not seek to start" );

  // Unmarshal another copy.
  result = CoUnmarshalInterface( stream, IID_ITest, (void **) server );
  ASSERT( result, "Could not unmarshal from stream" );

  // Release the proxy.
  (*server)->Release();
  *server = NULL;

  // Seek back to the start of the stream.
  pos.QuadPart = 0;
  result = stream->Seek( pos, STREAM_SEEK_SET, NULL );
  ASSERT( result, "Could not seek to start" );

  // Unmarshal another copy.
  result = CoUnmarshalInterface( stream, IID_ITest, (void **) server );
  ASSERT( result, "Could not unmarshal from stream" );

  // Release the proxy.
  (*server)->Release();
  *server = NULL;

  success = TRUE;
cleanup:
  // The stream releases the memory.
  if (stream != NULL)
    stream->Release();
  return success;
}

/***************************************************************************/
void do_secure_release()
{
  BOOL               success          = FALSE;
  HRESULT            result;
  int                i;
  ITest             *client1          = NULL;
  ITest             *client2          = NULL;
  SAptId             id1;
  SAptId             id2;
  DWORD              class_index;
  CTest             *local            = NULL;
  SAptId             idl;
  IUnknown          *unknown          = NULL;
  DWORD              what;
  DWORD              authn_level_out;
  DWORD              imp_level_out;
  DWORD              authn_svc_out;
  DWORD              authz_svc_out;
  OLECHAR           *princ_name_out = NULL;
  BOOL               machine_local;

  // Say hello.
  hello( "secure_release" );
  ASSERT_EXPR( GlobalSecurityModel != auto_sm ||
               GlobalAuthnLevel != RPC_C_AUTHN_LEVEL_NONE,
               "Secure_Release test must be run with security enabled.\n" );

  // Figure out if the server is on the same machine.
  machine_local = wcscmp(ThisMachine, Name) == 0;

  // Initialize OLE.
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );
  result = initialize_security();
  ASSERT( result, "Could not initialize security" );

  // Determine the server class id.
  if (ThreadMode == COINIT_MULTITHREADED)
    class_index = free_auto_none;
  else
    class_index = apt_auto_none;

  // Create a server.
  result = create_instance( ClassIds[class_index], WhatDest, &client1, &id1 );
  ASSERT( result,  "Could not create instance of test server" );
  ASSERT_EXPR( client1 != NULL, "Create instance returned NULL." );

  // Create a local object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not allocate local object." );
  result = local->get_id( &idl );
  ASSERT( result, "Could not get id of local object" );

  // Make the server remember the local object.
  result = client1->remember( local, idl );
  ASSERT( result, "Could not remember local object" );

  // Tell the server to call back on release.
  result = client1->by_the_way( callback_on_release_btw );
  ASSERT( result, "Could not talk to server" );

  // Get IUnknown.
  result = client1->QueryInterface( IID_IUnknown, (void **) &unknown );
  ASSERT( result, "Could not query interface IUnknown" );

  // Turn off security.
  result = MCoSetProxyBlanket( unknown, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_NONE,
                               RPC_C_IMP_LEVEL_ANONYMOUS, NULL, EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Release ITest.
  client1->Release();
  client1 = NULL;

  // Release IUnknown.
  unknown->Release();
  unknown = NULL;

  // Ask the local object how secure the release call was.
  result = local->what( &what );
  ASSERT( result, "Server won't answer my question" );
  if (machine_local)
  {
    ASSERT_EXPR( what == release_secure_btw, "Release wasn't secure.\n" );
  }
  else
  {
    ASSERT_EXPR( what == release_unsecure_btw, "Release wasn't unsecure.\n" );
  }

  // Uninitialize.
  local->Release();
  local = NULL;
  CoUninitialize();

  // Initialize OLE.
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Secure to unsecure with secure refs.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, GlobalAuthnLevel,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_SECURE_REFS, NULL );
  ASSERT( result, "Could not initialize security" );

  // Create a server.
  result = create_instance( ClassIds[class_index], WhatDest, &client1, &id1 );
  ASSERT( result,  "Could not create instance of test server" );
  ASSERT_EXPR( client1 != NULL, "Create instance returned NULL." );

  // Create a local object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not allocate local object." );
  result = local->get_id( &idl );
  ASSERT( result, "Could not get id of local object" );

  // Make the server remember the local object.
  result = client1->remember( local, idl );
  ASSERT( result, "Could not remember local object" );

  // Tell the server to call back on release.
  result = client1->by_the_way( callback_on_release_btw );
  ASSERT( result, "Could not talk to server" );

  // Get IUnknown.
  result = client1->QueryInterface( IID_IUnknown, (void **) &unknown );
  ASSERT( result, "Could not query interface IUnknown" );

  // Turn off security.
  result = MCoSetProxyBlanket( unknown, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_NONE,
                               RPC_C_IMP_LEVEL_ANONYMOUS, NULL, EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Release ITest.
  client1->Release();
  client1 = NULL;

  // Release IUnknown.
  unknown->Release();
  unknown = NULL;

  // Ask the local object how secure the release call was.
  result = local->what( &what );
  ASSERT( result, "Server won't answer my question" );
  ASSERT_EXPR( what == release_secure_btw, "Release wasn't secure.\n" );

  // Uninitialize.
  local->Release();
  local = NULL;
  CoUninitialize();

  // Initialize OLE.
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Unsecure to secure without secure refs.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  ASSERT( result, "Could not initialize security" );

  // Determine the server class id.
  if (ThreadMode == COINIT_MULTITHREADED)
    class_index = free_auto_connect;
  else
    class_index = apt_auto_connect;

  // Create a server.
  result = create_instance( ClassIds[class_index], WhatDest, &client1, &id1 );
  ASSERT( result,  "Could not create instance of test server" );
  ASSERT_EXPR( client1 != NULL, "Create instance returned NULL." );

  // Create a local object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not allocate local object." );
  result = local->get_id( &idl );
  ASSERT( result, "Could not get id of local object" );

  // Make the server remember the local object.
  result = client1->remember( local, idl );
  ASSERT( result, "Could not remember local object" );

  // Tell the server to call back on release.
  result = client1->by_the_way( callback_on_release_btw );
  ASSERT( result, "Could not talk to server" );

  // Get IUnknown.
  result = client1->QueryInterface( IID_IUnknown, (void **) &unknown );
  ASSERT( result, "Could not query interface IUnknown" );

  // Turn off security.
  result = MCoSetProxyBlanket( unknown, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_NONE,
                               RPC_C_IMP_LEVEL_ANONYMOUS, NULL, EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Release ITest.
  client1->Release();
  client1 = NULL;

  // Release IUnknown.
  unknown->Release();
  unknown = NULL;

  // Ask the local object how secure the release call was.
  result = local->what( &what );
  ASSERT( result, "Server won't answer my question" );
  if (machine_local)
  {
    ASSERT_EXPR( what == release_secure_btw, "Release wasn't secure.\n" );
  }
  else
  {
    ASSERT_EXPR( what == nothing_btw, "Unsecure release made it.\n" );
  }

  // Uninitialize.
  local->Release();
  local = NULL;
  CoUninitialize();

  // Initialize OLE.
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Unsecure to secure with secure refs.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_SECURE_REFS, NULL );
  ASSERT_EXPR( result != S_OK, "Could initialize security with bad params.\n" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (unknown != NULL)
    unknown->Release();
  if (client1 != NULL)
    client1->Release();
  if (client2 != NULL)
    client2->Release();
  if (local != NULL)
    local->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nSecure_Release Test Passed.\n" );
  else
    printf( "\n\nSecure_Release Test Failed.\n" );
}

/***************************************************************************/
void do_security()
{
  BOOL               success          = FALSE;
  ITest             *server           = NULL;
  ITest             *local            = NULL;
  ITest             *server2          = NULL;
  ITest             *local2           = NULL;
  SAptId             id_server;
  SAptId             id_local;
  SAptId             id_server2;
  SAptId             id_local2;
  HRESULT            result;

  // Initialize OLE.
  hello( "security" );
  ASSERT_EXPR( GlobalSecurityModel == auto_sm &&
               GlobalAuthnLevel == RPC_C_AUTHN_LEVEL_NONE,
               "Security test must be run with no security.\n" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  if (!Change)
  {
    // Test automatic security.
    success = do_security_auto();
    if (!success)
      goto cleanup;
    success = FALSE;

    // Uninitialize.
    CoUninitialize();

    // Reinitialize.
    result = initialize(NULL,ThreadMode);
    ASSERT( result, "Reinitialize failed" );
  }

  // Set security to automatic none.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_NONE,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  ASSERT( result, "Could not initialize security to none" );

  // Create a local server
  result = new_apartment( &local, &id_local, NULL, ThreadMode );
  ASSERT( result,  "Could not create local instance of test server" );

  // Create a client possibly on a remote machine.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result,  "Could not create instance of test server" );
  ASSERT_EXPR( server != NULL, "Create instance returned NULL." );

  // Test proxy copy for a local object.
  if (ThreadMode != COINIT_MULTITHREADED)
  {
    success = do_security_copy( local, id_local );
    if (!success)
      goto cleanup;
    success = FALSE;
  }

  // Test proxy copy for a remote object.
  success = do_security_copy( server, id_server );
  if (!success)
    goto cleanup;
  success = FALSE;

#if  (_WIN32_WINNT >= 0x0500 )
  // Test default parameters for a local object.
  if (ThreadMode != COINIT_MULTITHREADED)
  {
    success = do_security_default( local, id_local );
    if (!success)
      goto cleanup;
    success = FALSE;
  }

  // Test default parameters for a remote object.
  success = do_security_default( server, id_server );
  if (!success)
    goto cleanup;
  success = FALSE;
#endif

  // Test delegation for local objects
  if (ThreadMode != COINIT_MULTITHREADED)
  {
    // Create a local server
    result = new_apartment( &local2, &id_local2, NULL, ThreadMode );
    ASSERT( result,  "Could not create local instance of test server" );

    success = do_security_delegate( local, id_local, local2, id_local2 );
    if (!success)
      goto cleanup;
    success = FALSE;
  }

  // Create a client possibly on a remote machine.
  result = create_instance( get_class(any_wc), WhatDest, &server2, &id_server2 );
  ASSERT( result,  "Could not create instance of test server" );
  ASSERT_EXPR( server2 != NULL, "Create instance returned NULL." );

  // Test delegation
  success = do_security_delegate( server, id_server, server2, id_server2 );
  if (!success)
    goto cleanup;
  success = FALSE;

  // Try some calls.
  if (ThreadMode != COINIT_MULTITHREADED)
  {
    success = do_security_handle( local, id_local );
    if (!success)
      goto cleanup;
    success = FALSE;
  }

  // Try some calls.
  success = do_security_handle( server, id_server );
  if (!success)
    goto cleanup;
  success = FALSE;

  // Test nested impersonation for a local object.
  if (ThreadMode != COINIT_MULTITHREADED)
  {
    success = do_security_nested( local, id_local );
    if (!success)
      goto cleanup;
    success = FALSE;
  }

  // Test nested impersonation for a remote object.
  success = do_security_nested( server, id_server );
  if (!success)
    goto cleanup;
  success = FALSE;

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server2 != NULL)
    server2->Release();
  if (local2 != NULL)
    local2->Release();
  if (server != NULL)
    server->Release();
  if (local != NULL)
    local->Release();

  wait_apartment();
  CoUninitialize();

  if (success)
    printf( "\n\nSecurity Test Passed.\n" );
  else
    printf( "\n\nSecurity Test Failed.\n" );
}

/***************************************************************************/
BOOL do_security_auto( )
{
  BOOL                         success = FALSE;
  DWORD                        i;
  DWORD                        j;
  DWORD                        k;
  HRESULT                      result;
  SOLE_AUTHENTICATION_SERVICE  svc_list;
  ITest                       *server  = NULL;
  SAptId                       id_server;
  DWORD                        authn_level;
  DWORD                        authn_level_out;

  // Figure out the class id offset based on the threading model.
  if (ThreadMode == COINIT_MULTITHREADED)
    k = 5;
  else
    k = 0;

  // Try all types of security initialization.
  for (i = 0; i < 5; i++)
  {

    // Initialize security.
    switch (i)
    {
      case 0:
        authn_level = RPC_C_AUTHN_LEVEL_NONE;
        result = MCoInitializeSecurity( NULL, -1, NULL, NULL,
                                        RPC_C_AUTHN_LEVEL_NONE,
                                        RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                        EOAC_NONE, NULL );
        ASSERT( result, "Could not initialize security to none" );
        break;
      case 1:
        authn_level = RPC_C_AUTHN_LEVEL_CONNECT;
        result = MCoInitializeSecurity( NULL, -1, NULL, NULL,
                                        RPC_C_AUTHN_LEVEL_CONNECT,
                                        RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                        EOAC_NONE, NULL );
        ASSERT( result, "Could not initialize security to connect" );
        break;
      case 2:
        authn_level = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
        result = MCoInitializeSecurity( NULL, -1, NULL, NULL,
                                        RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                                        RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                        EOAC_NONE, NULL );
        ASSERT( result, "Could not initialize security to integrity" );
        break;
      case 3:
        authn_level = RPC_C_AUTHN_LEVEL_NONE;
        svc_list.dwAuthnSvc     = RPC_C_AUTHN_WINNT;
        svc_list.dwAuthzSvc     = RPC_C_AUTHZ_NONE;
        svc_list.pPrincipalName = NULL;
        result = MCoInitializeSecurity( NULL, 1, &svc_list, NULL,
                                        RPC_C_AUTHN_LEVEL_NONE,
                                        RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                        EOAC_NONE, NULL );
        ASSERT( result, "Could not initialize security with authentication services" );
        break;
      case 4:
        // Try legacy security by doing nothing.
        authn_level = RPC_C_AUTHN_LEVEL_NONE;
        break;
    }

    // Try all types of servers.
    for (j = 0; j < 5; j++)
    {
      // Create a server.
      result = create_instance( ClassIds[j+k], WhatDest, &server, &id_server );
      ASSERT( result,  "Could not create instance of test server" );
      ASSERT_EXPR( server != NULL, "Create instance returned NULL." );

      // Call it once.
      success = do_security_lazy_call( server, id_server, authn_level,
                                       RPC_C_IMP_LEVEL_IMPERSONATE,
                                       -1, RPC_C_AUTHZ_NONE,
                                       DomainUser );
      if (!success) goto cleanup;
      success = FALSE;

      if (j == 1 || j == 2)
      {
        // Set the security too low.
        result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                    NULL, RPC_C_AUTHN_LEVEL_NONE,
                                    RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                    EOAC_NONE );
        ASSERT( result, "Could not set blanket with authentication level none" );

        // Make a bad call.  Allow the security provider to up the level.
        result = server->secure( id_server, RPC_C_AUTHN_LEVEL_NONE,
                                 RPC_C_IMP_LEVEL_IMPERSONATE,
                                 RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                 NULL, DomainUser, &authn_level_out );
        ASSERT_EXPR( result != S_OK ||
                     (j == 1 && authn_level_out >= RPC_C_AUTHN_LEVEL_CONNECT) ||
                     (j == 2 && authn_level_out >= RPC_C_AUTHN_LEVEL_PKT_INTEGRITY),
                     "Bad call succeeded." );
      }

      // Release it.
      server->Release();
      server = NULL;
    }

    if (ThreadMode == COINIT_APARTMENTTHREADED)
    {
      // Create a local server.
      result = new_apartment( &server, &id_server, NULL, ThreadMode );
      ASSERT( result,  "Could not create local instance of test server" );

      // Make a local call.
      success = do_security_lazy_call( server, id_server, authn_level,
                                       RPC_C_IMP_LEVEL_IMPERSONATE,
                                       RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                       DomainUser );
      if (!success) goto cleanup;
      success = FALSE;

      // Release it.
      server->Release();
      server = NULL;

      // Wait for the helper thread to die.
      wait_apartment();
    }

    // Uninitialize OLE.
    CoUninitialize();

    // Reinitialize OLE.
    result = initialize(NULL,ThreadMode);
    ASSERT( result, "Reinitialize failed" );
  }

  success = TRUE;
cleanup:
  if (server != NULL)
    server->Release();
  return success;
}

/***************************************************************************/
BOOL do_security_call( ITest *server, SAptId id, DWORD authn_level,
                       DWORD imp_level, DWORD authn_svc, DWORD authz_svc,
                       WCHAR *name )
{
  BOOL     success = FALSE;
  HRESULT  result;
  DWORD    authn_level_out;
  DWORD    imp_level_out;
  DWORD    authn_svc_out;
  DWORD    authz_svc_out;
  OLECHAR *princ_name_out = NULL;

  result = MCoSetProxyBlanket( server, authn_svc, authz_svc, NULL,
                              authn_level, imp_level, NULL, EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Verify the authentication information.
  result = MCoQueryProxyBlanket( server, &authn_svc_out, &authz_svc_out,
                                &princ_name_out, &authn_level_out,
                                &imp_level_out, NULL, NULL );
  if (result == S_OK)
  {
    // ASSERT_EXPR( princ_name_out == NULL, "Got a principle name." );
    ASSERT_EXPR( authn_level <= authn_level_out, "Wrong authentication level." );
    ASSERT_EXPR( imp_level == imp_level_out || authn_level == RPC_C_AUTHN_LEVEL_NONE,
                                             "Wrong impersonation level." );
    ASSERT_EXPR( authn_svc == RPC_C_AUTHN_NONE || authn_svc == authn_svc_out, "Wrong authentication service." );
    ASSERT_EXPR( authz_svc == authz_svc_out, "Wrong authorization service." );
  }

  // Make a call.
  result = server->secure( id, authn_level, imp_level, authn_svc, authz_svc,
                           NULL, name, &authn_level_out );
  ASSERT( result, "Secure call failed" );

  success = TRUE;
cleanup:
  CoTaskMemFree( princ_name_out );
  return success;
}

/***************************************************************************/
BOOL do_security_copy( ITest *server, SAptId id )
{
  BOOL     success = FALSE;
  ITest   *copy1   = NULL;
  ITest   *copy2   = NULL;
  ITest   *copy3   = NULL;
  HRESULT  result;

  // Make a copy.
  result = MCoCopyProxy( server, (IUnknown **) &copy1 );
  ASSERT( result, "Could not copy proxy" );

  // Verify that it calls at none.
  success = do_security_lazy_call( copy1, id, RPC_C_AUTHN_LEVEL_NONE,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   -1, RPC_C_AUTHZ_NONE,
                                   DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Verify that the original calls at none.
  success = do_security_lazy_call( server, id, RPC_C_AUTHN_LEVEL_NONE,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   -1, RPC_C_AUTHZ_NONE,
                                   DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Call on the original at connect.
  success = do_security_call( server, id, RPC_C_AUTHN_LEVEL_CONNECT,
                              RPC_C_IMP_LEVEL_IMPERSONATE,
                              RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                              DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Verify that the copy still calls at none.
  success = do_security_lazy_call( copy1, id, RPC_C_AUTHN_LEVEL_NONE,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   -1, RPC_C_AUTHZ_NONE,
                                   DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Call on the copy at encrypt.
  success = do_security_call( copy1, id, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                              RPC_C_IMP_LEVEL_IMPERSONATE,
                              RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                              DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Verify that the original still calls at connect.
  success = do_security_lazy_call( server, id, RPC_C_AUTHN_LEVEL_CONNECT,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                   DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Free the copy.
  copy1->Release();
  copy1 = NULL;

  // Make a copy.
  result = MCoCopyProxy( server, (IUnknown **) &copy1 );
  ASSERT( result, "Could not copy proxy" );

  // Verify that the copy calls at none.
  success = do_security_lazy_call( copy1, id, RPC_C_AUTHN_LEVEL_NONE,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   -1, RPC_C_AUTHZ_NONE,
                                   DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Copy the copy.
  result = MCoCopyProxy( copy1, (IUnknown **) &copy2 );
  ASSERT( result, "Could not copy a copy of a proxy" );

  // Verify the second copy calls at none.
  success = do_security_lazy_call( copy2, id, RPC_C_AUTHN_LEVEL_NONE,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   -1, RPC_C_AUTHZ_NONE,
                                   DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Change the first copy to integrity.
  success = do_security_call( copy1, id, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                              RPC_C_IMP_LEVEL_IMPERSONATE,
                              RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                              DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Change the second copy to encrypt.
  success = do_security_call( copy2, id, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                              RPC_C_IMP_LEVEL_IMPERSONATE,
                              RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                              DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Verify that the original is still connect.
  success = do_security_lazy_call( server, id, RPC_C_AUTHN_LEVEL_CONNECT,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                   DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Querying a copy should return the original.
  result = copy1->QueryInterface( IID_ITest, (void **) &copy3 );
  ASSERT( result, "Could not QueryInterface" );
  ASSERT_EXPR( server == copy3, "QueryInterface did not return the original." );
  copy3->Release();
  copy3 = NULL;

  // Free the original.
  server->Release();
  server = NULL;

  // Free the second copy.
  copy2->Release();
  copy2 = NULL;

  // Make another copy.
  result = MCoCopyProxy( copy1, (IUnknown **) &copy2 );
  ASSERT( result, "Could not copy a copy of a proxy" );

  // Verify that it calls at none.
  success = do_security_lazy_call( copy2, id, RPC_C_AUTHN_LEVEL_NONE,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   -1, RPC_C_AUTHZ_NONE,
                                   DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Query for the original.
  result = copy1->QueryInterface( IID_ITest, (void **) &server );
  ASSERT( result, "Could not QueryInterface" );

  // Verify that it calls at connect.
  success = do_security_lazy_call( server, id, RPC_C_AUTHN_LEVEL_CONNECT,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                   DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  // Verify that the first copy is still at integrity
  success = do_security_lazy_call( copy1, id, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                                   RPC_C_IMP_LEVEL_IMPERSONATE,
                                   RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                   DomainUser );
  if (!success) goto cleanup;
  success = FALSE;

  success = TRUE;
cleanup:
  if (copy1 != NULL)
    copy1->Release();
  if (copy2 != NULL)
    copy2->Release();
  if (copy3 != NULL)
    copy3->Release();
  return success;
}

/***************************************************************************/
#if  (_WIN32_WINNT >= 0x0500 )
BOOL do_security_default( ITest *server, SAptId id )
{
  BOOL    success          = FALSE;
  DWORD   ignore;
  HRESULT result;
  DWORD   authn_svc_out;

  // Set everything default.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_DEFAULT,
                               RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL,
                               RPC_C_AUTHN_LEVEL_DEFAULT,
                               RPC_C_IMP_LEVEL_DEFAULT, COLE_DEFAULT_AUTHINFO,
                               EOAC_DEFAULT );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server->secure( id, RPC_C_AUTHN_LEVEL_NONE,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_NONE,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser, &ignore );
  ASSERT( result, "Secure call failed" );

  // Default the authentication level.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_NONE,
                               RPC_C_AUTHZ_NONE, NULL,
                               RPC_C_AUTHN_LEVEL_DEFAULT,
                               RPC_C_IMP_LEVEL_IDENTIFY, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server->secure( id, RPC_C_AUTHN_LEVEL_NONE,
                           RPC_C_IMP_LEVEL_IDENTIFY, RPC_C_AUTHN_NONE,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser, &ignore );
  ASSERT( result, "Secure call failed" );

  // Default the authentication service.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_DEFAULT,
                               RPC_C_AUTHZ_NONE, NULL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IDENTIFY, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Query the authentication service used.
  result = MCoQueryProxyBlanket( server, &authn_svc_out, NULL, NULL, NULL,
                                 NULL, NULL, NULL );
  ASSERT( result, "Could not queyr blanket" );

  // Make a call.
  result = server->secure( id, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IDENTIFY, authn_svc_out,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser, &ignore );
  ASSERT( result, "Secure call failed" );

  // Default the authorization service.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_DEFAULT, NULL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IDENTIFY, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server->secure( id, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IDENTIFY, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser, &ignore );
  ASSERT( result, "Secure call failed" );

  // Default the impersonation level.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE, NULL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_DEFAULT, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server->secure( id, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser, &ignore );
  ASSERT( result, "Secure call failed" );

  // Default the authid.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE, NULL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IDENTIFY, COLE_DEFAULT_AUTHINFO,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server->secure( id, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IDENTIFY, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser, &ignore );
  ASSERT( result, "Secure call failed" );

  // Default the principal name.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE, COLE_DEFAULT_PRINCIPAL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IDENTIFY, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server->secure( id, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IDENTIFY, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser, &ignore );
  ASSERT( result, "Secure call failed" );

  // Default the capabilities.
  result = server->secure( id, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IDENTIFY, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser, &ignore );
  ASSERT( result, "Secure call failed" );

  // Default the principal name.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT,
                               RPC_C_AUTHZ_NONE, COLE_DEFAULT_PRINCIPAL,
                               RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IDENTIFY, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Default everything but a bad authentication level.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_DEFAULT,
                               RPC_C_AUTHZ_DEFAULT, COLE_DEFAULT_PRINCIPAL,
                               55,
                               RPC_C_IMP_LEVEL_DEFAULT, COLE_DEFAULT_AUTHINFO,
                               EOAC_DEFAULT );
  ASSERT_EXPR( result != S_OK, "Set blanket accepted a bad authentication level" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  return success;
}
#endif

/***************************************************************************/
BOOL do_security_delegate( ITest *server, SAptId id, ITest *server2,
                           SAptId id2 )
{
  BOOL     success = FALSE;
  HRESULT  result;

  // Make a call.
  result = server->delegate( server2, id2, DomainUser );
  ASSERT( result, "Delegate call failed" );

  success = TRUE;
cleanup:
  return success;
}

/***************************************************************************/
BOOL do_security_handle( ITest *server, SAptId id )
{
  BOOL               success          = FALSE;
  HRESULT            result;

  // Make a call with no security.
  success = do_security_call( server, id, RPC_C_AUTHN_LEVEL_NONE,
                              RPC_C_IMP_LEVEL_IMPERSONATE,
                              RPC_C_AUTHN_NONE, RPC_C_AUTHZ_NONE, DomainUser );
  if (!success)
    return FALSE;

  // Make a call with connect security.
  success = do_security_call( server, id, RPC_C_AUTHN_LEVEL_CONNECT,
                              RPC_C_IMP_LEVEL_IMPERSONATE,
                              RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, DomainUser );
  if (!success)
    return FALSE;

  // Make a call with integrity security.
  success = do_security_call( server, id, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                              RPC_C_IMP_LEVEL_IMPERSONATE,
                              RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, DomainUser );
  if (!success)
    return FALSE;


  // Make a call with encrypt security.
  success = do_security_call( server, id, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                              RPC_C_IMP_LEVEL_IMPERSONATE,
                              RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, DomainUser );
  if (!success)
    return FALSE;

  // Make a call with no security.
  // BUGBUG - Win95 doesn't support identify yet.
  if (!Win95)
    success = do_security_call( server, id, RPC_C_AUTHN_LEVEL_NONE,
                                RPC_C_IMP_LEVEL_IDENTIFY,
                                RPC_C_AUTHN_NONE, RPC_C_AUTHZ_NONE, DomainUser );
  if (!success)
    return FALSE;

  // Make a call with connect security.
  // BUGBUG - Win95 doesn't support identify yet.
  if (!Win95)
    success = do_security_call( server, id, RPC_C_AUTHN_LEVEL_CONNECT,
                                RPC_C_IMP_LEVEL_IDENTIFY,
                                RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, DomainUser );
  if (!success)
    return FALSE;

  // Make a call with integrity security.
  // BUGBUG - Win95 doesn't support identify yet.
  if (!Win95)
    success = do_security_call( server, id, RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,
                                RPC_C_IMP_LEVEL_IDENTIFY,
                                RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, DomainUser );
  if (!success)
    return FALSE;


  // Make a call with encrypt security.
  // BUGBUG - Win95 doesn't support identify yet.
  if (!Win95)
    success = do_security_call( server, id, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                RPC_C_IMP_LEVEL_IDENTIFY,
                                RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, DomainUser );
  if (!success)
    return FALSE;

/*
  // Try to release IServerSecurity too many times.
  result = server->by_the_way( release_too_much_btw );
  if (result != RPC_E_SERVERFAULT)
  {
    printf( "Too many releases of IServerSecurity did not fail: 0x%x\n", result );
    return FALSE;
  }
*/

  // Finally, its all over.
  return TRUE;
}

/***************************************************************************/
BOOL do_security_lazy_call( ITest *server, SAptId id, DWORD authn_level,
                            DWORD imp_level, DWORD authn_svc, DWORD authz_svc,
                            WCHAR *name )
{
  BOOL     success = FALSE;
  HRESULT  result;
  DWORD    authn_level_out;
  DWORD    imp_level_out;
  DWORD    authn_svc_out;
  DWORD    authz_svc_out;
  OLECHAR *princ_name_out = NULL;

  // Verify the authentication information.
  result = MCoQueryProxyBlanket( server, &authn_svc_out, &authz_svc_out,
                                &princ_name_out, &authn_level_out,
                                &imp_level_out, NULL, NULL );
  if (result == S_OK)
  {
    // ASSERT_EXPR( princ_name_out == NULL, "Got a principle name." );
    ASSERT_EXPR( authn_level <= authn_level_out, "Wrong authentication level." );
    ASSERT_EXPR( imp_level == imp_level_out || authn_level == RPC_C_AUTHN_LEVEL_NONE,
                                             "Wrong impersonation level." );
    ASSERT_EXPR( authn_svc == -1 || authn_svc == authn_svc_out, "Wrong authentication service." );
    ASSERT_EXPR( authz_svc == authz_svc_out, "Wrong authorization service." );
  }

  // Make a call.
  result = server->secure( id, authn_level, imp_level, authn_svc, authz_svc,
                           NULL, name, &authn_level_out );
  ASSERT( result, "Secure call failed" );

  success = TRUE;
cleanup:
  CoTaskMemFree( princ_name_out );
  return success;
}

/***************************************************************************/
BOOL do_security_nested( ITest *server, SAptId id )
{
  HRESULT          result;
  ITest           *test;
  BOOL             success    = FALSE;
  IServerSecurity *security   = NULL;
  PSID             me         = NULL;

  // Create a test object.
  test = new CTest;
  ASSERT_EXPR( test != NULL, "Could not create object" );

  // Make a recursive call.  The proxy is set to encrypt from the previous test.
  result = server->recurse_secure( test, 3, 1, DomainUser );
  ASSERT( result, "Could not make recursive call with impersonation." );

  // Try to get call context.
  result = MCoGetCallContext( IID_IServerSecurity, (void **) &security );
  ASSERT_EXPR( result != S_OK, "Get call context succeeded outside a call." );

  // Check the thread's token.
  if (!Win95)
  {
    result = check_token( DomainUser, NULL, -1 );
    ASSERT( result, "Wrong token after call." );
  }

  success = TRUE;
cleanup:
  if (security != NULL)
    security->Release();
  if (test != NULL)
    test->Release();
  return success;
}

/***************************************************************************/
void do_send()
{
  LRESULT   result;

  // Say hello.
  printf( "Sending a message to window 0x%x\n", NumIterations );
  result = SendMessageA( (HWND) NumIterations, WM_USER, 0, 0 );

  if (result == 0)
    printf( "\n\nSendMessageA succeeded.\n" );
  else
    printf( "\n\nSendMessageA failed: 0x%x\n", result );
}

/***************************************************************************/
void do_server(  )
{
  HRESULT                      result;
  BOOL                         success  = FALSE;
  SOLE_AUTHENTICATION_SERVICE  svc_list;

  // Initialize OLE.
  hello( "server" );
  printf( "Initializing thread 0x%x\n", GetCurrentThreadId() );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );
  result = initialize_security();
  ASSERT( result, "Could not initialize security" );

  // Create our class factory
  ClassFactory = new CTestCF();
  ASSERT_EXPR( ClassFactory != NULL, "Could not create class factory." );

  // Register our class with OLE
  result = CoRegisterClassObject(get_class(any_wc), ClassFactory, CLSCTX_LOCAL_SERVER,
      REGCLS_SINGLEUSE, &Registration);
  ASSERT( result, "CoRegisterClassObject failed" );

  // CoRegister bumps reference count so we don't have to!
  ClassFactory->Release();

  // Do whatever we have to do till it is time to pay our taxes and die.
  server_loop();

  // Deregister out class - should release object as well
  if (!dirty_thread())
  {
    result = CoRevokeClassObject(Registration);
    ASSERT( result, "CoRevokeClassObject failed" );
  }

  success = TRUE;
cleanup:
  if (!dirty_thread())
  {
    printf( "Uninitializing thread 0x%x\n", GetCurrentThreadId() );
    CoUninitialize();
  }
  else
    printf( "\n\nI didn't clean up\n" );

  if (success)
    printf( "\n\nServer Passed.\n" );
  else
    printf( "\n\nServer Failed.\n" );
}


/***************************************************************************/
void do_sid()
{
  BOOL                 success       = FALSE;
  BOOL                 call_success;
  SID                 *pSID           = NULL;
  DWORD                cbSID         = 1024;
  WCHAR               *lpszDomain    = NULL;
  DWORD                cchDomainName = 80;
  SID_NAME_USE         sid_use;
  HRESULT              result        = S_OK;
  DWORD                i;

  // Say hello.
  printf( "Looking up sid for %ws.\n", Name );

  // Lookup the name.
  pSID       = (SID *) LocalAlloc(LPTR, cbSID*2);
  lpszDomain = (WCHAR *) LocalAlloc(LPTR, cchDomainName*2);
  ASSERT_EXPR( pSID != NULL && lpszDomain != NULL, "LocalAlloc" );
  call_success = LookupAccountName(NULL,
          Name,
          pSID,
          &cbSID,
          lpszDomain,
          &cchDomainName,
          &sid_use);
  result = GetLastError();
  if (!call_success)
    ASSERT( result, "Could not LookupAccountName" );
  ASSERT_EXPR( IsValidSid(pSID), "Got a bad SID." );
  printf( "SID\n" );
  printf( "     Revision:            0x%02x\n", pSID->Revision );
  printf( "     SubAuthorityCount:   0x%x\n", pSID->SubAuthorityCount );
  printf( "     IdentifierAuthority: 0x%02x%02x%02x%02x%02x%02x\n",
          pSID->IdentifierAuthority.Value[0],
          pSID->IdentifierAuthority.Value[1],
          pSID->IdentifierAuthority.Value[2],
          pSID->IdentifierAuthority.Value[3],
          pSID->IdentifierAuthority.Value[4],
          pSID->IdentifierAuthority.Value[5] );
  for (i = 0; i < pSID->SubAuthorityCount; i++)
    printf( "     SubAuthority[%d]:     0x%08x\n", i,
            pSID->SubAuthority[i] );
  printf( " Domain: %ws\n", lpszDomain );
  printf( " SID_NAME_USE: 0x%x\n", sid_use );

  success = TRUE;
cleanup:
  if (lpszDomain != NULL)
    LocalFree((HLOCAL) lpszDomain);
  if (pSID != NULL)
    LocalFree(pSID);

  if (success)
    printf( "\n\nSid succeeded.\n" );
  else
    printf( "\n\nSid failed.\n" );
}

/***************************************************************************/
void do_simple_rundown()
{
  BOOL      success = FALSE;
  ITest    *client1 = NULL;
  CTest    *local  = NULL;
  SAptId    id1;
  SAptId    local_id;
  HRESULT   result;

  // Initialize OLE.
  hello( "simple rundown" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a server
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client1 );
  ASSERT( result,  "Could not create server" );
  result = client1->get_id( &id1 );
  ASSERT( result, "Could not get id" );

  // Create a local object.
  local = new CTest;
  ASSERT_EXPR( local != NULL, "Could not create a local object." );
  result = local->get_id( &local_id );
  ASSERT( result, "Could not get id" );

  // Tell it to remember this object.
  result = client1->remember( local, local_id );
  ASSERT( result, "Could not remember local object" );
  local->Release();
  local = NULL;

  // Tell the other apartment to die.
  result = client1->set_state( dirty_s, THREAD_PRIORITY_NORMAL );
  ASSERT( result, "Could not set exit dirty" );
  result = client1->exit();

  // Wait araound till no one references the local object.
  printf( "Wait for object to rundown.  This could take 12 minutes.\n" );
  server_loop();

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (client1 != NULL)
    client1->Release();
  if (local != NULL)
    local->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nSimple Rundown Test Passed.\n" );
  else
    printf( "\n\nSimple Rundown Test Failed.\n" );
}

/***************************************************************************/
void do_snego()
{
#if  (_WIN32_WINNT >= 0x0500 )
  BOOL               success          = FALSE;
  ITest             *server           = NULL;
  SAptId             id_server;
  HRESULT            result;
  DWORD              ignore;
  SEC_WINNT_AUTH_IDENTITY_EXW auth_id;
  DWORD                authn_svc;
  DWORD                authz_svc;
  DWORD                authn_level;
  DWORD                imp_level;
  DWORD                capabilities;
  WCHAR               *principal        = NULL;
  SEC_WINNT_AUTH_IDENTITY_EXW *auth_id_out = NULL;

  // Only run on NT 5.
  if (!NT5)
  {
    printf( "Snego test can only run on NT 5.\n" );
    return;
  }

  // Initialize OLE.
  hello( "snego" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );
  result = initialize_security();
  ASSERT( result, "Could not initialize security" );

  // Create a client.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result,  "Could not create instance of test server" );

  // Get the security blanket.
  result = MCoQueryProxyBlanket( server, &authn_svc, &authz_svc, &principal,
                                &authn_level, &imp_level,
                                (void **) &auth_id_out, &capabilities );
  ASSERT( result, "Could not query blanket" );

  if (Change)
  {
    // Make a secure call with default security.
    result = server->secure( id_server, RPC_C_AUTHN_LEVEL_CONNECT,
                             RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_GSS_NEGOTIATE,
                             RPC_C_AUTHZ_NONE, NULL, DomainUser,
                             &ignore );
    if (result != S_OK)
      printf( "Default secure call failed: 0x%x\n", result );
    result = S_OK;

    // Set the blanket to NTLMSSP
    result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                                 NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                 EOAC_NONE );
    ASSERT( result, "Could not set blanket" );

    // Make a secure call.
    result = server->secure( id_server, RPC_C_AUTHN_LEVEL_CONNECT,
                             RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                             RPC_C_AUTHZ_NONE, NULL, DomainUser,
                             &ignore );
    if (result != S_OK)
      printf( "Secure call with ntlmsssp failed: 0x%x\n", result );
    result = S_OK;

    // Make a secure call with redmond principal name.
    result = server->secure( id_server, RPC_C_AUTHN_LEVEL_CONNECT,
                             RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                             RPC_C_AUTHZ_NONE, NULL, L"redmond\\alexarm",
                             &ignore );
    if (result != S_OK)
      printf( "Secure call with ntlmsssp and redmond\\alexarm failed: 0x%x\n", result );
    result = S_OK;

    // Set the blanket to kerberos
    result = MCoSetProxyBlanket( server, RPC_C_AUTHN_GSS_KERBEROS, RPC_C_AUTHZ_NAME,
                                 DomainUser, RPC_C_AUTHN_LEVEL_CONNECT,
                                 RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                 EOAC_NONE );
    ASSERT( result, "Could not set blanket" );

    // Make a secure call.
    result = server->secure( id_server, RPC_C_AUTHN_LEVEL_CONNECT,
                             RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_GSS_KERBEROS,
                             RPC_C_AUTHZ_NONE, NULL, DomainUser,
                             &ignore );
    if (result != S_OK)
      printf( "Secure call with kerberos failed: 0x%x\n", result );
    result = S_OK;
  }

  // Fill in the authentication identity.
  auth_id.User              = NULL;
  auth_id.UserLength        = 0;
  auth_id.Domain            = NULL;
  auth_id.DomainLength      = 0;
  auth_id.Password          = NULL;
  auth_id.PasswordLength    = 0;
  auth_id.Flags             = SEC_WINNT_AUTH_IDENTITY_UNICODE;
  auth_id.Version           = SEC_WINNT_AUTH_IDENTITY_VERSION;
  auth_id.Length            = sizeof(auth_id);
  auth_id.PackageList       = PackageList;
  auth_id.PackageListLength = sizeof(WCHAR) * (wcslen(PackageList)+1);

  // Tell snego what authentication services to try.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_GSS_NEGOTIATE, RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, &auth_id,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a secure call.
  result = server->secure( id_server, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_GSS_NEGOTIATE,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser,
                           &ignore );
  ASSERT( result, "Secure call with authn svc list failed" );

  // Tell snego what authentication services to try.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_GSS_NEGOTIATE, RPC_C_AUTHZ_NONE,
                               DomainUser, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, &auth_id,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a secure call.
  result = server->secure( id_server, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_GSS_NEGOTIATE,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser,
                           &ignore );
  ASSERT( result, "Secure call with authn svc list failed" );

  // Set authentication service to snego.
  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_GSS_NEGOTIATE, RPC_C_AUTHZ_NONE,
                               principal, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a call.
  result = server->secure( id_server, RPC_C_AUTHN_LEVEL_CONNECT,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_GSS_NEGOTIATE,
                           RPC_C_AUTHZ_NONE, NULL, DomainUser,
                           &ignore );
  ASSERT( result, "Secure call failed" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (principal != NULL)
    CoTaskMemFree( principal );
  if (server != NULL)
    server->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nSnego Test Passed.\n" );
  else
    printf( "\n\nSnego Test Failed.\n" );
#else
  printf( "Snego test can only run on NT 5.\n" );
#endif
}

/***************************************************************************/
void do_ssl()
{
#if  (_WIN32_WINNT >= 0x0500 )
  BOOL              success     = FALSE;
  ITest            *server      = NULL;
  ITest            *server2     = NULL;
  ITest            *server3     = NULL;
  SAptId            id_server;
  SAptId            id_server2;
  SAptId            id_server3;
  HRESULT           result;
  HCRYPTPROV        prov        = 0;
  DWORD             len;
  HCERTSTORE        cert_store  = NULL;
  HCERTSTORE        root_store  = NULL;
  HCERTSTORE        trust_store  = NULL;
  PCCERT_CONTEXT    prev_cert   = NULL;
  PCCERT_CONTEXT    cert        = NULL;
  PCCERT_CONTEXT    parent      = NULL;
  PCCERT_CONTEXT    last        = NULL;
  CERT_NAME_BLOB   *subject;
  CERT_NAME_BLOB   *issuer;
  WCHAR            *name        = NULL;
  DWORD             ignore;
  UCHAR            *buffer      = NULL;
  SOLE_AUTHENTICATION_SERVICE  svc_list[3];
  SOLE_AUTHENTICATION_LIST     auth_list;
  SOLE_AUTHENTICATION_INFO     auth_info[3];
  SEC_WINNT_AUTH_IDENTITY_W    ntlm;
  SEC_WINNT_AUTH_IDENTITY_W    kerb;
  BOOL                         top;
  WCHAR                       *principal = NULL;
  COSERVERINFO                 server_machine;
  MULTI_QI                     server_instance;

  // Only run on NT 5.
  if (!NT5)
  {
    printf( "SSL test can only run on NT 5.\n" );
    return;
  }

  // Say hello.
  hello( "ssl" );

  // Get the default full provider.
  success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL, 0 );
  ASSERT_GLE( success, NTE_BAD_KEYSET, "Could not acqure full context." );

  // If there is no container, create one.
  if (!success)
  {
    success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET );
    ASSERT_GLE( success, S_OK, "Could not acqure full context." );
  }
  success = FALSE;

  // Call CertOpenSystemStore to open the store.
  cert_store = CertOpenSystemStore(prov, L"my" );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting System Store Handle" );

  // Call CertOpenSystemStore to open the root store.
  root_store = CertOpenSystemStore(prov, L"root" );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting root Store Handle" );
  prov = 0;

  // Call CertOpenSystemStore to open the trust store.
  trust_store = CertOpenSystemStore(prov, L"trust" );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting trust Store Handle" );

  // Look to see if the certificate is already installed.
  cert = CertFindCertificateInStore( cert_store,
                                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                     0,
                                     CERT_FIND_SUBJECT_STR,
                                     CERT_DCOM,
                                     NULL );
  ASSERT_GLE( cert != NULL, S_OK, "Could not find certificate in store" );

  // Print the fullsic principal name for the certificate.
  result = RpcCertGeneratePrincipalName( cert, RPC_C_FULL_CERT_CHAIN, &principal );
  if (result != 0)
    printf( "Could not generate fullsic principal name: 0x%x\n", result );
  else
    printf( "Fullsic: <%ws>\n", principal );

  // Free the string.
  result = RpcStringFree( &principal );
  ASSERT( result, "Could not free principal" );

  // Print the standard principal name for the certificate.
  result = RpcCertGeneratePrincipalName( cert, 0, &principal );
  if (result != 0)
    printf( "Could not generate standard principal name: 0x%x\n", result );
  else
    printf( "Standard: <%ws>\n", principal );

  // Initialize OLE.
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Initialize security with the default certificate.
  svc_list[0].dwAuthnSvc     = RPC_C_AUTHN_GSS_SCHANNEL;
  svc_list[0].dwAuthzSvc     = RPC_C_AUTHZ_NONE;
  svc_list[0].pPrincipalName = NULL;
  result = MCoInitializeSecurity( NULL, 1, svc_list, NULL, GlobalAuthnLevel,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_NONE, NULL );
  ASSERT( result, "Could not initialize security with default SSL server cert" );

  // Reinitialize.
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Specify the server certificate.
  svc_list[0].dwAuthnSvc     = RPC_C_AUTHN_GSS_SCHANNEL;
  svc_list[0].dwAuthzSvc     = RPC_C_AUTHZ_NONE;
  svc_list[0].pPrincipalName = (WCHAR *) cert;
  svc_list[1].dwAuthnSvc     = RPC_C_AUTHN_WINNT;
  svc_list[1].dwAuthzSvc     = RPC_C_AUTHZ_NONE;
  svc_list[1].pPrincipalName = NULL;
  svc_list[2].dwAuthnSvc     = RPC_C_AUTHN_GSS_KERBEROS;
  svc_list[2].dwAuthzSvc     = RPC_C_AUTHZ_NONE;
  svc_list[2].pPrincipalName = DomainUser;

  // Specify all the authentication info.
  auth_list.cAuthInfo     = 3;
  auth_list.aAuthInfo     = auth_info;
  auth_info[0].dwAuthnSvc = RPC_C_AUTHN_GSS_SCHANNEL;
  auth_info[0].dwAuthzSvc = RPC_C_AUTHZ_NONE;
  auth_info[0].pAuthInfo  = (void *) cert;
  auth_info[1].dwAuthnSvc = RPC_C_AUTHN_WINNT;
  auth_info[1].dwAuthzSvc = RPC_C_AUTHZ_NONE;
  auth_info[1].pAuthInfo  = &ntlm;
  auth_info[2].dwAuthnSvc = RPC_C_AUTHN_GSS_KERBEROS;
  auth_info[2].dwAuthzSvc = RPC_C_AUTHZ_NONE;
  auth_info[2].pAuthInfo  = &kerb;
  ntlm.User               = L"oleuser";
  ntlm.UserLength         = wcslen(ntlm.User);
  ntlm.Domain             = L"redmond";
  ntlm.DomainLength       = wcslen(ntlm.Domain);
  ntlm.Password           = OleUserPassword;
  ntlm.PasswordLength     = wcslen(ntlm.Password);
  ntlm.Flags              = SEC_WINNT_AUTH_IDENTITY_UNICODE;
  kerb.User               = L"oleuser2";
  kerb.UserLength         = wcslen(kerb.User);
  kerb.Domain             = L"ntdev";
  kerb.DomainLength       = wcslen(kerb.Domain);
  kerb.Password           = OleUserPassword;
  kerb.PasswordLength     = wcslen(kerb.Password);
  kerb.Flags              = SEC_WINNT_AUTH_IDENTITY_UNICODE;

  // Initialize security with the extra authentication info.
  result = MCoInitializeSecurity( NULL, 3, svc_list, NULL,
                                  RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, &auth_list,
                                  EOAC_NONE, NULL );
  ASSERT( result, "Could not initialize security with auth info" );

  // Create a server.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result,  "Could not create instance of test server" );

  // Create a server.
  result = create_instance( get_class(any_wc), WhatDest, &server2, &id_server2 );
  ASSERT( result,  "Could not create instance of test server" );

  // Create a server.
  result = create_instance( get_class(any_wc), WhatDest, &server3, &id_server3 );
  ASSERT( result,  "Could not create instance of test server" );

  // Tell the first server to reinitialize with just NTLM.
  result = server->reinitialize( RPC_C_AUTHN_WINNT );
  ASSERT( result, "Could not reinitialize" );

  // Wait for the reinitialize to complete.
  printf( "Waiting 3 seconds for server to reinitialize.\n" );
  Sleep( 3000 );

  // Release the old proxy.
  server->Release();
  server = NULL;

  // Get a new proxy.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id_server );
  ASSERT( result,  "Could not create instance of test server using NTLM" );

  // Tell the second server to reinitialize with just Kerberos.
  result = server2->reinitialize( RPC_C_AUTHN_GSS_KERBEROS );
  ASSERT( result, "Could not reinitialize" );

  // Wait for the reinitialize to complete.
  printf( "Waiting 3 seconds for server to reinitialize.\n" );
  Sleep( 3000 );

  // Release the old proxy.
  server2->Release();
  server2 = NULL;

  // Get a new proxy.
  result = create_instance( get_class(any_wc), WhatDest, &server2, &id_server2 );
  if (result != S_OK)
    printf( "Could not create instance of test server using Kerberos, oh well: 0x%x\n", result );

  // Tell the third server to reinitialize with just SSL.
  result = server3->reinitialize( RPC_C_AUTHN_GSS_SCHANNEL );
  ASSERT( result, "Could not reinitialize" );

  // Wait for the reinitialize to complete.
  printf( "Waiting 3 seconds for server to reinitialize.\n" );
  Sleep( 3000 );

  // Release the old proxy.
  server3->Release();
  server3 = NULL;

  // Get a new proxy.
  result = create_instance( get_class(any_wc), WhatDest, &server3, &id_server3 );
  ASSERT( result,  "Could not create instance of test server using SSL" );

  // Make a secure call that should default to NTLM.
  result = server->secure( id_server, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                           RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE, NULL, L"redmond\\oleuser",
                           &ignore );
  ASSERT( result, "Secure call with ntlmsssp failed" );

  // Make a secure call that should default to Kerberos.
  result = server2->secure( id_server2, RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_GSS_KERBEROS,
                            RPC_C_AUTHZ_NONE, NULL, L"Redmond\\oleuser2",
                            &ignore );
  if (result != S_OK)
    printf( "Secure call with Kerberos failed: 0x%x\n", result );
  result = S_OK;

  // Make a secure call that should default to SSL.
  result = server3->secure( id_server3, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                            RPC_C_IMP_LEVEL_IMPERSONATE, RPC_C_AUTHN_GSS_SCHANNEL,
                            RPC_C_AUTHZ_NONE, NULL,
                            principal, &ignore );
  ASSERT( result, "Secure call with SSL failed" );

  // Set the blanket to SSL
  result = MCoSetProxyBlanket( server3, RPC_C_AUTHN_GSS_SCHANNEL,
                               RPC_C_AUTHZ_NONE,
                               principal, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a secure call.
  result = server3->secure( id_server3, RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            RPC_C_AUTHN_GSS_SCHANNEL,
                            RPC_C_AUTHZ_NONE, NULL, principal,
                            &ignore );
  ASSERT( result, "Secure call with SSL failed" );

  // Tell the proxy to use SSL with no principal
  result = MCoSetProxyBlanket( server3, RPC_C_AUTHN_GSS_SCHANNEL,
                               RPC_C_AUTHZ_NONE,
                               NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Make a secure call.
  result = server3->secure( id_server3, RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            RPC_C_AUTHN_GSS_SCHANNEL,
                            RPC_C_AUTHZ_NONE, NULL, principal,
                            &ignore );
  ASSERT( result, "Secure call with SSL and no principal name failed" );

  // Tell the proxy to use SSL with a client certificate.
  result = MCoSetProxyBlanket( server3, RPC_C_AUTHN_GSS_SCHANNEL,
                               RPC_C_AUTHZ_NONE,
                               principal, RPC_C_AUTHN_LEVEL_CONNECT,
                               RPC_C_IMP_LEVEL_IMPERSONATE, (void *) cert,
                               EOAC_NONE );
  ASSERT( result, "Could not set blanket with client cert" );

  // Make a secure call.
  result = server3->secure( id_server3, RPC_C_AUTHN_LEVEL_CONNECT,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            RPC_C_AUTHN_GSS_SCHANNEL,
                            RPC_C_AUTHZ_NONE, NULL, principal,
                            &ignore );
  ASSERT( result, "Secure call with SSL and no principal name failed" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (principal != NULL)
    RpcStringFree( &principal );
  if (buffer != NULL)
    CoTaskMemFree( buffer );
  if (cert != NULL)
    CertFreeCertificateContext(cert);
  if (parent != NULL)
    CertFreeCertificateContext(parent);
  if (prev_cert != NULL)
    CertFreeCertificateContext(prev_cert);
  if (last != NULL)
    CertFreeCertificateContext(last);
  if (cert_store != NULL)
    CertCloseStore( cert_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (root_store != NULL)
    CertCloseStore( root_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (trust_store != NULL)
    CertCloseStore( trust_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (prov != 0 )
    CryptReleaseContext( prov, 0 );
  if (server != NULL)
    server->Release();
  if (server2 != NULL)
    server2->Release();
  if (server3 != NULL)
    server3->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nSSL Test Passed.\n" );
  else
    printf( "\n\nSSL Test Failed.\n" );
#else
  printf( "SSL test can only run on NT 5.\n" );
#endif
}

/***************************************************************************/
void do_thread()
{
  BOOL      success = FALSE;
  ITest    *client1 = NULL;
  ITest    *client2 = NULL;
  ITest    *client3 = NULL;
  ITest    *client4 = NULL;
  SAptId    id1;
  SAptId    id2;
  SAptId    id4;
  HRESULT   result;
  GUID      guid;

  // Initialize OLE.
  hello( "thread" );
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Create a client on this thread.
  client3 = new CTest;
  ASSERT_EXPR( client3 != NULL, "Could not create a local object." );

  // Create a client on another thread in this process
  result = client3->get_obj_from_new_apt( &client4, &id4 );
  ASSERT( result, "Could not get in process client" );

  // Create a server
  result = CoCreateInstance( get_class(any_wc), NULL, CLSCTX_LOCAL_SERVER,
                             IID_ITest, (void **) &client1 );
  ASSERT( result,  "Could not create instance of test server" );
  result = client1->get_id( &id1 );
  ASSERT( result, "Could not get id of server" );

  // Create an object in another apartment in the server.
  result = client1->get_obj_from_new_apt( &client2, &id2 );
  ASSERT( result, "Could not get in process server" );

  // Check each object.
  result = client1->check( id1 );
  ASSERT( result, "Could not check server 1" );
  result = client2->check( id2 );
  ASSERT( result, "Could not check server 2" );

  // Pass a server to the other thread in this process.
  result = client4->remember( client1, id1 );
  ASSERT( result, "Client could not remember server" );

  // Release the second object.
  client2->Release();
  client2 = NULL;

  // Check the first object.
  result = client1->check( id1 );
  ASSERT( result, "Could not check server 1" );

  // Check the first object from another thread.
  result = client4->call_next();
  ASSERT( result, "Could not check server 1 from thread 2" );

  // Release the first object from this thread.
  client1->Release();
  client1 = NULL;

  // Check the first object from another thread.
  result = client4->call_next();
  ASSERT( result, "Could not check server 1 from thread 2" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (client2 != NULL)
    client2->Release();
  if (client1 != NULL)
    client1->Release();
  if (client3 != NULL)
    client3->Release();
  if (client4 != NULL)
    client4->Release();
  wait_apartment();
  CoUninitialize();

  if (success)
    printf( "\n\nThread Test Passed.\n" );
  else
    printf( "\n\nThread Test Failed.\n" );
}

/***************************************************************************/
void do_three()
{
/*
  BOOL              success     = FALSE;
  ITest            *server      = NULL;
  ITest            *server2     = NULL;
  ITest            *server3     = NULL;
  SAptId            id_server;
  SAptId            id_server2;
  SAptId            id_server3;
  HRESULT           result;
  HCRYPTPROV        prov        = 0;
  DWORD             len;
  HCERTSTORE        cert_store  = NULL;
  HCERTSTORE        root_store  = NULL;
  HCERTSTORE        trust_store  = NULL;
  PCCERT_CONTEXT    prev_cert   = NULL;
  PCCERT_CONTEXT    cert        = NULL;
  PCCERT_CONTEXT    parent      = NULL;
  PCCERT_CONTEXT    last        = NULL;
  CERT_NAME_BLOB   *subject;
  CERT_NAME_BLOB   *issuer;
  WCHAR            *name        = NULL;
  DWORD             ignore;
  UCHAR            *buffer      = NULL;
  SOLE_AUTHENTICATION_SERVICE  svc_list[3];
  SOLE_AUTHENTICATION_LIST     auth_list;
  SOLE_AUTHENTICATION_INFO     auth_info[3];
  SEC_WINNT_AUTH_IDENTITY_W    ntlm;
  SEC_WINNT_AUTH_IDENTITY_W    kerb;
  BOOL                         top;
  WCHAR                       *principal = NULL;
  COSERVERINFO                 server_machine;
  MULTI_QI                     server_instance;
  CERT_CHAIN_PARA              chain_para;
  const CERT_CHAIN_CONTEXT    *chain     = NULL;
  CERT_CHAIN_POLICY_PARA       policy;
  CERT_CHAIN_POLICY_STATUS     status;

  // Only run on NT 5.
  if (!NT5)
  {
    printf( "SSL test can only run on NT 5.\n" );
    return;
  }

  // Say hello.
  hello( "three" );

  // Get the default full provider.
  success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL, 0 );
  ASSERT_GLE( success, NTE_BAD_KEYSET, "Could not acqure full context." );

  // If there is no container, create one.
  if (!success)
  {
    success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET );
    ASSERT_GLE( success, S_OK, "Could not acqure full context." );
  }
  success = FALSE;

  // Call CertOpenSystemStore to open the store.
  cert_store = CertOpenSystemStore(prov, UserName );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting System Store Handle" );

  // Call CertOpenSystemStore to open the root store.
  root_store = CertOpenSystemStore(prov, L"root" );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting root Store Handle" );
  prov = 0;

  // Call CertOpenSystemStore to open the trust store.
  trust_store = CertOpenSystemStore(prov, L"trust" );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting trust Store Handle" );
  prov = 0;

  // Look to see if the certificate is already installed.
  cert = CertFindCertificateInStore( cert_store,
                                     X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                     0,
                                     CERT_FIND_SUBJECT_STR,
                                     CERT_DCOM,
                                     NULL );
  if (cert == NULL)
    printf( "Could not find certificate in store: 0x%x\n", GetLastError() );

  // Write the test certificate to the store.
  if (cert == NULL)
  {
    success = CertAddSerializedElementToStore( cert_store,
                                         Cert20,
                                         sizeof(Cert20),
                                         CERT_STORE_ADD_REPLACE_EXISTING,
                                         0,
                                         CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                         NULL,
                                         (const void **) &cert );
    ASSERT_GLE( success, S_OK, "Could not add serialized certificate to store" );
    success = FALSE;

    // Write the test certificate issuer to the cert store.
    success = CertAddSerializedElementToStore( root_store,
                                         CertSrv2,
                                         sizeof(CertSrv2),
                                         CERT_STORE_ADD_REPLACE_EXISTING,
                                         0,
                                         CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                         NULL,
                                         NULL );
    if (!success)
      printf( "Could not write CA certificate: 0x%x\n", GetLastError() );
//    ASSERT_GLE( success, S_OK, "Could not add serialized certificate to store" );
    success = FALSE;
  }

  // Get the certificate chain.
  chain_para.RequestedUsage.Usage.cUsageIdentifier     = 0;
  chain_para.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;
  chain_para.RequestedUsage.dwType                     = USAGE_MATCH_TYPE_AND;
  chain_para.cbSize                                    = sizeof(chain_para);
  success = CertGetCertificateChain( NULL, cert, NULL, NULL, &chain_para,
                                     CERT_CHAIN_REVOCATION_CHECK_CHAIN, NULL,
                                     &chain );
  ASSERT_GLE( success, S_OK, "Could not get certificate chain" );
  success = FALSE;

  // Verify that the certificate is valid.
  policy.cbSize              = sizeof(policy);
  policy.dwFlags             = 0;
  policy.pvExtraPolicyPara   = NULL;
  status.cbSize              = sizeof(status);
  status.pvExtraPolicyStatus = NULL;
  success = CertVerifyCertificateChainPolicy( CERT_CHAIN_POLICY_SSL,
                                              chain, &policy, &status );
  ASSERT_EXPR( success, "Could not verify certificate chain" );
  success = FALSE;

  // Print the fullsic principal name for the certificate.
  result = RpcCertGeneratePrincipalName( cert, RPC_C_FULL_CERT_CHAIN, &principal );
  if (result != 0)
    printf( "Could not generate fullsic principal name: 0x%x\n", result );
  else
    printf( "Fullsic: <%ws>\n", principal );

  // Free the string.
  result = RpcStringFree( &principal );
  ASSERT( result, "Could not free principal" );

  // Print the standard principal name for the certificate.
  result = RpcCertGeneratePrincipalName( cert, 0, &principal );
  if (result != 0)
    printf( "Could not generate standard principal name: 0x%x\n", result );
  else
    printf( "Standard: <%ws>\n", principal );

  // Initialize OLE.
  result = initialize(NULL,ThreadMode);
  ASSERT( result, "Initialize failed" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (chain != NULL)
    CertFreeCertificateChain( chain );
  if (principal != NULL)
    RpcStringFree( &principal );
  if (buffer != NULL)
    CoTaskMemFree( buffer );
  if (cert != NULL)
    CertFreeCertificateContext(cert);
  if (parent != NULL)
    CertFreeCertificateContext(parent);
  if (prev_cert != NULL)
    CertFreeCertificateContext(prev_cert);
  if (last != NULL)
    CertFreeCertificateContext(last);
  if (cert_store != NULL)
    CertCloseStore( cert_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (root_store != NULL)
    CertCloseStore( root_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (trust_store != NULL)
    CertCloseStore( trust_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (prov != 0 )
    CryptReleaseContext( prov, 0 );
  if (server != NULL)
    server->Release();
  if (server2 != NULL)
    server2->Release();
  if (server3 != NULL)
    server3->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nThree Test Passed.\n" );
  else
    printf( "\n\nThree Test Failed.\n" );
*/
}

/***************************************************************************/
void sid_to_str( SID *sid, WCHAR *str )
{
    wsprintf( str, L"S-1-5-%d-%d-%d-%d-%d", sid->SubAuthority[0],
      sid->SubAuthority[1], sid->SubAuthority[2], sid->SubAuthority[3],
      sid->SubAuthority[4] );
}

void do_two()
{
  BOOL               success          = FALSE;
  HRESULT            result;
  HANDLE             user             = NULL;
  HANDLE             iuser            = NULL;
  HKEY               profile_key      = NULL;
  WCHAR              sid[256];
  SID_NAME_USE       use;
  DWORD              size             = 256;
  WCHAR              domain[256];
  DWORD              domain_size      = 256;
  WCHAR              sid_str[256];

  // Initialize.
  hello( "two" );

  // Logon the user
  success = LogonUser( Name, Name2, L"", LOGON32_LOGON_INTERACTIVE,
                       LOGON32_PROVIDER_DEFAULT, &user );
  ASSERT_GLE( success, S_OK, "Could not log on user" );
  success = FALSE;

  // Convert it into an impersonation token.
  success = DuplicateTokenEx( user,
                              MAXIMUM_ALLOWED,
                              NULL, SecurityImpersonation, TokenImpersonation,
                              &iuser );
  ASSERT_GLE( success, S_OK, "Could not duplicate token" );

  // Lookup the user's sid.
  success = LookupAccountName( NULL, Name, sid, &size, domain, &domain_size, &use );
  ASSERT_GLE( success, S_OK, "LookupAccountName failed" );

  // Convert user SID to a string.
  sid_to_str( (SID *) sid, sid_str );

  // Open the registry key.
  result = RegOpenKeyEx(
             HKEY_USERS,
             sid_str,
             0,
             KEY_READ | KEY_WRITE,
             &profile_key );
  ASSERT( result, "Could not open user hive key" );

  // Call UnloadUserProfile.
  success = UnloadUserProfile( iuser, profile_key );
  ASSERT_GLE( success, S_OK, "Could not unload user profile" );

  // Finally, its all over.
  success = TRUE;
cleanup:

  if (user != NULL)
    CloseHandle( user );
  if (iuser != NULL)
    CloseHandle( iuser );

  if (success)
    printf( "\n\nTwo Test Passed.\n" );
  else
    printf( "\n\nTwo Test Failed.\n" );
}

/***************************************************************************/
void do_uninit()
{
  BOOL               success          = FALSE;
  ITest             *server           = NULL;
  ITest             *server2          = NULL;
  SAptId             id;
  SAptId             id2;
  HRESULT            result;
  DWORD              i;
  HANDLE             thread[MAX_THREADS];
  DWORD              thread_id;

  // This test always runs in multithreaded mode.  It tests a multithread
  // only problem and uses freethreaded blocking.
  ThreadMode = COINIT_MULTITHREADED;

  // Initialize OLE.
  hello( "uninit" );
  result = initialize( NULL, ThreadMode );
  ASSERT( result, "Initialize failed" );

  // Create a possibly remote object.
  result = create_instance( ClassIds[free_auto_none], WhatDest, &server, &id );
  ASSERT( result, "Could not create server" );

  // Get another object.
  result = server->get_obj_from_this_apt( &server2, &id2 );
  ASSERT( result, "Could not get another object" );

  // Tell the server to remember its neighbor
  result = server->remember( server2, id2 );
  ASSERT( result, "Could not remember server" );
  server2->Release();
  server2 = NULL;

  // Tell it to wait for a call during shutdown and lower its priority.
  result = server->set_state( late_dispatch_s, THREAD_PRIORITY_LOWEST );
  ASSERT( result, "Could not set server state" );

  // Don't create too many threads.
  if (NumThreads > MAX_THREADS)
    NumThreads = MAX_THREADS;

  // Create some helper threads.
  GlobalBool = TRUE;
  for (i = 0; i < NumThreads; i++)
  {
    thread[i] = CreateThread( NULL, 0, do_uninit_helper, server, 0, &thread_id );
    if (thread[i] == NULL)
    {
      printf( "Could not create helper thread number %d.\n", i );
      goto cleanup;
    }
  }

  // Call the server.  Marshal an interface.  Start shutting down.
  // Wait before returning.
  result = server->get_next_slowly( &server2, &id2 );
  ASSERT( result, "Could not call server during shutdown" );

  // Let the helpers run a while.
  printf( "Waiting 5 seconds for server to die.\n" );
  Sleep( 5000 );

  // Tell all the helpers to die.
  GlobalBool = FALSE;
  result = WaitForMultipleObjects( NumThreads, thread, TRUE, INFINITE );
  ASSERT_EXPR( result != WAIT_FAILED, "Could not wait for helper threads to die.\n" );

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (server2 != NULL)
    server2->Release();
  if (server != NULL)
    server->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nUninit Test Passed.\n" );
  else
    printf( "\n\nUninit Test Failed.\n" );
}

/***************************************************************************/
DWORD _stdcall do_uninit_helper( void *param )
{
  ITest *server = (ITest *) param;
  ITest *server2;
  SAptId id;

  // Call the server till the process terminates.
  while (GlobalBool)
    server->get_next( &server2, &id );

  return 0;
}

/***************************************************************************/
void do_unknown()
{
  BOOL               success          = FALSE;
  ITest             *server           = NULL;
  IUnknown          *unknown          = NULL;
  SAptId             id;
  HRESULT            result;

  // Initialize OLE.
  hello( "unknown" );
  result = initialize( NULL, ThreadMode );
  ASSERT( result, "Initialize failed" );

  // Set security to connect with secure references.
  result = MCoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                                  RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                  EOAC_SECURE_REFS, NULL );
  ASSERT( result, "Could not initialize security to connect" );

  if (ThreadMode == COINIT_APARTMENTTHREADED)
  {
    // Create a local server
    result = new_apartment( &server, &id, NULL, ThreadMode );
    ASSERT( result, "Could not create local instance of test server" );
    result = server->QueryInterface( IID_IUnknown, (void **) &unknown );
    ASSERT( result, "Could not get IUnknown" );

    // Test IUnknown
    success = do_unknown_helper( unknown );
    if (!success) goto cleanup;
    success = FALSE;

    // Release the local server.
    unknown->Release();
    unknown = NULL;
    server->Release();
    server = NULL;
  }

  // Create a possibly remote object.
  result = create_instance( get_class(any_wc), WhatDest, &server, &id );
  ASSERT( result, "Could not create server" );
  result = server->QueryInterface( IID_IUnknown, (void **) &unknown );
  ASSERT( result, "Could not get IUnknown" );

  // Test IUnknown
  success = do_unknown_helper( unknown );
  if (!success) goto cleanup;
  success = FALSE;

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (unknown != NULL)
    unknown->Release();
  if (server != NULL)
    server->Release();
  CoUninitialize();

  if (success)
    printf( "\n\nUnknown Test Passed.\n" );
  else
    printf( "\n\nUnknown Test Failed.\n" );
}

/***************************************************************************/
BOOL do_unknown_call( IUnknown *server, DWORD authn, DWORD imp, REFIID iid )
{
  BOOL     success = FALSE;
  HRESULT  result;
  DWORD    authn_level_out;
  DWORD    imp_level_out;
  DWORD    authn_svc_out;
  DWORD    authz_svc_out;
  OLECHAR *princ_name_out = NULL;
  ITest   *test           = NULL;

  result = MCoSetProxyBlanket( server, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE,
                               NULL, authn, imp, NULL, EOAC_NONE );
  ASSERT( result, "Could not set blanket" );

  // Verify the authentication information.
  result = MCoQueryProxyBlanket( server, &authn_svc_out, &authz_svc_out,
                                &princ_name_out, &authn_level_out,
                                &imp_level_out, NULL, NULL );
  if (result == S_OK)
  {
    // ASSERT_EXPR( princ_name_out == NULL, "Got a principle name." );
    ASSERT_EXPR( authn <= authn_level_out, "Wrong authentication level." );
    ASSERT_EXPR( imp == imp_level_out || authn == RPC_C_AUTHN_LEVEL_NONE,
                                             "Wrong impersonation level." );
    ASSERT_EXPR( RPC_C_AUTHN_WINNT == authn_svc_out, "Wrong authentication service." );
    ASSERT_EXPR( RPC_C_AUTHZ_NONE == authz_svc_out, "Wrong authorization service." );
  }

  // Query for the interface.
  result = server->QueryInterface( iid, (void **) &test );
  ASSERT( result, "Could not query interface" );

  success = TRUE;
cleanup:
  CoTaskMemFree( princ_name_out );
  if (test != NULL)
    test->Release();
  return success;
}

/***************************************************************************/
BOOL do_unknown_helper( IUnknown *server )
{
  BOOL success;

  // Make an unsecure impersonate query.
  success = do_unknown_call( server, RPC_C_AUTHN_LEVEL_NONE,
                             RPC_C_IMP_LEVEL_IMPERSONATE, IID_ITestNoneImp );
  if (!success) return FALSE;

  // Make a connect level impersonate query.
  success = do_unknown_call( server, RPC_C_AUTHN_LEVEL_CONNECT,
                             RPC_C_IMP_LEVEL_IMPERSONATE, IID_ITestConnectImp );
  if (!success) return FALSE;

  // Make an encrypt level impersonate query.
  success = do_unknown_call( server, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                             RPC_C_IMP_LEVEL_IMPERSONATE, IID_ITestEncryptImp );
  if (!success) return FALSE;

  // Make an unsecure identify query.
  success = do_unknown_call( server, RPC_C_AUTHN_LEVEL_NONE,
                             RPC_C_IMP_LEVEL_IDENTIFY, IID_ITestNoneId );
  if (!success) return FALSE;

  // Make a connect level identify query.
  success = do_unknown_call( server, RPC_C_AUTHN_LEVEL_CONNECT,
                             RPC_C_IMP_LEVEL_IDENTIFY, IID_ITestConnectId );
  if (!success) return FALSE;

  // Make an encrypt level identify query.
  success = do_unknown_call( server, RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                             RPC_C_IMP_LEVEL_IDENTIFY, IID_ITestEncryptId );
  if (!success) return FALSE;
  return TRUE;
}

/***************************************************************************/
void do_ver()
{
  BOOL               success          = FALSE;
  HRESULT            result;
  DWORD              size;
  void              *buf;
  DWORD              dwDummy;
  VS_FIXEDFILEINFO  *info;
  UINT               len;

  // Find out how much version information there is for the file.
  printf( "File:           <%ws>\n", Name );
  size = GetFileVersionInfoSize(Name, &dwDummy);
  if (size == 0)
  {
    result = GetLastError();
    ASSERT( result, "File has no version information" );
  }

  // Allocate memory for the version information.
  buf = _alloca(size);

  // Get the version information.
  success = GetFileVersionInfo(Name, 0L, size, buf);
  ASSERT_EXPR( success, "Could not get file version information." );
  success = FALSE;

  // Lookup something.
  success = VerQueryValue(buf, L"\\", (void **) &info, &len);
  ASSERT_EXPR( success, "Could not query file version information." );
  success = FALSE;

  // Print the version information
  printf( "File version:   0x%x:0x%x\n", info->dwFileVersionMS, info->dwFileVersionLS );
  if (Verbose)
  {
    printf( "Signature:      0x%x\n", info->dwSignature );
    printf( "StrucVersion:   0x%x\n", info->dwStrucVersion );
    printf( "ProductVersion: 0x%x:0x%x\n", info->dwProductVersionMS, info->dwProductVersionLS );
    printf( "FileFlagsMask:  0x%x\n", info->dwFileFlagsMask );
    printf( "FileFlags:      0x%x\n", info->dwFileFlags );
    printf( "FileOS:         0x%x\n", info->dwFileOS );
    printf( "FileType:       0x%x:0x%x\n", info->dwFileType, info->dwFileSubtype );
    printf( "FileDate:       0x%x:0x%x\n", info->dwFileDateMS, info->dwFileDateLS );
  }

  // Finally, its all over.
  success = TRUE;
cleanup:

  if (success)
    printf( "\n\nVer Test Passed.\n" );
  else
    printf( "\n\nVer Test Failed.\n" );
}

/***************************************************************************/
void *Fixup( char *name )
{
    HINSTANCE  ole;
    void      *fn;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return NULL;
    }

    // Get the function
    fn = GetProcAddress( ole, name );
    FreeLibrary( ole );
    if (fn == NULL)
    {
      printf( "Could not find %s in ole32.dll.\n", name );
      return NULL;
    }

    // Call function
    return fn;
}

/***************************************************************************/
EXTERN_C HRESULT PASCAL FixupCoCopyProxy(
    IUnknown    *pProxy,
    IUnknown   **ppCopy )
{
    HINSTANCE ole;
    HRESULT   result;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return E_NOTIMPL;
    }

    // Get the function
    GCoCopyProxy = (CoCopyProxyFn) GetProcAddress( ole, "CoCopyProxy" );
    FreeLibrary( ole );
    if (GCoCopyProxy == NULL)
    {
      printf( "Could not find security in ole32.dll.\n" );
      return E_NOTIMPL;
    }

    // Call function
    return GCoCopyProxy( pProxy, ppCopy );
}

/***************************************************************************/
EXTERN_C HRESULT PASCAL FixupCoGetCallContext( REFIID riid, void **ppInterface )
{
    HINSTANCE ole;
    HRESULT   result;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return E_NOTIMPL;
    }

    // Get the function
    GCoGetCallContext = (CoGetCallContextFn)
                          GetProcAddress( ole, "CoGetCallContext" );
    FreeLibrary( ole );
    if (GCoGetCallContext == NULL)
    {
      printf( "Could not find security in ole32.dll.\n" );
      return E_NOTIMPL;
    }

    // Call function
    return GCoGetCallContext( riid, ppInterface );
}

/***************************************************************************/
EXTERN_C HRESULT PASCAL FixupCoImpersonateClient()
{
    HINSTANCE ole;
    HRESULT   result;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return E_NOTIMPL;
    }

    // Get the function
    GCoImpersonateClient = (CoImpersonateClientFn)
                             GetProcAddress( ole, "CoImpersonateClient" );
    FreeLibrary( ole );
    if (GCoImpersonateClient == NULL)
    {
      printf( "Could not find security in ole32.dll.\n" );
      return E_NOTIMPL;
    }

    // Call function
    return GCoImpersonateClient();
}

/***************************************************************************/
EXTERN_C HRESULT PASCAL FixupCoInitializeSecurity(
                                PSECURITY_DESCRIPTOR         pSecDesc,
                                DWORD                        cAuthSvc,
                                SOLE_AUTHENTICATION_SERVICE *asAuthSvc,
                                WCHAR                       *pPrincName,
                                DWORD                        dwAuthnLevel,
                                DWORD                        dwImpLevel,
                                RPC_AUTH_IDENTITY_HANDLE     pAuthInfo,
                                DWORD                        dwCapabilities,
                                void                        *pReserved )
{
    HINSTANCE ole;
    HRESULT   result;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return E_NOTIMPL;
    }

    // Get the function
    GCoInitializeSecurity = (CoInitializeSecurityFn)
                              GetProcAddress( ole, "CoInitializeSecurity" );
    FreeLibrary( ole );
    if (GCoInitializeSecurity == NULL)
    {
      printf( "Could not find security in ole32.dll.\n" );
      return E_NOTIMPL;
    }

    // Call function
    return GCoInitializeSecurity( pSecDesc, cAuthSvc, asAuthSvc, pPrincName,
                                  dwAuthnLevel, dwImpLevel, pAuthInfo,
                                  dwCapabilities, pReserved );
}

/***************************************************************************/
EXTERN_C HRESULT PASCAL FixupCoQueryAuthenticationServices( DWORD *pcbAuthSvc,
                                      SOLE_AUTHENTICATION_SERVICE **asAuthSvc )
{
    HINSTANCE ole;
    HRESULT   result;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return E_NOTIMPL;
    }

    // Get the function
    GCoQueryAuthenticationServices = (CoQueryAuthenticationServicesFn)
                                     GetProcAddress( ole, "CoQueryAuthenticationServices" );
    FreeLibrary( ole );
    if (GCoQueryAuthenticationServices == NULL)
    {
      printf( "Could not find security in ole32.dll.\n" );
      return E_NOTIMPL;
    }

    // Call function
    return GCoQueryAuthenticationServices( pcbAuthSvc, asAuthSvc );
}

/***************************************************************************/
EXTERN_C HRESULT PASCAL FixupCoQueryClientBlanket(
    DWORD             *pAuthnSvc,
    DWORD             *pAuthzSvc,
    OLECHAR          **pServerPrincName,
    DWORD             *pAuthnLevel,
    DWORD             *pImpLevel,
    RPC_AUTHZ_HANDLE  *pPrivs,
    DWORD             *pCapabilities )
{
    HINSTANCE ole;
    HRESULT   result;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return E_NOTIMPL;
    }

    // Get the function
    GCoQueryClientBlanket = (CoQueryClientBlanketFn)
                             GetProcAddress( ole, "CoQueryClientBlanket" );
    FreeLibrary( ole );
    if (GCoQueryClientBlanket == NULL)
    {
      printf( "Could not find security in ole32.dll.\n" );
      return E_NOTIMPL;
    }

    // Call function
    return GCoQueryClientBlanket( pAuthnSvc, pAuthzSvc, pServerPrincName,
                                  pAuthnLevel, pImpLevel, pPrivs, pCapabilities );
}

/***************************************************************************/
EXTERN_C HRESULT PASCAL FixupCoQueryProxyBlanket(
    IUnknown                  *pProxy,
    DWORD                     *pAuthnSvc,
    DWORD                     *pAuthzSvc,
    OLECHAR                  **pServerPrincName,
    DWORD                     *pAuthnLevel,
    DWORD                     *pImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  *pAuthInfo,
    DWORD                     *pCapabilities )
{
    HINSTANCE ole;
    HRESULT   result;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return E_NOTIMPL;
    }

    // Get the function
    GCoQueryProxyBlanket = (CoQueryProxyBlanketFn)
                           GetProcAddress( ole, "CoQueryProxyBlanket" );
    FreeLibrary( ole );
    if (GCoQueryProxyBlanket == NULL)
    {
      printf( "Could not find security in ole32.dll.\n" );
      return E_NOTIMPL;
    }

    // Call function
    return GCoQueryProxyBlanket( pProxy, pAuthnSvc, pAuthzSvc, pServerPrincName,
                                 pAuthnLevel, pImpLevel, pAuthInfo, pCapabilities );
}

/***************************************************************************/
EXTERN_C HRESULT PASCAL FixupCoRevertToSelf()
{
    HINSTANCE ole;
    HRESULT   result;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return E_NOTIMPL;
    }

    // Get the function
    GCoRevertToSelf = (CoRevertToSelfFn) GetProcAddress( ole, "CoRevertToSelf" );
    FreeLibrary( ole );
    if (GCoRevertToSelf == NULL)
    {
      printf( "Could not find security in ole32.dll.\n" );
      return E_NOTIMPL;
    }

    // Call function
    return GCoRevertToSelf();
}

/***************************************************************************/
EXTERN_C HRESULT PASCAL FixupCoSetProxyBlanket(
    IUnknown                 *pProxy,
    DWORD                     dwAuthnSvc,
    DWORD                     dwAuthzSvc,
    OLECHAR                  *pServerPrincName,
    DWORD                     dwAuthnLevel,
    DWORD                     dwImpLevel,
    RPC_AUTH_IDENTITY_HANDLE  pAuthInfo,
    DWORD                     dwCapabilities )
{
    HINSTANCE ole;
    HRESULT   result;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return E_NOTIMPL;
    }

    // Get the function
    GCoSetProxyBlanket = (CoSetProxyBlanketFn)
                         GetProcAddress( ole, "CoSetProxyBlanket" );
    FreeLibrary( ole );
    if (GCoSetProxyBlanket == NULL)
    {
      printf( "Could not find security in ole32.dll.\n" );
      return E_NOTIMPL;
    }

    // Call function
    return GCoSetProxyBlanket( pProxy, dwAuthnSvc, dwAuthzSvc, pServerPrincName,
                               dwAuthnLevel, dwImpLevel, pAuthInfo, dwCapabilities );
}

/***************************************************************************/
EXTERN_C HRESULT PASCAL FixupCoSwitchCallContext( IUnknown *pNewObject, IUnknown **ppOldObject )
{
    HINSTANCE ole;
    HRESULT   result;

    // Load ole32.dll
    ole = LoadLibraryA( "ole32.dll" );
    if (ole == NULL)
    {
      printf( "Could not load ole32.dll to get security function.\n" );
      return E_NOTIMPL;
    }

    // Get the function
    GCoSwitchCallContext = (CoSwitchCallContextFn)
                           GetProcAddress( ole, "CoSwitchCallContext" );
    FreeLibrary( ole );
    if (GCoSwitchCallContext == NULL)
    {
      printf( "Could not find security in ole32.dll.\n" );
      return E_NOTIMPL;
    }

    // Call function
    return GCoSwitchCallContext( pNewObject, ppOldObject );
}

/***************************************************************************/
SAptData *get_apt_data()
{
    SAptData *tls = (SAptData *) TlsGetValue( TlsIndex );
    if (tls == NULL)
        return &ProcessAptData;
    else
        return tls;
}

/***************************************************************************/
DWORD get_apt_type()
{
  if (TlsGetValue( TlsIndex ) != NULL)
      return COINIT_APARTMENTTHREADED;
  else
      return COINIT_MULTITHREADED;
}

/***************************************************************************/
UUID get_class( DWORD type )
{
  DWORD i;

  // Increment the class id count.  Ignore race conditions.
  i         = NumClass;
  NumClass += 1;

  // Pick a class.
  if (type == opposite_wc)
      return ServerClsid[1];
  else if (Change)
      return ServerClsid[i&1];
  else
      return ServerClsid[0];
}

/***************************************************************************/
DWORD get_sequence()
{
  SAptData *apt = get_apt_data();
  return apt->sequence++;
}

/***************************************************************************/
HRESULT get_token_name( WCHAR **name, BOOL revert )
{
  TOKEN_USER        *token_info       = NULL;
  DWORD              info_size        = 1024;
  HANDLE             token            = NULL;
  HRESULT            result           = E_OUTOFMEMORY;
  DWORD              lNameLen         = 1000;
  DWORD              lDomainLen       = 1000;
  DWORD              lIgnore;
  WCHAR              token_name[1000];
  WCHAR              domain[1000];
  SID_NAME_USE       sIgnore;
  BOOL               success;

  // Open the thread token.
  *name = NULL;
  success = OpenThreadToken( GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE,
                             TRUE, &token );
  ASSERT_GLE( success, ERROR_NO_TOKEN, "Could not OpenThreadToken" );
  if (!success && GetLastError() == ERROR_NO_TOKEN)
    return S_OK;
  success = FALSE;

  // Remove the thread token.
  if (revert)
  {
    success = SetThreadToken( NULL, NULL );
    ASSERT_GLE( success, S_OK, "Could not remove thread token" );
    success = FALSE;
  }

  // Get memory for the token information.
  token_info = (TOKEN_USER *) malloc( info_size );
  ASSERT_EXPR( token_info != NULL, "Could not allocate memory." );

  // Get the token sid.
  success = GetTokenInformation( token, TokenUser, token_info, info_size, &info_size );
  ASSERT_GLE( success, S_OK, "Could not GetTokenInformation" );
  success = FALSE;

  // Get the user name.
  success = LookupAccountSid( NULL, token_info->User.Sid, token_name,
                              &lNameLen, domain, &lDomainLen, &sIgnore );
  ASSERT_GLE( success, S_OK, "Could not LookupAccountSid" );
  success = FALSE;

  // Allocate the name.
  *name = (WCHAR *) CoTaskMemAlloc( sizeof(WCHAR) * (lNameLen+lDomainLen+2) );
  ASSERT_EXPR( *name != NULL, "Could not allocate memory" );

  // Stick the domain and user names together.
  wcscpy( *name, domain );
  wcscat( *name, L"\\" );
  wcscat( *name, token_name );

  // Restore the thread token.
  if (revert)
  {
    success = SetThreadToken( NULL, token );
    ASSERT_GLE( success, S_OK, "Could not replace thread token" );
    success = FALSE;
  }

  result = S_OK;
cleanup:
  if (token_info != NULL)
    free(token_info);
  if (token != NULL)
    CloseHandle( token );
  return result;
}

/***************************************************************************/
void hello( char *test )
{
  // Say hello.
  if (ThreadMode == COINIT_APARTMENTTHREADED)
    printf( "Running %s test in apartment threaded mode.\n", test );
  else
    printf( "Running %s test in multithreaded mode.\n", test );
}

/***************************************************************************/
void impersonate()
{
  BOOL success;
  HANDLE oleadmin = NULL;

  // Log on.
  success = LogonUser( L"oleadmin", L"redmond", OleUserPassword, LOGON32_LOGON_BATCH,
                 LOGON32_PROVIDER_DEFAULT, &oleadmin );
  ASSERT_GLE( success, S_OK, "Could not log on oleadmin" );
  success = FALSE;

  // Set the token on the thread.
  success = ImpersonateLoggedOnUser( oleadmin );
  ASSERT_GLE( success, S_OK, "Could not impersonate oleadmin" );
  success = FALSE;

  // Close the handle.
  Preimpersonate = L"redmond\\oleadmin";
cleanup:
  if (oleadmin != NULL)
    CloseHandle( oleadmin );
}

/***************************************************************************/
void increment_object_count()
{
  SAptData *apt = get_apt_data();

  apt->what_next = wait_wn;
  InterlockedIncrement( &apt->object_count );
}

/***************************************************************************/
HRESULT initialize( void *reserved, ULONG flags )
{
  HINSTANCE ole;
  INIT_FN   init_ex;
  HRESULT   result;

  // For the apartment model, just use CoInitialize.
  if (flags == COINIT_APARTMENTTHREADED)
    return CoInitialize( NULL );

  // For free threading, try to find the CoInitializeEx API.
  ole = LoadLibraryA( "ole32.dll" );
  if (ole == NULL)
  {
    printf( "Could not load ole32.dll to get CoInitializeEx.\n" );
    return E_NOTIMPL;
  }

  // Get CoInitializeEx.
  init_ex = (INIT_FN) GetProcAddress( ole, "CoInitializeEx" );
  if (init_ex == NULL)
  {
    FreeLibrary( ole );
    printf( "Could not find CoInitializeEx in ole32.dll.\n" );
    return E_NOTIMPL;
  }

  // Call CoInitializeEx.
  result = init_ex( reserved, flags );
  FreeLibrary( ole );
  return result;
}

/***************************************************************************/
HRESULT initialize_security()
{
  HRESULT                      result;
  SOLE_AUTHENTICATION_SERVICE  svc_list;

  // Initialize security.
  if (GlobalSecurityModel == basic_sm)
  {
    printf( "Basic security model.\n" );
    svc_list.dwAuthnSvc     = GlobalAuthnSvc;
    svc_list.dwAuthzSvc     = RPC_C_AUTHZ_NONE;
#if  (_WIN32_WINNT >= 0x0500 )
    if (GlobalAuthnSvc == RPC_C_AUTHN_GSS_KERBEROS)
      svc_list.pPrincipalName = DomainUser;
    else
#endif
      svc_list.pPrincipalName = NULL;
    result = MCoInitializeSecurity( NULL, 1, &svc_list, NULL, GlobalAuthnLevel,
                                    RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                    EOAC_NONE, NULL );
  }
  else if (GlobalSecurityModel == auto_sm)
  {
    printf( "Automatic security model.\n" );
    result = MCoInitializeSecurity( NULL, -1, NULL, NULL, GlobalAuthnLevel,
                                    RPC_C_IMP_LEVEL_IMPERSONATE, NULL,
                                    EOAC_NONE, NULL );
  }
  else
  {
    printf( "Legacy security model.\n" );
    result = S_OK;
  }
  return result;
}

/***************************************************************************/
void interrupt()
{
  while (GlobalInterruptTest)
  {
    GlobalTest->check( GlobalApt );
    check_for_request();
  }
  GlobalTest->Release();
}

/***************************************************************************/
void interrupt_marshal()
{
  int i;

  for (i = 0; i < NUM_MARSHAL_LOOP; i++ )
  {
    GlobalTest->recurse( GlobalTest2, 1 );
    check_for_request();
  }
  GlobalTest->Release();
  GlobalTest2->Release();
  what_next( wait_wn );
}

/***************************************************************************
 Function:    main

 Synopsis:    Executes the BasicBnd test

 Effects:     None


 Returns:     Exits with exit code 0 if success, 1 otherwise

***************************************************************************/

int _cdecl main(int argc, char *argv[])
{
  HRESULT      result;
  SAptData     tls_data;
  BOOL         success = TRUE;
  DWORD        ignore;
  TOKEN_USER  *token_info       = NULL;
  DWORD        info_size        = 1024;
  HANDLE       token            = NULL;
  char         machinea[MAX_NAME];
  DWORD        i;
  DWORD        lNameLen    = 1000;
  DWORD        lDomainLen  = 1000;
  SID_NAME_USE sIgnore;
  WCHAR        token_name[1000];
  WCHAR        domain[1000];

  // Get the default full provider.
  // BUGBUG - Remove this when SSL works.
#if  (_WIN32_WINNT >= 0x0500 )
  HCRYPTPROV        prov        = 0;
  success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL,
                                 CRYPT_VERIFYCONTEXT );
  if (!success)
    printf( "Could not acquire crypt context: 0x%x\n", GetLastError() );
#endif

  // Initialize Globals.
  MainThread = GetCurrentThreadId();
  Win95      = GetVersion() & 0x80000000;
  NT5        = GetVersion() & 0xffff >= 5;

  // Get the computer name.
  ignore = sizeof(machinea);
  success = GetComputerNameA( machinea, &ignore );
  if (!success)
  {
    printf( "Could not get computer name.\n" );
    return 0;
  }

  // Convert the name to unicode.
  MultiByteToWideChar( CP_ACP, 0, machinea, strlen(machinea)+1, Name,
                       MAX_NAME );
  wcscpy( ThisMachine, Name );

  // Get the user name.
  ignore = sizeof(ProcessName);
  success = GetUserNameA( (char *) ProcessName, &ignore );
  if (!success)
  {
    printf( "Could not get user name.\n" );
    strcpy( (char *) ProcessName, "The root of all evil!" );
  }

  // Create an event for termination notification.
  Done = CreateEventA( NULL, FALSE, FALSE, NULL );
  if (Done == NULL)
  {
    printf( "Could not create event.\n" );
    return 0;
  }

  // Get an event for signalling raw RPCs.
  RawEvent = CreateEventA( NULL, FALSE, FALSE, NULL );
  if (RawEvent == NULL)
  {
    printf( "Could not create event.\n" );
    return 0;
  }

  // Allocate a TLS index.
  TlsIndex = TlsAlloc();
  if (TlsIndex == 0xffffffff)
  {
    printf( "Could not allocate TLS index.\n" );
    return 0;
  }

  // Open the process's token.
  OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &token );
  result = GetLastError();
  if (result == 0)
  {

    // Lookup SID of process token.
    token_info = (TOKEN_USER *) malloc( info_size );
    if (token_info != NULL)
    {
      GetTokenInformation( token, TokenUser, token_info, info_size, &info_size );
      result = GetLastError();
      if (result == 0)
        ProcessSid = (SID *) token_info->User.Sid;
    }
    CloseHandle( token );
  }

  // Get the domain name for the process sid.
  if (ProcessSid != NULL)
  {
    success = LookupAccountSid( NULL, ProcessSid, token_name,
                                &lNameLen, domain, &lDomainLen, &sIgnore );
    if (success)
    {
      DomainUser = (WCHAR *) malloc( (wcslen(token_name) + wcslen(domain) + 2) *
                                     sizeof(WCHAR));
      if (DomainUser != NULL)
      {
        wcscpy( DomainUser, domain );
        wcscat( DomainUser, L"\\" );
        wcscat( DomainUser, token_name );
      }
    }
  }

  // Parse the parameters.
  if (!parse( argc, argv ))
    return 0;

  // Make sure the registry is set.
  if (!registry_setup( argv[0] ))
    return 0;

  // Setup ssl if necessary.
  if (!ssl_setup())
    return 0;

  // Always initiailize the apartment global data for the multithreaded mode.
  ProcessAptData.object_count = 0;
  ProcessAptData.what_next    = setup_wn;
  ProcessAptData.exit_dirty   = FALSE;
  ProcessAptData.sequence     = 0;
  ProcessAptData.server       = NULL;

  // In the single threaded mode, stick a pointer to the object count
  // in TLS.
  if (ThreadMode == COINIT_APARTMENTTHREADED)
  {
    tls_data.object_count = 0;
    tls_data.what_next    = setup_wn;
    tls_data.exit_dirty   = FALSE;
    tls_data.sequence     = 0;
    tls_data.server       = NULL;
    TlsSetValue( TlsIndex, &tls_data );
  }

  // Switch to the correct test.
  switch_test();

  // Cleanup.
  TlsFree( TlsIndex );
  CloseHandle( Done );
  return 1;
}

/*************************************************************************/
void __RPC_FAR * __RPC_API midl_user_allocate( size_t count )
{
  return malloc(count);
}

/*************************************************************************/
void __RPC_USER midl_user_free( void __RPC_FAR * p )
{
  free( p );
}

/*************************************************************************/
HRESULT new_apartment( ITest ** test, SAptId *id, HANDLE *thread_out,
                       DWORD thread_mode )
{
  new_apt_params params;
  HANDLE         thread;
  DWORD          thread_id;
  DWORD          status;
  HRESULT        result = E_FAIL;
  IClassFactory *factory;
  SThreadList   *list;

  // Don't accept thread_out anymore.
  ASSERT_EXPR( thread_out == NULL, "Invalid argument to new-apartment." );

  // Create an event.
  params.stream      = NULL;
  params.ready       = CreateEventA( NULL, FALSE, FALSE, NULL );
  params.thread_mode = thread_mode;
  ASSERT_EXPR( params.ready != NULL, "Could not allocate memory." );

  // Start a new thread/apartment.
  thread = CreateThread( NULL, 0, apartment_base, &params, 0, &thread_id );
  ASSERT_EXPR( thread != NULL, "Could not create thread." );

  // Wait till it has marshalled a class factory.
  status = WaitForSingleObject( params.ready, INFINITE );
  ASSERT_EXPR( status == WAIT_OBJECT_0 && params.stream != NULL,
               "Helper did not return stream." );

  // Unmarshal the class factory.
  result = CoUnmarshalInterface( params.stream, IID_IClassFactory,
                                 (void **) &factory );
  params.stream->Release();
  ASSERT( result, "Could not unmarshal interface" );

  // Create a test object.
  result = factory->CreateInstance( NULL, IID_ITest, (void **) test );
  factory->Release();
  ASSERT( result, "Could not create instance" );
  if (id != NULL)
    (*test)->get_id( id );

  // Create a new thread record.
  list = new SThreadList;
  ASSERT_EXPR( list != NULL, "Could not allocate memory." );

  // Add the thread to the list.
  list->thread    = thread;
  thread          = NULL;
  list->next      = ThreadList.next;
  ThreadList.next = list;

  result = S_OK;
cleanup:
  if (thread != NULL)
    CloseHandle( thread );
  if (params.ready != NULL)
    CloseHandle( params.ready );
  return result;
}

/*************************************************************************/
/* Parse the arguments. */
BOOL parse( int argc, char *argv[] )
{
  int  i;
  int  j;
  int  len;
  char buffer[80];
  BOOL got_name = FALSE;

  WhatTest   = lots_wt;
  ThreadMode = COINIT_APARTMENTTHREADED;

  // Parse each item, skip the command name
  for (i = 1; i < argc; i++)
  {
    if (_stricmp( argv[i], "Apartment" ) == 0)
      ThreadMode = COINIT_APARTMENTTHREADED;

    else if (_stricmp( argv[i], "-auto" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include an authentication level after the -auto option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &GlobalAuthnLevel );
      GlobalSecurityModel = auto_sm;
    }

    else if (_stricmp( argv[i], "-b" ) == 0)
      DebugBreak();

    else if (_stricmp( argv[i], "-basic" ) == 0)
      GlobalSecurityModel = basic_sm;

    else if (_stricmp( argv[i], "-c" ) == 0)
      Change = TRUE;

    else if (_stricmp( argv[i], "Access" ) == 0)
      WhatTest = access_wt;

    else if (_stricmp( argv[i], "Access_Control" ) == 0)
      WhatTest = access_control_wt;

    else if (_stricmp( argv[i], "Anti_delegation" ) == 0)
      WhatTest = anti_delegation_wt;

    else if (_stricmp( argv[i], "Appid" ) == 0)
      WhatTest = appid_wt;

    else if (_stricmp( argv[i], "Async" ) == 0)
      WhatTest = async_wt;

    else if (_stricmp( argv[i], "Cancel" ) == 0)
      WhatTest = cancel_wt;

    else if (_stricmp( argv[i], "Cert" ) == 0)
      WhatTest = cert_wt;

    else if (_stricmp( argv[i], "Cloak" ) == 0)
      WhatTest = cloak_wt;

    else if (_stricmp( argv[i], "Cloak_Act" ) == 0)
      WhatTest = cloak_act_wt;

    else if (_stricmp( argv[i], "Crash" ) == 0)
      WhatTest = crash_wt;

    else if (_stricmp( argv[i], "Create_Dir" ) == 0)
      WhatTest = create_dir_wt;

    else if (_stricmp( argv[i], "Crypt" ) == 0)
      WhatTest = crypt_wt;

    else if (_stricmp( argv[i], "Cstress" ) == 0)
      WhatTest = cstress_wt;

    else if (_stricmp( argv[i], "-d" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include a debugger after the -d option.\n" );
        return FALSE;
      }
      WriteClass = TRUE;
      if (_stricmp( argv[i], "none" ) == 0)
        strcpy( Debugger, "" );
      else
        strcpy( Debugger, argv[i] );
      if (WhatTest == lots_wt)
        WhatTest = none_wt;
    }

    else if (_stricmp( argv[i], "Delegate" ) == 0)
      WhatTest = delegate_wt;

    else if (_stricmp( argv[i], "-e" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include an element count after the -e option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &NumElements );
    }

    else if (_stricmp( argv[i], "-Embedding" ) == 0)
      WhatTest = server_wt;

    else if (_stricmp( argv[i], "-hex" ) == 0)
    {
      // Count the number of dwords.
      j  = i+1;
      while (argv[j] != NULL && argv[j][0] != '-')
        j += 1;

      // Allocate the hex block.
      GlobalHex = (DWORD *) malloc( (j - i - 1) * sizeof(DWORD) );
      if (GlobalHex == NULL)
      {
        printf( "Could not allocate memory for -hex.\n" );
        return FALSE;
      }

      // Read the dwords.
      j = 0;
      while (argv[i+1] != NULL && argv[i+1][0] != '-' )
        sscanf( argv[++i], "%x", &GlobalHex[j++] );
    }

    else if (_stricmp( argv[i], "-i" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include an iteration count after the -i option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &NumIterations );
    }

    else if (_stricmp( argv[i], "Hook" ) == 0)
      WhatTest = hook_wt;

    else if (_stricmp( argv[i], "Leak" ) == 0)
      WhatTest = leak_wt;

    else if (_stricmp( argv[i], "-legacy" ) == 0)
      GlobalSecurityModel = legacy_sm;

    else if (_stricmp( argv[i], "load_client" ) == 0)
      WhatTest = load_client_wt;

    else if (_stricmp( argv[i], "Load_Server" ) == 0)
      WhatTest = load_server_wt;

    else if (_stricmp( argv[i], "Mmarshal" ) == 0)
      WhatTest = mmarshal_wt;

    else if (_stricmp( argv[i], "Multi" ) == 0)
      ThreadMode = COINIT_MULTITHREADED;

    else if (_stricmp( argv[i], "-n" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include a name after the -n option.\n" );
        return FALSE;
      }
      if (!got_name)
      {
        MultiByteToWideChar( CP_ACP, 0, argv[i], strlen(argv[i])+1, Name,
                             sizeof(Name) );
        Name[strlen(argv[i])] = 0;
        got_name = TRUE;
      }
      else
      {
        MultiByteToWideChar( CP_ACP, 0, argv[i], strlen(argv[i])+1, Name2,
                             sizeof(Name2) );
        Name2[strlen(argv[i])] = 0;
      }
      WhatDest = different_machine_wd;
    }

    else if (_stricmp( argv[i], "Name" ) == 0)
      WhatTest = name_wt;

    else if (_stricmp( argv[i], "Null" ) == 0)
      WhatTest = null_wt;

    else if (_stricmp( argv[i], "One" ) == 0)
      WhatTest = one_wt;

    else if (_stricmp( argv[i], "Perf" ) == 0)
      WhatTest = perf_wt;

    else if (_stricmp( argv[i], "PerfAccess" ) == 0)
      WhatTest = perfaccess_wt;

    else if (_stricmp( argv[i], "PerfApi" ) == 0)
      WhatTest = perfapi_wt;

    else if (_stricmp( argv[i], "PerfRemote" ) == 0)
      WhatTest = perfremote_wt;

    else if (_stricmp( argv[i], "PerfRpc" ) == 0)
      WhatTest = perfrpc_wt;

    else if (_stricmp( argv[i], "PerfSec" ) == 0)
      WhatTest = perfsec_wt;

    else if (_stricmp( argv[i], "Pipe" ) == 0)
      WhatTest = pipe_wt;

    else if (_stricmp( argv[i], "Post" ) == 0)
      WhatTest = post_wt;

    else if (_stricmp( argv[i], "-o" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include an object count after the -o option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &NumObjects );
    }

    else if (_stricmp( argv[i], "-o" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include an object count after the -o option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &NumObjects );
    }

    else if (_stricmp( argv[i], "-p" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include a process count after the -p option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &NumProcesses );
    }

    else if (_stricmp( argv[i], "-pl" ) == 0)
      WhatDest = same_process_wd;

    else if (_stricmp( argv[i], "-popup" ) == 0)
      Popup = TRUE;

    else if (_stricmp( argv[i], "Pound" ) == 0)
      WhatTest = pound_wt;

    else if (_stricmp( argv[i], "-r" ) == 0)
    {
      WriteClass = TRUE;
      if (WhatTest == lots_wt)
        WhatTest = none_wt;
    }

    else if (_stricmp( argv[i], "-recurse" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include a recursion count after the -recurse option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &NumRecursion );
    }

    else if (_stricmp( argv[i], "Regload" ) == 0)
      WhatTest = regload_wt;

    else if (_stricmp( argv[i], "Regpeek" ) == 0)
      WhatTest = regpeek_wt;

    else if (_stricmp( argv[i], "Regsave" ) == 0)
      WhatTest = regsave_wt;

    else if (_stricmp( argv[i], "Reject" ) == 0)
      WhatTest = reject_wt;

    else if (_stricmp( argv[i], "Remote_client" ) == 0)
      WhatTest = remote_client_wt;

    else if (_stricmp( argv[i], "Remote_server" ) == 0)
      WhatTest = remote_server_wt;

    else if (_stricmp( argv[i], "Ring" ) == 0)
      WhatTest = ring_wt;

    else if (_stricmp( argv[i], "Rpc" ) == 0)
      WhatTest = rpc_wt;

    else if (_stricmp( argv[i], "Rundown" ) == 0)
      WhatTest = rundown_wt;

    else if (_stricmp( argv[i], "-s" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include a protocol sequence after the -s option.\n" );
        return FALSE;
      }
      MultiByteToWideChar( CP_ACP, 0, argv[i], strlen(argv[i])+1, TestProtseq,
                           sizeof(TestProtseq) );
      TestProtseq[strlen(argv[i])] = 0;
    }

    else if (_stricmp( argv[i], "SecPkg" ) == 0)
      WhatTest = secpkg_wt;

    else if (_stricmp( argv[i], "-SecPkg" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include a comma separated security package list\n" );
        printf( "with no spaces after the -SecPkg option.\n" );
        return FALSE;
      }
      MultiByteToWideChar( CP_ACP, 0, argv[i], strlen(argv[i])+1, PackageList,
                           sizeof(PackageList) );
      TestProtseq[strlen(argv[i])] = 0;
    }

    else if (_stricmp( argv[i], "Security" ) == 0)
      WhatTest = security_wt;

    else if (_stricmp( argv[i], "SecureRefs" ) == 0)
      WhatTest = securerefs_wt;

    else if (_stricmp( argv[i], "Secure_Release" ) == 0)
      WhatTest = secure_release_wt;

    else if (_stricmp( argv[i], "Send" ) == 0)
      WhatTest = send_wt;

    else if (_stricmp( argv[i], "Snego" ) == 0)
      WhatTest = snego_wt;

    else if (_stricmp( argv[i], "-ssl" ) == 0)
    {
      WriteCert = TRUE;
      if (WhatTest == lots_wt)
        WhatTest = none_wt;
    }

    else if (_stricmp( argv[i], "-t" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include a thread count after the -t option.\n" );
        return FALSE;
      }
      sscanf( argv[i], "%d", &NumThreads );
    }

    else if (_stricmp( argv[i], "sid" ) == 0)
      WhatTest = sid_wt;

    else if (_stricmp( argv[i], "Simple_rundown" ) == 0)
      WhatTest = simple_rundown_wt;

    else if (_stricmp( argv[i], "ssl" ) == 0)
      WhatTest = ssl_wt;

    else if (_stricmp( argv[i], "Thread" ) == 0)
      WhatTest = thread_wt;

    else if (_stricmp( argv[i], "Three" ) == 0)
      WhatTest = three_wt;

    else if (_stricmp( argv[i], "Two" ) == 0)
      WhatTest = two_wt;

    else if (_stricmp( argv[i], "-u" ) == 0)
    {
      if (argv[++i] == NULL)
      {
        printf( "You must include a name after the -u option.\n" );
        return FALSE;
      }
      MultiByteToWideChar( CP_ACP, 0, argv[i], strlen(argv[i])+1, UserName,
                           sizeof(UserName) );
      UserName[strlen(argv[i])] = 0;
    }

    else if (_stricmp( argv[i], "Uninit" ) == 0)
      WhatTest = uninit_wt;

    else if (_stricmp( argv[i], "Unknown" ) == 0)
      WhatTest = unknown_wt;

    else if (_stricmp( argv[i], "-v" ) == 0)
      Verbose = TRUE;

    else if (_stricmp( argv[i], "Ver" ) == 0)
      WhatTest = ver_wt;

    else
    {
      printf( "You don't know what you are doing!\n" );
      printf( "This program tests the channel.\n" );
      printf( "\n" );
      printf( "Access               Test IAccessControl with CIS.\n" );
      printf( "Access_Control       Test DCOMAccessControl.\n" );
      printf( "Anti_Delegation      Make sure no tokens are passed on calls.\n" );
      printf( "Appid                Test EOAC_APPID with CIS.\n" );
      printf( "Apartment            Apartment threading mode.\n" );
      printf( "Async                Test async.\n" );
      printf( "Cancel               Cancel test.\n" );
      printf( "Cert                 Enumerate certificate store -u.\n" );
      printf( "Cloak                Cloak test.\n" );
      printf( "Cloak_Act            Cloak activation test.\n" );
      printf( "Crash                Crash test.\n" );
      printf( "Create_dir           Create -i copies of directory -n.\n" );
      printf( "Crypt                Cryptography test.\n" );
      printf( "Cstress              Cancel stress test.\n" );
      printf( "Delegate             Delegation test.\n" );
      printf( "Hook                 Channel hook test.\n" );
      printf( "Leak                 Look for memory leaks (doesn't fail if there are any).\n" );
      printf( "Load_Client          Remote load performance - client.\n" );
      printf( "Load_Server          Remote load performance - server.\n" );
      printf( "Mmarshal             Multiple marshal test.\n" );
      printf( "Multi                Multithreaded mode.\n" );
      printf( "Name                 Lookup the name for the sid speficied by -hex.\n" );
      printf( "Null                 Apartment null call test.\n" );
      printf( "One                  Used for testing new tests.\n" );
      printf( "Perf                 Performance test.\n" );
      printf( "PerfAccess           IAccessContorl Performance test.\n" );
      printf( "PerfApi              API Performance test.\n" );
      printf( "PerfRemote           Remote call performance test.\n" );
      printf( "PerfRpc              Raw RPC performance test.\n" );
      printf( "PerfSec              Security performance test.\n" );
      printf( "Pipe                 Pipe test.\n" );
      printf( "Post                 Post a message to window specified by -i.\n" );
      printf( "Pound                Create as many servers as possible.\n" );
      printf( "Regload              Load a registry key from a file (-n).\n" );
      printf( "Regpeek              Read and write a registry key.\n" );
      printf( "Regsave              Save a registry key to a file (-n).\n" );
      printf( "Reject               Reject test.\n" );
      printf( "Remote_Client        Remote performance - client.\n" );
      printf( "Remote_Server        Remote performance - server.\n" );
      printf( "Ring                 Run ring test.\n" );
      printf( "Rpc                  Test both RPC and OLE calls.\n" );
      printf( "Rundown              Rundown test.\n" );
      printf( "SecPkg               List security packages.\n" );
      printf( "SecureRefs           Secure Addref/Release Test.\n" );
      printf( "Secure_Release       Secure Addref/Release Test version 2.\n" );
      printf( "Security             Security test.\n" );
      printf( "Send                 Send a message to window specified by -i.\n" );
      printf( "Sid                  Lookup the sid for the name specified by -n\n" );
      printf( "Simple_Rundown       Wait for object exporter to timeout.\n" );
      printf( "Snego                Test Snego.\n" );
      printf( "SSL                  Test SSL.\n" );
      printf( "Thread               Calling on multiple threads.\n" );
      printf( "Three                Used for reproducing bugs.\n" );
      printf( "Two                  Used for reproducing bugs.\n" );
      printf( "Uninit               Calls during uninitialization.\n" );
      printf( "Unknown              IUnknown security.\n" );
      printf( "Ver                  Print file version info.\n" );
      printf( "\n" );
      printf( "-auto n              Use automatic security set to level n.\n" );
      printf( "-b                   Stop in debugger before going on.\n" );
      printf( "-basic               Use basic security.\n" );
      printf( "-c                   Change the test.\n" );
      printf( "-d debugger          Debugger to run app under of none.\n" );
      printf( "-e n                 Number of elements.\n" );
      printf( "-Embedding           Server side.\n" );
      printf( "-hex xxxxxxxx ...    Input hex numbers till the next -\n" );
      printf( "-legacy              Use legacy security.\n" );
      printf( "-i n                 Number of iterations.\n" );
      printf( "-n name              String name.\n" );
      printf( "-o n                 Number of objects.\n" );
      printf( "-p n                 Number of processes.\n" );
      printf( "-pl                  Create the server process local.\n" );
      printf( "-popup               Display popups for sync during test.\n" );
      printf( "-r                   Force setup to be rerun.\n" );
      printf( "-recurse n           Number of recursions.\n" );
      printf( "-s protseq           Change default protocol sequence.\n" );
      printf( "-SecPkg pkg1,pkg2    Security package list.\n" );
      printf( "-ssl                 Setup certificates for SSL test.\n" );
      printf( "-t n                 Number of threads.\n" );
      printf( "-u username          Name of user.\n" );
      printf( "\n" );
      printf( "The test currently only runs in the single threaded mode\n" );
      printf( "and requires the apartment model.\n" );
      printf( "If no test is specified the cancel, crash, null,\n" );
      printf( "ring, and rundown tests will be run.  The options have the\n" );
      printf( "following default values.\n" );
      printf( "     authn level           - %d\n", GlobalAuthnLevel );
      printf( "     iterations            - %d\n", NumIterations );
      printf( "     name                  - %ws\n", Name );
      printf( "     objects               - 2\n" );
      printf( "     processes             - 2\n" );
      printf( "     recurse               - 2\n" );
      printf( "     protseq               - %ws\n", TestProtseq );
      printf( "     security package list - %ws\n", PackageList );
      printf( "     security model        - %d\n", GlobalSecurityModel );
      printf( "     threads               - 2\n" );
      return FALSE;
    }
  }

  // Figure out the class id based on the thread model and security model.
  if (GlobalSecurityModel == auto_sm)
    if (GlobalAuthnLevel == RPC_C_AUTHN_LEVEL_CONNECT)
      i = 1;
    else if (GlobalAuthnLevel == RPC_C_AUTHN_LEVEL_PKT_INTEGRITY)
      i = 2;
    else
      i = 0;
  else if (GlobalSecurityModel == basic_sm)
    i = 3;
  else
    i = 4;
  if (ThreadMode == COINIT_MULTITHREADED)
  {
    ServerClsid[0] = ClassIds[free_auto_none+i];
    ServerClsid[1] = ClassIds[apt_auto_none+i];
  }
  else
  {
    ServerClsid[0] = ClassIds[apt_auto_none+i];
    ServerClsid[1] = ClassIds[free_auto_none+i];
  }

  return TRUE;
}

/***************************************************************************/
void pound()
{
  HRESULT   result;
  SAptData *apt = get_apt_data();
  SAptId    id;

  // Wait for the signal.
  result = WaitForSingleObject( ManualReset, INFINITE );
  if (result != WAIT_OBJECT_0)
  {
    printf( "Wait failed: 0x%x\n", result );
    return;
  }

  // Call the server until at least one call succeeds.
  do
  {
    result = apt->server->get_id( &id );
  }
  while (result != S_OK);

  // Tell the server loop to return to normal.
  what_next( wait_wn );
}

/***************************************************************************/
BOOL registry_setup( char *argv0 )
{
  char  value[REGISTRY_ENTRY_LEN];
  LONG  value_size;
  LONG  result;
  char  directory[MAX_PATH];
  char *appname;
  int   i;
  int   j;
  char *class_id;
  HKEY  key = NULL;
  DWORD ignore;

  // Find out if the registry is setup.
  value_size = sizeof(value);
  result = RegQueryValueA(
             HKEY_CLASSES_ROOT,
             REG_CLASS_EXE,
             value,
             &value_size );

  // If the registry is not setup or needs to be rewritten, write it.
  if (result != ERROR_SUCCESS || WriteClass)
  {
    // Write the IAsync interface name.
    strcpy( value, "Interface\\{70000000-76d7-11cf-9af1-0020af6e72f4}" );
    result = RegSetValueA(
               HKEY_CLASSES_ROOT,
               value,
               REG_SZ,
               "IAsync",
               strlen("IAsync") );
    ASSERT( result, "Could not set interface name: 0x%x" );

    // Write the IAsync interface to proxy class id translation.
    strcpy( value, "Interface\\{70000000-76d7-11cf-9af1-0020af6e72f4}\\ProxyStubClsid32" );
    result = RegSetValueA(
               HKEY_CLASSES_ROOT,
               value,
               REG_SZ,
               REG_INTERFACE_CLASS,
               strlen(REG_INTERFACE_CLASS) );
    ASSERT( result, "Could not set interface class: 0x%x" );

    // Write the IAsync interface asynchronous IID.
    strcpy( value, "Interface\\{70000000-76d7-11cf-9af1-0020af6e72f4}\\AsynchronousInterface" );
    result = RegSetValueA(
               HKEY_CLASSES_ROOT,
               value,
               REG_SZ,
               REG_ASYNC_IID,
               strlen(REG_ASYNC_IID) );
    ASSERT( result, "Could not set interface class: 0x%x" );

    // Write the IAsync asyncronous interface name.
    strcpy( value, "Interface\\{70000001-76d7-11cf-9af1-0020af6e72f4}" );
    result = RegSetValueA(
               HKEY_CLASSES_ROOT,
               value,
               REG_SZ,
               "IAsync",
               strlen("IAsync") );
    ASSERT( result, "Could not set interface name: 0x%x" );

    // Write the IAsync asynchronous interface to proxy class id translation.
    strcpy( value, "Interface\\{70000001-76d7-11cf-9af1-0020af6e72f4}\\ProxyStubClsid32" );
    result = RegSetValueA(
               HKEY_CLASSES_ROOT,
               value,
               REG_SZ,
               REG_INTERFACE_CLASS,
               strlen(REG_INTERFACE_CLASS) );
    ASSERT( result, "Could not set interface class: 0x%x" );

    // Write the IAsync asynchronous interface synchronous IID.
    strcpy( value, "Interface\\{70000001-76d7-11cf-9af1-0020af6e72f4}\\AsynchronousInterface" );
    result = RegSetValueA(
               HKEY_CLASSES_ROOT,
               value,
               REG_SZ,
               REG_SYNC_IID,
               strlen(REG_SYNC_IID) );
    ASSERT( result, "Could not set interface class: 0x%x" );

    // Register the hook 1 class.
    result = RegSetValueA(
         HKEY_CLASSES_ROOT,
         "CLSID\\{60000400-76d7-11cf-9af1-0020af6e72f4}",
         REG_SZ,
         REG_HOOK_NAME, strlen(REG_HOOK_NAME) );
    ASSERT( result, "RegSetValue failed" );

    // Register the hook 2 class.
    result = RegSetValueA(
         HKEY_CLASSES_ROOT,
         "CLSID\\{60000401-76d7-11cf-9af1-0020af6e72f4}",
         REG_SZ,
         REG_HOOK_NAME, strlen(REG_HOOK_NAME) );
    ASSERT( result, "RegSetValue failed" );

    // Register the which class.
    result = RegSetValueA(
         HKEY_CLASSES_ROOT,
         "CLSID\\{60000402-76d7-11cf-9af1-0020af6e72f4}",
         REG_SZ,
         REG_WHICH_NAME, strlen(REG_WHICH_NAME) );
    ASSERT( result, "RegSetValue failed" );

    // Write all the interface ids.
    for (i = 0; i < NUM_INTERFACE_IDS; i++)
    {
      // Write the interface name.
      strcpy( value, "Interface\\{60000300-76d7-11cf-9af1-0020af6e72f4}" );
      value[18] += (char) i;
      result = RegSetValueA(
                 HKEY_CLASSES_ROOT,
                 value,
                 REG_SZ,
                 REG_INTERFACE_NAME[i],
                 strlen(REG_INTERFACE_NAME[i]) );
      ASSERT( result, "Could not set interface name: 0x%x" );

      // Write the interface to proxy class id translation.
      strcpy( value, "Interface\\{60000300-76d7-11cf-9af1-0020af6e72f4}\\ProxyStubClsid32" );
      value[18] += (char) i;
      result = RegSetValueA(
                 HKEY_CLASSES_ROOT,
                 value,
                 REG_SZ,
                 REG_INTERFACE_CLASS,
                 strlen(REG_INTERFACE_CLASS) );
      ASSERT( result, "Could not set interface class: 0x%x" );
    }

    // Write the proxy name.
    result = RegSetValueA(
         HKEY_CLASSES_ROOT,
         "CLSID\\{60000300-76d7-11cf-9af1-0020af6e72f4}",
         REG_SZ,
         REG_PROXY_NAME,
         strlen(REG_PROXY_NAME) );
    ASSERT( result, "Could not set interface name: 0x%x" );

    // Compute the path to the application.
    result = GetFullPathNameA( argv0, sizeof(directory), directory, &appname );
    ASSERT_EXPR( result != 0, "Could not GetFullPathName." );
    result = appname - directory;
    if (result + strlen(REG_PROXY_DLL) > MAX_PATH ||
        result + strlen(REG_APP_EXE) + strlen(Debugger) > MAX_PATH)
    {
      printf( "Buffer too small.\n" );
      goto cleanup;
    }

    // Write the proxy dll path.
    strcpy( appname, REG_PROXY_DLL );
    result = RegSetValueA(
               HKEY_CLASSES_ROOT,
               "CLSID\\{60000300-76d7-11cf-9af1-0020af6e72f4}\\InprocServer32",
               REG_SZ,
               directory,
               strlen(directory) );
    ASSERT( result, "Could not set interface name: 0x%x" );

    // Register the hook 1 dll.
    strcpy( appname, REG_HOOK_DLL );
    result = RegSetValueA(
         HKEY_CLASSES_ROOT,
         "CLSID\\{60000400-76d7-11cf-9af1-0020af6e72f4}\\InprocServer32",
         REG_SZ,
         directory, strlen(directory) );
    ASSERT( result, "Could not set hook 1 inproc server" );

    // Register the hook 2 dll.
    result = RegSetValueA(
         HKEY_CLASSES_ROOT,
         "CLSID\\{60000401-76d7-11cf-9af1-0020af6e72f4}\\InprocServer32",
         REG_SZ,
         directory, strlen(directory) );
    ASSERT( result, "Could not set hook 2 inproc server" );

    // Register the which dll.
    result = RegSetValueA(
         HKEY_CLASSES_ROOT,
         "CLSID\\{60000402-76d7-11cf-9af1-0020af6e72f4}\\InprocServer32",
         REG_SZ,
         directory, strlen(directory) );
    ASSERT( result, "Could not set which hook inproc server" );

    // Open the which dll inproc server key.
    result = RegOpenKeyExA(
               HKEY_CLASSES_ROOT,
               "CLSID\\{60000402-76d7-11cf-9af1-0020af6e72f4}\\InprocServer32",
               0,
               KEY_SET_VALUE,
               &key );
    ASSERT( result, "Could not open which dll inproc server key" );

    // Register the which dll threading model.
    result = RegSetValueExA(
         key,
         "ThreadingModel",
         NULL,
         REG_SZ,
         (unsigned const char *) "Apartment",
         strlen("Apartment") );
    ASSERT( result, "Could not set which hook inproc server" );

    // Close the which dll inproc server key.
    RegCloseKey( key );
    key = NULL;

    // Open the registry key for the app id.
    result = RegCreateKeyExA( HKEY_CLASSES_ROOT,
               "AppID\\{60000300-76d7-11cf-9af1-0020af6e72f4}",
               NULL,
               NULL,
               REG_OPTION_NON_VOLATILE,
               KEY_READ | KEY_WRITE,
               NULL,
               &key,
               &ignore );
    ASSERT( result, "Could not create app id key: 0x%x" );

    // Write the app id.
    result = RegSetValueExA(
               key,
               NULL,
               NULL,
               REG_SZ,
               (UCHAR *) REG_APPID_NAME,
               strlen(REG_APPID_NAME) );
    ASSERT( result, "Could not set app id name: 0x%x" );

    // Make a simple security descriptor allowing everyone access.
    result = setup_access( key );
    ASSERT( result, "Could not set up access permission" );

    // Write the value to run as logged on user.
    result = RegSetValueExA(
               key,
               "RunAs",
               NULL,
               REG_SZ,
               (unsigned char *) REG_LOGGED_ON,
               strlen(REG_LOGGED_ON) );
    ASSERT( result, "Could not set RunAs value: 0x%x" );
    RegCloseKey( key );
    key = NULL;

    // Open the registry key for the module name.
    result = RegCreateKeyExA( HKEY_CLASSES_ROOT,
               "AppID\\app.exe",
               NULL,
               NULL,
               REG_OPTION_NON_VOLATILE,
               KEY_READ | KEY_WRITE,
               NULL,
               &key,
               &ignore );
    ASSERT( result, "Could not create module name key: 0x%x" );

    // Write the app id under the module name.
    result = RegSetValueExA(
               key,
               "AppID",
               NULL,
               REG_SZ,
               (unsigned char *) REG_INTERFACE_CLASS,
               strlen(REG_INTERFACE_CLASS) );
    ASSERT( result, "Could not set appid value: 0x%x" );
    RegCloseKey( key );
    key = NULL;

    // Compute the base application execution command.
    strcpy( appname, REG_APP_EXE );
    i = strlen( Debugger );
    if (i != 0)
      Debugger[i++] = ' ';
    strcpy( &Debugger[i], directory );
    i = strlen( Debugger );

    // Allocate strings for the class id name keys.
    class_id     = (char *) _alloca( strlen(REG_CLASS_ID) + 1 );
    if (class_id == NULL)
    {
      printf( "Could not _alloca string space.\n" );
      return FALSE;
    }
    strcpy( class_id, REG_CLASS_ID );

    // Write all the class ids.
    for (j = 0; j < NUM_CLASS_IDS; j++)
    {
      // Adjust the id in the class strings.
      class_id[14]     = '0'+j;

      // Open the registry key for the app id.
      result = RegCreateKeyExA( HKEY_CLASSES_ROOT,
                 class_id,
                 NULL,
                 NULL,
                 REG_OPTION_NON_VOLATILE,
                 KEY_READ | KEY_WRITE,
                 NULL,
                 &key,
                 &ignore );
      ASSERT( result, "Could not create class id key: 0x%x" );

      // Write the application class name for the apartment class.
      result = RegSetValueExA(
                 key,
                 NULL,
                 NULL,
                 REG_SZ,
                 (UCHAR *) REG_APP_NAME[j],
                 strlen(REG_APP_NAME[j]) );
      ASSERT( result, "Could not set interface name: 0x%x" );

      // Write the application path.
      strcpy( &Debugger[i], REG_APP_OPTIONS[j] );
      result = RegSetValueA(
                 key,
                 "LocalServer32",
                 REG_SZ,
                 Debugger,
                 strlen(Debugger) );
      ASSERT( result, "Could not set app exe: 0x%x" );

      // Write the application id value.
      result = RegSetValueExA(
                 key,
                 "AppID",
                 NULL,
                 REG_SZ,
                 (unsigned char *) REG_INTERFACE_CLASS,
                 strlen(REG_INTERFACE_CLASS) );
      ASSERT( result, "Could not set appid value: 0x%x" );
      RegCloseKey( key );
      key = NULL;
    }
    printf( "Setup successful.\n" );
  }

  return TRUE;

cleanup:
  if (key != NULL)
    RegCloseKey( key );
  printf( "Setup failed.\n" );
  return FALSE;
}

/***************************************************************************/
void reinitialize()
{
  HRESULT                      result;
  SAptData                    *mine;
  SOLE_AUTHENTICATION_SERVICE  svc_list;

  // Get the apartment specific data.
  if (ThreadMode == COINIT_MULTITHREADED)
    mine = &ProcessAptData;
  else
    mine = (SAptData *) TlsGetValue( TlsIndex );
  mine->what_next = quit_wn;

  // Revoke the class factory.
  ClassFactory->AddRef();
  result = CoRevokeClassObject(Registration);
  if (!SUCCEEDED(result))
  {
    printf( "CoRevokeClassObject failed: %x\n", result );
    return;
  }

  // Reinitialize.
  CoUninitialize();
  result = initialize(NULL,ThreadMode);
  if (!SUCCEEDED(result))
  {
    printf( "Could not reinitialize server: 0x%x\n", result );
    return;
  }

  // Initialize security.
  result = initialize_security();
  if (!SUCCEEDED(result))
  {
    printf( "initialize_security failed: %x\n", result );
    return;
  }

  // Register our class with OLE
  result = CoRegisterClassObject(get_class(any_wc), ClassFactory, CLSCTX_LOCAL_SERVER,
      REGCLS_SINGLEUSE, &Registration);
  if (!SUCCEEDED(result))
  {
    printf( "CoRegisterClassObject failed: %x\n", result );
    return;
  }

  // Make the server loop think we've started over.
  mine->what_next = setup_wn;
  mine->object_count = 0;
}

/***************************************************************************/
void server_loop(  )
{
  BOOL               success = FALSE;
  register SAptData *mine    = get_apt_data();
  HRESULT            result;

  // Do whatever we have to do till it is time to pay our taxes and die.
  while ((mine->what_next == setup_wn || mine->object_count > 0) &&
         mine->what_next != quit_wn)
    switch (mine->what_next)
    {

      // Wait till a quit arrives.
      case setup_wn:
      case wait_wn:
        wait_for_message();
        break;

#if  (_WIN32_WINNT >= 0x0500 )
      case basic_async_wn:
        // Wait for the begin to complete.
        printf( "Waiting 2 seconds for async begin to complete.\n" );
        Sleep( 2000);

        // Impersonate.
        result = Security->ImpersonateClient();
        ASSERT( result, "Could not async impersonate" );

        // Verify the token.
        result = check_token( CallUser, Security, RPC_C_IMP_LEVEL_IMPERSONATE );
        ASSERT( result, "Wrong async user" );

        // Revert if not preimpersonating.
        if (Preimpersonate == NULL)
        {
          result = Security->RevertToSelf();
          ASSERT( result, "Could not async revert" );
        }

        // Complete the call.
        result = Call->Signal();
        ASSERT( result, "Could not complete async call" );
        Call->Release();
        Security->Release();
        Call            = NULL;
        Security        = NULL;
        mine->what_next = wait_wn;
        break;
#endif

      case callback_wn:
        callback();
        mine->what_next = wait_wn;
        break;

      case catch_wn:
        __try
        {
          mine->what_next = wait_wn;
          server_loop();
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
          printf( "Caught exception at top of thread 0x%x\n",
                   GetCurrentThreadId() );
          mine->what_next = crippled_wn;
        }
        break;

      case crippled_wn:
        crippled();
        break;

      case impersonate_wn:
        impersonate();
        mine->what_next = wait_wn;
        break;

      case interrupt_wn:
        interrupt();
        break;

      case interrupt_marshal_wn:
        interrupt_marshal();
        break;

      case pound_wn:
        pound();
        break;

#if  (_WIN32_WINNT >= 0x0500 )
      case race_async_wn:
        // Complete the call.
        result = Call->Signal();
        ASSERT( result, "Could not complete async call" );
        Call->Release();
        Security->Release();
        Call            = NULL;
        Security        = NULL;
        mine->what_next = wait_wn;
        break;
#endif

      case reinitialize_wn:
        reinitialize();
        break;

      case rest_and_die_wn:
        Sleep(5000);
        mine->what_next = quit_wn;
        break;

      case revert_wn:
        SetThreadToken( NULL, NULL );
        Preimpersonate = NULL;
        mine->what_next = wait_wn;
        break;
    }

  success = TRUE;
cleanup:
  if (!success)
    Sleep( 0xfffffffe );
}


/***************************************************************************/
HRESULT setup_access( HKEY key )
{
  HRESULT              result = S_OK;
  SECURITY_DESCRIPTOR *sec    = NULL;
  DWORD                i;

  if (ProcessSid != NULL)
  {
    i = GetLengthSid( ProcessSid );
    sec = (SECURITY_DESCRIPTOR *) CoTaskMemAlloc( sizeof(SECURITY_DESCRIPTOR) +
                                                  i*2 );
    ASSERT_EXPR( sec != NULL, "Could not allocate memory." );
    sec->Revision = SECURITY_DESCRIPTOR_REVISION;
    sec->Sbz1     = 0;
    sec->Control  = SE_SELF_RELATIVE;
    sec->Owner    = (SID *) sizeof(SECURITY_DESCRIPTOR);
    sec->Group    = (SID *) (sizeof(SECURITY_DESCRIPTOR) + i);
    sec->Sacl     = NULL;
    sec->Dacl     = NULL;
    memcpy( sec+1, ProcessSid, i );
    memcpy( ((char *) (sec+1)) + i, ProcessSid, i );

    // Write the launch permissions.
    result = RegSetValueExA(
               key,
               "LaunchPermission",
               NULL,
               REG_BINARY,
               (UCHAR *) sec,
               sizeof(SECURITY_DESCRIPTOR) + 2*i );
    ASSERT( result, "Could not set launch permissions" );

    // Write the access permissions.
    result = RegSetValueExA(
               key,
               "AccessPermission",
               NULL,
               REG_BINARY,
               (UCHAR *) sec,
               sizeof(SECURITY_DESCRIPTOR) + 2*i );
    ASSERT( result, "Could not set access permissions" );
  }

cleanup:
  if (sec != NULL)
    CoTaskMemFree( sec );
  return result;
}

/***************************************************************************/
BOOL ssl_setup()
{
  BOOL              success     = TRUE;
#if  (_WIN32_WINNT >= 0x0500 )
  HRESULT           result;
  HCRYPTPROV        prov        = 0;
  DWORD             len;
  HCERTSTORE        cert_store  = NULL;
  HCERTSTORE        root_store  = NULL;
  PCCERT_CONTEXT    cert        = NULL;
  WCHAR                       *principal = NULL;
  CERT_CHAIN_PARA              chain_para;
  const CERT_CHAIN_CONTEXT    *chain     = NULL;
  CERT_CHAIN_POLICY_PARA       policy;
  CERT_CHAIN_POLICY_STATUS     status;
  HCRYPTKEY                    key       = NULL;
  CERT_KEY_CONTEXT             key_context;
  HCRYPTHASH                   hash      = NULL;
  HCRYPTKEY                    session   = NULL;

  // Only run on NT 5.
  success = FALSE;
  if (!WriteCert) return TRUE;
  ASSERT_EXPR( NT5, "SSL can only be setup on NT 5" );

  // Get the default full provider.
  success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL, 0 );
  ASSERT_GLE( success, NTE_BAD_KEYSET, "Could not acqure full context." );

  // If there is no container, create one.
  if (!success)
  {
    success = CryptAcquireContext( &prov, NULL, NULL, PROV_RSA_FULL, CRYPT_NEWKEYSET );
    ASSERT_GLE( success, S_OK, "Could not acqure full context." );
  }
  success = FALSE;

  // Call CertOpenSystemStore to open the store.
  cert_store = CertOpenSystemStore(prov, UserName );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting System Store Handle" );

  // Call CertOpenSystemStore to open the root store.
  root_store = CertOpenSystemStore(prov, L"root" );
  ASSERT_GLE( cert_store != NULL, S_OK, "Error Getting root Store Handle" );

  // Write the test certificate to the store.
  success = CertAddSerializedElementToStore( cert_store,
                                       Cert20,
                                       sizeof(Cert20),
                                       CERT_STORE_ADD_REPLACE_EXISTING,
                                       0,
                                       CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                       NULL,
                                       (const void **) &cert );
  ASSERT_GLE( success, S_OK, "Could not add serialized certificate to store" );
  success = FALSE;

  // Write the test certificate issuer to the cert store.
  success = CertAddSerializedElementToStore( root_store,
                                       CertSrv2,
                                       sizeof(CertSrv2),
                                       CERT_STORE_ADD_REPLACE_EXISTING,
                                       0,
                                       CERT_STORE_CERTIFICATE_CONTEXT_FLAG,
                                       NULL,
                                       NULL );
  ASSERT_GLE( success, S_OK, "Could not add serialized certificate to store" );
  success = FALSE;

  // Get the certificate chain.
  chain_para.RequestedUsage.Usage.cUsageIdentifier     = 0;
  chain_para.RequestedUsage.Usage.rgpszUsageIdentifier = NULL;
  chain_para.RequestedUsage.dwType                     = USAGE_MATCH_TYPE_AND;
  chain_para.cbSize                                    = sizeof(chain_para);
  success = CertGetCertificateChain( NULL, cert, NULL, NULL, &chain_para,
                                     CERT_CHAIN_REVOCATION_CHECK_CHAIN, NULL,
                                     &chain );
  ASSERT_GLE( success, S_OK, "Could not get certificate chain" );
  success = FALSE;

  // Verify that the certificate is valid.
  policy.cbSize              = sizeof(policy);
  policy.dwFlags             = 0;
  policy.pvExtraPolicyPara   = NULL;
  status.cbSize              = sizeof(status);
  status.pvExtraPolicyStatus = NULL;
  success = CertVerifyCertificateChainPolicy( CERT_CHAIN_POLICY_SSL,
                                              chain, &policy, &status );
  ASSERT_EXPR( success, "Could not verify certificate chain" );
  ASSERT_EXPR( status.dwError == 0 || status.dwError == CRYPT_E_REVOCATION_OFFLINE,
               "Certificate chain is bad" );
  success = FALSE;

  // Print the fullsic principal name for the certificate.
  result = RpcCertGeneratePrincipalName( cert, RPC_C_FULL_CERT_CHAIN, &principal );
  if (result != 0)
    printf( "Could not generate fullsic principal name: 0x%x\n", result );
  else
    printf( "Fullsic: <%ws>\n", principal );

  // Free the string.
  result = RpcStringFree( &principal );
  ASSERT( result, "Could not free principal" );

  // Print the standard principal name for the certificate.
  result = RpcCertGeneratePrincipalName( cert, 0, &principal );
  if (result != 0)
    printf( "Could not generate standard principal name: 0x%x\n", result );
  else
    printf( "Standard: <%ws>\n", principal );
/*
  // Create a hash.
  success = CryptCreateHash( prov, CALG_MD2, NULL, 0, &hash );
  ASSERT_GLE( success, S_OK, "Could not create hash" );
  success = FALSE;

  // Feed it the password.
  success = CryptHashData( hash, CertPassword, sizeof(CertPassword), 0 );
  ASSERT_GLE( success, S_OK, "Could not hash password" );
  success = FALSE;

  // Derive a session key from the hash.
  success = CryptDeriveKey( prov, CALG_RC2, hash, 0, &session );
  ASSERT_GLE( success, S_OK, "Could not derive a session key" );
  success = FALSE;
*/
  // Import the private key.
  success = CryptImportKey( prov, Cert20_Private, sizeof(Cert20_Private),
                            session, CRYPT_EXPORTABLE, &key );
  ASSERT_GLE( success, S_OK, "Could not import private key" );
  success = FALSE;

  // Set this key on the certificate.
  key_context.cbSize     = sizeof(key_context);
  key_context.hCryptProv = prov;
  key_context.dwKeySpec  = key;
  success = CertSetCertificateContextProperty( cert, CERT_KEY_CONTEXT_PROP_ID,
                                               CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                               &key_context );
  ASSERT_GLE( success, S_OK, "Could not set certificate key context" );
  success = FALSE;

  // Finally, its all over.
  success = TRUE;
cleanup:
  if (hash != NULL)
    CryptDestroyHash( hash );
  if (session != NULL)
    CryptDestroyKey( session );
  if (key != NULL)
    CryptDestroyKey( key );
  if (chain != NULL)
    CertFreeCertificateChain( chain );
  if (principal != NULL)
    RpcStringFree( &principal );
  if (cert != NULL)
    CertFreeCertificateContext(cert);
  if (cert_store != NULL)
    CertCloseStore( cert_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (root_store != NULL)
    CertCloseStore( root_store, CERT_CLOSE_STORE_CHECK_FLAG );
  if (prov != 0 )
    CryptReleaseContext( prov, 0 );

  if (success)
    printf( "Successfully setup SSL.\n" );
  else
    printf( "Failed to setup SSL.\n" );
#endif
  return success;
}

/***************************************************************************/
void switch_test()
{
  switch (WhatTest)
  {
    case access_wt:
      do_access();
      break;

    case access_control_wt:
      do_access_control();
      break;

    case anti_delegation_wt:
      do_anti_delegation();
      break;

    case appid_wt:
      do_appid();
      break;

#if  (_WIN32_WINNT >= 0x0500 )
    case async_wt:
      do_async();
      break;
#endif

    case cancel_wt:
      do_cancel();
      break;

    case cert_wt:
      do_cert();
      break;

    case cloak_wt:
      do_cloak();
      break;

#if  (_WIN32_WINNT >= 0x0500 )
    case cloak_act_wt:
      do_cloak_act();
      break;
#endif

    case crash_wt:
      do_crash();
      break;

    case create_dir_wt:
      do_create_dir();
      break;

#if  (_WIN32_WINNT >= 0x0500 )
    case crypt_wt:
      do_crypt();
      break;
#endif

    case cstress_wt:
      do_cstress();
      break;

#if  (_WIN32_WINNT >= 0x0500 )
    case delegate_wt:
      do_delegate();
      break;
#endif

    case hook_wt:
      do_hook();
      break;

    case leak_wt:
      do_leak();
      break;

    case load_client_wt:
      do_load_client();
      break;

    case load_server_wt:
      do_load_server();
      break;

    case lots_wt:
      do_lots();
      break;

    case mmarshal_wt:
      do_mmarshal();
      break;

    case name_wt:
      do_name();
      break;

    case none_wt:
      break;

    case null_wt:
      do_null();
      break;

    case one_wt:
      do_one();
      break;

    case perf_wt:
      do_perf();
      break;

    case perfaccess_wt:
      do_perfaccess();
      break;

    case perfapi_wt:
      do_perfapi();
      break;

    case perfremote_wt:
      do_perfremote();
      break;

    case perfrpc_wt:
      do_perfrpc();
      break;

    case perfsec_wt:
      do_perfsec();
      break;

    case pipe_wt:
      do_pipe();
      break;

    case post_wt:
      do_post();
      break;

    case pound_wt:
      do_pound();
      break;

    case regload_wt:
      do_regload();
      break;

    case regpeek_wt:
      do_regpeek();
      break;

    case regsave_wt:
      do_regsave();
      break;

    case reject_wt:
      do_reject();
      break;

    case remote_client_wt:
      do_remote_client();
      break;

    case remote_server_wt:
      do_remote_server();
      break;

    case ring_wt:
      do_ring();
      break;

    case rpc_wt:
      do_rpc();
      break;

    case rundown_wt:
      do_rundown();
      break;

    case secpkg_wt:
      do_secpkg();
      break;

    case securerefs_wt:
      do_securerefs();
      break;

    case secure_release_wt:
      do_securerefs();
      break;

    case security_wt:
      do_security();
      break;

    case send_wt:
      do_send();
      break;

    case server_wt:
      do_server();
      break;

    case sid_wt:
      do_sid();
      break;

    case simple_rundown_wt:
      do_simple_rundown();
      break;

    case snego_wt:
      do_snego();
      break;

    case ssl_wt:
      do_ssl();
      break;

    case thread_wt:
      do_thread();
      break;

    case three_wt:
      do_three();
      break;

    case two_wt:
      do_two();
      break;

    case uninit_wt:
      do_uninit();
      break;

    case unknown_wt:
      do_unknown();
      break;

    case ver_wt:
      do_ver();
      break;

    default:
      printf( "I don't know what to do - %d\n", WhatTest );
      break;
  }
}

/***************************************************************************/
DWORD _stdcall thread_helper( void *param )
{
  ITest   *test = (ITest *) param;
  HRESULT  result;

  // Call the server.
  result = test->sleep( 2000 );

  // Check the result for multithreaded mode.
  if (ThreadMode == COINIT_MULTITHREADED)
  {
    if (result != S_OK)
    {
      printf( "Could not make multiple calls in multithreaded mode: 0x%x\n",
              result );
        Multicall_Test = FALSE;
    }
  }

  // Check the result for single threaded mode.
  else
  {
    if (SUCCEEDED(result))
    {
      Multicall_Test = FALSE;
      printf( "Call succeeded on wrong thread in single threaded mode: 0x%x.\n",
              result );
    }
#if NEVER
    else if (DebugCoGetRpcFault() != RPC_E_ATTEMPTED_MULTITHREAD)
    {
      printf( "Multithread failure code was 0x%x not 0x%x\n",
              DebugCoGetRpcFault(), RPC_E_ATTEMPTED_MULTITHREAD );
      Multicall_Test = FALSE;
    }
#endif
  }

#define DO_DA 42
  return DO_DA;
}

/***************************************************************************/
DWORD _stdcall status_helper( void *param )
{
  long  num_calls;
  long  num_clients;
  long  total_clients;
  DWORD last_time;
  DWORD this_time;
  DWORD rate;

  // Wake up periodically and print statistics.
  last_time = GetTickCount();
  while (TRUE)
  {
    Sleep( STATUS_DELAY );
    num_calls     = InterlockedExchange( &GlobalCalls, 0 );
    num_clients   = GlobalClients;
    total_clients = GlobalTotal;
    this_time     = GetTickCount();
    if (num_calls != 0)
      rate = (this_time - last_time)*1000/num_calls;
    else
      rate = 99999999;
    printf( "Time: %d   Calls: %d   Clients: %d   Total Clients: %d   uSec/Call: %d\n",
            this_time - last_time, num_calls, num_clients, total_clients,
            rate );
    last_time = this_time;
  }
  return 0;
}

/***************************************************************************/
HRESULT switch_thread( SIMPLE_FN fn, void *param )
{
  MSG msg;

  if (ThreadMode == COINIT_MULTITHREADED)
  {
    fn( param );
    return S_OK;
  }
  else
  {
    if (PostThreadMessage( GlobalThreadId, WM_USER+1, (unsigned int) fn,
                              (long) param ))
    {
      GetMessage( &msg, NULL, 0, 0 );
      return S_OK;
    }
    else
      return E_FAIL;
  }
}

/***************************************************************************/
void thread_get_interface_buffer( void *p )
{
  SGetInterface     *getif   = (SGetInterface *) p;
  HANDLE             memory  = NULL;
  IStream           *stream  = NULL;
  LARGE_INTEGER      pos;
  DWORD              size;
  void              *objref;
  WCHAR              name[MAX_COMPUTERNAME_LENGTH+1];
  DWORD              name_size = sizeof(name)/sizeof(WCHAR);

  // Find out how much memory to allocate.
  getif->status   = RPC_S_OUT_OF_RESOURCES;
  getif->status = CoGetMarshalSizeMax( (unsigned long *) getif->buf_size,
                                IID_ITest, GlobalTest,
                                MSHCTX_DIFFERENTMACHINE,
                                NULL,
                                MSHLFLAGS_NORMAL );
  ASSERT( getif->status, "Could not marshal server object" );

  // Allocate memory.
  memory = GlobalAlloc( GMEM_FIXED, *getif->buf_size );
  ASSERT_EXPR( memory != NULL, "Could not allocate memory." );

  // Create a stream.
  getif->status = CreateStreamOnHGlobal( memory, TRUE, &stream );
  ASSERT( getif->status, "Could not create stream" );

  // Marshal the object.
  getif->status = CoMarshalInterface( stream, IID_ITest, GlobalTest,
                               MSHCTX_DIFFERENTMACHINE,
                               NULL,
                               MSHLFLAGS_NORMAL );
  ASSERT( getif->status, "Could not marshal object" );

  // Find the object reference in the stream.
  objref = (void *) GlobalLock( memory );

  // Allocate a buffer for MIDL.
  *getif->buffer = (unsigned char *) midl_user_allocate( *getif->buf_size );
  ASSERT_EXPR( *getif->buffer != NULL, "Could not allocate MIDL memory." );

  // Copy the stream to the buffer.
  memcpy( *getif->buffer, objref, *getif->buf_size );
  GlobalUnlock( memory );

  // Make sure that the original reference to the object gets released once.
  if (InterlockedExchange( &GlobalFirst, FALSE ) == TRUE)
    GlobalTest->Release();

  // Return the buffer.
  getif->status   = RPC_S_OK;
cleanup:
  if (stream != NULL)
    stream->Release();
  PostThreadMessage( getif->thread, WM_USER, 0, 0 );
}

/***************************************************************************/
void __RPC_USER transmit_crash_to_xmit( transmit_crash __RPC_FAR *c, DWORD  __RPC_FAR * __RPC_FAR *x )
{
  DWORD tmp = 1 / *c;

  *x = (DWORD *) CoTaskMemAlloc( 4 );
  **x = tmp;
  *c -= 1;
}

/***************************************************************************/
void __RPC_USER transmit_crash_from_xmit( DWORD  __RPC_FAR *x, transmit_crash __RPC_FAR *c )
{
  *c = *x;
}

/***************************************************************************/
void __RPC_USER transmit_crash_free_inst( transmit_crash __RPC_FAR *x )
{
}

/***************************************************************************/
void __RPC_USER transmit_crash_free_xmit( DWORD  __RPC_FAR *x )
{
  CoTaskMemFree( x );
}

/***************************************************************************/
void wait_apartment()
{
  HRESULT      result;
  SThreadList *next;

  // Loop over all apartments.
  next = ThreadList.next;
  while (next != &ThreadList)
  {
    // Wait for the thread.
    result = WaitForSingleObject( next->thread, INFINITE );
    if (result != WAIT_OBJECT_0)
      printf( "WaitForSingleObject on thread 0x%x failed with 0x%x.\n",
              next->thread, result );

    // Remove the thread.
    ThreadList.next = next->next;
    delete next;
    next            = ThreadList.next;
  }
}

/***************************************************************************/
void wait_for_message()
{
  MSG   msg;
  DWORD status;

  if (get_apt_type() == COINIT_MULTITHREADED)
  {
    status = WaitForSingleObject( Done, INFINITE );
    if (status != WAIT_OBJECT_0 )
    {
      printf( "Could not wait for event.\n" );
    }
  }
  else
  {
    if (GetMessageA( &msg, NULL, 0, 0 ))
    {
      if (msg.hwnd == NULL && msg.message == WM_USER+1)
        ((SIMPLE_FN) msg.wParam)( (void *) msg.lParam );
      else
      {
        TranslateMessage (&msg);
        DispatchMessageA (&msg);
      }
    }
  }
}

/***************************************************************************/
void wake_up_and_smell_the_roses()
{
  if (get_apt_type() == COINIT_MULTITHREADED)
    SetEvent( Done );
}

/***************************************************************************/
void what_next( what_next_en what )
{
  SAptData *apt = get_apt_data();
  apt->what_next = what;
}

/***************************************************************************/
unsigned long xacl_call( handle_t binding )
{
  RPC_STATUS status;
  RPC_STATUS status2;
  BOOL       success;
  DWORD      granted_access;
  BOOL       access;
  BOOL       ignore;
  HANDLE     token;
  HANDLE     none;
  PRIVILEGE_SET privilege;
  DWORD         privilege_size = sizeof(privilege);
  GENERIC_MAPPING gmap;
  LARGE_INTEGER start;
  LARGE_INTEGER impersonate;
  LARGE_INTEGER open;
  LARGE_INTEGER accesscheck;
  LARGE_INTEGER setnull;
  LARGE_INTEGER opennull;
  LARGE_INTEGER settoken;
  LARGE_INTEGER close;
  LARGE_INTEGER revert;
  LARGE_INTEGER freq;

#if 1
  QueryPerformanceCounter( &start );
#endif
  status = RpcImpersonateClient( binding );
#if 1
  QueryPerformanceCounter( &impersonate );
#endif
  if (status == RPC_S_OK)
  {
    // Get the thread token.
    success = OpenThreadToken( GetCurrentThread(),
                               TOKEN_IMPERSONATE | TOKEN_READ,
                               TRUE, &token );
#if 1
    QueryPerformanceCounter( &open );
#endif
    if (!success)
    {
      printf( "Could not OpenThreadToken.\n" );
      status = E_FAIL;
    }

    // Check access.
    else
    {
      gmap.GenericRead    = READ_CONTROL;
      gmap.GenericWrite   = READ_CONTROL;
      gmap.GenericExecute = READ_CONTROL;
      gmap.GenericAll     = READ_CONTROL;
      privilege.PrivilegeCount = 1;
      privilege.Control        = 0;
      success = AccessCheck( GlobalSecurityDescriptor, token, READ_CONTROL,
                             &gmap, &privilege, &privilege_size,
                             &granted_access, &access );
#if 1
      QueryPerformanceCounter( &accesscheck );
#endif

      if (!success)
      {
        printf( "Bad parameters to AccessCheck: 0x%x.\n",
                GetLastError() );
        status = E_FAIL;
      }
      else if (!access)
      {
        printf( "Could not get access.\n" );
        status = ERROR_ACCESS_DENIED;
      }

      // Set the thread token to null.
      success = SetThreadToken( NULL, NULL );
      if (!success)
      {
        printf( "SetThreadToken null failed.\n" );
        status = E_FAIL;
      }
      QueryPerformanceCounter( &setnull );

      // Try to open a null token.
      success = OpenThreadToken( GetCurrentThread(),
                                 TOKEN_IMPERSONATE,
                                 TRUE, &none );
      if (success)
      {
        printf( "OpenThreadToken null succeeded.\n" );
        status = E_FAIL;
      }
      QueryPerformanceCounter( &opennull );

      // Set the thread token.
      success = SetThreadToken( NULL, token );
      if (!success)
      {
        printf( "SetThreadToken failed: 0x%x\n", GetLastError() );
        status = E_FAIL;
      }
      QueryPerformanceCounter( &settoken );

      // Close the token handle.
      CloseHandle( token );
#if 1
      QueryPerformanceCounter( &close );
#endif
    }
    status2 = RpcRevertToSelf();
#if 1
    QueryPerformanceCounter( &revert );
    QueryPerformanceFrequency( &freq );
    start.QuadPart = 1000000 * (impersonate.QuadPart - start.QuadPart) / freq.QuadPart;
    printf( "RpcImpersonateClient took % 10d uS\n", start.u.LowPart );
    impersonate.QuadPart = 1000000 * (open.QuadPart - impersonate.QuadPart) / freq.QuadPart;
    printf( "OpenThreadToken took      % 10d uS\n", impersonate.u.LowPart );
    open.QuadPart = 1000000 * (accesscheck.QuadPart - open.QuadPart) / freq.QuadPart;
    printf( "AccessCheck took          % 10d uS\n", open.u.LowPart );
    accesscheck.QuadPart = 1000000 * (setnull.QuadPart - accesscheck.QuadPart) / freq.QuadPart;
    printf( "SetThreadToken null took  % 10d uS\n", accesscheck.u.LowPart );
    setnull.QuadPart = 1000000 * (opennull.QuadPart - setnull.QuadPart) / freq.QuadPart;
    printf( "OpenThreadToken null took % 10d uS\n", setnull.u.LowPart );
    opennull.QuadPart = 1000000 * (settoken.QuadPart - opennull.QuadPart) / freq.QuadPart;
    printf( "SetThreadToken took       % 10d uS\n", setnull.u.LowPart );
    settoken.QuadPart = 1000000 * (close.QuadPart - settoken.QuadPart) / freq.QuadPart;
    printf( "CloseHandle took          % 10d uS\n", settoken.u.LowPart );
    close.QuadPart = 1000000 * (revert.QuadPart - close.QuadPart) / freq.QuadPart;
    printf( "RpcRevertToSelf took      % 10d uS\n", close.u.LowPart );
#endif
    if (status2 != RPC_S_OK)
      status = status2;
  }

  return status;
}

/***************************************************************************/
unsigned long xaudit_call( handle_t binding )
{
  RPC_STATUS status;
  RPC_STATUS status2;
  BOOL       success;
  DWORD      granted_access;
  BOOL       access;
  BOOL       ignore;
  HANDLE     token;
  GENERIC_MAPPING gmap;
  LARGE_INTEGER start;
  LARGE_INTEGER impersonate;
  LARGE_INTEGER accesscheck;
  LARGE_INTEGER revert;
  LARGE_INTEGER freq;

#if 1
  QueryPerformanceCounter( &start );
#endif
  status = RpcImpersonateClient( binding );
#if 1
  QueryPerformanceCounter( &impersonate );
#endif
  if (status == RPC_S_OK)
  {
    // Check access and do audits.
    gmap.GenericRead    = READ_CONTROL;
    gmap.GenericWrite   = READ_CONTROL;
    gmap.GenericExecute = READ_CONTROL;
    gmap.GenericAll     = READ_CONTROL;
    success = AccessCheckAndAuditAlarm( L"Test",
                                        NULL,
                                        L"Test Type Name",
                                        L"Test Name",
                                        GlobalSecurityDescriptor,
                                        READ_CONTROL,
                                        &gmap,
                                        FALSE,
                                        &granted_access,
                                        &access,
                                        &ignore );
#if 1
    QueryPerformanceCounter( &accesscheck );
#endif
    if (!success)
    {
      printf( "Bad parameters to AccessCheckAndAuditAlarm: 0x%x.\n",
              GetLastError() );
      status = E_FAIL;
    }
    else if (!access)
    {
      printf( "Could not get access.\n" );
      status = E_FAIL;
    }
    status2 = RpcRevertToSelf();
#if 1
    QueryPerformanceCounter( &revert );
    QueryPerformanceFrequency( &freq );
    start.QuadPart = 1000000 * (impersonate.QuadPart - start.QuadPart) / freq.QuadPart;
    printf( "RpcImpersonateClient took %duS\n", start.u.LowPart );
    impersonate.QuadPart = 1000000 * (accesscheck.QuadPart - impersonate.QuadPart) / freq.QuadPart;
    printf( "AccessCheckAndAuditAlarm took %duS\n", impersonate.u.LowPart );
    accesscheck.QuadPart = 1000000 * (revert.QuadPart - accesscheck.QuadPart) / freq.QuadPart;
    printf( "RpcRevertToSelf took %duS\n", accesscheck.u.LowPart );
#endif
    if (status2 != RPC_S_OK)
      status = status2;
  }

  return status;
}

/***************************************************************************/
unsigned long xcheck_client( handle_t binding, error_status_t *error_status )
{
  HANDLE             client_token   = NULL;
  HANDLE             server_token   = NULL;
  TOKEN_USER        *client_sid;
  TOKEN_USER        *server_sid;
  DWORD              count;
  char               buffer1[100];
  char               buffer2[100];
  HRESULT            result = S_OK;
  RPC_STATUS         status;
  HANDLE             process = NULL;

  // Get this process's security token.
  *error_status = RPC_S_OK;
  if (!OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &server_token ))
  {
    printf( "Could not GetProcessToken: 0x%x\n", GetLastError() );
    result = E_FAIL;
    goto cleanup;
  }

  // Get the token's user id.
  if (!GetTokenInformation( server_token, TokenUser, &buffer1, sizeof(buffer1),
                            &count ))
  {
    printf( "Could not GetTokenInformation: 0x%x\n", GetLastError() );
    result = E_FAIL;
    goto cleanup;
  }
  server_sid = (TOKEN_USER *) &buffer1;

  // Impersonate the client.
  status = RpcImpersonateClient( binding );
  if (status != RPC_S_OK)
  {
    printf( "Could not impersonate client: 0x%x\n", status );
    result = MAKE_WIN32( status );
    goto cleanup;
  }

  // Get the clients security token.
  if (!OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, FALSE, &client_token ))
  {
    printf( "Could not GetProcessToken: 0x%x\n", GetLastError() );
    result = E_FAIL;
    goto cleanup;
  }

  // Get the token's user id.
  if (!GetTokenInformation( client_token, TokenUser, &buffer2, sizeof(buffer2),
                            &count ))
  {
    printf( "Could not GetTokenInformation: 0x%x\n", GetLastError() );
    result = E_FAIL;
    goto cleanup;
  }
  client_sid = (TOKEN_USER *) &buffer2;

  // Compare the client and server.
  if (!EqualSid( server_sid->User.Sid, client_sid->User.Sid))
  {
    printf( "Client and server have different SIDs.\n" );
    result = E_FAIL;
    goto cleanup;
  }

  // Try to open this process while impersonating the client.
  process = OpenProcess( PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId() );
  if (process == NULL)
  {
    printf( "Could not open process.\n" );
    result = E_FAIL;
    goto cleanup;
  }

  // Undo the impersonation.
  status = RpcRevertToSelf();
  if (status != RPC_S_OK)
  {
    printf( "Could not revert to self: 0x%x\n", status );
    result = MAKE_WIN32( status );
    goto cleanup;
  }

cleanup:
  if (client_token != NULL)
    CloseHandle( client_token );
  if (server_token != NULL)
    CloseHandle( server_token );
  if (process != NULL)
    CloseHandle( process );
  return result;
}

/***************************************************************************/
void xget_interface_buffer( handle_t binding, long *buf_size,
                            unsigned char **buffer, SAptId *id,
                            error_status_t *status )
{
  SGetInterface get_interface;

  *buffer                = NULL;
  get_interface.buf_size = buf_size;
  get_interface.buffer   = buffer;
  get_interface.thread   = GetCurrentThreadId();
  *status = switch_thread( thread_get_interface_buffer, (void *) &get_interface );
  if (*status == RPC_S_OK)
    *status = get_interface.status;
  InterlockedIncrement( &GlobalClients );
  InterlockedIncrement( &GlobalTotal );
}

/***************************************************************************/
unsigned long ximpersonate_call( handle_t binding )
{
  RPC_STATUS status;

  status = RpcImpersonateClient( binding );
  if (status == RPC_S_OK)
    status = RpcRevertToSelf();

  return status;
}

/***************************************************************************/
void xnullcall( handle_t binding )
{
}

/***************************************************************************/
void xrelease_interface( handle_t binding, error_status_t *status )
{
  *status = RPC_S_OK;
  InterlockedDecrement( &GlobalClients );
}

/***************************************************************************/
void xset_status( handle_t binding, HRESULT result, error_status_t *status )
{
  RawResult = result;
  *status   = RPC_S_OK;
  SetEvent( RawEvent );
}

/***************************************************************************/
unsigned long xtest( handle_t binding, ITest *obj, SAptId id,
                     error_status_t *status )
{
  *status = RPC_S_OK;
  return obj->check( id );
}

/***************************************************************************/
unsigned long xtransitive( handle_t handle, wchar_t *binding )
{
  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\channel\idl\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       PCH.CXX
//
//  Contents:   Precompiled header
//
//  History:    12-Jul-93 ShannonC  Created
//
//--------------------------------------------------------------------------

#include "stdrpc.hxx"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cmarshal\app\app.cxx ===
//+-------------------------------------------------------------
//
// File:        perfcli.cxx
//
// Contents:    First attempt at getting perfcliing to work
//
// This is the client side
//
//
//---------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>

#include <ole2.h>
#include <com.hxx>
#include "app.hxx"
#include <memalloc.h>
#include <objerror.h>

#pragma hdrstop

//+--------------------------------------------------------------
/* Definitions. */

#define MAX_CALLS    1000
#define MAX_THREADS  10

typedef enum what_next_en
{
  wait_wn,
  interrupt_wn,
  quit_wn
} what_next_en;

//+--------------------------------------------------------------
/* Prototypes. */
void interrupt                  ( void );
void check_for_request          ( void );
BOOL server_loop                ( void );
DWORD _stdcall ThreadHelper     ( void * );
void wait_for_message           ( void );
void wake_up_and_smell_the_roses( void );


//+--------------------------------------------------------------
/* Globals. */
DWORD        thread_mode = COINIT_MULTITHREADED;
HANDLE       Done;
BOOL         server;
BOOL         Multicall_Test;
BOOL         InterruptTestResults;
BOOL         InterruptTestDone;
DWORD        MainThread;
DWORD        NestedCallCount = 0;
what_next_en WhatNext;
ITest       *global_test = NULL;
BOOL         global_interrupt_test;


/***************************************************************************/
STDMETHODIMP_(ULONG) CTest::AddRef( THIS )
{
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CTest::CTest()
{
  ref_count = 1;
  custom    = NULL;
}

/***************************************************************************/
CTest::~CTest()
{
  if (custom != NULL)
  {
    custom->Release();
    custom = NULL;
  }
}

/***************************************************************************/
STDMETHODIMP CTest::sick( ULONG val )
{
  TRY
  {
    THROW( CException(val) );
  }
  CATCH( CException, exp )
  {
  }
  END_CATCH;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::die_cpp( ULONG val )
{
  THROW( CException(val) );
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTest::die_nt( ULONG val )
{
  RaiseException( val, 0, 0, NULL );
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP_(DWORD) CTest::die( ITest *callback, ULONG catch_depth,
                                ULONG throw_depth, ULONG throw_val )
{
  if (catch_depth == 0)
  {
    TRY
    {
      return callback->die( this, catch_depth - 1, throw_depth - 1, throw_val );
    }
    CATCH( CException, exp )
    {
#if DBG==1
      if (DebugCoGetRpcFault() != throw_val)
      {
        printf( "Propogated server fault was returned as 0x%x not 0x%x\n",
                DebugCoGetRpcFault(), throw_val );
//        return FALSE;
      }
#endif
      return TRUE;
    }
    END_CATCH
  }
  else if (throw_depth == 0)
  {
    THROW( CException(throw_val) );
  }
  else
    return callback->die( this, catch_depth - 1, throw_depth - 1, throw_val );
  return FALSE;
}

/***************************************************************************/
STDMETHODIMP CTest::interrupt( ITest *param, BOOL go )
{
  global_interrupt_test = go;
  if (go)
  {
    global_test = param;
    global_test->AddRef();
    WhatNext = interrupt_wn;
    wake_up_and_smell_the_roses();
  }
  else
    WhatNext = wait_wn;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP_(BOOL) CTest::hello()
{
  if (GetCurrentThreadId() == MainThread)
    printf( "Hello on the main thread.\n" );
  else
    printf( "Hello on thread %d.\n", GetCurrentThreadId );
  return !InterruptTestDone;
}

/***************************************************************************/
STDMETHODIMP CTest::recurse( ITest *callback, ULONG depth )
{
  if (depth == 0)
    return S_OK;
  else
    return callback->recurse( this, depth-1 );
}

/***************************************************************************/
STDMETHODIMP CTest::recurse_interrupt( ITest *callback, ULONG depth )
{
  MSG msg;

  if (PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ))
  {
    TranslateMessage (&msg);
    DispatchMessage (&msg);
  }

  if (depth == 0)
    return S_OK;
  else
    return callback->recurse( this, depth-1 );
}

/***************************************************************************/
STDMETHODIMP CTest::sleep( ULONG time )
{

  // For single threaded mode, verify that this is the only call on the
  // main thread.
  NestedCallCount += 1;
  printf( "Sleeping on thread %d for the %d time concurrently.\n",
          GetCurrentThreadId(), NestedCallCount );
  if (thread_mode == COINIT_SINGLETHREADED)
  {
    if (GetCurrentThreadId() != MainThread)
    {
      printf( "Sleep called on the wrong thread in single threaded mode.\n" );
      NestedCallCount -= 1;
      return FALSE;
    }
    else if (NestedCallCount != 1)
    {
      printf( "Sleep nested call count is %d instead of not 1 in single threaded mode.\n",
              NestedCallCount );
      NestedCallCount -= 1;
      return FALSE;
    }
  }

  // For multithreaded mode, verify that this is not the main thread.
  else if (GetCurrentThreadId() == MainThread)
  {
    printf( "Sleep called on the main thread in multi threaded mode.\n" );
    NestedCallCount -= 1;
    return FALSE;
  }

  Sleep( time );
  NestedCallCount -= 1;
  return S_OK;
}

/***************************************************************************/
STDMETHODIMP_(DWORD) CTest::DoTest( ITest *test, ITest *another )
{
  HRESULT  result;
  int      i;
  BOOL     success;
  HANDLE   helper[MAX_THREADS];
  DWORD    thread_id;
  DWORD    status;

  // Let the server throw and exception and catch it before returning.
  result = test->sick( 95 );
  if (result != S_OK)
  {
    printf( "Internal server fault was not dealt with correctly.\n" );
    return FALSE;
  }

  // Let the server throw a C++ exception here.
  result = test->die_cpp( 0xdeaff00d );
  if (result != RPC_E_FAULT)
  {
    printf( "C++ server fault was not dealt with correctly.\n" );
    return FALSE;
  }
#if DBG==1
  if (DebugCoGetRpcFault() != 0xdeaff00d)
  {
    printf( "C++ server fault was returned as 0x%x not 0x%x\n",
            DebugCoGetRpcFault(), 0xdeaff00d );
//    return FALSE;
  }
#endif

  // Let the server throw a NT exception here.
  result = test->die_nt( 0xaaaabdbd );
  if (result != RPC_E_FAULT)
  {
    printf( "NT server fault was not dealt with correctly.\n" );
    return FALSE;
  }
#if DBG==1
  if (DebugCoGetRpcFault() != 0xaaaabdbd)
  {
    printf( "C++ server fault was returned as 0x%x not 0x%x\n",
            DebugCoGetRpcFault(), 0xaaaabdbd );
    return FALSE;
  }
#endif

  // Test a recursive call.
  result = test->recurse( this, 10 );
  if (result != S_OK)
  {
    printf( "Recursive call failed: 0x%x\n", result );
    return FALSE;
  }

  // Test throwing and immediately catching an exception.
  //success = test->die( this, 2, 3, 0x12345678 );
  //if (!success)
  //{
  //  printf( "Could not catch server exception.\n" );
  //  return FALSE;
  //}

  // Test throwing, propogating, and then catching an exception.
  // success = test->die( this, 1, 3, 0x87654321 );
  //if (!success)
  //{
  //  printf( "Could not catch propogated server exception.\n" );
  //  return FALSE;
  //}

  // Test multiple threads.
  Multicall_Test = TRUE;
  for (i = 0; i < MAX_THREADS; i++)
  {
    helper[i] = CreateThread( NULL, 0, ThreadHelper, test, 0, &thread_id );
    if (helper == NULL)
    {
      printf( "Could not create helper thread number %d.\n", i );
      return FALSE;
    }
  }
  result = test->sleep(4000);
  if (result != S_OK)
  {
    printf( "Multiple call failed on main thread: 0x%x\n", result );
    return FALSE;
  }
  status = WaitForMultipleObjects( MAX_THREADS, helper, TRUE, INFINITE );
  if (status == WAIT_FAILED)
  {
    printf( "Could not wait for helper threads to die: 0x%x\n", status );
    return FALSE;
  }
  if (!Multicall_Test)
  {
    printf( "Multiple call failed on helper thread.\n" );
    return FALSE;
  }

  // See if methods can correctly call GetMessage.
  another->interrupt( test, TRUE );
  result = test->recurse_interrupt( this, 10 );
  if (result != S_OK)
  {
    printf( "Recursive call with interrupts failed: 0x%x\n", result );
    return FALSE;
  }
  another->interrupt( test, FALSE );

  // Finally, its all over.
  return TRUE;
}

/***************************************************************************/
STDMETHODIMP CTest::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_ITest))
  {
    *ppvObj = (IUnknown *) this;
    AddRef();
    return S_OK;
  }
  else if (IsEqualIID( riid, IID_IMarshal))
  {
    if (custom == NULL)
    {
      custom = new CCMarshal;
      if (custom == NULL)
        return E_FAIL;
    }
    *ppvObj = (IMarshal *) custom;
    custom->AddRef();
    return S_OK;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CTest::Release( THIS )
{
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    WhatNext = quit_wn;
    wake_up_and_smell_the_roses();
    delete this;
    return 0;
  }
  else
    return ref_count;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CTestCF::AddRef( THIS )
{
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CTestCF::CTestCF()
{
  ref_count = 1;
}

/***************************************************************************/
CTestCF::~CTestCF()
{
}

/***************************************************************************/
STDMETHODIMP CTestCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    *ppv = NULL;
    if (pUnkOuter != NULL)
    {
	return E_FAIL;
    }

    if (!IsEqualIID( iidInterface, IID_ITest ))
      return E_NOINTERFACE;

    CTest *Test = new FAR CTest();

    if (Test == NULL)
    {
	return E_OUTOFMEMORY;
    }

    *ppv = Test;
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CTestCF::LockServer(BOOL fLock)
{
    return E_FAIL;
}


/***************************************************************************/
STDMETHODIMP CTestCF::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_IClassFactory))
  {
    *ppvObj = (IUnknown *) this;
    AddRef();
    return S_OK;
  }

  *ppvObj = NULL;
  return E_NOINTERFACE;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CTestCF::Release( THIS )
{
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;
}

/***************************************************************************/
void interrupt()
{
  while (global_interrupt_test)
  {
    global_test->hello();
    check_for_request();
  }
  global_test->Release();
}

//+--------------------------------------------------------------
// Function:    Main
//
// Synopsis:    Executes the BasicBnd test
//
// Effects:     None
//
//
// Returns:     Exits with exit code 0 if success, 1 otherwise
//
// History:     05-Mar-92   Sarahj   Created
//
//---------------------------------------------------------------

int _cdecl main(int argc, char *argv[])
{
  HRESULT result;
  DWORD   wrong;
  BOOL    success = TRUE;
  ITest  *another = NULL;
  ITest  *test = NULL;
  CTest  *tester = new CTest;

  // Initialize Globals.
  MainThread = GetCurrentThreadId();

  // Create an event for termination notification.
  Done = CreateEvent( NULL, FALSE, FALSE, NULL );
  if (Done == NULL)
  {
    printf( "Could not create event.\n" );
    success = FALSE;
    goto exit_main;
  }

  int len;
  TCHAR buffer[80];

  // Look up the thread mode from the win.ini file.
  len = GetProfileString( L"My Section", L"ThreadMode", L"MultiThreaded", buffer,
                          sizeof(buffer) );
  if (lstrcmp(buffer, L"SingleThreaded") == 0)
  {
    thread_mode = COINIT_SINGLETHREADED;
    wrong = COINIT_MULTITHREADED;
    printf( "Testing channel in single threaded mode.\n" );
  }
  else if (lstrcmp(buffer, L"MultiThreaded") == 0)
  {
    thread_mode = COINIT_MULTITHREADED;
    wrong = COINIT_SINGLETHREADED;
    printf( "Testing channel in multithreaded mode.\n" );
  }

  // Initialize OLE.
  result = OleInitializeEx(NULL, thread_mode);
  if (!SUCCEEDED(result))
  {
    success = FALSE;
    printf( "OleInitializeEx failed: %x\n", result );
    goto exit_main;
  }
  result = CoInitializeEx(NULL, thread_mode);
  if (!SUCCEEDED(result))
  {
    success = FALSE;
    printf( "Recalling CoInitializeEx failed: %x\n", result );
    goto exit_main;
  }
  result = CoInitializeEx(NULL, wrong);
  if (result == S_OK)
  {
    success = FALSE;
    printf( "Recalling CoInitializeEx with wrong thread mode succeeded: %x\n", result );
    goto exit_main;
  }
  CoUninitialize();
  CoUninitialize();

  // If this is a server app, register and wait for a quit message.
  if (argv[1] == NULL)
    server = FALSE;
  else
    server = strcmp( argv[1], "-Embedding" ) == 0;
  if (server)
  {
    success = server_loop( );
  }

  // Initialize and run the tests.
  else
  {
    // Get a test object.
    result = CoCreateInstance( CLSID_ITest, NULL, CLSCTX_LOCAL_SERVER,
                               IID_ITest, (void **) &test );
    if (!SUCCEEDED(result))
    {
      printf( "Could not create instance of test server: %x\n", result );
      success = FALSE;
      goto exit_main;
    }

    // Get another test object.
    result = CoCreateInstance( CLSID_ITest, NULL, CLSCTX_LOCAL_SERVER,
                               IID_ITest, (void **) &another );
    if (!SUCCEEDED(result))
    {
      printf( "Could not create another instance of test server: %x\n", result );
      success = FALSE;
      goto exit_main;
    }

    success = tester->DoTest( test, another );
  }

exit_main:

  // Release the external test objects used.
  if (test != NULL)
    test->Release();
  if (another != NULL)
    another->Release();

  // Release the internal test object.
  tester->Release();
  //wait_for_message();

  OleUninitialize();

  if (!server)
    if (success)
      printf("\nChannel Unit Test: PASSED\n");
    else
      printf("\nChannel Unit Test: FAILED\n");

  return !success;
}

//+--------------------------------------------------------------
void check_for_request()
{
  MSG msg;

  if (thread_mode == COINIT_SINGLETHREADED)
  {
    if (PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ))
    {
      TranslateMessage (&msg);
      DispatchMessage (&msg);
    }
  }
}

//+--------------------------------------------------------------
BOOL server_loop(  )
{
  HRESULT result;
  DWORD   dwRegistration;

  // Create our class factory
  WhatNext = wait_wn;
  CTestCF *test_cf = new CTestCF();

  // Register our class with OLE
  result = CoRegisterClassObject(CLSID_ITest, test_cf, CLSCTX_LOCAL_SERVER,
      REGCLS_SINGLEUSE, &dwRegistration);
  if (!SUCCEEDED(result))
  {
    printf( "CoRegisterClassObject failed: %x\n", result );
    return FALSE;
  }

  // CoRegister bumps reference count so we don't have to!
  test_cf->Release();

  // Do whatever we have to do till it is time to pay our taxes and die.
  while (WhatNext != quit_wn)
    switch (WhatNext)
    {

      // Wait till a quit arrives.
      case wait_wn:
        wait_for_message();
        break;

      case interrupt_wn:
        interrupt();
        break;
    }

  // Deregister out class - should release object as well
  result = CoRevokeClassObject(dwRegistration);
  if (!SUCCEEDED(result))
  {
    printf( "CoRevokeClassObject failed: %x\n", result );
    return FALSE;
  }

  return TRUE;
}


/***************************************************************************/
DWORD _stdcall ThreadHelper( void *param )
{
  ITest   *test = (ITest *) param;
  HRESULT  result;

  // Call the server.
  result = test->sleep( 2000 );

  // Check the result for single threaded mode.
  if (thread_mode == COINIT_SINGLETHREADED)
  {
    if (SUCCEEDED(result))
    {
      Multicall_Test = FALSE;
      printf( "Call succeeded on wrong thread in single threaded mode: 0x%x.\n",
              result );
    }
#if DBG==1
    else if (DebugCoGetRpcFault() != RPC_E_ATTEMPTED_MULTITHREAD)
    {
      printf( "Multithread failure code was 0x%x not 0x%x\n",
              DebugCoGetRpcFault(), RPC_E_ATTEMPTED_MULTITHREAD );
      Multicall_Test = FALSE;
    }
#endif
  }

  // Check the result for multithreaded mode.
  else if (result != S_OK)
  {
    printf( "Could not make multiple calls in multithreaded mode: 0x%x\n",
            result );
      Multicall_Test = FALSE;
  }

#define DO_DA 42
  return DO_DA;
}

/***************************************************************************/
void wait_for_message()
{
  MSG   msg;
  DWORD status;

  if (thread_mode == COINIT_MULTITHREADED)
  {
    status = WaitForSingleObject( Done, INFINITE );
    if (status != WAIT_OBJECT_0 )
    {
      printf( "Could not wait for event.\n" );
    }
  }
  else
  {
    while (GetMessage( &msg, NULL, 0, 0 ) && msg.message != WM_USER)
    {
      TranslateMessage (&msg);
      DispatchMessage (&msg);
    }
  }
}

/***************************************************************************/
void wake_up_and_smell_the_roses()
{
  if (thread_mode == COINIT_MULTITHREADED)
    SetEvent( Done );
  else
    PostThreadMessage(MainThread, WM_USER, 0, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cmarshal\idl\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       PCH.CXX
//
//  Contents:   Precompiled header
//
//  History:    12-Jul-93 ShannonC  Created
//
//--------------------------------------------------------------------------

#include "stdrpc.hxx"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\channel\idl\makefile.inc ===
itest.h: itest.idl
     midl itest.idl                \
          -internal                \
          -Zp8                     \
          -I$(INCLUDES:;= -I)      \
          -ms_ext                  \
          -c_ext                   \
          -Os                      \
          -out ..\app              \
          -header ..\idl\itest.h   \
          -iid ..\app\itest_i.c    \
          $(C_DEFINES)             \
          -DMIDL_PASS

async.h: async.idl
     midl async.idl                \
          -internal                \
          -Zp8                     \
          -I$(INCLUDES:;= -I)      \
          -ms_ext                  \
          -c_ext                   \
          -Os                      \
          -out ..\app              \
          -header ..\idl\async.h   \
          -iid ..\app\async_i.c    \
          $(C_DEFINES)             \
          -DMIDL_PASS

dog.h: dog.idl
     midl dog.idl                  \
          -Zp8                     \
          -I$(INCLUDES:;= -I)      \
          -ms_ext                  \
          -c_ext                   \
          -Os                      \
          -out ..\app              \
          -header ..\idl\dog.h     \
          -iid ..\app\dog_i.c      \
          -prefix server x         \
          $(C_DEFINES)             \
          -DMIDL_PASS

#
# This target compiles all .idl files into their corresponding _?.c?? and
# .h components
#
allidl:   itest.h dog.h async.h

clean:
          erase itest.h  >NUL 2>NUL
          erase dog.h  >NUL 2>NUL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cmarshal\app\app_i.c ===
#pragma warning(disable:4101)    // Ignore variable not use warning

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: iperf_i.c
//
//  Contents: IID_IPerf
//
//  History: Created by Microsoft (R) MIDL Compiler Version 1.10.83
//
//--------------------------------------------------------------------------
typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;


const IID CLSID_ITest =
{0x60000430, 0xAB0F, 0x101A, {0xB4, 0xAE, 0x08, 0x00, 0x2B, 0x30, 0x61, 0x2C}};


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cmarshal\app\cmarshal.cxx ===
//+-------------------------------------------------------------------
//
//  File:       cmarshal.cxx
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      DllGetClassObject (Bindings key func)
//                      CBasicBndCF (class factory)
//                      CBasicBnd   (actual class implementation)
//
//  Classes:    CBasicBndCF, CBasicBnd
//
//
//  History:	30-Nov-92      SarahJ      Created
//
//---------------------------------------------------------------------

#include    <windows.h>
#include    <ole2.h>
#include    "app.hxx"


/***************************************************************************/
STDMETHODIMP_(ULONG) CCMarshal::AddRef( THIS )
{
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CCMarshal::CCMarshal()
{
  ref_count  = 1;
}

/***************************************************************************/
CCMarshal::~CCMarshal()
{
}

/***************************************************************************/
STDMETHODIMP CCMarshal::sick( ULONG val )
{
  return proxy->sick( val );
}

/***************************************************************************/
STDMETHODIMP CCMarshal::die_cpp( ULONG val )
{
  return proxy->die_cpp( val );
}

/***************************************************************************/
STDMETHODIMP CCMarshal::die_nt( ULONG val )
{
  return proxy->die_nt( val );
}

/***************************************************************************/
STDMETHODIMP_(DWORD) CCMarshal::die( ITest *callback, ULONG catch_depth,
                                ULONG throw_depth, ULONG throw_val )
{
  return proxy->die( callback, catch_depth, throw_depth, throw_val );
}

/***************************************************************************/
STDMETHODIMP CCMarshal::interrupt( ITest *param, BOOL go )
{
  return proxy->interrupt( param, go );
}

/***************************************************************************/
STDMETHODIMP_(BOOL) CCMarshal::hello()
{
  return proxy->hello();
}

/***************************************************************************/
STDMETHODIMP CCMarshal::recurse( ITest *callback, ULONG depth )
{
  return proxy->recurse( callback, depth );
}

/***************************************************************************/
STDMETHODIMP CCMarshal::recurse_interrupt( ITest *callback, ULONG depth )
{
  return proxy->recurse_interrupt( callback, depth );
}

/***************************************************************************/
STDMETHODIMP CCMarshal::sleep( ULONG time )
{
  return proxy->sleep( time );
}

/***************************************************************************/
STDMETHODIMP_(DWORD) CCMarshal::DoTest( ITest *test, ITest *another )
{
  return proxy->DoTest( test, another );
}

/***************************************************************************/
STDMETHODIMP CCMarshal::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_ITest))
  {
    *ppvObj = (ITest *) this;
    AddRef();
    return S_OK;
  }
  else
  {
    *ppvObj = NULL;
    return E_NOINTERFACE;
  }
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CCMarshal::Release( THIS )
{
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;
}


/***************************************************************************/
STDMETHODIMP_(ULONG) CCMarshalCF::AddRef( THIS )
{
  InterlockedIncrement( (long *) &ref_count );
  return ref_count;
}

/***************************************************************************/
CCMarshalCF::CCMarshalCF()
{
  ref_count = 1;
}

/***************************************************************************/
CCMarshalCF::~CCMarshalCF()
{
}

/***************************************************************************/
STDMETHODIMP CCMarshalCF::CreateInstance(
    IUnknown FAR* pUnkOuter,
    REFIID iidInterface,
    void FAR* FAR* ppv)
{
    *ppv = NULL;
    if (pUnkOuter != NULL)
    {
	return E_FAIL;
    }

    if (!IsEqualIID( iidInterface, IID_ITest ))
      return E_NOINTERFACE;

    CCMarshal *Test = new FAR CCMarshal();

    if (Test == NULL)
    {
	return E_OUTOFMEMORY;
    }

    *ppv = Test;
    return S_OK;
}

/***************************************************************************/
STDMETHODIMP CCMarshalCF::LockServer(BOOL fLock)
{
    return E_FAIL;
}


/***************************************************************************/
STDMETHODIMP CCMarshalCF::QueryInterface( THIS_ REFIID riid, LPVOID FAR* ppvObj)
{
  if (IsEqualIID(riid, IID_IUnknown) ||
     IsEqualIID(riid, IID_IClassFactory))
  {
    *ppvObj = (IUnknown *) this;
    AddRef();
    return S_OK;
  }

  *ppvObj = NULL;
  return E_NOINTERFACE;
}

/***************************************************************************/
STDMETHODIMP_(ULONG) CCMarshalCF::Release( THIS )
{
  if (InterlockedDecrement( (long*) &ref_count ) == 0)
  {
    delete this;
    return 0;
  }
  else
    return ref_count;
}



CMarshalBase::CMarshalBase()
{
  proxy = NULL;
  marshaller = NULL;
}


CMarshalBase::~CMarshalBase()
{
  if (proxy != NULL)
  {
    proxy->Release();
    proxy = NULL;
  }
  if (marshaller != NULL)
  {
    marshaller->Release();
    marshaller = NULL;
  }
}


// Returns the clsid of the object that created this CMarshalBase.
//
 STDMETHODIMP CMarshalBase::GetUnmarshalClass(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, CLSID * pCid)
{
    *pCid = CLSID_ITest;
    return S_OK;
}


 STDMETHODIMP CMarshalBase::GetMarshalSizeMax(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, DWORD * pSize)
{
  SCODE result;

  if (marshaller == NULL)
  {
    result = CoGetStandardMarshal( riid, this, dwDestContext, pvDestContext,
                                    mshlflags, &marshaller );
    if (FAILED(result))
      return result;
  }
  return marshaller->GetMarshalSizeMax( riid, this, dwDestContext,
                                        pvDestContext, mshlflags, pSize );
}


 STDMETHODIMP CMarshalBase::MarshalInterface(IStream * pStm,
     REFIID riid, void * pv,
     DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags)
{
  SCODE result;

  if (marshaller == NULL)
    return E_FAIL;

  result = marshaller->MarshalInterface( pStm, riid, this, dwDestContext,
                                         pvDestContext, mshlflags );
  if (SUCCEEDED(result))
  {
    proxy = (ITest *) pv;
    ((IUnknown *) pv)->AddRef();
  }
  return result;
}


 STDMETHODIMP CMarshalBase::UnmarshalInterface(IStream * pStm,
					REFIID riid, void * * ppv)
{
  SCODE result;

  if (marshaller == NULL)
  {
    result = CoGetStandardMarshal( riid, this, 0, NULL,
                                    MSHLFLAGS_NORMAL, &marshaller );
    if (FAILED(result))
      return result;
  }

  result = marshaller->UnmarshalInterface( pStm, riid, (void **) &proxy );
  if (SUCCEEDED(result))
  {
    *ppv = this;
    AddRef();
  }
  else
    *ppv = NULL;
  return result;
}


 STDMETHODIMP CMarshalBase::ReleaseMarshalData(IStream * pStm)
{
  return marshaller->ReleaseMarshalData( pStm );
}


 STDMETHODIMP CMarshalBase::DisconnectObject(DWORD dwReserved)
{
  return marshaller->DisconnectObject( dwReserved );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\dll\cairo\makefile.inc ===
obj\i386\oleimpl.def: oleimpl.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\dll\daytona\makefile.inc ===
obj\i386\oleimpl.def: oleimpl.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\dll\chicago\makefile.inc ===
obj\i386\oleimpl.def: oleimpl.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\cmarshal\cmarshal\inproc.cxx ===
#include    <windows.h>
#include    <ole2.h>
#include    <app.hxx>

//+-------------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Entry point to DLL - does little else
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------



//
//  Entry point to DLL is traditional LibMain
//  Do nothing in here
//


extern "C" BOOL _cdecl LibMain ( HINSTANCE hinst,
                          HANDLE    segDS,
                          UINT      cbHeapSize,
			  LPTSTR    lpCmdLine)
{
    return TRUE;
}


//+-------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Called by client (from within BindToObject et al)
//              interface requested  should be IUnknown or IClassFactory -
//              Creates ClassFactory object and returns pointer to it
//
//  Arguments:  REFCLSID clsid    - class id
//              REFIID iid        - interface id
//              void FAR* FAR* ppv- pointer to class factory interface
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------


STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    if (!IsEqualIID(iid, IID_IUnknown) && !IsEqualIID(iid, IID_IClassFactory))
    {
	return E_NOINTERFACE;
    }

    if (IsEqualIID(clsid, CLSID_ITest))
    {
      *ppv = new CCMarshalCF();
      return S_OK;
    }

    return E_FAIL;
}


STDAPI DllCanUnloadNow(void)
{
    return S_FALSE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\common\oleport.h ===
#ifndef __OLEPORT_H__
#define __OLEPORT_H__

#include    <string.h>
#include    <stdlib.h>

#ifdef __cplusplus
// BUGBUG:  This definition is here to ease porting. In the future
//          it s/b removed to use the single official definition along
//          with all the changes that will be required in the code.
#define GUID_DEFINED

struct GUID
{
        unsigned long Data1;
        unsigned short Data2;
        unsigned short Data3;
        unsigned char Data4[8];

    int operator==(const GUID& iidOther) const
        { return !memcmp(&Data1, &iidOther.Data1, sizeof(GUID)); }

    int operator!=(const GUID& iidOther) const
        { return !((*this) == iidOther); }
};
#endif // __cplusplus

#include    <windows.h>

// Handle port problems easily
#define WIN32

#ifdef _NTIDW340
#ifdef __cplusplus
#define jmp_buf int
#endif // __cplusplus
#endif // _NTIDW340

// PORT: HTASK no longer seems to be defined in Win32
#define HTASK DWORD
#define HINSTANCE_ERROR 32
#define __loadds
#define __segname
#define BASED_CODE
#define HUGE
#define _ffree free
#define __based(x)
#include <port1632.h>

#endif // __OLEPORT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\dll\oleimpl.cxx ===
//+-------------------------------------------------------------------
//
//  File:       oleimpl.cxx
//
//  Contents:   This file contins the DLL entry points
//                      LibMain
//                      DllGetClassObject (Bindings key func)
//                      CBasicBndCF (class factory)
//                      CBasicBnd   (actual class implementation)
//
//  Classes:    CBasicBndCF, CBasicBnd
//
//
//  History:	30-Nov-92      SarahJ       Created
//              31-Dec-93      ErikGav      Chicago port
//              30-Jun-94      AndyH        Add call to another DLL
//
//---------------------------------------------------------------------

// Turn off ole Cairol IUnknown
#include    <windows.h>
#include    <ole2.h>
#include    <debnot.h>
#include    <com.hxx>
#include    "oleimpl.hxx"
extern "C" {
#include "..\oledll2\oledll2.h" 
}

ULONG g_UseCount = 0;

CBasicBndCF *g_pcf = NULL;

static const char *szFatalError = "OLEIMPL.DLL - Fatal Error";

void MsgBox(char *pszMsg)
{
    MessageBoxA(NULL, pszMsg, szFatalError, MB_OK);
}

void HrMsgBox(char *pszMsg, HRESULT hr)
{
    char awcBuf[512];

    // Build string for output
    wsprintfA(awcBuf, "%s HRESULT = %lx", pszMsg, hr);

    // Display message box
    MessageBoxA(NULL, &awcBuf[0], szFatalError, MB_OK);
}


//+-------------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Entry point to DLL - does little else
//              Added call to anther DLL.  This is to test loading of in
//              InProcServer that uses another statically linked DLL.  
//              The extra DLL (OleDll2.DLL) should not be on the path 
//              when the test is run.  The entry point FuntionInAnotherDLL
//              is exported by OleDll2.DLL
//
//  Arguments:
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------



//
//  Entry point to DLL is traditional LibMain
//  Call FunctionInAnotherDLL().
//


extern "C" BOOL _cdecl LibMain ( HINSTANCE hinst,
                          HANDLE    segDS,
                          UINT      cbHeapSize,
			  LPTSTR    lpCmdLine)
{
    FunctionInAnotherDLL();
    return TRUE;
}


//+-------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Called by client (from within BindToObject et al)
//              interface requested  should be IUnknown or IClassFactory -
//              Creates ClassFactory object and returns pointer to it
//
//  Arguments:  REFCLSID clsid    - class id
//              REFIID iid        - interface id
//              void FAR* FAR* ppv- pointer to class factory interface
//
//  Returns:    TRUE
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------


STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    if (!GuidEqual(iid,	IID_IUnknown) && !GuidEqual(iid, IID_IClassFactory))
    {
	return E_NOINTERFACE;
    }

    if (GuidEqual(clsid, CLSID_BasicBnd))
    {
	if (g_pcf)
	{
	    *ppv = g_pcf;
	    g_pcf->AddRef();
	}
	else
	{
	    *ppv = new CBasicBndCF();
	}

	return (*ppv != NULL) ? S_OK : E_FAIL;
    }

    return E_FAIL;
}


STDAPI DllCanUnloadNow(void)
{
    return (g_UseCount == 0)
	? S_OK
	: S_FALSE;
}

//+-------------------------------------------------------------------
//
//  Class:    CBasicBndCF
//
//  Synopsis: Class Factory for CBasicBnd
//
//  Interfaces:  IUnknown      - QueryInterface, AddRef, Release
//               IClassFactory - CreateInstance
//
//  History:  21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------


//+-------------------------------------------------------------------
//
//  Member:     CBasicBndCF::CBasicBndCF()
//
//  Synopsis:   The constructor for CBAsicBnd.
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBndCF::CBasicBndCF() : _cRefs(1)
{
    g_UseCount++;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndObj()
//
//  Synopsis:   The destructor for CBAsicBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBndCF::~CBasicBndCF()
{
    g_UseCount--;
    return;
}


//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::QueryInterface
//
//  Synopsis:   Only IUnknown and IClassFactory supported
//
//--------------------------------------------------------------------


STDMETHODIMP CBasicBndCF::QueryInterface(REFIID iid, void FAR * FAR * ppv)
{
    if (GuidEqual(iid, IID_IUnknown) || GuidEqual(iid, IID_IClassFactory))
    {
        *ppv = this;
	AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG) CBasicBndCF::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CBasicBndCF::Release(void)
{
    ULONG cRefs = --_cRefs;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}



//+-------------------------------------------------------------------
//
//  Method:     CBasicBndCF::CreateInstance
//
//  Synopsis:   This is called by Binding process to create the
//              actual class object
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBndCF::CreateInstance(IUnknown FAR* pUnkOuter,
	                                 REFIID iidInterface,
                                         void FAR* FAR* ppv)
{
    HRESULT hresult = S_OK;

    class CUnknownBasicBnd *pubb = new FAR CUnknownBasicBnd(pUnkOuter);

    if (pubb == NULL)
    {
	return E_OUTOFMEMORY;
    }

    //	Because when an aggregate is being requested, the controlling
    //	must be returned, no QI is necessary.
    if (pUnkOuter == NULL)
    {
	hresult = pubb->QueryInterface(iidInterface, ppv);

	pubb->Release();
    }
    else
    {
	*ppv = (void *) pubb;
    }

    return hresult;
}

//+-------------------------------------------------------------------
//
//  Method:	CBasicBndCF::LockServer
//
//  Synopsis:	Who knows what this is for?
//
//--------------------------------------------------------------------

STDMETHODIMP CBasicBndCF::LockServer(BOOL fLock)
{
    return E_FAIL;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::CBasicBnd()
//
//  Synopsis:   The constructor for CBAsicBnd. I
//
//  Arguments:  None
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBnd::CBasicBnd(IUnknown *punk)
    : _punk(punk), _pmkContainer(NULL)
{
    // Create storage for "contained" objects
    SCODE sc = StgCreateDocfile(NULL,
	STGM_DELETEONRELEASE|STGM_DFRALL|STGM_CREATE, 0, &_psStg1);

    if (sc != S_OK)
    {
        HrMsgBox("CBasicBnd::CBasicBnd Create of first storage failed", sc);
    }

    sc = StgCreateDocfile(NULL,
	STGM_DELETEONRELEASE|STGM_DFRALL|STGM_CREATE, 0, &_psStg2);

    if (sc != S_OK)
    {
        HrMsgBox("CBasicBnd::CBasicBnd Create of second storage failed", sc);
    }
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::~CBasicBndObj()
//
//  Synopsis:   The destructor for CBAsicBnd.
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

CBasicBnd::~CBasicBnd()
{
    if (_pmkContainer)
    {
	_pmkContainer->Release();
    }

    if (_psStg1)
    {
	_psStg1->Release();
    }

    if (_psStg2)
    {
	_psStg2->Release();
    }

    return;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::QueryInterface
//
//  Returns:	S_OK
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------


STDMETHODIMP CBasicBnd::QueryInterface(REFIID iid, void **ppiuk)
{
    return _punk->QueryInterface(iid, ppiuk);
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::AddRef
//
//  Synopsis:   Standard stuff
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP_(ULONG) CBasicBnd::AddRef(void)
{
    return _punk->AddRef();
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Release
//
//  Synopsis:   Standard stuff
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------

STDMETHODIMP_(ULONG) CBasicBnd::Release(void)
{
    return _punk->Release();
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Load
//
//  Synopsis:   IPeristFile interface - needed 'cause we bind with
//              file moniker and BindToObject insists on calling this
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::Load(LPCWSTR lpszFileName, DWORD grfMode)
{
    if (grfMode & ~(STGM_READWRITE | STGM_SHARE_EXCLUSIVE))
    {
	// Test requires default bind storage request and caller
	// has set some other bits so we fail.
	return STG_E_INVALIDPARAMETER;
    }

    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::Save
//
//  Synopsis:   IPeristFile interface - save
//              does little but here for commentry
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::Save(LPCWSTR lpszFileName, BOOL fRemember)
{
    return S_OK;
}


//+-------------------------------------------------------------------
//
//  Member:     CBasicBnd::SaveCpmpleted
//              CBasicBnd::GetCurFile
//              CBasicBnd::IsDirty
//
//  Synopsis:   More IPeristFile interface methods
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::SaveCompleted(LPCWSTR lpszFileName)
{
    return S_OK;
}

STDMETHODIMP CBasicBnd::GetCurFile(LPWSTR FAR *lpszFileName)
{
    return S_OK;
}

STDMETHODIMP CBasicBnd::IsDirty()
{
    return S_OK;
}

//+-------------------------------------------------------------------
//
//  Interface:  IPersist
//
//  Synopsis:   IPersist interface methods
//              Need to return a valid class id here
//
//  History:    21-Nov-92  SarahJ  Created
//

STDMETHODIMP CBasicBnd::GetClassID(LPCLSID classid)
{
    *classid = CLSID_BasicBnd;
    return S_OK;
}

// *** IOleObject methods ***
STDMETHODIMP CBasicBnd::SetClientSite(LPOLECLIENTSITE pClientSite)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetClientSite(LPOLECLIENTSITE FAR* ppClientSite)
{
    return E_FAIL;
}


STDMETHODIMP CBasicBnd::SetHostNames(
    LPCWSTR szContainerApp,
    LPCWSTR szContainerObj)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::Close(DWORD dwSaveOption)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetMoniker(DWORD dwWhichMoniker, LPMONIKER pmk)
{
    if (_pmkContainer)
    {
	_pmkContainer->Release();

    }

    _pmkContainer = pmk;

    pmk->AddRef();

    return S_OK;
}

STDMETHODIMP CBasicBnd::GetMoniker(
    DWORD dwAssign,
    DWORD dwWhichMoniker,
    LPMONIKER FAR* ppmk)
{
    if (_pmkContainer != NULL)
    {
	*ppmk = _pmkContainer;
	_pmkContainer->AddRef();
	return S_OK;
    }

    return E_FAIL;
}

STDMETHODIMP CBasicBnd::InitFromData(
    LPDATAOBJECT pDataObject,
    BOOL fCreation,
    DWORD dwReserved)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetClipboardData(
    DWORD dwReserved,
    LPDATAOBJECT FAR* ppDataObject)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::DoVerb(
   LONG iVerb,
   LPMSG lpmsg,
   LPOLECLIENTSITE pActiveSite,
   LONG reserved,
   HWND hwndParent,
   LPCRECT lprcPosRect)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::EnumVerbs(IEnumOLEVERB FAR* FAR* ppenumOleVerb)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::Update(void)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::IsUpToDate(void)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetUserClassID(CLSID FAR* pClsid)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetUserType(DWORD dwFormOfType, LPWSTR FAR* pszUserType)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetExtent(DWORD dwDrawAspect, LPSIZEL lpsizel)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::Advise(
    IAdviseSink FAR* pAdvSink,
    DWORD FAR* pdwConnection)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::Unadvise(DWORD dwConnection)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::EnumAdvise(LPENUMSTATDATA FAR* ppenumAdvise)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::GetMiscStatus(DWORD dwAspect, DWORD FAR* pdwStatus)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::SetColorScheme(LPLOGPALETTE lpLogpal)
{
    return E_FAIL;
}

// *** IParseDisplayName method ***
STDMETHODIMP CBasicBnd::ParseDisplayName(
    LPBC pbc,
    LPWSTR lpszDisplayName,
    ULONG FAR* pchEaten,
    LPMONIKER FAR* ppmkOut)
{
    *pchEaten = wcslen(lpszDisplayName);
    return CreateItemMoniker(L"\\", lpszDisplayName, ppmkOut);
}

// *** IOleContainer methods ***
STDMETHODIMP CBasicBnd::EnumObjects(
    DWORD grfFlags,
    LPENUMUNKNOWN FAR* ppenumUnknown)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::LockContainer(BOOL fLock)
{
    return E_FAIL;
}

// *** IOleItemContainer methods ***
STDMETHODIMP CBasicBnd::GetObject(
    LPWSTR lpszItem,
    DWORD dwSpeedNeeded,
    LPBINDCTX pbc,
    REFIID riid,
    LPVOID FAR* ppvObject)
{
    IStorage *psStorage;
    IOleObject *poo;
    IUnknown *punk;

    if (wcscmp(lpszItem, L"1") == 0)
    {
	psStorage = _psStg1;
    }
    else if (wcscmp(lpszItem, L"2") == 0)
    {
	psStorage = _psStg2;
    }
    else
    {
	return E_FAIL;
    }

    IOleClientSite * pocsObjCliSite;

    HRESULT hresult = QueryInterface(IID_IOleClientSite,
	(void **) &pocsObjCliSite);

    // Call OleCreate to create our embedded object
    hresult = OleCreate(
               CLSID_TestEmbed,         // Class ID of the object we are
                                        //   creating
               IID_IOleObject,          // Interface by which we want to talk
                                        //   to the object
               OLERENDER_NONE,          // We don't want to draw the object
                                        //   when it is not active
               NULL,                    // Used if we do draw the object when
                                        //   it is non-active
               pocsObjCliSite,          // IOleClientSite the server will use
               psStorage,               // IStorage the server will use
	       (void **) &poo);		// Pointer to the object

    if (FAILED(hresult))
    {
        HrMsgBox("CBasicBnd::GetObject OlCreate Failed!", hresult);
        return hresult;
    }

    // Set the client site
    hresult = poo->SetClientSite(pocsObjCliSite);

    if (FAILED(hresult))
    {
        HrMsgBox("CBasicBnd::GetObject SetClientSite failed!", hresult);
        return hresult;
    }

    hresult = poo->QueryInterface(IID_IUnknown, (void **)&punk);

    if (FAILED(hresult))
    {
        HrMsgBox("CBasicBnd::GetObject QI to IUnknown failed!", hresult);
        return hresult;
    }

    hresult = OleRun(punk);

    if (FAILED(hresult))
    {
        HrMsgBox("CBasicBnd::GetObject OleRun failed!", hresult);
        return hresult;
    }

    punk->Release();

    LPRECT lprPosRect = (LPRECT) new RECT;

    hresult = poo->DoVerb(
		 OLEIVERB_SHOW,     // Verb we are invoking
		 NULL,		    // MSG that causes us to do this verb
		 pocsObjCliSite,    // Client site of this object
		 0,		    // Reserved - definitive value?
		 0,		    // hwndParent - ???
		 lprPosRect);	    // lprcPosRect - rectangle wrt hwndParent

    if (FAILED(hresult))
    {
        HrMsgBox("CBasicBnd::GetObject DoVerb  failed!", hresult);
        return hresult;
    }

    delete lprPosRect;

    pocsObjCliSite->Release();

    *ppvObject = (void *) poo;

    return hresult;
}

STDMETHODIMP CBasicBnd::GetObjectStorage(
    LPWSTR lpszItem,
    LPBINDCTX pbc,
    REFIID riid,
    LPVOID FAR* ppvStorage)
{
    return E_FAIL;
}

STDMETHODIMP CBasicBnd::IsRunning(LPWSTR lpszItem)
{
    return E_FAIL;
}

CUnknownBasicBnd::CUnknownBasicBnd(IUnknown *punk)
    : _pbasicbnd(NULL), _cRefs(1)
{
    if (punk == NULL)
    {
	punk = (IUnknown *) this;
    }

    // BUGBUG: No error checking!
    _pbasicbnd = new CBasicBnd(punk);
    g_UseCount++;
}

CUnknownBasicBnd::~CUnknownBasicBnd(void)
{
    g_UseCount--;
    delete _pbasicbnd;
}



//+-------------------------------------------------------------------
//
//  Member:	CUnknownBasicBnd::QueryInterface
//
//  Returns:	S_OK
//
//  History:    21-Nov-92  SarahJ  Created
//
//--------------------------------------------------------------------


STDMETHODIMP CUnknownBasicBnd::QueryInterface(
    REFIID iid,
    void **ppiuk)
{
    if (GuidEqual(iid, IID_IUnknown))
    {
	*ppiuk = (IUnknown *) this;
    }
    else if (GuidEqual(iid, IID_IOleClientSite))
    {
	*ppiuk = (IOleClientSite *) _pbasicbnd;
    }
    else if (GuidEqual(iid, IID_IPersistFile)
	|| GuidEqual(iid, IID_IPersist))
    {
	*ppiuk = (IPersistFile *) _pbasicbnd;
    }
    else if (GuidEqual(iid, IID_IOleObject))
    {
	*ppiuk = (IOleObject *) _pbasicbnd;
    }
    else if (GuidEqual(iid, IID_IOleItemContainer))
    {
	*ppiuk = (IOleItemContainer *)_pbasicbnd;
    }
    else if (GuidEqual(iid, IID_IOleContainer))
    {
	*ppiuk = (IOleContainer *)_pbasicbnd;
    }
    else if (GuidEqual(iid, IID_IParseDisplayName))
    {
	*ppiuk = (IParseDisplayName *)_pbasicbnd;
    }
    else
    {
        *ppiuk = NULL;
	return E_NOINTERFACE;
    }

    _pbasicbnd->AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CUnknownBasicBnd::AddRef(void)
{
    return ++_cRefs;
}

STDMETHODIMP_(ULONG) CUnknownBasicBnd::Release(void)
{
    ULONG cRefs = --_cRefs;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}



#ifdef CAIROLE_DOWNLEVEL

extern "C"
{
	EXPORTDEF void APINOT
	RegisterWithCommnot(void);

	EXPORTDEF void APINOT
	DeRegisterWithCommnot(void);
}

//+-------------------------------------------------------------------
//
//  Function:   RegisterWithCommnot
//
//  Synopsis:	Used by Cairo to work around DLL unloading problems
//
//  Arguments:  <none>
//
//  History:	06-Oct-92  BryanT	Created
//
//--------------------------------------------------------------------
EXPORTIMP void APINOT
RegisterWithCommnot( void )
{
}

//+-------------------------------------------------------------------
//
//  Function:   DeRegisterWithCommnot
//
//  Synopsis:	Used by Cairo to work around DLL unloading problems
//
//  Arguments:  <none>
//
//  History:	06-Oct-92  BryanT	Created
//
//  Notes:	BUGBUG: Keep in touch with BryanT to see if this is
//		obsolete.
//
//--------------------------------------------------------------------

EXPORTIMP void APINOT
DeRegisterWithCommnot( void )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\dll\iclisite.cxx ===
//+-------------------------------------------------------------
// File:        iclisite.cxx
//
// Contents:    CObjClientSite object implementation
//
// Methods:     CObjClientSite
//              ~CObjClientSite
//              Create
//              QueryInterface
//              AddRef
//              Release
//              SaveObject    (NYI)
//              GetMoniker    (NYI)
//              GetContainer
//              ShowObject    (NYI)
//              OnShowWindow
//
// History:     04-Dec-92   Created     DeanE
//---------------------------------------------------------------
#pragma optimize("",off)
#include <windows.h>
#include <ole2.h>
#include <com.hxx>
#include "oleimpl.hxx"

//+-------------------------------------------------------------------
//  Method:	CBasicBnd::SaveObject
//
//  Synopsis:   See spec 2.00.09 p107.  This object should be saved.
//
//  Returns:    Should always return S_OK.
//
//  History:    04-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::SaveObject(void)
{
    // BUGBUG - NYI
    //   Returning S_OK tells OLE that we actually saved this object
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:	CBasicBnd::GetContainer
//
//  Synopsis:   See spec 2.00.09 p108.  Return the container in which
//              this object is found.
//
//  Returns:    Should return S_OK.
//
//  History:    04-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::GetContainer(LPOLECONTAINER FAR *ppContainer)
{
    return QueryInterface(IID_IOleContainer, (void **) ppContainer);
}


//+-------------------------------------------------------------------
//  Method:	CBasicBnd::ShowObject
//
//  Synopsis:   See spec 2.00.09 p109.  Server for this object is asking
//              us to display it.  Caller should not assume we have
//              actually worked, but we return S_OK either way.  Great!
//
//  Returns:    S_OK whether we work or not...
//
//  History:    04-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::ShowObject(void)
{
    return(S_OK);
}


//+-------------------------------------------------------------------
//  Method:	CBasicBnd::OnShowWindow
//
//  Synopsis:   ???
//
//  Parameters: [fShow] -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::OnShowWindow(BOOL fShow)
{
    return(S_OK);
}



//+-------------------------------------------------------------------
//  Method:	CBasicBnd::RequestNewObjectLayout
//
//  Synopsis:   ???
//
//  Parameters: [fShow] -
//
//  Returns:    S_OK?
//
//  History:    16-Dec-92   DeanE   Created
//--------------------------------------------------------------------
STDMETHODIMP CBasicBnd::RequestNewObjectLayout(void)
{
    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\inc\tstclsid.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	tstclsid.h
//
//  Contents:	CLSID's for various test apps
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//		08-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef __TSTCLSID_H
#define __TSTCLSID_H

extern "C" CLSID CLSID_SimpleServer;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\inc\testmess.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	testmess.h
//
//  Contents:	Declarations for private test messages
//
//  Classes:
//
//  Functions:
//
//  History:    dd-mmm-yy Author    Comment
//		06-Feb-94 alexgo    author
//
//--------------------------------------------------------------------------

#ifndef __TESTMESS_H
#define __TESTMESS_H

#define TEST_SUCCESS	0
#define TEST_FAILURE	1
#define TEST_UNKNOWN	2

// Test End:  sent back to the driver from the test app idicating the
// success or failure of the test (and optionally a failure code)
//	wParam == TEST_SUCCESS | TEST_FAILURE
//	lParam == HRESULT (optional)
#define	WM_TESTEND	WM_USER + 1

// Test Register: sent back to the driver from the test app giving
// the driver a window handle that it can send messages to.
//	wParam == HWND of the test app
#define WM_TESTREG	WM_USER + 2

// Tests Completed:  used to indicate that all requested tests have
// been completed
#define WM_TESTSCOMPLETED WM_USER + 3

// Test Start: used to kick the task stack interpreter into action
#define WM_TESTSTART	WM_USER + 4

// Individual test messages.  Sent by the driver app to the test app
// telling it to start an individual test.
#define WM_TEST1	WM_USER + 10
#define WM_TEST2	WM_USER + 11
#define WM_TEST3	WM_USER + 12
#define WM_TEST4	WM_USER + 13
#define WM_TEST5	WM_USER + 14

#endif  // !__TESTMESS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\bttncur\bttncur.c ===
/*
 * BTTNCUR.C
 * Buttons & Cursors Version 1.1, Win32 version August 1993
 *
 * Public functions to generate different states of toolbar buttons from
 * a single bitmap.  States are normal, pressed, checked, and disabled.
 *
 * Copyright (c)1992-1993 Microsoft Corporation, All Rights Reserved,
 * as applied to redistribution of this source code in source form
 * License is granted to use of compiled code in shipped binaries.
 */

#ifdef WIN32
#define _INC_OLE
#define __RPC_H__
#endif

#include <windows.h>
#include <memory.h>
#include "bttncur.h"
#include "bttncuri.h"


//Display sensitive information
TOOLDISPLAYDATA     tdd;

//Library instance
HINSTANCE           ghInst;


//Cache GDI objects to speed drawing.
HDC     hDCGlyphs    = NULL;
HDC     hDCMono      = NULL;
HBRUSH	hBrushDither = NULL;

// Common clean up code
void FAR PASCAL WEP(int bSystemExit);


//Standard images to use in case caller doesn't provide them
HBITMAP rghBmpStandardImages[3];

//Standard button colors.
const COLORREF crStandard[4]={ RGB(0, 0, 0)          //STDCOLOR_BLACK
                             , RGB(128, 128, 128)    //STDCOLOR_DKGRAY
                             , RGB(192, 192, 192)    //STDCOLOR_LTGRAY
                             , RGB(255, 255, 255)};  //STDCOLOR_WHITE


/*
 * Mapping from image identifier to button type (command/attribute).
 * Version 1.00 of this DLL has no attribute images defined, so
 * the code will only support three states for each command
 * button.  Any state is, however, valid for an application
 * defined image.
 */

UINT mpButtonType[TOOLIMAGE_MAX-TOOLIMAGE_MIN+1]=
        {
        BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND,
        BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND,
        BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND, BUTTONTYPE_COMMAND
        };



/*
 * LibMain
 *
 * Purpose:
 *  Entry point conditionally compiled for Windows NT and Windows
 *  3.1.  Provides the proper structure for each environment
 *  and calls InternalLibMain for real initialization.
 */

#ifdef WIN32
BOOL _cdecl LibMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpvReserved)
    {
    if (DLL_PROCESS_ATTACH == dwReason)
	{
	return FInitialize(hDll);
        }
    else if (DLL_PROCESS_DETACH == dwReason)
	{
	WEP(0);
	}
    else
        {
	return TRUE;
        }
    }

#else
HANDLE FAR PASCAL LibMain(HANDLE hInstance, WORD wDataSeg
    , WORD cbHeapSize, LPSTR lpCmdLine)
    {
     //Perform global initialization.
    if (FInitialize(hInstance))
        {
        if (0!=cbHeapSize)
            UnlockData(0);
        }

    return hInstance;
    }
#endif




/*
 * FInitialize
 *
 * Purpose:
 *  Initialization function for the DLL.
 *
 * Parameters:
 *  hInstance       HANDLE instance of the DLL.
 *
 * Return Value:
 *  BOOL            TRUE if the function was successful, FALSE otherwise.
 */

BOOL FInitialize(HANDLE hInstance)
    {
    UINT        i;

    /*
     * To remain backwards compatible with 1.0 we'll default to 96DPI
     * like we forced in the older version.  If the application calls
     * UIToolButtonDraw we use the values here.  If the application
     * calls UIToolButtonDrawTDD then we use the pointer to the
     * application-provided TOOLDISPLAYDATA structure.
     */
    tdd.uDPI     =96;
    tdd.cyBar    =CYBUTTONBAR96;
    tdd.cxButton =TOOLBUTTON_STD96WIDTH;
    tdd.cyButton =TOOLBUTTON_STD96HEIGHT;
    tdd.cxImage  =TOOLBUTTON_STD96IMAGEWIDTH;
    tdd.cyImage  =TOOLBUTTON_STD96IMAGEHEIGHT;
    tdd.uIDImages=IDB_STANDARDIMAGES96;

    for (i=0; i < 3; i++)
        {
        rghBmpStandardImages[i]=LoadBitmap(hInstance
            , MAKEINTRESOURCE(IDB_STANDARDIMAGESMIN+i));

        if (NULL==rghBmpStandardImages[i])
            return FALSE;
        }

    ghInst=hInstance;

    //Perform global initialization.
    if (ToolButtonInit())
        {
        CursorsCache(hInstance);
        return TRUE;
        }

    return FALSE;
    }




/*
 * WEP
 *
 * Purpose:
 *  Required DLL Exit function.  Does nothing.
 *
 * Parameters:
 *  bSystemExit     BOOL indicating if the system is being shut
 *                  down or the DLL has just been unloaded.
 *
 * Return Value:
 *  void
 *
 */

void FAR PASCAL WEP(int bSystemExit)
    {
    /*
     * **Developers:  Note that WEP is called AFTER Windows does any
     *                automatic task cleanup.  You may see warnings for
     *                that two DCs, a bitmap, and a brush, were not
     *                deleted before task termination.  THIS IS NOT A
     *                PROBLEM WITH THIS CODE AND IT IS NOT A BUG.  This
     *                WEP function is properly called and performs the
     *                cleanup as appropriate.  The fact that Windows is
     *                calling WEP after checking task cleanup is not
     *                something we can control.  Just to prove it, the
     *                OutputDebugStrings in this and ToolButtonFree
     *                show that the code is exercised.
     */

   #ifdef DEBUG
    OutputDebugString("BTTNCUR.DLL:  WEP Entry\r\n");
    OutputDebugString("BTTNCUR.DLL:  The two DC's, the brush, and the three\r\n");
    OutputDebugString("BTTNCUR.DLL:  bitmaps that Debug Windows shows\r\n");
    OutputDebugString("BTTNCUR.DLL:  above were detected BEFORE this WEP\r\n");
    OutputDebugString("BTTNCUR.DLL:  had a chance to do it!  NOT A BUG!\r\n");
   #endif

    CursorsFree();
    ToolButtonFree();

   #ifdef DEBUG
    OutputDebugString("BTTNCUR.DLL:  WEP Exit\r\n");
   #endif
    return;
    }





/*
 * UIToolConfigureForDisplay
 * Public API
 *
 * Purpose:
 *  Initializes the library to scale button images for the display type.
 *  Without calling this function the library defaults to 96 DPI (VGA).
 *  By calling this function an application acknowledges that it must
 *  use the data returned from this function to configure itself for
 *  the display.
 *
 * Parameters:
 *  lpDD            LPTOOLDISPLAYDATA to fill with the display-sensitive
 *                  size values.
 *
 * Return Value:
 *  BOOL            TRUE if the sizes were obtained, FALSE otherwise.
 */

BOOL WINAPI UIToolConfigureForDisplay(LPTOOLDISPLAYDATA lpDD)
    {
    int         cy;
    HDC         hDC;


    if (NULL==lpDD || IsBadWritePtr(lpDD, sizeof(TOOLDISPLAYDATA)))
        return FALSE;

    /*
     * Determine the aspect ratio of the display we're currently
     * running on and calculate the necessary information.
     *
     * By retrieving the logical Y extent of the display driver, you
     * only have limited possibilities:
     *      LOGPIXELSY      Display
     *      ----------------------------------------
     *         48             CGA    (unsupported)
     *         72             EGA
     *         96             VGA
     *        120             8514/a (i.e. HiRes VGA)
     */

    hDC=GetDC(NULL);

    if (NULL==hDC)
        return FALSE;

    cy=GetDeviceCaps(hDC, LOGPIXELSY);
    ReleaseDC(NULL, hDC);

    /*
     * Instead of single comparisons, check ranges instead, so in case
     * we get something funky, we'll act reasonable.
     */
    if (72 >=cy)
        {
        lpDD->uDPI     =72;
        lpDD->cyBar    =CYBUTTONBAR72;
        lpDD->cxButton =TOOLBUTTON_STD72WIDTH;
        lpDD->cyButton =TOOLBUTTON_STD72HEIGHT;
        lpDD->cxImage  =TOOLBUTTON_STD72IMAGEWIDTH;
        lpDD->cyImage  =TOOLBUTTON_STD72IMAGEHEIGHT;
        lpDD->uIDImages=IDB_STANDARDIMAGES72;
        }
    else
        {
        if (72 < cy && 120 > cy)
            {
            lpDD->uDPI     =96;
            lpDD->cyBar    =CYBUTTONBAR96;
            lpDD->cxButton =TOOLBUTTON_STD96WIDTH;
            lpDD->cyButton =TOOLBUTTON_STD96HEIGHT;
            lpDD->cxImage  =TOOLBUTTON_STD96IMAGEWIDTH;
            lpDD->cyImage  =TOOLBUTTON_STD96IMAGEHEIGHT;
            lpDD->uIDImages=IDB_STANDARDIMAGES96;
            }
        else
            {
            lpDD->uDPI     =120;
            lpDD->cyBar    =CYBUTTONBAR120;
            lpDD->cxButton =TOOLBUTTON_STD120WIDTH;
            lpDD->cyButton =TOOLBUTTON_STD120HEIGHT;
            lpDD->cxImage  =TOOLBUTTON_STD120IMAGEWIDTH;
            lpDD->cyImage  =TOOLBUTTON_STD120IMAGEHEIGHT;
            lpDD->uIDImages=IDB_STANDARDIMAGES120;
            }
        }

    return TRUE;
    }








/*
 * ToolButtonInit
 * Internal
 *
 * Purpose:
 *  Initializes GDI objects for drawing images through UIToolButtonDraw.
 *  If the function fails, the function has already performed proper
 *  cleanup.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  BOOL            TRUE if initialization succeeded.  FALSE otherwise.
 */

static BOOL ToolButtonInit(void)
    {
    COLORREF        rgbHi;

    //DC for BitBltting the image (the glyph)
    hDCGlyphs=CreateCompatibleDC(NULL);

    //Create a monochrome DC and a brush for doing pattern dithering.
    hDCMono=CreateCompatibleDC(NULL);

    //Windows 3.0 doesn't support COLOR_BTNHIGHLIGHT, so leave it white.
    if (0x0300 < (UINT)GetVersion())
        rgbHi=GetSysColor(COLOR_BTNHIGHLIGHT);
    else
        rgbHi=crStandard[STDCOLOR_WHITE];

    hBrushDither=HBrushDitherCreate(GetSysColor(COLOR_BTNFACE), rgbHi);

    if (NULL==hDCGlyphs || NULL==hDCMono || NULL==hBrushDither)
        {
        //On failure, cleanup whatever might have been allocated.
        ToolButtonFree();
        return FALSE;
        }

    return TRUE;
    }





/*
 * ToolButtonFree
 * Internal
 *
 * Purpose:
 *  Free all GDI allocations made during initialization.  Note that the
 *  DEBUG output included here shows that WEP is called and cleanup actually
 *  occurs.  However, if you watch debug output in DBWIN or on a terminal,
 *  the debugging version of Windows does automatic app cleanup before WEP
 *  is called, leading some to believe that this code is buggy.  The
 *  debug output below shows that we do perform all necessary cleanup.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

static void ToolButtonFree(void)
    {
    UINT        i;

    if (NULL!=hDCMono)
        DeleteDC(hDCMono);

    hDCMono=NULL;

    if (NULL!=hDCGlyphs)
        DeleteDC(hDCGlyphs);

    hDCGlyphs=NULL;

    if (NULL!=hBrushDither)
        DeleteObject(hBrushDither);

    hBrushDither=NULL;

    for (i=0; i < 3; i++)
        {
        if (NULL!=rghBmpStandardImages[i])
            DeleteObject(rghBmpStandardImages[i]);
        rghBmpStandardImages[i]=NULL;
        }

    return;
    }





/*
 * HBrushDitherCreate
 * Internal
 *
 * Purpose:
 *  Creates and returns a handle to a pattern brush created from
 *  an 8*8 monochrome pattern bitmap.  We use the button face and
 *  highlight colors to indicate the resulting colors of a PatBlt
 *  using this brush.
 *
 * Parameters:
 *  rgbFace         COLORREF of the button face color.
 *  rgbHilight      COLORREF of the button highlight color.
 *
 * Return Value:
 *  HBITMAP         Handle to the dither bitmap.
 */

static HBRUSH HBrushDitherCreate(COLORREF rgbFace, COLORREF rgbHilight)
    {
    struct  //BITMAPINFO with 16 colors
        {
        BITMAPINFOHEADER    bmiHeader;
        RGBQUAD             bmiColors[16];
        } bmi;

    HBRUSH          hBrush=NULL;
    DWORD           patGray[8];
    HDC             hDC;
    HBITMAP         hBmp;
    static COLORREF rgbFaceOld   =0xFFFFFFFF;  //Initially an impossible color
    static COLORREF rgbHilightOld=0xFFFFFFFF;  //so at first we always create

    /*
     * If the colors haven't changed from last time, just return the
     * existing brush.
     */
    if (rgbFace==rgbFaceOld && rgbHilight==rgbHilightOld)
        return hBrushDither;

    rgbFaceOld=rgbFace;
    rgbHilightOld=rgbHilight;

    /*
     * We're going to create an 8*8 brush for PatBlt using the
     * button face color and button highlight color.  We use this
     * brush to affect the pressed state and the disabled state.
     */
    bmi.bmiHeader.biSize         = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth        = 8;
    bmi.bmiHeader.biHeight       = 8;
    bmi.bmiHeader.biPlanes       = 1;
    bmi.bmiHeader.biBitCount     = 1;
    bmi.bmiHeader.biCompression  = BI_RGB;
    bmi.bmiHeader.biSizeImage    = 0;
    bmi.bmiHeader.biXPelsPerMeter= 0;
    bmi.bmiHeader.biYPelsPerMeter= 0;
    bmi.bmiHeader.biClrUsed      = 0;
    bmi.bmiHeader.biClrImportant = 0;

    bmi.bmiColors[0].rgbBlue     = GetBValue(rgbFace);
    bmi.bmiColors[0].rgbGreen    = GetGValue(rgbFace);
    bmi.bmiColors[0].rgbRed      = GetRValue(rgbFace);
    bmi.bmiColors[0].rgbReserved = 0;

    bmi.bmiColors[1].rgbBlue     = GetBValue(rgbHilight);
    bmi.bmiColors[1].rgbGreen    = GetGValue(rgbHilight);
    bmi.bmiColors[1].rgbRed      = GetRValue(rgbHilight);
    bmi.bmiColors[1].rgbReserved = 0;

    //Create the byte array for CreateDIBitmap.
    patGray[6]=patGray[4]=patGray[2]=patGray[0]=0x5555AAAAL;
    patGray[7]=patGray[5]=patGray[3]=patGray[1]=0xAAAA5555L;

    //Create the bitmap
    hDC=GetDC(NULL);
    hBmp=CreateDIBitmap(hDC, &bmi.bmiHeader, CBM_INIT, patGray
                        , (LPBITMAPINFO)&bmi, DIB_RGB_COLORS);
    ReleaseDC(NULL, hDC);

    //Create the brush from the bitmap
    if (NULL!=hBmp)
        {
        hBrush=CreatePatternBrush(hBmp);
        DeleteObject(hBmp);
        }

    /*
     * If we could recreate a brush, clean up and make it the current
     * pattern.  Otherwise the best we can do it return the old one,
     * which will be colored wrong, but at least it works.
     */
    if (NULL!=hBrush)
        {
        if (NULL!=hBrushDither)
            DeleteObject(hBrushDither);

        hBrushDither=hBrush;
        }

    return hBrushDither;
    }





/*
 * UIToolButtonDraw
 * Public API
 *
 * Purpose:
 *  Draws the complete image of a toolbar-style button with a given
 *  image in the center and in a specific state.  The button is drawn
 *  on a specified hDC at a given location, so this function is useful
 *  on standard owner-draw buttons as well as on toolbar controls that
 *  have only one window but show images of multiple buttons.
 *
 * Parameters:
 *  hDC             HDC on which to draw.
 *  x, y            int coordinates at which to draw.
 *  dx, dy          int dimensions of the *button*, not necessarily the image.
 *  hBmp            HBITMAP from which to draw the image.
 *  bmx, bmy        int dimensions of each bitmap in hBmp.  If hBmp is NULL
 *                  then these are forced to the standard sizes.
 *  iImage          int index to the image to draw in the button
 *  uStateIn        UINT containing the state index for the button and the
 *                  color control bits.
 *
 * Return Value:
 *  BOOL            TRUE if drawing succeeded, FALSE otherwise meaning that
 *                  hDC is NULL or hBmp is NULL and iImage is not a valid
 *                  index for a standard image.
 */

BOOL WINAPI UIToolButtonDraw(HDC hDC, int x, int y, int dx, int dy
    , HBITMAP hBmp, int bmx, int bmy, int iImage, UINT uStateIn)
    {
    return UIToolButtonDrawTDD(hDC, x, y, dx, dy, hBmp, bmx, bmy, iImage
        , uStateIn, &tdd);
    }






/*
 * UIToolButtonDrawTDD
 * Public API
 *
 * Purpose:
 *  Draws the complete image of a toolbar-style button with a given
 *  image in the center and in a specific state.  The button is drawn
 *  on a specified hDC at a given location, so this function is useful
 *  on standard owner-draw buttons as well as on toolbar controls that
 *  have only one window but show images of multiple buttons.
 *
 *  This is the same as UIToolButtonDraw but adds the pTDD configuration
 *  structure.  UIToolButtonDraw calls us with that pointing to the
 *  default 96dpi structure.
 *
 * Parameters:
 *  hDC             HDC on which to draw.
 *  x, y            int coordinates at which to draw.
 *  dx, dy          int dimensions of the *button*, not necessarily the image.
 *  hBmp            HBITMAP from which to draw the image.
 *  bmx, bmy        int dimensions of each bitmap in hBmp.  If hBmp is NULL
 *                  then these are forced to the standard sizes.
 *  iImage          int index to the image to draw in the button
 *  uStateIn        UINT containing the state index for the button and the
 *                  color control bits.
 *  pTDD            LPTOOLDISPLAYDATA containing display configuration.
 *                  Can be NULL if hBmp is non-NULL.
 *
 * Return Value:
 *  BOOL            TRUE if drawing succeeded, FALSE otherwise meaning that
 *                  hDC is NULL or hBmp is NULL and iImage is not a valid
 *                  index for a standard image.
 */

BOOL WINAPI UIToolButtonDrawTDD(HDC hDC, int x, int y, int dx, int dy
    , HBITMAP hBmp, int bmx, int bmy, int iImage, UINT uStateIn
    , LPTOOLDISPLAYDATA pTDD)
    {
    static COLORREF crSys[5];  //Avoid stack arrays in DLLs: use static
    UINT            uState=(UINT)LOBYTE((WORD)uStateIn);
    UINT            uColors=(UINT)HIBYTE((WORD)uStateIn & PRESERVE_ALL);
    int             xOffsetGlyph, yOffsetGlyph;
    int             i, iSaveDC;
    HDC             hMemDC;
    HGDIOBJ         hObj;
    HBRUSH          hBR;
    HBITMAP         hBmpT;
    HBITMAP         hBmpMono;
    HBITMAP         hBmpMonoOrg;
    HBITMAP         hBmpSave=NULL;

    if (NULL==hDC)
        return FALSE;

    /*
     * If we're given no image bitmap, then use the standard and validate the
     * image index.  We also enforce the standard bitmap size and the size of
     * the button (as requested by User Interface designers).
     */
    if (NULL==hBmp && !(uState & BUTTONGROUP_BLANK))
        {
        hBmp=rghBmpStandardImages[pTDD->uIDImages-IDB_STANDARDIMAGESMIN];

        bmx=pTDD->cxImage;            //Force bitmap dimensions
        bmy=pTDD->cyImage;

        dx=pTDD->cxButton;            //Force button dimensions
        dy=pTDD->cyButton;

        if (iImage > TOOLIMAGE_MAX)
            return FALSE;

        /*
         * If we are using a standard command button, verify that the state
         * does not contain the LIGHTFACE group which only applies to
         * attribute buttons.
         */
        if (BUTTONTYPE_COMMAND==mpButtonType[iImage]
            && (uState & BUTTONGROUP_LIGHTFACE))
            return FALSE;
        }

    //Create a dithered bitmap.
    hBmpMono=CreateBitmap(dx-2, dy-2, 1, 1, NULL);

    if (NULL==hBmpMono)
        return FALSE;

    hBmpMonoOrg=(HBITMAP)SelectObject(hDCMono,  hBmpMono);


    //Save the DC state before we munge on it.
    iSaveDC=SaveDC(hDC);

    /*
     * Draw a button sans image.  This also fills crSys with the system
     * colors for us which has space for five colors.  We don't use the
     * fifth, the frame color, in this function.
     */
    DrawBlankButton(hDC, x, y, dx, dy, (BOOL)(uState & BUTTONGROUP_DOWN), crSys);

    //Shift coordinates to account for the button's border
    x++;
    y++;
    dx-=2;
    dy-=2;

    /*
     * Determine the offset necessary to center the image but also reflect
     * the pushed-in state, which means just adding 1 to the up state.
     */
    i=(uState & BUTTONGROUP_DOWN) ? 1 : 0;
    xOffsetGlyph=((dx-bmx) >> 1)+i;
    yOffsetGlyph=((dy-bmy) >> 1)+i;


    //Select the given image bitmap into the glyph DC before calling MaskCreate
    if (NULL!=hBmp)
        hBmpSave=(HBITMAP)SelectObject(hDCGlyphs, hBmp);


    /*
     * Draw the face on the button.  If we have an up or [mouse]down
     * button then we can just draw it as-is.  For indeterminate,
     * disabled, or down disabled we have to gray the image and possibly
     * add a white shadow to it (disabled/down disabled).
     *
     * Also note that for the intermediate state we first draw the normal
     * up state, then proceed to add disabling looking highlights.
     */

    //Up, mouse down, down, indeterminate
    if ((uState & BUTTONGROUP_ACTIVE) && !(uState & BUTTONGROUP_BLANK))
        {
        BOOL            fColorsSame=TRUE;

        /*
         * In here we pay close attention to the system colors.  Where
         * the source image is black, we paint COLOR_BTNTEXT.  Where
         * light gray, we paint COLOR_BTNFACE.  Where dark gray we paint
         * COLOR_BTNSHADOW, and where white we paint COLOR_BTNHILIGHT.
         *
         * The uColors variable contains flags to prevent color
         * conversion.  To do a little optimization, we just do a
         * single BitBlt if we're preserving all colors or if no colors
         * are different than the standards, which is by far the most
         * common case.  Otherwise, cycle through the four colors we can
         * convert and do a BitBlt that converts it to the system color.
         */

        //See what colors are different.
        for (i=STDCOLOR_BLACK; i<=STDCOLOR_WHITE; i++)
            fColorsSame &= (crSys[i]==crStandard[i]);

        if (PRESERVE_ALL==uColors || fColorsSame)
            {
            BitBlt(hDC, x+xOffsetGlyph, y+yOffsetGlyph, bmx, bmy
                   , hDCGlyphs, iImage*bmx, 0, SRCCOPY);
            }
        else
            {
            /*
             * Cycle through hard-coded colors and create a mask that has all
             * regions of that color in white and all other regions black.
             * Then we select a pattern brush of the color to convert to:
             * if we aren't converting the color then we use a brush of
             * the standard hard-coded color, otherwise we use the actual
             * system color.  The ROP_DSPDxax means that anything that's
             * 1's in the mask get the pattern, anything that's 0 is unchanged
             * in the destination.
             *
             * To prevent too many Blts to the screen, we use an intermediate
             * bitmap and DC.
             */

            hMemDC=CreateCompatibleDC(hDC);

            //Make sure conversion of monochrome to color stays B&W
            SetTextColor(hMemDC, 0L);                     //0's in mono -> 0
            SetBkColor(hMemDC, (COLORREF)0x00FFFFFF);     //1's in mono -> 1

            hBmpT=CreateCompatibleBitmap(hDC, bmx, bmy);
            SelectObject(hMemDC, hBmpT);

            //Copy the unmodified bitmap to the temporary bitmap
            BitBlt(hMemDC, 0, 0, bmx, bmy, hDCGlyphs, iImage*bmx, 0, SRCCOPY);

            for (i=STDCOLOR_BLACK; i<=STDCOLOR_WHITE; i++)
                {
                //Convert pixels of the color to convert to 1's in the mask
                SetBkColor(hDCGlyphs, crStandard[i]);
                BitBlt(hDCMono, 0, 0, bmx, bmy, hDCGlyphs, iImage*bmx, 0, SRCCOPY);

                //Preserve or modify the color depending on the flag.
                hBR=CreateSolidBrush((uColors & (1 << i))
                                     ? crStandard[i] : crSys[i]);

                if (NULL!=hBR)
                    {
                    hObj=SelectObject(hMemDC, hBR);

                    if (NULL!=hObj)
                        {
                        BitBlt(hMemDC, 0, 0, dx-1, dy-1, hDCMono, 0, 0, ROP_DSPDxax);
                        SelectObject(hMemDC, hObj);
                        }

                    DeleteObject(hBR);
                    }
                }

            //Now put the final version on the display and clean up
            BitBlt(hDC, x+xOffsetGlyph, y+yOffsetGlyph, dx-1, dy-1
                   , hMemDC, 0, 0, SRCCOPY);

            DeleteDC(hMemDC);
            DeleteObject(hBmpT);

            }
        }


    //Disabled and indeterminate states (unless we're blank)
    if ((uState & BUTTONGROUP_DISABLED || ATTRIBUTEBUTTON_INDETERMINATE==uState)
        && !(uState & BUTTONGROUP_BLANK))
        {
        //Grayed state (up or down, no difference)
        MaskCreate(iImage, dx, dy, bmx, bmy, xOffsetGlyph, yOffsetGlyph, 0);

        //Make sure conversion of monochrome to color stays B&W
        SetTextColor(hDC, 0L);                     //0's in mono -> 0
        SetBkColor(hDC, (COLORREF)0x00FFFFFF);     //1's in mono -> 1

        //If we're disabled, up or down, draw the highlighted shadow.
        if (uState & BUTTONGROUP_DISABLED)
            {
            hBR=CreateSolidBrush(crSys[SYSCOLOR_HILIGHT]);

            if (NULL!=hBR)
                {
                hObj=SelectObject(hDC, hBR);

                if (NULL!=hObj)
                    {
                    //Draw hilight color where we have 0's in the mask
                    BitBlt(hDC, x+1, y+1, dx-2, dy-2, hDCMono, 0, 0, ROP_PSDPxax);
                    SelectObject(hDC, hObj);
                    }
                DeleteObject(hBR);
                }
            }

        //Draw the gray image.
        hBR=CreateSolidBrush(crSys[SYSCOLOR_SHADOW]);

        if (NULL!=hBR)
            {
            hObj=SelectObject(hDC, hBR);

            if (NULL!=hObj)
                {
                //Draw the shadow color where we have 0's in the mask
                BitBlt(hDC, x, y, dx-2, dy-2, hDCMono, 0, 0, ROP_PSDPxax);
                SelectObject(hDC, hObj);
                }

            DeleteObject(hBR);
            }
        }

    //If the button is selected do the dither brush avoiding the glyph
    if (uState & BUTTONGROUP_LIGHTFACE)
        {
        HBRUSH      hBRDither;

        /*
         * Get the dither brush.  This function will recreate it if
         * necessary or return the global one if the colors already match.
         */
        hBRDither=HBrushDitherCreate(crSys[SYSCOLOR_FACE], crSys[SYSCOLOR_HILIGHT]);
        hObj=SelectObject(hDC, hBRDither);

        if (NULL!=hObj)
            {
            /*
             * The mask we create now determines where the dithering
             * ends up.  In the down disabled state, we have to preserve
             * the highlighted shadow, so the mask we create must have
             * two masks of the original glyph, one of them offset by
             * one pixel in both x & y.  For the indeterminate state,
             * we have to mask all highlighted areas.  The state passed
             * to MaskCreate matters here (we've used zero before).
             */
            MaskCreate(iImage, dx, dy, bmx, bmy
                       , xOffsetGlyph-1, yOffsetGlyph-1, uState);

            //Convert monochrome masks to B&W color bitmap in the BitBlt.
            SetTextColor(hDC, 0L);
            SetBkColor(hDC, (COLORREF)0x00FFFFFF);

            /*
             * Only draw the dither brush where the mask is 1's.  For
             * the indeterminate state we have to not overdraw the
             * shadow highlight so we use dx-3, dy-3 instead of dx-1
             * and dy-1.  We do this whether or not we're blank.
             */
            i=(ATTRIBUTEBUTTON_INDETERMINATE==uState
               || BLANKBUTTON_INDETERMINATE==uState) ? 3 : 1;

            BitBlt(hDC, x+1, y+1, dx-i, dy-i, hDCMono, 0, 0, ROP_DSPDxax);
            SelectObject(hDC, hObj);
            }

        //DO NOT delete hBRDither!  It's a reference to a shared global.
        }

    //Cleanup hDCGlyphs:  Must do AFTER calling MaskCreate
    if (NULL!=hBmpSave)
        SelectObject(hDCGlyphs, hBmpSave);

    SelectObject(hDCMono,   hBmpMonoOrg);
    DeleteObject(hBmpMono);

    //Restore everything in the DC.
    RestoreDC(hDC, iSaveDC);
    return TRUE;
    }






/*
 * DrawBlankButton
 *
 * Purpose:
 *  Draws a button with no face using the current system colors in either
 *  an up or down state.
 *
 * Parameters:
 *  hDC             HDC on which to draw
 *  x, y            int coordinates where we start drawing
 *  dx,dy           int size of the button
 *  fDown           BOOL indicating the up or down state of the button
 *  pcr             COLORREF FAR * to five colors in which we store text,
 *                  shadow, face, highlight, and frame colors.  This is
 *                  a matter of convenience for the caller, since we have
 *                  to load these colors anyway we might as well send them
 *                  back.
 *
 * Return Value:
 *  None
 */

static void DrawBlankButton(HDC hDC, int x, int y, int dx, int dy
    , BOOL fDown, COLORREF FAR *pcr)
    {
    //Get the current system colors for buttons.
    pcr[0]=GetSysColor(COLOR_BTNTEXT);
    pcr[1]=GetSysColor(COLOR_BTNSHADOW);
    pcr[2]=GetSysColor(COLOR_BTNFACE);

    //Windows 3.0 doesn't support COLOR_BTNHIGHLIGHT, so leave it white.
    if (0x0300 < (UINT)GetVersion())
        pcr[3]=GetSysColor(COLOR_BTNHIGHLIGHT);
    else
        pcr[3]=crStandard[STDCOLOR_WHITE];

    pcr[4]=GetSysColor(COLOR_WINDOWFRAME);

    //Draw the border around the button.
    PatB(hDC, x+1,    y,      dx-2, 1,    pcr[4]);
    PatB(hDC, x+1,    y+dy-1, dx-2, 1,    pcr[4]);
    PatB(hDC, x,      y+1,    1,    dy-2, pcr[4]);
    PatB(hDC, x+dx-1, y+1,    1,    dy-2, pcr[4]);

    //Shift coordinates to account for the border we just drew
    x++;
    y++;
    dx-=2;
    dy-=2;

    //Paint the interior grey as a default.
    PatB(hDC, x, y, dx, dy, pcr[2]);

    /*
     * Draw shadows and highlights.  The DOWN grouping that contains
     * down, mouse down, and down disabled are drawn depressed.  Up,
     * indeterminate, and disabled are drawn up.
     */

    if (fDown)
        {
        PatB(hDC, x, y, 1,  dy, pcr[1]);
        PatB(hDC, x, y, dx, 1,  pcr[1]);
        }
    else
        {
        //Normal button look.
        PatB(hDC, x, y, 1,    dy-1, pcr[3]);
        PatB(hDC, x, y, dx-1, 1,    pcr[3]);

        PatB(hDC, x+dx-1, y,      1,  dy, pcr[1]);
        PatB(hDC, x,      y+dy-1, dx, 1,  pcr[1]);

        PatB(hDC, x+1+dx-3, y+1,    1,    dy-2, pcr[1]);
        PatB(hDC, x+1,      y+dy-2, dx-2, 1,    pcr[1]);
        }

    return;
    }






/*
 * PatB
 * Internal
 *
 * Purpose:
 *  A more convenient PatBlt operation for drawing button borders and
 *  highlights.
 *
 * Parameters:
 *  hDC             HDC on which to paint.
 *  x, y            int coordinates at which to paint.
 *  dx, dy          int dimensions of rectangle to paint.
 *  rgb             COLORREF to use as the background color.
 *
 * Return Value:
 *  None
 */

static void PatB(HDC hDC, int x, int y, int dx, int dy, COLORREF rgb)
    {
    RECT        rc;

    SetBkColor(hDC, rgb);
    SetRect(&rc, x, y, x+dx, y+dy);
    ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    }




/*
 * MaskCreate
 * Internal
 *
 * Purpose:
 *  Creates a monochrome mask bitmap of the given image at the given offset
 *  in the global hDCMono.  Anywhere in the image that you have the light
 *  gray (STDCOLOR_LTGRAY) or the white highlight (STDCOLOR_WHITE) you get
 *  get 1's.  All other pixels are 0's
 *
 * Parameters:
 *  iImage          UINT index of the image for which to create a mask.
 *  dx, dy          int dimensions of the button.
 *  bmx, bmy        int dimensions of the bitmap to use.
 *  xOffset         int offset for x inside hDCMono where we paint.
 *  yOffset         int offset for y inside hDCMono where we paint.
 *  uState          UINT state of the image.  Special cases are made
 *                  for ATTRIBUTEBUTTON_DOWNDISABLED and
 *                  ATTRIBUTEBUTTON_INDETERMINATE.  In any case where you
 *                  do not want a special case, pass zero here, regardless
 *                  of the true button state.
 *
 * Return Value:
 *  None
 */

static void MaskCreate(UINT iImage, int dx, int dy, int bmx, int bmy
    ,int xOffset, int yOffset, UINT uState)
    {
    //Initalize whole area with zeros
    PatBlt(hDCMono, 0, 0, dx, dy, WHITENESS);

    if (uState & BUTTONGROUP_BLANK)
        return;

    //Convert face colored pixels to 1's. all others to black.
    SetBkColor(hDCGlyphs, crStandard[STDCOLOR_LTGRAY]);
    BitBlt(hDCMono, xOffset, yOffset, bmx, bmy, hDCGlyphs, iImage*bmx, 0, SRCCOPY);

    //In the indeterminate state, don't turn highlight's to 1's. Leave black.
    if (ATTRIBUTEBUTTON_INDETERMINATE!=uState)
        {
        //Convert highlight colored pixels to 1's and OR them with the previous.
        SetBkColor(hDCGlyphs, crStandard[STDCOLOR_WHITE]);
        BitBlt(hDCMono, xOffset, yOffset, bmx, bmy, hDCGlyphs, iImage*bmx, 0, SRCPAINT);
        }

    /*
     * For the down disabled state, AND this same mask with itself at an
     * offset of 1, which accounts for the highlight shadow.
     */
    if (ATTRIBUTEBUTTON_DOWNDISABLED==uState)
        BitBlt(hDCMono, 1, 1, dx-1, dy-1, hDCMono,  0, 0, SRCAND);

    return;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\bttncur\bttncuri.h ===
/*
 * BTTNCURI.H
 *
 * Private include file for the Button Images and Cursors DLL.
 *
 * Copyright (c)1992-1993 Microsoft Corporation, All Right Reserved,
 * as applied to redistribution of this source code in source form
 * License is granted to use of compiled code in shipped binaries.
 */

#ifdef __cplusplus
extern "C"
    {
#endif

//Function prototypes.

//BTTNCUR.C
#ifdef WIN32
    extern BOOL WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);
    extern _cexit(void);
#else
    HANDLE FAR PASCAL LibMain(HANDLE, WORD, WORD, LPSTR);
#endif

BOOL               FInitialize(HANDLE);
void FAR PASCAL    WEP(int);
static BOOL        ToolButtonInit(void);
static void        ToolButtonFree(void);
static HBRUSH      HBrushDitherCreate(COLORREF, COLORREF);
static void        DrawBlankButton(HDC, int, int, int, int, BOOL, COLORREF FAR *);
static void        PatB(HDC, int, int, int, int, COLORREF);
static void        MaskCreate(UINT, int, int, int, int, int, int, UINT);


//CURSORS.C
void               CursorsCache(HINSTANCE);
void               CursorsFree(void);



/*
 * Wierd Wild Wooly Waster (raster) Ops for special bltting.  See the
 * Windows SDK reference on Raster Operation Codes for explanation of
 * these.  The DSPDxax and PSDPxax is a reverse-polish notation for
 * operations where D==Destination, S==Source, P==Patterm, a==AND,
 * x==XOR.  Both of these codes are actually described in Programming
 * Windows by Charles Petzold, Second Edition, pages 622-624.
 */
#define ROP_DSPDxax  0x00E20746
#define ROP_PSDPxax  0x00B8074A


/*
 * Color indices into an array of standard hard-coded black, white, and
 * gray colors.
 */

#define STDCOLOR_BLACK      0
#define STDCOLOR_DKGRAY     1
#define STDCOLOR_LTGRAY     2
#define STDCOLOR_WHITE      3

/*
 * Color indices into an array of system colors, matching those in
 * the hard-coded array for the colors they replace.
 */

#define SYSCOLOR_TEXT       0
#define SYSCOLOR_SHADOW     1
#define SYSCOLOR_FACE       2
#define SYSCOLOR_HILIGHT    3


/*
 * Button types, used internally to distinguish command buttons from
 * attribute buttons to enforce three-state or six-state possibilities.
 * Command buttons can only have three states (up, mouse down, disabled)
 * while attribute buttons add (down, down disabled, and indeterminate).
 */

#define BUTTONTYPE_COMMAND      0
#define BUTTONTYPE_ATTRIBUTE    1


#ifdef __cplusplus
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\bttncur\bttncur.h ===
/*
 * BTTNCUR.H
 * Buttons & Cursors Version 1.1, March 1993
 *
 * Public include file for the Button Images and Cursor DLL, including
 * structures, definitions, and function prototypes.
 *
 * Copyright (c)1992-1993 Microsoft Corporation, All Rights Reserved,
 * as applied to redistribution of this source code in source form
 * License is granted to use of compiled code in shipped binaries.
 */


#ifndef _BTTNCUR_H_
#define _BTTNCUR_H_

#ifdef __cplusplus
extern "C"
    {
#endif


//Standard image bitmap

//WARNING:  Obsolete.  Use the return from UIToolDisplayData
#define IDB_STANDARDIMAGES              400

//New values for display types
#define IDB_STANDARDIMAGESMIN           400
#define IDB_STANDARDIMAGES96            400
#define IDB_STANDARDIMAGES72            401
#define IDB_STANDARDIMAGES120           402



//Image indices inside the standard bitmap.
#define TOOLIMAGE_MIN                   0
#define TOOLIMAGE_EDITCUT               0
#define TOOLIMAGE_EDITCOPY              1
#define TOOLIMAGE_EDITPASTE             2
#define TOOLIMAGE_FILENEW               3
#define TOOLIMAGE_FILEOPEN              4
#define TOOLIMAGE_FILESAVE              5
#define TOOLIMAGE_FILEPRINT             6
#define TOOLIMAGE_HELP                  7
#define TOOLIMAGE_HELPCONTEXT           8
#define TOOLIMAGE_MAX                   8


//Additional Standard Cursors as defined in the UI Design Guide.
#define IDC_NEWUICURSORMIN              500
#define IDC_RIGHTARROW                  500
#define IDC_CONTEXTHELP                 501
#define IDC_MAGNIFY                     502
#define IDC_NODROP                      503
#define IDC_TABLETOP                    504
#define IDC_HSIZEBAR                    505
#define IDC_VSIZEBAR                    506
#define IDC_HSPLITBAR                   507
#define IDC_VSPLITBAR                   508
#define IDC_SMALLARROWS                 509
#define IDC_LARGEARROWS                 510
#define IDC_HARROWS                     511
#define IDC_VARROWS                     512
#define IDC_NESWARROWS                  513
#define IDC_NWSEARROWS                  514
#define IDC_NEWUICURSORMAX              514



//Standard sizes for toolbar buttons and bitmaps on display types

//WARNING:  These are obsolete for version 1.0 compatibility/
#define TOOLBUTTON_STDWIDTH             24
#define TOOLBUTTON_STDHEIGHT            22
#define TOOLBUTTON_STDIMAGEWIDTH        16
#define TOOLBUTTON_STDIMAGEHEIGHT       15

/*
 * Applications can call UIToolDisplayData to get the particular
 * values to use for the current display instead of using these values
 * directly.  However, if the application has the aspect ratio already
 * then these are available for them.
 */

//Sizes for 72 DPI (EGA)
#define TOOLBUTTON_STD72WIDTH           24
#define TOOLBUTTON_STD72HEIGHT          16
#define TOOLBUTTON_STD72IMAGEWIDTH      16
#define TOOLBUTTON_STD72IMAGEHEIGHT     11

//Sizes for 96 DPI (VGA)
#define TOOLBUTTON_STD96WIDTH           24
#define TOOLBUTTON_STD96HEIGHT          22
#define TOOLBUTTON_STD96IMAGEWIDTH      16
#define TOOLBUTTON_STD96IMAGEHEIGHT     15

//Sizes for 120 DPI (8514/a)
#define TOOLBUTTON_STD120WIDTH          32
#define TOOLBUTTON_STD120HEIGHT         31
#define TOOLBUTTON_STD120IMAGEWIDTH     24
#define TOOLBUTTON_STD120IMAGEHEIGHT    23


//Sizes of a standard button bar depending on the display
#define CYBUTTONBAR72                   23
#define CYBUTTONBAR96                   29
#define CYBUTTONBAR120                  38



/*
 * The low-word of the state contains the display state where each
 * value is mutually exclusive and contains one or more grouping bits.
 * Each group represents buttons that share some sub-state in common.
 *
 * The high-order byte controls which colors in the source bitmap,
 * black, white, gray, and dark gray, are to be converted into the
 * system colors COLOR_BTNTEXT, COLOR_HILIGHT, COLOR_BTNFACE, and
 * COLOR_BTNSHADOW.  Any or all of these bits may be set to allow
 * the application control over specific colors.
 *
 * The actual state values are split into a command group and an
 * attribute group.  Up, mouse down, and disabled states are identical,
 * but only attributes can have down, down disabled, and indeterminate
 * states.
 *
 * BUTTONGROUP_BLANK is defined so an application can draw only the button
 * without an image in the up, down, mouse down, or indeterminate
 * state, that is, BUTTONGROUP_BLANK is inclusive with BUTTONGROUP_DOWN
 * and BUTTONGROUP_LIGHTFACE.
 */


#define BUTTONGROUP_DOWN                0x0001
#define BUTTONGROUP_ACTIVE              0x0002
#define BUTTONGROUP_DISABLED            0x0004
#define BUTTONGROUP_LIGHTFACE           0x0008
#define BUTTONGROUP_BLANK               0x0010

//Command buttons only
#define COMMANDBUTTON_UP                (BUTTONGROUP_ACTIVE)
#define COMMANDBUTTON_MOUSEDOWN         (BUTTONGROUP_ACTIVE | BUTTONGROUP_DOWN)
#define COMMANDBUTTON_DISABLED          (BUTTONGROUP_DISABLED)

//Attribute buttons only
#define ATTRIBUTEBUTTON_UP              (BUTTONGROUP_ACTIVE)
#define ATTRIBUTEBUTTON_MOUSEDOWN       (BUTTONGROUP_ACTIVE | BUTTONGROUP_DOWN)
#define ATTRIBUTEBUTTON_DISABLED        (BUTTONGROUP_DISABLED)
#define ATTRIBUTEBUTTON_DOWN            (BUTTONGROUP_ACTIVE | BUTTONGROUP_DOWN | BUTTONGROUP_LIGHTFACE)
#define ATTRIBUTEBUTTON_INDETERMINATE   (BUTTONGROUP_ACTIVE | BUTTONGROUP_LIGHTFACE)
#define ATTRIBUTEBUTTON_DOWNDISABLED    (BUTTONGROUP_DISABLED | BUTTONGROUP_DOWN | BUTTONGROUP_LIGHTFACE)

//Blank buttons only
#define BLANKBUTTON_UP                  (BUTTONGROUP_ACTIVE | BUTTONGROUP_BLANK)
#define BLANKBUTTON_DOWN                (BUTTONGROUP_ACTIVE | BUTTONGROUP_BLANK | BUTTONGROUP_DOWN | BUTTONGROUP_LIGHTFACE)
#define BLANKBUTTON_MOUSEDOWN           (BUTTONGROUP_ACTIVE | BUTTONGROUP_BLANK | BUTTONGROUP_DOWN)
#define BLANKBUTTON_INDETERMINATE       (BUTTONGROUP_ACTIVE | BUTTONGROUP_BLANK | BUTTONGROUP_LIGHTFACE)


/*
 * Specific bits to prevent conversions of specific colors to system
 * colors.  If an application uses this newer library and never specified
 * any bits, then they benefit from color conversion automatically.
 */
#define PRESERVE_BLACK                  0x0100
#define PRESERVE_DKGRAY                 0x0200
#define PRESERVE_LTGRAY                 0x0400
#define PRESERVE_WHITE                  0x0800

#define PRESERVE_ALL                    (PRESERVE_BLACK | PRESERVE_DKGRAY | PRESERVE_LTGRAY | PRESERVE_WHITE)
#define PRESERVE_NONE                   0   //Backwards compatible



//Structure for UIToolConfigureForDisplay
typedef struct tagTOOLDISPLAYDATA
    {
    UINT        uDPI;       //Display driver DPI
    UINT        cyBar;      //Vertical size for a bar containing buttons.
    UINT        cxButton;   //Dimensions of a button.
    UINT        cyButton;
    UINT        cxImage;    //Dimensions of bitmap image
    UINT        cyImage;
    UINT        uIDImages;  //Standard resource ID for display-sensitive images
    } TOOLDISPLAYDATA, FAR *LPTOOLDISPLAYDATA;



//Public functions in BTTNCUR.DLL
HCURSOR WINAPI UICursorLoad(UINT);
BOOL    WINAPI UIToolConfigureForDisplay(LPTOOLDISPLAYDATA);
BOOL    WINAPI UIToolButtonDraw(HDC, int, int, int, int, HBITMAP, int, int, int, UINT);
BOOL    WINAPI UIToolButtonDrawTDD(HDC, int, int, int, int, HBITMAP, int, int, int, UINT, LPTOOLDISPLAYDATA);


#ifdef __cplusplus
    }
#endif

#endif //_BTTNCUR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\bttncur\daytona\makefile.inc ===
obj\*\bttncur.def: bttncur.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\bttncur\chicago\makefile.inc ===
obj\*\bttncur.def: bttncur.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\api.c ===
/*
 * API.C
 * GizmoBar Version 1.00, Win32 version August 1993
 *
 * API functions affecting a GizmoBar and a message processing function to
 * handle the equivalent called through messages.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#include <windows.h>
#include "gizmoint.h"



/*
 * GBMessageHandler
 *
 * Purpose:
 *  Processes control messages that are equivalents of available
 *  control API.  The data passed with these messages is simply
 *  extracted from structures and passed as parameters to their
 *  equivalent function.
 *
 * Parameters:
 *  <Standard Message Parameters> plus
 *  pGB             LPGIZMOBAR providing control-specific data.
 *
 * Return Value:
 *  LRESULT         Return value from equivalent API function.
 */

LRESULT GBMessageHandler(HWND hWnd, UINT iMsg, WPARAM wParam
    , LPARAM lParam, LPGIZMOBAR pGB)
    {
    LRESULT         lRet=0L;
    LPCREATEGIZMO   pCG;
    LPGBMSG         pMsg;
    LPGBGETTEXT     pGT;
    LPGBGETINT      pGI;
    LPGBSETINT      pSI;

    if (NULL==pGB)
        return 0L;

    switch (iMsg)
        {
        case GBM_HWNDASSOCIATESET:
            lRet=(LRESULT)(UINT)GBHwndAssociateSet(hWnd, (HWND)wParam);
            break;

        case GBM_HWNDASSOCIATEGET:
            lRet=(LRESULT)(UINT)GBHwndAssociateGet(hWnd);
            break;

        case GBM_GIZMOADD:
            pCG=(LPCREATEGIZMO)lParam;
            lRet=(LRESULT)GBGizmoAdd(pCG->hWndParent, pCG->iType, pCG->iGizmo
                , pCG->uID, pCG->dx, pCG->dy, pCG->pszText, pCG->hBmp
                , pCG->iImage, pCG->uState);
            break;

        case GBM_GIZMOREMOVE:
            lRet=(LRESULT)GBGizmoRemove(hWnd, wParam);
            break;

        case GBM_GIZMOSENDMESSAGE:
            pMsg=(LPGBMSG)lParam;
            lRet=GBGizmoSendMessage(hWnd, wParam, pMsg->iMsg, pMsg->wParam, pMsg->lParam);
            break;

        case GBM_GIZMOSHOW:
            lRet=(LRESULT)GBGizmoShow(hWnd, wParam, (BOOL)LOWORD(lParam));
            break;

        case GBM_GIZMOENABLE:
            lRet=(LRESULT)GBGizmoEnable(hWnd, wParam, (BOOL)LOWORD(lParam));
            break;

        case GBM_GIZMOCHECK:
            lRet=(LRESULT)GBGizmoCheck(hWnd, wParam, (BOOL)LOWORD(lParam));
            break;

        case GBM_GIZMOFOCUSSET:
            lRet=(LRESULT)GBGizmoFocusSet(hWnd, wParam);
            break;

        case GBM_GIZMOEXIST:
            lRet=(LRESULT)GBGizmoExist(hWnd, wParam);
            break;

        case GBM_GIZMOTYPEGET:
            lRet=(LRESULT)GBGizmoTypeGet(hWnd, wParam);
            break;

        case GBM_GIZMODATASET:
            lRet=(LRESULT)GBGizmoDataSet(hWnd, wParam, (DWORD)lParam);
            break;

        case GBM_GIZMODATAGET:
            lRet=(LRESULT)GBGizmoDataGet(hWnd, wParam);
            break;

        case GBM_GIZMONOTIFYSET:
            lRet=(LRESULT)GBGizmoNotifySet(hWnd, wParam, (BOOL)LOWORD(lParam));
            break;

        case GBM_GIZMONOTIFYGET:
            lRet=(LRESULT)GBGizmoNotifyGet(hWnd, wParam);
            break;

        case GBM_GIZMOTEXTGET:
            pGT=(LPGBGETTEXT)lParam;
            lRet=(LRESULT)GBGizmoTextGet(hWnd, wParam, pGT->psz, pGT->cch);
            break;

        case GBM_GIZMOTEXTSET:
            GBGizmoTextSet(hWnd, wParam, (LPTSTR)lParam);
            break;

        case GBM_GIZMOINTGET:
            pGI=(LPGBGETINT)lParam;
            lRet=(LRESULT)GBGizmoIntGet(hWnd, wParam, &pGI->fSuccess, pGI->fSigned);
            break;


        case GBM_GIZMOINTSET:
            pSI=(LPGBSETINT)lParam;
            GBGizmoIntSet(hWnd, wParam, pSI->uValue, pSI->fSigned);
            break;

        default:
            break;
        }

    return lRet;
    }










/*
 * PGizmoFromHwndID
 *
 * Purpose:
 *  Retrieves the pGizmo for the given GizmoBar and the gizmo ID.
 *
 * Parameters:
 *  hWnd            HWND of a GizmoBar.
 *  uID             UINT gizmo identifier.
 *
 * Return Value:
 *  LPGIZMO         NULL if the gizmo does not exist or hWnd is invalid.
 *                  non-NULL LPGIZMO otherwise.
 */

LPGIZMO PGizmoFromHwndID(HWND hWnd, UINT uID)
    {
    LPGIZMOBAR    pGB;

    if (!IsWindow(hWnd))
        return FALSE;

    pGB=(LPGIZMOBAR)GetWindowLong(hWnd, GBWL_STRUCTURE);

    if (NULL==pGB)
        return FALSE;

    return GizmoPFind(&pGB->pGizmos, uID);
    }






/*
 * GBHwndAssociateSet
 *
 * Purpose:
 *  Changes the associate window of a GizmoBar.
 *
 * Parameters:
 *  hWnd            HWND of the control window.
 *
 * Set Parameters:
 *  hWndAssociate   HWND of new associate.
 *
 * Return Value:
 *  HWND            Handle of previous associate.
 */

HWND WINAPI GBHwndAssociateSet(HWND hWnd, HWND hWndNew)
    {
    HWND        hWndOld=NULL;
    LPGIZMOBAR  pGB;

    pGB=(LPGIZMOBAR)GetWindowLong(hWnd, GBWL_STRUCTURE);

    if (NULL!=pGB)
        {
        hWndOld=pGB->hWndAssociate;
        pGB->hWndAssociate=hWndNew;

        if (NULL!=hWndOld)
            SendCommand(hWndOld, pGB->uID, GBN_ASSOCIATELOSS, hWnd);

        if (NULL!=hWndNew)
            SendCommand(hWndNew, pGB->uID, GBN_ASSOCIATEGAIN, hWnd);
        }

    return hWndOld;
    }





/*
 * GBHwndAssociateGet
 *
 * Purpose:
 *  Retrieves the associate window of a GizmoBar
 *
 * Parameters:
 *  hWnd            HWND of the control window.
 *
 * Set Parameters:
 *  hWndAssociate   HWND of new associate.
 *
 * Return Value:
 *  HWND            Handle of current associate.
 */

HWND WINAPI GBHwndAssociateGet(HWND hWnd)
    {
    HWND        hWndOld=NULL;
    LPGIZMOBAR  pGB;

    pGB=(LPGIZMOBAR)GetWindowLong(hWnd, GBWL_STRUCTURE);

    if (NULL!=pGB)
        hWndOld=pGB->hWndAssociate;

    return hWndOld;
    }





/*
 * GBGizmoAdd
 *
 * Purpose:
 *  Creates a new gizmo on the GizmoBar.  Subsequent operations should
 *  be done using the identifier, uID, for this gizmo.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  iType           UINT type of the gizmo to create.
 *  iGizmo          UINT position (zero-based) at which to place the gizmo.
 *  uID             UINT identifier for WM_COMMAND from this gizmo.
 *  dx, dy          UINT dimensions of the gizmo.
 *  pszText         LPTSTR initial text for edit, list, combo, and text gizmos.
 *  hBitmap         HBITMAP for gizmos of the button types (COMMAND or
 *                  ATTRIBUTE) specifies a source bitmap from which the
 *                  button image is taken.
 *  iImage          UINT index into hBitmap for the image for this button.
 *  uState          UINT initial state of the gizmo.
 *
 * Return Value:
 *  BOOL            TRUE if creation succeeded, FALSE otherwise.
 */

BOOL WINAPI GBGizmoAdd(HWND hWnd, UINT iType, UINT iGizmo, UINT uID
    , UINT dx, UINT dy, LPTSTR pszText, HBITMAP hBmp, UINT iImage, UINT uState)
    {
    BOOL        fSuccess;
    LPGIZMOBAR  pGB;
    LPGIZMO     pGizmo;

    if (!IsWindow(hWnd))
        return FALSE;

    pGB=(LPGIZMOBAR)GetWindowLong(hWnd, GBWL_STRUCTURE);

    if (NULL==pGB)
        return FALSE;

    /*
     * This automatically creates the windows, allocates structures, includes
     * the gizmo in pGB->pGizmos, and so forth.
     */
    pGizmo=GizmoPAllocate((LPINT)&fSuccess, &pGB->pGizmos, hWnd, iType
        , iGizmo, uID, dx, dy, pszText, hBmp, iImage, uState);

    if (fSuccess)
        {
        if (NULL!=pGB->hWndAssociate)
            SendCommand(pGB->hWndAssociate,GBN_GIZMOADDED, pGB->uID, hWnd);

        InvalidateRect(hWnd, NULL, TRUE);
        UpdateWindow(hWnd);
        }
    else
        GizmoPFree(&pGB->pGizmos, pGizmo);

    return fSuccess;
    }





/*
 * GBGizmoRemove
 *
 * Purpose:
 *  Removes an existing gizmo from the GizmoBar.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifier for this gizmo.
 *
 * Return Value:
 *  BOOL            TRUE if deletion succeeded, FALSE otherwise.
 */

BOOL WINAPI GBGizmoRemove(HWND hWnd, UINT uID)
    {
    LPGIZMOBAR  pGB;
    LPGIZMO     pGizmo;

    if (!IsWindow(hWnd))
        return FALSE;

    pGB=(LPGIZMOBAR)GetWindowLong(hWnd, GBWL_STRUCTURE);

    if (NULL==pGB)
        return FALSE;

    pGizmo=GizmoPFind(&pGB->pGizmos, uID);

    if (NULL==pGizmo)
        return FALSE;

    GizmoPFree(&pGB->pGizmos, pGizmo);

    if (NULL!=pGB->hWndAssociate)
        SendCommand(pGB->hWndAssociate, GBN_GIZMOREMOVED, pGB->uID, hWnd);

    InvalidateRect(hWnd, NULL, TRUE);
    UpdateWindow(hWnd);
    return TRUE;
    }






/*
 * GBGizmoSendMessage
 *
 * Purpose:
 *  Implements the equivalent of SendMessage to a gizmo in the
 *  GizmoBar.  Separators, command buttons, and attribute buttons
 *  do not accept messages.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifier of the gizmo to affect.
 *  iMsg            UINT message to send.
 *  wParam          WPARAM of the message.
 *  lParam          LPARAM of the message.
 *
 * Return Value:
 *  LRESULT         Return value from the message.  0L if the
 *                  gizmo does not accept messages.
 */

LRESULT WINAPI GBGizmoSendMessage(HWND hWnd, UINT uID, UINT iMsg
    , WPARAM wParam, LPARAM lParam)
    {
    LPGIZMO     pGizmo;
    LONG        lRet=0L;

    pGizmo=PGizmoFromHwndID(hWnd, uID);

    if (NULL!=pGizmo && NULL!=pGizmo->hWnd)
        lRet=SendMessage(pGizmo->hWnd, iMsg, wParam, lParam);

    return lRet;
    }






/*
 * GBGizmoShow
 *
 * Purpose:
 *  Shows or hides a control, adjusting the positions of all others
 *  to make room for or reuse the space for this control.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifier of the gizmo to affect.
 *  fShow           BOOL TRUE to show the gizmo, FALSE to hide it.
 *
 * Return Value:
 *  BOOL            TRUE if the function was successful, FALSE otherwise.
 */

BOOL WINAPI GBGizmoShow(HWND hWnd, UINT uID, BOOL fShow)
    {
    BOOL        fRet=FALSE;
    LPGIZMO     pGizmo;

    pGizmo=PGizmoFromHwndID(hWnd, uID);

    if (NULL!=pGizmo)
        {
        if (fShow && pGizmo->fHidden)
            {
            if (NULL!=pGizmo->hWnd)
                ShowWindow(pGizmo->hWnd, SW_SHOWNORMAL);

            GizmosExpand(pGizmo);
            }

        if (!fShow && !pGizmo->fHidden)
            {
            if (NULL!=pGizmo->hWnd)
                ShowWindow(pGizmo->hWnd, SW_HIDE);

            GizmosCompact(pGizmo);
            }

        //This will be right even if we didn't change anything.
        pGizmo->fHidden=!fShow;
        }

    InvalidateRect(hWnd, NULL, TRUE);
    UpdateWindow(hWnd);
    return fRet;
    }






/*
 * GBGizmoEnable
 *
 * Purpose:
 *  Enables or disables a control on the GizmoBar.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifier of the gizmo to affect.
 *  fEnable         BOOL TRUE to enable the gizmo, FALSE otherwise.
 *
 * Return Value:
 *  BOOL            TRUE if the gizmo was previously disabled, FALSE
 *                  otherwise.
 */

BOOL WINAPI GBGizmoEnable(HWND hWnd, UINT uID, BOOL fEnable)
    {
    LPGIZMO     pGizmo;
    BOOL        fRet=FALSE;

    pGizmo=PGizmoFromHwndID(hWnd, uID);

    if (NULL==pGizmo)
        return FALSE;

    fRet=(BOOL)(BUTTONGROUP_DISABLED & pGizmo->uState);

    //Use windows to enable or disable window gizmos
    if (NULL!=pGizmo->hWnd)
        EnableWindow(pGizmo->hWnd, fEnable);
    else
        {
        //If we're not down, command and attribute buttons act the same.
        if (!(BUTTONGROUP_DOWN & pGizmo->uState))
            GizmoPStateSet(hWnd, pGizmo, fEnable ? COMMANDBUTTON_UP : COMMANDBUTTON_DISABLED);
        else
            {
            //Attribute buttons are a little more sensitive with DOWNDISABLED
            GizmoPStateSet(hWnd, pGizmo
                , fEnable ? ATTRIBUTEBUTTON_DOWN : ATTRIBUTEBUTTON_DOWNDISABLED);
            }
        }

    return fRet;
    }







/*
 * GBGizmoCheck
 *
 * Purpose:
 *  Checks or unchecks an attribute button in the GizmoBar.  If the
 *  gizmo is part of a group of mutually exclusive attributes, then
 *  other gizmos are unchecked when this one is checked.  If this is
 *  the only one checked in these circumstances, this function is a NOP.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifier of the gizmo to affect.
 *  fCheck          BOOL TRUE to check this gizmo, FALSE to uncheck.
 *
 * Return Value:
 *  BOOL            TRUE if the change took place.  FALSE otherwise.
 */

BOOL WINAPI GBGizmoCheck(HWND hWnd, UINT uID, BOOL fCheck)
    {
    LPGIZMOBAR  pGB;
    LPGIZMO     pGizmo;

    if (!IsWindow(hWnd))
        return FALSE;

    pGB=(LPGIZMOBAR)GetWindowLong(hWnd, GBWL_STRUCTURE);

    if (NULL==pGB)
        return FALSE;

    pGizmo=GizmoPFind(&pGB->pGizmos, uID);

    if (NULL!=pGizmo)
        GizmoPCheck(hWnd, pGizmo, fCheck);

    return TRUE;
    }






/*
 * GBGizmoFocusSet
 *
 * Purpose:
 *  Sets the focus to a partuclar gizmo in the gizmo if that gizmo
 *  can accept the focus.  Separators, attribute buttons, text,
 *  and command buttons cannot have the focus.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifier of the gizmo to affect.
 *
 * Return Value:
 *  BOOL            TRUE if the focus was set.  FALSE otherwise, such as
 *                  when uID identifies a control that cannot have focus.
 */

UINT WINAPI GBGizmoFocusSet(HWND hWnd, UINT uID)
    {
    LPGIZMO     pGizmo;
    BOOL        fRet=FALSE;

    pGizmo=PGizmoFromHwndID(hWnd, uID);

    if (NULL!=pGizmo && NULL!=pGizmo->hWnd)
        {
        fRet=TRUE;
        SetFocus(pGizmo->hWnd);
        }

    return fRet;
    }





/*
 * GBGizmoExist
 *
 * Purpose:
 *  Determines if a gizmo of a given identifier exists in the GizmoBar.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifier to verify.
 *
 * Return Value:
 *  BOOL            TRUE if the gizmo exists, FALSE otherwise.
 */

BOOL WINAPI GBGizmoExist(HWND hWnd, UINT uID)
    {
    return (NULL!=PGizmoFromHwndID(hWnd, uID));
    }





/*
 * GBGizmoTypeGet
 *
 * Purpose:
 *  Returns the type of the gizmo specified by the given identifer.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifier to find.
 *
 * Return Value:
 *  int             A GIZMOTYPE_* value if the function is successful,
 *                  otherwise -1.
 */

int WINAPI GBGizmoTypeGet(HWND hWnd, UINT uID)
    {
    int         iRet=-1;
    LPGIZMO     pGizmo;

    pGizmo=PGizmoFromHwndID(hWnd, uID);

    if (NULL!=pGizmo)
        iRet=pGizmo->iType;

    return iRet;
    }





/*
 * GBGizmoDataSet
 * GBGizmoDataGet
 *
 * Purpose:
 *  Sets or retrieves an extra DWORD value associated with the given gizmo.
 *  Applications can store any information here they please.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifier of the gizmo.
 *  dwData          (Set only) DWORD data to store with the gizmo.
 *
 * Return Value:
 *  DWORD           Set:  Previous value
 *                  Get:  Current value
 */

DWORD WINAPI GBGizmoDataSet(HWND hWnd, UINT uID, DWORD dwData)
    {
    LPGIZMO     pGizmo;
    DWORD       dw=0L;

    pGizmo=PGizmoFromHwndID(hWnd, uID);

    if (NULL!=pGizmo)
        {
        dw=pGizmo->dwData;
        pGizmo->dwData=dwData;
        }

    return dw;
    }



DWORD WINAPI GBGizmoDataGet(HWND hWnd, UINT uID)
    {
    LPGIZMO     pGizmo;
    DWORD       dw=0L;

    pGizmo=PGizmoFromHwndID(hWnd, uID);

    if (NULL!=pGizmo)
        dw=pGizmo->dwData;

    return dw;
    }






/*
 * GBGizmoNotifySet
 * GBGizmoNotifyGet
 *
 * Purpose:
 *  Sets or retrieves the notify status of a gizmo.  If notify is FALSE,
 *  the no WM_COMMAND messages are sent from the GizmoBar to the parent
 *  window when this gizmo is used.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifier of the gizmo.
 *  fNotify         (Set only) BOOL new notify status to set.
 *
 * Return Value:
 *  BOOL            Set:  Previous value of the notify flag.
 *                  Get:  Current value of the notify flag.
 */

BOOL WINAPI GBGizmoNotifySet(HWND hWnd, UINT uID, BOOL fNotify)
    {
    LPGIZMO     pGizmo;
    BOOL        fRet=FALSE;

    pGizmo=PGizmoFromHwndID(hWnd, uID);

    if (NULL!=pGizmo)
        {
        fRet=pGizmo->fNotify;
        pGizmo->fNotify=fNotify;
        }

    return fRet;
    }


BOOL WINAPI GBGizmoNotifyGet(HWND hWnd, UINT uID)
    {
    LPGIZMO     pGizmo;
    BOOL        fRet=FALSE;

    pGizmo=PGizmoFromHwndID(hWnd, uID);

    if (NULL!=pGizmo)
        fRet=pGizmo->fNotify;

    return fRet;
    }







/*
 * GBGizmoTextSet
 * GBGizmoTextGet
 *
 * Purpose:
 *  Retrieves or sets text in a GizmoBar gizmo.  Separators, command buttons,
 *  and attribute buttons are not affected by this call.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifying the gizmo.
 *  psz             LPTSTR (Set) providing the text to show in the window
 *                  or (Get) pointing to a buffer to receive the text.
 *  cch             (Get only) UINT maximum number of chars to copy to psz.
 *
 * Return Value:
 *  int             Number of characters copied to psz.
 */

void WINAPI GBGizmoTextSet(HWND hWnd, UINT uID, LPTSTR psz)
    {
    //This fails on non-windowed gizmos anyway, so we don't check.
    SetDlgItemText(hWnd, uID, psz);
    return;
    }


int WINAPI GBGizmoTextGet(HWND hWnd, UINT uID, LPTSTR psz, UINT cch)
    {
    //This fails on non-windowed gizmos anyway, so we don't check.
    return GetDlgItemText(hWnd, uID, psz, cch);
    }








/*
 * GBGizmoIntSet
 * GBGizmoIntGet
 *
 * Purpose:
 *  Retrieves or sets an integer in a GizmoBar gizmo.  Separators, command
 *  buttons, and attribute buttons are not affected by this call.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  uID             UINT identifying the gizmo.
 *
 *  (Set only)
 *  u               UINT value to set in the gizmo.
 *  fSigned         BOOL TRUE to indicate if the value is signed.
 *
 *  (Get only)
 *  pfTrans         BOOL FAR * in which the success of the function is returned.
 *  fSigned         BOOL TRUE to indicate if the value is signed.
 *
 * Return Value:
 *  (Set): None
 *  (Get): UINT     Integer translation of the gizmo's text.
 */

void WINAPI GBGizmoIntSet(HWND hWnd, UINT uID, UINT u, BOOL fSigned)
    {
    //This fails on non-windowed gizmos anyway, so we don't check.
    SetDlgItemInt(hWnd, uID, u, fSigned);
    return;
    }



UINT WINAPI GBGizmoIntGet(HWND hWnd, UINT uID, BOOL FAR *pfTrans, BOOL fSigned)
    {
    //This fails on non-windowed gizmos anyway, so we don't check.
    return GetDlgItemInt(hWnd, uID, pfTrans, fSigned);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\bttncur\cursors.c ===
/*
 * CURSORS.C
 * Buttons & Cursors Version 1.1, Win32 version August 1993
 *
 * Public functions to retrieve new cursors from the BTTNCUR DLL based
 * on ordinal to prevent applications from necessarily calling LoadCursor
 * directly on the DLL.
 *
 * Copyright (c)1992-1993 Microsoft Corporation, All Rights Reserved,
 * as applied to redistribution of this source code in source form
 * License is granted to use of compiled code in shipped binaries.
 */

#ifdef WIN32
#define _INC_OLE
#define __RPC_H__
#endif

#include <windows.h>
#include "bttncur.h"
#include "bttncuri.h"


/*
 * The +1 is because MAX is the highest allowable number and MIN is not
 * necessarily zero.
 */
HCURSOR rgHCursors[IDC_NEWUICURSORMAX-IDC_NEWUICURSORMIN+1];



/*
 * CursorsCache
 * Internal
 *
 * Purpose:
 *  Loads all the cursors available through NewUICursorLoad into
 *  a global array.  This way we can clean up all the cursors without
 *  placing the burden on the application.
 *
 * Parameters:
 *  hInst           HANDLE of the DLL instance.
 *
 * Return Value:
 *  None.  If any of the LoadCursor calls fail, then the corresponding
 *  array entry is NULL and NewUICursorLoad will fail.  Better to fail
 *  an app getting a cursor than failing to load the app just for that
 *  reason; and app can attempt to load the cursor on startup if it's
 *  that important, and fail itself.
 */

void CursorsCache(HINSTANCE hInst)
    {
    UINT            i;

    for (i=IDC_NEWUICURSORMIN; i<=IDC_NEWUICURSORMAX; i++)
        rgHCursors[i-IDC_NEWUICURSORMIN]=LoadCursor(hInst, MAKEINTRESOURCE(i));

    return;
    }




/*
 * CursorsFree
 * Internal
 *
 * Purpose:
 *  Frees all the cursors previously loaded through CursorsCache.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void CursorsFree(void)
    {
    /*
     * Note that since cursors are discardable resources and should
     * not be used with DestroyCursor, there's nothing to do here.
     * We still provide this API for compatibility and to maintain
     * symmetry.
     */
    return;
    }





/*
 * UICursorLoad
 * Public API
 *
 * Purpose:
 *  Loads and returns a handle to one of the new standard UI cursors
 *  contained in UITOOLS.DLL.  The application must not call DestroyCursor
 *  on this cursor as it is managed by the DLL.
 *
 * Parameters:
 *  iCursor         UINT index to the cursor to load which must be one
 *                  of the following values:
 *
 *                      IDC_RIGHTARROW    Right pointing standard arrow
 *                      IDC_CONTEXTHELP   Arrow with a ? (context help)
 *                      IDC_MAGNIFY       Magnifying glass for zooming
 *                      IDC_NODROP        Circle with a slash
 *                      IDC_TABLETOP      Small arrow pointing down
 *
 *                      IDC_SMALLARROWS   Thin four-headed arrow
 *                      IDC_LARGEARROWS   Wide four-headed arrow
 *                      IDC_HARROWS       Horizontal two-headed arrow
 *                      IDC_VARROWS       Vertical two-headed arrow
 *                      IDC_NESWARROWS    Two-headed arrow pointing NE<->SW
 *                      IDC_NWSEHARROWS   Two-headed arrow pointing NW<->SE
 *
 *                      IDC_HSIZEBAR      Horizontal two-headed arrow with
 *                                        a single vertical bar down the
 *                                        middle
 *
 *                      IDC_VSIZEBAR      Vertical two-headed arrow with a
 *                                        single horizontal bar down the
 *                                        middle
 *
 *                      IDC_HSPLITBAR     Horizontal two-headed arrow with
 *                                        split double vertical bars down the
 *                                        middle
 *
 *                      IDC_VSPLITBAR     Vertical two-headed arrow with split
 *                                        double horizontal bars down the
 *                                        middle
 *
 * Return Value:
 *  HCURSOR         Handle to the loaded cursor if successful, NULL
 *                  if iCursor is out of range or the function could not
 *                  load the cursor.
 */

HCURSOR WINAPI UICursorLoad(UINT iCursor)
    {
    HCURSOR     hCur=NULL;

    if ((iCursor >= IDC_NEWUICURSORMIN) && (iCursor <= IDC_NEWUICURSORMAX))
        hCur=rgHCursors[iCursor-IDC_NEWUICURSORMIN];

    return hCur;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\bttncur\dllentry.c ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       dllentry.c
//
//  Contents:   Dll Entry point code.  Calls the appropriate run-time
//              init/term code and then defers to LibMain for further
//              processing.
//
//  Classes:    <none>
//
//  Functions:  DllEntryPoint - Called by loader
//
//  History:    10-May-92  BryanT    Created
//              22-Jul-92  BryanT    Switch to calling _cexit/_mtdeletelocks
//                                    on cleanup.
//              06-Oct-92  BryanT    Call RegisterWithCommnot on entry
//                                    and DeRegisterWithCommnot on exit.
//                                    This should fix the heap dump code.
//              27-Dec-93  AlexT     Post 543 builds don't need special code.
//
//--------------------------------------------------------------------

#define USE_CRTDLL
#include <windows.h>

BOOL WINAPI _CRT_INIT (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

BOOL DllEntryPoint (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

BOOL __cdecl LibMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

BOOL DllEntryPoint (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRc = FALSE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            _CRT_INIT(hDll, dwReason, lpReserved);

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            fRc = LibMain (hDll, dwReason, lpReserved);
            break;

        case DLL_PROCESS_DETACH:
            fRc = LibMain (hDll, dwReason, lpReserved);
            _CRT_INIT(hDll, dwReason, lpReserved);
    }

    return(fRc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\book1632.h ===
/*
 * WIN1632.H
 *
 * Macros and other definitions that assist in porting between Win16
 * and Win32 applications.  Define WIN32 to enable 32-bit versions.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  INTERNET>kraigb@microsoft.com
 */


#ifndef _BOOK1632_H_
#define _BOOK1632_H_

//Macros to handle control message packing between Win16 and Win32
#ifdef WIN32

#define MAKEPOINT MAKEPOINTS

#ifndef COMMANDPARAMS
#define COMMANDPARAMS(wID, wCode, hWndMsg)                          \
    WORD        wID     = LOWORD(wParam);                           \
    WORD        wCode   = HIWORD(wParam);                           \
    HWND        hWndMsg = (HWND)(UINT)lParam;
#endif  //COMMANDPARAMS

#ifndef SendCommand
#define SendCommand(hWnd, wID, wCode, hControl)                     \
            SendMessage(hWnd, WM_COMMAND, MAKELONG(wID, wCode)      \
                        , (LPARAM)hControl)
#endif  //SendCommand

#ifndef MENUSELECTPARAMS
#define MENUSELECTPARAMS(wID, wFlags, hMenu)                        \
    WORD        wID     = LOWORD(wParam);                           \
    WORD        wFlags  = HIWORD(wParam);                           \
    HMENU       hMenu   = (HMENU)lParam;
#endif  //MENUSELECTPARAMS


#ifndef SendMenuSelect
#define SendMenuSelect(hWnd, wID, wFlags, hMenu)                    \
            SendMessage(hWnd, WM_MENUSELECT, MAKELONG(wID, wFlags)  \
                        , (LPARAM)hMenu)
#endif  //SendMenuSelect

#ifndef SendScrollPosition
#define SendScrollPosition(hWnd, iMsg, iPos)                        \
            SendMessage(hWnd, iMsg, MAKELONG(SB_THUMBPOSITION, iPos), 0)
#endif //SendScrollPosition

#ifndef ScrollThumbPosition
#define ScrollThumbPosition(w, l) HIWORD(w)
#endif //ScrollThumbPosition

#ifndef GETWINDOWINSTANCE
#define GETWINDOWINSTANCE(h) (HINSTANCE)GetWindowLong(h, GWL_HINSTANCE)
#endif  //GETWINDOWINSTANCE

#ifndef GETWINDOWID
#define GETWINDOWID(h) (UINT)GetWindowLong(h, GWW_ID)
#endif  //GETWINDOWID

#ifndef POINTFROMLPARAM
#define POINTFROMLPARAM(p, l) {p.x=(LONG)(SHORT)LOWORD(l); \
                               p.y=(LONG)(SHORT)HIWORD(l);}
#endif  //POINTEFROMLPARAM

#ifndef EXPORT
#define EXPORT
#endif //EXPORT

#ifndef MDIREFRESHMENU
#define MDIREFRESHMENU(h) SendMessage(h, WM_MDIREFRESHMENU, 0, 0L)
#endif  //MDIREFRESHMENU


//****END WIN32



#else



//****START !WIN32

#ifndef COMMANDPARAMS
#define COMMANDPARAMS(wID, wCode, hWndMsg)                          \
    WORD        wID     = LOWORD(wParam);                           \
    WORD        wCode   = HIWORD(lParam);                           \
    HWND        hWndMsg = (HWND)(UINT)lParam;
#endif  //COMMANDPARAMS

#ifndef SendCommand
#define SendCommand(hWnd, wID, wCode, hControl)                     \
            SendMessage(hWnd, WM_COMMAND, wID                       \
                        , MAKELONG(hControl, wCode))
#endif  //SendCommand

#ifndef MENUSELECTPARAMS
#define MENUSELECTPARAMS(wID, wFlags, hMenu)                        \
    WORD        wID     = LOWORD(wParam);                           \
    WORD        wFlags  = LOWORD(lParam);                           \
    HMENU       hMenu   = (HMENU)HIWORD(lParam);
#endif  //MENUSELECTPARAMS

#ifndef SendMenuSelect
#define SendMenuSelect(hWnd, wID, wFlags, hMenu)                    \
            SendMessage(hWnd, WM_MENUSELECT, wID                    \
                        , MAKELONG(wFlags, hMenu))
#endif  //SendMenuSelect

#ifndef SendScrollPosition
#define SendScrollPosition(hWnd, iMsg, iPos)                        \
            SendMessage(hWnd, iMsg, SB_THUMBPOSITION, MAKELONG(iPos, 0))
#endif //Send ScrollPosition

#ifndef ScrollThumbPosition
#define ScrollThumbPosition(w, l) LOWORD(l)
#endif //ScrollThumbPosition

#ifndef GETWINDOWINSTANCE
#define GETWINDOWINSTANCE(h) (HINSTANCE)GetWindowWord(h, GWW_HINSTANCE)
#endif  //GETWINDOWINSTANCE

#ifndef GETWINDOWID
#define GETWINDOWID(h) (UINT)GetWindowWord(h, GWW_ID)
#endif  //GETWINDOWID

#ifndef POINTFROMLPARAM
#define POINTFROMLPARAM(p, l) {p.x=LOWORD(l); p.y=HIWORD(l);}
#endif  //POINTEFROMLPARAM

#ifndef EXPORT
#define EXPORT  __export
#endif //EXPORT


#ifndef MDIREFRESHMENU
#define MDIREFRESHMENU(h) SendMessage(h, WM_MDISETMENU, TRUE, 0L)
#endif  //MDIREFRESHMENU




#endif  //!WIN32

#endif  //_BOOK1632_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\dllentry.c ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 1992.
//
//  File:       dllentry.c
//
//  Contents:   Dll Entry point code.  Calls the appropriate run-time
//              init/term code and then defers to LibMain for further
//              processing.
//
//  Classes:    <none>
//
//  Functions:  DllEntryPoint - Called by loader
//
//  History:    10-May-92  BryanT    Created
//              22-Jul-92  BryanT    Switch to calling _cexit/_mtdeletelocks
//                                    on cleanup.
//              06-Oct-92  BryanT    Call RegisterWithCommnot on entry
//                                    and DeRegisterWithCommnot on exit.
//                                    This should fix the heap dump code.
//              27-Dec-93  AlexT     Post 543 builds don't need special code.
//
//--------------------------------------------------------------------

#define USE_CRTDLL
#include <windows.h>

BOOL WINAPI _CRT_INIT (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

BOOL DllEntryPoint (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

BOOL __cdecl LibMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);

BOOL DllEntryPoint (HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    BOOL fRc = FALSE;

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            _CRT_INIT(hDll, dwReason, lpReserved);

        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            fRc = LibMain (hDll, dwReason, lpReserved);
            break;

        case DLL_PROCESS_DETACH:
            fRc = LibMain (hDll, dwReason, lpReserved);
            _CRT_INIT(hDll, dwReason, lpReserved);
    }

    return(fRc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\gizmo.c ===
/*
 * GIZMO.C
 * GizmoBar Version 1.00, Win32 version August 1993
 *
 * Allocate, free, find, and enumerate functions for the GIZMO structure
 * and a generic subclass procedure to handle tabbing between gizmos.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#include <windows.h>
#include "gizmoint.h"


/*
 * In order to control tabbing in the gizmos, we need to subclass
 * real pushbuttons, edit controls, listboxes, and comboboxes.  So
 * we keep an array of the four original procs for such controls.
 */
WNDPROC     pfnOrg[CSUBGIZMOS]={NULL, NULL, NULL, NULL};


TCHAR szStatic[]=TEXT("static");
TCHAR szEdit[]=TEXT("edit");
TCHAR szCombobox[]=TEXT("combobox");
TCHAR szListbox[]=TEXT("listbox");
TCHAR szButton[]=TEXT("button");


//Here so PAINT.C can get at it.
TOOLDISPLAYDATA tdd;



/*
 * GizmoPAllocate
 *
 * Purpose:
 *  Allocates and initializes a GIZMO data structure.
 *
 * Parameters:
 *  pfSuccess       LPINT flag indicating success of failure.
 *  ppFirst         LPLPGIZMO providing the first gizmo in this list.
 *  hWndParent      HWND of the parent of this gizmo.  Can be NULL for
 *                  iType==GIZMOTYPE_BUTTON* or GIZMOTYPE_SEPARATOR.
 *  iType           UINT gizmo control type.
 *  iGizmo          UINT index of this gizmo in the GizmoBar.
 *  uID             UINT identifier to send with WM_COMMAND for this control.
 *  dx, dy          UINT width and height of the gizmo.
 *  pszText         LPTSTR to the text for edits, listboxes, combobox, and text.
 *  dwStyle         DWORD style for edits, lists, and combos, and texts.
 *  hBmp            HBITMAP for button gizmos, is applicable.
 *  iImage          UINT index into hBmp for the button image, if applicable.
 *  uState          UINT initial state of the control.
 *
 * Return Value:
 *  LPGIZMO         If NULL returned then GizmoPAllocate could not allocate
 *                  memory.  If a non-NULL pointer is returned with
 *                  *pfSuccess, then call GizmoPFree immediately.  If you
 *                  get a non-NULL pointer and *pfSuccess==TRUE then the
 *                  function succeeded.
 */

LPGIZMO GizmoPAllocate(LPINT pfSuccess, LPLPGIZMO ppFirst, HWND hWndParent
    , UINT iType, UINT iGizmo, UINT uID, UINT dx, UINT dy, LPTSTR pszText
    , HBITMAP hBmp, UINT iImage, UINT uState)
    {
    LPGIZMO         pGizmo;
    LPGIZMO         pCur, pPrev;
    LPTSTR          pszClass;
    HINSTANCE       hInst;
    UINT            i;
    DWORD           dwStyle;
    HWND            hWndE;

    if (NULL==pfSuccess)
        return NULL;

    //Make sure we know of this gizmo type.
    if (GIZMOTYPE_MIN > iType || GIZMOTYPE_MAX < iType)
        return NULL;

    *pfSuccess=FALSE;

    //Allocate the structure
    pGizmo=(LPGIZMO)LocalAlloc(LPTR, CBGIZMO);

    if (NULL==pGizmo)
        return NULL;


    //Store the necessary information for this gizmo.
    pGizmo->iType   =iType;
    pGizmo->uID     =uID;
    pGizmo->hBmp    =hBmp;
    pGizmo->iBmp    =iImage;
    pGizmo->uState  =uState;
    pGizmo->fNotify =TRUE;


    /*
     * Insert this structure into our gizmo list.  Each time we scan
     * we increment the index counter (starting at zero) comparing it
     * to the desired index of insertion.  We then know exactly where
     * to insert this new gizmo.  Note that we insert the new gizmo in
     * the list appropriately for the given owner, so enumerations will
     * come out ordered in the same way for that owner.
     */

    i=0;
    pCur=*ppFirst;
    pPrev=NULL;

    while (NULL!=pCur && i++ < iGizmo)
        {
        pPrev=pCur;
        pCur =pCur->pNext;
        }

    //Point to our neighbors
    pGizmo->pPrev=pPrev;
    pGizmo->pNext=pCur;


    //Point out neighbors to us.
    if (NULL==pPrev)
        *ppFirst=pGizmo;
    else
        pPrev->pNext=pGizmo;

    if (NULL!=pCur)
        pCur->pPrev=pGizmo;


    //Our x-coordinate is the x of the previous gizmo plus its width.
    if (NULL!=pPrev)
        pGizmo->x=pGizmo->pPrev->x+pGizmo->pPrev->dx;
    else
        pGizmo->x=4;    //First gizmo is at x=4


    //If we're a separator or image button, force standards on dx.
    UIToolConfigureForDisplay(&tdd);
    pGizmo->cxImage=tdd.cxImage;
    pGizmo->cyImage=tdd.cyImage;

    if ((GIZMOTYPE_DRAWN & iType) && NULL==hBmp)
        dx=tdd.cxButton;

    if (GIZMOTYPE_SEPARATOR==iType)
        dx=6;

    /*
     * Now create windows for edits, texts, lists, and comboboxes.
     * First calculate the most often defaults used in the switch.
     */
    pGizmo->dx=dx+6;
    pGizmo->dy=min(dy, tdd.cyButton);
    pGizmo->y=2;
    pszClass=NULL;

    //If this is new gizmo is a window, create it.
    switch (iType)
            {
            case GIZMOTYPE_TEXT:
                pGizmo->dx=dx;
                pGizmo->y=(tdd.cyBar-1-pGizmo->dy) >> 1;  //Center vertically.
                pszClass=szStatic;
                dwStyle=SS_LEFT;
                break;

            case GIZMOTYPE_EDIT:
                pGizmo->y=(tdd.cyBar-1-pGizmo->dy) >> 1;  //Center vertically.
                pszClass=szEdit;
                dwStyle=ES_LEFT | WS_BORDER | WS_TABSTOP;
                break;

            case GIZMOTYPE_LISTBOX:
                pGizmo->dy=dy;
                pszClass=szCombobox;
                dwStyle=CBS_DROPDOWNLIST | WS_TABSTOP;
                break;

            case GIZMOTYPE_COMBOBOX:
                pGizmo->dy=dy;
                pszClass=szCombobox;
                dwStyle=CBS_DROPDOWN | WS_TABSTOP;
                break;

            case GIZMOTYPE_BUTTONNORMAL:
                pGizmo->dy=dy;
                pszClass=szButton;
                dwStyle=BS_PUSHBUTTON | WS_TABSTOP;
                break;

            case GIZMOTYPE_SEPARATOR:
                pGizmo->dx=dx;
                pGizmo->y=3;
                break;

            case GIZMOTYPE_BUTTONATTRIBUTEIN:
            case GIZMOTYPE_BUTTONATTRIBUTEEX:
            case GIZMOTYPE_BUTTONCOMMAND:
                pGizmo->dx=dx;
                pGizmo->y=3;
                break;
            }


    //If we matched a classname, create a window.
    if (GIZMOTYPE_WINDOWS & iType)
        {
        if (!IsWindow(hWndParent))
            return pGizmo;

	hInst=(HINSTANCE) GetWindowLongPtr(hWndParent, GWLP_HINSTANCE);

        pGizmo->hWnd=CreateWindow(pszClass, pszText
            , dwStyle | WS_CHILD | WS_VISIBLE, pGizmo->x, pGizmo->y
            , dx, pGizmo->dy, hWndParent, (HMENU)uID, hInst, NULL);

        if (NULL==pGizmo->hWnd)
            return pGizmo;

        /*
         * Subclass comboboxes, listboxes, edits, and windowed buttons.
         * We use iType to index the original proc array so we can use
         * a single subclass procedure for all controls.  If you mess
         * with the gizmo type definitions, this is going to break.
         */

        if (GIZMOTYPE_WINDOWS & iType && GIZMOTYPE_TEXT!=iType)
            {
            //Give the window its type.
            BITPOSITION(iType, i);
            SetProp(pGizmo->hWnd, SZTYPEPROP, (HANDLE)i);

            if (NULL==pfnOrg[i])
                pfnOrg[i]=(WNDPROC)GetWindowLongPtr(pGizmo->hWnd, GWLP_WNDPROC);

            SetWindowLongPtr(pGizmo->hWnd, GWLP_WNDPROC, (LONG_PTR)GenericSubProc);

            //If we're a combobox, get the edit control and subclass it.
            if (GIZMOTYPE_COMBOBOX==iType)
                {
                hWndE=GetDlgItem(pGizmo->hWnd, ID_COMBOEDIT);
                SetProp(hWndE, SZTYPEPROP, (HANDLE)-1);        //Special flag.

                if (NULL==pfnOrg[0])
                    pfnOrg[0]=(WNDPROC)GetWindowLongPtr(pGizmo->hWnd, GWLP_WNDPROC);

                SetWindowLongPtr(hWndE, GWLP_WNDPROC, (LONG_PTR)GenericSubProc);
                }
            }
        }


    //Finally, move all our neighbors to the right over to accomodate us.
    GizmosExpand(pGizmo);

    *pfSuccess=TRUE;
    return pGizmo;
    }






/*
 * GizmoPFree
 *
 * Purpose:
 *  Reverses all initialization done by GizmoPAllocate, cleaning up
 *  any allocations including the application structure itself.
 *
 * Parameters:
 *  ppFirst         LPLPGIZMO providing the first gizmo in this list.
 *  pGizmo          LPGIZMO to the structure
 *
 * Return Value:
 *  LPGIZMO         NULL if successful, pGizmo if not, meaning we couldn't
 *                  free something.
 */

LPGIZMO GizmoPFree(LPLPGIZMO ppFirst, LPGIZMO pGizmo)
    {
    int     i;

    if (NULL==pGizmo)
        return NULL;

    //Move other gizmos to fill in this gap.
    GizmosCompact(pGizmo);

    //Unsubclass
    if (GIZMOTYPE_WINDOWS & pGizmo->iType && GIZMOTYPE_TEXT!=pGizmo->iType)
        {
        i=(int)GetProp(pGizmo->hWnd, SZTYPEPROP);
        RemoveProp(pGizmo->hWnd, SZTYPEPROP);

        SetWindowLongPtr(pGizmo->hWnd, GWLP_WNDPROC, (LONG_PTR)pfnOrg[i]);
        }

    //If this was a window gizmo, destroy the window.
    if (NULL!=pGizmo->hWnd && IsWindow(pGizmo->hWnd))
        DestroyWindow(pGizmo->hWnd);

    //Unlink ourselves.
    if (NULL!=pGizmo->pNext)
        pGizmo->pNext->pPrev=pGizmo->pPrev;

    if (NULL!=pGizmo->pPrev)
        pGizmo->pPrev->pNext=pGizmo->pNext;
    else
        *ppFirst=pGizmo->pNext;

    return (LPGIZMO)LocalFree((HLOCAL)(UINT)(LONG)pGizmo);
    }






/*
 * GizmosExpand
 *
 * Purpose:
 *  Given a starting gizmo and a width, moves it and all gizmos to its
 *  right to the right by the width to make space for showing or creating
 *  a new gizmo.
 *
 * Parameters:
 *  pGizmo          LPGIZMO specifying the gizmo that was inserted.
 *
 * Return Value:
 *  None
 */

void GizmosExpand(LPGIZMO pGizmo)
    {
    int         cx;

    cx=(int)pGizmo->dx;

    /*
     * If we and the next control are buttons, use our width-1 to
     * expand so we overlap borders with our neighboring button.
     */

    if (NULL!=pGizmo->pNext)
        {
        if ((GIZMOTYPE_BUTTONS & pGizmo->pNext->iType)
            && (GIZMOTYPE_BUTTONS & pGizmo->iType))
            cx-=1;
        }

    //Walk the gizmo list moving them right by our width.
    pGizmo=pGizmo->pNext;

    while (NULL!=pGizmo)
        {
        pGizmo->x+=cx;

        //hWnd is NULL for buttons and separators.
        if (NULL!=pGizmo->hWnd)
            SetWindowPos(pGizmo->hWnd, NULL, pGizmo->x, pGizmo->y, 0, 0, SWP_NOZORDER | SWP_NOSIZE);

        pGizmo=pGizmo->pNext;
        }

    return;
    }







/*
 * GizmosCompact
 *
 * Purpose:
 *  Given a gizmo, moves all other gizmos to the right of it to the
 *  left by its width on the GizmoBar.  Used when removing or hiding
 *  the gizmo.
 *
 * Parameters:
 *  pGizmo          LPGIZMO that is going away, visibly or physically.
 *
 * Return Value:
 *  None
 */

void GizmosCompact(LPGIZMO pGizmo)
    {
    UINT        cx;
    LPGIZMO     pCur;

    //Move all the gizmos beyond us on the GizmoBar back by our width.
    if (NULL!=pGizmo->pNext)
        {
        cx=pGizmo->pNext->x - pGizmo->x;
        pCur=pGizmo->pNext;

        while (NULL!=pCur)
            {
            pCur->x-=cx;

            if (NULL!=pCur->hWnd)
                {
                SetWindowPos(pCur->hWnd, NULL, pCur->x, pCur->y
                             , 0, 0, SWP_NOZORDER | SWP_NOSIZE);
                }

            pCur=pCur->pNext;
            }
        }

    return;
    }






/*
 * GizmoPFind
 *
 * Purpose:
 *  Given a GIZMO identifier, locates and returns a pointer to the structure
 *  for that position.
 *
 * Parameters:
 *  ppFirst         LPLPGIZMO providing the first gizmo in this list.
 *  uID             UINT identifier to find.
 *
 * Return Value:
 *  LPGIZMO         A pointer to a GIZMO structure allocated through
 *                  GizmoPAllocate, NULL if iGizmo is out of range.
 */

LPGIZMO GizmoPFind(LPLPGIZMO ppFirst, UINT uID)
    {
    LPGIZMO      pGizmo;

    pGizmo=*ppFirst;

    /*
     * Yep, linear search, but a better search algorithm won't improve
     * things appreciably.  The better thing to optimize is what the
     * caller passes as ppFirst.
     */
    while (NULL!=pGizmo && uID!=pGizmo->uID)
        pGizmo=pGizmo->pNext;

    return pGizmo;
    }






/*
 * GizmoFEnum
 *
 * Purpose:
 *  Enumerates the list of GIZMO structures, passing each one to
 *  an application-defined callback.
 *
 * Parameters:
 *  ppFirst         LPLPGIZMO providing the first gizmo in this list.
 *  pfnEnum         LPFNGIZMOENUM to call for each enumerated structure.
 *  dw              DWORD extra data to pass to the enumeration function.
 *
 * Return Value:
 *  LPGIZMO         NULL if the enumeration completed.  Otherwise a pointer
 *                  to the gizmo that enumeration stopped on.
 */

LPGIZMO GizmoPEnum(LPLPGIZMO ppFirst, LPFNGIZMOENUM pfnEnum, DWORD dw)
    {
    LPGIZMO pGizmo;
    UINT    i=0;

    pGizmo=*ppFirst;

    while (NULL!=pGizmo)
        {
        if (!(*pfnEnum)(pGizmo, i++, dw))
            break;

        pGizmo=pGizmo->pNext;
        }

    return pGizmo;
    }




/*
 * GizmoPStateSet
 *
 * Purpose:
 *  State maniuplation functions.  Set and Clear also invalidate
 *  this gizmo's rectangle on the given window and forces a repaint.
 *
 * Parameters:
 *  hWnd            HWND of the window to repaint.
 *  pGizmo          LPGIZMO affected.
 *  dwNew           DWORD new state flags.
 *
 * Return Value:
 *  UINT            Previous state.
 */

UINT  GizmoPStateSet(HWND hWnd, LPGIZMO pGizmo, UINT uNew)
    {
    UINT        uRet;
    RECT        rc;

    if (GIZMOTYPE_SEPARATOR==pGizmo->iType)
        return pGizmo->uState;

    //Preserve the color conversion flags across this state change.
    uRet=pGizmo->uState;
    pGizmo->uState=(uNew & 0x00FF) | (uRet & 0xFF00);

    //Adjust the rectangle by  one to avoid repainting  borders.
    SetRect(&rc, pGizmo->x+1, pGizmo->y+1, pGizmo->x+pGizmo->dx-1, pGizmo->y+pGizmo->dy-1);
    InvalidateRect(hWnd, &rc, FALSE);
    UpdateWindow(hWnd);

    return uRet;
    }








/*
 * GizmoPCheck
 *
 * Purpose:
 *  Handles checking a single button in a group of attribute buttons.
 *  If the gizmo belongs to a group of mutually exclusive buttons then
 *  the others surrounding it are unchecked appropriately.
 *
 * Parameters:
 *  hWnd            HWND of the GizmoBar.
 *  pGizmo          LPGIZMO of the gizmo affected.
 *  fCheck          BOOL TRUE to check the button, FALSE to uncheck.
 *
 * Return Value:
 *  BOOL            TRUE if the gizmo was previously checked, FALSE
 *                  otherwise.
 */

BOOL GizmoPCheck(HWND hWnd, LPGIZMO pGizmo, BOOL fCheck)
    {
    BOOL        fPrevCheck;
    LPGIZMO     pCur;


    //Ignore command buttons.
    if (GIZMOTYPE_BUTTONCOMMAND==pGizmo->iType)
        return FALSE;

    //Get the previous state
    fPrevCheck=(BOOL)(BUTTONGROUP_DOWN & pGizmo->uState);


    //Simply set the state for inclusive attribute buttons.
    if (GIZMOTYPE_BUTTONATTRIBUTEIN==pGizmo->iType)
        {
        if (pGizmo->fDisabled)
            {
            GizmoPStateSet(hWnd, pGizmo
                , fCheck ? ATTRIBUTEBUTTON_DOWNDISABLED : ATTRIBUTEBUTTON_DISABLED);
            }
        else
            {
            GizmoPStateSet(hWnd, pGizmo
                , fCheck ? ATTRIBUTEBUTTON_DOWN : ATTRIBUTEBUTTON_UP);
            }
        }


    if (GIZMOTYPE_BUTTONATTRIBUTEEX==pGizmo->iType)
        {
        //We cannot uncheck an exclusive attribute
        if (!fCheck)
            return fPrevCheck;

        /*
         * For exclusive buttons we have to do more work.  First, if we're
         * already checked (incliding DOWN and MOUSEDOWN) then we set DOWN
         * and exit.  If we're not already checked, then we look for the
         * gizmo around us, backwards and forwards, that is checked and
         * uncheck him.
         */

        //Search  backwards.
        pCur=pGizmo->pPrev;

        while (NULL!=pCur)
            {
            //Stop at any non-exclusive attribute.
            if (GIZMOTYPE_BUTTONATTRIBUTEEX!=pCur->iType)
                {
                pCur=NULL;
                break;
                }

            //If it's down, set it up and we've finished.
            if (BUTTONGROUP_DOWN & pCur->uState)
                break;

            pCur=pCur->pPrev;
            }


        //If we didn't find a previous one, pCur is NULL, so look ahead.
        if (NULL==pCur)
            {
            pCur=pGizmo->pNext;

            while (NULL!=pCur)
                {
                //Stop at any non-exclusive attribute.
                if (GIZMOTYPE_BUTTONATTRIBUTEEX!=pCur->iType)
                    {
                    pCur=NULL;
                    break;
                    }

                //If it's down, set it up and we've finished.
                if (BUTTONGROUP_DOWN & pCur->uState)
                    break;

                pCur=pCur->pNext;
                }
            }

        //If pCur is non-NULL, the we found a neighbor, so uncheck him
        if (NULL!=pCur)
            {
            GizmoPStateSet(hWnd, pCur
                , (pGizmo->fDisabled) ? ATTRIBUTEBUTTON_DISABLED : ATTRIBUTEBUTTON_UP);
            }

        //Always set ourselves down
        GizmoPStateSet(hWnd, pGizmo
            , (pGizmo->fDisabled) ? ATTRIBUTEBUTTON_DOWNDISABLED : ATTRIBUTEBUTTON_DOWN);
        }

    return fPrevCheck;
    }







/*
 * GenericSubProc
 *
 * Purpose:
 *  Subclasses window controls in Gizmos so we can trap the tab key and
 *  tab to the next control.  We can have one shared generic subclass
 *  procedure because we save the type index for this control in the
 *  property "iType."  This allows us to look up the original procedure
 *  in the pfnOrg array.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

//LRESULT FAR PASCAL EXPORT GenericSubProc(HWND hWnd, UINT iMsg
LRESULT FAR PASCAL GenericSubProc(HWND hWnd, UINT iMsg
    , WPARAM wParam, LPARAM lParam)
    {
    LRESULT     lRet;
    RECT        rc;
    RECT        rcE;
    HWND        hWndE;
    HBRUSH      hBr;
    HDC         hDC;
    UINT        dx;
    UINT        iType, i;

    i=(int)GetProp(hWnd, SZTYPEPROP);
    iType=POSITIONBIT(i);

    //Special:  paint the gap in drop-down comboboxes.
    if (GIZMOTYPE_COMBOBOX==iType && WM_PAINT==iMsg)
        {
        //Do default painting.
        lRet=(*pfnOrg[i])(hWnd, iMsg, wParam, lParam);

        hWndE=GetDlgItem(hWnd, ID_COMBOEDIT);

        GetClientRect(hWnd, &rc);
        GetClientRect(hWndE, &rcE);

        //The width of the button is the scroll bar width.
        dx=GetSystemMetrics(SM_CXVSCROLL);

        //Calculate the rectangle
        rc.right -=dx;
        rc.left   =rcE.right;
        rc.bottom+=1;

        //Paint the gap
        hDC=GetDC(hWnd);   //Already did BeginPaint and EndPaint

        hBr=CreateSolidBrush(GetSysColor(COLOR_BTNFACE));
        FillRect(hDC, &rc, hBr);
        DeleteObject(hBr);

        ReleaseDC(hWnd, hDC);
        return lRet;
        }

    //Control tabbing to the next or previous control in the GizmoBar.
    if (WM_KEYDOWN==iMsg && VK_TAB==wParam)
        {
        hWndE=hWnd;

        if (-1==i)
            hWndE=GetParent(hWnd);

        hWndE=GetNextDlgTabItem(GetParent(hWndE), hWnd, (BOOL)(GetKeyState(VK_SHIFT)));
        SetFocus(hWndE);
        return 0L;
        }

    if (-1==i) i=0;

    //Eat tab chars in edit controls to prevent beeping.
    if (0==i && WM_CHAR==iMsg && VK_TAB==wParam)
        return 0L;


    //Do this or edit controls bomb big-time.
    return CallWindowProc(pfnOrg[i], hWnd, iMsg, wParam, lParam);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\gizmo.h ===
/*
 * GIZMO.H
 * GizmoBar Version 1.00, Win32 version August 1993
 *
 * Data structure and type definitions for the GIZMO data structure.  Each
 * gizmo on a gizmobar has one of these structures associated with it.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#ifndef _GIZMO_H_
#define _GIZMO_H_

#ifdef __cplusplus
extern "C"
    {
#endif


typedef struct tagGIZMO
    {
    struct tagGIZMO FAR *pPrev;
    struct tagGIZMO FAR *pNext;
    UINT                 iType;
    HWND                 hWnd;       //Texts, edits, lists, and combos only.
    UINT                 uID;
    UINT                 x, y;
    UINT                 dx, dy;
    UINT                 cxImage;    //From UIToolConfigureForDisplay
    UINT                 cyImage;
    HBITMAP              hBmp;       //Buttons only.
    UINT                 iBmp;
    BOOL                 fNotify;    //Indicates whether we send WM_COMMANDs
    BOOL                 fHidden;    //Independent of state
    BOOL                 fDisabled;
    UINT                 uState;
    UINT                 uStateOrg;
    DWORD                dwData;     //Application-supplied data.
    } GIZMO, FAR * LPGIZMO;

typedef LPGIZMO FAR *LPLPGIZMO;
#define CBGIZMO sizeof(GIZMO)

//Property name we attach to controls in a gizmo to identify control type
#define SZTYPEPROP      TEXT("iType")

//Number of controls we subclass
#define CSUBGIZMOS       4

//ID of edit controls in comboboxes
#define ID_COMBOEDIT     1001


/*
 * Conversion of iType (a positioned bit) into its position.
 * The BITPOSITION macro does not need to be fast because we only
 * use it once when creating a gizmo.  POSITIONBIT does, however, since
 * we use it in subclass procedures.
 */
#define BITPOSITION(i, j)  {int k=i; for (j=0; k>>=1; j++);}
#define POSITIONBIT(i)     (1 << i)

//Control classifications.  GIZMOBAR.H must be included first.
#define GIZMOTYPE_WINDOWS           (GIZMOTYPE_TEXT | GIZMOTYPE_EDIT | GIZMOTYPE_LISTBOX | GIZMOTYPE_COMBOBOX | GIZMOTYPE_BUTTONNORMAL)
#define GIZMOTYPE_BUTTONS           (GIZMOTYPE_BUTTONATTRIBUTEIN | GIZMOTYPE_BUTTONATTRIBUTEEX | GIZMOTYPE_BUTTONCOMMAND | GIZMOTYPE_BUTTONNORMAL)
#define GIZMOTYPE_DRAWN             (GIZMOTYPE_BUTTONATTRIBUTEIN | GIZMOTYPE_BUTTONATTRIBUTEEX | GIZMOTYPE_BUTTONCOMMAND)


//These must stay in sync with GIZMOBAR.H
#define GIZMOTYPE_MIN               GIZMOTYPE_EDIT
#define GIZMOTYPE_MAX               GIZMOTYPE_BUTTONCOMMAND


//Enumeration callback
typedef BOOL (FAR PASCAL *LPFNGIZMOENUM)(LPGIZMO, UINT, DWORD);


//GIZMO.C
LPGIZMO  GizmoPAllocate(LPINT, LPLPGIZMO, HWND, UINT, UINT, UINT, UINT, UINT, LPTSTR, HBITMAP, UINT, UINT);
void     GizmosExpand(LPGIZMO);
LPGIZMO  GizmoPFree(LPLPGIZMO, LPGIZMO);
void     GizmosCompact(LPGIZMO);
LPGIZMO  GizmoPFind(LPLPGIZMO, UINT);
LPGIZMO  GizmoPEnum(LPLPGIZMO, LPFNGIZMOENUM, DWORD);
UINT     GizmoPStateSet(HWND, LPGIZMO, UINT);
BOOL     GizmoPCheck(HWND, LPGIZMO, BOOL);

//LRESULT FAR PASCAL EXPORT GenericSubProc(HWND, UINT, WPARAM, LPARAM);
LRESULT FAR PASCAL GenericSubProc(HWND, UINT, WPARAM, LPARAM);


#ifdef __cplusplus
    }
#endif

#endif //_GIZMO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\gizmobar.c ===
/*
 * GIZMOBAR.C
 * GizmoBar Version 1.00, Win32 version August 1993
 *
 * Contains the main window procedure of the GizmoBar control
 * that handles mouse logic and Windows messages.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#include <windows.h>
#include "gizmoint.h"



/*
 * GizmoBarWndProc
 *
 * Purpose:
 *  Window Procedure for the GizmoBar custom control.  Handles all
 *  messages like WM_PAINT just as a normal application window would.
 *  Any message not processed here should go to DefWindowProc.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

LRESULT FAR PASCAL GizmoBarWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
    {
    BOOL            fSuccess;
    BOOL            fTemp;
    LPCREATESTRUCT  pCreate;
    LPGIZMOBAR      pGB;
    LPGIZMO         pGizmo;
    RECT            rc;
    POINT           pt;
    short           x, y;
    COLORREF        cr;

    COMMANDPARAMS(wID, wCode, hWndMsg);

    pGB=(LPGIZMOBAR)GetWindowLong(hWnd, GBWL_STRUCTURE);

    //Pass control messages onto another function for processing.
    if (iMsg >= WM_USER)
        return GBMessageHandler(hWnd, iMsg, wParam, lParam, pGB);

    switch (iMsg)
        {
        case WM_NCCREATE:
            pCreate=(LPCREATESTRUCT)lParam;

            pGB=GizmoBarPAllocate((LPINT)&fSuccess, hWnd, pCreate->hInstance
                , pCreate->hwndParent, pCreate->style, 0
                , (UINT)pCreate->hMenu);

            if (!fSuccess)
                {
                GizmoBarPFree(pGB);
                return -1L;
                }
            else
                SetWindowLong(hWnd, GBWL_STRUCTURE, (LONG)pGB);

            return DefWindowProc(hWnd, iMsg, wParam, lParam);


        case WM_DESTROY:
            /*
             * We want to clean up before DestroyWindow nukes all the
             * children, so WM_DESTROY is a better to do it than
             * WM_NCDESTROY.
             */
            GizmoBarPFree(pGB);
            break;


        case WM_ERASEBKGND:
            /*
             * Eat this message to avoid erasing portions that
             * we are going to repaint in WM_PAINT.  Part of a
             * change-state-and-repaint strategy is to rely on
             * WM_PAINT to do anything visual, which includes
             * erasing invalid portions.  Letting WM_ERASEBKGND
             * erase the background is redundant.
             */
            return TRUE;

       #ifdef WIN32
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORSTATIC:
            fTemp=TRUE;
       #else
        case WM_CTLCOLOR:
            //Change the color of static text on the GizmoBar.
            fTemp=(HIWORD(lParam)==CTLCOLOR_STATIC
                || HIWORD(lParam)==CTLCOLOR_BTN);
       #endif

            if (fTemp)
                {
                cr=GetSysColor(COLOR_BTNFACE);
                SetTextColor((HDC)wParam, GetSysColor(COLOR_BTNTEXT));
                SetBkColor((HDC)wParam, cr);

                /*
                 * If the system colors have changed, then crFace will
                 * not be equal to COLOR_BTNFACE, so we reinitialize the
                 * background brush.  This scheme handles system color
                 * changes appropriately without processing WM_WININICHANGE
                 * and without blindly creating a new brush on every
                 * WM_CTLCOLOR message.
                 */
                if (cr!=pGB->crFace)
                    {
                    pGB->crFace=cr;

                    if (NULL!=pGB->hBrFace)
                        DeleteObject(pGB->hBrFace);

                    pGB->hBrFace=CreateSolidBrush(pGB->crFace);
                    }

                return (LONG)(UINT)pGB->hBrFace;
                }

            return DefWindowProc(hWnd, iMsg, wParam, lParam);


        case WM_PAINT:
            GizmoBarPaint(hWnd, pGB);
            break;


        case WM_SETFONT:
            /*
             * wParam has the new font that we now send to all other
             * windows controls in us.  We control repaints here to
             * prevent a lot of repainting for each control.
             */
            DefWindowProc(hWnd, WM_SETREDRAW, FALSE, 0L);

            if ((WPARAM)NULL!=wParam)
                {
                pGB->hFont=(HFONT)wParam;
                GizmoPEnum(&pGB->pGizmos, FEnumChangeFont, (DWORD)(LPSTR)pGB);

                DefWindowProc(hWnd, WM_SETREDRAW, TRUE, 0L);
                InvalidateRect(hWnd, NULL, FALSE);
                UpdateWindow(hWnd);
                }

            break;


        case WM_GETFONT:
            return (LRESULT)(UINT)pGB->hFont;


        case WM_ENABLE:
            /*
             * wParam has the new enable flag that we use to enable
             * or disable ALL controls in us at one time.  We also turn
             * the redraw off to prevent a lot of flicker.
             */
            DefWindowProc(hWnd, WM_SETREDRAW, FALSE, 0L);

            pGB->fEnabled=(BOOL)wParam;
            GizmoPEnum(&pGB->pGizmos, FEnumEnable, (DWORD)(LPSTR)pGB);

            DefWindowProc(hWnd, WM_SETREDRAW, TRUE, 0L);
            InvalidateRect(hWnd, NULL, FALSE);
            UpdateWindow(hWnd);
            break;


        case WM_CANCELMODE:
            pGizmo=pGB->pGizmoTrack;

            pGB->fTracking=FALSE;
            pGB->fMouseOut=FALSE;

            if (NULL!=pGizmo)
                GizmoPStateSet(hWnd, pGizmo, COMMANDBUTTON_UP);

            ReleaseCapture();
            break;


        case WM_LBUTTONDBLCLK:
        case WM_LBUTTONDOWN:
            //Get the mouse coordinates.
            x=LOWORD(lParam);
            y=HIWORD(lParam);


            /*
             * See if we hit a command or attribute gizmo or not.  Anything
             * else that is a control will get the message instead of
             * us anyway, so we don't have to check.  FEnumHitTest also
             * validates drawn gizmos, enabled, and visible, so we don't.
             */
            pGizmo=GizmoPEnum(&pGB->pGizmos, FEnumHitTest, lParam);

            if (NULL==pGizmo)
                break;          //Didn't hit one matching our needs.

            /*
             * Inform the associate that a command was hit like a menu item.
             */
            if (NULL!=pGB->hWndAssociate)
                {
                if (pGizmo->fNotify)
                    SendMenuSelect(pGB->hWndAssociate, pGizmo->uID, 0, 0);
                }

            /*
             * We hit a button.  If it's a command or attribute, then change
             * the state and start tracking.
             */
            pGB->fTracking=TRUE;
            pGB->pGizmoTrack=pGizmo;
            pGB->fMouseOut=FALSE;
            SetCapture(hWnd);

            pGizmo->uStateOrg=pGizmo->uState;
            GizmoPStateSet(hWnd, pGizmo, ATTRIBUTEBUTTON_MOUSEDOWN);

            break;


        case WM_MOUSEMOVE:
            POINTFROMLPARAM(pt, lParam);

            if (!pGB->fTracking)
                break;

            pGizmo=pGB->pGizmoTrack;
            SetRect(&rc, pGizmo->x, pGizmo->y, pGizmo->x+pGizmo->dx, pGizmo->y+pGizmo->dy);

            fTemp=pGB->fMouseOut;
            pGB->fMouseOut=!PtInRect(&rc, pt);

            //If the mouse went out, change state to the original.
            if (!fTemp && pGB->fMouseOut)
                {
                GizmoPStateSet(hWnd, pGizmo, pGizmo->uStateOrg);

                if (NULL!=pGB->hWndAssociate)
                    {
                    //Notify that we left the button
                    if (pGizmo->fNotify)
                        SendMenuSelect(pGB->hWndAssociate, 0x0000, 0xFFFF, 0);
                    }
                }

            if (fTemp && !pGB->fMouseOut)
                {
                GizmoPStateSet(hWnd, pGizmo, ATTRIBUTEBUTTON_MOUSEDOWN);

                if (NULL!=pGB->hWndAssociate)
                    {
                    //Notify that we pressed down again
                    if (pGizmo->fNotify)
                        SendMenuSelect(pGB->hWndAssociate, pGizmo->uID, 0x0000, 0);
                    }
                }

            break;


        case WM_LBUTTONUP:
            if (!pGB->fTracking)
                break;

            pGB->fTracking=FALSE;
            pGizmo=pGB->pGizmoTrack;
            ReleaseCapture();


            /*
             * Repaint if we were actually below the mouse when this
             * occurred.  For command buttons, pop the button up.  For
             * attributes, either toggle the state (inclusive buttons)
             * or check the selected one (exclusive buttons).
             */

            if (!pGB->fMouseOut)
                {
                //Command buttons always come up.
                if (GIZMOTYPE_BUTTONCOMMAND==pGizmo->iType)
                    GizmoPStateSet(hWnd, pGizmo, COMMANDBUTTON_UP);

                //Attribute inclusive buttons toggle
                if (GIZMOTYPE_BUTTONATTRIBUTEIN==pGizmo->iType)
                    GizmoPCheck(hWnd, pGizmo, !(BUTTONGROUP_DOWN & pGizmo->uStateOrg));

                //Attribure exclusive buttons are always checked.
                if (GIZMOTYPE_BUTTONATTRIBUTEEX==pGizmo->iType)
                    GizmoPCheck(hWnd, pGizmo, TRUE);

                //Only send messages if notify is ON.
                if (NULL!=pGB->hWndAssociate && pGizmo->fNotify)
                    {
                    SendMenuSelect(pGB->hWndAssociate, 0, 0xFFFF, 0);
                    SendCommand(pGB->hWndAssociate, pGizmo->uID, BN_CLICKED, hWnd);
                    }
                }

            break;


        case WM_COMMAND:
            //Pass control messages on if the gizmo's notify is ON.
            if (NULL!=pGB->hWndAssociate)
                {
                pGizmo=PGizmoFromHwndID(hWnd, wID);

                if (NULL!=pGizmo)
                    {
                    if (pGizmo->fNotify)
                        SendMessage(pGB->hWndAssociate, iMsg, wParam, lParam);
                    }
                }
            break;

        default:
            return DefWindowProc(hWnd, iMsg, wParam, lParam);
        }

    return 0L;
    }





/*
 * FEnumChangeFont
 *
 * Purpose:
 *  Enumeration callback for all the gizmos we know about in order to
 *  send a new font to them that's stored in LPGIZMOBAR in dw.
 *
 * Parameters:
 *  pGizmo          LPGIZMO to draw.
 *  iGizmo          UINT index on the GizmoBar of this gizmo.
 *  dw              DWORD extra data passed to GizmoPEnum, in our case
 *                  the GizmoBar's pGB.
 *
 * Return Value:
 *  BOOL            TRUE to continue the enumeration, FALSE otherwise.
 */

BOOL FAR PASCAL FEnumChangeFont(LPGIZMO pGizmo, UINT iGizmo, DWORD dw)
    {
    LPGIZMOBAR  pGB=(LPGIZMOBAR)dw;

    //We only need to change fonts in windowed controls using WM_SETFONT
    if (NULL!=pGizmo->hWnd)
        SendMessage(pGizmo->hWnd, WM_SETFONT, (WPARAM)pGB->hFont, 1L);

    return TRUE;
    }






/*
 * FEnumEnable
 *
 * Purpose:
 *  Enumeration callback for all the gizmos we know about in order to
 *  enable or disable them from the WM_ENABLE message.
 *
 * Parameters:
 *  pGizmo          LPGIZMO to draw.
 *  iGizmo          UINT index on the GizmoBar of this gizmo.
 *  dw              DWORD extra data passed to GizmoPEnum, in our case
 *                  the GizmoBar's pGB.
 *
 * Return Value:
 *  BOOL            TRUE to continue the enumeration, FALSE otherwise.
 */

BOOL FAR PASCAL FEnumEnable(LPGIZMO pGizmo, UINT iGizmo, DWORD dw)
    {
    LPGIZMOBAR  pGB=(LPGIZMOBAR)dw;
    BOOL        fEnable=pGB->fEnabled;

    //NOTE:  This code is duplicated in GBGizmoEnable in API.C
    if (NULL!=pGizmo->hWnd)
        EnableWindow(pGizmo->hWnd, fEnable);
    else
        {
        //If we're not down, command and attribute buttons act the same.
        if (!(BUTTONGROUP_DOWN & pGizmo->uState))
            {
            GizmoPStateSet(pGB->hWnd, pGizmo
                , fEnable ? COMMANDBUTTON_UP : COMMANDBUTTON_DISABLED);
            }
        else
            {
            //Attribute buttons are a little more sensitive with DOWNDISABLED
            GizmoPStateSet(pGB->hWnd, pGizmo
                , fEnable ? ATTRIBUTEBUTTON_DOWN : ATTRIBUTEBUTTON_DOWNDISABLED);
            }
        }

    return TRUE;
    }







/*
 * FEnumHitTest
 *
 * Purpose:
 *  Enumeration callback for all the gizmos we know about in order to
 *  hit-test them.
 *
 * Parameters:
 *  pGizmo          LPGIZMO to draw.
 *  iGizmo          UINT index on the GizmoBar of this gizmo.
 *  dw              DWORD extra data passed to GizmoPEnum, in our case
 *                  the hDC on which to draw.
 *
 * Return Value:
 *  BOOL            TRUE to continue the enumeration, FALSE otherwise.
 */

BOOL FAR PASCAL FEnumHitTest(LPGIZMO pGizmo, UINT iGizmo, DWORD dw)
    {
    RECT  rc;
    POINT pt;

    POINTFROMLPARAM(pt, dw);
	
    //Hit tests have to happen on visible, enabled, and drawn controls only.
    if (GIZMOTYPE_DRAWN & pGizmo->iType
        && !pGizmo->fHidden && !(BUTTONGROUP_DISABLED & pGizmo->uState))
        {
        SetRect(&rc, pGizmo->x, pGizmo->y
            , pGizmo->x+pGizmo->dx, pGizmo->y+pGizmo->dy);

        //Stop enumeration if we have a hit.
        return !PtInRect(&rc, pt);
        }

    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\gizmobar.h ===
/*
 * GIZMOBAR.H
 * GizmoBar Version 1.00, Win32 version August 1993
 *
 * Public definitions for application that use the GizmoBar such as
 * messages, prototypes for API functions, notification codes, and
 * control styles.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#ifndef _GIZMOBAR_H_
#define _GIZMOBAR_H_

#ifdef __cplusplus
extern "C"
    {
#endif


//Classname
#define CLASS_GIZMOBAR  TEXT("gizmobar")


//Message API Functions
HWND    WINAPI GBHwndAssociateSet(HWND, HWND);
HWND    WINAPI GBHwndAssociateGet(HWND);

BOOL    WINAPI GBGizmoAdd(HWND, UINT, UINT, UINT, UINT, UINT, LPTSTR, HBITMAP, UINT, UINT);
BOOL    WINAPI GBGizmoRemove(HWND, UINT);

LRESULT WINAPI GBGizmoSendMessage(HWND, UINT, UINT, WPARAM, LPARAM);

BOOL    WINAPI GBGizmoShow(HWND, UINT, BOOL);
BOOL    WINAPI GBGizmoEnable(HWND, UINT, BOOL);
BOOL    WINAPI GBGizmoCheck(HWND, UINT, BOOL);
UINT    WINAPI GBGizmoFocusSet(HWND, UINT);
BOOL    WINAPI GBGizmoExist(HWND, UINT);

int     WINAPI GBGizmoTypeGet(HWND, UINT);

DWORD   WINAPI GBGizmoDataSet(HWND, UINT, DWORD);
DWORD   WINAPI GBGizmoDataGet(HWND, UINT);
BOOL    WINAPI GBGizmoNotifySet(HWND, UINT, BOOL);
BOOL    WINAPI GBGizmoNotifyGet(HWND, UINT);

int     WINAPI GBGizmoTextGet(HWND, UINT, LPTSTR, UINT);
void    WINAPI GBGizmoTextSet(HWND, UINT, LPTSTR);
UINT    WINAPI GBGizmoIntGet(HWND, UINT, BOOL FAR *, BOOL);
void    WINAPI GBGizmoIntSet(HWND, UINT, UINT, BOOL);



//Notification codes sent via WM_COMMAND from GBHwndAssociateSet
#define GBN_ASSOCIATEGAIN               1
#define GBN_ASSOCIATELOSS               2
#define GBN_GIZMOADDED                  3
#define GBN_GIZMOREMOVED                4

//Message equivalents for functions.
#define GBM_HWNDASSOCIATESET            (WM_USER+0)
#define GBM_HWNDASSOCIATEGET            (WM_USER+1)
#define GBM_GIZMOADD                    (WM_USER+2)
#define GBM_GIZMOREMOVE                 (WM_USER+3)
#define GBM_GIZMOSENDMESSAGE            (WM_USER+4)
#define GBM_GIZMOSHOW                   (WM_USER+5)
#define GBM_GIZMOENABLE                 (WM_USER+6)
#define GBM_GIZMOCHECK                  (WM_USER+7)
#define GBM_GIZMOFOCUSSET               (WM_USER+8)
#define GBM_GIZMOEXIST                  (WM_USER+9)
#define GBM_GIZMOTYPEGET                (WM_USER+10)
#define GBM_GIZMODATASET                (WM_USER+11)
#define GBM_GIZMODATAGET                (WM_USER+12)
#define GBM_GIZMONOTIFYSET              (WM_USER+13)
#define GBM_GIZMONOTIFYGET              (WM_USER+14)
#define GBM_GIZMOTEXTGET                (WM_USER+15)
#define GBM_GIZMOTEXTSET                (WM_USER+16)
#define GBM_GIZMOINTGET                 (WM_USER+17)
#define GBM_GIZMOINTSET                 (WM_USER+18)




/*
 * Structure passed in lParam of GBM_GIZMOADD that mirrors the parameters
 * to GBGizmoAdd.
 */

typedef struct
    {
    HWND        hWndParent;         //Parent window
    UINT        iType;              //Type of gizmo
    UINT        iGizmo;             //Position in which to create gizmo
    UINT        uID;                //Identifier of gizmo (for WM_COMMAND messages)
    UINT        dx;                 //Dimensions of gizmo
    UINT        dy;
    LPTSTR       pszText;            //Gizmo text
    HBITMAP     hBmp;               //Source of gizmo button image.
    UINT        iImage;             //Index of image from hBmp
    UINT        uState;             //Initial state of the gizmo.
    } CREATEGIZMO, FAR *LPCREATEGIZMO;

#define CBCREATEGIZMO sizeof(CREATEGIZMO)


//For GBM_GIZMOSENDMESSAGE
typedef struct
    {
    UINT        iMsg;
    WPARAM      wParam;
    LPARAM      lParam;
    } GBMSG, FAR * LPGBMSG;

#define CBGBMSG sizeof(GBMSG);

//For GBM_GIZMOGETTEXT
typedef struct
    {
    LPTSTR       psz;
    UINT        cch;
    } GBGETTEXT, FAR * LPGBGETTEXT;

#define CBGBGETTEXT sizeof(GBGETTEXT);


//For GBM_GIZMOGETINT
typedef struct
    {
    BOOL        fSigned;
    BOOL        fSuccess;
    } GBGETINT, FAR * LPGBGETINT;

#define CBGBGETINT sizeof(GBGETINT);


//For GBM_GIZMOSETINT
typedef struct
    {
    UINT        uValue;
    BOOL        fSigned;
    } GBSETINT, FAR * LPGBSETINT;

#define CBGBSETINT sizeof(GBSETINT);



//Gizmo control types.  DO NOT CHANGE THESE!
#define GIZMOTYPE_EDIT                  0x0001
#define GIZMOTYPE_LISTBOX               0x0002
#define GIZMOTYPE_COMBOBOX              0x0004
#define GIZMOTYPE_BUTTONNORMAL          0x0008      //Top of windowed gizmos.
#define GIZMOTYPE_TEXT                  0x0010
#define GIZMOTYPE_SEPARATOR             0x0020
#define GIZMOTYPE_BUTTONATTRIBUTEIN     0x0040
#define GIZMOTYPE_BUTTONATTRIBUTEEX     0x0080
#define GIZMOTYPE_BUTTONCOMMAND         0x0100


//Generic state flags for non-buttons based on BTTNCUR.H's button groups.
#define GIZMO_NORMAL                    (BUTTONGROUP_ACTIVE)
#define GIZMO_DISABLED                  (BUTTONGROUP_DISABLED)



#ifdef __cplusplus
    }   //Match with extern "C" above.
#endif



#endif //_GIZMOBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\gizmoint.h ===
/*
 * GIZMOINT.H
 * GizmoBar Version 1.00, Win32 version August 1993
 *
 * Internal definitions for the GizmoBar DLL
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#ifndef _GIZMOINT_H_
#define _GIZMOINT_H_

#include <bttncur.h>
#include <book1632.h>
#include "gizmo.h"
#include "gizmobar.h"

#ifdef __cplusplus
extern "C"
    {
#endif


/*
 * The main gizmobar structure itself.  There's only one of these,
 * but it references the first GIZMO in the list.
 */

typedef struct tagGIZMOBAR
    {
    LPGIZMO     pGizmos;            //List of gizmos we own.
    HWND        hWnd;               //Window handle of ourselves.
    HINSTANCE   hInst;
    HWND        hWndAssociate;      //Associate window handle who gets messages.
    DWORD       dwStyle;            //Copy of GetWindowLong(hWnd, GWL_STYLE)
    UINT        uState;             //State flags
    UINT        uID;                //Control ID.

    HBRUSH      hBrFace;            //Static control background color
    COLORREF    crFace;             //Color of hBrFace
    HFONT       hFont;              //Font in use, defaults to system, WM_SETFONT
    BOOL        fEnabled;           //Are we enabled?

    LPGIZMO     pGizmoTrack;        //Current pressed button.
    BOOL        fTracking;
    BOOL        fMouseOut;
    } GIZMOBAR, FAR * LPGIZMOBAR;

#define CBGIZMOBAR sizeof(GIZMOBAR)


//Extra bytes for the window if the size of a local handle.
#define CBWINDOWEXTRA       sizeof(LPGIZMOBAR)

#define GBWL_STRUCTURE      0


//Structure for passing paint information to a gizmo enumeration callback.
typedef struct
    {
    HDC     hDC;
    BOOL    fPaint;
    } PAINTGIZMO, FAR * LPPAINTGIZMO;



//Private functions specific to the control.

//INIT.C
#ifdef WIN32
    extern BOOL WINAPI _CRT_INIT(HINSTANCE, DWORD, LPVOID);
    extern _cexit(void);
#endif //WIN32

void FAR PASCAL   WEP(int);
BOOL              FRegisterControl(HINSTANCE);
LPGIZMOBAR        GizmoBarPAllocate(LPINT, HWND, HINSTANCE, HWND, DWORD, UINT, UINT);
LPGIZMOBAR        GizmoBarPFree(LPGIZMOBAR);


//PAINT.C
void              GizmoBarPaint(HWND, LPGIZMOBAR);
BOOL FAR PASCAL   FEnumPaintGizmos(LPGIZMO, UINT, DWORD);


//GIZMOBAR.C
LRESULT FAR PASCAL GizmoBarWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL    FAR PASCAL FEnumChangeFont(LPGIZMO, UINT, DWORD);
BOOL    FAR PASCAL FEnumEnable(LPGIZMO, UINT, DWORD);
BOOL    FAR PASCAL FEnumHitTest(LPGIZMO, UINT, DWORD);


//API.C  Also see GIZMOBAR.H for others
LRESULT    GBMessageHandler(HWND, UINT, WPARAM, LPARAM, LPGIZMOBAR);
LPGIZMO    PGizmoFromHwndID(HWND, UINT);


#endif //_GIZMOINT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\chicago\makefile.inc ===
obj\*\gizmobar.def: gizmobar.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\init.c ===
/*
 * INIT.C
 * GizmoBar Version 1.00, Win32 version August 1993
 *
 * LibMain entry point and initialization code for the GizmoBar
 * DLL that is likely to be used once or very infrequently.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#include <windows.h>
#include "gizmoint.h"


/*
 * LibMain
 *
 * Purpose:
 *  Entry point conditionally compiled for Windows NT and Windows
 *  3.1.  Provides the proper structure for each environment
 *  and calls InternalLibMain for real initialization.
 */

#ifdef WIN32
BOOL _cdecl LibMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpvReserved)
    {
    if (DLL_PROCESS_ATTACH == dwReason)
	{
	return FRegisterControl(hDll);
	}
    else
        {
        return TRUE;
	}
    }

#else
HANDLE FAR PASCAL LibMain(HANDLE hInstance, WORD wDataSeg
    , WORD cbHeapSize, LPSTR lpCmdLine)
    {
     //Perform global initialization.
    if (FRegisterControl(hInstance))
        {
        if (0!=cbHeapSize)
            UnlockData(0);
        }

    return hInstance;
    }
#endif




/*
 * WEP
 *
 * Purpose:
 *  Required DLL Exit function.  Does nothing.
 *
 * Parameters:
 *  bSystemExit     BOOL indicating if the system is being shut
 *                  down or the DLL has just been unloaded.
 *
 * Return Value:
 *  void
 *
 */

void FAR PASCAL WEP(int bSystemExit)
    {
    return;
    }




/*
 * FRegisterControl
 *
 * Purpose:
 *  Registers the GizmoBar control class, including CS_GLOBALCLASS
 *  to make the control available to all applications in the system.
 *
 * Parameters:
 *  hInst           HINSTANCE of the DLL that will own this class.
 *
 * Return Value:
 *  BOOL            TRUE if the class is registered, FALSE otherwise.
 */

BOOL FRegisterControl(HINSTANCE hInst)
    {
    static BOOL     fRegistered=FALSE;
    WNDCLASS        wc;

    if (!fRegistered)
        {
        wc.lpfnWndProc   =GizmoBarWndProc;
        wc.cbClsExtra    =0;
        wc.cbWndExtra    =CBWINDOWEXTRA;
        wc.hInstance     =hInst;
        wc.hIcon         =NULL;
        wc.hCursor       =LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground =(HBRUSH)(COLOR_BTNFACE+1);
        wc.lpszMenuName  =NULL;
        wc.lpszClassName =CLASS_GIZMOBAR;
        wc.style         =CS_DBLCLKS | CS_GLOBALCLASS | CS_VREDRAW | CS_HREDRAW;

        fRegistered=RegisterClass(&wc);
        }

    return fRegistered;
    }






/*
 * GizmoBarPAllocate
 *
 * Purpose:
 *  Allocates and initializes the control's primary data structure for
 *  each window that gets created.
 *
 * Parameters:
 *  pfSuccess       LPINT indicating success of the function.
 *  hWnd            HWND that is tied to this structure.
 *  hInst           HINSTANCE of the DLL.
 *  hWndAssociate   HWND to which we send messages.
 *  dwStyle         DWORD initial style.
 *  uState          UINT initial state.
 *  uID             UINT identifier for this window.
 *
 * Return Value:
 *  LPGIZMOBAR      If NULL returned then GizmoBarPAllocate could not allocate
 *                  memory.  If a non-NULL pointer is returned with
 *                  *pfSuccess, then call GizmoBarPFree immediately.  If you
 *                  get a non-NULL pointer and *pfSuccess==TRUE then the
 *                  function succeeded.
 */

LPGIZMOBAR GizmoBarPAllocate(LPINT pfSuccess, HWND hWnd, HINSTANCE hInst
    , HWND hWndAssociate, DWORD dwStyle, UINT uState, UINT uID)
    {
    LPGIZMOBAR    pGB;

    if (NULL==pfSuccess)
        return NULL;

    *pfSuccess=FALSE;

    //Allocate the structure
    pGB=(LPGIZMOBAR)(void *)LocalAlloc(LPTR, CBGIZMOBAR);

    if (NULL==pGB)
        return NULL;

    //Initialize LibMain parameter holders.
    pGB->hWnd         =hWnd;
    pGB->hInst        =hInst;
    pGB->hWndAssociate=hWndAssociate;
    pGB->dwStyle      =dwStyle;
    pGB->uState       =uState;
    pGB->uID          =uID;
    pGB->fEnabled     =TRUE;

    pGB->crFace=GetSysColor(COLOR_BTNFACE);
    pGB->hBrFace=CreateSolidBrush(pGB->crFace);

    if (NULL==pGB->hBrFace)
        return pGB;

    pGB->hFont=GetStockObject(SYSTEM_FONT);

    *pfSuccess=TRUE;
    return pGB;
    }




/*
 * GizmoBarPFree
 *
 * Purpose:
 *  Reverses all initialization done by GizmoBarPAllocate, cleaning up
 *  any allocations including the application structure itself.
 *
 * Parameters:
 *  pGB             LPGIZMOBAR to the control's structure
 *
 * Return Value:
 *  LPGIZMOBAR      NULL if successful, pGB if not, meaning we couldn't
 *                  free some allocation.
 */

LPGIZMOBAR GizmoBarPFree(LPGIZMOBAR pGB)
    {
    if (NULL==pGB)
        return NULL;

    /*
     * Free all the gizmos we own.  When we call GizmoPFree we always
     * free the first one in the list which updates pGB->pGizmos for
     * us, so we just have to keep going until pGizmos is NULL, meaning
     * we're at the end of the list.
     */
    while (NULL!=pGB->pGizmos)
        GizmoPFree(&pGB->pGizmos, pGB->pGizmos);

    if (NULL!=pGB->hBrFace)
        DeleteObject(pGB->hBrFace);

    /*
     * Notice that since we never create a font, we aren't responsible
     * for our hFont member.
     */

    return (LPGIZMOBAR)(void *)LocalFree((HLOCAL)(void *)(LONG)pGB);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\paint.c ===
/*
 * PAINT.C
 * GizmoBar Version 1.00, Win32 version August 1993
 *
 * Contains any code related to GizmoBar visuals, primarily
 * the WM_PAINT handler.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 *
 * Kraig Brockschmidt, Software Design Engineer
 * Microsoft Systems Developer Relations
 *
 * Internet  :  kraigb@microsoft.com
 * Compuserve:  >INTERNET:kraigb@microsoft.com
 */


#include <windows.h>
#include "gizmoint.h"


//In GIZMO.C
extern TOOLDISPLAYDATA tdd;


/*
 * GizmoBarPaint
 *
 * Purpose:
 *  Handles all WM_PAINT messages for the control and paints either the
 *  entire thing or just one GizmoBar button if pGB->pGizmoPaint is non-NULL.
 *
 * Parameters:
 *  hWnd            HWND Handle to the control.
 *  pGB             LPGIZMOBAR control data pointer.
 *
 * Return Value:
 *  None
 */

void GizmoBarPaint(HWND hWnd, LPGIZMOBAR pGB)
    {
    PAINTSTRUCT ps;
    RECT        rc;
    HDC         hDC;
    HBRUSH      hBr=NULL;
    HPEN        hPen=NULL;


    hDC=BeginPaint(hWnd, &ps);
    GetClientRect(hWnd, &rc);

    /*
     * The only part of the frame we need to draw is the bottom line,
     * so we inflate the rectangle such that all other parts are outside
     * the visible region.
     */
    hBr =CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

    if (NULL!=hBr)
        SelectObject(hDC, hBr);

    hPen=CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));

    if (NULL!=hPen)
        SelectObject(hDC, hPen);

    Rectangle(hDC, rc.left-1, rc.top-1, rc.right+1, rc.bottom);


    /*
     * All that we have to do to draw the controls is start through the
     * list, ignoring anything but buttons, and calling BTTNCUR's
     * UIToolButtonDraw for buttons.  Since we don't even have to track
     * positions of things, we can just use an enum.
     */
    GizmoPEnum(&pGB->pGizmos, FEnumPaintGizmos, (DWORD)(LPSTR)&ps);

    //Clean up
    EndPaint(hWnd, &ps);

    if (NULL!=hBr)
        DeleteObject(hBr);

    if (NULL!=hPen)
        DeleteObject(hPen);

    return;
    }





/*
 * FEnumPaintGizmos
 *
 * Purpose:
 *  Enumeration callback for all the gizmos we know about in order to
 *  draw them.
 *
 * Parameters:
 *  pGizmo          LPGIZMO to draw.
 *  iGizmo          UINT index on the GizmoBar of this gizmo.
 *  dw              DWORD extra data passed to GizmoPEnum, in our case
 *                  a pointer to the PAINTSTRUCT.
 *
 * Return Value:
 *  BOOL            TRUE to continue the enumeration, FALSE otherwise.
 */

BOOL FAR PASCAL FEnumPaintGizmos(LPGIZMO pGizmo, UINT iGizmo, DWORD dw)
    {
    LPPAINTSTRUCT   pps=(LPPAINTSTRUCT)dw;
    RECT            rc, rcI;

    //Only draw those marked for repaint.
    if ((GIZMOTYPE_DRAWN & pGizmo->iType))
        {
        SetRect(&rc, pGizmo->x, pGizmo->y, pGizmo->x+pGizmo->dx, pGizmo->y+pGizmo->dy);

        //Only draw gizmos in the repaint area
        if (IntersectRect(&rcI, &rc, &pps->rcPaint))
            {
            UIToolButtonDrawTDD(pps->hdc, pGizmo->x, pGizmo->y
                , pGizmo->dx, pGizmo->dy, pGizmo->hBmp, pGizmo->cxImage
                , pGizmo->cyImage, pGizmo->iBmp, (UINT)pGizmo->uState, &tdd);
            }
        }

    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\gizmobar\daytona\makefile.inc ===
obj\*\gizmobar.def: gizmobar.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\ole2ui\busy.h ===
/*
 * BUSY.H
 *
 * Internal definitions, structures, and function prototypes for the
 * OLE 2.0 UI Busy dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#ifndef _BUSY_H_
#define _BUSY_H_

//Internally used structure
typedef struct tagBUSY
    {
    //Keep this item first as the Standard* functions depend on it here.
    LPOLEUIBUSY     lpOBZ;       //Original structure passed.

    /*
     * What we store extra in this structure besides the original caller's
     * pointer are those fields that we need to modify during the life of
     * the dialog or that we don't want to change in the original structure
     * until the user presses OK.
     */

    DWORD               dwFlags;                // Flags passed in
    HWND                hWndBlocked;            // HWND of app which is blocking
    } BUSY, *PBUSY, FAR *LPBUSY;

// Internal function prototypes
BOOL    GetTaskInfo(HWND hWnd, HTASK htask, LPTSTR FAR* lplpszTaskName, LPTSTR FAR*lplpszWindowName, HWND FAR*lphWnd);
void    BuildBusyDialogString(HWND, DWORD, int, LPTSTR, LPTSTR);
BOOL CALLBACK EXPORT BusyDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
void    BusyCleanup(HWND hDlg);
BOOL    FBusyInit(HWND hDlg, WPARAM wParam, LPARAM lParam);
BOOL    InitEnumeration(void);
void    UnInitEnumeration(void);
        StartTaskManager(void);
void    MakeWindowActive(HWND hWndSwitchTo);

#endif //_BUSY_H_





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\ole2ui\common.h ===
/*
 * COMMON.H
 *
 * Structures and definitions applicable to all OLE 2.0 UI dialogs.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _COMMON_H_
#define _COMMON_H_


//Macros to handle control message packing between Win16 and Win32
#ifdef WIN32

#ifndef COMMANDPARAMS
#define COMMANDPARAMS(wID, wCode, hWndMsg)                          \
    WORD        wID     = LOWORD(wParam);                           \
    WORD        wCode   = HIWORD(wParam);                           \
    HWND        hWndMsg = (HWND)(UINT)lParam;
#endif  //COMMANDPARAMS

#ifndef SendCommand
#define SendCommand(hWnd, wID, wCode, hControl)                     \
            SendMessage(hWnd, WM_COMMAND, MAKELONG(wID, wCode)      \
                        , (LPARAM)hControl)
#endif  //SendCommand

#else   //Start !WIN32

#ifndef COMMANDPARAMS
#define COMMANDPARAMS(wID, wCode, hWndMsg)                          \
    WORD        wID     = LOWORD(wParam);                           \
    WORD        wCode   = HIWORD(lParam);                           \
    HWND        hWndMsg = (HWND)(UINT)lParam;
#endif  //COMMANDPARAMS

#ifndef SendCommand
#define SendCommand(hWnd, wID, wCode, hControl)                     \
            SendMessage(hWnd, WM_COMMAND, wID                       \
                        , MAKELONG(hControl, wCode))
#endif  //SendCommand

#endif  //!WIN32



//Property labels used to store dialog structures and fonts
#define STRUCTUREPROP       TEXT("Structure")
#define FONTPROP            TEXT("Font")


/*
 * Standard structure for all dialogs.  This commonality lets us make
 * a single piece of code that will validate this entire structure and
 * perform any necessary initialization.
 */

typedef struct tagOLEUISTANDARD
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;       //Structure Size
    DWORD           dwFlags;        //IN-OUT:  Flags
    HWND            hWndOwner;      //Owning window
    LPCTSTR         lpszCaption;    //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;       //Hook callback
    LPARAM          lCustData;      //Custom data to pass to hook
    HINSTANCE       hInstance;      //Instance for customized template name
    LPCTSTR         lpszTemplate;   //Customized template name
    HRSRC           hResource;      //Customized template handle
    } OLEUISTANDARD, *POLEUISTANDARD, FAR *LPOLEUISTANDARD;



//Function prototypes
//COMMON.C
UINT  WINAPI  UStandardValidation(const LPOLEUISTANDARD, const UINT, const HGLOBAL FAR *);

#ifdef WIN32
UINT  WINAPI  UStandardInvocation(DLGPROC, LPOLEUISTANDARD, HGLOBAL, LPTSTR);
#else
UINT  WINAPI  UStandardInvocation(DLGPROC, LPOLEUISTANDARD, HGLOBAL, LPCTSTR);
#endif

LPVOID WINAPI LpvStandardInit(HWND, UINT, BOOL, HFONT FAR *);
LPVOID WINAPI LpvStandardEntry(HWND, UINT, WPARAM, LPARAM, UINT FAR *);
UINT WINAPI   UStandardHook(LPVOID, HWND, UINT, WPARAM, LPARAM);
void WINAPI   StandardCleanup(LPVOID, HWND);
void WINAPI   StandardShowDlgItem(HWND hDlg, int idControl, int nCmdShow);


//DRAWICON.C

//Structure for label and source extraction from a metafile
typedef struct tagLABELEXTRACT
    {
    LPTSTR      lpsz;
    UINT        Index;      // index in lpsz (so we can retrieve 2+ lines)
    DWORD       PrevIndex;  // index of last line (so we can mimic word wrap)

    union
        {
        UINT    cch;        //Length of label for label extraction
        UINT    iIcon;      //Index of icon in source extraction.
        } u;

    //For internal use in enum procs
    BOOL        fFoundIconOnly;
    BOOL        fFoundSource;
    BOOL        fFoundIndex;
    } LABELEXTRACT, FAR * LPLABELEXTRACT;


//Structure for extracting icons from a metafile (CreateIcon parameters)
typedef struct tagICONEXTRACT
    {
    HICON       hIcon;          //Icon created in the enumeration proc.

    /*
     * Since we want to handle multitasking well we have the caller
     * of the enumeration proc instantiate these variables instead of
     * using statics in the enum proc (which would be bad).
     */
    BOOL        fAND;
    HGLOBAL     hMemAND;        //Enumeration proc allocates and copies
    } ICONEXTRACT, FAR * LPICONEXTRACT;


//Structure to use to pass info to EnumMetafileDraw
typedef struct tagDRAWINFO
    {
    RECT     Rect;
    BOOL     fIconOnly;
    } DRAWINFO, FAR * LPDRAWINFO;


int CALLBACK EXPORT EnumMetafileIconDraw(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPARAM);
int CALLBACK EXPORT EnumMetafileExtractLabel(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPLABELEXTRACT);
int CALLBACK EXPORT EnumMetafileExtractIcon(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPICONEXTRACT);
int CALLBACK EXPORT EnumMetafileExtractIconSource(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPLABELEXTRACT);


//Shared globals:  our instance, registered messages used from all dialogs and clipboard
// formats used by the PasteSpecial dialog
extern HINSTANCE  ghInst;

extern UINT       uMsgHelp;
extern UINT       uMsgEndDialog;
extern UINT       uMsgBrowse;
extern UINT       uMsgChangeIcon;
extern UINT       uMsgFileOKString;
extern UINT       uMsgCloseBusyDlg;

extern UINT       cfObjectDescriptor;
extern UINT       cfLinkSrcDescriptor;
extern UINT       cfEmbedSource;
extern UINT       cfEmbeddedObject;
extern UINT       cfLinkSource;
extern UINT       cfOwnerLink;
extern UINT       cfFileName;

//Standard control identifiers
#define ID_NULL                         98

#endif //_COMMON_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\oleutest\letest\ole2ui\busy.c ===
/*
 * BUSY.C
 *
 * Implements the OleUIBusy function which invokes the "Server Busy"
 * dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#define STRICT  1
#include "ole2ui.h"
#include "common.h"
#include "utility.h"
#include "busy.h"
#include <ctype.h> // for tolower() and toupper()

#ifndef WIN32
#include <toolhelp.h>
#endif


/*
 * OleUIBusy
 *
 * Purpose:
 *  Invokes the standard OLE "Server Busy" dialog box which
 *  notifies the user that the server application is not receiving
 *  messages.  The dialog then asks the user to either cancel
 *  the operation, switch to the task which is blocked, or continue
 *  waiting.
 *
 * Parameters:
 *  lpBZ            LPOLEUIBUSY pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *              OLEUI_BZERR_HTASKINVALID  : Error
 *              OLEUI_BZ_SWITCHTOSELECTED : Success, user selected "switch to"
 *              OLEUI_BZ_RETRYSELECTED    : Success, user selected "retry"
 *              OLEUI_CANCEL              : Success, user selected "cancel"
 */

STDAPI_(UINT) OleUIBusy(LPOLEUIBUSY lpOBZ)
    {
    UINT        uRet = 0;
    HGLOBAL     hMemDlg=NULL;

#if !defined( WIN32 )
// BUGBUG32:    this is not yet ported to NT

    uRet=UStandardValidation((LPOLEUISTANDARD)lpOBZ, sizeof(OLEUIBUSY)
                             , &hMemDlg);

    // Error out if the standard validation failed
    if (OLEUI_SUCCESS!=uRet)
        return uRet;

    // Validate HTASK
    if (!IsTask(lpOBZ->hTask))
        uRet = OLEUI_BZERR_HTASKINVALID;

    // Error out if our secondary validation failed
    if (OLEUI_ERR_STANDARDMIN <= uRet)
        {
        if (NULL!=hMemDlg)
            FreeResource(hMemDlg);

        return uRet;
        }

    // Invoke the dialog.
    uRet=UStandardInvocation(BusyDialogProc, (LPOLEUISTANDARD)lpOBZ,
                             hMemDlg, MAKEINTRESOURCE(IDD_BUSY));
#endif

    return uRet;
}


/*
 * BusyDialogProc
 *
 * Purpose:
 *  Implements the OLE Busy dialog as invoked through the OleUIBusy function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 *
 */

BOOL CALLBACK EXPORT BusyDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
    {
    LPBUSY         lpBZ;
    UINT           uRet = 0;

    //Declare Win16/Win32 compatible WM_COMMAND parameters.
    COMMANDPARAMS(wID, wCode, hWndMsg);

    //This will fail under WM_INITDIALOG, where we allocate it.
    lpBZ=(LPBUSY)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

    //If the hook processed the message, we're done.
    if (0!=uRet)
        return (BOOL)uRet;

    //Process the temination message
    if (iMsg==uMsgEndDialog)
    {
        BusyCleanup(hDlg);
        StandardCleanup(lpBZ, hDlg);
        EndDialog(hDlg, wParam);
        return TRUE;
    }

    // Process our special "close" message.  If we get this message,
    // this means that the call got unblocked, so we need to
    // return OLEUI_BZ_CALLUNBLOCKED to our calling app.
    if (iMsg == uMsgCloseBusyDlg)
    {
        SendMessage(hDlg, uMsgEndDialog, OLEUI_BZ_CALLUNBLOCKED, 0L);
        return TRUE;
    }

    switch (iMsg)
        {
        case WM_INITDIALOG:
            FBusyInit(hDlg, wParam, lParam);
            return TRUE;

        case WM_ACTIVATEAPP:
        {
            /* try to bring down our Busy/NotResponding dialog as if
            **    the user entered RETRY.
            */
            BOOL fActive = (BOOL)wParam;
            if (fActive) {
                // If this is the app BUSY case, then bring down our
                // dialog when switching BACK to our app
                if (lpBZ && !(lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG))
                    SendMessage(hDlg,uMsgEndDialog,OLEUI_BZ_RETRYSELECTED,0L);
            } else {
                // If this is the app NOT RESPONDING case, then bring down
                // our dialog when switching AWAY to another app
                if (lpBZ && (lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG))
                    SendMessage(hDlg,uMsgEndDialog,OLEUI_BZ_RETRYSELECTED,0L);
            }
            return TRUE;
        }

        case WM_COMMAND:
            switch (wID)
                {
                case IDBZ_SWITCHTO:
                {
                    BOOL fNotRespondingDlg =
                            (BOOL)(lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG);

                    // If user selects "Switch To...", switch activation
                    // directly to the window which is causing the problem.
                    if (IsWindow(lpBZ->hWndBlocked))
                        MakeWindowActive(lpBZ->hWndBlocked);
                    else
                        StartTaskManager(); // Fail safe: Start Task Manager

                    // If this is the app not responding case, then we want
                    // to bring down the dialog when "SwitchTo" is selected.
                    // If the app is busy (RetryRejectedCall situation) then
                    // we do NOT want to bring down the dialog. this is
                    // the OLE2.0 user model design.
                    if (fNotRespondingDlg)
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_BZ_SWITCHTOSELECTED, 0L);
                    break;
                }
                case IDBZ_RETRY:
                    SendMessage(hDlg, uMsgEndDialog, OLEUI_BZ_RETRYSELECTED, 0L);
                    break;

                case IDCANCEL:
                    SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                    break;
                }
            break;
        }
    return FALSE;
    }


/*
 * FBusyInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Busy dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */

BOOL FBusyInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
    {
    LPBUSY           lpBZ;
    LPOLEUIBUSY      lpOBZ;
    HFONT            hFont;
    LPTSTR           lpTaskName;
    LPTSTR           lpWindowName;
    HICON            hIcon;

    lpBZ=(LPBUSY)LpvStandardInit(hDlg, sizeof(OLEUIBUSY), TRUE, &hFont);

    // PvStandardInit sent a termination to us already.
    if (NULL==lpBZ)
        return FALSE;

    // Our original structure is in lParam
    lpOBZ = (LPOLEUIBUSY)lParam;

    // Copy it to our instance of the structure (in lpBZ)
    lpBZ->lpOBZ=lpOBZ;

    //Copy other information from lpOBZ that we might modify.
    lpBZ->dwFlags = lpOBZ->dwFlags;

    // Set default information
    lpBZ->hWndBlocked = NULL;

    // Insert HWND of our dialog into the address pointed to by
    // lphWndDialog.  This can be used by the app who called
    // OleUIBusy to bring down the dialog with uMsgCloseBusyDialog
    if (lpOBZ->lphWndDialog &&
        !IsBadWritePtr((VOID FAR *)lpOBZ->lphWndDialog, sizeof(HWND)))
        {
        *lpOBZ->lphWndDialog = hDlg;
        }

    // Update text in text box --
    // GetTaskInfo will return two pointers, one to the task name
    // (file name) and one to the window name.  We need to call
    // OleStdFree on these when we're done with them.  We also
    // get the HWND which is blocked in this call
    //
    // In the case where this call fails, a default message should already
    // be present in the dialog template, so no action is needed

    if (GetTaskInfo(hDlg, lpOBZ->hTask, &lpTaskName, &lpWindowName, &lpBZ->hWndBlocked))
        {
        // Build string to present to user, place in IDBZ_MESSAGE1 control
        BuildBusyDialogString(hDlg, lpBZ->dwFlags, IDBZ_MESSAGE1, lpTaskName, lpWindowName);
        OleStdFree(lpTaskName);
        OleStdFree(lpWindowName);
        }

    // Update icon with the system "exclamation" icon
    hIcon = LoadIcon(NULL, IDI_EXCLAMATION);
    SendDlgItemMessage(hDlg, IDBZ_ICON, STM_SETICON, (WPARAM)hIcon, 0L);

    // Disable/Enable controls
    if ((lpBZ->dwFlags & BZ_DISABLECANCELBUTTON) ||
        (lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG))              // Disable cancel for "not responding" dialog
        EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);

    if (lpBZ->dwFlags & BZ_DISABLESWITCHTOBUTTON)
        EnableWindow(GetDlgItem(hDlg, IDBZ_SWITCHTO), FALSE);

    if (lpBZ->dwFlags & BZ_DISABLERETRYBUTTON)
        EnableWindow(GetDlgItem(hDlg, IDBZ_RETRY), FALSE);

    // Call the hook with lCustData in lParam
    UStandardHook((LPVOID)lpBZ, hDlg, WM_INITDIALOG, wParam, lpOBZ->lCustData);

    // Update caption if lpszCaption was specified
    if (lpBZ->lpOBZ->lpszCaption && !IsBadReadPtr(lpBZ->lpOBZ->lpszCaption, 1)
          && lpBZ->lpOBZ->lpszCaption[0] != '\0')
        SetWindowText(hDlg, lpBZ->lpOBZ->lpszCaption);

    return TRUE;
    }


/*
 * BuildBusyDialogString
 *
 * Purpose:
 *  Builds the string that will be displayed in the dialog from the
 *  task name and window name parameters.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  dwFlags         DWORD containing flags passed into dialog
 *  iControl        Control ID to place the text string
 *  lpTaskName      LPSTR pointing to name of task (e.g. C:\TEST\TEST.EXE)
 *  lpWindowName    LPSTR for name of window
 *
 * Caveats:
 *  The caller of this function MUST de-allocate the lpTaskName and
 *  lpWindowName pointers itself with OleStdFree
 *
 * Return Value:
 *  void
 */

void BuildBusyDialogString(HWND hDlg, DWORD dwFlags, int iControl, LPTSTR lpTaskName, LPTSTR lpWindowName)
{
    LPTSTR      pszT, psz1, psz2, psz3;
    UINT        cch;
    LPTSTR      pszDot, pszSlash;
    UINT        uiStringNum;

    /*
     * We need scratch memory for loading the stringtable string,
     * the task name, and constructing the final string.  We therefore
     * allocate three buffers as large as the maximum message
     * length (512) plus the object type, guaranteeing that we have enough
     * in all cases.
     */
    cch=512;

    // Use OLE-supplied allocation
    if ((pszT = OleStdMalloc((ULONG)(3*cch))) == NULL)
        return;

    psz1=pszT;
    psz2=psz1+cch;
    psz3=psz2+cch;

    // Parse base name out of path name, use psz2 for the task
    // name to display
    // In Win32, _fstrcpy is mapped to handle UNICODE stuff
    _fstrcpy(psz2, lpTaskName);
    pszDot = _fstrrchr(psz2, TEXT('.'));
    pszSlash = _fstrrchr(psz2, TEXT('\\')); // Find last backslash in path

    if (pszDot != NULL)
#ifdef UNICODE
      *pszDot = TEXT('\0'); // Null terminate at the DOT
#else
      *pszDot = '\0'; // Null terminate at the DOT
#endif

    if (pszSlash != NULL)
      psz2 = pszSlash + 1; // Nuke everything up to this point

#ifdef LOWERCASE_NAME
    // Compile this with /DLOWERCASE_NAME if you want the lower-case
    // module name to be displayed in the dialog rather than the
    // all-caps name.
    {
    int i,l;

    // Now, lowercase all letters except first one
    l = _fstrlen(psz2);
    for(i=0;i<l;i++)
      psz2[i] = tolower(psz2[i]);

    psz2[0] = toupper(psz2[0]);
    }
#endif

    // Check size of lpWindowName.  We can reasonably fit about 80
    // characters into the text control, so truncate more than 80 chars
    if (_fstrlen(lpWindowName)> 80)
#ifdef UNICODE
      lpWindowName[80] = TEXT('\0');
#else
      lpWindowName[80] = '\0';
#endif

    // Load the format string out of stringtable, choose a different
    // string depending on what flags are passed in to the dialog
    if (dwFlags & BZ_NOTRESPONDINGDIALOG)
        uiStringNum = IDS_BZRESULTTEXTNOTRESPONDING;
    else
        uiStringNum = IDS_BZRESULTTEXTBUSY;

    if (LoadString(ghInst, uiStringNum, psz1, cch) == 0)
      return;

    // Build the string. The format string looks like this:
    // "This action cannot be completed because the '%s' application
    // (%s) is [busy | not responding]. Choose \"Switch To\" to activate '%s' and
    // correct the problem."

    wsprintf(psz3, psz1, (LPSTR)psz2, (LPTSTR)lpWindowName, (LPTSTR)psz2);
    SetDlgItemText(hDlg, iControl, (LPTSTR)psz3);
    OleStdFree(pszT);

    return;
}



/*
 * BusyCleanup
 *
 * Purpose:
 *  Performs busy-specific cleanup before termination.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box so we can access controls.
 *
 * Return Value:
 *  None
 */
void BusyCleanup(HWND hDlg)
{
   return;
}



/*
 * GetTaskInfo()
 *
 * Purpose:  Gets information about the specified task and places the
 * module name, window name and top-level HWND for the task in the specified
 * pointers
 *
 * NOTE: The two string pointers allocated in this routine are
 * the responsibility of the CALLER to de-allocate.
 *
 * Parameters:
 *    hWnd             HWND who called this function
 *    htask            HTASK which we want to find out more info about
 *    lplpszTaskName   Location that the module name is returned
 *    lplpszWindowName Location where the window name is returned
 *
 */

BOOL GetTaskInfo(HWND hWnd, HTASK htask, LPTSTR FAR* lplpszTaskName, LPTSTR FAR*lplpszWindowName, HWND FAR*lphWnd)
{
    BOOL        fRet = FALSE;
#if !defined( WIN32 )
    TASKENTRY   te;
#endif
    HWND        hwndNext;
    LPTSTR      lpszTN = NULL;
    LPTSTR      lpszWN = NULL;
    HWND        hwndFind = NULL;

    // Clear out return values in case of error
    *lplpszTaskName = NULL;
    *lplpszWindowName = NULL;

#if !defined( WIN32 )
    te.dwSize = sizeof(TASKENTRY);
    if (TaskFindHandle(&te, htask))
#endif
        {
        // Now, enumerate top-level windows in system
        hwndNext = GetWindow(hWnd, GW_HWNDFIRST);
        while (hwndNext)
            {
            // See if we can find a non-owned top level window whose
            // hInstance matches the one we just got passed.  If we find one,
            // we can be fairly certain that this is the top-level window for
            // the task which is blocked.
            //
            // REVIEW:  Will this filter hold true for InProcServer DLL-created
            // windows?
            //
            if ((hwndNext != hWnd) &&
#if !defined( WIN32 )
                (GetWindowWord(hwndNext, GWW_HINSTANCE) == (WORD)te.hInst) &&
#else
                ((HTASK) GetWindowThreadProcessId(hwndNext,NULL) == htask) &&
#endif
				(IsWindowVisible(hwndNext)) &&
                !GetWindow(hwndNext, GW_OWNER))
                {
                // We found our window!  Alloc space for new strings
                if ((lpszTN = OleStdMalloc(OLEUI_CCHPATHMAX_SIZE)) == NULL)
                    return TRUE;  // continue task window enumeration

                if ((lpszWN = OleStdMalloc(OLEUI_CCHPATHMAX_SIZE)) == NULL)
                    return TRUE;  // continue task window enumeration

                // We found the window we were looking for, copy info to
                // local vars
                GetWindowText(hwndNext, lpszWN, OLEUI_CCHPATHMAX);
#if !defined( WIN32 )
                 LSTRCPYN(lpszTN, te.szModule, OLEUI_CCHPATHMAX);
#else
                /* WIN32 NOTE: we are not able to get a module name
                **    given a thread process id on WIN32. the best we
                **    can do is use the window title as the module/app
                **    name.
                */
                 LSTRCPYN(lpszTN, lpszWN, OLEUI_CCHPATHMAX);
#endif
                hwndFind = hwndNext;

                fRet = TRUE;
                goto OKDone;
                }

            hwndNext = GetWindow(hwndNext, GW_HWNDNEXT);
            }
        }

OKDone:

    // OK,